<html><head></head><body>
<div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.2.1">Software Design Principles and Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Software development</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.4.1"> is fundamentally a </span><em class="italic"><span class="koboSpan" id="kobo.5.1">human-intensive discipline.</span></em><span class="koboSpan" id="kobo.6.1"> This means that it requires knowledge of both techniques and technology, but also comprehension of the problem and the ability to make decisions to implement a solution on multiple levels of abstraction. </span><span class="koboSpan" id="kobo.6.2">Programming has much to do with how a developer thinks. </span><span class="koboSpan" id="kobo.6.3">Over the years, and within each context and language, guidelines and solutions have emerged to solve recurring problems. </span><span class="koboSpan" id="kobo.6.4">Knowledge of these </span><em class="italic"><span class="koboSpan" id="kobo.7.1">patterns</span></em><span class="koboSpan" id="kobo.8.1"> will help you identify when to apply them and speed your development on a sure footing. </span><span class="koboSpan" id="kobo.8.2">On the other hand, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">principles</span></em><span class="koboSpan" id="kobo.10.1"> are guiding concepts that should be applied at every stage of the process and have more to do with how you approach </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will take a look at a non-exclusive and non-exhaustive list of principles and patterns that are common in Vue 3 </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">application development.</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.14.1">Principles</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.15.1">Patterns</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<ul>
<li><span class="koboSpan" id="kobo.16.1">Separation </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">of concerns</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Composition </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">over inheritance</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Single responsibility</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Encapsulatio</span></span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">n</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">KIC – keep </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">it clean</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">DRY – don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">repeat yourself</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">KISS – keep it </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">simple stupid</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Code for </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the next</span></span></li>
</ul>
</td>
<td class="No-Table-Style">
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Singleton</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Dependency injection</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Observer</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Command</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Proxy</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Decorator</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Façade</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Callbacks</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Promises</span></span></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.40.1">Table 2.1 </span><span xml:lang="en-GB"><span class="koboSpan" id="kobo.41.1">–</span></span><span class="koboSpan" id="kobo.42.1"> The principles and patterns covered in this chapter</span></p>
<p><span class="koboSpan" id="kobo.43.1">Understanding these principles and patterns will help you use the framework more efficiently and more often than not, it will prevent you from “reinventing the wheel”. </span><span class="koboSpan" id="kobo.43.2">Together with the first chapter, this will conclude the </span><em class="italic"><span class="koboSpan" id="kobo.44.1">foundational part </span></em><span class="koboSpan" id="kobo.45.1">of this book and will give you the basis to follow the practical parts and implementation of application examples in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">the book.</span></span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.47.1">What are the principles of software design?</span></h1>
<p><span class="koboSpan" id="kobo.48.1">In </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.49.1">software development, design principles are </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.50.1">high-level conceptual guidelines that should apply to the entire process. </span><span class="koboSpan" id="kobo.50.2">Not every project will use the same principles, and these are not mandatory rules to be enforced. </span><span class="koboSpan" id="kobo.50.3">They can appear in a project from the architecture down to the </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">user interface</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.53.1">UI</span></strong><span class="koboSpan" id="kobo.54.1">) and</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.55.1"> the last bit of code. </span><span class="koboSpan" id="kobo.55.2">In practice, some of these principles can also influence software attributes, such as maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">and re-usability.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.57.1">A non-exclusive list of design principles</span></h1>
<p><span class="koboSpan" id="kobo.58.1">Design</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.59.1"> principles vary somewhat depending on the context, domain, and even the team one may be part of at the time. </span><span class="koboSpan" id="kobo.59.2">The principles included in this chapter are, </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">therefore, non-exclusive.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.61.1">Separation of concerns</span></h2>
<p><span class="koboSpan" id="kobo.62.1">This</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.63.1"> is perhaps the most</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.64.1"> important principle in software engineering. </span><span class="koboSpan" id="kobo.64.2">Separation of concerns implies that a system must be divided into subsystems of elements grouped by their function or service (the </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">concern</span></strong><span class="koboSpan" id="kobo.66.1">). </span><span class="koboSpan" id="kobo.66.2">For example, we can consider the human body as a </span><em class="italic"><span class="koboSpan" id="kobo.67.1">system</span></em><span class="koboSpan" id="kobo.68.1"> composed of many subsystems (respiratory, circulatory, digestive, etc.). </span><span class="koboSpan" id="kobo.68.2">These, in turn, are integrated by different organs, which are made of tissues, and so forth, down to the smallest cell. </span><span class="koboSpan" id="kobo.68.3">Following the same idea in software, an application can be divided into elements grouped by concerns, from the large architecture all the way down to the last function. </span><span class="koboSpan" id="kobo.68.4">Without this breakdown of complexity into manageable parts, creating a functional system would be much harder, if </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">not impossible.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">In general, the</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.71.1"> application of this </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.72.1">principle starts with the big picture of what the system should be, looks into what it should do to accomplish that, and then breaks it down into manageable </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">working parts.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">As an example, here is a crude graphical representation of separation of concerns for a web application. </span><span class="koboSpan" id="kobo.74.2">Each box in this diagram identifies a different </span><em class="italic"><span class="koboSpan" id="kobo.75.1">concern</span></em><span class="koboSpan" id="kobo.76.1"> that, in turn, can be detailed into smaller functional parts. </span><span class="koboSpan" id="kobo.76.2">Even better, you can see how this principle allows you to identify the integrating parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">a system.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.78.1"><img alt="Figure 2.1 – A simple architectural view of a web application showing separation of concerns" src="image/Figure_2.01_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.79.1">Figure 2.1 – A simple architectural view of a web application showing separation of concerns</span></p>
<p><span class="koboSpan" id="kobo.80.1">If we were to drill down into any of these small boxes within their respective domains, we could still find more concerns to subdivide until we reach an indivisible atomic element (a component or function, for example). </span><span class="koboSpan" id="kobo.80.2">This principle has much to do with and benefits from other principles, such as abstraction and single responsibility. </span><span class="koboSpan" id="kobo.80.3">We will review them further down the line in this </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">same chapter.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.82.1">Composition over inheritance</span></h2>
<p><span class="koboSpan" id="kobo.83.1">The </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.84.1">principle of </span><em class="italic"><span class="koboSpan" id="kobo.85.1">composition over inheritance</span></em><span class="koboSpan" id="kobo.86.1"> comes</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.87.1"> directly</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.88.1"> from </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">Object-Oriented Programming</span></strong><span class="koboSpan" id="kobo.90.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.91.1">OOP</span></strong><span class="koboSpan" id="kobo.92.1">). </span><span class="koboSpan" id="kobo.92.2">It states that an object should attempt to use other objects’ functionality when needed, by referencing or instantiating them instead of creating a large and complex inheritance family tree of classes to add such functionality. </span><span class="koboSpan" id="kobo.92.3">Now, JavaScript is fundamentally a </span><em class="italic"><span class="koboSpan" id="kobo.93.1">functional </span></em><span class="koboSpan" id="kobo.94.1">language, even though it supports multiple paradigms, including features from OOP, so this principle applies as well. </span><span class="koboSpan" id="kobo.94.2">There is one note of warning for those migrating from OOP into JavaScript, and that is to avoid the temptation to treat JavaScript as a pure OOP language. </span><span class="koboSpan" id="kobo.94.3">Doing so could create unnecessary complexity instead of benefiting from the virtues of </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">the language.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">In Vue 3, there is no extension or inheritance of components. </span><span class="koboSpan" id="kobo.96.2">When we need shared or inherited functionality, we have a nice toolset of options to replace the inheritance paradigm. </span><span class="koboSpan" id="kobo.96.3">We will see later how we can comply with this principle by using </span><em class="italic"><span class="koboSpan" id="kobo.97.1">composable components</span></em><span class="koboSpan" id="kobo.98.1"> in </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.99.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.100.1">, </span><em class="italic"><span class="koboSpan" id="kobo.101.1">User Interface Composition </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.102.1">with Components.</span></em></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.103.1">Single responsibility principle</span></h2>
<p><span class="koboSpan" id="kobo.104.1">This</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.105.1"> principle can be found </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.106.1">in OOP as well as in functional programming. </span><span class="koboSpan" id="kobo.106.2">Simply put, it states that a class, method, function, or </span><em class="italic"><span class="koboSpan" id="kobo.107.1">component </span></em><span class="koboSpan" id="kobo.108.1">should deal with only one responsibility or functionality. </span><span class="koboSpan" id="kobo.108.2">If you have worked in other disciplines and languages, this comes naturally. </span><span class="koboSpan" id="kobo.108.3">Multipurpose functions are hard to maintain and tend to grow out of control, especially in a language such as JavaScript, which is loosely typed and highly dynamic. </span><span class="koboSpan" id="kobo.108.4">The same concept also applies directly to Vue 3 components. </span><span class="koboSpan" id="kobo.108.5">Each component should deal with one specific operation and avoid attempting to do too much by itself. </span><span class="koboSpan" id="kobo.108.6">In practice, when a component grows beyond a certain scope, it is best to split it into multiple components or extract the behavior into external modules. </span><span class="koboSpan" id="kobo.108.7">There are cases when you may end up with a many-thousand-lines-long component, but in my experience, this is rarely necessary and can and should be avoided. </span><span class="koboSpan" id="kobo.108.8">A warning, though, is that too much specificity could also lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">unnecessary complexity.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">As an example, let’s imagine a sign-in screen that also displays a sign-up option. </span><span class="koboSpan" id="kobo.110.2">This approach is common on many sites today. </span><span class="koboSpan" id="kobo.110.3">You could include all the functionalities inside just one component, but that would break this principle. </span><span class="koboSpan" id="kobo.110.4">A better alternative would be to split the components into at least three components for </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">this task:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.112.1">A parent component that handles the UI logic. </span><span class="koboSpan" id="kobo.112.2">This component decides when to show/hide the sign-in and </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">sign-up components.</span></span></li>
<li><span class="koboSpan" id="kobo.114.1">A child component that handles the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">sign-in function.</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">A child component that handles the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">sign-up function.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.118.1">Here is a</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.119.1"> graphical representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">this configuration:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.121.1"><img alt="Figure 2.2 – The composition of a sign-in/up interface using multiple components" src="image/Figure_2.02_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.122.1">Figure 2.2 – The composition of a sign-in/up interface using multiple components</span></p>
<p><span class="koboSpan" id="kobo.123.1">I think</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.124.1"> that you can quickly grasp the benefits of this principle. </span><span class="koboSpan" id="kobo.124.2">It makes the code easy to manage, maintain, and adapt since web applications have the tendency to mutate and evolve very, very quickly. </span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.125.1">Best practice tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.126.1">Give components a single responsibility and functionality. </span><span class="koboSpan" id="kobo.126.2">Avoid mammoth monolithic components as much </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">as possible.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.128.1">Encapsulation</span></h2>
<p><span class="koboSpan" id="kobo.129.1">Encapsulation is</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.130.1"> the notion that</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.131.1"> you</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.132.1"> should wrap data and methods to act as a single unit while exposing a well-defined </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">application programming interface</span></strong><span class="koboSpan" id="kobo.134.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.135.1">API</span></strong><span class="koboSpan" id="kobo.136.1">). </span><span class="koboSpan" id="kobo.136.2">Often</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.137.1">, this is done in the form of classes, modules, or libraries. </span><span class="koboSpan" id="kobo.137.2">JavaScript is not an exception, and it is highly recommended to follow this principle. </span><span class="koboSpan" id="kobo.137.3">In Vue 3, this concept applies to not only components but also CSS styles and HTML. </span><span class="koboSpan" id="kobo.137.4">The introduction of </span><em class="italic"><span class="koboSpan" id="kobo.138.1">single-file components</span></em><span class="koboSpan" id="kobo.139.1"> is a clear example of how the framework promotes this principle in action and how important it is for today’s development. </span><span class="koboSpan" id="kobo.139.2">With only a few edge-case situations, we should consider the (</span><strong class="bold"><span class="koboSpan" id="kobo.140.1">UI</span></strong><span class="koboSpan" id="kobo.141.1">) components as black boxes that receive incoming parameters and provide outgoing data. </span><span class="koboSpan" id="kobo.141.2">Other components should not be </span><em class="italic"><span class="koboSpan" id="kobo.142.1">aware</span></em><span class="koboSpan" id="kobo.143.1"> of their inner workings, only the API. </span><span class="koboSpan" id="kobo.143.2">As we build example applications throughout this book, you will see this principle </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">in action.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.145.1">KIC – keep it clean</span></h2>
<p><span class="koboSpan" id="kobo.146.1">This </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.147.1">principle refers mainly to the </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.148.1">way </span><em class="italic"><span class="koboSpan" id="kobo.149.1">you write</span></em><span class="koboSpan" id="kobo.150.1"> code. </span><span class="koboSpan" id="kobo.150.2">I should emphasize here that KIC applies directly to two categories that strongly affect web and Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">3 applications:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.152.1">How you format </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">your code</span></span></li>
<li><span class="koboSpan" id="kobo.154.1">How you tidy up events </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">and variables</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.156.1">The first item includes the use of code conventions, comments, and indentation to the organization of the code and logical grouping of functions. </span><span class="koboSpan" id="kobo.156.2">For example, if you have methods that deal </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.157.1">with </span><strong class="bold"><span class="koboSpan" id="kobo.158.1">create, read, update, and delete</span></strong><span class="koboSpan" id="kobo.159.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.160.1">CRUD</span></strong><span class="koboSpan" id="kobo.161.1">) operations, it would be best to place them near each other in the code, rather than spread around the source file. </span><span class="koboSpan" id="kobo.161.2">Many </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">integrated development environments</span></strong><span class="koboSpan" id="kobo.163.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.164.1">IDEs</span></strong><span class="koboSpan" id="kobo.165.1">) contain</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.166.1"> features to collapse or expand the inner code of functions. </span><span class="koboSpan" id="kobo.166.2">This helps to quickly review and locate sections in the code with </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">similar logic.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">The second part of this principle has to do with memory and reference handling. </span><span class="koboSpan" id="kobo.168.2">JavaScript has a very good garbage collector, the function of which is to discard unused data to reclaim memory. </span><span class="koboSpan" id="kobo.168.3">However, there are occasions when the algorithm is prevented from freeing up resources because a reference is still pending. </span><span class="koboSpan" id="kobo.168.4">If you have worked with other languages, such as C/C++, this issue may sound familiar as you need to manually reserve and release memory when not in use. </span><span class="koboSpan" id="kobo.168.5">In JavaScript, if you register a function to listen to an event, it is best to manually deregister it at the appropriate life cycle event of your component when no longer needed. </span><span class="koboSpan" id="kobo.168.6">This will prevent memory leaks and waste of memory and also prevent some security risks (which are out of the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">this book).</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">We will review the component’s life cycle in </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.171.1">Chapter 4</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.172.1">, User Interface Composition with Components,</span></em><span class="koboSpan" id="kobo.173.1"> but for now, take the following example as a good application of this principle and keep it as best practice. </span><span class="koboSpan" id="kobo.173.2">In this example, we will create a </span><em class="italic"><span class="koboSpan" id="kobo.174.1">composable </span></em><span class="koboSpan" id="kobo.175.1">component to detect when the </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.176.1">window size changes, so in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">script setup</span></strong><span class="koboSpan" id="kobo.178.1"> section we will find something </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">like this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.180.1">Registers a function on the window object’s resize event during the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">mounting state.</span></span></li>
<li><span class="koboSpan" id="kobo.182.1">Deregisters the event before the component </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">is unmounted.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.184.1">Here is the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">code fragment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
&lt;script setup&gt;
   import {onMounted, onBeforeUnmount} from "vue"
   onMounted(()=&gt;{
       window.</span><strong class="bold"><span class="koboSpan" id="kobo.187.1">addEventListener</span></strong><span class="koboSpan" id="kobo.188.1">("resize", myFunction)
   })
   onBeforeUnmount(()=&gt;{
       window.</span><strong class="bold"><span class="koboSpan" id="kobo.189.1">removeEventListener</span></strong><span class="koboSpan" id="kobo.190.1">("resize", myFunction)
   })
   function myFunction(){
       // Do something wit</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.191.1">h the event here
   }
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.192.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">onMounted</span></strong><span class="koboSpan" id="kobo.194.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">onBeforeUnmount</span></strong><span class="koboSpan" id="kobo.196.1"> functions are part of the Vue 3 framework and are triggered </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.197.1">by the appropriate component life cycle event. </span><span class="koboSpan" id="kobo.197.2">Here, we attach our function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">resize</span></strong><span class="koboSpan" id="kobo.199.1"> event when the component is mounted to </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.200.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">Document Object Model </span></strong><span class="koboSpan" id="kobo.202.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.203.1">DOM</span></strong><span class="koboSpan" id="kobo.204.1">), and we release it just before it is removed. </span><span class="koboSpan" id="kobo.204.2">The important concept to remember is to clean up after yourself and </span><em class="italic"><span class="koboSpan" id="kobo.205.1">keep </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.206.1">it clean</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.208.1">DRY – don’t repeat yourself</span></h2>
<p><span class="koboSpan" id="kobo.209.1">This</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.210.1"> principle is quite </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.211.1">famous, almost to the point of turning into a cliché. </span><span class="koboSpan" id="kobo.211.2">Sadly, it is easily forgotten. </span><span class="koboSpan" id="kobo.211.3">It is credited to Andrew Hunt and David Thomas, who used it in the book </span><em class="italic"><span class="koboSpan" id="kobo.212.1">The Pragmatic Programmer</span></em><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">It is mostly thought of as </span><em class="italic"><span class="koboSpan" id="kobo.214.1">don’t write the same thing twice</span></em><span class="koboSpan" id="kobo.215.1"> and is not far off, but it goes beyond that. </span><span class="koboSpan" id="kobo.215.2">It encompasses the notion of avoiding redundancy in the process as well as in the logic of the application. </span><span class="koboSpan" id="kobo.215.3">The core idea is that each process that executes business logic should exist in only one place in your </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">entire application.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">For example, most web applications have some asynchronous connection with a server through the use of an API. </span><span class="koboSpan" id="kobo.217.2">There may also be multiple elements in the application that will use or need to use this remote computer/server communication. </span><span class="koboSpan" id="kobo.217.3">If you were going to code the entire code/logic to communicate with the server in each component, we would end up with not only duplication of code but also application logic. </span><span class="koboSpan" id="kobo.217.4">Maintaining such a system would open up the door to an amazing number of negative side effects and security concerns, poor user experience, and much more. </span><span class="koboSpan" id="kobo.217.5">According to this principle, a better approach is to abstract all communication code related to the server API into a single module, or class. </span><span class="koboSpan" id="kobo.217.6">In practice, in JavaScript this can even be delegated to a web worker in a separate thread. </span><span class="koboSpan" id="kobo.217.7">We will explore this implementation later in </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.218.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.219.1">,</span><em class="italic"><span class="koboSpan" id="kobo.220.1"> Multithreading with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.221.1">Web Workers</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">As a rule of thumb, if you see yourself writing kind-of-the-same-code” in different components or classes, it is a clear opportunity to abstract the functionality into its own module </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">or component.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.225.1">KISS – keep it simple and short</span></h2>
<p><span class="koboSpan" id="kobo.226.1">This </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.227.1">principle is not</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.228.1"> exclusive to the </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.229.1">software design realm. </span><span class="koboSpan" id="kobo.229.2">It was coined by the US Navy back in the ’60s (according to Wikipedia, </span><a href="https://en.wikipedia.org/wiki/KISS_principle"><span class="koboSpan" id="kobo.230.1">https://en.wikipedia.org/wiki/KISS_principle</span></a><span class="koboSpan" id="kobo.231.1">). </span><span class="koboSpan" id="kobo.231.2">The idea is pure common sense: it is better to build simple, small functional parts that work together than attempt to create a big and complex program in one go. </span><span class="koboSpan" id="kobo.231.3">Also, algorithms should be implemented in the most simple and efficient way. </span><span class="koboSpan" id="kobo.231.4">In web development, this principle is essential. </span><span class="koboSpan" id="kobo.231.5">Modern web applications are composed of hundreds of working parts spread over multiple </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.232.1">computers, servers, and environments. </span><span class="koboSpan" id="kobo.232.2">The more complex a system or code implementation is, the harder it is also to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">and adapt.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">There is a </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.235.1">warning, though. </span><span class="koboSpan" id="kobo.235.2">Keeping things simple does not mean over-simplification or unnecessary segregation. </span><span class="koboSpan" id="kobo.235.3">Too many small parts can introduce unnecessary complexity in the system. </span><span class="koboSpan" id="kobo.235.4">Applying the KISS principle means staying in that sweet middle point where things are manageable and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">to understand.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.237.1">Code for the next</span></h2>
<p><span class="koboSpan" id="kobo.238.1">This </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.239.1">principle is the idea that you should make your code readable and easy to understand for someone else besides you. </span><span class="koboSpan" id="kobo.239.2">Naming conventions, logic flow, and inter-line comments are all part of this. </span><span class="koboSpan" id="kobo.239.3">Not only for the case when you may need to delegate your code to another but also when you come back in a year or two to the same code. </span><span class="koboSpan" id="kobo.239.4">The last thing you want to do is to waste time thinking about what the past inexperienced you did with that clever line of spaghetti code Smart developers code as if they were going to teach somebody else, simply and elegantly. </span><span class="koboSpan" id="kobo.239.5">Especially if you are using or contributing to open-source code, this principle is vital for group collaboration. </span><span class="koboSpan" id="kobo.239.6">In this case, it is worth mentioning the </span><em class="italic"><span class="koboSpan" id="kobo.240.1">Boy Scout Principle,</span></em><span class="koboSpan" id="kobo.241.1"> which is similar but applies in groups. </span><span class="koboSpan" id="kobo.241.2">It states that when you find a hard-to-read or “spaghetti” code, you refactor it to make </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">it clean.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.243.1">Best practice tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.244.1">Keep your code clean with on-source comments and documentation explaining your logic, as if teaching somebody else. </span><span class="koboSpan" id="kobo.244.2">More often than not, you will be </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">teaching yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">Design principles apply to many different scenarios, some beyond the practice of software development. </span><span class="koboSpan" id="kobo.246.2">It is important to consider them until they become second nature. </span><span class="koboSpan" id="kobo.246.3">In general, the application of these and other principles, together with the application of design patterns, make an important mark on your </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">professional development.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.248.1">What is a software design pattern?</span></h1>
<p><span class="koboSpan" id="kobo.249.1">In </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.250.1">software </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.251.1">development, it is common for certain processes and tasks to appear in multiple projects, in one way or another, or with some degree of variation. </span><span class="koboSpan" id="kobo.251.2">A </span><em class="italic"><span class="koboSpan" id="kobo.252.1">design pattern</span></em><span class="koboSpan" id="kobo.253.1"> is a proven solution for such similar problems. </span><span class="koboSpan" id="kobo.253.2">It does not prescribe code but acts like a reasoning template, an approach that has been abstracted independent of the implementation to be reused and adapted to particular circumstances. </span><span class="koboSpan" id="kobo.253.3">In practice, there is plenty of room for creativity to apply a pattern. </span><span class="koboSpan" id="kobo.253.4">Entire books have been dedicated to this subject and provide more detail than the scope of this book allows. </span><span class="koboSpan" id="kobo.253.5">In the following pages, we will take a look at what I consider to be the most recurrent patterns to keep in mind for Vue 3 applications. </span><span class="koboSpan" id="kobo.253.6">Even though we see them in isolation for the purposes of studying them, the reality is that often the implementation overlaps, mixes, and encapsulates multiple patterns in a single piece of code. </span><span class="koboSpan" id="kobo.253.7">For example, you can use a </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">singleton </span></strong><span class="koboSpan" id="kobo.255.1">to act as a </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">decorator </span></strong><span class="koboSpan" id="kobo.257.1">and a </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">proxy </span></strong><span class="koboSpan" id="kobo.259.1">to simplify or alter the communication between services in your application (we will do this quite often, actually, and the full code can be seen in </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.260.1">Chapter 8</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.261.1">, Multithreading with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.262.1">Web Workers</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Design patterns can also be understood as software engineering and development </span><em class="italic"><span class="koboSpan" id="kobo.265.1">best practices</span></em><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">And the opposite of that, </span><em class="italic"><span class="koboSpan" id="kobo.267.1">bad practice</span></em><span class="koboSpan" id="kobo.268.1">, is often referred to as an </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">anti-pattern</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">Anti-patterns</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.271.1"> are “solutions” that, even though they fix an issue in the short term, create problems and bad consequences along the line. </span><span class="koboSpan" id="kobo.271.2">They generate the need to work around the problem and destabilize the whole structure </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">and implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Let’s now view a list of patterns that should be part of your toolbox for Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">3 projects.</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.275.1">A quick reference list of patterns</span></h1>
<p><span class="koboSpan" id="kobo.276.1">Patterns are classified according to the type of function or problem they solve. </span><span class="koboSpan" id="kobo.276.2">There are plenty of patterns according to the context, language, and architecture of a system. </span><span class="koboSpan" id="kobo.276.3">Here is a non-exclusive list of patterns that we will use throughout this book and that, in my experience, are more likely to appear in </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Vue applications:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.278.1">Creational patterns</span></strong><span class="koboSpan" id="kobo.279.1">: These </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.280.1">deal with</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.281.1"> the approach to creating classes, objects, and </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">data structures:</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.283.1">Singleton pattern</span></span></li><li><span class="koboSpan" id="kobo.284.1">Dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">injection pattern</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.286.1">Factory pattern</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.287.1">Behavioral patterns</span></strong><span class="koboSpan" id="kobo.288.1">: These</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.289.1"> deal with</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.290.1"> communication between objects, components, and other elements of </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the application:</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.292.1">Observer pattern</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.293.1">Command pattern</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">Structural patterns</span></strong><span class="koboSpan" id="kobo.295.1">: These </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.296.1">provide templates</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.297.1"> that affect the design of your application and the relationship </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">between components:</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.299.1">Proxy pattern</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.300.1">Decorator pattern</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.301.1">Façade pattern</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.302.1">Asynchronous patterns</span></strong><span class="koboSpan" id="kobo.303.1">: These </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.304.1">deal </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.305.1">with data and process flow with asynchronous requests and events in single-threaded applications (heavily used in </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">web applications):</span></span><ul><li><span class="No-Break"><span class="koboSpan" id="kobo.307.1">Callbacks pattern</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.308.1">Promises pattern</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.309.1">Not by any means this list of patterns is exclusive. </span><span class="koboSpan" id="kobo.309.2">There are many more patterns and classifications, and a full library is dedicated to this subject. </span><span class="koboSpan" id="kobo.309.3">It is worth mentioning that the description and application for some of these may differ from one literature to another and there is some overlapping depending on the context </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">and implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">With that introduction to design patterns, let’s look at them in detail </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">with examples.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.313.1">The singleton pattern</span></h2>
<p><span class="koboSpan" id="kobo.314.1">This</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.315.1"> is a very common pattern in JavaScript and perhaps </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.316.1">one of, if not the most important. </span><span class="koboSpan" id="kobo.316.2">The basic concept defines that one object’s instance must only exist once in the entire application, and all references and function calls are done through this object. </span><span class="koboSpan" id="kobo.316.3">A singleton can act as a gateway to resources, libraries, </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">and data.</span></span></p>
<h3><span class="koboSpan" id="kobo.318.1">When to use it</span></h3>
<p><span class="koboSpan" id="kobo.319.1">Here is a </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.320.1">short rule of thumb to know when to apply </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">this pattern:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.322.1">When you need to make sure a resource is accessed through only one gateway, for example, the global </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">application state</span></span></li>
<li><span class="koboSpan" id="kobo.324.1">When you need to encapsulate or simplify behavior or communications (used in conjunction with other patterns). </span><span class="koboSpan" id="kobo.324.2">For example, the API </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">access object.</span></span></li>
<li><span class="koboSpan" id="kobo.326.1">When the </span><em class="italic"><span class="koboSpan" id="kobo.327.1">cost </span></em><span class="koboSpan" id="kobo.328.1">of multiple instantiations is detrimental. </span><span class="koboSpan" id="kobo.328.2">For example, the creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">web workers.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.330.1">Implementations</span></h3>
<p><span class="koboSpan" id="kobo.331.1">There</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.332.1"> are many ways that you can apply this pattern in JavaScript. </span><span class="koboSpan" id="kobo.332.2">In some cases, the implementation from other languages is migrated to JavaScript, often following Java examples with the use of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">getInstance()</span></strong><span class="koboSpan" id="kobo.334.1"> method to obtain the singleton. </span><span class="koboSpan" id="kobo.334.2">However, there are better ways to implement this pattern in JavaScript. </span><span class="koboSpan" id="kobo.334.3">Let’s see </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">them next.</span></span></p>
<h4><span class="koboSpan" id="kobo.336.1">Method 1</span></h4>
<p><span class="koboSpan" id="kobo.337.1">The simplest way is through a </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.338.1">module that exports a plain object literal or a </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.340.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.341.1">JSON</span></strong><span class="koboSpan" id="kobo.342.1">), which is a </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">static object:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.344.1">./chapter 2/singleton-json.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
const my_singleton={
    // Implementation code here...
</span><span class="koboSpan" id="kobo.345.2">}
export default my_singleton;</span></pre>
<p><span class="koboSpan" id="kobo.346.1">You then </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.347.1">can import this module into other modules and still always have the same object. </span><span class="koboSpan" id="kobo.347.2">This works because bundlers and browsers are smart enough to avoid the repetition of imports, so once this object has been brought in the first time, it will ignore the next requests. </span><span class="koboSpan" id="kobo.347.3">When not using a bundler, the ES6 implementation of JavaScript also defines that modules </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">are singletons.</span></span></p>
<h4><span class="koboSpan" id="kobo.349.1">Method 2</span></h4>
<p><span class="koboSpan" id="kobo.350.1">This method creates a class and then, on the first instantiation, saves the reference for </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">future calls.</span></span><span class="koboSpan" id="kobo.352.1">
In order for this to work, we use a variable (traditionally called </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">_instance</span></strong><span class="koboSpan" id="kobo.354.1">) from the class and save the reference to the instance in the constructor. </span><span class="koboSpan" id="kobo.354.2">In the following calls, we check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">_instance</span></strong><span class="koboSpan" id="kobo.356.1"> value exists, and if so, return it. </span><span class="koboSpan" id="kobo.356.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">./chapter 2/singleton-class.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
class myClass{
    constructor(){
        if(</span><strong class="bold"><span class="koboSpan" id="kobo.360.1">myClass._instance</span></strong><span class="koboSpan" id="kobo.361.1">){
            </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">return myClass._instance;</span></strong><span class="koboSpan" id="kobo.363.1">
        }else{
            </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">myClass._instance=this;</span></strong><span class="koboSpan" id="kobo.365.1">
        }
        return this;
    }
}
export default new myClass()</span></pre>
<p><span class="koboSpan" id="kobo.366.1">This second method may be more familiar to other language developers. </span><span class="koboSpan" id="kobo.366.2">Notice how we are also exporting a new instance of the class and not the class directly. </span><span class="koboSpan" id="kobo.366.3">This way, the invoker </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.367.1">will not have to remember to instantiate the class every time, and the code will be the same as in </span><em class="italic"><span class="koboSpan" id="kobo.368.1">method 1</span></em><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">This use case is something that needs to be coordinated with your team to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">different implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">The invoker then can call methods from each one directly (assuming the singleton has a function/method </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">myFunction()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">):</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.375.1">./chapter 2/singleton-invoker.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
import my_method1_singleton from "./singleton-json";
import my_method2_singleton from "./singleton-class";
console.log("Look mom, no instantiation in both cases!")
my_method1_singleton.myFunction()
my_method2_singleton.myFunction()</span></pre>
<p><span class="koboSpan" id="kobo.377.1">The singleton pattern is extremely useful, though it rarely exists </span><em class="italic"><span class="koboSpan" id="kobo.378.1">in isolation</span></em><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">Often, we use singletons to wrap the implementation of other patterns and make sure we have a single point of access. </span><span class="koboSpan" id="kobo.379.3">In our examples, we will use this pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">quite often.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.381.1">The dependency injection pattern</span></h2>
<p><span class="koboSpan" id="kobo.382.1">This </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.383.1">pattern simply states that the</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.384.1"> dependencies for a class or function are provided as inputs, for example, as parameters, properties, or other types of implementations. </span><span class="koboSpan" id="kobo.384.2">This simple statement opens a very wide range of possibilities. </span><span class="koboSpan" id="kobo.384.3">Let’s take, for example, a class that works with the browser’s </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">IndexedDB API</span></strong><span class="koboSpan" id="kobo.386.1"> through</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.387.1"> an abstraction class. </span><span class="koboSpan" id="kobo.387.2">We will learn more about the IndexedDB API in </span><a href="B18602_07.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.388.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.389.1">, </span><em class="italic"><span class="koboSpan" id="kobo.390.1">Data Flow Management</span></em><span class="koboSpan" id="kobo.391.1">, but for now, just concentrate on the dependency part. </span><span class="koboSpan" id="kobo.391.2">Consider that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">dbManager.js</span></strong><span class="koboSpan" id="kobo.393.1"> file exposes an object that handles the operations with the database, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">projects</span></strong><span class="koboSpan" id="kobo.395.1"> object deals with CRUD operations for the projects table (or collection). </span><span class="koboSpan" id="kobo.395.2">Without using dependency injection, you will have something </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.397.1">./chapter 2/dependency-injection-1.js</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.398.1">import dbManager from "dbManager"</span></strong><span class="koboSpan" id="kobo.399.1">
const projects={
    getAllProjects(){
        return </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">dbManager.</span></strong><span class="koboSpan" id="kobo.401.1">getAll("projects")
    }
}
export default projects;</span></pre>
<p><span class="koboSpan" id="kobo.402.1">The</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.403.1"> preceding code shows a “normal” approach, where we import the dependencies at the beginning of the file and then use </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.404.1">them in our code. </span><span class="koboSpan" id="kobo.404.2">Now, let’s tweak this same code to use </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">dependency injection:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.406.1">./chapter 2/dependency-injection-2.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
const projects={
    getAllProjects(</span><strong class="bold"><span class="koboSpan" id="kobo.408.1">dbManager</span></strong><span class="koboSpan" id="kobo.409.1">){
        return </span><strong class="bold"><span class="koboSpan" id="kobo.410.1">dbManager</span></strong><span class="koboSpan" id="kobo.411.1">.getAll("projects")
    }
}
export default projects;</span></pre>
<p><span class="koboSpan" id="kobo.412.1">As you can see, the main difference is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">dbManager</span></strong><span class="koboSpan" id="kobo.414.1"> is now passed as a parameter to the function. </span><span class="koboSpan" id="kobo.414.2">This is what </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.415.1">is called </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">injection</span></strong><span class="koboSpan" id="kobo.417.1">. </span><span class="koboSpan" id="kobo.417.2">This opens up many ways to manage dependencies and, at the same time, pushes the hardcoding of dependencies up the implementation tree. </span><span class="koboSpan" id="kobo.417.3">This makes this class highly reusable, at least for as long as the dependency respects the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">expected API.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">The preceding example is not the only way to inject a dependency. </span><span class="koboSpan" id="kobo.419.2">We could, for example, assign it to a property for the object’s internal use. </span><span class="koboSpan" id="kobo.419.3">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">projects.js</span></strong><span class="koboSpan" id="kobo.421.1"> file was implemented using the property approach instead, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.423.1">./chapter 2/dependency-injection-3.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
const projects={
    </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">dbManager,</span></strong><span class="koboSpan" id="kobo.426.1">
    getAllProjects(){
        return </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">this.dbManager</span></strong><span class="koboSpan" id="kobo.428.1">.getAll("projects")
    }
}
export default projects;</span></pre>
<p><span class="koboSpan" id="kobo.429.1">In this </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.430.1">case, the invoker of the object (a singleton, by the way) needs to be aware of the property and assign it before calling on any </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.431.1">of its functions. </span><span class="koboSpan" id="kobo.431.2">Here is an example of how that </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">would look:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.433.1">./chapter 2/dependency-injection-4.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
import projects from "projects.js"
import dbManager from "dbManager.js"
</span><strong class="bold"><span class="koboSpan" id="kobo.435.1">projects.dbManager=dbManager;</span></strong><span class="koboSpan" id="kobo.436.1">
projects.getAllProjects();</span></pre>
<p><span class="koboSpan" id="kobo.437.1">But this approach is not recommended. </span><span class="koboSpan" id="kobo.437.2">You can clearly see that it breaks the principle of encapsulation, as we are directly assigning a property for the object. </span><span class="koboSpan" id="kobo.437.3">It also doesn’t feel like clean code even though it is </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">valid code.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Passing the dependencies one function at a time is also not recommended. </span><span class="koboSpan" id="kobo.439.2">So, what is a better approach? </span><span class="koboSpan" id="kobo.439.3">It depends on </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the implementation:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.441.1">In a class, it is convenient to require the dependencies in the constructor (and if not found, throw </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">an error)</span></span></li>
<li><span class="koboSpan" id="kobo.443.1">In a plain JSON object, it is convenient to provide a function to set the dependency explicitly and let the object decide how to use </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">it internally</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.445.1">This last approach is also recommended for passing a dependency after the instantiation of an object when the dependency is not ready at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">of implementation</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">Here is a </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.448.1">code example for the first point mentioned in the </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">preceding list:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.450.1">./chapter 2/dependency-injection-5.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
class Projects {
    constructor(</span><strong class="bold"><span class="koboSpan" id="kobo.452.1">dbManager</span></strong><span class="koboSpan" id="kobo.453.1">=null){
        if(</span><strong class="bold"><span class="koboSpan" id="kobo.454.1">!dbManager</span></strong><span class="koboSpan" id="kobo.455.1">){
            </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">throw "Dependency missing"</span></strong><span class="koboSpan" id="kobo.457.1">
        }else{
            </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">this.dbManager=dbManager;</span></strong><span class="koboSpan" id="kobo.459.1">
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.460.1">In the</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.461.1"> constructor, we declare the expected parameter with a default value. </span><span class="koboSpan" id="kobo.461.2">If the dependency is not provided, we throw an error. </span><span class="koboSpan" id="kobo.461.3">Otherwise, we assign it to an internal private attribute for the use of the instance. </span><span class="koboSpan" id="kobo.461.4">In this case, the invoker should look </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
// Projects are a class
import Projects from "projects.js"
import </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">dbManager </span></strong><span class="koboSpan" id="kobo.465.1">from "dbManager.js"
try{
    const projects=</span><strong class="bold"><span class="koboSpan" id="kobo.466.1">new Projects(dbManager)</span></strong><span class="koboSpan" id="kobo.467.1">;
}catch{
    // Error handler here
}</span></pre>
<p><span class="koboSpan" id="kobo.468.1">In an alternative implementation, we could have a function that basically does the same by receiving the dependency and assigning it to a </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">private attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
import projects from "projects.js"
import </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">dbManager </span></strong><span class="koboSpan" id="kobo.472.1">from "dbManager.js"
projects.setDBManager</span><strong class="bold"><span class="koboSpan" id="kobo.473.1">(dbManager)</span></strong><span class="koboSpan" id="kobo.474.1">;</span></pre>
<p><span class="koboSpan" id="kobo.475.1">This approach is better than directly assigning the internal attribute, but you still need to remember to do the assignment before using any of the methods in </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">the object.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.477.1">Best practice note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.478.1">Whatever approach you use for dependency injection, remain constant throughout your </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.480.1">You </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.481.1">may have noticed that we have mainly been focusing on objects. </span><span class="koboSpan" id="kobo.481.2">As you may have already guessed, passing a dependency to a function is just the same as passing another parameter, so it does not deserve </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">special attention.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">This example has just moved the dependency implementation responsibility up to another class in the hierarchy. </span><span class="koboSpan" id="kobo.483.2">But what if we implement a singleton pattern to handle all or most of the dependencies in our application? </span><span class="koboSpan" id="kobo.483.3">This way, we could just delegate the loading of the dependencies to one class or object at a determined point in our application life cycle. </span><span class="koboSpan" id="kobo.483.4">But how do we implement such a thing? </span><span class="koboSpan" id="kobo.483.5">We will need </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.485.1">A method to register </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the dependency</span></span></li>
<li><span class="koboSpan" id="kobo.487.1">A method to retrieve the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">by name</span></span></li>
<li><span class="koboSpan" id="kobo.489.1">A structure to keep the reference to </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">each dependency</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.491.1">Let’s put that </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.492.1">into action and create a very </span><em class="italic"><span class="koboSpan" id="kobo.493.1">naive</span></em><span class="koboSpan" id="kobo.494.1"> implementation of such a singleton. </span><span class="koboSpan" id="kobo.494.2">Please keep in mind that this is an academic exercise, so we are not considering error </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">checking, de-registration,</span></span><span class="koboSpan" id="kobo.496.1">
or </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">other considerations:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.498.1">./chapter 2/dependency-injection-6.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
const dependencyService={                          //1
    </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">dependencies</span></strong><span class="koboSpan" id="kobo.501.1">:{},                               //2
    </span><strong class="bold"><span class="koboSpan" id="kobo.502.1">provide</span></strong><span class="koboSpan" id="kobo.503.1">(name, dependency){                     //3
        </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">this.dependencies[name]=dependency</span></strong><span class="koboSpan" id="kobo.505.1">         //4
        return this;                               //5
    },
    </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">inject</span></strong><span class="koboSpan" id="kobo.507.1">(name){                                  //6
        </span><strong class="bold"><span class="koboSpan" id="kobo.508.1">return this.dependencies[name]</span></strong><span class="koboSpan" id="kobo.509.1">??null;      //7
    }
}
export default dependencyService;</span></pre>
<p><span class="koboSpan" id="kobo.510.1">With </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.511.1">this bare minimum implementation, let’s look at each line by the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">line comment:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.513.1">We create a simple JavaScript object literal as </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">a singleton.</span></span></li>
<li><span class="koboSpan" id="kobo.515.1">We declare an empty object to use as a dictionary to hold our dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">by name.</span></span></li>
<li><span class="koboSpan" id="kobo.517.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">provide</span></strong><span class="koboSpan" id="kobo.519.1"> function lets us register a dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">by name.</span></span></li>
<li><span class="koboSpan" id="kobo.521.1">Here, we just use the name as the field name and assign the dependency passed by argument (notice we are not checking pre-existing </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">names, etc.).</span></span></li>
<li><span class="koboSpan" id="kobo.523.1">Here, we return the source object, mainly for convenience so we can chain </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">the invocation.</span></span></li>
<li><span class="koboSpan" id="kobo.525.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">inject</span></strong><span class="koboSpan" id="kobo.527.1"> function will take the name as registered in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">provide </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">function.</span></span></li>
<li><span class="koboSpan" id="kobo.530.1">We return the dependency or </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">null </span></strong><span class="koboSpan" id="kobo.532.1">if </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">not found.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.534.1">With that </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.535.1">singleton on board, we can now use it across our application to distribute the dependencies as needed. </span><span class="koboSpan" id="kobo.535.2">For that, we need a parent object to import them and populate the service. </span><span class="koboSpan" id="kobo.535.3">Here is an example of how that </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">might look:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.537.1">./chapter 2/dependency-injection-7.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
import dependencyService from "./dependency-injection-6"
import myDependency1 from "myFile1"
import myDependency2 from "myFile2"
</span><strong class="bold"><span class="koboSpan" id="kobo.539.1">import dbManager from "dbManager"</span></strong><span class="koboSpan" id="kobo.540.1">
dependencyService
    .provide("dependency1", myDependency1)
    .provide("dependency2", myDependency2)
    .</span><strong class="bold"><span class="koboSpan" id="kobo.541.1">provide("dbManager", dbManager)</span></strong></pre>
<p><span class="koboSpan" id="kobo.542.1">As</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.543.1"> you can see, this module has hard-coded dependencies, and its work is to load them into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">dependencyService</span></strong><span class="koboSpan" id="kobo.545.1"> object. </span><span class="koboSpan" id="kobo.545.2">Then, the dependent function or object needs only to import the service and retrieve the dependency it needs by the registration name </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
import dependencyService from "./dependency-injection-6"
const </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">dbManager</span></strong><span class="koboSpan" id="kobo.549.1">=dependencyService</span><strong class="bold"><span class="koboSpan" id="kobo.550.1">.inject("dbManager")</span></strong></pre>
<p><span class="koboSpan" id="kobo.551.1">This approach does create a tight coupling between components but is here as a reference. </span><span class="koboSpan" id="kobo.551.2">It has the advantage that we can control all the dependencies in a single location so that the maintenance benefits could be significant. </span><span class="koboSpan" id="kobo.551.3">The choice of names for the methods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">dependencyService</span></strong><span class="koboSpan" id="kobo.553.1"> object was not random either: these are the same used by Vue 3 inside the component’s hierarchy. </span><span class="koboSpan" id="kobo.553.2">This is very useful for implementing some User Interface design patterns. </span><span class="koboSpan" id="kobo.553.3">We will see this in more detail in </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.554.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.555.1">, </span><em class="italic"><span class="koboSpan" id="kobo.556.1">User Interface Composition with Components</span></em><span class="koboSpan" id="kobo.557.1"> and </span><a href="B18602_07.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.558.1">C</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.559.1">hapter 7</span></em></span></a><span class="koboSpan" id="kobo.560.1">, </span><em class="italic"><span class="koboSpan" id="kobo.561.1">Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.562.1">Flow Management</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">As you can see, this </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.565.1">pattern is very important and is implemented in Vue 3 with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">provide</span></strong><span class="koboSpan" id="kobo.567.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">inject</span></strong><span class="koboSpan" id="kobo.569.1"> functions. </span><span class="koboSpan" id="kobo.569.2">It's a great addition to our toolset, but there is more still. </span><span class="koboSpan" id="kobo.569.3">Let’s move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">next one.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.571.1">The factory pattern</span></h2>
<p><span class="koboSpan" id="kobo.572.1">The </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.573.1">factory pattern provides us with a way to create objects</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.574.1"> without creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">direct dependency.</span></span><span class="koboSpan" id="kobo.576.1">
It works through a function that, based on the input, will return an instantiated object. </span><span class="koboSpan" id="kobo.576.2">The use of such an implementation will be made through a common or standard interface. </span><span class="koboSpan" id="kobo.576.3">For example, consider two classes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">Circle</span></strong><span class="koboSpan" id="kobo.578.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">Square</span></strong><span class="koboSpan" id="kobo.580.1">. </span><span class="koboSpan" id="kobo.580.2">Both implement the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">draw()</span></strong><span class="koboSpan" id="kobo.582.1"> method, which draws the figure to a canvas. </span><span class="koboSpan" id="kobo.582.2">Then, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">factory</span></strong><span class="koboSpan" id="kobo.584.1"> function would work something </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.586.1">
function createShape(type){
    switch(type){
        case "circle": return new Circle();
        case "square": return new Square();
}}
let
    shape1=createShape("circle"),
    shape2=createShape("square");
shape1.draw();
shape2.draw();</span></pre>
<p><span class="koboSpan" id="kobo.587.1">This method is quite popular, especially in conjunction with other patterns, as we will see multiple times in </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">this book.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.589.1">The observer pattern</span></h2>
<p><span class="koboSpan" id="kobo.590.1">The </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.591.1">observer pattern</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.592.1"> is very useful and one of the basis of a reactive framework. </span><span class="koboSpan" id="kobo.592.2">It defines a relationship between objects where one is being observed (the </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">subject</span></strong><span class="koboSpan" id="kobo.594.1">) for changes or events, and other(s) are notified of such changes (the </span><strong class="bold"><span class="koboSpan" id="kobo.595.1">observers</span></strong><span class="koboSpan" id="kobo.596.1">). </span><span class="koboSpan" id="kobo.596.2">The observers are also called </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">listeners</span></strong><span class="koboSpan" id="kobo.598.1">. </span><span class="koboSpan" id="kobo.598.2">Here</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.599.1"> is a </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">graphical representation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.601.1"><img alt="Figure 2.3 – The subject emits an event and notifies the observers" src="image/Figure_2.03_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.602.1">Figure 2.3 – The subject emits an event and notifies the observers</span></p>
<p><span class="koboSpan" id="kobo.603.1">As you can see, the subject emits an event to notify the observers. </span><span class="koboSpan" id="kobo.603.2">It is for the subject to define what events and parameters it will </span><strong class="bold"><span class="koboSpan" id="kobo.604.1">publish</span></strong><span class="koboSpan" id="kobo.605.1">. </span><span class="koboSpan" id="kobo.605.2">Meanwhile, the observers </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">subscribe</span></strong><span class="koboSpan" id="kobo.607.1"> to each event by registering a function with the publisher. </span><span class="koboSpan" id="kobo.607.2">This implementation is why this pattern is often referred to as </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.608.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.609.1">pub/sub</span></strong><span class="koboSpan" id="kobo.610.1"> pattern, and it can have </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">several variations.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">When looking into the implementation of this pattern, it is important to notice the cardinality of the publication: </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">1</span></strong><span class="koboSpan" id="kobo.614.1"> event to </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">0..N</span></strong><span class="koboSpan" id="kobo.616.1"> observers (functions). </span><span class="koboSpan" id="kobo.616.2">This means that the subject must implement, on top of its main purpose, the functionality to publish events and keep track of the subscribers. </span><span class="koboSpan" id="kobo.616.3">Since this would break a principle or two in the design (separation of concerns, single responsibility, etc.), it is common to extract this functionality into a middle object. </span><span class="koboSpan" id="kobo.616.4">The previous design then changes to add a </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">middle layer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.618.1"><img alt="Figure 2.4 – An observer implementation with a dispatcher middle object" src="image/Figure_2.04_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Figure 2.4 – An observer implementation with a dispatcher middle object</span></p>
<p><span class="koboSpan" id="kobo.620.1">This middle</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.621.1"> object, sometimes referred to as an “</span><strong class="bold"><span class="koboSpan" id="kobo.622.1">event dispatcher</span></strong><span class="koboSpan" id="kobo.623.1"> encapsulates the basic functionality to register observers, receive events from the subject, and </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.624.1">dispatch them to the observers. </span><span class="koboSpan" id="kobo.624.2">It also does some clean-up activities when an observer is no longer observing Let’s put these concepts into a simple and naive implementation of an event dispatcher in </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">plain JavaScript:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.626.1">./chapter 2/Observer-1.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
class </span><strong class="bold"><span class="koboSpan" id="kobo.628.1">ObserverPattern</span></strong><span class="koboSpan" id="kobo.629.1">{
constructor(){
</span><strong class="bold"><span class="koboSpan" id="kobo.630.1">    this.events={}</span></strong><span class="koboSpan" id="kobo.631.1">                                             </span><strong class="bold"><span class="koboSpan" id="kobo.632.1">//1</span></strong><span class="koboSpan" id="kobo.633.1">
}
</span><strong class="bold"><span class="koboSpan" id="kobo.634.1">on</span></strong><span class="koboSpan" id="kobo.635.1">(event_name, fn=()=&gt;{}){                                     </span><strong class="bold"><span class="koboSpan" id="kobo.636.1">//2</span></strong><span class="koboSpan" id="kobo.637.1">
    if(!this.events[event_name]){
</span><strong class="bold"><span class="koboSpan" id="kobo.638.1">       this.events[event_name]=[]</span></strong><span class="koboSpan" id="kobo.639.1">
    }
</span><strong class="bold"><span class="koboSpan" id="kobo.640.1">    this.events[event_name].push(fn)</span></strong><span class="koboSpan" id="kobo.641.1">                           </span><strong class="bold"><span class="koboSpan" id="kobo.642.1">//3</span></strong><span class="koboSpan" id="kobo.643.1">
}
</span><strong class="bold"><span class="koboSpan" id="kobo.644.1">emit</span></strong><span class="koboSpan" id="kobo.645.1">(event_name, data){                                        </span><strong class="bold"><span class="koboSpan" id="kobo.646.1">//4</span></strong><span class="koboSpan" id="kobo.647.1">
    if(!this.events[event_name]){
       return
    }
for(let i=0, l=this.events[event_name].length; i&lt;l; i++){
</span><strong class="bold"><span class="koboSpan" id="kobo.648.1">    this.events[event_name][i](data)</span></strong><span class="koboSpan" id="kobo.649.1">
}
}
</span><strong class="bold"><span class="koboSpan" id="kobo.650.1">off</span></strong><span class="koboSpan" id="kobo.651.1">(event_name, fn){                                           </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">//5</span></strong><span class="koboSpan" id="kobo.653.1">
    let i=this.events[event_name].indexOf(fn);
    if(i&gt;-1){
</span><strong class="bold"><span class="koboSpan" id="kobo.654.1">        this.events[event_name].splice(i, 1);</span></strong><span class="koboSpan" id="kobo.655.1">
    }
}
}</span></pre>
<p><span class="koboSpan" id="kobo.656.1">The </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.657.1">preceding implementation is, again, naive. </span><span class="koboSpan" id="kobo.657.2">It doesn’t contain the </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.658.1">necessary error and edge case handling that you would use in production, but it does have the bare basics for an event dispatcher. </span><span class="koboSpan" id="kobo.658.2">Let’s look into it line </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">by line:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.660.1">In the constructor, we declare an object to use internally as a dictionary for </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">our events.</span></span></li>
<li><span class="koboSpan" id="kobo.662.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">on</span></strong><span class="koboSpan" id="kobo.664.1"> method allows the observers to register their functions. </span><span class="koboSpan" id="kobo.664.2">In this line, if the event is not initialized, we create an </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">empty array.</span></span></li>
<li><span class="koboSpan" id="kobo.666.1">In this line, we just push the function to the array (as I said, this is a naive implementation, as we don’t check for duplicates, </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">for example).</span></span></li>
<li><span class="koboSpan" id="kobo.668.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">emit</span></strong><span class="koboSpan" id="kobo.670.1"> method allows the subject to publish an event by its name and pass some data to it. </span><span class="koboSpan" id="kobo.670.2">Here, we run over the array and execute each function passing the data we received as </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">a parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.672.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">off</span></strong><span class="koboSpan" id="kobo.674.1"> method is necessary to deregister the function once it is not used (see the </span><em class="italic"><span class="koboSpan" id="kobo.675.1">keep it clean </span></em><span class="koboSpan" id="kobo.676.1"> principle, earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">this chapter).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.678.1">In order </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.679.1">for this implementation to work, every observer and the subject </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.680.1">need to reference the same implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">ObserverClass</span></strong><span class="koboSpan" id="kobo.682.1">. </span><span class="koboSpan" id="kobo.682.2">The easiest way to secure this is to implement it through a </span><em class="italic"><span class="koboSpan" id="kobo.683.1">singleton pattern</span></em><span class="koboSpan" id="kobo.684.1">. </span><span class="koboSpan" id="kobo.684.2">Once imported, each observer registers with the dispatcher with </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">this line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.686.1">
import dispatcher from "ObserverClass.js"    //a singleton
</span><strong class="bold"><span class="koboSpan" id="kobo.687.1">dispatcher.on("event_name", myFunction)</span></strong></pre>
<p><span class="koboSpan" id="kobo.688.1">Then, the subject emits the event and passes the data with the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">following lines:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
import dispatcher from "ObserverClass.js"    //a singleton
</span><strong class="bold"><span class="koboSpan" id="kobo.691.1">dispatcher.emit("event_name", data)</span></strong></pre>
<p><span class="koboSpan" id="kobo.692.1">Finally, when the observer no longer needs to watch the subject, it needs to clean up the reference with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">off</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.694.1"> method:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.695.1">dispatcher.off("event_name", myFunction)</span></strong></pre>
<p><span class="koboSpan" id="kobo.696.1">There are a good number of edge cases and controls that we have not covered here, and rather than reinventing the wheel, I suggest using a ready-made solution for these cases. </span><span class="koboSpan" id="kobo.696.2">In our book, we will use </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.697.1">one named </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">mitt</span></strong><span class="koboSpan" id="kobo.699.1"> (</span><a href="https://www.npmjs.com/package/mitt"><span class="koboSpan" id="kobo.700.1">https://www.npmjs.com/package/mitt</span></a><span class="koboSpan" id="kobo.701.1">). </span><span class="koboSpan" id="kobo.701.2">That has the same methods as in our example. </span><span class="koboSpan" id="kobo.701.3">We will see how to install packaged dependencies in </span><a href="B18602_03.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.702.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.703.1">, </span><em class="italic"><span class="koboSpan" id="kobo.704.1">Setting up a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.705.1">Working Project</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.707.1">The command pattern</span></h2>
<p><span class="koboSpan" id="kobo.708.1">This </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.709.1">pattern is very useful and easy to understand </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.710.1">and implement. </span><span class="koboSpan" id="kobo.710.2">Instead of executing a function right away, the basic concept is to create an object or structure with the information necessary for the execution. </span><span class="koboSpan" id="kobo.710.3">This data package (the </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">command</span></strong><span class="koboSpan" id="kobo.712.1">) is then delegated to another object that will perform the execution according to some logic to handle it. </span><span class="koboSpan" id="kobo.712.2">For example, the commands can be serialized and queued, scheduled, reversed, grouped together, and</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.713.1"> transformed. </span><span class="koboSpan" id="kobo.713.2">Here is a graphical representation of this pattern with the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">necessary parts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.715.1"><img alt="Figure 2.5 – A graphical implementation of the command pattern" src="image/Figure_2.05_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.716.1">Figure 2.5 – A graphical implementation of the command pattern</span></p>
<p><span class="koboSpan" id="kobo.717.1">The </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.718.1">diagram shows how the clients submit their commands to the </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">Invoker</span></strong><span class="koboSpan" id="kobo.720.1">. </span><span class="koboSpan" id="kobo.720.2">The</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.721.1"> invoker usually implements some sort of queue or task array to handle the commands and then routes the execution to the proper </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">Receiver</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">If there</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.724.1"> is any data to return, it also returns it to the proper client. </span><span class="koboSpan" id="kobo.724.2">It is also common that the invoker attaches additional data to the command to keep track of clients and receives, especially in the case of asynchronous executions. </span><span class="koboSpan" id="kobo.724.3">It also provides a single point of “entry” to the receivers and decouples the “clients” </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">from them.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">Let’s again work on a naive implementation of an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Invoker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.728.1"> class:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.729.1">./chapter 2/Command-1.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.730.1">
class CommandInvoker{
    </span><strong class="bold"><span class="koboSpan" id="kobo.731.1">addCommand</span></strong><span class="koboSpan" id="kobo.732.1">(command_data){                          </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">//1</span></strong><span class="koboSpan" id="kobo.734.1">
        // .. </span><span class="koboSpan" id="kobo.734.2">queue implementation here
    }
    </span><strong class="bold"><span class="koboSpan" id="kobo.735.1">runCommand(command_data)</span></strong><span class="koboSpan" id="kobo.736.1">{                          </span><strong class="bold"><span class="koboSpan" id="kobo.737.1">//2</span></strong><span class="koboSpan" id="kobo.738.1">
        switch(</span><strong class="bold"><span class="koboSpan" id="kobo.739.1">command_data.action)</span></strong><span class="koboSpan" id="kobo.740.1">{                   </span><strong class="bold"><span class="koboSpan" id="kobo.741.1">//3</span></strong><span class="koboSpan" id="kobo.742.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.743.1">        case "eat"</span></strong><span class="koboSpan" id="kobo.744.1">:
                // .. </span><span class="koboSpan" id="kobo.744.2">invoke the receiver here
                break;
            </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">case "code":</span></strong><span class="koboSpan" id="kobo.746.1">
                // .. </span><span class="koboSpan" id="kobo.746.2">invoke the receiver here
                break;
            </span><strong class="bold"><span class="koboSpan" id="kobo.747.1">case "repeat":</span></strong><span class="koboSpan" id="kobo.748.1">
                // .. </span><span class="koboSpan" id="kobo.748.2">invoke the receiver here
                break;
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.749.1">In the </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.750.1">preceding code, we have implemented a </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.751.1">bare-bones example of what an </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">Invoker</span></strong><span class="koboSpan" id="kobo.753.1"> should have line </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">by line:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.755.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">Invoker </span></strong><span class="koboSpan" id="kobo.757.1">exposes a method to add commands to the object. </span><span class="koboSpan" id="kobo.757.2">This is only necessary when the commands will be somehow queued, serialized, or processed according to </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">some logic.</span></span></li>
<li><span class="koboSpan" id="kobo.759.1">This line executes the command according to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">action</span></strong><span class="koboSpan" id="kobo.761.1"> field contained in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">command_data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.763.1"> parameter.</span></span></li>
<li><span class="koboSpan" id="kobo.764.1">Based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">action</span></strong><span class="koboSpan" id="kobo.766.1"> field, the </span><em class="italic"><span class="koboSpan" id="kobo.767.1">invoker</span></em><span class="koboSpan" id="kobo.768.1"> routes the execution to the </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">proper receiver.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.770.1">There are many ways to implement the logic for routing the execution. </span><span class="koboSpan" id="kobo.770.2">It is important to notice that this pattern can be implemented on a larger scale depending on the context. </span><span class="koboSpan" id="kobo.770.3">For example, the invoker might not even be in the web client application and be on the server or on a different machine. </span><span class="koboSpan" id="kobo.770.4">We will see an implementation of this pattern in </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.771.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.772.1">, </span><em class="italic"><span class="koboSpan" id="kobo.773.1">Multithreading with Web Workers</span></em><span class="koboSpan" id="kobo.774.1">, where we use this pattern to process tasks between different threads and unload the main thread (where Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">3 runs).</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.776.1">The proxy pattern</span></h2>
<p><span class="koboSpan" id="kobo.777.1">The </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.778.1">definition for this pattern comes directly from its</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.779.1"> name, as the word “proxy” means something or someone who acts on behalf of another as if it was the same. </span><span class="koboSpan" id="kobo.779.2">That is a mouthful, but it will make you remember it. </span><span class="koboSpan" id="kobo.779.3">Let’s look into an example to clarify how this works. </span><span class="koboSpan" id="kobo.779.4">We will need at least three entities (components, </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">objects, etc.):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.781.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">client</span></strong><span class="koboSpan" id="kobo.783.1"> entity that </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.784.1">needs to access the API of a </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">target entity</span></span></li>
<li><span class="koboSpan" id="kobo.786.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">target</span></strong><span class="koboSpan" id="kobo.788.1"> entity </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.789.1">that exposes a </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">well-known API</span></span></li>
<li><span class="koboSpan" id="kobo.791.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.792.1">proxy</span></strong><span class="koboSpan" id="kobo.793.1"> object </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.794.1">that sits in between and exposes the same API as the target while at the same time intercepting every communication from the client and relaying it to </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">the target</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.796.1">We can graphically represent the relationship between these entities in </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">this way:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.798.1"><img alt="Figure 2.6 – The proxy object exposes the same API as the target" src="image/Figure_2.06_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.799.1">Figure 2.6 – The proxy object exposes the same API as the target</span></p>
<p><span class="koboSpan" id="kobo.800.1">The key factor for this pattern is that the proxy behaves and exposes the same API as the target, in such a way that the client does not know or doesn’t need to know that it is dealing with a proxy and not the target object directly. </span><span class="koboSpan" id="kobo.800.2">So, why would we want to do such a thing? </span><span class="koboSpan" id="kobo.800.3">There are many good reasons, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.802.1">You need to maintain the original unmodified API, but at the </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">same time:</span></span><ul><li><span class="koboSpan" id="kobo.804.1">Need to process the inputs or outputs for </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">the client</span></span></li><li><span class="koboSpan" id="kobo.806.1">Need to intercept each API call to add internal functionality, such as maintenance operations, performance improvements, error checking, </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">and validation</span></span></li><li><span class="koboSpan" id="kobo.808.1">The target is an expensive resource, so a proxy could implement logic to leverage their operations (for example, </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">a cache)</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.810.1">You need to change the client or the target but can’t modify </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">the API</span></span></li>
<li><span class="koboSpan" id="kobo.812.1">You need to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">backward compatibility</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.814.1">There</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.815.1"> are more reasons that you may come across, but</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.816.1"> I hope that by now you can see how this can be useful. </span><span class="koboSpan" id="kobo.816.2">Being a pattern, this template can be implemented on multiple levels, from a simple object proxy to a full application or server. </span><span class="koboSpan" id="kobo.816.3">It is quite common when performing partial upgrades of a system or application. </span><span class="koboSpan" id="kobo.816.4">On a lower level, JavaScript even natively includes a constructor for proxying objects that Vue 3 uses internally to </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">create reactivity.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">In </span><a href="B18602_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.819.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.820.1">, </span><em class="italic"><span class="koboSpan" id="kobo.821.1">The Vue 3 Framework</span></em><span class="koboSpan" id="kobo.822.1">, we reviewed the options for reactivity with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">ref()</span></strong><span class="koboSpan" id="kobo.824.1"> but this new version of Vue also includes another alternative for complex structures, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">reactive()</span></strong><span class="koboSpan" id="kobo.826.1">. </span><span class="koboSpan" id="kobo.826.2">The first one uses pub/sub methods (the observer pattern!), but the latter uses native proxy handlers (this pattern!). </span><span class="koboSpan" id="kobo.826.3">Let’s look into an example of how this native implementation may work with a naive </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">partial implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.828.1">In this simple example, we will make an object with reactive properties automatically convert Celsius degrees to and back from Fahrenheit using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Proxy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.830.1"> object:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.831.1">./chapter 2/proxy-1.js</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.832.1">
let temperature={celsius:0,fahrenheit: 32},                    </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">//1</span></strong><span class="koboSpan" id="kobo.834.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">handler</span></strong><span class="koboSpan" id="kobo.836.1">={                                                  </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">//2</span></strong><span class="koboSpan" id="kobo.838.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">set(target, key, value)</span></strong><span class="koboSpan" id="kobo.840.1">{                                 </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">//3</span></strong><span class="koboSpan" id="kobo.842.1">
         </span><strong class="bold"><span class="koboSpan" id="kobo.843.1">target[key]=value;</span></strong><span class="koboSpan" id="kobo.844.1">                                    </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">//4</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.846.1">    switch(key){</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.847.1">     case "celsius":</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.848.1">           target.fahrenheit=calculateFahrenheit(value);</span></strong><span class="koboSpan" id="kobo.849.1">       </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">//5</span></strong><span class="koboSpan" id="kobo.851.1">
           break;
    case "</span><strong class="bold"><span class="koboSpan" id="kobo.852.1">fahrenheit</span></strong><span class="koboSpan" id="kobo.853.1">":
           </span><strong class="bold"><span class="koboSpan" id="kobo.854.1">target.celsius=calculateCelsius(value);</span></strong><span class="koboSpan" id="kobo.855.1">
         }
      },
      get(target, key){
         return </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">target[key]</span></strong><span class="koboSpan" id="kobo.857.1">;                                   </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">//6</span></strong><span class="koboSpan" id="kobo.859.1">
      }
    },
    </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">degrees=new Proxy(temperature, handler)</span></strong><span class="koboSpan" id="kobo.861.1">                    </span><strong class="bold"><span class="koboSpan" id="kobo.862.1">//7</span></strong><span class="koboSpan" id="kobo.863.1">
// Auxiliar functions
function </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">calculateCelsius</span></strong><span class="koboSpan" id="kobo.865.1">(fahrenheit){
    return (fahrenheit - 32) / 1.8
}
function </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">calculateFahrenheit</span></strong><span class="koboSpan" id="kobo.867.1">(celsius){
    return (celsius * 1.8) + 32
}
</span><strong class="bold"><span class="koboSpan" id="kobo.868.1">degrees.celsius=25</span></strong><span class="koboSpan" id="kobo.869.1">                                             </span><strong class="bold"><span class="koboSpan" id="kobo.870.1">//8</span></strong><span class="koboSpan" id="kobo.871.1">
console.log(</span><strong class="bold"><span class="koboSpan" id="kobo.872.1">degrees</span></strong><span class="koboSpan" id="kobo.873.1">)
// Prints in the console:
</span><strong class="bold"><span class="koboSpan" id="kobo.874.1">// {celsius:25, fahrenheit:77}</span></strong><span class="koboSpan" id="kobo.875.1">                                 </span><strong class="bold"><span class="koboSpan" id="kobo.876.1">//9</span></strong></pre>
<p><span class="koboSpan" id="kobo.877.1">Let’s</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.878.1"> review the code line by line to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">this </span></span><span class="No-Break"><a id="_idIndexMarker178"/></span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">works:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.881.1">In this line, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">temperature</span></strong><span class="koboSpan" id="kobo.883.1"> object, which is going to be our target to be proxied. </span><span class="koboSpan" id="kobo.883.2">We initialize its two properties with an equal </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">converted value.</span></span></li>
<li><span class="koboSpan" id="kobo.885.1">We declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">handler</span></strong><span class="koboSpan" id="kobo.887.1"> object, which will be our proxy for the </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">temperature object.</span></span></li>
<li><span class="koboSpan" id="kobo.889.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">set</span></strong><span class="koboSpan" id="kobo.891.1"> function in the proxy handler receives three arguments: the target object, the key referred to, and the value attempted to be assigned. </span><span class="koboSpan" id="kobo.891.2">Notice that I say “attempted”, as the operation has been intercepted by </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">the proxy.</span></span></li>
<li><span class="koboSpan" id="kobo.893.1">On this line, we </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.894.1">perform the assignment as intended to the object property. </span><span class="koboSpan" id="kobo.894.2">Here, we could have done other transformations or logic, such as validation or raised an event (the observer </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">pattern again!).</span></span></li>
<li><span class="koboSpan" id="kobo.896.1">Notice</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.897.1"> how we use a switch to filter the property names that we are interested in. </span><span class="koboSpan" id="kobo.897.2">When the key is </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">celsius</span></strong><span class="koboSpan" id="kobo.899.1">, we calculate and assign the value in Fahrenheit. </span><span class="koboSpan" id="kobo.899.2">The opposite happens when we receive an assignment for </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">fahrenheit</span></strong><span class="koboSpan" id="kobo.901.1"> degrees. </span><span class="koboSpan" id="kobo.901.2">This is where the </span><strong class="bold"><span class="koboSpan" id="kobo.902.1">reactivity</span></strong><span class="koboSpan" id="kobo.903.1"> comes </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">into play.</span></span></li>
<li><span class="koboSpan" id="kobo.905.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">get</span></strong><span class="koboSpan" id="kobo.907.1"> function, at least in this example, we just specifically return the value requested. </span><span class="koboSpan" id="kobo.907.2">In the way this is implemented, it would be the same as if we skip the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">getter</span></strong><span class="koboSpan" id="kobo.909.1"> function. </span><span class="koboSpan" id="kobo.909.2">However, it is here as an example that we could operate and transform the value to be returned as this operation is </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">also intercepted.</span></span></li>
<li><span class="koboSpan" id="kobo.911.1">Finally, in line 7, we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">degrees</span></strong><span class="koboSpan" id="kobo.913.1"> object as the proxy for </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">temperature</span></strong><span class="koboSpan" id="kobo.915.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">the handler.</span></span></li>
<li><span class="koboSpan" id="kobo.917.1">On this line, we test the reactivity by assigning a value in </span><em class="italic"><span class="koboSpan" id="kobo.918.1">Celsius </span></em><span class="koboSpan" id="kobo.919.1">to the member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">degrees</span></strong><span class="koboSpan" id="kobo.921.1"> object, just like we normally would to any </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">other object.</span></span></li>
<li><span class="koboSpan" id="kobo.923.1">When we print the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">degrees</span></strong><span class="koboSpan" id="kobo.925.1"> object to the console, we notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">fahrenheit</span></strong><span class="koboSpan" id="kobo.927.1"> property has been </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">automatically updated.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.929.1">This is a rather limited and simple example of how the native </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">Proxy()</span></strong><span class="koboSpan" id="kobo.931.1"> constructor works and applies the pattern. </span><span class="koboSpan" id="kobo.931.2">Vue 3 has a more complex approach to reactivity and tracking dependencies, using the proxy and observer patterns. </span><span class="koboSpan" id="kobo.931.3">However, this gives us a good idea of what approach is happening behind the scenes when we see the HTML updated live in front of our </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">very eyes.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">The concept of proxying between a client and a target is also related to the next two patterns: the </span><em class="italic"><span class="koboSpan" id="kobo.934.1">decorator and the façade patterns</span></em><span class="koboSpan" id="kobo.935.1"> since they are also a sort of proxy implementation. </span><span class="koboSpan" id="kobo.935.2">The distinguishing key factor is that the proxy retains the same API as the original </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">target object.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.937.1">The decorator pattern</span></h2>
<p><span class="koboSpan" id="kobo.938.1">This </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.939.1">pattern </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.940.1">may, at first sight, seem very similar to the </span><em class="italic"><span class="koboSpan" id="kobo.941.1">proxy pattern</span></em><span class="koboSpan" id="kobo.942.1">, and indeed it is, but it adds a few distinctive features that set it apart. </span><span class="koboSpan" id="kobo.942.2">It does have the same moving parts as the proxy, meaning there is a </span><strong class="bold"><span class="koboSpan" id="kobo.943.1">Client</span></strong><span class="koboSpan" id="kobo.944.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">Target</span></strong><span class="koboSpan" id="kobo.946.1">, and a </span><strong class="bold"><span class="koboSpan" id="kobo.947.1">Decorator</span></strong><span class="koboSpan" id="kobo.948.1"> in between that implements the same interface as the target (yes, just like in the proxy pattern). </span><span class="koboSpan" id="kobo.948.2">However, while in the </span><em class="italic"><span class="koboSpan" id="kobo.949.1">Proxy pattern</span></em><span class="koboSpan" id="kobo.950.1"> the intercepted API calls mainly deal with the data and internal maintenance (“housekeeping”), the decorator augments the functionality of the original object to do more. </span><span class="koboSpan" id="kobo.950.2">This is the defining factor that </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">separates them.</span></span></p>
<p><span class="koboSpan" id="kobo.952.1">In the proxy example, notice how the additional functionality was an </span><em class="italic"><span class="koboSpan" id="kobo.953.1">internal reactivity </span></em><span class="koboSpan" id="kobo.954.1">to keep the degrees in each scale synchronized. </span><span class="koboSpan" id="kobo.954.2">When you change one, it internally and automatically updates the other. </span><span class="koboSpan" id="kobo.954.3">In a decorator pattern, the proxy object performs additional operations before, during, or after executing the API call to the target object. </span><span class="koboSpan" id="kobo.954.4">Just like in the proxy pattern, all of this is transparent for the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">client object.</span></span></p>
<p><span class="koboSpan" id="kobo.956.1">For example, building on the previous code, imagine that now we want to log each call to the API of a certain target while keeping the same functionality. </span><span class="koboSpan" id="kobo.956.2">Graphically, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.958.1"><img alt="Figure 2.7 – An example of a decorator that augments the target with a logging feature" src="image/Figure_2.07_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.959.1">Figure 2.7 – An example of a decorator that augments the target with a logging feature</span></p>
<p><span class="koboSpan" id="kobo.960.1">Here, what was first a simple proxy, now by the mere act of performing a humble logging call, has now become a decorator. </span><span class="koboSpan" id="kobo.960.2">In the code, we only need to add this line before the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">set()</span></strong><span class="koboSpan" id="kobo.962.1"> method (assuming there is also a function </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">getTimeStamp()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.966.1">
console.log(getTimeStamp());</span></pre>
<p><span class="koboSpan" id="kobo.967.1">Of course, this </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.968.1">is a simple example just to make a point. </span><span class="koboSpan" id="kobo.968.2">In the real world, decorators</span><strong class="bold"> </strong><span class="koboSpan" id="kobo.969.1">are very useful for adding functionality to your application without having to rewrite the logic or significant portions of your code. </span><span class="koboSpan" id="kobo.969.2">On top of this, decorators can be </span><em class="italic"><span class="koboSpan" id="kobo.970.1">stackable</span></em><span class="koboSpan" id="kobo.971.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.972.1">chainable</span></em><span class="koboSpan" id="kobo.973.1">, meaning that you can create “decorators for decorators” if needed, so each one will represent one step of added functionality that would maintain the same API of the target object. </span><span class="koboSpan" id="kobo.973.2">And just like that, we are beginning to step into the boundaries</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.974.1"> of a </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">middleware pattern</span></strong><span class="koboSpan" id="kobo.976.1">, but we will </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.977.1">not cover it in this book. </span><span class="koboSpan" id="kobo.977.2">Anyway, the idea behind that other pattern is to create layers of middleware functions with a specified API, each one that performs one action, but with the difference that any step can decide to abort the operation, so the target may or may not be called. </span><span class="koboSpan" id="kobo.977.3">But that is another story... </span><span class="koboSpan" id="kobo.977.4">let’s get back </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">to decorators.</span></span></p>
<p><span class="koboSpan" id="kobo.979.1">Previously in this book, we mentioned that Vue 3 components do not have inheritance like plain JavaScript classes implemented by extending from one another. </span><span class="koboSpan" id="kobo.979.2">Instead, we can use the decorator pattern on components to add functionality or change the visual appearance. </span><span class="koboSpan" id="kobo.979.3">Let’s look at a brief example now, as we will see components and UI design in detail in </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.980.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.981.1">, </span><em class="italic"><span class="koboSpan" id="kobo.982.1">User Interface Composition </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.983.1">with Components</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.985.1">Consider that we have the simplest of components that displays a humble </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">h1</span></strong><span class="koboSpan" id="kobo.987.1"> tag with a title that receives the following </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">as input:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.989.1">./chapter 2/decorator-1.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.990.1">
&lt;script setup&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.991.1">    const $props=defineP</span><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.992.1">rops(['label'])</span></strong><span class="koboSpan" id="kobo.993.1">          //1
&lt;/script&gt;
&lt;template&gt;
    &lt;h1&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.994.1">{{$props.label}}</span></strong><span class="koboSpan" id="kobo.995.1">&lt;/h1&gt;                    //2
&lt;/template&gt;
&lt;style scoped&gt;&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.996.1">In this simple component, we declare a single input named </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">label</span></strong><span class="koboSpan" id="kobo.998.1"> in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">//1</span></strong><span class="koboSpan" id="kobo.1000.1">. </span><span class="koboSpan" id="kobo.1000.2">Don’t worry about the syntax for now, as we will see this in detail in </span><a href="B18602_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1001.1">Chapte</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1002.1">r 4</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.1003.1">,</span></em> <em class="italic"><span class="koboSpan" id="kobo.1004.1">User Interface Composition with Components. </span></em><span class="koboSpan" id="kobo.1005.1">On line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">//2</span></strong><span class="koboSpan" id="kobo.1007.1">, we are interpolating the value plainly inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">h1</span></strong><span class="koboSpan" id="kobo.1009.1"> tags just </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.1011.1">So, to create a </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.1012.1">decorator for this component we need to apply the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">simple rules:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1014.1">It has to act on behalf of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">component (object)</span></span></li>
<li><span class="koboSpan" id="kobo.1016.1">It has to respect the same API (inputs, outputs, function </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">calls, etc.)</span></span></li>
<li><span class="koboSpan" id="kobo.1018.1">It has to augment the functionality or visual representation before, after, or during the execution of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">target API</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1020.1">With </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.1021.1">that in mind, we can create a decorator component that intercepts the label attribute, changes it a bit, and also modifies the visual appearance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">target component:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1023.1">./chapter 2/decorator-2.vue</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1024.1">
&lt;script setup&gt;
    import HeaderH1 from "./decorator-1.vue"
</span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">    const $props=defineProps(['label'])</span></strong><span class="koboSpan" id="kobo.1026.1">                //1
&lt;/script&gt;
&lt;template&gt;
    &lt;div </span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">style="color: purple !important;"</span></strong><span class="koboSpan" id="kobo.1028.1">&gt;            //2
        &lt;HeaderH1 :title=</span><strong class="bold"><span class="koboSpan" id="kobo.1029.1">"$props.label+'!!!'"</span></strong><span class="koboSpan" id="kobo.1030.1">&gt;         //3
        &lt;/HeaderH1&gt;
    &lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1031.1">In this code, in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">//1</span></strong><span class="koboSpan" id="kobo.1033.1">, you can see that we keep the same interface as the target component (that we imported in the previous line), and then in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">//2</span></strong><span class="koboSpan" id="kobo.1035.1">, we modify (augment) the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">color </span></strong><span class="koboSpan" id="kobo.1037.1">attribute and in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">//3</span></strong><span class="koboSpan" id="kobo.1039.1"> we are also modifying the data passed to the target component by adding three exclamation marks. </span><span class="koboSpan" id="kobo.1039.2">With those simple tasks, we have kept the conditions to build a decorator pattern extrapolated to Vue 3 components. </span><span class="koboSpan" id="kobo.1039.3">Not bad </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.1041.1">Decorators are very useful, but there is still one more proxy-like pattern that is also very common and handy: the </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">façade pattern.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.1043.1">The façade pattern</span></h2>
<p><span class="koboSpan" id="kobo.1044.1">By now, you </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.1045.1">may have seen the progressive pattern in</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.1046.1"> these, well, patterns. </span><span class="koboSpan" id="kobo.1046.2">We started with a proxy to act on behalf of another object or entity, we augmented it with the use of decorators while keeping the same API, and now is the turn for the façade pattern. </span><span class="koboSpan" id="kobo.1046.3">Its job is, in addition to the functions of a proxy and decorator, to simplify the API and hide the large complexity behind it. </span><span class="koboSpan" id="kobo.1046.4">So, a façade sits between a client and a target, but now the target is highly complex, being an object or even a system or multiple subsystems. </span><span class="koboSpan" id="kobo.1046.5">This pattern is also used to change the API of an object or to limit the exposure to the client. </span><span class="koboSpan" id="kobo.1046.6">We can picture the interactions </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.1048.1"><img alt="Figure 2.8 – A façade object simplifying the interaction with a complex API or system" src="image/Figure_2.08_B18602.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1049.1">Figure 2.8 – A façade object simplifying the interaction with a complex API or system</span></p>
<p><span class="koboSpan" id="kobo.1050.1">As you can see, the main purpose of the façade is to offer a simpler approach to a complex interaction or API. </span><span class="koboSpan" id="kobo.1050.2">We will use this pattern many times during our examples to simplify native implementations in the browser with more developer-friendly approaches. </span><span class="koboSpan" id="kobo.1050.3">We will use libraries to encapsulate the use of IndexedDB and create our own simplified communication with web workers in </span><a href="B18602_08.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1051.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1052.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1053.1">Multithreading with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1054.1">Web Workers</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1056.1">Needless to say, you will have seen this pattern in action before, as it is one of the foundational concepts of modern technology. </span><em class="italic"><span class="koboSpan" id="kobo.1057.1">Hiding complexity</span></em><span class="koboSpan" id="kobo.1058.1"> behind a simple interface (API) is all around us and is a big part of web development. </span><span class="koboSpan" id="kobo.1058.2">After all, the entire internet is extremely complicated, with thousands of moving parts, and the technology that makes up web pages is close to magic. </span><span class="koboSpan" id="kobo.1058.3">Without this pattern, we would still be programming with zeros </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">and ones.</span></span></p>
<p><span class="koboSpan" id="kobo.1060.1">In practice, you will add layers of simplification to your own applications to break down complexity. </span><span class="koboSpan" id="kobo.1060.2">One way to do it is to use third-party libraries that provide a simplified interface. </span><span class="koboSpan" id="kobo.1060.3">In the following chapters, we will use some of these, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1062.1">Axios</span></strong><span class="koboSpan" id="kobo.1063.1">: To </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.1064.1">handle </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.1065.1">all </span><strong class="bold"><span class="koboSpan" id="kobo.1066.1">Asynchronous JavaScript and XML</span></strong><span class="koboSpan" id="kobo.1067.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1068.1">AJAX</span></strong><span class="koboSpan" id="kobo.1069.1">) communications with </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">the server</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1071.1">DexieDB</span></strong><span class="koboSpan" id="kobo.1072.1">: To</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.1073.1"> handle the API to IndexedDB (the browser’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">local database)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1075.1">Mitt</span></strong><span class="koboSpan" id="kobo.1076.1">: To </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.1077.1">create event pipelines (we mentioned this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">Observer pattern)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1079.1">Vue 3</span></strong><span class="koboSpan" id="kobo.1080.1">: To </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.1081.1">create </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">amazing UIs</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1083.1">In general, there </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.1084.1">are façade libraries for most of the native</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.1085.1"> implementations of web technologies, which are well battle tested. </span><span class="koboSpan" id="kobo.1085.2">Developers are very good at simplifying these and sharing the code with others, thanks to the open source movement. </span><span class="koboSpan" id="kobo.1085.3">Still, when using other people’s modules, make sure they are “safe.” </span><span class="koboSpan" id="kobo.1085.4">Don’t reinvent the wheel, and don’t repeat yourself But now, it is time to move on to the next pattern in </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">our list.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.1087.1">The callback pattern</span></h2>
<p><span class="koboSpan" id="kobo.1088.1">The</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.1089.1"> callback pattern is easy to understand. </span><span class="koboSpan" id="kobo.1089.2">It applies when an </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.1090.1">operation needs to be executed after a </span><strong class="bold"><span class="koboSpan" id="kobo.1091.1">synchronous</span></strong><span class="koboSpan" id="kobo.1092.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.1093.1">asynchronous</span></strong><span class="koboSpan" id="kobo.1094.1"> operation has finished. </span><span class="koboSpan" id="kobo.1094.2">For this, the function invocation includes, as one of the parameters, a function to be executed when the operations are completed. </span><span class="koboSpan" id="kobo.1094.3">Having said that, we need to distinguish between the following two types of </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">code flow:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1096.1">Synchronous operations are executed one after another in sequential order. </span><span class="koboSpan" id="kobo.1096.2">It is the basic code flow, top </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">to bottom.</span></span></li>
<li><span class="koboSpan" id="kobo.1098.1">Asynchronous operations are executed out of the normal flow once invoked. </span><span class="koboSpan" id="kobo.1098.2">Their length is uncertain, as well as their success </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">or failure.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1100.1">It is for asynchronous cases that the </span><em class="italic"><span class="koboSpan" id="kobo.1101.1">callback pattern</span></em><span class="koboSpan" id="kobo.1102.1"> is especially useful. </span><span class="koboSpan" id="kobo.1102.2">Think, for example, of a network call. </span><span class="koboSpan" id="kobo.1102.3">Once invoked, we don’t know how long it will take to get an answer from the server and whether it will succeed, fail, or throw an error. </span><span class="koboSpan" id="kobo.1102.4">If we didn’t have asynchronous operations, our application would be </span><em class="italic"><span class="koboSpan" id="kobo.1103.1">frozen</span></em><span class="koboSpan" id="kobo.1104.1">, waiting until a resolution happens. </span><span class="koboSpan" id="kobo.1104.2">That would not be a good user experience, even though it would be </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">computationally correct.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">One important </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.1107.1">feature in JavaScript is that, being single-threaded, asynchronous functions don’t block the main thread allowing the execution to continue. </span><span class="koboSpan" id="kobo.1107.2">This is important since the rendering functions of the browser run on the same thread. </span><span class="koboSpan" id="kobo.1107.3">However, this is not free as they do consume resources, but they won’t freeze the UI, at least in theory. </span><span class="koboSpan" id="kobo.1107.4">In practice, it will depend on a number of factors heavily influenced by the browser environment and the hardware. </span><span class="koboSpan" id="kobo.1107.5">Still, let’s stick to </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">the theory.</span></span></p>
<p><span class="koboSpan" id="kobo.1109.1">Let’s see an </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.1110.1">example of a synchronous callback function and turn it asynchronous. </span><span class="koboSpan" id="kobo.1110.2">The example function is very simple: we will calculate the Fibonacci value of a given number using the callback pattern. </span><span class="koboSpan" id="kobo.1110.3">But first, a refresher on the formula for </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">the calculation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1112.1">
F(0)=0
F(1)=1
F(n)=F(n-1)+F(n-2), with n&gt;=2</span></pre>
<p><span class="koboSpan" id="kobo.1113.1">So, here is a JavaScript function that applies the formula and receives a callback to return the value. </span><span class="koboSpan" id="kobo.1113.2">Notice that this function </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">is synchronous:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1115.1">./chapter 2/callback-1.js - Synchronous Fibonacci</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1116.1">
function FibonacciSync(n, callback){
    if(n&lt;2){
</span><strong class="bold"><span class="koboSpan" id="kobo.1117.1">       callback(n)</span></strong><span class="koboSpan" id="kobo.1118.1">
    } else{
        let pre_1=0,pre_2=1,value;
        for(let i=1; i&lt;n; i++){
           value=pre_1+pre_2;
           pre_1=pre_2;
           pre_2=value;
        }
</span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">        callback(value)</span></strong><span class="koboSpan" id="kobo.1120.1">
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1121.1">Notice how instead of returning the value with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">return</span></strong><span class="koboSpan" id="kobo.1123.1">, we are passing it as a parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">callback</span></strong><span class="koboSpan" id="kobo.1125.1"> function. </span><span class="koboSpan" id="kobo.1125.2">When is it useful to use such a thing? </span><span class="koboSpan" id="kobo.1125.3">Consider these </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">simple examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1127.1">
FibonacciSync(8, </span><strong class="bold"><span class="koboSpan" id="kobo.1128.1">console.log</span></strong><span class="koboSpan" id="kobo.1129.1">);
// Will print 21 to the console
FibonacciSync(8, </span><strong class="bold"><span class="koboSpan" id="kobo.1130.1">alert</span></strong><span class="koboSpan" id="kobo.1131.1">)
// Will show a modal with the number 21</span></pre>
<p><span class="koboSpan" id="kobo.1132.1">Just by </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.1133.1">replacing the callback function, we can considerably alter how the result is presented. </span><span class="koboSpan" id="kobo.1133.2">However, the example function has a</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.1134.1"> fundamental flaw affecting the user experience. </span><span class="koboSpan" id="kobo.1134.2">Being synchronous, the calculation time is proportional to the parameter passed: the larger </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">n</span></strong><span class="koboSpan" id="kobo.1136.1">, the more time it will take. </span><span class="koboSpan" id="kobo.1136.2">With a sufficiently large number, we can easily hang up the browser, but also, much before that, we can freeze the interface. </span><span class="koboSpan" id="kobo.1136.3">You can test that the execution is synchronous with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1138.1">
console.log("Before")
FibonacciSync(9, console.log)
console.log("After")
// Will output
// Before
// 34
// After</span></pre>
<p><span class="koboSpan" id="kobo.1139.1">To turn this simple function into an asynchronous function, you can simply wrap the logic inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">setImmediate</span></strong><span class="koboSpan" id="kobo.1141.1"> call. </span><span class="koboSpan" id="kobo.1141.2">This will take the execution out of the normal workflow. </span><span class="koboSpan" id="kobo.1141.3">The new function now looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1143.1">
function </span><strong class="bold"><span class="koboSpan" id="kobo.1144.1">FibonacciAsync</span></strong><span class="koboSpan" id="kobo.1145.1">(n, callback){
</span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">    setImmediate(()=&gt;{</span></strong><span class="koboSpan" id="kobo.1147.1">
        if (n&lt;2){
            callback(n)
        } else{
            let pre_1=0,pre_2=1,value;
            for(let i=1; i&lt;n; i++){
                value=pre_1+pre_2;
                pre_1=pre_2;
                pre_2=value;
            }
            callback(value);
        }
    </span><strong class="bold"><span class="koboSpan" id="kobo.1148.1">})</span></strong><span class="koboSpan" id="kobo.1149.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.1150.1">As you can </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.1151.1">see, we use an arrow function to wrap up </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1152.1">the code without any modifications. </span><span class="koboSpan" id="kobo.1152.2">Now, see the difference when we execute the same snippet as before with </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">this function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1154.1">
console.log("Before")
</span><strong class="bold"><span class="koboSpan" id="kobo.1155.1">FibonacciAsync</span></strong><span class="koboSpan" id="kobo.1156.1">(9, console.log)
console.log("After")
// Will output
// Before
</span><strong class="bold"><span class="koboSpan" id="kobo.1157.1">// After</span></strong><span class="koboSpan" id="kobo.1158.1">
// 34</span></pre>
<p><span class="koboSpan" id="kobo.1159.1">As you can see </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.1160.1">by the output, the snippet outputs </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">After</span></strong><span class="koboSpan" id="kobo.1162.1"> before </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">34</span></strong><span class="koboSpan" id="kobo.1164.1">. </span><span class="koboSpan" id="kobo.1164.2">This is because our asynchronous operation has been taken out of the normal flow as expected. </span><span class="koboSpan" id="kobo.1164.3">When calling an asynchronous function, the execution </span><em class="italic"><span class="koboSpan" id="kobo.1165.1">does not wait</span></em><span class="koboSpan" id="kobo.1166.1"> for a result and continues executing</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.1167.1"> the next instruction. </span><span class="koboSpan" id="kobo.1167.2">This can be confusing at times but is very powerful and useful. </span><span class="koboSpan" id="kobo.1167.3">However, the pattern does not prescribe how to handle errors or failed operations or how to chain or sequentially run multiple calls. </span><span class="koboSpan" id="kobo.1167.4">There are different ways to deal with those cases, but they are not part of the pattern. </span><span class="koboSpan" id="kobo.1167.5">There is another way to handle asynchronous operations that offers more flexibility and control:</span><em class="italic"><span class="koboSpan" id="kobo.1168.1"> promises.</span></em><span class="koboSpan" id="kobo.1169.1"> We will see this next, and in most cases, you can use either pattern interchangeably. </span><span class="koboSpan" id="kobo.1169.2">I say, “in most cases,” </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">not all!</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.1171.1">The promise pattern</span></h2>
<p><span class="koboSpan" id="kobo.1172.1">The </span><em class="italic"><span class="koboSpan" id="kobo.1173.1">promises pattern</span></em><span class="koboSpan" id="kobo.1174.1"> is</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.1175.1"> made primarily to deal </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.1176.1">with asynchronous operations. </span><span class="koboSpan" id="kobo.1176.2">Just like with callbacks, the invocation of a promised function takes the execution out of the normal flow, but it returns a special object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">Promise</span></strong><span class="koboSpan" id="kobo.1178.1">. </span><span class="koboSpan" id="kobo.1178.2">This object exposes a simple API with three methods: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">then</span></strong><span class="koboSpan" id="kobo.1180.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">catch</span></strong><span class="koboSpan" id="kobo.1182.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">finally</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1185.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1186.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">then</span></strong><span class="koboSpan" id="kobo.1188.1"> method receives two callback functions, traditionally called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">resolve</span></strong><span class="koboSpan" id="kobo.1190.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">reject</span></strong><span class="koboSpan" id="kobo.1192.1">. </span><span class="koboSpan" id="kobo.1192.2">They are used in the asynchronous code to return a successful value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">resolve</span></strong><span class="koboSpan" id="kobo.1194.1">) or a faile</span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.1195.1">d or negative </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">value (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">reject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1199.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">catch</span></strong><span class="koboSpan" id="kobo.1201.1"> method receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">error </span></strong><span class="koboSpan" id="kobo.1203.1">parameter and is triggered when the process throws an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">error</span></strong><span class="koboSpan" id="kobo.1205.1"> and the execution </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">is interrupted.</span></span></li>
<li><span class="koboSpan" id="kobo.1207.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">finally</span></strong><span class="koboSpan" id="kobo.1209.1"> method executes in either case and receives a </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">callback function.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1211.1">While a promise is running, it is said to be in an </span><em class="italic"><span class="koboSpan" id="kobo.1212.1">indeterminate</span></em><span class="koboSpan" id="kobo.1213.1"> state until it is resolved or rejected. </span><span class="koboSpan" id="kobo.1213.2">There is no time limit for how long a promise will wait in this state, something that makes it especially useful for lengthy </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.1214.1">operations such as network calls and </span><strong class="bold"><span class="koboSpan" id="kobo.1215.1">inter-process </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1216.1">communication</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1218.1">IPC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1220.1">Let’s see how to</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.1221.1"> implement the previous example with the Fibonacci series </span><a id="_idIndexMarker211"/><span class="No-Break"><span class="koboSpan" id="kobo.1222.1">using promises:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1223.1">
function FibonacciPromise(</span><strong class="bold"><span class="koboSpan" id="kobo.1224.1">n</span></strong><span class="koboSpan" id="kobo.1225.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1226.1">    return new Promise</span></strong><span class="koboSpan" id="kobo.1227.1">((</span><strong class="bold"><span class="koboSpan" id="kobo.1228.1">resolve</span></strong><span class="koboSpan" id="kobo.1229.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1230.1">reject</span></strong><span class="koboSpan" id="kobo.1231.1">) =&gt; {          </span><strong class="bold"><span class="koboSpan" id="kobo.1232.1">//1</span></strong><span class="koboSpan" id="kobo.1233.1">
        if (n &lt; 0) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1234.1">            reject()</span></strong><span class="koboSpan" id="kobo.1235.1">                                   </span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">//2</span></strong><span class="koboSpan" id="kobo.1237.1">
        } else {
             if (n &lt; 2) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1238.1">                 resolve(n)</span></strong><span class="koboSpan" id="kobo.1239.1">                            </span><strong class="bold"><span class="koboSpan" id="kobo.1240.1">//3</span></strong><span class="koboSpan" id="kobo.1241.1">
             } else {
                  let pre_1 = 1, pre_2 = 1, value;
                  for (let i = 2; i &lt; n; i++) {
                      value = pre_1 + pre_2;
                      pre_1 = pre_2;
                      pre_2 = value;
                  }
                  </span><strong class="bold"><span class="koboSpan" id="kobo.1242.1">resolve(value);</span></strong><span class="koboSpan" id="kobo.1243.1">
             }
        }
    })
}</span></pre>
<p><span class="koboSpan" id="kobo.1244.1">At first sight, it is easy to see that the implementation has changed a bit. </span><span class="koboSpan" id="kobo.1244.2">We start on line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">//1</span></strong><span class="koboSpan" id="kobo.1246.1"> by immediately returning a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">new Promise()</span></strong><span class="koboSpan" id="kobo.1248.1"> object. </span><span class="koboSpan" id="kobo.1248.2">This</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.1249.1"> constructor receives a callback function, that will, in turn, receive two callbacks named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">resolve() </span></strong><span class="koboSpan" id="kobo.1251.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">reject()</span></strong><span class="koboSpan" id="kobo.1253.1">. </span><span class="koboSpan" id="kobo.1253.2">We need to use these in our logic to return a value in case of success (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">resolve</span></strong><span class="koboSpan" id="kobo.1255.1">) or failure (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">reject</span></strong><span class="koboSpan" id="kobo.1257.1">). </span><span class="koboSpan" id="kobo.1257.2">Also notice that we don’t have to wrap our code in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1258.1">setImmediate</span></strong><span class="koboSpan" id="kobo.1259.1"> function, as a promise is by nature asynchronous. </span><span class="koboSpan" id="kobo.1259.2">We now check for negative numbers and then reject the operation in that case (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">//2</span></strong><span class="koboSpan" id="kobo.1261.1">). </span><span class="koboSpan" id="kobo.1261.2">The other change we make is to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">callb</span><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.1263.1">ack()</span></strong><span class="koboSpan" id="kobo.1264.1"> invocation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">resolve()</span></strong><span class="koboSpan" id="kobo.1266.1"> in lines</span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">//3</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1268.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">//</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.1270.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1272.1">The invocation now </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">also changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1274.1">
console.log("Before")
FibonacciPromise(9)</span><strong class="bold"><span class="koboSpan" id="kobo.1275.1">.then</span></strong><span class="koboSpan" id="kobo.1276.1">(
</span><strong class="bold"><span class="koboSpan" id="kobo.1277.1">    value=&gt;console.log(value),</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1278.1">    ()=&gt;{console.log("Undefined for negative numbers!")}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1279.1">);</span></strong><span class="koboSpan" id="kobo.1280.1">
console.log("After")
// Will output:
// Before
// After
// 34</span></pre>
<p><span class="koboSpan" id="kobo.1281.1">As you </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.1282.1">can see, we chain to the invocation, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">then</span></strong><span class="koboSpan" id="kobo.1284.1"> method, and pass to it the two functions for success and failure (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">resolve</span></strong><span class="koboSpan" id="kobo.1286.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">reject</span></strong><span class="koboSpan" id="kobo.1288.1"> in our code). </span><span class="koboSpan" id="kobo.1288.2">Just like before, we get the same output. </span><span class="koboSpan" id="kobo.1288.3">Now, this may seem more verbose (it is), but the benefits greatly outweigh the extra typing. </span><span class="koboSpan" id="kobo.1288.4">Promises are chainable, meaning that for su</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.1289.1">ccessful operations, you can return a new promise and, that way, have a sequential operation. </span><span class="koboSpan" id="kobo.1289.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1291.1">
MyFunction()
    .then(()=&gt;{ return new Promise(...)}, ()=&gt;{...})
    .then(()=&gt;{ return new Promise(...)}, ()=&gt;{...})
    .then(()=&gt;{ return new Promise(...)}, ()=&gt;{...})
    .then(()=&gt;{ return new Promise(...)}, ()=&gt;{...})
    .catch(err=&gt;{...})</span></pre>
<p><span class="koboSpan" id="kobo.1292.1">There are other methods exposed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">Promise</span></strong><span class="koboSpan" id="kobo.1294.1"> constructor, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">.all</span></strong><span class="koboSpan" id="kobo.1296.1">, but I will refer you to the documentation to dig deeper into the possibilities and syntax (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><span class="koboSpan" id="kobo.1297.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</span></a><span class="koboSpan" id="kobo.1298.1">). </span><span class="koboSpan" id="kobo.1298.2">Still, quite verbose. </span><span class="koboSpan" id="kobo.1298.3">Lucky for us, JavaScript provides us with a simplified syntax to handle promises, </span><strong class="bold"><span class="koboSpan" id="kobo.1299.1">async/await,</span></strong><span class="koboSpan" id="kobo.1300.1"> and</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.1301.1"> think of them as a way to code in a more “traditional” way. </span><span class="koboSpan" id="kobo.1301.2">This only applies </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.1302.1">to the invocation of promised functions and can only be used </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">in functions.</span></span></p>
<p><span class="koboSpan" id="kobo.1304.1">To see this as an example, let’s imagine that we have three functions that return promises, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">MyFuncA</span></strong><span class="koboSpan" id="kobo.1306.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">MyFuncB</span></strong><span class="koboSpan" id="kobo.1308.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">MyFuncC</span></strong><span class="koboSpan" id="kobo.1310.1"> (yes, I know, not the greatest names). </span><span class="koboSpan" id="kobo.1310.2">Each one</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.1311.1"> returns, in case of success, </span><em class="italic"><span class="koboSpan" id="kobo.1312.1">one single value </span></em><span class="koboSpan" id="kobo.1313.1">(this is a condition). </span><span class="koboSpan" id="kobo.1313.2">These are then used within </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">MyProcessFunction</span></strong><span class="koboSpan" id="kobo.1315.1"> with the new syntax. </span><span class="koboSpan" id="kobo.1315.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.1316.1">the declaration:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1317.1">async </span></strong><span class="koboSpan" id="kobo.1318.1">function myProcessFunction() {                  //1
</span><strong class="bold"><span class="koboSpan" id="kobo.1319.1">    try {</span></strong><span class="koboSpan" id="kobo.1320.1">                                             </span><strong class="bold"><span class="koboSpan" id="kobo.1321.1">//2</span></strong><span class="koboSpan" id="kobo.1322.1">
         let     a = </span><strong class="bold"><span class="koboSpan" id="kobo.1323.1">await </span></strong><span class="koboSpan" id="kobo.1324.1">MyFuncA(),                 //3
                 b = await MyFuncB(),
                 c = await MyFuncC()
         console.log(a + b + c)                       //4
</span><strong class="bold"><span class="koboSpan" id="kobo.1325.1">    } catch {</span></strong><span class="koboSpan" id="kobo.1326.1">
             console.log("Error")
</span><strong class="bold"><span class="koboSpan" id="kobo.1327.1">    }</span></strong><span class="koboSpan" id="kobo.1328.1">
}
// Invoke the function normally
</span><strong class="bold"><span class="koboSpan" id="kobo.1329.1">MyProcessFunction()</span></strong><span class="koboSpan" id="kobo.1330.1">                                   </span><strong class="bold"><span class="koboSpan" id="kobo.1331.1">//5</span></strong></pre>
<p><span class="koboSpan" id="kobo.1332.1">We start by declaring our function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">async</span></strong><span class="koboSpan" id="kobo.1334.1"> keyword (line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">//1</span></strong><span class="koboSpan" id="kobo.1336.1">). </span><span class="koboSpan" id="kobo.1336.2">This signals to the interpreter that we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">await</span></strong><span class="koboSpan" id="kobo.1338.1"> syntax inside our function. </span><span class="koboSpan" id="kobo.1338.2">One condition is to wrap the code in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">try...catch</span></strong><span class="koboSpan" id="kobo.1340.1"> block. </span><span class="koboSpan" id="kobo.1340.2">Then, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">await</span></strong><span class="koboSpan" id="kobo.1342.1"> keyword in front of the invocation of each promised function call, as in line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">//3</span></strong><span class="koboSpan" id="kobo.1344.1">. </span><span class="koboSpan" id="kobo.1344.2">By line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">//4</span></strong><span class="koboSpan" id="kobo.1346.1">, we are certain that each variable has received a value. </span><span class="koboSpan" id="kobo.1346.2">Certainly, this approach is easi</span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1347.1">er to follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">and read.</span></span></p>
<p><span class="koboSpan" id="kobo.1349.1">Let’s investigate the equivalences</span><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1350.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">the line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1352.1">
let a=await MyFuncA()</span></pre>
<p><span class="koboSpan" id="kobo.1353.1">This will match the </span><em class="italic"><span class="koboSpan" id="kobo.1354.1">thenable </span></em><span class="koboSpan" id="kobo.1355.1">(using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">then</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">) syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1359.1">
let a;
MyFuncA()
    .then(result=&gt;{ a=result; })</span></pre>
<p><span class="koboSpan" id="kobo.1360.1">However, the </span><a id="_idIndexMarker217"/><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.1361.1">problem with this last syntax is that we </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.1362.1">need to make sure that all the variables </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">a</span></strong><span class="koboSpan" id="kobo.1364.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">b</span></strong><span class="koboSpan" id="kobo.1366.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">c</span></strong><span class="koboSpan" id="kobo.1368.1"> have values before w</span><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.1369.1">e can run line </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">//4</span></strong><span class="koboSpan" id="kobo.1371.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">console.log(a+b+c)</span></strong><span class="koboSpan" id="kobo.1373.1">, which wo</span><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.1374.1">uld mean chaining the invocations </span><span class="No-Break"><span class="koboSpan" id="kobo.1375.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1376.1">
let </span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.1377.1">a,b,c;
MyFuncA()
    .then(result=&gt;{ a=result; </span><strong class="bold"><span class="koboSpan" id="kobo.1378.1">return MyFuncB()</span></strong><span class="koboSpan" id="kobo.1379.1">})
    .then(result=&gt;{ b=result; </span><strong class="bold"><span class="koboSpan" id="kobo.1380.1">return MyFuncC()</span></strong><span class="koboSpan" id="kobo.1381.1">})
    .then(result=&gt;{ c=result; </span><strong class="bold"><span class="koboSpan" id="kobo.1382.1">console.log(a+b+c)</span></strong><span class="koboSpan" id="kobo.1383.1">})</span></pre>
<p><span class="koboSpan" id="kobo.1384.1">This format is harder to follow and certainly more verbose. </span><span class="koboSpan" id="kobo.1384.2">For these cases, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">async/await</span></strong><span class="koboSpan" id="kobo.1386.1"> syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">is preferred.</span></span></p>
<p><span class="koboSpan" id="kobo.1388.1">The use of promises is great for wrapping lengthy or uncertain operations and integrating with other patterns that we have seen (façade, decorator, etc.). </span><span class="koboSpan" id="kobo.1388.2">It is an important pattern to keep in mind that we will use extensively in </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">our applications.</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.1390.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1391.1">In this chapter, we have seen principles for software development and important design patterns, with examples in plain JavaScript and, when appropriate, hinted at implementations with Vue 3. </span><span class="koboSpan" id="kobo.1391.2">These patterns can be hard to grasp the first time you see them, but we will use them and return to them in the rest of the book so that this chapter will work as a reference. </span><span class="koboSpan" id="kobo.1391.3">This will give you a better idea of when and how to apply different patterns according to the needs of </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.1393.1">In the next chapter, we will start to implement a project from scratch and will set the foundations for the applications we will build in the rest of the book. </span><span class="koboSpan" id="kobo.1393.2">As we move for</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.1394.1">ward, we will reference these patterns to help you consolidate </span><span class="No-Break"><span class="koboSpan" id="kobo.1395.1">their application.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1396.1">Review questions</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.1397.1">What is the difference between a principle and </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">a pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.1399.1">Why is the singleton pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.1400.1">so important?</span></span></li>
<li><span class="koboSpan" id="kobo.1401.1">How can you </span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1">manage dependencies?</span></span></li>
<li><span class="koboSpan" id="kobo.1403.1">What patterns make </span><span class="No-Break"><span class="koboSpan" id="kobo.1404.1">reactivity possible?</span></span></li>
<li><span class="koboSpan" id="kobo.1405.1">Do patterns intertwine? </span><span class="koboSpan" id="kobo.1405.2">Why? </span><span class="koboSpan" id="kobo.1405.3">Can you give </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">an example?</span></span></li>
<li><span class="koboSpan" id="kobo.1407.1">What is asynchronous programming, and why is it </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">so important?</span></span></li>
<li><span class="koboSpan" id="kobo.1409.1">Can you think of use cases for </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1410.1">promised</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1411.1"> functions?</span></span></li>
</ul>
</div>
</body></html>