- en: '*Chapter 3*: Connecting to the Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our backend and frontend can communicate, create new posts, and respond with
    a list of all posts while using fake data. The next step on our list will be to
    use a database, such as a SQL server, to serve as data storage.
  prefs: []
  type: TYPE_NORMAL
- en: We want our backend to persist data to our SQL database by using Sequelize.
    Our Apollo Server should use this data for queries and mutations, as needed. For
    this to happen, we must implement database models for our GraphQL entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using databases in GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Sequelize in Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing database models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeding data with Sequelize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Apollo with Sequelize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing database migrations with Sequelize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: Using databases in GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GraphQL** is a protocol for sending and receiving data. **Apollo** is one
    of the many libraries that you can use to implement that protocol. Neither GraphQL
    (in its specifications) nor Apollo works directly on the data layer. Where the
    data that you put into your response comes from, and where the data that you send
    with your request is saved, are up to the developer to decide.'
  prefs: []
  type: TYPE_NORMAL
- en: This logic indicates that the database and the services that you use do not
    matter to Apollo, so long as the data that you respond with matches the GraphQL
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: As we are living in the Node.js ecosystem in this project and book, it would
    be fitting to use MongoDB. MongoDB offers a great client library for Node.js and
    uses JavaScript as its native choice of language for interactions and querying.
  prefs: []
  type: TYPE_NORMAL
- en: The general alternative to a database system such as MongoDB is a typical MySQL
    server with proven stability and global usage. One case that I encounter frequently
    involves systems and applications relying on older code bases and databases that
    need upgrades. A great way to accomplish this is to get an over-layering API level
    with GraphQL. In this scenario, the GraphQL server receives all requests and,
    one by one, you can replace the existing code bases that the GraphQL server relies
    on. In these cases, it is helpful that GraphQL is database agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use SQL via Sequelize to see this feature in a real-world
    use case. For future purposes, it will also help you to handle problems with existing
    SQL-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MySQL for development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL is an excellent starting point for getting on track in a developmental
    career. It is also well suited for local development on your machine since the
    setup is easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to set up MySQL on your machine depends on your operating system. As we
    mentioned in [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Preparing
    Your Development Environment*, we are assuming that you are using a Debian-based
    system. For this, you can use the following instructions. If you already have
    a working setup for MySQL or Apache, these commands may not work, or may not be
    required in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: For other operating systems, there are great prebuilt packages. I recommend
    that all Windows users use XAMPP and that Mac users use MAMP. These offer an easy
    installation process for what we did manually on Linux. They also implement MySQL,
    Apache, and PHP, including phpMyAdmin.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Do not follow these instructions when setting up a real SQL server for public
    and production use. A professional setup includes many security features to protect
    you against attacks. This installation should only be used in development, on
    your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following steps to get MySQL running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you should always install all the updates available for your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to install MySQL and a GUI to see what we have inside our database.
    The most common GUI for a MySQL server is phpMyAdmin. For this, you need to install
    a web server and PHP. We are going to install Apache as our web server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If, at any point in the process, you receive an error stating that the package
    could not be found, ensure that your system is Debian-based. The installation
    process can differ on other systems. You can easily search for the matching package
    for your system on the internet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install all the necessary dependencies with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the installation, you will need to run the MySQL setup in the root shell.
    You will have to enter the root password for this. Alternatively, you can run
    `sudo -i`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can execute the MySQL installation command; follow the steps as prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can ignore most of these steps and security settings but be careful when
    you are asked for the root password of your MySQL instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must create a separate user for development aside from the root user. You
    are discouraged from using the root user at all. Log into our MySQL server with
    the root user to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the following SQL command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can install phpMyAdmin since our MySQL server has been set up. You will
    be asked for a web server when executing the following command. Select `apache2`
    with the spacebar and navigate to **ok** by hitting the *Tab* key. When you're
    asked for it, select the automatic setup method for phpMyAdmin. You should not
    do this manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, phpMyAdmin will want you to enter a password. I recommend that
    you choose the same password that you chose for the root user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the installation, we will need to set up Apache to serve phpMyAdmin.
    The following `ln` command creates a symbolic link in the root folder of the Apache
    public `HTML` folder. Apache will now serve phpMyAdmin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can visit phpMyAdmin under `http://localhost/phpmyadmin` and log in
    with the newly created user. This should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – phpMyAdmin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – phpMyAdmin
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have installed the database for our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: phpMyAdmin chooses the language according to your environment, so it might differ
    slightly from what's shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database in MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start implementing our backend, we need to add a new database that
    we can use.
  prefs: []
  type: TYPE_NORMAL
- en: You are free to do this via the command line or phpMyAdmin. As we have just
    installed phpMyAdmin, we are going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run raw SQL commands in the **SQL** tab of phpMyAdmin. The corresponding
    command to create a new database is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, you can follow the next set of steps to use the graphical method.
    In the left-hand panel, click on the **New** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with a screen like the following. It will show all the
    databases, including their collation of your MySQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – phpMyAdmin databases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.02_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – phpMyAdmin databases
  prefs: []
  type: TYPE_NORMAL
- en: Enter a database name, such as `graphbook_dev`, and then choose the `uft8_general_ci`
    collation. After doing so, click on **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: You will see a page that says **No tables found in database**, which is correct.
    This will change later, when we have implemented our database models, such as
    posts and users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to set up Sequelize in Node.js and connect
    it to our SQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Sequelize into our Node.js stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just set up a MySQL database, and we want to use it inside of our Node.js
    backend. There are many libraries to connect to and query your MySQL database.
    We are going to use Sequelize in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Object–Relational Mappers (ORMs)
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives include Waterline ORM and js-data, which offer the same functionalities
    as Sequelize. What is great about these is that they not only offer SQL dialects,
    but also feature database adapters for MongoDB, Redis, and more. So, if you need
    an alternative, check them out.
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize is an ORM for Node.js. It supports the PostgreSQL, MySQL, SQLite,
    and MSSQL standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Sequelize in your project via `npm`. We will also install a second
    package, called `mysql2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql2` package allows Sequelize to speak with our MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize is just a wrapper around the various libraries for the different database
    systems. It offers great features for intuitive model usage, as well as functions
    for creating and updating database structures and inserting development data.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you would run `npx sequelize-cli init` before starting with the database
    connection or models, but I prefer a more custom approach. From my point of view,
    this is a bit cleaner. This approach is also why we are setting up the database
    connection in an extra file and are not relying on boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Sequelize Traditionally
  prefs: []
  type: TYPE_NORMAL
- en: You can look at the official tutorial in the Sequelize documentation if you
    want to see how it would usually be done. The approach that we are taking and
    the one from the tutorial do not differ too much, but it is always good to see
    another way of doing things. The documentation can be found at [https://sequelize.org/master/manual/migrations.html](https://sequelize.org/master/manual/migrations.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by setting Sequelize up in our backend.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database with Sequelize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to initialize the connection from Sequelize to our MySQL
    server. To do this, we will create a new folder and file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `index.js` database, we will establish a connection to our database
    with Sequelize. Internally, Sequelize relies on the `mysql2` package, but we do
    not use it ourselves, which is very convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we load Sequelize from `node_modules` and then create an instance
    of it. The following properties are important for Sequelize:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the database name as the first parameter, which we just created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third parameters are the credentials of our `devuser`. Replace
    them with the username and password that you entered for your database. `devuser`
    has permission to access all the databases in our MySQL server. This makes development
    a lot easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter is a general options object that can hold many more properties.
    The preceding object is an example configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `host` option of our MySQL database is our local machine alias, `localhost`.
    If this is not the case, you can also specify the IP or URL of the MySQL server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dialect` is, of course, `mysql`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `pool` option, you tell Sequelize the configuration for every database
    connection. The preceding configuration allows for a minimum of zero connections,
    which means that Sequelize should not maintain one connection, but should create
    a new one whenever it is needed. The maximum number of connections is five. This
    option also relates to the number of replica sets that your database system has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `idle` field of the `pool` option specifies how long a connection can be
    unused before it gets closed and removed from the pool of active connections.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When trying to establish a new connection to our MySQL server, the timeout before
    the connection is aborted is defined by the `acquire` option. In cases in which
    a connection cannot be created, this option helps stop your server from freezing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Executing the preceding code will instantiate Sequelize and will successfully
    create a connection to our MySQL server. Going further, we need to handle multiple
    databases for every environment that our application can run in, from development
    to production. You will see that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a configuration file with Sequelize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous setup for our database connection with Sequelize is fine, but it
    is not made for later deployment. The best option is to have a separate configuration
    file that is read and used according to the environment that the server is running
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, create a new `index.js` file inside a separate folder (called `config`),
    next to the `database` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Your sample configuration should look like the following code if you have followed
    the instructions for creating a MySQL database. The only thing that we did here
    was copy our current configuration into a new object indexed with the `development`
    or `production` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize expects a `config.json` file inside this folder by default, but this
    setup will allow us to take on a more custom approach in later chapters. The `development`
    environment directly stores the credentials for your database, whereas the `production`
    configuration uses environment variables to fill them.
  prefs: []
  type: TYPE_NORMAL
- en: We can remove the configuration that we hardcoded earlier and replace the contents
    of our `database/index.js` file to require our `configFile` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `NODE_ENV` environment variable to get
    the environment that the server is running in. We read the `config` file and pass
    the correct configuration to the Sequelize instance. The environment variable
    will allow us to switch to a new environment, such as `production`, later in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The Sequelize instance is then exported for use throughout our application.
    We use a special `db` object for this. You will see why we are doing this later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to generate and write models and migrations for all
    the entities that our application will have.
  prefs: []
  type: TYPE_NORMAL
- en: Writing database models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating a connection to our MySQL server via Sequelize, we want to use
    it. However, our database is missing a table or structure that we can query or
    manipulate. Creating those is the next thing that we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we have two GraphQL entities: `User` and `Post`.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize lets us create a database schema for each of our GraphQL entities.
    The schema is validated when we insert or update rows in our database. We already
    wrote a schema for GraphQL in the `schema.js` file, which is used by Apollo Server,
    but we need to create a second one for our database. The field types, as well
    as the fields themselves, can vary between the database and the GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL schemas can have more fields than our database model, or vice versa.
    Perhaps you do not want to export all the data from your database through the
    API, or maybe you want to generate data for your GraphQL API on the fly when you're
    requesting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the first model for our posts. Create two new folders (one called
    `models` and another called `migrations`) next to the `database` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating each model in a separate file is much cleaner than having one big file
    for all the models.
  prefs: []
  type: TYPE_NORMAL
- en: Your first database model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the Sequelize CLI to generate our first database model. Install
    it globally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This gives you the ability to run the `sequelize` command inside your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sequelize CLI allows us to generate the model automatically. This can be
    done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize expects us to run the command in the folder where we have run `sequelize
    init` by default. Our file structure is different because we have two layers with
    `src/server`. For this reason, we specify the path manually with the first two
    parameters; that is, `--models-path` and `--migrations-path`.
  prefs: []
  type: TYPE_NORMAL
- en: The `--name` parameter gives our model a name under which it can be used. The
    `--attributes` option specifies the fields that the model should include.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are customizing your setup, you may want to know about other options
    that the CLI offers. You can view the manual for every command easily by appending
    `--help` as an option: `sequelize model:generate --help`.'
  prefs: []
  type: TYPE_NORMAL
- en: This command creates a `post.js` model file in your `models` folder and a database
    migration file, named `XXXXXXXXXXXXXX-create-post.js`, in your `migrations` folder.
    The `X` icons indicate the timestamp when you're generating the files with the
    CLI. You will see how migrations work in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following model file was created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating the `Post` class and extending the `Model` class from
    Sequelize. Then, we are using the `init` function of Sequelize to create a database
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the model attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is an `option` object, where the `sequelize` connection
    instance and model name are passed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model Customization
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are many more options that Sequelize offers us to customize our database
    models. If you want to look up which options are available, you can find them
    at [https://sequelize.org/master/manual/model-basics.html](https://sequelize.org/master/manual/model-basics.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A `post` object has the `id`, `text`, and `user` properties. The user will be
    a separate model, as shown in the GraphQL schema. Consequently, we only need to
    configure `id` and `text` as columns of a post.
  prefs: []
  type: TYPE_NORMAL
- en: '`id` is the key that uniquely identifies a data record from our database. We
    do not specify this when running the `model:generate` command because it is generated
    by MySQL automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: The `text` column is just a MySQL `TEXT` field that allows us to write long
    posts. Alternatively, there are other MySQL field types, with `MEDIUMTEXT`, `LONGTEXT`,
    and `BLOB`, which could save more characters. A regular `TEXT` column should be
    fine for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: The Sequelize CLI created a model file, exporting a function that, after execution,
    returns the real database model. You will soon see why this is a great way of
    initializing our models.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the migration file that is also created by the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Your first database migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, MySQL has not known anything about our plan to save posts inside of
    it. Our database tables and columns need to be created, hence why the migration
    file was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'A migration file has multiple advantages, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Migrations allow us to track database changes through our regular version control
    system, such as Git or SVN. Every change to our database structure should be covered
    in a migration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migration files enable us to write updates that automatically apply database
    changes for new versions of our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our first migration file creates a `Posts` table and adds all the required
    columns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By convention, the model name is pluralized in migrations, but it is singular
    inside model definitions. Our table names are also pluralized. Sequelize offers
    options to change this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A migration has two properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `up` property states what should be done when running the migration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `down` property states what is run when undoing a migration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned previously, the `id` and `text` columns are created, as well
    as two additional `datetime` columns, to save the creation and update time.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field has set `autoIncrement` and `primaryKey` to `true`. `id` will
    count upward, from one to nearly infinite, for each post in our table. This `id`
    uniquely identifies posts for us. Passing `allowNull` with `false` disables this
    feature so that we can insert a row with an empty field value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this migration, we will use the Sequelize CLI again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Look inside of phpMyAdmin. Here, you will find the new table, called `posts`.
    The structure of the table should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Posts table structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.03_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Posts table structure
  prefs: []
  type: TYPE_NORMAL
- en: All the columns were created as we desired.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, two additional fields – `createdAt` and `updatedAt` – were created.
    These two fields tell us when a row was either created or updated. The fields
    were created by Sequelize automatically. If you do not want this, you can set
    the `timestamps` property in the model to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you use Sequelize and its migration feature, you will have an additional
    table called `sequelizemeta`. The contents of the table should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Migrations table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.04_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Migrations table
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize saves every migration that has been executed. If we add more fields
    in development or a news release cycle, we can write a migration that runs all
    the table-altering statements for us as an update. Sequelize skips all the migrations
    that are saved inside the meta table.
  prefs: []
  type: TYPE_NORMAL
- en: One major step is to bind our model to Sequelize. This process can be automated
    by running `sequelize init`, but understanding it will teach us way more than
    relying on premade boilerplate commands.
  prefs: []
  type: TYPE_NORMAL
- en: Importing models with Sequelize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to import all the database models at once, in a central file. Our database
    connection instantiator will then rely on this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `index.js` file in the `models` folder and use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding logic will also be generated when running `sequelize init`, but
    this way, the database connection is set up in a separate file from loading the
    models. Usually, this would happen in just one file when using the Sequelize boilerplate
    code. Furthermore, we have introduced some webpack-specific configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize what happens in the preceding code, we search for all the files
    ending with `.js` in the same folder as the current file and load them all with
    the `require.context` statement. In development, we must execute the `babel-plugin-require-context-hook/register`
    Hook to load the `require.context` function at the top. This package must be installed
    with `npm`, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to load the Babel plugin at the start of our development server, so,
    open the `package.json` file and edit the `server` script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the plugin is loaded and we run the `require('babel-plugin-require-context-hook/register')()`
    function, the `require.context` method becomes available for us. Make sure that
    you set the `NODE_ENV` variable to `development`; otherwise, this won't work.
  prefs: []
  type: TYPE_NORMAL
- en: In production, the `require.context` function is included in the generated bundle
    of webpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loaded model files export a function with the following two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Our Sequelize instance, after creating a connection to our database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sequelize` class itself, including the data types it offers, such as integer
    or text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the exported functions imports the actual Sequelize model. Once all
    the models have been imported, we loop through them and check whether they have
    a function called `associate`. If this is the case, we execute the `associate`
    function and, through that, we establish relationships between multiple models.
    Currently, we have not set up an association, but that will change later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to use our models. Go back to the `index.js` database file and
    import all the models through the aggregated `index.js` file that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Before exporting the `db` object at the end of the file, we need to run the
    `models` wrapper to read all model `.js` files. We pass our Sequelize instance
    as a parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The new database object in the preceding command has `sequelize` and `models`
    as properties. Under `models`, you can find the `Post` model and every new model
    that we are going to add later.
  prefs: []
  type: TYPE_NORMAL
- en: The database `index.js` file is ready and can now be used. You should import
    this file only once because it can get messy when you're creating multiple instances
    of Sequelize. The pool functionality won't work correctly, and we will end up
    with more connections than the maximum of five that we specified earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must create the global database instance in the `index.js` file of the root
    server folder. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We require the `database` folder and the `index.js` file inside this folder.
    Loading the file instantiates the Sequelize object, including all the database
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, we want to query some data from our database via the GraphQL
    API that we implemented in [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032),
    *Setting Up GraphQL with Express.js*.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding data with Sequelize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should fill the empty `Posts` table with our fake data. To accomplish this,
    we will use Sequelize's feature for seeding data to our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `seeders`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our next Sequelize CLI command to generate a boilerplate file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeders are great for importing test data into a database for development.
    Our `seed` file has the timestamp and the words `fake-posts` in the name, and
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, nothing is done here. It is just an
    empty boilerplate file. We need to edit this file to create the fake posts that
    we already had in our backend. This file looks like our migration from the previous
    section. Replace the contents of the file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `up` migration, we are bulk inserting two posts through `queryInterface`
    and its `bulkInsert` command. For this, we will pass an array of posts, excluding
    the `id` property and the associated user. This `id` is created automatically,
    and the user is saved in a separate table later. `queryInterface` of Sequelize
    is the general interface that Sequelize uses to talk to all databases.
  prefs: []
  type: TYPE_NORMAL
- en: In our seed file, we need to add the `createdAt` and `updatedAt` fields since
    Sequelize does not set up default values for the timestamp columns in MySQL. In
    reality, Sequelize takes care of the default values of those fields by itself,
    but not when seeding data. If you do not provide these values, the seed will fail,
    because `NULL` is not allowed for `createdAt` and `updatedAt`.
  prefs: []
  type: TYPE_NORMAL
- en: The `down` migration bulk deletes all the rows in the table since this is the
    apparent reverse action of the `up` migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute all the seeds from the `seeders` folder with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize does not check or save whether a seed has been run already, as we
    are doing it with the preceding command. This means that you can run seeds multiple
    times if you want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a filled-in `Posts` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The Posts table with seed data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.05_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – The Posts table with seed data
  prefs: []
  type: TYPE_NORMAL
- en: The demo posts are now inside our database.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover how to use Sequelize with our Apollo Server, as well as how to
    add the relationship between the user and their posts, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Sequelize with GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database object is initialized upon starting the server within the root
    `index.js` file. We pass it from this global location down to the spots where
    we rely on the database. This way, we do not import the database file repeatedly
    but have a single instance that handles all the database queries for us.
  prefs: []
  type: TYPE_NORMAL
- en: The services that we want to publicize through the GraphQL API need access to
    our MySQL database. The first step is to implement the posts in our GraphQL API.
    It should respond with the fake posts from the database we just inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Global database instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To pass the database down to our GraphQL resolvers, we must create a new object
    in the server `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `utils` object directly under the `import` statement of the
    `database` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `utils` object holds all the utilities that our services might need access
    to. This can be anything from third-party tools to our MySQL server, or any other
    database, as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the line where we import the `services` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code might look weird to you, but what we are doing here is executing
    the function that is the result of the `import` statement and passing the `utils`
    object as a parameter. We must do this in two separate lines since the `import`
    syntax does not allow it in just one line; so, we must first import the function
    that's been exported from the `services` folder into a separate variable.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the return value of the `import` statement has been a simple object.
    We have to change this so that it matches our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go to the services `index.js` file and change the contents of the
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We surrounded the preceding `services` object with a function, which was then
    exported. That function accepts only one parameter, which is our `utils` object.
  prefs: []
  type: TYPE_NORMAL
- en: That object is then given to a new function, called `graphql`. Every service
    that we are going to use has to be a function that accepts this parameter. This
    allows us to hand over any property that we want to the deepest point in our application.
  prefs: []
  type: TYPE_NORMAL
- en: When executing the preceding exported function, the result is the regular `services`
    object we used previously. We only wrapped it inside a function to pass the `utils`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `graphql` import that we are doing needs to accept the `utils` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.js` file from the `graphql` folder and replace everything but
    the `require` statements at the top with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have surrounded everything with a function that accepts the `utils`
    object. The aim of all this is to have access to the database within our GraphQL
    resolvers, which are given to `ApolloServer`.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we are using the `Resolvers.call` function from JavaScript.
    This function allows us to set the owner object of the exported `Resolvers` function.
    What we are saying here is that the scope of `Resolvers` is the `utils` object.
  prefs: []
  type: TYPE_NORMAL
- en: So, within the `Resolvers` function, accessing this now gives us the `utils`
    object as the scope. At the moment, `Resolvers` is just a simple object, but because
    we used the `call` method, we must also return a function from the `resolvers.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surround the `resolvers` object in this file with a function and return the
    `resolvers` object from inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We cannot use the arrow syntax, as we did previously. ES6 arrow syntax would
    automatically take a scope, but we want the `call` function to take over here.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way of doing this would be to hand over the `utils` object as
    a parameter. I think the way that we have chosen to do things is a bit cleaner,
    but handle it as you like.
  prefs: []
  type: TYPE_NORMAL
- en: Running the first database query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can start to use the database. Add the following code to the top of
    the `export default function resolver` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword is the owner of the current method and holds the `db` object,
    as stated previously. We extracted the database models from the `db` object that
    we built in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about models is that you do not need to write raw queries against
    the database. You have already told Sequelize which fields and tables it can use
    by creating a model. At this point, you can use Sequelize's methods to run queries
    against the database within your resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can query all the posts through the Sequelize model, instead of returning
    the fake posts from before. Replace the `posts` property within `RootQuery` with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we searched for and selected all the posts that we have
    in our database. We used the Sequelize `findAll` method and returned the result
    of it. The return value will be a JavaScript promise, which automatically gets
    resolved once the database has finished collecting the data.
  prefs: []
  type: TYPE_NORMAL
- en: A typical news feed, such as on Twitter or Facebook, orders the posts according
    to the creation date. That way, you have the newest posts at the top and the oldest
    at the bottom. Sequelize expects an array of arrays as a parameter of the order
    property that we pass as the first parameter to the `findAll` method. The results
    are ordered by their creation date.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many other methods that Sequelize offers. You can query for just one
    entity, count them, find them, create them if they are not found, and much more.
    You can look up the methods that Sequelize provides at [https://sequelize.org/master/manual/model-querying-basics.html](https://sequelize.org/master/manual/model-querying-basics.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the server with `npm run server` and execute the GraphQL posts
    query from [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032), *Setting
    Up GraphQL with Express.js*, again. The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `id` and `text` fields look fine, but the `user` object is `null`. This
    happened because we did not define a user model or declare a relationship between
    the user and the post model. We will change this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one relationships in Sequelize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to associate each post with a user, to fill in the gap that we created
    in our GraphQL response. A post must have an author. It would not make sense to
    have a post without an associated user.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will generate a `User` model and migration. We will use the Sequelize
    CLI again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The migration file creates the `Users` table and adds the `avatar` and `username`
    columns. A data row looks like a post in our fake data, but it also includes an
    autogenerated ID and two timestamps, as you saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship of the users to their specific posts is still missing as we
    have only created the model and migration file. We still have to add the relationship
    between posts and users. This will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What every post needs is an extra field called `userId`. This column acts as
    the foreign key to reference a unique user. Then, we can join the user that's
    related to each post.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: MySQL offers great documentation for people that are not used to foreign key
    constraints. If you are one of them, you should read up on this topic at [https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the table structure with migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to write a third migration, adding the `userId` column to our `Post`
    table, but also including it in our database `Post` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a boilerplate migration file is very easy with the Sequelize CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can directly replace the content of the generated migration file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This migration is a bit more complex, and I will explain it on a step-by-step
    basis:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `up` migration, we are using `queryInterface` to add the `userId` column
    to the `Posts` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we are adding a foreign key constraint with the `addConstraint` function.
    This constraint represents the relationship between both the user and the post
    entities. The relationship is saved in the `userId` column of the `Post` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I experienced some issues when running the migrations without using `Promise.all`,
    which ensures that all the promises in the array are resolved. Returning only
    the array did not run both the `addColumn` and `addConstraint` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding `addConstraint` function receives the `foreign key` string as
    a `type`, which says that the data type is the same as the corresponding column
    in the `Users` table. We want to give our constraint the custom name `fk_user_id`
    to identify it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we are specifying the `references` field for the `userId` column. Sequelize
    requires a table, which is the `Users` table, and the field that our foreign key
    relates to, which is the `id` column of the `User` table. This is everything that
    is required to get a working database relationship.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, we are changing the `onUpdate` and `onDelete` constraints to `cascade`.
    What this means is that, when a user either gets deleted or has their user ID
    updated, the change is reflected in the user's posts. Deleting a user results
    in deleting all the posts of a user, while updating a user's ID updates the ID
    on all the user's posts. We do not need to handle all this in our application
    code, which would be inefficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is a lot more about this topic in the Sequelize documentation. If you
    want to read up on this, you can find more information at [https://sequelize.org/master/manual/query-interface.html](https://sequelize.org/master/manual/query-interface.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rerun the migration to see what changes occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of running migrations through Sequelize is that it goes through
    all the possible migrations from the `migrations` folder. It excludes those that
    are already saved inside the `SequelizeMeta` table, and then chronologically runs
    the migrations that are left. Sequelize can do this because the timestamp is included
    in every migration's filename.
  prefs: []
  type: TYPE_NORMAL
- en: After running the migration, there should be a `Users` table, and the `userId`
    column should have been added to the `Posts` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the relationship view of the `Posts` table in phpMyAdmin. You
    can find it under the **Structure** view, by clicking on **Relation view**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – MySQL foreign keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.06_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – MySQL foreign keys
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have our foreign key constraint. The correct name was taken,
    as well as the cascade option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you receive an error when running migrations, you can easily undo them,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This command undoes the most recent migrations. Always be conscious of what
    you do here. Keep a backup if you are unsure whether everything works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also revert all migrations at once, or only revert to one specific
    migration so that you can go back to a specific timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Leave out the `--to` parameter to undo all migrations.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have established the database relationship, but Sequelize must
    know about the relationship too. You will learn how this is done in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Model associations in Sequelize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the relationship configured with the foreign key, it needs
    to be configured inside our Sequelize model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `Post` model file and replace the `associate` function with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `associate` function gets evaluated inside our aggregating `index.js` file,
    where all the model files are imported.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `belongsTo` function here, which tells Sequelize that every
    post belongs to exactly one user. Sequelize gives us a new function on the `Post`
    model, called `getUser`, to retrieve the associated user. This naming is done
    by convention, as you can see. Sequelize does all this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not forget to add `userId` as a queryable field to the `Post` model itself,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User` model needs to implement the reverse association too. Add the following
    code to the `User` model file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `hasMany` function means the exact opposite of the `belongsTo` function.
    Every user can have multiple posts associated in the `Post` table. It can be anything,
    from zero to multiple posts.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare the new data layout with the preceding one. Up to this point,
    we had the posts and users inside one big array of objects. Now, we have split
    every object into two tables. Both tables connect through the foreign key. This
    is required every time we run the GraphQL query to get all the posts, including
    their authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we must extend our current `resolvers.js` file. Add the `Post` property
    to the `resolvers` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`RootQuery` and `RootMutation` were the two main properties that we''ve had
    so far. `RootQuery` is the starting point where all GraphQL queries begin.'
  prefs: []
  type: TYPE_NORMAL
- en: With the old demo posts, we were able to directly return a valid and complete
    response, since everything that we needed was in there already. Now, a second
    query, or a `JOIN`, is being executed to collect all the necessary data for a
    complete response.
  prefs: []
  type: TYPE_NORMAL
- en: The `Post` entity is introduced to our `resolvers`, where we can define functions
    for every property of our GraphQL schema. Only the user is missing in our response;
    the rest is there. That is why we have added the `user` function to the resolvers.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the function is the `post` model instance that we are
    returning inside the `RootQuery` resolver.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are using the `getUser` function that Sequelize gave us. Executing
    the `getUser` function runs the correct MySQL `SELECT` query to get the correct
    user from the `Users` table. It does not run a real MySQL `JOIN`; it only queries
    the user in a separate MySQL command. Later, in the *Chats and messages in GraphQL*
    section, you will learn about another way to run a `JOIN` directly, which is more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you query for all the posts via the GraphQL API, the user will still
    be `null`. We have not added any users to the database yet, so let's insert them
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding foreign key data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The challenge of adding users is that we have already introduced a foreign
    key constraint to the database. You can follow these instructions to learn how
    to get it working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must use the Sequelize CLI to generate an empty `seeders` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill in the following code to insert the fake users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code looks like the `seeders` file for the posts, but instead,
    we are now inserting users with the correct fields. Every user receives an auto-incremented
    ID by our MySQL server when inserting a user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must maintain the relationships that have been configured in our database.
    Adjust the `posts` seed file to reflect this and replace the `up` migration so
    that the correct user IDs are inserted for every post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using a raw MySQL query to get all the users and their IDs to insert
    them with our posts. This ensures that we have a valid foreign key relationship
    that MySQL allows us to insert.
  prefs: []
  type: TYPE_NORMAL
- en: The posts we have currently stored in our table do not receive a `userId`, and
    we do not want to write a separate migration or seed to fix those posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options here. You can either manually truncate the tables through
    phpMyAdmin and SQL statements, or you can use the Sequelize CLI. It is easier
    to use the CLI, but the result will be the same either way. The following command
    will undo all the seeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When undoing seeds, the tables are not truncated, so the `autoIncrement` index
    is not set back to one; instead, it stays at the current index. Reverting seeds
    multiple times raises the user's or post's ID, which stops the seeds from working.
    We have fixed this by using the raw MySQL query that retrieves the current user
    IDs before inserting the posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one problem before running our seeders again: we created the `users`
    seed file after the `post` seeders file. This means that the posts are inserted
    before the users exist, because of the timestamps of the files. Generally, this
    is not a problem, but since we have introduced a foreign key constraint, we are
    not able to insert posts with a `userId` when the underlying user does not exist
    in our database. MySQL forbids this. Simply adjust the timestamp of the fake user
    seed file so that it''s before the post seed file''s timestamp, or vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After renaming the files, run all the seeds with the following command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look inside your database, you should see a filled `Posts` table,
    including `userId`. The `Users` table should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Users table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.07_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The Users table
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can rerun the GraphQL query, and you should see a working association
    between the users and their posts because the `user` field is filled in.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have achieved a lot as we can serve data from our database through
    the GraphQL API by matching its schema.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are some ways to automate this process, through additional npm packages.
    There is a package that automates the process of creating a GraphQL schema from
    your database models for you. As always, you are more flexible when you do not
    rely on pre-configured packages. You can find the package at [https://www.npmjs.com/package/graphql-tools-sequelize](https://www.npmjs.com/package/graphql-tools-sequelize).
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data with Sequelize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Requesting data from our database via the GraphQL API works. Now comes the
    tough part: adding a new post to the `Posts` table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we must extract the new database model from the `db` object
    at the top of the exported function in our `resolvers.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Currently, we have no authentication to identify the user that is creating the
    post. We will fake this step until the authentication is implemented [*Chapter
    6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141), *Authentication with Apollo
    and React*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to edit the GraphQL resolvers to add the new post. Replace the old
    `addPost` function with the new one, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, the preceding mutation returns a promise. This promise is resolved
    when the deepest query has been executed successfully. The execution order is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve all the users from the database through the `User.findAll` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We insert the post into our database with the `create` function from Sequelize.
    The only property that we pass is the `post` object from the original request,
    which only holds the text of the post. MySQL autogenerates the `id` property of
    the post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sequelize also offers a `build` function, which initializes the model instance
    for us. In this case, we would have to run the `save` method to insert the model
    manually. The `create` function does this for us all at once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The post has been created, but `userId` has not been set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could also directly add the user ID to the `Post.create` function. The problem
    here is that we would not establish the model associations, even though this is
    reflected in the database. If we return the created post model without explicitly
    using `setUser` on the model instance, we cannot use the `getUser` function, which
    is used to return the user for the mutation's response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, to fix this problem, we must run the `create` function, resolve the promise,
    and then run `setUser` separately. As a parameter of `setUser`, we statically
    take the ID of the first user from the `users` array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We resolve the promise of the `setUser` function by using an array surrounded
    by `Promise.all`. This allows us to add further Sequelize methods later. For example,
    you could add a category to each post, too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have set `userId` correctly, the returned value is the newly created
    post model instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Everything is set now. To test our API, we are going to use Postman again.
    We need to change the `addPost` request. `userInput`, which we added previously,
    is not needed anymore, because the backend statically chooses the first user out
    of our database. You can send the following request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Your GraphQL schema must reflect this change, so remove `userInput` from there,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `addPost` GraphQL mutation now adds a post to the `Posts` table,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Post inserted into the database table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.08_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Post inserted into the database table
  prefs: []
  type: TYPE_NORMAL
- en: As we are not using the demo `posts` array anymore, you can remove it from the
    `resolvers.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have rebuilt the example from the previous chapter, but we are
    using a database in our backend. To extend our application, we are going to add
    two new entities called `Chat` and `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook provides users with various ways to interact. Currently, we only have
    the opportunity to request and insert posts. As is the case with Facebook, we
    want to have chats with our friends and colleagues. We will introduce two new
    entities to cover this.
  prefs: []
  type: TYPE_NORMAL
- en: The first entity is called `Chat`, while the second entity is called `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start the implementation, we need to lay out a detailed plan of what
    those entities will enable us to do.
  prefs: []
  type: TYPE_NORMAL
- en: A user can have multiple chats, and a chat can belong to multiple users. This
    relationship allows us to have group chats with multiple users, as well as private
    chats between only two users. A message belongs to one user, but every message
    also belongs to one chat.
  prefs: []
  type: TYPE_NORMAL
- en: Model and migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When transferring this into real code, we must generate the `Chat` model. The
    problem here is that we have a many-to-many relationship between users and chats.
    In MySQL, this kind of relationship requires a table to store the relationships
    between all the entities separately.
  prefs: []
  type: TYPE_NORMAL
- en: These tables are called `user_chats`. The user's ID and the chat's ID are associated
    with each other inside this table. If a user participates in multiple chats, they
    will have multiple rows in this table, with different chat IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Chat model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `Chat` model and migration. A chat itself does
    not store any data; we use it for grouping specific users'' messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the migration for our association table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust the `users_chats` migration that''s generated by the Sequelize CLI.
    We specify the user and chat IDs as attributes for our relationship. References
    inside a migration automatically create foreign key constraints for us. The migration
    file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A separate model file for the association table is not needed because we can
    rely on this table in the models where the association is required. The `id` column
    could be left out because the row can only be identified by the user and chat
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Associate the `User` model with the `Chat` model via the new relationship table
    in the `User` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for the `Chat` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `through` property tells Sequelize that the two models are related via the
    `users_chats` table. Normally, when you are not using Sequelize and are trying
    to select all users and chats merged in raw SQL, you need to maintain this association
    manually and join the three tables on your own. Sequelize's querying and association
    capabilities are so complex, so this is all done for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the migrations to let the changes take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what your database should look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Database structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.09_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Database structure
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see two foreign key constraints in the relationship view of the
    `users_chats` table. The naming is done automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Foreign keys for the users_chats table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Foreign keys for the users_chats table
  prefs: []
  type: TYPE_NORMAL
- en: This setup was the tough part. Next up is the message entity, which is a simple
    one-to-one relationship. One message belongs to one user and one chat.
  prefs: []
  type: TYPE_NORMAL
- en: Message model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A message is much like a post, except that it can only be read inside a chat
    and is not public to everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the model and migration file with the CLI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the missing references to the created migration file by replacing the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run the migrations again to create the `Messages` table using the
    `sequelize db:migrate` Terminal command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The references also apply to our model file, where we need to use Sequelize''s
    `belongsTo` function to get all those convenient model methods for our resolvers.
    Replace the `associate` function of the `Message` model with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined that every message is related to exactly one
    user and chat.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we must also associate the `Chat` model with the messages.
    Add the following code to the `associate` function of the `Chat` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to adjust our GraphQL API to provide chats and messages.
  prefs: []
  type: TYPE_NORMAL
- en: Chats and messages in GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have introduced some new entities with messages and chats. Let''s
    include those in our Apollo schema. In the following code, you can see an excerpt
    of the changed entities, fields, and parameters of our GraphQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following short changelog of our GraphQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: The `User` type received an `id` field, thanks to our database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Message` type is entirely new. It has a text field like a typical message,
    and user and chat fields, which are requested from the referenced tables in the
    database model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Chat` type is also new. A chat contains a list of messages that are returned
    as an array. These can be queried through the chat ID, which is saved in the message
    table. Furthermore, a chat has an unspecified number of users. The relationships
    between users and chats are saved in our separate **join table**. The interesting
    thing here is that our schema does not know anything about this table; it is just
    for our internal use to save the data appropriately in our MySQL server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have also added a new `RootQuery`, called `chats`. This query returns all
    the user's chats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These factors should be implemented in our resolvers too. Our resolvers should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the changes one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the `Message` property to our resolvers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `Chat` property to the `resolvers` object. There, we run the `getMessages`
    and `getUsers` functions, to retrieve all the joined data. All the messages are
    sorted by the ID in ascending order (to show the latest message at the bottom
    of a chat window, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I added the new `RootQuery`, called `chats`, to return all the fields, as in
    our schema:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a) Until we get a working authentication, we will statically use the first user
    when querying for all chats.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) We are using the `findAll` method of Sequelize and joining the users of any
    returned chat. For this, we use the `include` property of Sequelize on the `User`
    model within the `findAll` method. It runs a MySQL `JOIN`, not a second `SELECT`
    query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c) Setting the `include` statement to `required` runs an `INNER JOIN`, not a
    `LEFT OUTER JOIN`, by default. Any chat that does not match the condition in the
    `through` property is excluded. In our example, the condition is that the user
    ID must match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d) Lastly, we join all the available messages for each chat in the same way,
    without any condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must use the new models here. We should not forget to extract them from
    the `db.models` object inside the `resolver` function. It must look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You can send this GraphQL request to test the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The response should give us an empty `chats` array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This empty array was returned because we do not have any chats or messages in
    our database. You will learn how to fill it with data in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding many-to-many data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing our implementation requires data to be in our database. We have three
    new tables, so we will create three new seeders to get some test data to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the chats, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace the new seeder file with the following code. Running the following
    code creates a chat in our database. We do not need more than two timestamps because
    the chat ID is generated automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must insert the relationship between two users and the new chat. We
    can do this by creating two entries in the `users_chats` table where we reference
    them. Now, generate the boilerplate seed file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Our seed should look much like the previous ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `up` migration, we resolve all the users and chats using `Promise.all`.
    This ensures that, when the promise is resolved, all the chats and users are available
    at the same time. To test the chat functionality, we choose the first chat and
    the first two users that are returned from the database. We take their IDs and
    save them in our `users_chats` table. Those two users should be able to talk to
    each other through this one chat later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last table without any data in it is the `Messages` table. Generate the
    seed file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, replace the generated boilerplate code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now, all the seed files should be ready. It makes sense to empty all the tables
    before running the seeds so that you can work with clean data. I like to delete
    all the tables in the database from time to time and rerun all the migrations
    and seeds to test them from zero. Whether or not you are doing this, you should
    at least be able to run the new seed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to run the GraphQL `chats` query again. It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now, we can request all the chats that a user participates in and get
    all the referenced users and their messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we also want to do this for only one chat. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `RootQuery` chat that takes a `chatId` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this implementation, we have the problem that all the users can send a
    query to our Apollo Server and, in return, get the complete chat history, even
    if they are not referenced in the chat. We will not be able to fix this until
    we implement authentication later in [*Chapter 6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Authentication with Apollo and React*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the new query to the GraphQL schema, under `RootQuery`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the GraphQL request to test the implementation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are sending this query, including `chatId` as a parameter. To pass
    a parameter, you must define it in the query with its GraphQL data type. Then,
    you can set it in the specific GraphQL query that you are executing, which is
    the `chat` query. Lastly, you must insert the parameter's value into the `variables`
    field of the GraphQL request.
  prefs: []
  type: TYPE_NORMAL
- en: You may remember the response from the last time. The new response will look
    much like a result of the `chats` query, but instead of an array of chats, we
    will just have one `chat` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are missing a major feature: sending new messages or creating a new chat.
    We will create the corresponding schema, and the resolvers for it, in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new chat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New users want to chat with their friends, so creating a new chat is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to do this is to accept a list of user IDs so that we can allow
    group chats too. Do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `addChat` function to `RootMutation` in the `resolvers.js` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sequelize added the `setUsers` function to the chat model instance. It was added
    because of the associations using the `belongsToMany` method in the chat model.
    There, we can directly provide an array of user IDs that should be associated
    with the new chat, through the `users_chats` table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the schema so that you can run the GraphQL mutation. We must add the
    new input type and mutation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the new GraphQL `addChat` mutation as your request body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can verify that everything worked by checking the users that were returned
    inside the `chat` object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `addPost` mutation as our basis and extend it. The result accepts
    a `chatId` and uses the first user from our database. Later, the authentication
    will be the source of the user ID:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `addMessage` function to `RootMutation` in the `resolvers.js` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the new mutation to your GraphQL schema. We also have a new input
    type for our messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can send the request in the same way as the `addPost` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, everything is set. The client can now request all posts, chats, and messages.
    Furthermore, users can create new posts, create new chat rooms, and send chat
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal in this chapter was to create a working backend with a database as
    storage, which we have achieved pretty well. We can add further entities and migrate
    and seed them with Sequelize. Migrating our database changes won't be a problem
    for us when it comes to going into production.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also covered what Sequelize automates for us when using
    its models, and how great it works in coordination with our Apollo Server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on how to use the Apollo React Client library
    with our backend, as well as the database behind it.
  prefs: []
  type: TYPE_NORMAL
