- en: Dealing with Data and State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据和状态
- en: In this chapter, we will go one step further in structuring our application
    and work on the data architecture that serves as the base for our task management
    system. So far, we've obtained task data synchronously from the task service which
    we created in the previous chapter. However, in real-world scenarios, this will
    rarely be the case. In a real application, we would obtain data in an asynchronous
    way where we need to manage client state, and we need to ensure the integrity
    of our state and data at all times. In this chapter, we'll look at how we can
    restructure our application to deal with a RESTful interface using the HTTP client
    module which comes with Angular. We will use an in-memory database to simulate
    our HTTP backend. Furthermore, we will be looking at some critical concepts like
    reactive programming, immutability, and "pure" components to help us build a data
    architecture that shines on both a small as well as large scale.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步构建我们的应用程序结构，并专注于作为我们任务管理系统基础的数据架构。到目前为止，我们已经从我们在上一章中创建的任务服务同步获取了任务数据。然而，在现实世界的场景中，这种情况很少发生。在实际应用中，我们会以异步方式获取数据，我们需要管理客户端状态，并确保我们的状态和数据始终保持完整性。在本章中，我们将探讨如何重新构建我们的应用程序以使用
    Angular 中的 HTTP 客户端模块处理 RESTful 接口。我们将使用内存数据库来模拟我们的 HTTP 后端。此外，我们还将探讨一些关键概念，如响应式编程、不可变性和“纯”组件，以帮助我们构建一个在小规模和大规模上都能发光的数据架构。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Reactive programming, the basics of RxJS, and its operators to deal with asynchronous
    data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程、RxJS 的基础知识及其操作符，用于处理异步数据
- en: Restructuring our application to deal with simulated HTTP calls to an in-memory
    database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新构建我们的应用程序以处理对内存数据库的模拟 HTTP 调用
- en: The concept of immutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性的概念
- en: Using pure components in Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 中使用纯组件
- en: The introduction of container components to separate our user interface from
    application state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入容器组件以将我们的用户界面与应用程序状态分离
- en: Using `ChangeDetectionStrategy.OnPush` for pure components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为纯组件使用 `ChangeDetectionStrategy.OnPush`
- en: Reactive programming with RxJS
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJS 进行响应式编程
- en: So far, we have used simple array data structures in the task list that we created.
    That is not really what we'll find in real-world scenarios. In real applications,
    we have to deal with asynchronous data coming from a server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在创建的任务列表中使用了简单的数组数据结构。这并不是我们在现实世界场景中会遇到的。在实际应用中，我们必须处理来自服务器的异步数据。
- en: 'Handling data in applications behaves very similarly to streams. You take input,
    transform it, combine it, merge it, and finally, write it into the output. In
    systems such as this, it''s also very likely that input is in a continuous form
    and sometimes even of infinite duration. Just take a live feed as an example;
    this type of data flows continuously, and the data also flows infinitely. Functional
    and reactive programming are paradigms to help us deal with this kind of data
    more cleanly:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中处理数据的行为与流非常相似。你接收输入，转换它，组合它，合并它，最后将其写入输出。在这样的系统中，输入通常是连续的，有时甚至是无限期的。以实时流为例；这种类型的数据是连续流动的，数据也是无限流动的。函数式和响应式编程是帮助我们更干净地处理这类数据的范式：
- en: '![](img/857c6a52-fa81-44e7-ac6d-39dc549bc8fa.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/857c6a52-fa81-44e7-ac6d-39dc549bc8fa.png)'
- en: A simple observable subscription with value emission and a transformation
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的可观察订阅，带有值发射和转换
- en: Angular is reactive at its very core, and the whole change detection and bindings
    are built using a reactive architecture. The input and output of components, which
    we've learned about in the previous chapter, is nothing but a data flow that is
    established using a reactive event-driven approach. Angular uses RxJS, a functional
    and reactive programming library for JavaScript, to implement this data flow.
    In fact, the `EventEmitter`, which we've used to send output from within our components,
    is just a wrapper around a RxJS observable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 在其核心是响应式的，整个变更检测和绑定都是使用响应式架构构建的。我们在上一章中学到的组件的输入和输出，实际上就是一个使用响应式事件驱动方法建立的数据流。Angular
    使用 RxJS，这是一个用于 JavaScript 的函数式和响应式编程库，来实现这种数据流。实际上，我们用来从组件内部发送输出的 `EventEmitter`，只是
    RxJS 可观察对象的一个包装器。
- en: 'Before we mess around with RxJS within our task management system, let''s take
    a look at a straightforward RxJS example first to see how we can deal with observable
    streams in general:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在任务管理系统内玩弄 RxJS 之前，让我们先看看一个简单的 RxJS 示例，看看我们如何处理可观测流：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple script will generate an observable sequence from an array of numbers.
    We pass each number through the observable stream, item by item. We're using two
    simple operators before we subscribe to the observable and print the resulting
    items to the console. The map operator is squaring each number, which flows through
    the observable stream. The filter operator is then filtering out items which are
    greater or equal to `10`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本将从数字数组生成一个可观测序列。我们逐个将数字通过可观测流传递，使用两个简单的算子在我们订阅可观测量并打印结果到控制台之前。`map` 算子将每个数字平方，这些数字通过可观测流流动。然后，`filter`
    算子过滤掉大于或等于 `10` 的项。
- en: Observables provide a large number of so-called operators that allow you to
    transform the data stream that originated at the source observable. You might
    already know about some of these functional operators from the ECMAScript 5 array
    extra functions, such as `map` and `filter`. Using operators, you can model a
    whole transformation flow until you finally subscribe to the data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测量提供了一大批所谓的算子，这些算子允许你转换源自源可观测量的数据流。你可能已经从 ECMAScript 5 数组扩展函数中了解到一些这些函数算子，例如
    `map` 和 `filter`。使用算子，你可以模拟整个转换流程，直到你最终订阅数据。
- en: I often use the analogy of water pipes when talking about RxJS observables.
    If you think of your transformation operators as pieces within a pipeline, then
    the `subscribe` function is the final drain valve within the pipe. If you don't
    open the drain of a water pipe, no water will flow. The behaviour of RxJS is very
    similar. Without the final subscribe call, RxJS will not perform any of the operators.
    Only if you subscribe to an observable will it become active. Within the subscribe
    callback, you can then use the resulting items which flow through the stream.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常在谈论 RxJS 可观测量时使用水管的类比。如果你认为你的转换算子是管道中的部件，那么 `subscribe` 函数就是管道中的最终排水阀。如果你不打开水管的排水口，水就不会流动。RxJS
    的行为非常相似。如果没有最后的订阅调用，RxJS 不会执行任何算子。只有当你订阅一个可观测量时，它才会变得活跃。在订阅回调中，你可以使用通过流流动的结果项。
- en: Now, building pipelines come with a significant advantage. A transformation
    system which is built like a pipe is expecting input, and it will deliver some
    output. However, we don't perform anything immediately. Instead, we're setting
    up a system which knows how to deal with the data, when there's data flowing through
    it. This pipeline system is entirely stateless and reactive—reactive in the sense
    that it will react to incoming data and produce a new output of each input.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建管道带来了显著的优势。像管道一样构建的转换系统期待输入，并将产生一些输出。然而，我们不会立即执行任何操作。相反，我们正在设置一个系统，该系统知道如何处理通过它的数据，当有数据流动时。这个管道系统是完全无状态的并且是响应式的——响应式意味着它会对外来数据进行响应，并为每个输入产生新的输出。
- en: 'We can treat any source which emits items over time as an observable. Let''s
    take a look at another example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何随时间发出项的源视为可观测量。让我们看看另一个例子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we're using the `fromEvent` observable helper to create an
    observable source from the mouse move event on the window object. For each mouse
    move event, the event object will be emitted through the observable stream. We
    will then use the `throttleTime` operator to limit the amount of event emitted
    by the stream. This operator will block subsequent emissions within a given time
    frame, therefore throttling the steam. Within a `map` operator, we then format
    the emitted mouse event and finally subscribe to write the results to the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `fromEvent` 可观测量辅助函数从窗口对象的鼠标移动事件创建一个可观测源。对于每个鼠标移动事件，事件对象将通过可观测流发出。然后，我们将使用
    `throttleTime` 算子限制流发出的事件数量。这个算子将在给定的时间框架内阻止后续的发出，因此减缓了流。在 `map` 算子中，我们格式化发出的鼠标事件，并最终订阅将结果写入控制台。
- en: Using only a few lines of code, we've implemented an excellent little pipeline
    which transforms a source into a usable result. There lies the power of observables,
    reactive programming, and RxJS. We can solve difficult problems regarding building
    a reactive system in a very lovely and declarative way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用几行代码，我们就实现了一个优秀的管道，它将源转换成可用的结果。这就是观察者、响应式编程和 RxJS 的力量。我们可以以非常优雅和声明性的方式解决有关构建响应式系统的一些难题。
- en: HTTP client and in-memory web APIs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 客户端和内存中的 Web API
- en: At the beginning of this chapter, we decided that we'd like to change the way
    how we handle data within our application. Currently, our task data is embedded
    within our task service and retrieving as well as manipulating are both happening
    synchronously. Going forward, we want to change that and come as close as possible
    to a real-world situation. At the same time, we should keep an eye on the complexity
    costs of our solution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们决定我们想要改变我们在应用程序中处理数据的方式。目前，我们的任务数据嵌入在我们的任务服务中，检索以及操作都是同步发生的。从现在开始，我们想要改变这一点，尽可能接近现实世界的情况。同时，我们还应该关注我们解决方案的复杂性成本。
- en: Angular comes with a very nice utility for these use cases. Using the in-memory
    web API module, we can create a mock back-end service which will allow us to use
    a RESTful interface the same way as if we would connected to a real server. All
    remote calls using the Angular HTTP client will, however, be redirected to our
    local in-memory database. The way we deal with our data will be entirely authentic.
    At some point, we could even create a real backend server and connect our application
    to it, while our frontend code would stay the same.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 为这些用例提供了一个非常棒的实用工具。使用内存中的 Web API 模块，我们可以创建一个模拟的后端服务，这将允许我们以连接到真实服务器相同的方式使用
    RESTful 接口。然而，所有使用 Angular HTTP 客户端进行的远程调用都将重定向到我们的本地内存数据库。我们处理数据的方式将完全真实。在某个时候，我们甚至可以创建一个真正的后端服务器，并将我们的应用程序连接到它，同时我们的前端代码保持不变。
- en: 'Let''s look into the necessary changes in order to implement our data layer
    using the in-memory web API. As a first step, we need to install the package using
    npm. Open a command line and navigate to your project directory. Then, execute
    the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现我们的数据层所需的内存中 Web API 的必要更改。作为第一步，我们需要使用 npm 安装该包。打开命令行并导航到您的项目目录。然后，执行以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this command will install the in-memory web API package and save it
    to our project `package.json` file. As a next step, we want to create our application''s
    in-memory database. We''re creating a new TypeScript file on the path `src/app/database.ts`
    and adding the following content:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将安装内存中的 Web API 包并将其保存到我们的项目 `package.json` 文件中。作为下一步，我们想要创建我们应用程序的内存数据库。我们在路径
    `src/app/database.ts` 上创建一个新的 TypeScript 文件，并添加以下内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the Angular in-memory web API, we can create a class which holds all our
    initial data. The class is implementing the `InMemoryDbService` interface, which
    demands that we create a method named `createDb`. Within this function, we can
    create resources which will be made available for use with the Angular HTTP client
    in a RESTful style.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 内存中的 Web API，我们可以创建一个类来存储所有初始数据。这个类实现了 `InMemoryDbService` 接口，要求我们创建一个名为
    `createDb` 的方法。在这个函数中，我们可以创建资源，这些资源将以 RESTful 风格提供给 Angular HTTP 客户端使用。
- en: 'Next, we''re going to update our main application module located in the path
    `src/app/app.module.ts`, and set up our application for using the in-memory web
    API with our newly created database. You should only add the highlighted parts
    of the following code excerpt. The ellipsis character is indicating that there''s
    more code existing, which is irrelevant for the changes you need to apply to your
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新位于路径 `src/app/app.module.ts` 的主应用程序模块，并设置应用程序以使用我们新创建的内存中的 Web API
    和数据库。你应该只添加以下代码摘录中突出显示的部分。省略号字符表示存在更多代码，但这些代码对你需要应用到代码中的更改不相关：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've added two more modules to the import section of our main application module.
    We've added the Angular HTTP client module which we'll use to call our simulated
    REST endpoint in our database. As discussed earlier, this library would also be
    used in the same way if we were to call a remote server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的主应用程序模块的导入部分添加了两个额外的模块。我们添加了 Angular HTTP 客户端模块，我们将使用它来调用数据库中的模拟 REST
    端点。如前所述，如果我们要调用远程服务器，这个库也会以相同的方式使用。
- en: The second module we are importing is the HTTP client adapter of the in-memory
    web API module. This module will intercept all HTTP calls executed by the Angular
    HTTP client and redirect the requests to our local database. We're using the factory
    method `HttpClientInMemoryWebApiModule.forRoot` to configure the adapter module
    before we import it. In the first argument to the factory function, we're passing
    the database class we've created. In the second argument, we can provide some
    additional options for the adapter. In our case, we're setting the delay to zero.
    Using higher values will artificially delay the responses from our database, which
    is nice if you want to simulate a network delay.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入的第二个模块是内存中 Web API 模块的 HTTP 客户端适配器。此模块将拦截 Angular HTTP 客户端执行的所有 HTTP 调用，并将请求重定向到我们的本地数据库。我们使用工厂方法`HttpClientInMemoryWebApiModule.forRoot`在导入之前配置适配器模块。在工厂函数的第一个参数中，我们传递我们创建的数据库类。在第二个参数中，我们可以为适配器提供一些额外的选项。在我们的例子中，我们将延迟设置为零。使用更高的值将人为地延迟数据库的响应，如果你想要模拟网络延迟，这会很有用。
- en: Using behaviour subjects
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用行为主题
- en: 'The HTTP client is using RxJS to return observable streams for all HTTP request
    methods. The response body will then be emitted through the observable streams,
    and we can subscribe to the streams to retrieve the results:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端正在使用 RxJS 为所有 HTTP 请求方法返回可观察流。响应体将通过可观察流发射，我们可以订阅这些流以检索结果：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since we know how to deal with observable streams within our components, we
    could go ahead and directly return the observable resulting from the HTTP client
    call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道如何在组件中处理可观察流，我们可以继续直接返回 HTTP 客户端调用产生的可观察流。
- en: 'However, instead, we want to make use of a RxJS class called `BehaviorSubject`.
    The problem with directly returning the observable from the HTTP client is that
    we''re always returning a new observable when the tasks are loaded from the server.
    That would be impractical, and after reloading tasks when performing updates or
    adding new tasks, we''d like to be able to reuse the same observable stream to
    re-emit the updated task list. This way, all components of our system will be
    notified when we reload our tasks. You can use a behaviour subject whenever you
    want to create your own source of an observable stream. You can control what should
    be emitted and when. Let''s look at a simplified example of how a behaviour subject
    can be used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相反，我们想要利用一个名为`BehaviorSubject`的 RxJS 类。直接从 HTTP 客户端返回可观察流的问题在于，当任务从服务器加载时，我们总是返回一个新的可观察流。这将是不可行的，并且在重新加载任务以执行更新或添加新任务后，我们希望能够重用相同的可观察流来重新发射更新的任务列表。这样，当我们的任务重新加载时，系统中的所有组件都将被通知。你可以使用行为主题来创建自己的可观察流源。你可以控制应该发射什么以及何时发射。让我们看看一个简化的例子，看看如何使用行为主题：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within the constructor of a behaviour subject, we can specify the initial value
    or item which will be emitted initially to all subscribers. Behaviour subjects
    are also always emitting the most recent item they have to their new subscribers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为主题的构造函数中，我们可以指定初始值或项目，这些值或项目将被最初发射给所有订阅者。行为主题也总是向新订阅者发射它们最新的项目。
- en: A behaviour subject is both an observer as well as an observable. Therefore,
    it would be possible to directly call the `subscribe` method on the subject. However,
    if you'd like to convert your subject into a plain observable again, you can use
    the `asObservable` method. This is especially useful for encapsulation. When you're
    returning your observable stream to be used outside of your immediate program
    logic, you don't want to give the outside world the power to emit items. It should
    only be possible to observe the stream.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 行为主题既是观察者也是可观察的。因此，你可以在主题上直接调用`subscribe`方法。然而，如果你想将你的主题再次转换为普通的可观察流，你可以使用`asObservable`方法。这对于封装特别有用。当你返回你的可观察流以在你的程序逻辑之外使用时，你不想给外部世界发射项目的权力。应该只能观察流。
- en: Finally, whenever you want to emit a new item through the observable stream,
    you can use the `next` method on the subject.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论何时你想通过可观察流发射新的项目，你都可以在主题上使用`next`方法。
- en: Loading data in the task service
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在任务服务中加载数据
- en: 'It''s time to change our task service and make use of the Angular HTTP client
    to obtain the task data from our database. Let''s open up the `src/app/tasks/task.service.ts`
    file and change the file content to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候改变我们的任务服务并利用 Angular HTTP 客户端从我们的数据库中获取任务数据了。让我们打开`src/app/tasks/task.service.ts`文件，并将文件内容更改为以下内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are injecting the Angular HTTP client into our constructor so we can use
    it within our service. In the `loadTasks` method, we're executing a GET call on
    the RESTful tasks resource which is provided by our database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的构造函数中注入Angular HTTP客户端，以便我们可以在服务中使用它。在`loadTasks`方法中，我们正在对由我们的数据库提供的RESTful任务资源执行GET调用。
- en: The `tasks` member of our service is holding a behaviour subject which is initialised
    with an empty array. Whenever we call the internal `loadTasks` method, the resulting
    task list array is emitted through our behaviour subject by calling the next method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的`tasks`成员持有初始化为空数组的行为主题。每次我们调用内部的`loadTasks`方法时，结果的任务列表数组将通过调用`next`方法通过我们的行为主题发出。
- en: The `loadTasks` method is first called within the service constructor. That
    will ensure that the resulting task list obtained from the HTTP call is initially
    emitted through our behaviour subject. We also call the `loadTasks` method right
    after we've completed the POST requests within the `addTask` and `updateTask`
    methods. That will guarantee that we're reloading the updated task list from the
    "server" and emitting it through our behaviour subject.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTasks`方法首先在服务构造函数中被调用。这将确保从HTTP调用中获得的结果任务列表最初通过我们的行为主题发出。我们还在`addTask`和`updateTask`方法完成POST请求后调用`loadTasks`方法。这将保证我们从“服务器”重新加载更新后的任务列表并通过我们的行为主题发出。'
- en: Within the `getTasks` method, we're converting our subject to an observable
    and returning it. This way, we can ensure that no one outside of the service will
    have the power to emit items through our subject. Using the observable of our
    behaviour subject, we can have hundreds of components subscribing, which will
    all receive the most recent task list whenever there is a change in our data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getTasks`方法中，我们将主题转换为可观察对象并返回它。这样，我们可以确保服务外部没有人有权力通过我们的主题发出项。使用行为主题的可观察对象，我们可以有数百个组件订阅，当数据发生变化时，所有这些组件都将接收到最新的任务列表。
- en: The in-memory web API will automatically generate IDs for our tasks when we
    add new tasks by executing a post request to the tasks resource. This means that
    when we call the `addTask` method with a task object, we can skip adding the ID
    property and the in-memory database will take care of finding the next possible
    ID value for us.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过向任务资源执行POST请求添加新任务时，内存中的Web API将自动为我们生成任务ID。这意味着当我们用任务对象调用`addTask`方法时，我们可以跳过添加ID属性，内存数据库将为我们找到下一个可能的ID值。
- en: 'Now, let''s use our updated task service in the task list component. Open up
    the `src/app/tasks/task-list/task-list.component.ts` file and apply the following
    changes. Again, effective changes are in bold:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的任务列表组件中使用更新的任务服务。打开`src/app/tasks/task-list/task-list.component.ts`文件并应用以下更改。同样，有效的更改以粗体显示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have changed the type of our `tasks` member, which is now holding an observable
    with a task array generic type. In TypeScript, RxJS makes use of generics to specify
    what type of items will be emitted through the observable stream. The `tasks`
    member will store the observable stream which we obtain by calling our task service.
    It will make the basis for our filtering inside of the component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了`tasks`成员的类型，现在它持有带有任务数组泛型类型的可观察对象。在TypeScript中，RxJS使用泛型来指定将通过可观察流发出的项的类型。`tasks`成员将存储我们通过调用任务服务获得的可观察流，它将成为我们在组件内部过滤的基础。
- en: In the constructor of our task list component, we're still calling the `getTasks`
    method of our service. However, this time, we won't receive a list of tasks synchronously.
    Instead, we're an observable stream which will emit a list of tasks when we subscribe.
    Since we're using a behaviour subject inside of the task service, we will never
    need to call the task service again to obtain tasks. If there are updates to the
    task list data, we will receive a new item through the connected observable stream
    containing the most recent task list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务列表组件构造函数中，我们仍然在调用我们的服务中的`getTasks`方法。然而，这次，我们不会同步接收到任务列表。相反，我们是一个可观察的流，当订阅时将发出任务列表。由于我们在任务服务内部使用了一个行为主题，我们将永远不需要再次调用任务服务来获取任务。如果任务列表数据有更新，我们将通过连接的可观察流接收到一个新项目，其中包含最新的任务列表。
- en: We have also changed our `activeTaskFilterType` member to a behavior subject.
    That will help us in building a consistent reactive data flow within our component.
    Instead of storing the active filter type directly, we're using a subject to emit
    the filter type. Within the `activateFilterType` method, we do precisely this.
    When this method is called from our view, as a filter toggle button is clicked,
    we will emit the new active filter type using the behavior subject.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Our `tasks` observable will always emit the latest list when the underlying
    data is changed. Also, the `activeTaskFilterType` subject is emitting an item
    when we change the active task filter. Now, we can combine both streams to implement
    our filter logic reactively. Again, think of a pipeline system. Instead of filtering
    immediately, we are building a network of pipes which will filter whenever new
    data arrives. So, how can we combine two observable streams into one? There are
    many ways to do this using the broad variety of operators RxJS provides. However,
    in our current situation, the `combineLatest` operator will work best.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a small illustration of how this operator combines multiple
    observable streams into one single observable stream:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66f0af12-df90-4861-bc4d-68c8203391a4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Combining two observables into one by using the combineLatest operator
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The `combineLatest` operator is combining two or more input observables into
    a single output observable. The first item will be emitted on the output observable
    when all input observables have emitted at least one item. The emitted item on
    the output observable is always an array which contains the most recent, or latest
    items of all input observables. In the preceding example, you can see that the
    first item is emitted when **Observable 2** emits its item labelled with **(a)**.
    The emitted item is an array containing both values **(1)** from **Observable
    1** and **(a)** from **Observable 2**. After the first combined item was emitted,
    if one of the input streams is emitting a new item, the output observable by `combineLatest`
    will emit an updated item which again contains the latest items of all input observables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the behaviour we're looking for when we're building our filter
    observable. Just switch **Observable 1** from the preceding example with our tasks
    observable and **Observable 2** with our active filter type. Now, if we either
    input an observable, the tasks observable, the active filter subject, or emit
    a new item, our filtered output observable will also produce a new item. This
    is reactive programming at its best. We never need to be concerned about updating
    our state anymore. It's all taken care of using reactive streams.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Since `combineLatest` will just produce an array of all the latest values emitted
    by the input observables, we need to use an additional map operator to provide
    the desired filtered list output. We're destructuring the value pair emitted by
    `combineLatest` into a `tasks` and `activeTaskFilterType` variable and performing
    the filtering based on that data. The resulting filtered list is returned and
    will be emitted by the output observable of the map operator.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `combineLatest` 只会生成由输入可观察对象发出的所有最新值的数组，我们需要使用一个额外的 `map` 操作符来提供所需的过滤列表输出。我们将
    `combineLatest` 发出的值对解构为 `tasks` 和 `activeTaskFilterType` 变量，并根据该数据进行过滤。结果过滤列表被返回，并将由
    `map` 操作符的输出可观察对象发出。
- en: Subscribing in the view using the async pipe
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步管道在视图中订阅
- en: We have learned about RxJS observables and that they will not start to emit
    items if we don't subscribe to them. You can compare this to the analogy of the
    drain valve of a water pipe. If you don't open the drain, the water will not flow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 RxJS 的可观察对象，并且知道如果我们不订阅它们，它们就不会开始发出项目。你可以将这个类比于水管排水阀。如果你不打开排水阀，水就不会流动。
- en: Within our updated task list component, we now have a `filteredTasks` observable
    to which we can subscribe to and obtain the latest filtered tasks. However, there's
    a slightly better way to handle RxJS subscriptions, which we're going to take
    a look at now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新的任务列表组件中，我们现在有一个 `filteredTasks` 可观察对象，我们可以订阅它并获取最新的过滤后的任务。然而，处理 RxJS 订阅有一个稍微更好的方法，我们现在将要看看。
- en: The problem with subscriptions is that they always want to be cleaned up too.
    Imagine your subscription is causing many event handlers to be added and other
    resources which might get allocated for observing your stream. Calling the `subscribe`
    method will return a subscription object, and on that subscription object, you
    will find a method called `unsubscribe`. Usually, it's always a good idea to call
    this method when you don't need the observable subscription anymore. In the case
    of Angular components, we can say that when a component gets removed from the
    view, it's a good time to clean up the observable subscriptions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅的问题在于它们总是想要被清理。想象一下，你的订阅正在导致许多事件处理程序被添加，以及其他可能为观察你的流而分配的资源。调用 `subscribe`
    方法将返回一个订阅对象，在该订阅对象上，你会找到一个名为 `unsubscribe` 的方法。通常，当你不再需要可观察对象订阅时，调用这个方法总是一个好主意。在
    Angular 组件的情况下，我们可以这样说，当组件从视图中移除时，清理可观察对象订阅是一个好时机。
- en: 'Luckily, there''s a life cycle hook called `OnDestroy` for detecting when a
    component is removed from the view. We can use this hook to clean up any subscriptions
    to RxJS observables. Let''s take a look at a straightforward example of a component
    subscribing to an observable and unsubscribing within the `OnDestroy` life cycle
    hook:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为 `OnDestroy` 的生命周期钩子，用于检测组件何时从视图中移除。我们可以使用这个钩子来清理对 RxJS 可观察对象的任何订阅。让我们看看一个组件在
    `OnDestroy` 生命周期钩子中订阅可观察对象并取消订阅的简单示例：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding example, we''re creating an observable stream from the mouse
    move events on the window object. All we''d like to do is display the most recent
    mouse position, which was emitted by the observable stream, within our component
    view. You can immediately see that this is quite a bit of code just for dealing
    with one observable. We need to store three things for each observable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们正在从窗口对象的鼠标移动事件创建一个可观察对象流。我们想要做的只是显示由可观察对象流发出的最新鼠标位置，在我们的组件视图中。你可以立即看到，仅仅为了处理一个可观察对象，就需要编写大量的代码。对于每个可观察对象，我们需要存储三件事：
- en: The observable itself
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象本身
- en: A property to store the most recent emitted item by the stream
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于存储流最近发出的项目的属性
- en: The subscription object which allows us to unsubscribe and clean up when our
    component gets destroyed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅对象，允许我们在组件被销毁时取消订阅并清理
- en: This might be okay if we're only dealing with one single observable, however,
    imagine if your component needs to deal with several observables at the same time.
    This is going to be quite a mess.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只处理一个单一的可观察对象，这可能没问题，但是想象一下，如果你的组件需要同时处理多个可观察对象。这将变得相当混乱。
- en: Another problematic thing is that we need to manually unsubscribe when our component
    gets destroyed using the `OnDestroy` life cycle hook. This is a manual, error-prone
    process and we can lose track over our subscriptions quite easily.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们需要手动使用 `OnDestroy` 生命周期钩子来取消组件的订阅。这是一个手动且容易出错的流程，我们很容易就会失去对订阅的跟踪。
- en: Luckily, Angular comes with a genius solution for this problem. Instead of dealing
    with the subscription manually, we will use a view pipe with the name `AsyncPipe`
    to subscribe directly within the view of our component. This means that we don't
    need to subscribe in our component class and extract the latest emitted item manually.
    Instead, the async pipe will extract the item for us and update our view automatically
    whenever there's a new item coming through the stream. The async pipe will also
    store the subscription internally and automatically unsubscribe for us if it detects
    that the component has been destroyed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Angular 为这个问题提供了一个天才的解决方案。我们不需要手动处理订阅，我们将使用一个名为 `AsyncPipe` 的视图管道直接在我们的组件视图中进行订阅。这意味着我们不需要在我们的组件类中进行订阅并手动提取最新发出的项目。相反，异步管道将为我们提取项目，并在有新项目通过流传入时自动更新我们的视图。异步管道还将内部存储订阅，并在检测到组件已被销毁时自动为我们取消订阅。
- en: 'Let''s look at the same example from before, but now using the async pipe.
    The component class would look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前的相同示例，但现在使用异步管道。组件类将看起来像这样：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Wow! That''s a radical simplification, isn''t it? All we need to store now
    is the observable itself. Extracting the latest emitted item as well as unsubscribing
    from the stream is all handled by the async pipe. Let''s take a look at how we
    would need to change our view to use the async pipe:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是一个激进的简化，不是吗？我们现在只需要存储可观察对象本身。提取最新发出的项目以及从流中取消订阅都由异步管道处理。让我们看看我们如何需要更改我们的视图来使用异步管道：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How cool is that! By only using the async pipe in our view, we can create a
    subscription to the observable, render the latest item emitted by the stream,
    and unsubscribe when our component gets destroyed. Additionally, from a functional
    and reactive standpoint, we also enhanced our code in a way that we don't create
    any side effects within our component class. We don't hold any intermediate state,
    and all we store is the observable stream itself. The async pipe is an excellent
    addition to your toolset when dealing with asynchronous data, and you should always
    make use of it when working with RxJS observables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷！仅通过在我们的视图中使用异步管道，我们就可以创建对可观察对象的订阅，渲染流发出的最新项目，并在我们的组件被销毁时取消订阅。此外，从功能和响应式角度来看，我们还以我们不在我们的组件类中创建任何副作用的方式增强了我们的代码。我们不保留任何中间状态，我们存储的只是可观察对象流本身。异步管道是处理异步数据时你工具集的一个优秀补充，你应该始终在工作与
    RxJS 可观察对象一起时使用它。
- en: Okay, I hope you felt the power and simplicity of using the async pipe within
    the previous example. Now, we'll use that knowledge and refactor our task list
    component to use the async pipe to subscribe to our observables within the component
    view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我希望你感受到了在前一个示例中使用异步管道的强大和简单。现在，我们将使用这些知识重构我们的任务列表组件，以便在组件视图中使用异步管道来订阅我们的可观察对象。
- en: 'Since we''ve already updated our component logic to expose an observable to
    emit our filtered task list, we can go directly to the view of our task list component
    and apply the changes to use the async pipe. Let''s open the `src/app/tasks/task-list/task-list.component.html`
    file and implement the following changes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更新了我们的组件逻辑以公开一个可观察对象来发出我们的过滤任务列表，我们可以直接进入我们的任务列表组件视图并应用更改以使用异步管道。让我们打开`src/app/tasks/task-list/task-list.component.html`文件并实现以下更改：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've added two async pipes. The first one is to subscribe to our `activeTaskFilterType`
    behaviour subject. The async pipe will create a subscription directly from the
    view, and it will update our binding automatically whenever there's a new item
    emitted through the stream.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个异步管道。第一个是订阅我们的 `activeTaskFilterType` 行为主题。异步管道将直接从视图创建订阅，并且每当有新项目通过流发出时，它将自动更新我们的绑定。
- en: The second async pipe is used directly in the binding of the `NgFor` directive.
    We're subscribing to our `filteredTasks` observable, which will always emit the
    latest result of our filtered task list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个异步管道直接用于 `NgFor` 指令的绑定。我们正在订阅我们的 `filteredTasks` 可观察对象，它将始终发出过滤任务列表的最新结果。
- en: Recap
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Congratulations! We''ve successfully updated our code to establish a reactive
    data flow within our application using the in-memory web API and the Angular HTTP
    client. We are using RxJS observables, transforming them using operators, and
    resolving our data directly within the view using the Angular async pipe. This
    refactoring was quite a technical but significant change. We''re now following
    a very clean approach on how to react to application state changes. Our observable
    streams are router down directly into the view where we then subscribe using the
    async pipe. If Angular destroys our task list component, the async pipe will also
    take care of the necessary unsubscriptions. We''ve learned about the following
    topics:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The Angular in-memory API to simulate a RESTful backend and using HTTP client
    to obtain data
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJS basics, basic operators, as well as behaviour subject and the `combineLatest`
    operator
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the async pipe to subscribe from the view of our components
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing an end-to-end reactive data architecture within our application
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this section, we're going to learn about the concept of immutability.
    This knowledge will help us for the upcoming refactoring exercises of our application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data has initially been a core concept of functional programming.
    This section will not cover immutable data in much depth, but it will explain
    the core concept so that we can talk about how to apply this idea to Angular components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data structures force you to create a full copy of the data before
    you modify it. You'll never operate on the data directly, but on a copy of this
    same data. This approach has many benefits over mutable data operations, the most
    obvious probably being clean application state management. When you always operate
    on new copies of data, there's no chance that you're messing up data that you
    didn't want to modify.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take this simple example, which illustrates the issues object references
    can cause:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although this seems odd at first, it makes sense that the output of this case
    is valid. `Array.reverse()` is a mutable operation, and it will modify the innards
    of the array. The actual reference will stay the same because JavaScript will
    not create a copy of the array to reverse it. Although technically this makes
    a lot of sense, this is not what we expected in the first place when we looked
    at this code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'We can quickly change this example to an immutable procedure by creating a
    copy of the array before we reverse it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The issue with references is that they can cause a lot of unexpected side effects.
    Also, if we come back to our encapsulation topic from [Chapter 1](237031a7-f616-4811-8486-08b5113d316f.xhtml),
    *Component-Based User Interfaces*, object references are entirely against the
    concept of encapsulation. Although we might think that it would be safe to pass
    complex data types into a capsule, it''s not. As we''re dealing with references
    here, the data can still be modified from the outside, and our capsule will not
    have complete ownership. Consider the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even if we only wanted to store the data internally in our `Sum` class, we would
    have created the unwanted side effect of referencing and modifying the data object
    which is outside the instance. Multiple `sum` instances would also share the same
    data from outside and cause more side effects. As a developer, you've learned
    to treat object references correct, but they still can cause a lot of problems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have these problems with immutable data, which can be illustrated
    easily with primitive data types in JavaScript. Primitive data types don''t use
    references, and they are immutable by design:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's no way we can modify an instance of a string. Every modification that
    we perform on a string will generate a new string, and this prevents the unwanted
    side effects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: So, why do we still have object references within programming languages, even
    though they cause so many issues? Why aren't we performing all these operations
    on immutable data, and why aren't we only dealing with values rather than object
    references?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Of course, mutable data structures also come with their benefits, and it always
    depends on the context if immutable data brings value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: One of the main reasons that is often used against immutable data is its lousy
    performance. Of course, it costs some performance if we need to create tons of
    copies of our data every time we want to modify it. However, there are significant
    optimization techniques which eliminate the performance issues that we would usually
    expect from immutable data structures. Using a tree data structure that allows
    internal structural sharing, copies of the data will be shared internally. This
    technique allows for very efficient memory management, which in some situations
    even outperforms mutable data structures. I can highly recommend the paper by
    Chris Okasaki about *Purely Functional Data Structures* if you would like to read
    more about performance in immutable data structures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript does not support immutable data structures out of the box. However,
    you can use libraries, such as `Immutable.js` by Facebook, which provide you with
    an excellent API to deal with immutable data. `Immutable.js` even implements structural
    sharing and makes it a perfect power tool if you decide to build on an immutable
    architecture in your application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'As with every paradigm, there are pros and cons, and depending on the context,
    one concept may fit better than another one. In our application, we won''t use
    immutable data structures that are provided by third-party libraries, but we''ll
    borrow some of the benefits that you get from immutable data by going by the following
    immutable idioms:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s much easier to reason about immutable data**: You can always tell why
    your data is in a given state because you know the exact transformation path.
    This may sound irrelevant, but in practice, this is a huge benefit not only for
    humans to write code but also for compilers and interpreters to optimize it.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using immutable objects makes change detection much faster**: If we rely
    on immutable patterns to treat our data, we can rely on object reference checks
    to detect change. We no longer need to perform complex data analysis and comparison
    for dirty checking, and can fully rely on checking references. We have the guarantee
    that object properties don''t change without the object identity changing as well.
    This makes change detection as easy as `oldObject === newObject`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability with TypeScript
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With TypeScript 2, new type features were added which help you to embrace immutable
    operations. Using the `readonly` type modifier, we can achieve a compile-time
    immutability guard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example of how to use the `readonly` modifier
    to define some immutable data structures:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see from the preceding example, we can use the `readonly` modifier
    to prevent object properties from being modified. Instead, if we''d like to modify
    the `person` object, we''ll need to create a copy of that object. There are many
    ways to do this, however, using the object property spread operator is probably
    the most convenient of all. Let''s see how we can update our person object in
    an immutable way using the object property spread operator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the object property spread operator, we can spread all existing properties
    and their values of the existing person object into a new object literal. In the
    same step, we can then override any properties, right after the spread operation.
    This allows us to easily create a copy of an existing object and add or override
    specific properties. The preceding code could also be written by using `Object.assign`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Actually, this is how the object spread operator is desugaring to JavaScript.
    However, it's much more convenient to use the spread operator than `Object.assign`.
    The object spread operator is proposed to the future JavaScript standard and is
    currently at stage 3.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Pure components
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of a "pure" component is that its whole state is represented by its
    inputs, where all inputs are immutable. This is effectively a stateless component,
    but additionally, all the inputs are immutable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'I like to call such components "pure" because their behaviour can be compared
    to the concept of pure functions in functional programming. A pure function is
    a function which has the following properties:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: It does not rely on any state outside of the function scope
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always behaves the same and returns the same result if input parameters don't
    change
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It never changes any state outside the function scope (side effect)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With pure components, we have a simple guarantee. A pure component will never
    change without its input parameters being changed. Sticking to this idea about
    components gives us several advantages. Besides having a complete trust in your
    component state, we can also gain some performance benefits by optimizing the
    change detection of Angular. We know that a component will render exactly the
    same if its inputs don't change. This means that we can ignore all components
    and their subcomponents in change detection if there are no input changes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very easy to reason about pure components. Their behaviour can be predicted
    very easily. Let''s look at a simple illustration of a component tree with only
    pure components:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ecbe63d-591d-4b00-9fff-f10b11700f8a.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: A component tree with immutable components
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Usually, Angular performs change detection for every single binding in all of
    your components within the component tree. It does that on every browser event,
    which could change your system state. This eventually comes with a large performance
    overhead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have the guarantee that each component in our tree has a stable state
    until an immutable input property changes, we can safely ignore change detection
    that would usually be triggered by Angular. The only way that such a component
    could change is if an input of the component changes. Let''s say that there''s
    an event that causes the root component (**A**) to change the input binding value
    of component (**B**), which will change the value of a binding on component (**E**).
    This event and the resulting procedure would mark a certain path in our component
    tree to be checked by change detection:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53dd7069-784c-4b89-8b69-541b23283468.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: A marked path for change detection (in black) with "pure" components
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Although the state of the root component changed, which also changed input properties
    of the subcomponents on two levels, we only need to be concerned about a given
    path when thinking about possible changes in the system. Pure components give
    us the promise that they will not change if their inputs don't change. Immutability
    plays a big role here. Imagine that you're binding a mutable object to component
    (**B**), and component (**A**) would change a property of this object. As we use
    object references and mutable objects, the property would also be changed for
    component (**B**). However, there's no way for component (**B**) to notice this
    change and it would leave our component tree in an unstable state. Basically,
    we'd need to go back to the regular dirty checking of the whole tree again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: By knowing that all our components are pure and that their inputs are immutable,
    we can tell Angular to disable change detection until an input property value
    changes. This makes our component tree very efficient, and Angular can optimize
    change detection effectively. When thinking about large component trees, this
    can make the difference between a stunningly fast application and a slow one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The change detection of Angular is very flexible, and each component gets its
    own change detector. We can configure the change detection of a component by specifying
    the `changeDetection` property of the component decorator.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Using `ChangeDetectionStrategy`, we can choose from two strategies that apply
    for the change detection of our component. In order to tell Angular that our component
    should only be checked if an immutable input was changed, we can use the `OnPush`
    strategy. This change detection mode is specifically designed for the purpose
    of pure components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the two different configuration possibilities of component
    change-detection strategies and some possible use cases:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '| **Change-detection strategy** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `OnPush` | This strategy tells Angular that a given component subtree will
    only change under one of the following conditions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: One of the input properties changes where changes need to be immutable. Inputs
    are always checked for reference changes (using the triple-equals operator `===`)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event binding within the component subtree is receiving an event. This condition
    tells Angular that there might be a change inside of the component itself and
    it will trigger change detection, even if none of the inputs have changed.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '| Default | The default strategy of Angular''s change detection will perform
    change detection for every single browser event which occurs within your application.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: Introducing container components
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main topic of this book is to learn how to create scalable user interfaces
    using Angular components. You can probably already see a trend within this chapter.
    From a simple task list component holding its own state, we''re slowly moving
    into a more serious and maintainable application architecture. We''ve already
    been going through some major refactorings which can be summarized as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple task list component to list some tasks coming from a simple
    list of plain objects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting the task list component into various subcomponents and finding the
    right size for our components (task list, task, checkbox, toggle)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a service in order to store our task data and remove any data which
    was directly embedded into our components
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Angular HTTP client and the in-memory web API to simulate asynchronous
    data fetching and using RxJS observables in our service and components
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within this section, we''re going to learn about another concept which will
    enhance our maintainability even further. The concept of container components
    helps us to separate our user interface from our application state. This might
    sound difficult at the beginning but it''s actually a concept which blends really
    nicely into our existing approach. With the introduction of container components,
    we''re setting clear responsibilities when it comes to state management. Let''s
    look at the following illustration to see the concept in action:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76242032-1ff5-46bb-9c26-f662dd4781e6.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Container component and interactions with regular UI components
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Container components are in charge of your application state. They are the only
    components of your system which are allowed to manipulate state and data. They
    are passing this state and data down into your user interface component through
    component input. Within the preceding illustration, we have a container component
    surrounding **Component A**. **Component A** is again consisting of a subcomponent,
    **B**. Data is flowing down from our container component into component **A**
    and **B**. Whenever the container provides new data, that data is seeping down
    into your user interface components through their inputs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here comes the tricky part of this concept. User interface components,
    like component **A** and **B** within our illustration, are never, ever manipulating
    data directly. They will always delegate to their parent component. I often explain
    this concept as a kind of **inversion of control** (**IoC**). Instead of performing
    the action which was triggered by a user controlling the user interface directly,
    we just delegate to the parent component and tell it to perform this action. If
    the parent component is a simple UI component too, we delegate again. This goes
    on until we reach a container component. The container component then has the
    ability to effectively perform the desired operation on the application state.
    Once performed, the updated data will then seep back down the component tree.
    This approach of building user interfaces comes with an amazing list of positive
    effects on your application architecture:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**All your data manipulation is handled in a central location**:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is really beneficial since we can always go to one single place if we need
    to change the way we manipulate our state and data.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**All user interface components can be "pure"**:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we won't have any user interface components which manipulate data directly,
    and they are only dependent on the data which is flowing down the component tree
    into their inputs, we can build "pure" components in most cases. This gives all
    the benefits of "pure" components, including the performance boost.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Container components act as adapter layers**:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the container components are the only components which interact with your
    data services, database, state machine, or whatever else you're using to manage
    your state and data, we can see them as adapters of your application user interface
    to your data layer. When you decide to go differently about your state management
    and data sources, the only place where you need to apply changes is your container
    components.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Separation of state and user interface**:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation of your application's state from your user interface is underestimated
    by far. By building a simple UI component which just accepts data through its
    inputs, we can build highly flexible and reusable components. If we would like
    to include them in a completely different context of state and data, we simply
    create another container component.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Purifying our task list
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three sections, we looked into the basics of using immutable
    data structures and that Angular can be configured to assume that components only
    change when their input changes. We learned about the concept of "pure" components
    and how we can configure Angular's change detection to gain some performance benefits.
    We also learned about the concept of container components to separate our UI components
    from our application state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Within this section, we would like to refactor our application to include our
    newly learned skills about immutability, "pure" components, and container components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with our existing task list component. Currently, this component
    is directly interacting with data coming from the task service. However, we have
    learned that "pure" UI components should never directly retrieve or manipulate
    the state or data of our application. Instead, they should only depend on their
    inputs to retrieve data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `src/app/tasks/task-list/task-list.component.ts` file and apply
    the following changes. The code changes are highlighted in bold:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can immediately see that our component is now much simpler. Instead of it
    containing all the filter logic, we're just relying on the tasks passed to the
    component using the `tasks` input. Our task list component is now assuming that
    the tasks coming into the component input are already filtered and that it's no
    longer in control of the filtering itself. It still renders the filters, however,
    as you can see from the `activateFilterType` method, we're now using output properties
    to delegate the filter action to the parent component. We've also added outputs
    for adding a task as well as for updating a task. We've learned from the previous
    section about container components that our UI components use inversion of control.
    That's exactly what is happening here. We're no longer manipulating our state,
    but instead delegating the manipulation to our parent component using output properties.
    The `addTask` method, as well as the `updateTask` method, are both just emitting
    output, nothing else.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The same principle which we used for the tasks is also applied to the filter
    type list and the active filter type. We're using the input properties `taskFilterTypes`
    and `activeTaskFilterType` so that we can pass this information down from the
    parent component. The task list is no longer in charge of controlling the state
    of the active filter type and we can control this state from the parent container
    component.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re now assuming that tasks passed into the component using the task''s
    input property are already filtered, we need to apply a small change to our component
    template, too. Also, we no longer need the async pipe in our task list component,
    since our component will receive the resolved array of filtered tasks directly.
    We''ll let our container component deal with the observables. Let''s open the
    `src/app/tasks/task-list/task-list.component.html` file and apply some changes.
    Changed code is highlighted in bold and the ellipsis symbol is indicating more
    hidden but irrelevant code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's already it in our task list component. We're now only relying on input
    properties for obtaining the data required to render our component. This makes
    our component so much simpler, doesn't it?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the container component for our task list. We're creating
    a new component using the Angular CLI. This time, we're creating the component
    into a separate subfolder called `container`. As our application grows, and we
    have more container components that need to be created, we will put them all into
    this folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that we''re now starting to use the `-cd onpush` option for generating
    components using the Angular CLI. This will add the change detection strategy
    `OnPush` onto our generated component stubs for us:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The task list container is now responsible for dealing with the data necessary
    to render a task list component. It will also perform all the state and data manipulation
    required to cover the behaviour of our task list. Let''s open the generated component
    class file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When looking at the code of our new task list container component, you should
    notice something. The code is an exact copy of the code we had in our task list
    component before we turned it into a "pure" UI component. Well, does this look
    right? If you look at the code again, now that we have learned about separating
    the user interface concerns from our application state, you will notice that none
    of this code is actually the responsibility of a UI task list component. It's
    code that is mainly concerned with data manipulation and retrieval. It should
    actually never have been part of our task list UI component. This code clearly
    belongs to a container component.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the view template of our container component. A
    container component should actually never contain much code in the template. Ideally,
    the only thing you want to do within the view of a container component is to render
    the UI component which you''re concerned with in that specific container. Let''s
    open the `src/app/container/task-list-container/task-list-container.component.html`
    file and change its content to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you will have noticed, the only things we're concerned about in the view
    of our task list container component is to render a task list UI component. We're
    passing the list of filtered tasks into the task list component. Since we're using
    an observable within our container component, we use the async pipe again to subscribe
    and resolve to the most recently filtered task list. Similarly, we're passing
    the list of filter types and the currently active filter, which we both now store
    in our container, down into the task list component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we're binding the outputs of the task list UI component and
    calling the necessary method within the container when we get notified about updated
    tasks, filter changes, and newly added tasks. The task list UI component just
    tells us **what** to do, and inside of the container component, that we know **how**
    to do it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to deal with data and application state
    in a way which is best for the maintainability of our application. We have switched
    our task service from synchronous operations on tasks stored within the service
    directly to using the Angular in-memory web API and the HTTP client.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We learned about how we can profit from concepts, such as reactive programming,
    observable data structures, and immutable objects, in order to make our application
    perform better, and most importantly, simple and easy to reason about.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned about the separation of user interface from application
    state and implemented the concept of container components into our application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to organize our application on a larger scale.
    By introducing a new project layer, we can start organizing tasks within projects.
    We will create the necessary state and UI components in order to view and edit
    tasks within projects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
