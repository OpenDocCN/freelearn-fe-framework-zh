- en: Advanced Selectors and Traversing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级选择器和遍历
- en: In January 2009, jQuery's creator John Resig introduced a new open source JavaScript
    project called **Sizzle**. A standalone **CSS selector engine**, Sizzle was written
    to allow any JavaScript library to adopt it with little or no modification to
    its codebase. In fact, jQuery has been using Sizzle as its own selector engine
    ever since version 1.3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年1月，jQuery的创始人约翰·雷西格（**John Resig**）推出了一个名为**Sizzle**的新开源JavaScript项目。作为一个独立的**CSS选择器引擎**，Sizzle的编写旨在让任何JavaScript库都能够在几乎不修改其代码库的情况下采用它。事实上，jQuery自从1.3版本以来一直在使用Sizzle作为其自己的选择器引擎。
- en: Sizzle is the component within jQuery that is responsible for parsing the CSS
    selector expressions we put into the `$()` function. It determines which native
    DOM methods to use as it builds a collection of elements that we can then act
    on with other jQuery methods. The combination of Sizzle and jQuery's set of traversal
    methods makes jQuery an extremely powerful tool for finding elements on the page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Sizzle是jQuery中负责解析我们放入`$()`函数中的CSS选择器表达式的组件。它确定要使用哪些原生DOM方法，因为它构建了一个我们可以用其他jQuery方法操作的元素集合。Sizzle和jQuery的遍历方法集合的结合使得jQuery成为查找页面元素的非常强大的工具。
- en: 'In [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    we looked at each of the basic types of selector and traversal method so that
    we have a roadmap of what''s available to us in the jQuery library. In this more
    advanced chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)，*选择元素*中，我们查看了jQuery库中每种基本类型的选择器和遍历方法，以便我们了解在jQuery库中可用的内容。在这个更高级的章节中，我们将涵盖：
- en: Using selectors to find and filter data in various ways
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选择器以各种方式查找和过滤数据
- en: Writing plugins that add new selectors and DOM traversal methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写添加新选择器和DOM遍历方法的插件
- en: Optimizing our selector expressions for better performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化我们的选择器表达式以获得更好的性能
- en: Understanding some of the inner workings of the Sizzle engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Sizzle引擎的一些内部工作ings
- en: Selecting and traversing revisited
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和遍历重访
- en: 'To kick off this more in-depth look into selectors and traversing, we''ll build
    a script that will provide yet more selecting and traversing examples to inspect.
    For our sample, we''ll build an HTML document containing a list of news items.
    We''ll place those items in a table so that we can experiment with selecting rows
    and columns in several ways:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解选择器和遍历，我们将构建一个脚本，提供更多选择和遍历示例以进行检查。对于我们的示例，我们将构建一个包含新闻项列表的HTML文档。我们将这些项目放在一个表格中，以便我们可以以几种方式选择行和列进行实验：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting the example code
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下GitHub存储库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'From this code fragment, we can see the structure of the document. The table
    has four columns, representing date, headline, author, and topic, but some table
    rows contain a subheading of a calendar year instead of those four items:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个代码片段中，我们可以看到文档的结构。表格有四列，代表日期、标题、作者和主题，但是一些表格行包含一个日历年的副标题，而不是这四个项目：
- en: '![](img/image_09_001-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_001-1.jpg)'
- en: Between the title and table, there are sets of links representing each of the
    news topics in the table. For our first task, we'll change the behavior of these
    links to filter the table *in place* rather than requiring navigation to different
    pages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题和表格之间，有一组链接，代表着表格中的每个新闻主题。对于我们的第一个任务，我们将更改这些链接的行为，以*原地*过滤表格，而不需要导航到不同的页面。
- en: Dynamic table filtering
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态表格过滤
- en: 'In order to use the topic links to filter the table, we need to prevent their
    default linking behavior. We should also give the user some feedback about the
    currently selected topic:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用主题链接来过滤表格，我们需要阻止其默认的链接行为。我们还应该为当前选择的主题给用户提供一些反馈：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listing 9.1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1
- en: We remove the `selected` class from all the topic links when one is clicked
    on, then add the `selected` class to the new topic. The call to `.preventDefault()` prevents
    the link from being followed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击其中一个链接时，我们会从所有主题链接中删除`selected`类，然后将`selected`类添加到新主题上。调用`.preventDefault()`可以阻止链接被跟踪。
- en: 'Next, we need to actually perform the filtering operation. As a first pass
    at this problem, we can hide every row of the table that doesn''t contain the
    text of the topic:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实际执行过滤操作。作为解决此问题的第一步，我们可以隐藏表格中不包含主题文本的每一行：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 9.2
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2
- en: 'We''re now storing the text of the link in the constant `topic` so that we
    can compare it against the text in the table itself. First, we show all the table
    rows and then, if the topic is not All, we hide the irrelevant ones. The selector
    we''re using for this process is a little complex, though:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将链接的文本存储在常量`topic`中，以便我们可以将其与表格中的文本进行比较。首先，我们显示所有的表行，然后，如果主题不是全部，我们就隐藏不相关的行。我们用于此过程的选择器有点复杂：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The selector starts off straightforwardly, with `#news tr` locating all of the
    rows in the table. We then filter this element set using the `:has()` custom selector.
    This selector winnows the currently selected elements down to those that contain
    the specified descendant. In this case, we're eliminating the header rows (such
    as the calendar years) from consideration, since they do not contain `<td>` cells.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器从简单开始，使用`#news tr`定位表中的所有行。然后我们使用`:has()`自定义选择器来过滤这个元素集。这个选择器将当前选定的元素减少到那些包含指定后代的元素。在这种情况下，我们正在消除要考虑的标题行（如日历年份），因为它们不包含`<td>`单元格。
- en: Once we have found the rows of the table where the actual content lies, we need
    to find out which ones relate to the selected topic. The `:contains()` custom
    selector matches just the elements that have the given text string somewhere inside
    them; wrapping this in a `:not()` selector then gives us all the rows that don't
    have the topic string so we can hide them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了表的行，其中包含实际内容，我们就需要找出哪些行与所选主题相关。`:contains()`自定义选择器仅匹配具有给定文本字符串的元素；将其包装在`:not()`选择器中，然后我们就可以隐藏所有不包含主题字符串的行。
- en: 'This code works well enough, unless the topic happens to appear as part of
    a news headline, for instance. We also need to take care of the eventuality that
    one topic is a substring of another. To handle these cases, we will need to execute
    code for each of the rows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行得足够好，除非主题恰好出现在新闻标题中，例如。我们还需要处理一个主题是另一个主题子串的可能性。为了处理这些情况，我们需要对每一行执行代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 9.3
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3
- en: This new code eliminates some of the complex selector expression text by adding
    DOM traversal methods. The `.find()` method acts just like the space previously
    separating `#news` and `tr`, but the `.not()` method does something that `:not()`
    can't do. Just as we saw with the `.filter()` method back in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml),
    *Selecting Elements*, `.not()` can accept a callback function invoked once per
    element to be tested. If that function returns `true`, the element is excluded
    from the result set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码通过添加 DOM 遍历方法消除了一些复杂的选择器表达式文本。`.find()`方法的作用就像之前将`#news`和`tr`分开的空格一样，但是`.not()`方法做了`：not()`不能做的事情。就像我们在[第2章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)中看到的`.filter()`方法一样，`.not()`可以接受一个回调函数，每次测试一个元素时调用。如果该函数返回`true`，则将该元素从结果集中排除。
- en: Selectors versus traversal methods
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器与遍历方法
- en: The choice of using a selector or its equivalent traversal method has performance
    ramifications as well. We'll explore this choice in more detail later in this
    chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择器或其等效的遍历方法的选择在性能上也有影响。我们将在本章后面更详细地探讨这个选择。
- en: 'Inside the `.not()` method''s filtering function, we examine the child elements
    of the row to find the fourth one (which is the cell in the `Topic` column). A
    simple check of the text of this cell tells us whether the row should be hidden.
    Only the matching rows are displayed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.not()`方法的过滤函数中，我们检查行的子元素，找到第四个（也就是`Topic`列中的单元格）。对这个单元格的文本进行简单检查就能告诉我们是否应该隐藏该行。只有匹配的行会被显示：
- en: '![](img/image_09_002-1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_002-1.jpg)'
- en: Striping table rows
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条纹表行
- en: 'In [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    one of our selector examples illustrated the ways in which we can apply alternating
    row colors to a table. We saw that the `:even` and `:odd` custom selectors can
    make short work of this task, and that the CSS-native `:nth-child()` pseudo-class
    can accomplish it as well:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)中，我们的选择器示例之一演示了如何将交替的行颜色应用于表格。我们看到，`:even`和`:odd`自定义选择器可以轻松完成这项任务，CSS
    本地的`:nth-child()`伪类也可以完成：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing 9.4
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.4
- en: This straightforward selector finds every other table row, and since each year's
    news articles reside in their own `<tbody>` element, the alternation starts over
    again with each section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个直接的选择器找到每个表行，因为每年的新闻文章都放在自己的`<tbody>`元素中，所以每个部分都重新开始交替。
- en: '![](img/image_09_003-1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_003-1.jpg)'
- en: 'For a more complicated row-striping challenge, we can attempt to give the `alt`
    class to sets of two rows at a time. The first two rows will receive the class,
    then the next two will not, and so on. To achieve this, we will need to revisit
    **filtering functions**:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的行条纹挑战，我们可以尝试一次给两行设置`alt`类。前两行将收到类，然后接下来的两行将不会，以此类推。为了实现这一点，我们需要重新审视**过滤函数**：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 9.5
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5
- en: In our `.filter()` examples in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml),
    *Selecting Elements*, as well as the `.not()` example in *Listing 9.3*, our filtering
    functions examined each element to determine whether to include it in the result
    set. Here, though, we don't need information about the element to determine if
    it should be included. Instead, we need to know its position within the original
    set of elements. This information is passed as an argument to the function, and
    we're calling it `i`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)中的我们的`.filter()`示例中，*选择元素*，以及*列表9.3*中的`.not()`示例中，我们的过滤函数会检查每个元素，以确定是否将其包含在结果集中。但是，在这里，我们不需要关于元素的信息来确定是否应该包含它。相反，我们需要知道它在原始元素集合中的位置。这些信息作为参数传递给函数，并且我们将其称为`i`。
- en: The `i` parameter now holds the zero-based index of the element. With this,
    we can use the modulo operator (`%`) to determine whether we are in a pair of
    elements that should receive the `alt` class or not. Now, we have stripes of two
    rows throughout the table.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`i`参数保存了元素的从零开始的索引。有了这个，我们可以使用取模运算符（`%`）来确定我们是否在应该接收`alt`类的一对元素中。现在，我们在整个表中有两行间隔。
- en: 'There are a couple of loose ends to clean up, however. Because we''re no longer
    using the `:nth-child()` pseudo-class, the alternation does not begin again within
    each `<tbody>`. Also, we should be skipping table header rows for a consistent
    appearance. These goals can be achieved by making a couple of small modifications:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些松散的地方需要清理。因为我们不再使用`:nth-child()`伪类，所以交替不再在每个`<tbody>`中重新开始。另外，我们应该跳过表头行以保持一致的外观。通过进行一些小的修改，可以实现这些目标：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 9.6
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6
- en: 'To treat each group of rows independently, we can loop over the `<tbody>` elements
    with an `.each()` call. Within the loop, we then exclude subheading rows just
    as we did in *Listing 9.3*, using `.has()`. This results in a table striped in
    sets of two rows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了独立处理每组行，我们可以使用`.each()`调用对`<tbody>`元素进行循环。在循环内部，我们像在*列表9.3*中那样排除子标题行，使用`.has()`。结果是表被分成两行的一组进行条纹处理：
- en: '![](img/image_09_004-1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_004-1.jpg)'
- en: Combining filtering and striping
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合过滤和条纹
- en: 'Our advanced table striping now works nicely, but behaves strangely when the
    topic filter is used. For the two functions to play together well, we need to
    re-stripe the table each time a filter is used. We will also need to consider
    whether rows are currently hidden when calculating where to apply the `alt` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的高级表格条纹现在工作得很好，但在使用主题过滤器时行为奇怪。为了使这两个函数协调良好，我们需要在每次使用过滤器时重新为表添加条纹。我们还需要考虑当前行是否隐藏，以确定在哪里应用`alt`类：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 9.7
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7
- en: Combining the filtering code from *Listing 9.3* with our row striping routine,
    this script now defines a function called `stripe()`, which is called once when
    the document is loaded, and again each time a topic link is clicked. Within the
    function, we take care of removing the `alt` class from rows that no longer need
    it, as well as limiting the selected rows to those that are currently shown. We
    accomplish this with the `:visible` pseudo-class, which (along with its counterpart
    `:hidden`) respects whether elements are hidden for a variety of reasons, including
    having a `display` value of `none`, or `width` and `height` values of `0`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将*列表9.3*中的过滤代码与我们的行条纹例程结合起来，这个脚本现在定义了一个名为`stripe()`的函数，当文档加载时调用一次，每当点击主题链接时再次调用。在函数内部，我们负责从不再需要它的行中删除`alt`类，以及将所选行限制为当前显示的行。我们使用`:visible`伪类来实现这一点，它（以及它的对应项`:hidden`）尊重元素是否由于各种原因而隐藏，包括具有`display`值为`none`，或`width`和`height`值为`0`。
- en: 'We can now filter the rows of our table while preserving our row striping:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以过滤我们表的行而保留我们的行条纹：
- en: '![](img/5297_09_05.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_05.png)'
- en: More selector and traversal methods
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多选择器和遍历方法
- en: Even after all the examples we've seen, we have not come close to exploring
    every way to find elements on a page using jQuery. There are dozens of selectors
    and DOM traversal methods available to us, and each has a particular utility we
    may need to call upon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们看到的所有示例之后，我们也没有接近探索使用 jQuery 在页面上找到元素的每一种方式。我们有数十个选择器和 DOM 遍历方法可用，并且每个方法都有特定的实用性，我们可能需要调用其中的某一个。
- en: To find the appropriate selector or method for our needs, many resources are
    available to us. The quick reference at the end of this book lists each selector
    and method with a very brief description of each. For lengthier descriptions and
    usage examples, though, we will need a more thorough guide, such as the online
    jQuery API reference. This site lists all the selectors at [http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/),
    and the traversal methods at [http://api.jquery.com/category/traversing/](http://api.jquery.com/category/traversing/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到适合我们需求的选择器或方法，我们有许多资源可用。本书末尾的快速参考列出了每个选择器和方法，并简要描述了每个选择器和方法。然而，对于更详细的描述和用法示例，我们需要更全面的指南，比如在线
    jQuery API 参考。该网站列出了所有选择器在 [http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/)，以及遍历方法在
    [http://api.jquery.com/category/traversing/](http://api.jquery.com/category/traversing/)。
- en: Customizing and optimizing selectors
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义和优化选择器
- en: Many techniques that we've seen give us a tool chest that can be used to find
    any page element we want to work with. The story doesn't end here though; there
    is much to learn about performing our element-finding tasks efficiently. This
    efficiency can take the form of both code that is easier to write and read, and
    code that executes more quickly inside the web browser.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的许多技术都为我们提供了一个工具箱，可用于找到我们想要处理的任何页面元素。然而，故事并没有结束；有很多关于如何有效执行我们的元素查找任务的知识需要学习。这种效率可以以编写和阅读更简单的代码，以及在
    web 浏览器内更快执行的代码形式呈现。
- en: Writing a custom selector plugin
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义选择器插件
- en: One way to improve legibility is to encapsulate code snippets in reusable components.
    We do this all the time by creating functions. In [Chapter 8](091dd3f4-9663-47df-af02-817487c3038f.xhtml),
    *Developing Plugins*, we expanded this idea by crafting jQuery plugins that added
    methods to jQuery objects. This isn't the only way plugins can help us reuse code,
    though. Plugins can also provide additional **selector expressions**, such as
    the `:paused` selector that Cycle gave us in [Chapter 7](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml),
    *Using Plugins*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提高可读性的一种方法是将代码片段封装在可重用组件中。我们通过创建函数一直在做这件事。在 [第 8 章](091dd3f4-9663-47df-af02-817487c3038f.xhtml)，*开发插件*
    中，我们通过创建 jQuery 插件来为 jQuery 对象添加方法来扩展这个想法。然而，插件不仅仅可以帮助我们重用代码。插件还可以提供额外的**选择器表达式**，比如
    Cycle 在 [第 7 章](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml)，*使用插件* 中给我们的 `:paused`
    选择器。
- en: The easiest type of selector expression to add is a **pseudo-class**. This is
    an expression that starts with a colon, such as `:checked` or `:nth-child()`.
    To illustrate the process of creating a selector expression, we'll build a pseudo-class
    called `:group()`. This new selector will encapsulate the code we used to find
    table rows to stripe back in *Listing 9.6*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的最简单类型的选择器表达式是**伪类**。这是以冒号开头的表达式，比如 `:checked` 或 `:nth-child()`。为了说明创建选择器表达式的过程，我们将构建一个名为
    `:group()` 的伪类。这个新选择器将封装我们用来找到表格行以执行条纹化的代码，就像 *列表 9.6* 中一样。
- en: 'When using a selector expression to find elements, jQuery looks for instructions
    in an internal object called `expr`. The values in this object behave much like
    the filtering functions that we pass to `.filter()` or `.not()`, containing JavaScript
    code that causes each element to be contained in the result set if and only if
    the function returns `true`. We can add new expressions to this object using the
    `$.extend()` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用选择器表达式查找元素时，jQuery 会在内部对象 `expr` 中查找指令。这个对象中的值的行为类似于我们传递给 `.filter()` 或 `.not()`
    的过滤函数，包含导致每个元素包含在结果集中的 JavaScript 代码，仅当函数返回 `true` 时才会包含。我们可以使用 `$.extend()` 函数向这个对象添加新的表达式：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 9.8
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8
- en: This code tells jQuery that `group` is a valid string that can follow a colon
    in a selector expression, and that, when it is encountered, the given function
    should be called to determine whether the element should be included in the result
    set.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉 jQuery `group` 是一个有效的字符串，可以跟在选择器表达式的冒号后面，当遇到它时，应调用给定的函数来确定是否应将元素包含在结果集中。
- en: 'The function that is evaluated here is passed four parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里评估的函数传递了四个参数：
- en: '`element`: The DOM element under consideration. This is needed for most selectors,
    but not ours.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element`：要考虑的 DOM 元素。大多数选择器都需要这个，但我们的不需要。'
- en: '`index`: The index of the DOM element within the result set. Unfortunately,
    this is always 0, and we cannot rely on it. The only reason it''s included here
    is because we need positional access to the matches argument.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：结果集中的 DOM 元素的索引。不幸的是，这总是 0，我们不能依赖它。这里包括它的唯一原因是因为我们需要对匹配参数进行位置访问。'
- en: '`matches`: An array containing the result of the regular expression that was
    used to parse this selector. Typically, `matches[3]` is the only relevant item
    in the array; in a selector of the form `:group(2)`, the `matches[3]` item contains
    `2`, the text within the parentheses.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matches`：包含用于解析此选择器的正则表达式结果的数组。通常，`matches[3]`是数组中唯一相关的项目；在形式为`:group(2)`的选择器中，`matches[3]`项包含`2`，即括号内的文本。'
- en: Pseudo-class selectors can use some or all of the information contained in these
    three arguments to determine whether or not the element belongs in the result
    set. In this case, `element` and `matches` are all that we require. We actually
    do require the index position of every element that's passed to this function.
    Since the `index` argument cannot be relied upon, we simply use the `.index()`
    jQuery method to get the index for us.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 伪类选择器可以使用这三个参数中的部分或全部信息来确定元素是否属于结果集。在这种情况下，我们只需要`element`和`matches`。实际上，我们确实需要传递给此函数的每个元素的索引位置。由于无法依赖`index`参数，因此我们简单地使用`.index()`
    jQuery 方法来获取索引。
- en: 'With the new `:group` selector, we now have a flexible way to select alternating
    groups of elements. For example, we could combine the selector expression and
    `.filter()` function from *Listing 9.5* into a single selector expression: `$(''#news
    tr:group(2)'')`, or we could preserve the per-section behavior from *Listing 9.7*,
    and use `:group()` as an expression within a `.filter()` call. We can even change
    the number of rows to group by simply changing the number within the parentheses:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的`:group`选择器，我们现在有了一种灵活的方式来选择交替的元素组。例如，我们可以将选择器表达式和`.filter()`函数从*列表9.5*合并为一个单一的选择器表达式：`$('#news
    tr:group(2)')`，或者我们可以保留*列表9.7*中的每节行为，并将`:group()`作为一个表达式在`.filter()`调用中使用。我们甚至可以通过简单地在括号内更改数字来更改要分组的行数：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 9.9
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9
- en: 'Now we can see that the row striping alternates by groups of three:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，行条纹以三个一组交替：
- en: '![](img/image_09_006-1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_09_006-1.jpg)'
- en: Selector performance
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器性能
- en: In planning any web development project, we need to keep in mind the time it
    takes to create the site, the ease and speed with which we can maintain our code,
    and the performance of the site as users interact with it. Often the first two
    of these concerns are more important than the third. Especially with client-side
    scripting, developers can easily fall into the traps of **premature optimization**
    and **micro-optimization**. These pitfalls can cause us to spend countless hours
    tweaking our code to shave milliseconds from the JavaScript execution time, even
    when there was no noticeable performance lag in the first place.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划任何 web 开发项目时，我们需要记住创建网站所需的时间、我们可以维护代码的轻松程度和速度，以及用户与网站交互时的性能。通常，这些关注点中的前两个比第三个更重要。特别是在客户端脚本编写方面，开发者很容易陷入**过早优化**和**微优化**的陷阱。这些陷阱会导致我们花费无数小时微调我们的代码，以从
    JavaScript 执行时间中削减毫秒，即使一开始没有注意到性能滞后。
- en: A good rule of thumb is to consider the developer's time more valuable than
    the computer's time, unless users notice slowness in our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是认为开发者的时间比计算机的时间更宝贵，除非用户注意到我们应用程序的速度变慢。
- en: Even when performance is an issue, pinpointing the bottlenecks in our jQuery
    code can be difficult. As we hinted at earlier in this chapter, some selectors
    are generally faster than others, and moving part of a selector to a traversal
    method can help speed up the time it takes to find elements on the page. Selector
    and traversal performance is therefore often a good place to start examining our
    code to reduce the amount of delay that users may experience when interacting
    with the page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 即使性能是一个问题，定位我们的 jQuery 代码中的瓶颈也可能很困难。正如我们在本章前面提到的，某些选择器通常比其他选择器快，将选择器的一部分移到遍历方法中可以帮助加快在页面上查找元素所需的时间。因此，选择器和遍历性能通常是开始检查我们的代码以减少用户与页面交互时可能遇到的延迟量的良好起点。
- en: Any decrees made about the relative speed of selectors and traversal methods
    are likely to become outdated with the release of newer, faster browsers and clever
    speed tweaks introduced in newer jQuery versions. In matters of performance, it
    is a good idea to routinely question our assumptions and to optimize code after
    performing measurements using a tool such as **jsPerf** ([http://jsperf.com](http://jsperf.com)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择器和遍历方法的相对速度的任何判断都可能随着发布更新、更快的浏览器和新版本 jQuery 引入的聪明速度调整而过时。在性能方面，经常质疑我们的假设，并在使用像**jsPerf**（[http://jsperf.com](http://jsperf.com)）这样的工具进行测量后优化代码是个好主意。
- en: With this in mind, we'll examine a couple of simple guidelines for producing
    optimized jQuery selector code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将检查一些简单的指南，以生成优化的 jQuery 选择器代码。
- en: Sizzle selector implementation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sizzle 选择器实现
- en: 'As noted in the beginning of this chapter, when we pass a selector expression
    into the `$()` function, jQuery''s Sizzle implementation parses the expression
    and determines how to gather the elements represented by it. In its basic form,
    Sizzle applies the most efficient native **DOM method** that the browser supports
    to obtain a `nodeList`, a native array-like object of DOM elements that jQuery
    ultimately converts to a true array and adds to the `jQuery` object. The following
    is a list of DOM methods that jQuery uses internally, along with the recent browser
    versions that support them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开始时所指出的，当我们将选择器表达式传递给`$()`函数时，jQuery 的 Sizzle 实现会解析表达式并确定如何收集其中表示的元素。在其基本形式中，Sizzle
    应用最有效的本地**DOM 方法**，浏览器支持以获取`nodeList`，这是一个 DOM 元素的本机类似数组对象，jQuery 最终会将其转换为真正的数组，并将其添加到`jQuery`对象。以下是
    jQuery 内部使用的 DOM 方法列表，以及支持它们的最新浏览器版本：
- en: '| **Method** | **Selects** | **Supported by** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **选择** | **支持者** |'
- en: '| `.getElementById()` | The unique element with an ID that matches the given
    string. | All browsers |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `.getElementById()` | 与给定字符串匹配的唯一元素的 ID。 | 所有浏览器 |'
- en: '| `.getElementsByTagName()` | All elements with a tag name that matches the
    given string. | All browsers |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `.getElementsByTagName()` | 所有标签名称与给定字符串匹配的元素。 | 所有浏览器 |'
- en: '| `.getElementsByClassName()` | All elements that have one of their class names
    matching the given string. | IE9+, Firefox 3+, Safari 4+, Chrome 4+, and Opera
    10+ |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `.getElementsByClassName()` | 具有其中一个类名与给定字符串匹配的所有元素。 | IE9+，Firefox 3+，Safari
    4+，Chrome 4+，和 Opera 10+ |'
- en: '| `.querySelectorAll()` | All elements that match the given selector expression.
    | IE8+, Firefox 3.5+, Safari 3+, Chrome 4+, and Opera 10+ |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `.querySelectorAll()` | 所有匹配给定选择器表达式的元素。 | IE8+，Firefox 3.5+，Safari 3+，Chrome
    4+，和 Opera 10+ |'
- en: If a part of the selector expression cannot be handled by one of these methods,
    Sizzle falls back to looping through each element that has already been collected
    and testing each one against the expression part. If *no* part of the selector
    expression can be handled by a DOM method, Sizzle starts with a collection of
    *all* elements in the document, represented by `document.getElementsByTagName('*')`,
    and loops through each one in turn.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择器表达式的某个部分不能由这些方法之一处理，Sizzle 会回退到循环遍历已经收集的每个元素，并针对表达式的每个部分进行测试。如果选择器表达式的*任何*部分都不能由
    DOM 方法处理，Sizzle 就会以`document.getElementsByTagName('*')`表示的文档中*所有*元素的集合开始，并逐个遍历每个元素。
- en: This looping and testing of each element is much more costly in terms of performance
    than any of the native DOM methods. Fortunately, the most recent versions of all
    modern desktop browsers include the native `.querySelectorAll()` method, and Sizzle
    uses it when it can't use other, even speedier, native methods--with one exception.
    When the selector expression contains a custom jQuery selector such as `:eq()`
    or `:odd` or `:even` that has no CSS counterpart, Sizzle has no choice but to
    loop and test.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环和测试每个元素的方法在性能上要比任何本地 DOM 方法昂贵得多。幸运的是，现代桌面浏览器的最新版本都包括本地的`.querySelectorAll()`方法，并且当它不能使用其他更快的本地方法时，Sizzle
    会使用它--只有一个例外。当选择器表达式包含像`:eq()`或`:odd`或`:even`这样没有 CSS 对应的自定义 jQuery 选择器时，Sizzle
    就别无选择，只能循环和测试。
- en: Testing selector speed
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试选择器速度
- en: 'To get an idea of the performance difference between `.querySelectorAll()`
    and the *loop-and-test* procedure, consider a document in which we wish to select
    all the `<input type="text">` elements. We could write the selector expression
    in one of two ways: `$(''input[type="text"]'')`, which uses a *CSS attribute selector*,
    or `$(''input:text'')`, which uses a *custom jQuery selector*. To test just the
    portions of the selectors we are interested in here, we will remove the `input`
    parts and compare the speeds of `$(''[type="text"]'')` and `$('':text'')`. The
    JavaScript benchmarking site [http://jsperf.com/](http://jsperf.com/) lets us
    make this comparison, yielding dramatic results.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `.querySelectorAll()` 和 *循环测试* 过程之间的性能差异，可以考虑一个文档，其中我们希望选择所有 `<input type="text">`
    元素。我们可以用两种方式编写选择器表达式：`$('input[type="text"]')`，使用 *CSS 属性选择器*，或者 `$('input:text')`，使用
    *自定义 jQuery 选择器*。为了测试我们在这里感兴趣的选择器部分，我们将移除 `input` 部分，并比较 `$('[type="text"]')`
    和 `$(':text')` 的速度。JavaScript 基准测试网站 [http://jsperf.com/](http://jsperf.com/)
    让我们可以进行这种比较，得出戏剧性的结果。
- en: 'In jsPerf tests, each test case is cycled to see how many times it can be completed
    in a certain amount of time, so the higher the number, the better. When tested
    in modern browsers that support `.querySelectorAll()` (Chrome 26, Firefox 20,
    and Safari 6), the selector that can take advantage of it is remarkably faster
    than the custom jQuery selector:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jsPerf 测试中，每个测试用例会循环执行，以查看在一定时间内可以完成多少次，因此数字越高越好。在支持 `.querySelectorAll()`
    的现代浏览器（Chrome 26、Firefox 20 和 Safari 6）中进行测试时，能够利用它的选择器比自定义的 jQuery 选择器要快得多：
- en: '![](img/5297_09_07.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_07.png)'
- en: Figure 9.1
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1
- en: 'However, in a browser that does not support `.querySelectorAll()`, such as
    IE 7, the two selectors perform almost identically. In this case, both selectors
    force jQuery to loop through every element on the page and test each one individually:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在不支持 `.querySelectorAll()` 的浏览器中，例如 IE 7，这两个选择器的性能几乎相同。在这种情况下，这两个选择器都会强制
    jQuery 循环遍历页面上的每个元素，并分别测试每个元素：
- en: '![](img/5297_09_08.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_08.png)'
- en: Figure 9.2
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2
- en: 'The performance difference between a selector that uses a native method and
    one that doesn''t is also apparent when we look at `$(''input:eq(1)'')` and `$(''input'')
    .eq(1)`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 `$('input:eq(1)')` 和 `$('input') .eq(1)` 时，使用原生方法和不使用原生方法的选择器之间的性能差异也是显而易见的：
- en: '![](img/5297_09_09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_09.png)'
- en: Figure 9.3
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3
- en: While the raw number of operations per second varies greatly from browser to
    browser, all of the tested browsers show a significant performance boost when
    we move the custom `:eq()` selector out into the `.eq()` method. Using the simple
    `input` tag name as the argument for the `$()` function allows for a quick lookup,
    and the `.eq()` method then simply calls an array function to retrieve the second
    element in the jQuery collection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每秒操作次数在不同浏览器之间有很大差异，但所有测试的浏览器在将自定义的 `:eq()` 选择器移出到 `.eq()` 方法时都显示出显著的性能提升。使用简单的
    `input` 标签名称作为 `$()` 函数的参数允许快速查找，然后 `.eq()` 方法简单地调用数组函数来检索 jQuery 集合中的第二个元素。
- en: As a general rule of thumb, we should prefer selectors that are part of the
    CSS specification over jQuery's custom selectors whenever possible. Still, before
    changing our selectors, it makes sense to first confirm that there is a need to
    increase performance, and then test just how much the change would boost performance
    with a benchmarking tool such as [http://jsperf.com](http://jsperf.com).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，我们应尽可能使用 CSS 规范中的选择器，而不是 jQuery 的自定义选择器。但在更改选择器之前，先确认是否需要提高性能是有意义的，然后使用诸如
    [http://jsperf.com](http://jsperf.com) 这样的基准测试工具测试更改能够提升多少性能。
- en: DOM traversal under the hood
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在幕后进行 DOM 遍历
- en: In [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    and again at the beginning of this chapter, we looked at ways of traveling from
    one set of DOM elements to another by calling DOM traversal methods. Our (far
    from exhaustive) survey of such methods included simple ways to reach neighboring
    cells, such as `.next()` and `.parent()`, and more complex ways of combining selector
    expressions, such as `.find()` and `.filter()`. By now, we should have a fairly
    strong grasp to these approaches of getting from one DOM element to another step
    by step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)中，*选择元素*，以及本章的开头，我们讨论了通过调用
    DOM 遍历方法从一个 DOM 元素集合到另一个 DOM 元素集合的方法。我们（远非详尽）的调查包括简单到达相邻单元格的简单方法，例如 `.next()`
    和 `.parent()`，以及更复杂的组合选择器表达式的方式，例如 `.find()` 和 `.filter()`。到目前为止，我们应该对这些一步步从一个
    DOM 元素到另一个 DOM 元素的方法有相当牢固的掌握。
- en: Each time we take one of these steps, though, jQuery takes note of our travels,
    laying down a trail of breadcrumbs we can follow back home if needed. A couple
    of the methods we briefly touched on in that chapter, `.end()` and `.addBack()`,
    take advantage of this record keeping. To be able to get the most out of these
    methods, and in general to write efficient jQuery code, we need to understand
    a bit more about how the DOM traversal methods do their jobs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们执行其中一步时，jQuery 都会记录我们的行程，留下一串面包屑，如果需要的话，我们可以按照这些面包屑回到家里。在那一章中我们简要提及的几个方法，`.end()`
    和 `.addBack()`，利用了这种记录。为了能够充分利用这些方法，并且一般来说编写高效的 jQuery 代码，我们需要更多地了解 DOM 遍历方法如何执行它们的工作。
- en: jQuery traversal properties
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery 遍历属性
- en: As we know, we typically construct a jQuery object instance by passing a selector
    expression to the `$()` function. Within the resulting object, there lies an array
    structure containing references to each DOM element that matched that selector.
    What we haven't seen, though, are the other properties hidden in the object. For
    example, when a DOM traversal method is called, the `.prevObject` property holds
    a reference to the jQuery object the traversal method was called upon.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，通常通过将选择器表达式传递给 `$()` 函数来构造 jQuery 对象实例。在生成的对象内部，存在一个包含与该选择器匹配的每个 DOM 元素引用的数组结构。不过，我们没有看到对象中隐藏的其他属性。例如，当调用
    DOM 遍历方法时，`.prevObject` 属性保存了对调用该遍历方法的 jQuery 对象的引用。
- en: The jQuery object used to expose `selector` and `context` properties as well.
    Since they don't provide any value to us, they've been removed in jQuery 3.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 对象用于暴露 `selector` 和 `context` 属性。由于它们对我们没有提供任何价值，在 jQuery 3 中已经被移除。
- en: 'To see the `prevObject` property in action, we can highlight an arbitrary cell
    of our table and examine its value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `prevObject` 属性的作用，我们可以突出显示表格的任意单元格并检查其值：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 9.10
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10
- en: 'This snippet will highlight the single selected cell, as shown in the following
    screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码段将突出显示所选单个单元格，如下图所示：
- en: '![](img/5297_09_10.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_10.png)'
- en: 'We can see that `.prevObject` is undefined since this is a newly created object.
    If we add a traversal method to the mix, though, things get more interesting:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `.prevObject` 未定义，因为这是一个新创建的对象。但是，如果我们将遍历方法添加到混合中，情况就会变得更加有趣：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 9.11
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11
- en: 'This change alters which cells are highlighted, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改改变了高亮显示的单元格，如下图所示：
- en: '![](img/5297_09_11.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_11.png)'
- en: Now, the two cells following the one we initially selected are highlighted.
    Within the jQuery object, `.prevObject` now refers to the original jQuery object
    instance before the call to `.nextAll()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们最初选择的单元格后面的两个单元格被突出显示。在 jQuery 对象内部，`.prevObject` 现在指向 `.nextAll()` 调用之前的原始
    jQuery 对象实例。
- en: The DOM element stack
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM 元素栈
- en: Since each jQuery object instance has a `.prevObject` property pointing to the
    previous one, we have a linked list structure that implements a **stack**. Each
    traversal method call finds a new set of elements and pushes this set onto the
    stack. This is only useful if we can do something with this stack, which is where
    the `.end()` and `.addBack()` methods come into play.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 jQuery 对象实例都有一个 `.prevObject` 属性，指向前一个对象，我们有了一个实现 **栈** 的链表结构。每次遍历方法调用都会找到一组新的元素并将此集合推入堆栈。只有在我们可以对此堆栈执行某些操作时，才有用，这就是
    `.end()` 和 `.addBack()` 方法发挥作用的地方。
- en: 'The `.end()` method simply pops one element off the end of the stack, which
    is the same as fetching the value of the `.prevObject` property. We saw an example
    of this in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting
    Elements*, and we will see more later in this chapter. For a more interesting
    example, though, we''ll investigate how `.addBack()` manipulates the stack:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`.end()` 方法简单地从堆栈的末尾弹出一个元素，这与获取 `.prevObject` 属性的值相同。我们在[第 2 章](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml)中看到了一个示例，*选择元素*，在本章后面我们还会看到更多。然而，为了得到更有趣的例子，我们将研究
    `.addBack()` 如何操作堆栈：'
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 9.12
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12
- en: 'Once again, the highlighted cells have changed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，高亮显示的单元格已更改：
- en: '![](img/5297_09_12.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_12.png)'
- en: When `.addBack()` is called, jQuery looks back one step on the stack and combines
    the two element sets. In our example, this means that the highlighted cells include
    both the two cells found by the `.nextAll()` call and the original cell located
    using the selector. This new, merged element set is then pushed onto the stack.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `.addBack()` 方法时，jQuery 回顾栈上的上一步并将两个元素集合合并起来。在我们的例子中，这意味着突出显示的单元格包括 `.nextAll()`
    调用找到的两个单元格和使用选择器定位的原始单元格。然后，这个新的、合并的元素集合被推到栈上。
- en: This kind of stack manipulation is useful. To make sure these techniques work
    when they are needed, each traversal method implementation must properly update
    the stack; this means that we need to understand some of the system's inner workings
    if we want to provide traversal methods of our own.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种栈操作方式非常有用。为了确保在需要时这些技术能够发挥作用，每个遍历方法的实现都必须正确更新栈；这意味着如果我们想提供自己的遍历方法，我们需要了解系统的一些内部工作原理。
- en: Writing a DOM traversal method plugin
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 DOM 遍历方法插件
- en: Like any other jQuery object method, traversal methods can be added to jQuery
    by adding properties to `$.fn`. We saw in [Chapter 8](091dd3f4-9663-47df-af02-817487c3038f.xhtml),
    *Developing Plugins*, that new jQuery methods we define should operate on the
    matched set of elements and then return the jQuery object so that users can chain
    on additional methods. When we create DOM traversal methods, the process is similar,
    but the jQuery object we return needs to point to a new set of matched elements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何其他 jQuery 对象方法一样，遍历方法可以通过向 `$.fn` 添加属性来添加到 jQuery 中。我们在[第 8 章](091dd3f4-9663-47df-af02-817487c3038f.xhtml)中看到，我们定义的新的
    jQuery 方法应该在匹配的元素集合上操作，然后返回 jQuery 对象，以便用户可以链式调用其他方法。当我们创建 DOM 遍历方法时，这个过程是类似的，但是我们返回的
    jQuery 对象需要指向一个新的匹配元素集合。
- en: 'As an example, we''ll build a plugin that finds all of the table cells in the
    same column as a given cell. First we''ll look at the plugin code in its entirety,
    then examine it piece by piece to understand how it works:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们将构建一个插件，找到与给定单元格相同列的所有表格单元格。首先我们将完整地查看插件代码，然后逐个地分析它，以了解它的工作原理：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 9.13
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第 9.13 节
- en: Our `.column()` method could be called on a jQuery object pointing to zero,
    one, or more DOM elements. To account for all of these possibilities, we use the
    `.each()` method to loop over the elements, adding the columns of cells one by
    one into the variable `$cells`. This `$cells` variable starts out as an empty
    jQuery object, but then is expanded with the `.add()` method to point to more
    and more DOM elements as needed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `.column()` 方法可以在指向零个、一个或多个 DOM 元素的 jQuery 对象上调用。为了考虑到所有这些可能性，我们使用 `.each()`
    方法循环遍历元素，逐个将单元格列添加到变量 `$cells` 中。这个 `$cells` 变量一开始是一个空的 jQuery 对象，但随后通过 `.add()`
    方法扩展到需要的更多 DOM 元素。
- en: This explains the outer loop of the function; inside the loop, we need to understand
    how `$columnCells` gets populated with the DOM elements in the table column. First,
    we get a reference to the table cell being examined. We want to allow the `.column()`
    method to be called on table cells or on elements inside table cells. The `.closest()`
    method takes care of this for us; it travels up the DOM tree until it finds an
    element matching the selector we provide. This method will prove very useful to
    us in event delegation, which we'll revisit in [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了函数的外部循环；在循环内部，我们需要理解 `$columnCells` 如何填充表列中的 DOM 元素。首先，我们获取正在检查的表格单元格的引用。我们希望允许在表格单元格上或表格单元格内的元素上调用
    `.column()` 方法。`.closest()` 方法为我们处理了这个问题；它在 DOM 树中向上移动，直到找到与我们提供的选择器匹配的元素。这个方法在事件委托中会非常有用，我们将在[第
    10 章](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml)中重新讨论，*高级事件*。
- en: With our table cell in hand, we find its column number using the DOM `.cellIndex`
    property. This gives us a zero-based index of the cell's column; we add `1` to
    this number since we'll be using it in a one-based context later. Then, from the
    cell, we travel up to the nearest `<table>` element, back down to the `<td>` and
    `<th>` elements, and filter these cells down to the appropriate column with an
    `:nth-child()` selector expression.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们手头的表格单元格，我们使用 DOM 的 `.cellIndex` 属性找到它的列号。这给了我们一个基于零的单元格列的索引；我们在稍后的一个基于一的上下文中使用它时加上
    `1`。然后，从单元格开始，我们向上移动到最近的 `<table>` 元素，再返回到 `<td>` 和 `<th>` 元素，并用 `:nth-child()`
    选择器表达式过滤这些单元格，以获取适当的列。
- en: The plugin we're writing is limited to simple, non-nested tables due to the
    `.find('td, th')` call. To support nested tables, we would need to determine whether
    `<tbody>` tags are present and move up and down the DOM tree by the appropriate
    amount, which would add more complexity than is appropriate for this example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的插件仅限于简单的、非嵌套的表格，因为 `.find('td, th')` 调用。要支持嵌套表格，我们需要确定是否存在 `<tbody>`
    标签，并根据适当的数量在 DOM 树中上下移动，这将增加比这个示例适当的更多复杂性。
- en: Once we've found all the cells in the column or columns, we need to return the
    new jQuery object. We could just return `$cells` from our method, but this wouldn't
    properly respect the DOM element stack. Instead, we pass `$cells` to the `.pushStack()`
    method and return the result. This method accepts an array of DOM elements and
    adds them to the stack, so that later calls to methods such as `.addBack()`and
    `.end()` behave correctly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了列中的所有单元格，我们需要返回新的 jQuery 对象。我们可以从我们的方法中直接返回 `$cells`，但这不会正确地尊重 DOM 元素堆栈。相反，我们将
    `$cells` 传递给 `.pushStack()` 方法并返回结果。该方法接受一个 DOM 元素数组，并将它们添加到堆栈中，以便后续对 `.addBack()`
    和 `.end()` 等方法的调用能够正确地工作。
- en: 'To see our plugin in action, we can react to clicks on cells and highlight
    the corresponding column:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看我们的插件运行情况，我们可以对单元格的点击做出反应，并突出显示相应的列：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 9.14
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.14节
- en: 'The `active` class is added to the selected column, resulting in different
    shading when, for instance, one of the author''s names is clicked:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`active` 类将添加到所选列，从而导致不同的着色，例如，当点击其中一位作者的姓名时：'
- en: '![](img/5297_09_13.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_09_13.png)'
- en: DOM traversal performance
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM 遍历性能
- en: 'The rule of thumb about selector performance applies equally to DOM traversal
    performance: we should prioritize ease of code writing and code maintenance when
    possible, only sacrificing legibility for optimization when performance is a measurable
    problem. Again, sites such as [http://jsperf.com/](http://jsperf.com/) are helpful
    in determining the best approach given several options.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择器性能的经验法则同样适用于 DOM 遍历性能：在可能的情况下，我们应该优先考虑代码编写和代码维护的便利性，只有在性能是可测量的问题时才会为了优化而牺牲可读性。同样，诸如
    [http://jsperf.com/](http://jsperf.com/) 这样的网站有助于确定在给定多个选项的情况下采取最佳方法。
- en: While premature optimization should be avoided, it is good practice to minimize
    repetition of selectors and traversal methods. As these can be potentially expensive
    tasks, the fewer times we do them, the better. Two strategies for avoiding this
    repetition are **chaining** and **object caching**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应该避免过早地优化，但最小化选择器和遍历方法的重复是一个良好的实践。由于这些可能是昂贵的任务，我们做这些任务的次数越少越好。避免这种重复的两种策略是**链式操作**和**对象缓存**。
- en: Improving performance using chaining
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链式操作来改进性能
- en: We have used chaining many times now, and it has allowed us to keep our code
    concise. There can be a performance benefit to chaining as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经多次使用了链式操作，它使我们的代码保持简洁。链式操作也可能带来性能上的好处。
- en: 'Our `stripe()` function from *Listing 9.9* located the element with the ID
    `news` once instead of twice. It needed to remove the `alt` class from rows that
    no longer needed it, and to apply that class to the new set of rows. Using chaining,
    we combined these two thoughts into one and prevented this repetition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来自*第9.9节*的 `stripe()` 函数只定位了一次具有 ID `news` 的元素，而不是两次。它需要从不再需要的行中移除 `alt` 类，并将该类应用于新的行集。使用链式操作，我们将这两个想法合并成一个，避免了这种重复：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 9.15
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第9.15节
- en: In order to merge the two uses of `$('#news')`, we once again exploit the DOM
    element stack within the jQuery object. The first call to `.find()` pushes the
    table rows onto the stack, but then `.end()` pops this off the stack so that the
    next `.find()` call is operating on the `news` table once again. This kind of
    clever manipulation of the stack is a handy way of avoiding selector duplication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了合并两次使用 `$('#news')`，我们再次利用了 jQuery 对象内部的 DOM 元素堆栈。第一次调用 `.find()` 将表行推送到堆栈上，但然后
    `.end()` 将其从堆栈中弹出，以便下一次 `.find()` 调用再次操作 `news` 表。这种巧妙地操作堆栈的方式是避免选择器重复的便捷方式。
- en: Improving performance with caching
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存来改进性能
- en: Caching is simply storing the result of an operation so that it can be used
    multiple times without running the operation again. In the context of selector
    and traversal performance, we can cache a jQuery object in a constant for later
    use rather than creating a new one.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存只是简单地存储操作的结果，以便可以多次使用而不必再次运行该操作。在选择器和遍历性能的背景下，我们可以将 jQuery 对象缓存到常量中以供以后使用，而不是创建一个新的对象。
- en: 'Returning to our example, we can rewrite the `stripe()` function to avoid selector
    duplication with caching rather than chaining:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，我们可以重写 `stripe()` 函数，以避免选择器重复，而不是链接：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 9.16
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9.16
- en: The two operations are separate JavaScript statements once again, rather than
    being chained together. We're still executing the `$('#news')` selector only once,
    though, by storing the result in `$news`. This caching approach is a little more
    verbose than chaining, since we need to separately create the variable storing
    the jQuery object. Obviously, creating more constants to manage in our code is
    less desirable than chaining together function calls. But sometimes, chaining
    is simply too complex, and caching objects like this is the better choice.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作再次是分开的 JavaScript 语句，而不是链接在一起。尽管如此，我们仍然只执行了一次 `$('#news')` 选择器，通过将结果存储在
    `$news` 中。这种缓存方法比链接更繁琐，因为我们需要单独创建存储 jQuery 对象的变量。显然，在代码中创建更多的常量比链接函数调用更不理想。但有时，链接简单地太复杂了，像这样缓存对象是更好的选择。
- en: Because selecting elements on the page by ID is extremely fast, neither of these
    examples will have a big performance impact, and in practice we'd choose the approach
    that seemed the most legible and maintainable. These techniques are useful tools,
    though, when performance is found to be a concern.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为通过 ID 在页面上选择元素非常快，所以这些示例都不会对性能产生很大的影响，实际上我们会选择看起来最易读和易于维护的方法。但是当性能成为一个关注点时，这些技术是有用的工具。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we delved more deeply into jQuery's extensive capabilities
    for finding elements in a document. We've looked at some of the details of how
    the Sizzle selector engine works, and the implications this has on designing effective
    and efficient code. In addition, we have explored the ways in which we can extend
    and enhance jQuery's selectors and DOM traversal methods.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地了解了 jQuery 在查找文档中的元素方面的广泛功能。我们看了一些关于 Sizzle 选择器引擎如何工作的细节，以及这对设计有效和高效代码的影响。此外，我们还探讨了扩展和增强
    jQuery 选择器和 DOM 遍历方法的方式。
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A complete list of selectors and traversal methods is available in [Appendix
    B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml), *Quick Reference* in this book,
    or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 [附录 B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)、“快速参考” 中或在官方 jQuery
    文档中，提供了一份完整的选择器和遍历方法列表。
- en: Exercises
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The challenge exercises may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战性练习可能需要在 [http://api.jquery.com/](http://api.jquery.com/) 官方 jQuery 文档中使用。
- en: Modify the table row striping routine so that it gives no class to the first
    row, a class of `alt` to the second row, and a class of `alt-2` to the third row.
    Repeat this pattern for every set of three rows in a section.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改表格行条纹的例程，使其不给第一行任何类，第二行给予 `alt` 类，第三行给予 `alt-2` 类。对每组三行的行重复此模式。
- en: Create a new selector plugin called `:containsExactly()` that selects elements
    with text content that exactly matches what is put inside the parentheses.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `:containsExactly()` 的新选择器插件，它选择具有与括号内放置的内容完全匹配的文本内容的元素。
- en: Use this new `:containsExactly()`selector to rewrite the filtering code from
    *Listing 9.3*.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新的 `:containsExactly()` 选择器来重写 *清单 9.3* 中的过滤代码。
- en: Create a new DOM traversal plugin method called `.grandparent()` that moves
    from an element or elements to their grandparent elements in the DOM.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `.grandparent()` 的新 DOM 遍历插件方法，它从一个或多个元素移动到它们在 DOM 中的祖父元素。
- en: '**Challenge**: Using [http://jsperf.com/](http://jsperf.com/), paste in the
    content of `index.html` and compare the performance of finding the closest ancestor
    table element of `<td id="release">` using the following:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挑战**：使用 [http://jsperf.com/](http://jsperf.com/)，粘贴 `index.html` 的内容并比较使用以下内容查找
    `<td id="release">` 的最近祖先表元素的性能：'
- en: The `.closest()` method
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.closest()` 方法'
- en: The `.parents()` method, limiting the result to the first table found
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.parents()` 方法，将结果限制为找到的第一个表格'
- en: '**Challenge**: Using [http://jsperf.com/](http://jsperf.com/), paste in the
    content of `index.html` and compare the performance of finding the final `<td>`
    element in each row using the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挑战**：使用 [http://jsperf.com/](http://jsperf.com/)，粘贴 `index.html` 的内容并比较使用以下内容查找每一行中最后一个
    `<td>` 元素的性能：'
- en: The `:last-child` pseudo-class
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:last-child` 伪类'
- en: The `:nth-child()` pseudo-class
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:nth-child()` 伪类'
- en: The `.last()` method within each row (using `.each()` to loop over the rows)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行内的`.last()`方法（使用`.each()`循环遍历行）
- en: The `:last` pseudo-class within each row (using `.each()` to loop over the rows)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行内的`:last`伪类（使用`.each()`循环遍历行）
