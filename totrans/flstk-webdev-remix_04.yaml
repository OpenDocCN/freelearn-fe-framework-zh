- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Routing in Remix
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remix 中的路由
- en: “Routing is possibly the most important concept to understand in Remix.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “路由可能是理解 Remix 中最重要的概念。”
- en: – Remix documentation
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – Remix 文档
- en: Michael Jackson and Ryan Florence spent years building React Router. It is not
    a surprise that routing plays an integral role in Remix. One core idea that Michael
    and Ryan brought over from React Router to Remix is nested routing. Nested routing
    is a powerful feature that enables the composition of route components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔·杰克逊和瑞安·弗洛里斯花费了多年时间构建 React Router。路由在 Remix 中扮演着核心角色并不令人惊讶。迈克尔和瑞安从 React
    Router 带到 Remix 的一个核心思想是嵌套路由。嵌套路由是一个强大的功能，它能够组合路由组件。
- en: 'In this chapter, you will learn about routing in Remix. We’ll cover the following
    topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 Remix 中的路由。我们将涵盖以下主题：
- en: Working with Remix's route module API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Remix 的路由模块 API 进行工作
- en: Composing pages from nested routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从嵌套路由组合页面
- en: Using route parameters for dynamic routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由参数进行动态路由
- en: Sharing layouts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享布局
- en: Handling navigations in Remix
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Remix 中处理导航
- en: In this chapter, we will dive into nested routing and cover Remix’s route convention.
    We will start by creating standalone pages and reviewing Remix’s route module
    exports. Next, we will review nested, index, dynamic, and (pathless) layout routes.
    Finally, we will learn how to transition between routes and learn about the global
    navigation object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解嵌套路由并介绍 Remix 的路由约定。我们将从创建独立页面并回顾 Remix 的路由模块导出开始。接下来，我们将回顾嵌套、索引、动态和（无路径）布局路由。最后，我们将学习如何在路由之间进行转换，并了解全局导航对象。
- en: By the end of this chapter, you will understand the core principles behind Remix’s
    routing solution. You will have practiced creating new route modules and know
    which exports Remix supports. You will understand the advantages of nested routing
    and layout routes. You will also practice how to work with route parameters. Finally,
    you will know how to work with Remix’s global navigation object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 Remix 路由解决方案背后的核心原则。您将练习创建新的路由模块，并了解 Remix 支持哪些导出。您将理解嵌套路由和布局路由的优势。您还将练习如何处理路由参数。最后，您将了解如何使用
    Remix 的全局导航对象。
- en: In this chapter, we will add a login and a signup page to the BeeRich application.
    We will further create a dashboard route with nested expenses and income child
    routes. Then, we will create a shared layout for the index, login, and signup
    pages. Finally, we will animate page transitions using the global navigation object.
    Let’s jump right into it and create our first routes in Remix.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向 BeeRich 应用程序添加登录和注册页面。我们将进一步创建一个包含嵌套支出和收入子路由的仪表板路由。然后，我们将为索引、登录和注册页面创建共享布局。最后，我们将使用全局导航对象来动画化页面转换。让我们直接进入正题，并在
    Remix 中创建我们的第一个路由。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043), *Deployment Targets, Adapters,
    and Stacks*, we set up the demo application for this book. If you haven’t already,
    make sure to follow the instructions of [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043),
    as we will continue working with BeeRich in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 3 章*](B17399_03.xhtml#_idTextAnchor043)，*部署目标、适配器和堆栈*中，我们为本书设置了演示应用程序。如果您还没有这样做，请确保遵循[*第
    3 章*](B17399_03.xhtml#_idTextAnchor043)的说明，因为我们将在本章继续使用 BeeRich。
- en: 'You can find the solution code and additional information to this chapter on
    GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的解决方案代码和附加信息：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix)。
- en: Working with Remix's route module API
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Remix 的路由模块 API 进行工作
- en: Remix takes on the responsibilities of a compiler, a runtime, and a router.
    In Remix, you create routes (route modules) as part of a hierarchy. Among other
    things, Remix’s router determines which route modules to match and render on a
    request.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 承担了编译器、运行时和路由器的责任。在 Remix 中，您将创建路由（路由模块）作为层次结构的一部分。在其他方面，Remix 的路由器确定哪些路由模块与请求匹配并渲染。
- en: This section will walk you through the creation of route modules in Remix. You
    will learn how to create standalone pages and understand how routes tie back to
    the `root.tsx` file. You will further understand how index routes fit into the
    picture (or, I should say, on a screen). Finally, the section will introduce you
    to the different available exports that route modules can expose.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导你如何在Remix中创建路由模块。你将学习如何创建独立的页面，并了解路由如何与`root.tsx`文件相关联。你将进一步了解索引路由是如何融入画面（或者说，我应该说是屏幕）的。最后，本节将介绍路由模块可以公开的不同导出。
- en: Route file-naming conventions
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由文件命名规范
- en: Before we get started, note that Remix switched to a new route file-naming convention
    with Remix v2\. This book follows that convention.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请注意，Remix从Remix v2开始切换到新的路由文件命名约定。本书遵循该约定。
- en: 'If you are new to Remix, then this chapter will get you started with Remix’s
    latest convention. If you have prior experience with Remix’s v1 filesystem route
    convention, you can refer to this guide to learn what has changed: [https://remix.run/docs/en/1.19.3/file-conventions/route-files-v2](https://remix.run/docs/en/1.19.3/file-conventions/route-files-v2).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触Remix，那么这一章将帮助你开始使用Remix的最新约定。如果你之前有使用Remix v1文件系统路由约定的经验，你可以参考以下指南了解有哪些变化：[https://remix.run/docs/en/1.19.3/file-conventions/route-files-v2](https://remix.run/docs/en/1.19.3/file-conventions/route-files-v2)。
- en: Working with file-based routing
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于文件的路由进行工作
- en: 'We start by inspecting the current route structure of BeeRich. We will continue
    with the BeeRich code from the previous chapter. Alternatively, you can find the
    start code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks/bee-rich](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks/bee-rich).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查BeeRich当前的路线结构。我们将继续使用上一章的BeeRich代码。或者，你可以在以下位置找到本章的起始代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks/bee-rich](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks/bee-rich)。
- en: 'Let’s review the current route hierarchy:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾当前的路线层次结构：
- en: 'Run the following command in a terminal at the root of your Remix project:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Remix项目的根目录下终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s run our application locally by executing `npm run dev` in a terminal.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在本地运行我们的应用程序，通过在终端中执行`npm run dev`来启动。
- en: Open the application in your browser by navigating to [http://localhost:3000/](http://localhost:3000/).
    This routes us to the `/`path of the application. Welcome (again) to BeeRich!
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中导航到[http://localhost:3000/](http://localhost:3000/)来打开应用程序。这将把我们引导到应用程序的`/`路径。欢迎（再次）来到BeeRich！
- en: 'Back in your editor, open the `app/routes/_index.tsx` file. The file contains
    the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中，打开`app/routes/_index.tsx`文件。该文件包含以下代码：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s visit the `/demo` page. Add `demo` to the URL in the address bar
    of your browser. The demo page showcases available reusable components that we
    can use to build our BeeRich application.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们访问`/demo`页面。在浏览器地址栏的URL中添加`demo`。演示页面展示了我们可以用来构建BeeRich应用程序的可用可重用组件。
- en: Open the `app/routes/demo.tsx` file. Note that we again export a React component
    as the default export of the module.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/routes/demo.tsx`文件。注意，我们再次将React组件作为模块的默认导出。
- en: There is some magic at play here. We didn’t need to specify the routes hierarchy
    to Remix explicitly through code. No configuration file maps components to pathnames.
    This is the power of `routes` folder’s hierarchy. It creates an **asset manifest**
    that includes the route hierarchy of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些魔法在起作用。我们不需要通过代码明确指定Remix的路由层次结构。没有配置文件将组件映射到路径名。这是`routes`文件夹层次结构的强大之处。它创建了一个**资产清单**，其中包括应用程序的路由层次结构。
- en: When visiting a page, Remix knows which route components to render. Exporting
    the route component as the default export is a convention so that Remix can find
    your code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问一个页面时，Remix知道要渲染哪个路由组件。将路由组件作为默认导出是一个约定，这样Remix就能找到你的代码。
- en: Let’s dive into the conventions of Remix’s file-based routing and create some
    standalone pages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解Remix的基于文件的路由约定，并创建一些独立的页面。
- en: Creating route modules
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建路由模块
- en: 'In [*Chapter 8*](B17399_08.xhtml#_idTextAnchor119), *Session Management*, we
    will add a signup and login authentication flow to BeeRich. In this chapter, we
    will set up the general route structure to do so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B17399_08.xhtml#_idTextAnchor119) *会话管理*中，我们将向BeeRich添加注册和登录认证流程。在这一章中，我们将设置一般的路由结构来完成此操作：
- en: Create a new file in the `routes` folder and name it `login.tsx`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes`文件夹中创建一个新文件，并将其命名为`login.tsx`。
- en: Next, use the address bar of your browser to navigate to the newly created page
    ([http://localhost:3000/login](http://localhost:3000/login)).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用浏览器地址栏导航到新创建的页面（[http://localhost:3000/login](http://localhost:3000/login)）。
- en: 'We will see the following error pop up on the screen:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在屏幕上看到以下错误弹出：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A UI route must export a React component as its default export. This is part
    of the conventions of Remix’s file-based routing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: UI路由必须导出一个React组件作为其默认导出。这是Remix基于文件的路由约定的一部分。
- en: 'To remove the error from the screen, switch to your editor and add a React
    component to the newly created `login.tsx` file. The following code should suffice
    for now:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从屏幕上移除错误，切换到您的编辑器并在新创建的`login.tsx`文件中添加一个React组件。现在以下代码就足够了：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we use `H1`, a reusable component from the `app/components` folder,
    to avoid rewriting a bunch of custom styling.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们使用`H1`，来自`app/components`文件夹的可重用组件，以避免重写大量的自定义样式。
- en: Also, note that the import path starts with a tilde symbol (`~`). This is a
    neat TypeScript feature. We map the `app` folder to `~` in our `tsconfig.json`
    path configuration. This allows us to use the tilde symbol as a shorthand to target
    any file or folder in the `app` folder.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意导入路径以波浪线符号（`~`）开头。这是一个整洁的TypeScript特性。我们在`tsconfig.json`路径配置中将`app`文件夹映射到`~`。这允许我们使用波浪线符号作为快捷方式来定位`app`文件夹中的任何文件或文件夹。
- en: Refresh the browser window. The `/login` page should now render correctly. Awesome!
    You just created your first standalone page with Remix!
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新浏览器窗口。现在`/login`页面应该可以正确渲染。太棒了！您刚刚使用Remix创建了一个独立的页面！
- en: Next, create a `signup.tsx` file in the `routes` folder. Then, copy and paste
    the code from the login page and adapt the code to better fit the signup page.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`routes`文件夹中创建一个`signup.tsx`文件。然后，从登录页面复制并粘贴代码，并调整代码以更好地适应注册页面。
- en: Use the address bar of your browser to navigate to the newly created page ([http://localhost:3000/signup](http://localhost:3000/signup)).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器地址栏导航到新创建的页面（[http://localhost:3000/signup](http://localhost:3000/signup)）。
- en: 'Let’s run the `remix routes` command again to see how the routes hierarchy
    grew. Execute the following command in your terminal:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行`remix routes`命令来查看路由层次结构是如何增长的。在您的终端中执行以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This yields the following route hierarchy:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这产生了以下路由层次结构：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As expected, the routes hierarchy grew by two leave routes. Each leaf route
    represents a page in the application. Our application now handles the following
    four pathnames:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，路由层次结构增加了两个叶子路由。每个叶子路由代表应用程序中的一个页面。我们的应用程序现在处理以下四个路径名：
- en: '`/`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`'
- en: '`/``demo`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``demo`'
- en: '`/``login`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``login`'
- en: '`/``signup`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``signup`'
- en: So far, all our route modules in the `routes` folder are document/UI routes
    that render React components as part of the route hierarchy to the page. In the
    following section, we will provide a short overview of available route module
    exports and discuss the differences between UI and resource routes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们`routes`文件夹中的所有路由模块都是文档/UI路由，它们作为路由层次结构的一部分渲染React组件到页面。在下一节中，我们将提供可用的路由模块导出的简要概述，并讨论UI和资源路由之间的区别。
- en: Available route module exports
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的路由模块导出
- en: In Remix, we distinguish between resource routes and UI routes. Each UI route
    must export a React component as the default export. Resource routes do not export
    a React component as the default export. Instead, resource routes must export
    an `action` and/or a `loader` function. Among other things, resource routes can
    expose API endpoints, handle Webhooks, or create assets on the fly. We will create
    our first resource route later in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Remix中，我们区分资源路由和UI路由。每个UI路由必须导出一个React组件作为默认导出。资源路由不导出一个React组件作为默认导出。相反，资源路由必须导出一个`action`和/或`loader`函数。除了其他功能外，资源路由可以公开API端点，处理Webhooks或动态创建资产。我们将在本章后面创建我们的第一个资源路由。
- en: 'Remix inspects the exported functions of a route module to determine whether
    it is a UI or a resource route. While resource routes only support exporting an
    `action` or a `loader` function, UI routes can export the following named exports:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Remix检查路由模块导出的函数以确定它是一个UI路由还是一个资源路由。虽然资源路由仅支持导出`action`或`loader`函数，但UI路由可以导出以下命名的导出：
- en: '`action`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`'
- en: '`ErrorBoundary`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorBoundary`'
- en: '`handle`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle`'
- en: '`headers`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`'
- en: '`links`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`'
- en: '`loader`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loader`'
- en: '`meta`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`'
- en: '`shouldRevalidate`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldRevalidate`'
- en: We will learn more about the role of these exports in the following chapters.
    For now, let’s focus on how Remix uses the route module exports. Remix compiles
    the route hierarchy during build time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中了解更多关于这些导出角色的信息。现在，让我们专注于 Remix 如何使用路由模块导出。Remix 在构建时编译路由层次结构。
- en: 'In your file explorer, navigate to `public/build/` and open the `manifest-*.js`
    file. The manifest file is created after building the application (`npm run build`
    or `npm run dev`) and includes a routes section. The routes section contains an
    entry for every route module in the app. The entry for the `demo.tsx` route looks
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文件资源管理器中，导航到 `public/build/` 并打开 `manifest-*.js` 文件。清单文件是在构建应用程序后创建的（`npm
    run build` 或 `npm run dev`），其中包含一个路由部分。路由部分包含应用程序中每个路由模块的条目。`demo.tsx` 路由的条目如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in the code, Remix keeps track of the exported functions via Boolean
    flags. The Boolean flags are set to `false`, since our demo route does not export
    `action`, `loader`, or `ErrorBoundary`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，Remix 通过布尔标志跟踪导出的函数。布尔标志设置为 `false`，因为我们的演示路由没有导出 `action`、`loader` 或
    `ErrorBoundary`。
- en: Remix’s route module exports are part of the file-based route convention. Remix
    compiles the content of the route folder and generates a manifest file. This is
    how Remix lets us avoid a route hierarchy configuration in code and instead promotes
    a convention-based route hierarchy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的路由模块导出是文件路由约定的一部分。Remix 编译路由文件夹的内容并生成一个清单文件。这就是 Remix 让我们避免在代码中进行路由层次结构配置，而是促进基于约定的路由层次结构的原因。
- en: In this section, we created two new route modules and learned about the supported
    named exports of route modules in Remix. We also used the `remix routes` command
    to visualize our routes hierarchy. In the following section, we will dive into
    nested routing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了两个新的路由模块，并了解了 Remix 中路由模块支持的命名导出。我们还使用了 `remix routes` 命令来可视化我们的路由层次结构。在下一节中，我们将深入探讨嵌套路由。
- en: Composing pages from nested routes
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从嵌套路由组合页面
- en: BeeRich is a personal bookkeeping application. Users should be able to view
    their expenses and sources of income. In this section, we will create a hierarchy
    of nested routes to compose the dashboard pages of BeeRich.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 是一个个人记账应用程序。用户应该能够查看他们的支出和收入来源。在本节中，我们将创建嵌套路由的层次结构来组合 BeeRich 的仪表板页面。
- en: So far, we have seen `Outlet` being used in the `root.tsx` file. The `Outlet`
    component declares the location of the child route inside the markup of the parent
    route. The `Outlet` component in `root.tsx` is rendered inside the HTML `body`.
    Hence, all child routes are wrapped inside the `body` element. This is the power
    of nested routing. With nested routing, you can compose pages out of several route
    modules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到 `Outlet` 在 `root.tsx` 文件中被使用。`Outlet` 组件在父路由的标记中声明了子路由的位置。`root.tsx`
    中的 `Outlet` 组件在 HTML 的 `body` 元素内渲染。因此，所有子路由都被包裹在 `body` 元素内。这就是嵌套路由的力量。使用嵌套路由，你可以从多个路由模块中组合页面。
- en: 'Let’s use nested routing and the `Outlet` component to construct our dashboard.
    The two routes, `/dashboard/expenses` and `/dashboard/income`, will serve as our
    overview pages:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用嵌套路由和 `Outlet` 组件来构建我们的仪表板。两个路由，`/dashboard/expenses` 和 `/dashboard/income`，将作为我们的概览页面：
- en: 'First, add two files inside the `routes` folder:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `routes` 文件夹内添加两个文件：
- en: '`dashboard.expenses.tsx`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.expenses.tsx`'
- en: '`dashboard.income.tsx`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dashboard.income.tsx`'
- en: Note that we use dot delimiters (`.`) to separate path segments (`/`) in the
    URL.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用点分隔符（`.`）来分隔 URL 中的路径段（`/`）。
- en: Add a simple route component to both files. Review `login.tsx` for reference.
    In both files, export the component as the default export.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个文件中添加一个简单的路由组件。参考 `login.tsx`。在两个文件中，将组件作为默认导出。
- en: Then, run the application (`npm run dev`), and review the changes in a browser
    window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行应用程序（`npm run dev`），并在浏览器窗口中查看更改。
- en: The goal is to list all expenses and sources of income (invoices), respectively.
    For now, we will mock the data and focus on setting up the route hierarchy.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标是分别列出所有支出和收入来源（发票）。目前，我们将模拟数据并专注于设置路由层次结构。
- en: 'Add the following code to the `dashboard.expenses.tsx` file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `dashboard.expenses.tsx` 文件中：
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The provided code renders a hardcoded list of expenses to the page.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供的代码将硬编码的支出列表渲染到页面中。
- en: 'You can also find the final code for this chapter on GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich/solution](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich/solution).'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到本章的最终代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich/solution](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich/solution)。
- en: Similarly, we want to render a list of all sources of income on the `/dashboard/income`
    page. Copy the code from the `dashboard.expenses.tsx` file, and adapt it to render
    hardcoded invoices instead of expenses in `dashboard.income.tsx`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们希望在`/dashboard/income`页面上渲染所有收入来源的列表。从`dashboard.expenses.tsx`文件中复制代码，并将其修改为在`dashboard.income.tsx`中渲染硬编码的发票而不是支出。
- en: As shown in *Figure 4**.1*, both pages now render a list of items. In the future,
    users should also be able to edit an expense or invoice. For that, we will now
    create a nested details view.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如*图4.1*所示，两个页面现在都渲染了一个项目列表。在未来，用户还应该能够编辑支出或发票。为此，我们现在将创建一个嵌套的详细视图。
- en: '![Figure 4.1 – A screenshot of the expenses overview page](img/Figure_4.01_B17399.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 支出概览页面的截图](img/Figure_4.01_B17399.jpg)'
- en: Figure 4.1 – A screenshot of the expenses overview page
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 支出概览页面的截图
- en: 'So far, we have navigated between pages by changing the URL in the address
    bar of the browser. Now, it’s time to add anchor tags. A user should be able to
    click on a list item in the expenses overview to view the details view of the
    expense. Let’s wrap the content of the hardcoded list items with anchor tags.
    The first list item might look as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过在浏览器地址栏中更改URL来在页面之间导航。现在，是时候添加锚标签了。用户应该能够点击支出概览中的列表项以查看支出详情视图。让我们用锚标签包裹硬编码的列表项内容。第一个列表项可能看起来如下：
- en: '[PRE8]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure to wrap each item with an anchor tag.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保每个项目都用锚标签包裹。
- en: Each list item now links to a unique URL that includes the mock identifier of
    the expense. In the following section, we will learn more about dynamic routes
    with parameters. For now, let’s work with made-up mock identifiers to focus on
    the route structure.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个列表项现在都链接到一个包含支出模拟标识符的唯一URL。在下一节中，我们将了解更多关于带有参数的动态路由。现在，让我们使用虚构的模拟标识符来专注于路由结构。
- en: In your browser window, click on one of the list items. A click on an item should
    navigate you to a **404 Not Found** page. That’s expected, considering we did
    not create the associated route module yet.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器窗口中，点击列表项中的一个。点击一个项应该会导航你到一个**404未找到**页面。这是预期的，因为我们还没有创建相关的路由模块。
- en: Let’s add a hardcoded details page for the expense with the identifier `1`.
    Create a `dashboard.expenses.1.tsx` file.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为具有标识符`1`的支出添加一个硬编码的详细页面。创建一个`dashboard.expenses.1.tsx`文件。
- en: 'Add the following code to `dashboard.expenses.1.tsx`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`dashboard.expenses.1.tsx`中：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The newly created details route is dedicated to the expense with the identifier
    `1`. By clicking on a list item in the expenses overview, we should be redirected
    to the details view of the list item.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新创建的详情路由专门用于标识符为`1`的支出。通过在支出概览中点击列表项，我们应该被重定向到列表项的详情视图。
- en: Let’s test our implementation. Use the address bar to navigate back to the `/dashboard/expenses/`
    page. Then, click on the list item with the identifier `1`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试我们的实现。使用地址栏导航回`/dashboard/expenses/`页面。然后，点击具有标识符`1`的列表项。
- en: Snap! Something is wrong! We can see that the URL changes as expected. A click
    on the list item updates the pathname of the URL to `/dashboard/expenses/1`. However,
    the content of the page does not update. We still see the content of the expenses
    overview page. What’s wrong?
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Snap！出问题了！我们可以看到URL如预期那样发生了变化。点击列表项会将URL的路径名更新为`/dashboard/expenses/1`。然而，页面内容并没有更新。我们仍然看到支出概览页面的内容。这是怎么回事？
- en: We created a nested `dashboard.expenses.1.tsx` file within the `/expenses` path.
    But why is the content of the file not appearing on the page? Remix only seems
    to render the `dashboard.expenses.tsx` file.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`/expenses`路径内创建了一个嵌套的`dashboard.expenses.1.tsx`文件。但为什么文件的内容没有出现在页面上？Remix似乎只渲染了`dashboard.expenses.tsx`文件。
- en: The issue is that `dashboard.expenses.tsx` and `dashboard.expenses.1.tsx` both
    match the same path (`/dashboard/expenses/`). By doing so, we promoted the `dashboard.expenses.tsx`
    file to be a parent layout route module (such as `root.tsx`). If we want to display
    either the content of the `dashboard.expenses.tsx` file or the content of the
    `dashboard.expenses.1.tsx` file, then we need to make `dashboard.expenses.tsx`
    a sibling instead of a parent route.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题在于`dashboard.expenses.tsx`和`dashboard.expenses.1.tsx`都匹配相同的路径（`/dashboard/expenses/`）。通过这样做，我们将`dashboard.expenses.tsx`文件提升为父布局路由模块（如`root.tsx`）。如果我们想显示`dashboard.expenses.tsx`文件的内容或`dashboard.expenses.1.tsx`文件的内容，那么我们需要将`dashboard.expenses.tsx`从一个父路由改为兄弟路由。
- en: You learned earlier that index routes are used as the default child routes of
    a URL path segment. Let’s try to fix the issue by adding an index route.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您之前已经了解到索引路由被用作URL路径段的默认子路由。让我们通过添加索引路由来尝试修复问题。
- en: Rename the `dashboard.expenses.tsx` file to `dashboard.expenses._index.tsx`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dashboard.expenses.tsx`文件重命名为`dashboard.expenses._index.tsx`。
- en: By doing so, we declare the two route modules in the `expenses` path as siblings.
    Sibling route modules always match different pathnames.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样做，我们在`expenses`路径中声明了两个路由模块为兄弟关系。兄弟路由模块始终匹配不同的路径名。
- en: In your browser window, navigate back to the `/dashboard/expenses/` page. Now,
    click on the list item to navigate to `/dashboard/expenses/1`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器窗口中，导航回`/dashboard/expenses/`页面。现在，点击列表项以导航到`/dashboard/expenses/1`。
- en: The UI now updates as expected between the two pages. By declaring the two route
    modules as siblings, we either show the overview or the details page content.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在UI在两个页面之间按预期更新。通过将两个路由模块声明为兄弟关系，我们显示概览页面或详细页面内容。
- en: Remix’s route hierarchy distinguishes parent and sibling routes of a specific
    URL path. `dashboard.expenses.tsx` is a `/``expenses` path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的路由层次区分了特定URL路径的父路由和兄弟路由。`dashboard.expenses.tsx`是`/`到`expenses`路径。
- en: A parent route utilizes the `Outlet` component to declare where its child components
    should be rendered alongside its own layout. `root.tsx` is the top-level parent
    route.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 父路由使用`Outlet`组件来声明其子组件应与其自己的布局一起渲染的位置。`root.tsx`是顶级父路由。
- en: 'Let’s try it out:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: Undo your changes. Rename the `dashboard.expenses._index.tsx` file back to `dashboard.expenses.tsx`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 撤销您的更改。将`dashboard.expenses._index.tsx`文件重命名为`dashboard.expenses.tsx`。
- en: 'Now, import the `Outlet` component from Remix, and add it below the **All**
    **expenses** section:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从Remix导入`Outlet`组件，并将其添加到**所有****支出**部分下方：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Refresh your browser window. You should now see the expenses overview and the
    details view side by side when visiting `/dashboard/expenses/1`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新您的浏览器窗口。现在，当访问`/dashboard/expenses/1`时，您应该看到支出概览和详细视图并排显示。
- en: '![Figure 4.2 – A screenshot of the expenses overview page with the nested details
    view](img/Figure_4.02_B17399.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 包含嵌套详细视图的支出概览页面截图](img/Figure_4.02_B17399.jpg)'
- en: Figure 4.2 – A screenshot of the expenses overview page with the nested details
    view
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 包含嵌套详细视图的支出概览页面截图
- en: Awesome! We created our first layout route to compose a page from different
    route modules. By using nested routing, we map different segments of the URL to
    different route modules. This creates a hierarchically nested structure. Parent
    routes utilize the `Outlet` component to declare where the child route should
    be rendered on the page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们创建了第一个布局路由，从不同的路由模块中组合页面。通过使用嵌套路由，我们将URL的不同部分映射到不同的路由模块。这创建了一个层次嵌套的结构。父路由使用`Outlet`组件来声明子路由应在页面上渲染的位置。
- en: Note that the `/dashboard` path is not accompanied by a `dashboard.tsx` file.
    This should tell us that layout route modules are optional. We can use layout
    routes to share a common layout across all child routes or create complex pages
    that are made up of different route modules. However, if they're not needed, they
    can be omitted.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`/dashboard`路径没有伴随`dashboard.tsx`文件。这应该告诉我们布局路由模块是可选的。我们可以使用布局路由在所有子路由之间共享一个共同的布局或创建由不同路由模块组成的复杂页面。然而，如果它们不是必需的，则可以省略。
- en: For BeeRich, we want to use a parent layout route instead of an index route
    to render the overview page. With this page architecture, a user can see all expense-related
    information on one page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeeRich，我们希望使用父布局路由而不是索引路由来渲染概览页面。在这种页面架构中，用户可以在一个页面上看到所有与支出相关的信息。
- en: To practice working with parent layout routes, make sure to update the income
    pages and add the `Outlet` component to the `dashboard.income.tsx` file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习使用父布局路由，请确保更新收入页面并将 `Outlet` 组件添加到 `dashboard.income.tsx` 文件中。
- en: In this section, you learned how you can compose a page out of different route
    modules. Remix maps segments of the URL to different route modules in the routes
    hierarchy. With parent layout routes, we can nest and render child routes inside
    parent routes. Each page is then made up of code from different nested route modules.
    Next, we will refactor the hardcoded parameter routes and utilize parameterized
    path segments to create dynamic expense details pages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何将页面组合成不同的路由模块。Remix 将 URL 的段映射到路由层次结构中的不同路由模块。使用父布局路由，我们可以在父路由内部嵌套和渲染子路由。然后，每个页面由不同嵌套路由模块的代码组成。接下来，我们将重构硬编码的参数路由并利用参数化路径段来创建动态支出详情页面。
- en: Using route parameters for dynamic routing
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由参数进行动态路由
- en: URLs often include parameters such as identifiers to specify associated resources.
    This allows the application to retrieve the right data for the request. In this
    section, you will learn how to work with URL parameters in Remix.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: URL 通常包含标识符等参数，用于指定相关资源。这允许应用程序检索请求的正确数据。在本节中，你将学习如何在 Remix 中处理 URL 参数。
- en: So far, we have created a route module for a hardcoded expenses details page
    (`/dashboard.expenses.1.tsx`). The number `1` in the URL refers to the expense
    with the expense identifier `1`. However, the goal is to create a dynamic route
    module capable of handling variable identifiers. Luckily, Remix provides a convention
    for how to define a parameterized route segment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为硬编码的支出详情页面创建了一个路由模块 (`/dashboard.expenses.1.tsx`)。URL 中的数字 `1` 指的是具有支出标识符
    `1` 的支出。然而，目标是创建一个能够处理变量标识符的动态路由模块。幸运的是，Remix 提供了一种定义参数化路由段的方法。
- en: Parameterized route segments
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化路由段
- en: In Remix, dynamic segments of the URL are referred to as parameterized segments.
    We use the `$` symbol to declare a route parameter. This turns the URL segment
    into a parameter that we can access and use to fetch data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix 中，URL 的动态段被称为参数化段。我们使用 `$` 符号来声明路由参数。这会将 URL 段转换为我们可以访问并用于获取数据的参数。
- en: 'Let’s see how we can use a parameterized segment in BeeRich for the expenses
    details route:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 BeeRich 中使用参数化段来处理支出详情路由：
- en: Rename `dashboard.expenses.1.tsx` to `dashboard.expenses.$id.tsx`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `dashboard.expenses.1.tsx` 重命名为 `dashboard.expenses.$id.tsx`。
- en: The `$` symbol is part of Remix’s routing convention and declares a parameter
    for a dynamic route segment.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$` 符号是 Remix 的路由约定的一部分，用于声明动态路由段的参数。'
- en: 'Next, update the code inside the file and add the following mock data:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新文件内的代码并添加以下模拟数据：
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The mock data acts as our data source for now. We will add a real database in
    [*Chapter 5*](B17399_05.xhtml#_idTextAnchor078), *Fetching and* *Mutating Data*.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟数据目前是我们的数据源。我们将在 [*第 5 章*](B17399_05.xhtml#_idTextAnchor078) 中添加一个真实数据库，*获取和*
    *修改数据*。
- en: 'After that, add a `loader` function with the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加一个具有以下代码的 `loader` 函数：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the file’s route component, we can access the loader response data with
    the `useLoaderData` hook. Update the existing component code as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的路线组件中，我们可以使用 `useLoaderData` 钩子访问 `loader` 响应数据。按照以下方式更新现有的组件代码：
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure to test the implementation. Use the anchor tags of the expenses list
    to navigate between the different expenses details routes.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保测试实现。使用支出列表的锚点标签在不同的支出详情路由之间导航。
- en: As visible in the code, the `loader` function throws a `Response` if no expense
    identifier matches the route parameter. If you see an error, double-check that
    the identifier exists in the mock expenses array. And yes, you can throw `Response`
    objects with Remix – something we will explore in the next section.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如代码所示，如果没有任何支出标识符与路由参数匹配，`loader` 函数会抛出一个 `Response`。如果你看到错误，请确保标识符存在于模拟支出数组中。是的，你可以使用
    Remix 抛出 `Response` 对象——我们将在下一节中探讨这一点。
- en: Once you have tested your implementation, create a similar experience for the
    income page. This will help you practice what you have learned so far.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你测试了你的实现，为收入页面创建一个类似的经验。这将帮助你练习到目前为止所学的内容。
- en: 'If you haven’t already, wrap each list element in the `dashboard.income.tsx`
    file with an anchor element. Then, create the `dashboard.income.$id.tsx` file
    and implement the `loader` function. In case you get stuck, review the implementation
    of the expenses details route and apply it to `dashboard.income.$id.tsx`. You
    can also refer to the troubleshooting process from [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030),
    *Creating a New Remix App*. Finally, you can find the final solution for this
    chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请将`dashboard.income.tsx`文件中的每个列表元素包裹在一个锚点元素中。然后，创建`dashboard.income.$id.tsx`文件并实现`loader`函数。如果你遇到困难，请回顾支出详情路由的实现并将其应用于`dashboard.income.$id.tsx`。你也可以参考来自[*第2章*](B17399_02.xhtml#_idTextAnchor030)的故障排除过程，*创建新的Remix应用*。最后，你可以在本章节的最终解决方案中找到：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich)。
- en: In this section, you learned how to work with dynamic route segments and how
    to declare route parameters. You also got a short introduction to Remix’s `loader`
    function and the `useLoaderData` hook. In the following section, we will utilize
    shared layouts to improve our application’s look and feel.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何处理动态路由段以及如何声明路由参数。你还简要了解了Remix的`loader`函数和`useLoaderData`钩子。在下一节中，我们将利用共享布局来改进我们应用程序的外观和感觉。
- en: Sharing layouts
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享布局
- en: Nested routing enables us to compose a page from a nested route hierarchy. In
    this section, we will utilize parent routes to reuse layouts between nested child
    routes. We will also learn how to share code between routes without creating new
    segments in the URL, with pathless layout routes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套路由使我们能够从嵌套路由层次结构中组合页面。在本节中，我们将利用父路由在嵌套子路由之间重用布局。我们还将学习如何在路由之间共享代码，而无需在URL中创建新段，使用无路径布局路由。
- en: Using parent layout routes
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用父布局路由
- en: Let’s improve the look and feel of the BeeRich dashboard. Ideally, a user should
    be able to quickly switch between the income and expenses overview pages. It’s
    time to add a navigation bar.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进BeeRich仪表板的外观和感觉。理想情况下，用户应该能够快速在收入和支出概览页面之间切换。是时候添加导航栏了。
- en: We already utilized parent layout routes for the `dashboard/expenses` and `dashboard/income`
    pages. By rendering the list of expenses and income in a parent route (`dashboard.expenses.tsx`
    and `dashboard.income.tsx`, respectively), we nested the content of the child
    routes on the same page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`dashboard/expenses`和`dashboard/income`页面使用了父布局路由。通过在父路由（`dashboard.expenses.tsx`和`dashboard.income.tsx`，分别）中渲染支出和收入的列表，我们在同一页面上嵌套了子路由的内容。
- en: 'Now, we will take advantage of nested routing again to add a shared navigation
    bar to all dashboard pages. Follow these steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次利用嵌套路由来为所有仪表板页面添加共享导航栏。按照以下步骤操作：
- en: Create a `dashboard.tsx` file inside the `routes` folder.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes`文件夹内创建一个`dashboard.tsx`文件。
- en: Since the `dashboard.tsx` route module matches the `dashboard` path segment,
    it acts as the parent route for the segment’s nested route modules.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`dashboard.tsx`路由模块与`dashboard`路径段匹配，它充当该段嵌套路由模块的父路由。
- en: 'Add the following code to `dashboard.tsx`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`dashboard.tsx`中：
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code adds a navigation bar inside an HTML `header` element and renders Remix’s
    `Outlet` component inside a `main` element.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码在HTML的`header`元素内添加了一个导航栏，并在`main`元素内渲染Remix的`Outlet`组件。
- en: Run the app (`npm run dev`), and visit `/dashboard/expenses` in your browser
    window to review the changes.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用（`npm run dev`），然后在浏览器窗口中访问`/dashboard/expenses`以查看更改。
- en: As visible in *Figure 4**.3*, by adding a parent route module, we wrap every
    child route of `dashboard` with the markup rendered inside `dashboard.tsx`. Layout
    routes provide a great way to wrap all child routes in a common layout.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如*图4**.3*所示，通过添加父路由模块，我们将`dashboard`的每个子路由都包裹在`dashboard.tsx`中渲染的标记内。布局路由提供了一种将所有子路由包裹在公共布局中的绝佳方式。
- en: '![Figure 4.3 – A screenshot of the expenses page with a shared dashboard layout](img/Figure_4.03_B17399.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 共享仪表板布局的支出页面截图](img/Figure_4.03_B17399.jpg)'
- en: Figure 4.3 – A screenshot of the expenses page with a shared dashboard layout
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 共享仪表板布局的支出页面截图
- en: Let’s also add a navigation bar to our login, signup, and home (`_index.tsx`)
    pages. We could again use a parent layout route to share a common layout. However,
    this would add a new route segment to the path. It turns out that adding a parent
    route is not what we want. A parent route would alter the URL, but the home page
    should be located at the `/`path. Likewise, we want the login page to be located
    at `/login` and signup at `/signup`. Instead, let’s see how we can make a layout
    route pathless.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将导航栏添加到我们的登录、注册和主页（`_index.tsx`）页面。我们再次可以使用父布局路由来共享公共布局。然而，这将向路径添加一个新的路由段。结果证明，添加父路由并不是我们想要的。父路由会改变URL，但主页应该位于`/`路径。同样，我们希望登录页面位于`/login`，注册页面位于`/signup`。相反，让我们看看如何使布局路由路径无路径。
- en: Using pathless layout routes
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用无路径布局路由
- en: Luckily, Remix has a way of declaring `$` symbol declares a parameterized route
    module, using an underscore prefix (`_`) declares a pathless layout route. Pathless
    routes behave just like parent layout routes but do not add segments to the URL
    path.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Remix提供了一种声明方式：使用`$`符号声明参数化路由模块，使用下划线前缀（`_`）声明无路径布局路由。无路径路由的行为就像父布局路由一样，但不会向URL路径添加段。
- en: 'Let’s add a pathless layout route to share a layout between the login, signup,
    and home pages:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个无路径布局路由，以便在登录、注册和主页之间共享布局：
- en: Create a new `_layout.tsx` file in the `routes` folder.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes`文件夹中创建一个新的`_layout.tsx`文件。
- en: The underscore tells Remix to treat the route module as pathless. The route
    module’s name will not be added to the URL. You already know the underscore prefix
    from index routes, which serves a similar purpose.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下划线告诉Remix将路由模块视为无路径。路由模块的名称将不会添加到URL中。您已经从索引路由中了解到下划线前缀，它具有类似的作用。
- en: Note that the chosen name, `layout`, is not part of the convention – you can
    name the route module as you like.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，选定的名称`layout`不是约定的一部分——您可以按自己的喜好命名路由模块。
- en: 'Next, add the following code to the `routes/_layout.tsx` file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到`routes/_layout.tsx`文件中：
- en: '[PRE15]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code adds a navigation bar and renders `Outlet` in a styled `main` element.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码添加了一个导航栏并在一个样式化的`main`元素中渲染`Outlet`。
- en: Rename the `_index.tsx`, `login.tsx`, and `signup.tsx` route modules `_layout._index.tsx`,
    `_layout.login.tsx`, and `_layout.signup.tsx`, respectively.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`_index.tsx`、`login.tsx`和`signup.tsx`路由模块分别重命名为`_layout._index.tsx`、`_layout.login.tsx`和`_layout.signup.tsx`。
- en: Remove the `main` HTML tag from the `_index.tsx` JSX code, as it is now already
    rendered by the `__layout.tsx` module. That is the power of composition and nested
    routing. We can reduce code duplication and reuse layouts.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`_index.tsx` JSX代码中删除`main` HTML标签，因为它现在已经被`__layout.tsx`模块渲染。这就是组合和嵌套路由的力量。我们可以减少代码重复并重用布局。
- en: As always, make sure to test your changes before moving on. Run the application,
    and visit the `/`, `/login`, and `/signup` pages by trying out the new navigation
    bar.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，在继续之前确保测试您的更改。运行应用程序，并通过尝试新的导航栏来访问`/`、`/login`和`/signup`页面。
- en: In this section, you learned how to utilize layout routes to add common structure
    and styling to nested child routes. You were also introduced to pathless layout
    routes to share a layout without adding route segments to the URL path. In the
    following section, we will learn more about page navigations in Remix.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何利用布局路由为嵌套子路由添加公共结构和样式。您还介绍了无路径布局路由，以便在不向URL路径添加路由段的情况下共享布局。在下一节中，我们将学习更多关于Remix中页面导航的内容。
- en: Handling navigations in Remix
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理Remix中的导航
- en: So far, we have used anchor tags to navigate between pages. You might have noticed
    that every navigation – using an anchor tag – triggers a full-page reload. This
    is the browser’s default behavior when navigating between pages. However, Remix
    also offers primitives for client-side navigations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用锚点标签在页面之间进行导航。您可能已经注意到，每次导航（使用锚点标签）都会触发整个页面的重新加载。这是浏览器在页面之间导航时的默认行为。然而，Remix也提供了客户端导航的原语。
- en: In this section, we will introduce you to Remix’s link components and Remix’s
    global navigation object. We will practice utilizing the navigation object to
    indicate page loads and learn more about server-side redirects with Remix.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍Remix的链接组件和Remix的全局导航对象。我们将练习使用导航对象来指示页面加载，并了解Remix中关于服务器端重定向的更多信息。
- en: Navigating with Remix’s link components
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Remix的链接组件进行导航
- en: By default, a page navigation triggers a document request to the web server
    of the resource. The web server forwards the request to Remix (our HTTP request
    handler). Remix then renders a new document on the server to fulfill the request
    and responds with the rendered HTML document (or any other HTTP response).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，页面导航会触发对资源Web服务器的文档请求。Web服务器将请求转发到Remix（我们的HTTP请求处理器）。然后Remix在服务器上渲染一个新的文档以满足请求，并响应以渲染的HTML文档（或任何其他HTTP响应）。
- en: 'When utilizing Remix’s link components, Remix prevents the browser’s default
    behavior from making full-page requests. Instead, Remix executes fetch requests
    using the web''s Fetch API to fetch the required data for the requested URL. We
    avoid a full-page reload and instead execute a client-side navigation. Let''s
    replace the anchor tags in BeeRich with Remix’s links components – `Link` and
    `NavLink`. You can find styled example implementations for both link components
    in `/app/components/links.tsx`. For more information about the two components,
    visit the React Router documentation: [https://reactrouter.com/en/6.15.0/components/nav-link](https://reactrouter.com/en/6.15.0/components/nav-link):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Remix的链接组件时，Remix阻止浏览器默认行为进行全页请求。相反，Remix使用Web的Fetch API执行fetch请求来获取请求URL所需的数据。我们避免全页刷新，并执行客户端导航。让我们用Remix的链接组件（`Link`和`NavLink`）替换BeeRich中的锚标签。你可以在`/app/components/links.tsx`中找到这两个链接组件的样式示例实现。有关这两个组件的更多信息，请访问React
    Router文档：[https://reactrouter.com/en/6.15.0/components/nav-link](https://reactrouter.com/en/6.15.0/components/nav-link)：
- en: 'Fiirst, replace the anchor tags in `routes/_layout.tsx` with. Update the code
    as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`routes/_layout.tsx`中的锚标签替换为。按照以下代码更新：
- en: '[PRE16]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of using Remix's NavLink component directly, we use a styled wrapper
    component.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不是直接使用Remix的NavLink组件，而是使用一个样式包装组件。
- en: Next, run the application (`npm run dev`) and open it in a browser window. Navigate
    to the home page of the app. The navigation bar should now show three decently
    styled links.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行应用程序（`npm run dev`）并在浏览器窗口中打开它。导航到应用程序的主页。现在导航栏应该显示三个样式不错的链接。
- en: On the home page, click on either the **Log in** or **Sign up** link. You should
    see that the favicon in the tab of the browser window no longer indicates a full-page
    reload. Instead, Remix now fetches the required data and assets using JavaScript’s
    Fetch API, performing a client-side navigation. With these changes, our Remix
    app feels much more like an SPA.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页上，点击**登录**或**注册**链接。你应该看到浏览器窗口标签页中的favicon不再表示全页刷新。相反，Remix现在使用JavaScript的Fetch
    API获取所需数据和资产，执行客户端导航。这些更改使得我们的Remix应用程序感觉更像是一个单页应用（SPA）。
- en: 'Now, let’s refactor the code of the `dashboard.tsx` parent route. Import the
    `Container` and `NavLink` components from the `components` folder, import `Link`
    from Remix, and apply the following changes:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重构`dashboard.tsx`父路由的代码。从`components`文件夹中导入`Container`和`NavLink`组件，从Remix导入`Link`，并应用以下更改：
- en: '[PRE17]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, refactor the `dashboard.expenses.tsx` route module:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重构`dashboard.expenses.tsx`路由模块：
- en: '[PRE18]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, replace the anchor tags in `dashboard.income.tsx` with the `ListLinkItem`
    component. Use the `dashboard.expenses.tsx` file for reference.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将`dashboard.income.tsx`中的锚标签替换为`ListLinkItem`组件。以`dashboard.expenses.tsx`文件为参考。
- en: Run the application locally, and visit a browser window. Test the links on the
    expenses and income overview pages. Note how Remix no longer executes full-page
    reloads to navigate between the pages.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行应用程序，并在浏览器窗口中访问。测试支出和收入概览页面上的链接。注意Remix不再执行全页刷新来在页面之间导航。
- en: Opting for Remix’s link components avoids page reloads. With full-page reloads,
    we must re-fetch all data on every navigation. When using Remix’s link components,
    Remix only fetches the data required for newly added route modules. However, we
    can also see that Remix works just fine when using anchor tags. Remix enhances
    the experience with JavaScript where possible but can fall back to a browser’s
    default behavior if necessary.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Remix的链接组件可以避免页面刷新。在使用全页刷新时，我们必须在每次导航时重新获取所有数据。当使用Remix的链接组件时，Remix只获取新添加的路由模块所需的数据。然而，我们也可以看到当使用锚标签时，Remix仍然可以正常工作。Remix尽可能使用JavaScript来增强体验，但在必要时可以回退到浏览器的默认行为。
- en: Sometimes, when we attempt to enhance the experience with JavaScript, we might
    accidentally degrade the experience instead. By default, a browser replaces the
    tab's favicon with a loading indicator during page load. Without a full-page reload,
    we lose any indication that a page transition is happening. This is especially
    frustrating for users with slower internet connections. In the following section,
    we will utilize Remix’s global transition object to re-add page loading indicators.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们试图用JavaScript增强体验时，我们可能会无意中降低体验。默认情况下，浏览器在页面加载期间用加载指示器替换标签页的favicon。如果没有完整的页面重新加载，我们就失去了页面转换发生的任何指示。这对于网络连接较慢的用户来说尤其令人沮丧。在下一节中，我们将利用Remix的全局转换对象重新添加页面加载指示器。
- en: Indicating page transitions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指示页面转换
- en: 'You might ask yourself why we would need page load indicators. Navigations
    are so fast on `localhost` that you barely notice them. However, they can feel
    brutally long on **slow 3G** connections. Let’s prove that page transitions are
    necessary:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问自己为什么我们需要页面加载指示器。在`localhost`上导航如此之快，以至于您几乎注意不到它们。然而，在**慢速3G**连接上，它们可能会感觉非常漫长。让我们证明页面转换是必要的：
- en: Run BeeRich by executing `npm run dev` in the project’s `root` folder.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目的`root`文件夹中执行`npm run dev`来运行BeeRich。
- en: Open the application in your browser by visiting [http://localhost:3000](http://localhost:3000).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问[http://localhost:3000](http://localhost:3000)在浏览器中打开应用程序。
- en: Open the developer tools of your browser, and navigate to the **Network** tab.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开浏览器开发者工具，并导航到**网络**标签。
- en: Search for the throttling functionality, and select **Slow 3G** from the provided
    dropdown.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索节流功能，并从下拉菜单中选择**慢速3G**。
- en: Also, check the **Disable cache** checkbox to simulate a user’s first visit.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要检查**禁用缓存**复选框以模拟用户的首次访问。
- en: All popular browsers offer similar settings. Search on Google if you can’t find
    the described throttle and cache functionalities.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有主流浏览器都提供类似的设置。如果您找不到描述的节流和缓存功能，请在Google上搜索。
- en: Make sure to reload the browser window to reset the browser cache.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保重新加载浏览器窗口以重置浏览器缓存。
- en: Finally, navigate between the different pages of your app.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的应用的不同页面之间导航。
- en: '![Figure 4.4 – A screenshot of the Network tab of the Chrome DevTools](img/Figure_4.04_B17399.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – Chrome DevTools网络标签的截图](img/Figure_4.04_B17399.jpg)'
- en: Figure 4.4 – A screenshot of the Network tab of the Chrome DevTools
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – Chrome DevTools网络标签的截图
- en: How is the experience? Using a slow internet connection shows how important
    loading indicators are. By removing the browser’s default behavior (the loading
    spinner on the browser window tab), we robbed the user of a clear loading indication.
    We degraded the user experience. Luckily, Remix provides a global navigation object,
    which we can use to re-add loading indicators with JavaScript.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 体验如何？使用慢速互联网连接显示了加载指示器的重要性。通过移除浏览器的默认行为（浏览器窗口标签上的加载旋转器），我们剥夺了用户清晰的加载指示。我们降低了用户体验。幸运的是，Remix提供了一个全局导航对象，我们可以使用JavaScript重新添加加载指示器。
- en: 'First, let’s add a loading indicator to the expense and income detail views:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向费用和收入详情视图添加一个加载指示器：
- en: 'Open the `/routes/dashboard.expenses.tsx` file, and import the `useNavigation`
    hook from Remix:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`/routes/dashboard.expenses.tsx`文件，并从Remix导入`useNavigation`钩子：
- en: '[PRE19]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Call the hook inside the route component to access the global navigation object:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由组件内部调用钩子以访问全局导航对象：
- en: '[PRE20]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s see for ourselves! Open a browser window, and navigate to the `expenses`
    page.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们亲自看看！打开浏览器窗口，导航到`费用`页面。
- en: Open the **Console** tab in the browser’s developer tools.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器开发者工具中打开**控制台**标签。
- en: Click on the different expenses in the expenses list.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击费用列表中的不同费用项。
- en: '`navigation.state` is set to `idle` if there is no page navigation. On `GET`
    requests, `navigation.state` is set to `loading`. On form submissions, the state
    is set to `submitting` and then `loading` (as every submission also involves a
    page navigation).'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有页面导航，`navigation.state`设置为`idle`。在`GET`请求中，`navigation.state`设置为`loading`。在表单提交时，状态设置为`submitting`然后`loading`（因为每次提交也涉及页面导航）。
- en: With Remix, we can easily display pending UIs by checking the `navigation.state`
    value.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Remix，我们可以通过检查`navigation.state`值轻松显示挂起的UI。
- en: 'Let’s add a simple CSS animation to `dashboard.expenses.tsx`. First, import
    `clsx` to manage the Tailwind CSS classes:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`dashboard.expenses.tsx`中添加一个简单的CSS动画。首先，导入`clsx`来管理Tailwind CSS类：
- en: '[PRE21]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, wrap the existing `Outlet` component by a styled section:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将现有的`Outlet`组件包裹在一个样式化的部分中：
- en: '[PRE22]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ensure that your browser window is still throttling the network bandwidth. Click
    on the expense items in the expenses overview list, and note that the details
    view pulses when page navigations are in progress.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的浏览器窗口仍然限制网络带宽。点击支出概览列表中的支出项，并注意当页面导航正在进行时，详情视图会闪烁。
- en: Add the same animation to`dashboard.income.tsx` to practice working with Remix's
    navigation object.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的动画添加到 `dashboard.income.tsx` 以练习使用 Remix 的导航对象。
- en: 'Let’s also add a global progress bar to the application:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中添加一个全局进度条：
- en: Open the `root.tsx` file in your editor.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `root.tsx` 文件。
- en: 'Import `PageTransitionProgressBar` from the `components` folder:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `components` 文件夹导入 `PageTransitionProgressBar`：
- en: '[PRE23]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, render the `PageTransitionProgressBar` component inside the root component.
    This ensures that the component is rendered across all routes and pages of our
    application. We place the component inside the body above the `Outlet` component:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在根组件内部渲染 `PageTransitionProgressBar` 组件。这确保了组件将在我们应用程序的所有路由和页面上渲染。我们将组件放置在
    `Outlet` 组件上方：
- en: '[PRE24]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the `components/progress` file in your editor, and review the implementation
    of the `PageTransitionProgressBar` component.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `components/progress` 文件，并检查 `PageTransitionProgressBar` 组件的实现。
- en: In this section, you learned how to utilize the navigation object and the `useNavigation`
    hook to indicate loading states to a user. Now, we will wrap up the chapter by
    introducing server-side redirects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何利用导航对象和 `useNavigation` 钩子向用户指示加载状态。现在，我们将通过介绍服务器端重定向来结束本章。
- en: Redirecting a user from the server
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从服务器重定向用户
- en: Sometimes, the right place to trigger a navigation is on the server. In Remix,
    `loader` functions are a great place to check whether the requested resources
    exist and whether the user can access it. In this section, you will learn more
    about server-side redirects in Remix.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，触发导航的最佳位置是在服务器上。在 Remix 中，`loader` 函数是检查请求的资源是否存在以及用户是否有权访问的好地方。在本节中，你将了解
    Remix 中关于服务器端重定向的更多信息。
- en: 'Review the `dashboard.expenses.$id.tsx` route file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `dashboard.expenses.$id.tsx` 路由文件：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `loader` function, we access the route parameter to find the matching
    expense in the mock data. If we cannot find an expense that matches the `id` parameter,
    we throw a `Response`. Throwing responses is a great way to stop the execution
    early and return an error response. We will learn more about how to handle thrown
    `Response` objects in [*Chapter 7*](B17399_07.xhtml#_idTextAnchor105), *Error
    Handling* *in Remix*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loader` 函数中，我们访问路由参数以在模拟数据中找到匹配的支出。如果我们找不到与 `id` 参数匹配的支出，我们抛出一个 `Response`。抛出响应是提前停止执行并返回错误响应的好方法。我们将在
    [*第 7 章*](B17399_07.xhtml#_idTextAnchor105) 中学习如何处理抛出的 `Response` 对象，*Remix 中的错误处理*。
- en: For now, let's focus on Remix's `request/response` flow. It's important to understand
    that Remix operates both a frontend and a backend, following the client/server
    model of the web. Our frontend app runs in the browser and makes requests to the
    web server (backend). The backend application handles incoming HTTP requests and
    answers with HTTP responses.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于 Remix 的 `request/response` 流。了解 Remix 既是前端又是后端，遵循 Web 的客户端/服务器模型，这一点很重要。我们的前端应用程序在浏览器中运行并向
    Web 服务器（后端）发出请求。后端应用程序处理传入的 HTTP 请求并以 HTTP 响应回答。
- en: 'The great thing about Remix''s request/response model is that instead of being
    custom, it follows the web''s Fetch API standard. In `loader` functions, we return
    `Response` objects, following the Fetch API''s `Response` specification: [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 请求/响应模型的好处在于，它遵循 Web 的 Fetch API 标准，而不是自定义。在 `loader` 函数中，我们返回 `Response`
    对象，遵循 Fetch API 的 `Response` 规范：[https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)。
- en: 'On top of that, Remix provides primitives to create `Response` objects. Instead
    of creating `Response` objects ourselves, we can also use the following three
    helper functions:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Remix 提供了创建 `Response` 对象的原语。我们不仅自己创建 `Response` 对象，还可以使用以下三个辅助函数：
- en: '`defer`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer`'
- en: '`json`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json`'
- en: '`redirect`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect`'
- en: We have already used the `json` helper in our `loader` function. The helper
    returns a `Response` object, with the `Content-Type` HTTP header to `application/json`.
    The `redirect` helper creates `Response` with a `302` status code. `defer` is
    an advanced helper for streaming responses. We will practice working with defer
    in [*Chapter 13*](B17399_13.xhtml#_idTextAnchor194)*, Deferring* *Loader Data*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `loader` 函数中使用了 `json` 辅助函数。该辅助函数返回一个带有 `Content-Type` HTTP 头为 `application/json`
    的 `Response` 对象。`redirect` 辅助函数创建带有 `302` 状态码的 `Response`。`defer` 是一个用于流式传输响应的高级辅助函数。我们将在
    [*第13章*](B17399_13.xhtml#_idTextAnchor194)*，延迟* *加载数据* *中练习使用 defer。
- en: Let’s use `redirect` to fix a bug in our app. Have you noticed what happens
    if you directly navigate to [http://localhost:300/dashboard](http://localhost:300/dashboard)?
    We render an empty dashboard.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `redirect` 来修复我们应用程序中的一个错误。你注意到如果你直接导航到 [http://localhost:300/dashboard](http://localhost:300/dashboard)
    会发生什么吗？我们渲染了一个空白的仪表盘。
- en: Can you think of a reason for that behavior? The `/dashboard` path segment currently
    has no default child (a nested index route module). Conclusively, the `/dashboard`
    path matches with neither of the child routes when visiting the `/dashboard` path.
    When visiting [http://localhost:300/dashboard](http://localhost:300/dashboard),
    `Outlet` in `dashboard.tsx` returns `null`, and our dashboard remains empty.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到为什么会有这种行为吗？当前 `/dashboard` 路径段没有默认子路径（一个嵌套的索引路由模块）。最终，当访问 `/dashboard` 路径时，它与子路由中的任何一个都不匹配。当访问
    [http://localhost:300/dashboard](http://localhost:300/dashboard) 时，`dashboard.tsx`
    中的 `Outlet` 返回 `null`，我们的仪表盘保持为空。
- en: Sometimes, not having a default child route is not an issue. On the `/dashboard/expenses`
    and `/dashboard/income` overview pages, the `Outlet` also returns `null` when
    no identifier is added to the URL. Displaying an overview list without rendering
    a details view seems fine.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，没有默认子路由并不是一个问题。在 `/dashboard/expenses` 和 `/dashboard/income` 概览页面上，当 URL
    中没有添加标识符时，`Outlet` 也返回 `null`。在没有渲染详细视图的情况下显示概览列表似乎没问题。
- en: For `/dashboard`, we should think of a better solution than rendering an empty
    dashboard. For instance, we could create a `dashboard._index.tsx` file and export
    a route component that renders a simple welcome message. Or we redirect the user
    to another page!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `/dashboard`，我们应该考虑比渲染一个空仪表盘更好的解决方案。例如，我们可以创建一个 `dashboard._index.tsx` 文件，并导出一个渲染简单欢迎信息的路由组件。或者我们可以将用户重定向到另一个页面！
- en: 'Create a `dashboard._index.tsx` file in the `routes` folder, and add the following
    code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes` 文件夹中创建一个 `dashboard._index.tsx` 文件，并添加以下代码：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With these simple four lines of code, we create our first resource route. A
    resource route does not export a route component (otherwise, it would be a UI
    route). Instead, a resource route exports a `loader` function and/or `action`
    function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这简单的四行代码，我们创建了我们的第一个资源路由。资源路由不导出一个路由组件（否则它将是一个 UI 路由）。相反，资源路由导出一个 `loader`
    函数和/或 `action` 函数。
- en: Here, we use a `loader` function to immediately redirect the user to the expenses
    overview page. If a user enters [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    into the address bar, then the `loader` function returns a `Response` with the
    `30x` status code – a redirect.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `loader` 函数立即将用户重定向到支出概览页面。如果用户在地址栏中输入 [http://localhost:3000/dashboard](http://localhost:3000/dashboard)，那么
    `loader` 函数将返回一个带有 `30x` 状态码的 `Response` - 一个重定向。
- en: 'Try it out by navigating to [http://localhost:3000/dashboard](http://localhost:3000/dashboard).
    In your terminal, the server logs should look as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到 [http://localhost:3000/dashboard](http://localhost:3000/dashboard) 来尝试一下。在你的终端中，服务器日志应该如下所示：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On navigation to `/dashboard`, we redirect (the `302` status code) to the `/dashboard/expenses`
    route, which is then served (the `200` status code).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航到 `/dashboard` 时，我们重定向（`302` 状态码）到 `/dashboard/expenses` 路径，然后它被服务（`200`
    状态码）。
- en: 'Note that `redirect` is just a helper function to create a redirect `Response`
    object. It is nothing more than a simple wrapper for convenience:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`redirect` 只是一个用于创建重定向 `Response` 对象的辅助函数。它不过是一个简单的包装，方便使用：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remix provides full access to the web platform. You can create and return `Response`
    objects with varying status codes, instance properties, caching headers, and much
    more. All you need to do is follow the MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)).
    Later in this book, we will implement real-time functionality, add caching headers,
    and elegantly handle authentication errors, all by using the web platform’s `Response`
    API.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了对整个 Web 平台的完全访问权限。你可以创建并返回具有不同状态码、实例属性、缓存头等 `Response` 对象。你所需要做的就是遵循
    MDN Web 文档（[https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)）。在本书的后续部分，我们将实现实时功能，添加缓存头，并优雅地处理认证错误，所有这些都将通过使用
    Web 平台的 `Response` API 完成。
- en: In this section, you learned about server-side redirects. You now understand
    that Remix executes `loader` functions on the server and that `loader` functions
    must return a `Response` object (or something that Remix can parse into a `Response`
    object). You also practiced redirecting a user from a resource route to a UI route.
    Now, let’s reflect on what you learned in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了服务器端重定向。你现在理解了 Remix 在服务器上执行 `loader` 函数，并且 `loader` 函数必须返回一个 `Response`
    对象（或 Remix 可以解析为 `Response` 对象的东西）。你还练习了将用户从资源路由重定向到 UI 路由。现在，让我们回顾一下本章所学的内容。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Remix provides a convention-based file-based router. Arguably the most powerful
    feature of Remix’s router is nested routing. In Remix, you create routes (route
    modules) as part of a hierarchy. Remix’s router maps the pathname of the URL to
    a set of matching route modules. Route modules make up the pages of your Remix
    application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了一个基于约定的文件路由器。可以说，Remix 路由器最强大的功能之一是嵌套路由。在 Remix 中，你创建路由（路由模块）作为层次结构的一部分。Remix
    的路由器将 URL 的路径名映射到一组匹配的路由模块。路由模块构成了你的 Remix 应用程序的页面。
- en: In this chapter, you created your first routes in Remix. We started off by creating
    two standalone pages. You learned about the special role of index routes as the
    default children of their parent routes. You were also introduced to the exports
    available in Remix’s route modules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你在 Remix 中创建了你的第一个路由。我们首先创建了两个独立的页面。你学习了索引路由作为其父路由默认子路由的特殊作用。你还了解了 Remix
    路由模块中可用的导出。
- en: Next, we created a nested route hierarchy for our dashboard. We used parent
    layout routes and the `Outlet` component to reuse styling and content across different
    child routes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的仪表板创建了一个嵌套路由层次结构。我们使用了父布局路由和 `Outlet` 组件在不同的子路由之间重用样式和内容。
- en: We also used a `loader` function and a route parameter to create routes for
    our income and expenses details views. You learned how to declare parameterized
    route modules using the `$` syntax. You also used Remix’s `userLoaderData` hook
    to access JSON data returned from a `loader` function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `loader` 函数和路由参数来创建我们的收入和支出详情视图的路由。你学习了如何使用 `$` 语法声明参数化路由模块。你还使用了 Remix
    的 `userLoaderData` 钩子来访问 `loader` 函数返回的 JSON 数据。
- en: Thereafter, we used pathless layout routes to share layouts across different
    child routes without adding a path segment to a URL. You created a pathless route
    that wraps the login, signup, and home pages of BeeRich.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们使用了无路径布局路由，在不同子路由之间共享布局，而不需要在 URL 中添加路径段。你创建了一个无路径路由，用于包裹 BeeRich 的登录、注册和主页。
- en: You also learned about navigations and transitions in Remix. We replaced the
    HTML anchor tags with Remix’s `Link` and `NavLink` components. Now, you understand
    the benefits of avoiding full-page reloads and know that Remix fetches required
    scripts and data on each page request.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了 Remix 中的导航和过渡。我们用 Remix 的 `Link` 和 `NavLink` 组件替换了 HTML 锚标签。现在，你理解了避免完整页面重新加载的好处，并知道
    Remix 在每个页面请求时都会获取所需的脚本和数据。
- en: You further learned about the `useNavigation` hook and Remix’s navigation object.
    You practiced adding loading indicators to a page by using the state property
    of the navigation object. Finally, you learned more about the `Request`/`Response`
    model in Remix and how to redirect a user from the server.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你还进一步学习了 `useNavigation` 钩子和 Remix 的导航对象。你通过使用导航对象的 state 属性来练习向页面添加加载指示器。最后，你学习了更多关于
    Remix 中的 `Request`/`Response` 模型以及如何从服务器重定向用户。
- en: In the following chapter, you will learn about data loading and mutations in
    Remix. We will use Remix’s `action` and `loader` functions to implement the UI
    necessary to manage our expenses and income data in BeeRich.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解在 Remix 中的数据加载和变更。我们将使用 Remix 的 `action` 和 `loader` 函数来实现管理 BeeRich
    中我们的支出和收入数据的 UI。
- en: Further reading
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, you learned about the key concepts of Remix’s routing solution.
    You can find more concepts, such as optional route modules, in Remix’s route documentation:
    [https://remix.run/docs/en/2/file-conventions/routes](https://remix.run/docs/en/2/file-conventions/routes).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Remix 路由解决方案的关键概念。你可以在 Remix 的路由文档中找到更多概念，例如可选的路由模块：[https://remix.run/docs/en/2/file-conventions/routes](https://remix.run/docs/en/2/file-conventions/routes)。
- en: 'Read about Remix’s `Link` and `NavLink` components in the Remix documentation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Remix 文档中了解 `Link` 和 `NavLink` 组件：
- en: '[https://remix.run/docs/en/2/components/link](https://remix.run/docs/en/2/components/link)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://remix.run/docs/en/2/components/link](https://remix.run/docs/en/2/components/link)'
- en: '[https://remix.run/docs/en/2/components/nav-link](https://remix.run/docs/en/2/components/nav-link)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://remix.run/docs/en/2/components/nav-link](https://remix.run/docs/en/2/components/nav-link)'
- en: 'You can read more about the `Request`/`Response` model of the Fetch API here:
    [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 Fetch API 的 `Request`/`Response` 模型：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。
- en: Part 2 – Working with Remix and the Web Platform
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 使用 Remix 和 Web 平台
- en: In this part, you will gain hands-on experience with Remix’s primitives, conventions,
    and levers and build a full stack web application from start to finish. You will
    gain a deep understanding of Remix’s request-response flow, progressive enhancement,
    and how to build robust user experiences with error and session management in
    mind. Finally, you will practice working with web assets and file uploads in Remix.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将获得使用 Remix 的原语、约定和杠杆的实际经验，并从头到尾构建一个全栈 Web 应用程序。你将深入理解 Remix 的请求-响应流程、渐进增强，以及如何考虑错误和会话管理来构建健壮的用户体验。最后，你将练习在
    Remix 中处理 Web 资产和文件上传。
- en: 'This part has the following chapters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B17399_05.xhtml#_idTextAnchor078), *Fetching and Mutating Data*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B17399_05.xhtml#_idTextAnchor078), *获取和变更数据*'
- en: '[*Chapter 6*](B17399_06.xhtml#_idTextAnchor090), *Enhancing the User Experience*'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B17399_06.xhtml#_idTextAnchor090), *增强用户体验*'
- en: '[*Chapter 7*](B17399_07.xhtml#_idTextAnchor105), *Error Handling in Remix*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B17399_07.xhtml#_idTextAnchor105), *Remix 中的错误处理*'
- en: '[*Chapter 8*](B17399_08.xhtml#_idTextAnchor119), *Session Management*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B17399_08.xhtml#_idTextAnchor119), *会话管理*'
- en: '[*Chapter 9*](B17399_09.xhtml#_idTextAnchor137), *Assets and Metadata Handling*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B17399_09.xhtml#_idTextAnchor137), *处理资产和元数据*'
- en: '[*Chapter 10*](B17399_10.xhtml#_idTextAnchor154), *Working with File Uploads*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B17399_10.xhtml#_idTextAnchor154), *处理文件上传*'
