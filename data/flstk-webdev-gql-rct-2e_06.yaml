- en: '*Chapter 4*: Hooking Apollo into React'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：将Apollo集成到React中'
- en: Sequelize makes it easy to access and query our database. Posts, chats, and
    messages can be saved to our database in a snap. React helps us to view and update
    our data by building a **user interface** (**UI**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize使我们能够轻松访问和查询我们的数据库。帖子、聊天和信息可以瞬间保存到我们的数据库中。React通过构建**用户界面**（**UI**）帮助我们查看和更新我们的数据。
- en: In this chapter, we will introduce Apollo's React client to our frontend to
    connect it with the backend. We will query, create, and update post data using
    our frontend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的前端引入Apollo的React客户端，以便将其与后端连接。我们将使用前端查询、创建和更新帖子数据。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing and configuring Apollo Client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Apollo客户端
- en: Sending requests with GQL and Apollo's Query component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GQL和Apollo的Query组件发送请求
- en: Mutating data with Apollo Client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apollo客户端修改数据
- en: Implementing chats and messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现聊天和信息
- en: Pagination in React and GraphQL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React和GraphQL中的分页
- en: Debugging with the Apollo Client Devtools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apollo客户端Devtools进行调试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter04)'
- en: Installing and configuring Apollo Client
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置Apollo客户端
- en: We have tested our GraphQL **application programming interface** (**API**) multiple
    times during development. We can now start to implement the data layer of our
    frontend code. In later chapters, we will focus on other tasks, such as authentication
    and client-side routing. For now, we will aim to use our GraphQL API with our
    React app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们已经多次测试了我们的GraphQL **应用程序编程接口**（**API**）。现在，我们可以开始实现前端代码的数据层。在后面的章节中，我们将专注于其他任务，例如身份验证和客户端路由。目前，我们的目标是使用我们的GraphQL
    API与我们的React应用程序一起使用。
- en: To start, we must install the React Apollo Client library. Apollo Client is
    a GraphQL client that offers excellent integration with React and the ability
    to easily fetch data from our GraphQL API. Furthermore, it handles actions such
    as caching and subscriptions, to implement real-time communication with your GraphQL
    backend. Although Apollo Client is named after the Apollo brand, it is not tied
    to Apollo Server. You can use Apollo Client with any GraphQL API or schema out
    there, as long as they follow the protocol standards. You will soon see how perfectly
    the client merges with our React setup.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须安装React Apollo客户端库。Apollo客户端是一个GraphQL客户端，它提供了与React的优秀集成，并能够轻松从我们的GraphQL
    API获取数据。此外，它处理缓存和订阅等操作，以实现与GraphQL后端的实时通信。尽管Apollo客户端以Apollo品牌命名，但它并不依赖于Apollo
    Server。只要遵循协议标准，您就可以使用Apollo客户端与任何GraphQL API或模式一起使用。您很快就会看到客户端如何完美地与我们的React设置合并。
- en: 'As always, there are many alternatives out there. You can use any GraphQL client
    that you wish with the current API that we have built. This openness is the great
    thing about GraphQL: it uses an open standard for communication. Various libraries
    implement the GraphQL standard, and you are free to use any of them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有很多替代方案。您可以使用我们构建的当前API中的任何GraphQL客户端。这种开放性是GraphQL的伟大之处：它使用开放标准进行通信。各种库实现了GraphQL标准，您可以自由使用其中的任何一个。
- en: Important Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The most well-known alternatives are Relay (which is made by Facebook) and `graphql-request`
    (which is made by the people behind Prisma). All of these are great libraries
    that you are free to use. Personally, I mostly rely on Apollo, but Relay is highly
    recommended as well. You can find a long list of packages related to the GraphQL
    ecosystem at [https://github.com/chentsulin/awesome-graphql](https://github.com/chentsulin/awesome-graphql).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最知名的替代方案是Facebook开发的Relay和由Prisma背后的人开发的`graphql-request`。所有这些都是优秀的库，您可以自由使用。我个人主要依赖Apollo，但Relay也非常推荐。您可以在[https://github.com/chentsulin/awesome-graphql](https://github.com/chentsulin/awesome-graphql)找到与GraphQL生态系统相关的长列表的包。
- en: In addition to special client libraries, you could also just use a plain `fetch`
    method or `XMLHttpRequest` requests. The disadvantage is that you need to implement
    caching, write `request` objects, and integrate the `request` method into your
    application on your own. I do not recommend doing this because it takes a lot
    of time and you want to put that time into your business, not into implementing
    existing functionalities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '除了特殊的客户端库之外，你也可以仅仅使用普通的`fetch`方法或`XMLHttpRequest`请求。缺点是你需要自己实现缓存、编写`request`对象，并将`request`方法集成到你的应用程序中。我不建议这样做，因为它需要花费很多时间，而你希望将时间投入到你的业务中，而不是实现现有功能。 '
- en: Installing Apollo Client
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Apollo客户端
- en: 'We use `npm` to install our client dependencies, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`npm`安装客户端依赖项，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We need to install the following two packages to get the GraphQL client running:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使GraphQL客户端运行，我们需要安装以下两个包：
- en: '`@apollo/client` is the wrapping package for all of the packages that we installed.
    Apollo Client relies on all the other packages.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@apollo/client`是我们安装的所有包的包装包。Apollo客户端依赖于所有其他包。'
- en: '`graphql` is a reference implementation for GraphQL and provides logic to parse
    GraphQL queries.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphql`是GraphQL的参考实现，它提供了解析GraphQL查询的逻辑。'
- en: You will see how these packages work together in this section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本节中看到这些包是如何协同工作的。
- en: 'To get started with the manual setup of Apollo Client, create a new folder
    and file for the client, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始手动设置Apollo客户端，创建一个新的文件夹和文件，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will set up Apollo Client in this `index.js` file. Our first setup will represent
    the most basic configuration to get a working GraphQL client.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本地的`index.js`文件中设置Apollo客户端。我们的首次设置将代表最基本的配置，以便获得一个可工作的GraphQL客户端。
- en: Tip
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The code that follows was taken from the official Apollo documentation. Generally,
    I recommend reading through the Apollo documentation as it is very well written.
    You can find this at [https://www.apollographql.com/docs/react/essentials/get-started.html](https://www.apollographql.com/docs/react/essentials/get-started.html).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是从官方Apollo文档中摘录的。通常，我建议阅读Apollo文档，因为它写得非常好。你可以在[https://www.apollographql.com/docs/react/essentials/get-started.html](https://www.apollographql.com/docs/react/essentials/get-started.html)找到它。
- en: 'Just insert the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 只需插入以下代码：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code uses all of the new packages, apart from `react-apollo`.
    Let''s break down the code, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了所有的新包，除了`react-apollo`。让我们按以下方式分解代码：
- en: First, at the top of the file, we imported all required functions and classes
    from the `@apollo/client` package.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在文件顶部，我们导入了`@apollo/client`包中所有必需的函数和类。
- en: We instantiated `ApolloClient`. For this to work, we passed some parameters,
    which are the `link` and `cache` properties.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实例化了`ApolloClient`。为了使其工作，我们传递了一些参数，即`link`和`cache`属性。
- en: 'The `link` property is filled by the `from` command. This function walks through
    an array of links and initializes each of them, one by one. The links are described
    further here:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`属性由`from`命令填充。这个函数遍历一个链接数组，并逐个初始化它们。链接的描述如下：'
- en: a. The first link is the error link. It accepts a function that tells Apollo
    what should be done if an error occurs.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 第一个链接是错误链接。它接受一个函数，告诉Apollo如果发生错误应该做什么。
- en: b. The second link is the **HyperText Transfer Protocol** (**HTTP**) link for
    Apollo. You have to offer a **Uniform Resource Identifier** (**URI**), under which
    our Apollo or GraphQL server is reachable. Apollo Client sends all requests to
    this URI. Notably, the order of execution is the same as the array that we just
    created.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 第二个链接是Apollo的**超文本传输协议**（**HTTP**）链接。你必须提供一个**统一资源标识符**（**URI**），通过该URI我们可以访问我们的Apollo或GraphQL服务器。Apollo客户端会将所有请求发送到这个URI。值得注意的是，执行顺序与刚刚创建的数组顺序相同。
- en: The `cache` property takes an implementation for caching. One implementation
    can be the default package, `InMemoryCache`, or a different cache.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`属性接受一个缓存实现。一个实现可以是默认包`InMemoryCache`，或者不同的缓存。'
- en: Important Note
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are many more properties that our links can understand (especially the
    HTTP link). They feature a lot of different customization options, which we will
    look at later. You can also find them in the official documentation, at [https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/).
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的链接可以理解许多更多属性（尤其是HTTP链接）。它们提供了许多不同的自定义选项，我们将在稍后查看。你还可以在官方文档中找到它们，网址为[https://www.apollographql.com/docs/react/](https://www.apollographql.com/docs/react/)。
- en: In the preceding code snippet, we exported the initialized Apollo Client using
    the `export default client` line. We are now able to use it in our React app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 `export default client` 行导出了初始化的 Apollo Client。我们现在可以在我们的 React
    应用程序中使用它。
- en: The basic setup to send GraphQL requests using Apollo Client is finished. In
    the next section, we will send our first GraphQL request through Apollo Client.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apollo Client 发送 GraphQL 请求的基本设置已完成。在下一节中，我们将通过 Apollo Client 发送我们的第一个 GraphQL
    请求。
- en: Testing Apollo Client
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Apollo Client
- en: 'Before inserting the GraphQL client directly into our React application tree,
    we should test it. We will write some temporary code to send our first GraphQL
    query. After testing our GraphQL client, we will remove the code again. Follow
    these next steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 GraphQL 客户端直接插入我们的 React 应用程序树之前，我们应该对其进行测试。我们将编写一些临时代码来发送我们的第一个 GraphQL
    查询。测试完我们的 GraphQL 客户端后，我们将再次删除代码。按照以下步骤操作：
- en: 'Import the package at the top of the Apollo Client setup, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Apollo Client 设置的顶部导入包，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add the following code before the client is exported:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在客户端导出之前添加以下代码：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is almost the same as the example from the Apollo documentation,
    but I have replaced their query with one that matches our backend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码几乎与阿波罗文档中的示例相同，但我已经将他们的查询替换为与我们的后端匹配的一个。
- en: Here, we used the `gql` tool from Apollo Client to parse a `gql` command parses
    this literal to an **abstract syntax tree** (**AST**). ASTs are the first step
    of GraphQL; they are used to validate deeply nested objects, the schema, and the
    query. The client sends our query after the parsing has been completed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Apollo Client 的 `gql` 工具来解析一个 `gql` 命令，将这个字面量解析为一个 **抽象语法树**（**AST**）。ASTs
    是 GraphQL 的第一步；它们用于验证深度嵌套的对象、模式以及查询。客户端在解析完成后发送我们的查询。
- en: Tip
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to know more about ASTs, the people at *Contentful* wrote a great
    article about what ASTs mean to GraphQL, at [https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/](https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 ASTs 的信息，*Contentful* 的人写了一篇关于 ASTs 对 GraphQL 意义的精彩文章，请参阅 [https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/](https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/)。
- en: To test the preceding code, we should start the server and the frontend. One
    option is to build the frontend now, and then start the server. In this case,
    the `npm run server` and then open a second terminal. Then, you can start the
    `webpack` development server by executing `npm run client`. A new browser tab
    should open automatically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试前面的代码，我们应该启动服务器和前端。一个选项是现在构建前端，然后启动服务器。在这种情况下，执行 `npm run server` 并然后在第二个终端中打开。然后，你可以通过执行
    `npm run client` 来启动 `webpack` 开发服务器。应该会自动打开一个新的浏览器标签页。
- en: 'However, we have forgotten something: the client is set up in our new file,
    but it is not yet used anywhere. Import it in the `index.js` root file of our
    client React app, below the import of the `App` component, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们忘记了一些事情：客户端已设置在我们的新文件中，但尚未在任何地方使用。在客户端 React 应用的 `index.js` 根文件中导入它，在 `App`
    组件导入下方，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The browser should be reloaded, and the query sent. You should be able to see
    a new log inside the console of the developer tools of your browser.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器应该重新加载，并发送查询。你应该能在浏览器开发者工具的控制台中看到一条新的日志。
- en: 'The output should look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![Figure 4.1 – Manual client response'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 手动客户端响应'
- en: '](img/Figure_4.01_B17337.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.01_B17337.jpg]'
- en: Figure 4.1 – Manual client response
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 手动客户端响应
- en: 'The `data` object looks much like the response that we received when sending
    requests through Postman, except that it now has some new properties: `loading`
    and `networkStatus`. Each of these stands for a specific status, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 对象看起来与通过 Postman 发送请求时收到的响应非常相似，但现在它有一些新的属性：`loading` 和 `networkStatus`。每个都代表一个特定的状态，如下所示：'
- en: '`loading`, as you might expect, indicates whether the query is still running
    or has already finished.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`，正如你所期望的，表示查询是否仍在运行或已经完成。'
- en: '`networkStatus` goes beyond this and gives you the exact status of what happened.
    For example, the number 7 indicates that there are no running queries that produce
    errors. The number 8 means that there has been an error. You can look up the other
    numbers in the official GitHub repository, at [https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts](https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networkStatus` 超出了这个范围，并提供了发生事件的精确状态。例如，数字 7 表示没有正在运行的查询产生错误。数字 8 表示发生了错误。您可以在官方
    GitHub 仓库中查找其他数字，网址为 [https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts](https://github.com/apollographql/apollo-client/blob/main/src/core/networkStatus.ts)。'
- en: Now that we have verified that the query has run successfully, we can connect
    Apollo Client to the React `import` statement in the `App.js` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了查询已成功运行，我们可以将 Apollo Client 连接到 `App.js` 文件中的 React `import` 语句。
- en: Binding Apollo Client to React
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Apollo Client 绑定到 React
- en: 'We have tested Apollo Client and have confirmed that it works. However, React
    does not yet have access to it. Since Apollo Client is going to be used everywhere
    in our application, we can set it up in our root `index.js` file, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了 Apollo Client 并确认它正常工作。然而，React 还没有访问权限。由于 Apollo Client 将在我们的应用程序的每个地方使用，我们可以在根
    `index.js` 文件中设置它，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we mentioned in [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*, you should only edit this file when
    the whole application needs access to the new component. In the preceding code
    snippet, you can see that we import the last package that we installed at the
    beginning, from `@apollo/client/react`. The `ApolloProvider` component that we
    extracted from it is the first layer of our React application. It surrounds the
    `App` component, passing the Apollo Client that we wrote to the next level. To
    do this, we pass `client` to the provider as a property. Every underlying React
    component can now access Apollo Client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 1 章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017) 中提到的，*准备您的开发环境*，您应该只在整个应用程序需要访问新组件时编辑此文件。在前面的代码片段中，您可以看到我们从
    `@apollo/client/react` 中导入了我们最初安装的最后一个包。我们从其中提取的 `ApolloProvider` 组件是我们 React
    应用程序的第一层。它包围了 `App` 组件，并将我们编写的 Apollo Client 传递给下一层。为此，我们将 `client` 作为属性传递给提供者。现在，每个下层的
    React 组件都可以访问 Apollo Client。
- en: We should be now able to send GraphQL requests from our React app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够从我们的 React 应用程序发送 GraphQL 请求。
- en: Using Apollo Client in React
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 中使用 Apollo Client
- en: Apollo Client gives us everything that we need to send requests from our React
    components. We have already tested that the client works. Before moving on, we
    should clean up our file structure, to make it easier for us later in the development
    process. Our frontend is still displaying posts that come from static demo data.
    The first step is to move over to Apollo Client and fetch the data from our GraphQL
    API.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client 为我们从 React 组件发送请求提供了所有必要的东西。我们已经测试了客户端并确认它正常工作。在继续之前，我们应该清理我们的文件结构，以便在开发过程中更容易操作。我们的前端仍然显示来自静态演示数据的帖子。第一步是将
    Apollo Client 移动到我们的 GraphQL API 并获取数据。
- en: 'Follow these instructions to connect your first React component with Apollo
    Client:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明将您的第一个 React 组件与 Apollo Client 连接：
- en: Clone the `App.js` file to another file, called `Feed.js`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `App.js` 文件克隆到另一个名为 `Feed.js` 的文件中。
- en: Remove all parts where React `Helmet` is used, remove the `Feed` instead of
    `App`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有使用 React `Helmet` 的部分，移除 `Feed` 而不是 `App`。
- en: From the `App.js` file, remove all of the parts that we have left in the `Feed`
    component.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `App.js` 文件中，移除我们在 `Feed` 组件中留下的所有部分。
- en: 'Furthermore, we must render the `Feed` component inside of the `App` component.
    It should look like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们必须在 `App` 组件内部渲染 `Feed` 组件。它应该看起来像这样：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The corresponding `Feed` component should only include the parts where the news
    feed is rendered.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 `Feed` 组件应仅包含渲染新闻源的部分。
- en: We imported the `Feed` component and inserted it inside of the `return` statement
    of our `App` component so that it is rendered. The next chapter focuses on reusable
    React components and how to write well-structured React code. Now, let's take
    a look at why we split our `App` function into two separate files.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已导入 `Feed` 组件并将其插入到 `App` 组件的 `return` 语句中，以便进行渲染。下一章将重点介绍可重用 React 组件以及如何编写结构良好的
    React 代码。现在，让我们看看为什么我们将 `App` 函数拆分为两个单独的文件。
- en: Querying in React with Apollo Client
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apollo Client 在 React 中进行查询
- en: Apollo Client offers one primary way to request data from a GraphQL API. The
    `useQuery` function offered by the `@apollo/client` package provides the ability
    to request data via React Hooks within a functional React component. Beyond that,
    you can still rely on the plain `client.query` function for class-based components
    if required. There had been multiple ways to do this before, which were deprecated
    when the new version of Apollo Client was released. Before, you were able to use
    a `Query` component of Apollo, which is a special React component. Both approaches
    still exist but are deprecated, so it is not recommended to use them anymore.
    This is the reason why those approaches will not be explained in this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client 提供了一种主要方式来从 GraphQL API 请求数据。`@apollo/client` 包提供的 `useQuery`
    函数允许在功能 React 组件中使用 React Hooks 请求数据。除此之外，如果需要，你仍然可以依赖普通的 `client.query` 函数来处理基于类的组件。在
    Apollo Client 新版本发布之前，有多个这样做的方法，这些方法在新版本发布时已被弃用。以前，你可以使用 Apollo 的 `Query` 组件，这是一个特殊的
    React 组件。这两种方法仍然存在，但已被弃用，因此不建议再使用它们。这就是为什么这些方法将不会在本书中解释的原因。
- en: Apollo useQuery Hook
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apollo useQuery 钩子
- en: The newest version of Apollo Client comes with the `useQuery` Hook. You just
    need to pass the GraphQL query string to the `useQuery` Hook and it will return
    you an object that includes `data`, `error`, and `loading` properties that you
    can use to render your UI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client 的最新版本带有 `useQuery` 钩子。你只需要将 GraphQL 查询字符串传递给 `useQuery` 钩子，它将返回一个包含
    `data`、`error` 和 `loading` 属性的对象，你可以使用这些属性来渲染你的 UI。
- en: 'The actual way of implementing this `useQuery` Hook is very straightforward.
    Just follow these instructions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `useQuery` 钩子的实际方式非常简单。只需遵循以下说明：
- en: Remove the demo posts from the top of the `Feed.js` file.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Feed.js` 文件的顶部移除演示帖子。
- en: Remove the `useState(initialPosts)` line so that we can query the posts instead.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `useState(initialPosts)` 行，这样我们就可以查询帖子了。
- en: 'Import the `gql` function and the `useQuery` Hook from Apollo and parse the
    query, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Apollo 导入 `gql` 函数和 `useQuery` 钩子，并解析查询，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the `useQuery` Hook within the `Feed` function at the top, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的 `Feed` 函数中执行 `useQuery` 钩子，如下所示：
- en: '[PRE9]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before the actual `return` statement, add the following two statements, which
    will render loading and error messages if there have been any:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际的 `return` 语句之前，添加以下两个语句，如果有任何加载或错误信息，将会渲染：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Beneath these statements and before the last `return` statement, add this line
    of code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些语句和最后一个 `return` 语句之前，添加以下代码行：
- en: '[PRE11]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will make the `posts` property accessible from the data returned by the
    `useQuery` function if it is no longer loading and there is no error.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使 `posts` 属性在 `useQuery` 函数返回的数据中可用，前提是它不再加载且没有错误。
- en: Note that the function is now way cleaner because we only loop over the `posts`
    property and return the markup.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于我们只遍历 `posts` 属性并返回标记，所以函数现在要干净得多。
- en: In comparison with the older approaches, the `useQuery` Hook is easy to understand
    and also allows us to write readable and understandable code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与较旧的方法相比，`useQuery` 钩子易于理解，也允许我们编写可读和可理解的代码。
- en: The rendered output should look like that shown in [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*. The form to create a new post is not
    working at the moment because of our changes; let's fix this in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的输出应该看起来像在 [*第一章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017) 中所示，*准备你的开发环境*。由于我们的更改，创建新帖子的表单目前无法正常工作；让我们在下一节中修复这个问题。
- en: Mutating data with Apollo Client
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apollo Client 更改数据
- en: We have replaced the way we get data in our client. The next step is to switch
    the way in which we create new posts, too. Before Apollo Client, we had to add
    new fake posts to the array of demo posts manually, within the memory of the browser.
    Now, everything in our text area is sent with the `addPost` mutation to our GraphQL
    API, through Apollo Client.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改变了客户端获取数据的方式。下一步是切换我们创建新帖子的方式。在 Apollo Client 之前，我们必须手动将新的假帖子添加到演示帖子数组中，在浏览器的内存中。现在，我们文本区域中的所有内容都通过
    `addPost` 变更发送到我们的 GraphQL API，通过 Apollo Client。
- en: As with the GraphQL queries, there is a `useMutation` Hook that you can use
    to send a mutation against our GraphQL API. Before, there was also an HOC method
    and a separate `Mutation` component, which have been deprecated as well. They
    still exist for backward compatibility, but we will not cover them in this book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与GraphQL查询一样，有一个`useMutation`钩子，你可以用它向我们的GraphQL API发送突变。之前还有一个HOC方法和一个单独的`Mutation`组件，它们也已经弃用。它们仍然存在以保持向后兼容，但本书中不会涉及它们。
- en: Apollo useMutation Hook
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apollo useMutation钩子
- en: The newest version of Apollo Client comes with the `useMutation` Hook. The method
    works equally to the `useQuery` Hook—you just need to pass the parsed mutation
    string to it. In response to that, the `useMutation` Hook will return a function
    equally named to the mutation, which you can use to trigger those GraphQL requests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client的最新版本带来了`useMutation`钩子。这个方法与`useQuery`钩子的工作方式相同——你只需要传递解析后的突变字符串给它。作为回应，`useMutation`钩子将返回一个与突变同名的方法，你可以用它来触发那些GraphQL请求。
- en: 'Follow these instructions to implement the `useMutation` Hook and start using
    it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明实现`useMutation`钩子并开始使用它：
- en: 'Import the `useMutation` Hook from the `@apollo/client` package, like this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`@apollo/client`包中导入`useMutation`钩子，如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Parse the `addPost` mutation string below the `getPost` query with the `gql`
    function, like this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gql`函数将`addPost`突变字符串解析到`getPost`查询下方，如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the `Feed` component, add the following line of code to get the `addPost`
    function, which you can use in the `Feed` component wherever you want:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Feed`组件内部，添加以下代码行以获取`addPost`函数，你可以在`Feed`组件的任何地方使用它：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have got the `addPost` function, we can start making use of it.
    Just update the `handleSubmit` function, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了`addPost`函数，我们可以开始使用它了。只需更新`handleSubmit`函数，如下所示：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we completely got rid of the `newPost` object and just send
    the post's text. Our GraphQL API will create an **identifier** (**ID**) on insert
    to the database. As mentioned in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054),
    *Connecting to the Database*, we statically add the first user as the author of
    the post.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们完全去掉了`newPost`对象，只发送帖子的文本。我们的GraphQL API将在插入数据库时创建一个**标识符**（**ID**）。如[*第3章*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054)中所述，*连接到数据库*，我们静态地添加第一个用户作为帖子的作者。
- en: You can try to add a new post through the frontend but you won't be able to
    see it immediately. The form will be empty, but the new post will not be shown.
    This happens because the current state (or cache) of our component has not yet
    received the new post. The easiest way to test that everything has worked is to
    refresh the browser.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试通过前端添加一个新的帖子，但你不会立即看到它。表单将是空的，但新的帖子不会显示。这是因为我们组件的当前状态（或缓存）尚未收到新的帖子。测试一切是否正常工作的最简单方法是刷新浏览器。
- en: Of course, this is not the way that it should work. After the mutation has been
    sent, the new post should be directly visible in the feed. We will fix this now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是它应该工作的方式。在突变发送后，新的帖子应该直接在动态中可见。我们现在将修复这个问题。
- en: Updating the UI with Apollo Client
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apollo Client更新UI
- en: After running the `addPost` mutation, the request goes through to the server
    and saves the new post in our database without any problems. However, we still
    cannot see the changes take effect in the frontend immediately.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`addPost`突变后，请求通过服务器并成功保存了新的帖子到我们的数据库中，没有任何问题。然而，我们仍然不能立即在前端看到这些变化生效。
- en: 'There are two different ways to update the UI after a mutation, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在突变之后更新UI有两种不同的方式，如下所示：
- en: '**Refetching the dataset**: This is easy to implement but it refetches all
    of the data, which is inefficient.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新获取数据集**：这很容易实现，但它重新获取了所有数据，这是低效的。'
- en: '**Updating the cache according to the inserted data**: This is harder to understand
    and implement, but it attaches the new data to the cache of Apollo Client, so
    no refetching is needed.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根据插入的数据更新缓存**：这更难理解且实现起来更复杂，但它将新数据附加到Apollo Client的缓存中，因此不需要重新获取。'
- en: We use these solutions in different scenarios. Let's take a look at some examples.
    Refetching makes sense if further logic is implemented on the server that is hidden
    from the client when requesting a list of items and is not applied when inserting
    only one item. In these cases, the client cannot simulate the state of the typical
    response of a server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在不同的场景中使用这些解决方案。让我们看看一些例子。如果服务器上实现了对客户端隐藏的进一步逻辑，并且当请求项目列表时未应用，而插入单个项目时则应用，则重新获取是有意义的。在这些情况下，客户端无法模拟服务器典型响应的状态。
- en: Updating the cache, however, makes sense when adding or updating items in a
    list, such as our post feed. The client can insert the new post at the top of
    the feed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当在列表中添加或更新项目时，如我们的帖子源，更新缓存是有意义的。客户端可以将新帖子插入到源顶部。
- en: We will start by simply refetching requests, and then we'll go over the cache
    update implementation. The following sections (and chapters) will assume that
    you are not using the HOC method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简单地重新获取请求，然后我们将介绍缓存更新实现。以下部分（和章节）将假设您没有使用HOC方法。
- en: Refetching queries
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新获取查询
- en: 'As mentioned previously, this is the easiest method to update your UI. The
    only step is to set an array of queries to be refetched. The `useMutation` function
    should look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是更新UI的最简单方法。唯一的步骤是设置要重新获取查询的查询数组。`useMutation`函数应如下所示：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each object that you enter in the `refetchQueries` array needs a `query` property.
    Each component relying on one of those requests is rerendered when the response
    for its associated query arrives. It also includes components that are not inside
    of the `Feed` component. All components using the post's `GET_POSTS` query are
    rerendered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`refetchQueries`数组中输入的每个对象都需要一个`query`属性。当与这些请求相关联的响应到达时，依赖于这些请求的每个组件都会重新渲染。这还包括不在`Feed`组件内部的组件。所有使用帖子的`GET_POSTS`查询的组件都会重新渲染。
- en: You can also provide more fields to each query, such as variables to send parameters
    with the `refetch` request. Submitting the form resends the query, and you can
    see the new post directly in the feed. Refetching also reloads the posts that
    are already showing, which is unnecessary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为每个查询提供更多字段，例如发送参数的变量，与`refetch`请求一起发送。提交表单会重新发送查询，您可以直接在源中看到新帖子。重新获取还会重新加载已显示的帖子，这是不必要的。
- en: Now, let's take a look at how we can do this more efficiently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何能更有效地做到这一点。
- en: Updating the Apollo Client cache
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新Apollo Client缓存
- en: We want to explicitly add only the new post to the cache of Apollo Client. Using
    the cache helps us to save data by not refetching the complete feed or rerendering
    the complete list. To update the cache, you should remove the `refetchQueries`
    property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想明确地将新帖子添加到Apollo Client的缓存中。使用缓存可以帮助我们通过不重新获取整个源或重新渲染整个列表来保存数据。要更新缓存，您应该删除`refetchQueries`属性。
- en: 'There are technically at least two ways to update the cache on response of
    the mutation request. The first one is pretty straightforward and simple. You
    can then introduce a new property, called `update`, as shown in the following
    code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术上，至少有两种方式可以在突变请求的响应中更新缓存。第一种方法相当直接且简单。然后你可以引入一个新的属性，称为`update`，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new property runs when the GraphQL `addPost` mutation has finished. The
    first parameter that it receives is the `cache` parameter of Apollo Client, in
    which the whole cache is saved. The second parameter is the returned response
    of our GraphQL API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当GraphQL的`addPost`突变完成时，新属性会运行。它接收的第一个参数是Apollo Client的`cache`参数，其中保存了整个缓存。第二个参数是我们GraphQL
    API返回的响应。
- en: 'Updating the cache works like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更新缓存的方式如下：
- en: Use the `cache.readQuery` function by passing `query` as a parameter. It reads
    the data, which has been saved for this specific query inside of the cache. The
    `data` variable holds all of the posts that we have in our feed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cache.readQuery`函数，通过传递`query`作为参数。它读取缓存中为该特定查询保存的数据。`data`变量包含我们帖子源中的所有帖子。
- en: Now that we have all of the posts in an array, we can add the missing post.
    Make sure that you know whether you need to prepend or append an item. In our
    example, we create a `newData` object with a `posts` array inside it that consists
    of the newly added post at the top of our list and a destructured list of the
    old posts.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将所有帖子放入数组中，我们可以添加缺失的帖子。确保你知道是否需要将项目前置或后置。在我们的例子中，我们创建了一个`newData`对象，其中包含一个`posts`数组，该数组由顶部新添加的帖子和解构后的旧帖子列表组成。
- en: We need to save the changes back to the cache. The `cache.writeQuery` function
    accepts the `query` parameter that we used to send the request. This `query` parameter
    is used to update the saved data in our cache. The second parameter is the data
    that should be saved.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将更改保存回缓存。`cache.writeQuery`函数接受我们用来发送请求的`query`参数。这个`query`参数用于更新我们缓存中保存的数据。第二个参数是要保存的数据。
- en: When the cache has been updated, our UI reactively renders the changes.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当缓存已更新后，我们的UI会反应性地渲染更改。
- en: In reality, you can do whatever you want in the `update` function, but we only
    use it to update the Apollo Client store.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，你可以在`update`函数中做任何你想做的事情，但我们只使用它来更新Apollo客户端存储。
- en: The second way looks a bit more complicated but represents the way that is shown
    in the official documentation. The `update` function looks a bit more complex
    but comes with a small improvement of performance. It is your choice which one
    you like more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法看起来稍微复杂一些，但代表了官方文档中展示的方式。`update`函数看起来更复杂一些，但带来了一些性能上的小改进。你可以选择你更喜欢哪一个。
- en: 'Just replace the `update` function of the `useMutation` Hook, like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只需替换`useMutation`钩子的`update`函数，如下所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What the preceding code does is use the `cache.modify` function, which allows
    a more precise update than the one we did before. Instead of updating the whole
    `GET_POSTS` query within the Apollo Client, we are using the `cache.writeFragment`
    method of the `cache` object to update the cache and the UI only with the new
    post. This will improve the performance of our components, especially as the component
    logic grows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码所做的就是使用`cache.modify`函数，它允许比我们之前所做的更精确的更新。我们不是在Apollo客户端中更新整个`GET_POSTS`查询，而是使用`cache`对象的`cache.writeFragment`方法来更新缓存和UI，只更新新的帖子。这将提高我们组件的性能，尤其是在组件逻辑增长时。
- en: In the next section, we will be a bit more optimistic about the response of
    our server and will add the item before the request's response successfully arrives.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对我们的服务器响应更加乐观，并在请求的响应成功到达之前添加项目。
- en: Optimistic UI
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乐观式UI
- en: Apollo provides a great feature of being able to update the UI in an optimistic
    manner. An optimistic manner means that Apollo adds the new data or post to the
    storage before the request has finished. The advantage is that the user can see
    the new result, instead of waiting for the response of the server. This solution
    makes the application feel faster and more responsive.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo提供了一种能够以乐观方式更新UI的出色功能。乐观方式意味着在请求完成之前，Apollo会将新数据或帖子添加到存储中。这种解决方案的优点是用户可以看到新的结果，而不是等待服务器的响应。这种解决方案使得应用程序感觉更快、更响应。
- en: 'This section expects the `update` function of the `Mutation` component to already
    be implemented. Otherwise, this UI feature will not work. We need to add the `optimisticResponse`
    property to our mutation next to the `update` property of the `useMutation` configuration,
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节期望`Mutation`组件的`update`函数已经实现。否则，这个UI功能将不会工作。我们需要在`useMutation`配置的`update`属性旁边添加`optimisticResponse`属性，如下所示：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `optimisticResponse` property can be anything from a function to a simple
    object. The return value, however, needs to be a GraphQL `response` object. What
    you see here is an `addPost` object that looks as though our GraphQL API could
    return it, if our request is successful. You need to fill in the `__typename`
    fields, according to the GraphQL schema that you are using. That is why the `Post`
    and `User` type names are inside of this fake object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimisticResponse`属性可以是任何从函数到简单对象的东西。然而，返回值需要是一个GraphQL `response`对象。你在这里看到的是一个`addPost`对象，看起来就像我们的GraphQL
    API可以返回它，如果我们的请求成功的话。你需要根据你使用的GraphQL模式填写`__typename`字段。这就是为什么`Post`和`User`类型名称在这个假对象内部。'
- en: Technically, you can also add the `optimisticResponse` property on the actual
    call to `addPost` next to the `variables` property, but I think this is nothing
    that we need to pass with every call to this function but that actually should
    be set globally to the `useMutation` Hook.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你也可以在`addPost`的实际调用旁边添加`optimisticResponse`属性，在`variables`属性旁边，但我认为这不是我们需要在每次调用此函数时传递的东西，而实际上应该全局设置到`useMutation`钩子中。
- en: The `id` property of the optimistic response is set to `-1`. React expects that
    every component in a loop gets a unique `key` property. We usually use the `id`
    property of a post as the `key` value. -1 is never used by any other post because
    MySQL starts counting at 1\. Another advantage is that we can use this `id` property
    to set a special class to the post item in our list.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 乐观响应的`id`属性被设置为`-1`。React 预期循环中的每个组件都有一个唯一的`key`属性。我们通常使用帖子的`id`属性作为`key`值。由于
    MySQL 从 1 开始计数，因此`-1`永远不会被任何其他帖子使用。另一个优点是，我们可以使用这个`id`属性来设置列表中帖子项的特殊类。
- en: Furthermore, the username and the user's avatar are set to `loading`. That is
    because we don't have built-in authentication. React and Apollo do not have a
    user associated with the current session, so we cannot enter the user's data into
    the `optimisticResponse` property. We fix this once the authentication is ready.
    This is an excellent example of how to handle a situation in which you do not
    have all of the data until you receive a response from the server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户名和用户头像被设置为`loading`。这是因为我们没有内置的身份验证。React 和 Apollo 没有与当前会话关联的用户，所以我们不能将用户数据输入到`optimisticResponse`属性中。一旦身份验证就绪，我们就解决这个问题。这是一个处理在收到服务器响应之前没有所有数据的情景的绝佳例子。
- en: 'To set a particular class on the list item, we conditionally set the correct
    `className` property in our `map` loop. Insert the following code into the `return`
    statement:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要在列表项上设置特定的类，我们在`map`循环中条件性地设置正确的`className`属性。将以下代码插入到`return`语句中：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An example CSS style for this might look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，CSS 样式可能看起来像这样：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: CSS animations make your applications more modern and flexible. If you experience
    issues when viewing these in your browser, you may need to check whether your
    browser supports them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 动画使您的应用程序更加现代和灵活。如果您在浏览器中查看时遇到问题，您可能需要检查您的浏览器是否支持它们。
- en: 'You can see the result in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到结果：
- en: '![Figure 4.2 – Loading optimistic response'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 加载乐观响应'
- en: '](img/Figure_4.02_B17337.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B17337.jpg)'
- en: Figure 4.2 – Loading optimistic response
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 加载乐观响应
- en: The loading spinner and the username are removed once the response arrives from
    our API, and the `update` function is executed again with the real data. You do
    not need to take care of removing the loading post yourself as this is done by
    Apollo automatically. Any spinner component from an `npm` package or GIF file
    can be used where I have inserted the loading animation. The file that I am using
    needs to be saved under the `public` folder, with the name `loading.gif`, so that
    it can be used through the CSS we added in the preceding code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从我们的 API 收到响应，加载指示器和用户名就会被移除，然后再次执行带有真实数据的`update`函数。您无需自己处理移除加载帖子，因为这是由 Apollo
    自动完成的。任何来自`npm`包或 GIF 文件的旋转器组件都可以用于我插入加载动画的位置。我使用的文件需要保存在`public`文件夹下，文件名为`loading.gif`，这样就可以通过我们在前面代码中添加的
    CSS 使用它。
- en: Everything is now set up for sending new posts. The UI responds immediately
    and shows you the new post.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，用于发送新帖子。UI 会立即响应并显示新帖子。
- en: However, what about new posts from your friends and colleagues? Currently, you
    need to reload the page to see them, which is not very intuitive. At the moment,
    we only add the posts that we send on our own but do not receive any information
    about new posts from other people. I will show you the quickest way to handle
    this in the following section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于您朋友和同事的新帖子怎么办？目前，您需要重新加载页面才能看到它们，这并不直观。目前，我们只添加我们自己发送的帖子，但不会收到其他人新帖子的任何信息。我将在下一节中向您展示处理此问题的最快方法。
- en: Polling with Apollo Client
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Apollo 客户端进行轮询
- en: '**Polling** is nothing more than rerunning a request after a specified interval.
    This procedure is the simplest way to implement updates for our news feed. However,
    multiple issues are associated with polling, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮询**不过是每隔一段时间重新运行一次请求。这是实现我们新闻源更新的最简单方法。然而，轮询与多个问题相关，如下所述：'
- en: It is inefficient to send requests without knowing whether there is any new
    data. The browser might send dozens of requests without ever receiving a new post.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不知道是否有新数据的情况下发送请求是不高效的。浏览器可能会发送数十个请求，却从未收到任何新帖子。
- en: If we directly send the initial request again, we will get all of the posts,
    including those that we are already showing to the user.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们直接再次发送初始请求，我们将获得所有帖子，包括那些我们已经向用户展示的。
- en: When sending requests, the server needs to query the database and calculate
    everything. Unnecessary requests cost money and time.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送请求时，服务器需要查询数据库并计算一切。不必要的请求会耗费金钱和时间。
- en: 'There are some use cases in which polling makes sense. One example is a real-time
    graph, in which every axis tick is displayed to the user, whether there is data
    or not. You do not need to use an interrupt-based solution, since you want to
    show everything. Despite the issues that come with polling, let''s quickly run
    through how it works. All you need to do is fill in the `pollInterval` property
    in the configuration for the `useQuery` Hook, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用例中轮询是有意义的。一个例子是实时图表，其中无论是否有数据，每个轴刻度都会显示给用户。由于你想要显示所有内容，因此不需要使用基于中断的解决方案。尽管轮询会带来一些问题，但让我们快速了解一下它是如何工作的。你所需要做的就是填写`useQuery`
    Hook配置中的`pollInterval`属性，如下所示：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The request is resent every 5 seconds (5,000 **milliseconds**, or **ms**).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请求每5秒重发一次（5,000 **毫秒**，或**ms**）。
- en: As you might expect, there are other ways to implement real-time updates to
    your UI. One approach is to use **server-sent events**. A server-sent event is,
    as the name suggests, an event that is sent by the server to the client. The client
    needs to establish a connection to the server, but then the server can send messages
    to the client, in one direction. Another method is to use **WebSockets**, which
    allow for bidirectional communication between the server and the client. The most
    common method in relation to GraphQL, however, is to use **Apollo Subscriptions**.
    They are based on WebSockets and work perfectly with GraphQL. I will show you
    how Apollo Subscriptions work in [*Chapter 10*](B17337_10_Final_ASB_ePub.xhtml#_idTextAnchor183),
    *Real-Time Subscriptions*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，还有其他方法可以实现UI的实时更新。一种方法是用**服务器发送事件**。正如其名所示，服务器发送事件是由服务器发送到客户端的事件。客户端需要与服务器建立连接，然后服务器就可以向客户端发送消息，单向通信。另一种方法是使用**WebSockets**，它允许服务器和客户端之间进行双向通信。然而，与GraphQL相关最常见的方法是使用**Apollo
    Subscriptions**。它们基于WebSockets，并且与GraphQL配合得非常好。我将在[*第10章*](B17337_10_Final_ASB_ePub.xhtml#_idTextAnchor183)“实时订阅”中向你展示Apollo
    Subscriptions是如何工作的。
- en: Let's continue and integrate the rest of our GraphQL API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续并集成我们剩余的GraphQL API。
- en: Implementing chats and messages
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现聊天和消息
- en: In the previous chapter, we programmed a pretty dynamic way of creating chats
    and messages with your friends and colleagues, either one-on-one or in a group.
    There are some things that we have not discussed yet, such as authentication,
    real-time subscriptions, and friend relationships. First, however, we are going
    to work on our new skills, using React with Apollo Client to send GraphQL requests.
    It is a complicated task, so let's get started.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了一种相当动态的方式来创建与你的朋友和同事的聊天和消息，无论是单独还是分组。还有一些我们没有讨论的事情，比如身份验证、实时订阅和好友关系。然而，首先，我们将利用React和Apollo
    Client来发送GraphQL请求来锻炼我们的新技能。这是一个复杂的工作，所以让我们开始吧。
- en: Fetching and displaying chats
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取并显示聊天
- en: Our news feed is working as we expected. Now, we also want to cover chats. As
    with our feed, we need to query for every chat that the current user (or, in our
    case, the first user) is associated with.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新闻推送正如预期那样工作。现在，我们还想涵盖聊天。正如我们的推送一样，我们需要查询当前用户（或者在我们的情况下，是第一个用户）关联的每个聊天。
- en: The initial step is to get the rendering working with some demo chats. Instead
    of writing the data on our own, as we did in the first chapter, we can now execute
    the `chats` query. Then, we can copy the result into the new file as static demo
    data, before executing the actual `useQuery` Hook.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用一些示例聊天来使渲染工作。与我们在第一章中自己写入数据不同，我们现在可以执行`chats`查询。然后，我们可以将结果复制到新文件中作为静态示例数据，然后再执行实际的`useQuery`
    Hook。
- en: 'Let''s get started, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，如下所示：
- en: 'Send the GraphQL query. The best options involve the Apollo Client Devtools
    if you already know how they work. Otherwise, you can rely on Postman, as you
    did previously. The code is illustrated in the following snippet:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送GraphQL查询。如果你已经知道如何使用Apollo Client Devtools，那么最佳选项就是使用它们。否则，你可以像之前一样依赖Postman。代码在下面的代码片段中展示：
- en: '[PRE23]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The request looks a bit different from the one we tested with Postman. The chat
    panel that we are going to build only needs specific data. We do not need to render
    any messages inside of this panel, so we don't need to request them. A complete
    chat panel only requires the chat itself, the ID, the usernames, and the avatars.
    Later, we will retrieve all of the messages, too, when viewing a single chat.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请求看起来与我们在Postman中测试的请求略有不同。我们将要构建的聊天面板只需要特定的数据。我们不需要在这个面板内渲染任何消息，因此我们不需要请求它们。一个完整的聊天面板只需要聊天本身、ID、用户名和头像。稍后，当查看单个聊天时，我们还将检索所有消息。
- en: Next, create a new file called `Chats.js`, next to the `Feed.js` file.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`Chats.js`的新文件，位于`Feed.js`文件旁边。
- en: 'Copy the complete `chats` array from the response over to an array inside of
    the `Chats.js` file, as follows. Add it to the top of the file:'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将响应中的完整`chats`数组复制到`Chats.js`文件中的数组中，如下所示。将其添加到文件顶部：
- en: '[PRE24]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Import React ahead of the `chats` variable. Otherwise, we will not be able
    to render any React components. Here''s the code you''ll need to do this:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chats`变量之前导入React。否则，我们将无法渲染任何React组件。以下是您需要执行的代码：
- en: '[PRE25]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set up the functional React component. I have provided the basic markup here.
    Just copy it beneath the `chats` variable. I am going to explain the logic of
    the new component shortly:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置功能React组件。我在这里提供了基本的标记。只需将其复制到`chats`变量下面。我很快就会解释新组件的逻辑：
- en: '[PRE26]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The component is pretty basic, at the moment. The component maps over all of
    the chats and returns a new list item for each chat. Each list item has an image
    that is taken from the second user of the array, since we defined that the first
    user in the list is the current user, as long as we have not implemented authentication.
    We use a group icon if there are more than two users. When we have implemented
    authentication and we know the logged-in user, we can take the specific avatar
    of the user that we are chatting with.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，该组件相当基础。组件遍历所有聊天，并为每个聊天返回一个新的列表项。每个列表项都有一个图像，该图像来自数组的第二个用户，因为我们定义列表中的第一个用户是当前用户，只要我们没有实现身份验证。如果有超过两个用户，我们使用群组图标。当我们实现了身份验证并且我们知道已登录的用户时，我们可以获取我们正在与之聊天的特定用户头像。
- en: The title displayed inside of the `h2` tag at the top of the chat is the name
    of the user. For this, I have implemented the `usernamesToString` method, which
    loops over all of the usernames and concatenates them into a long string. The
    result is passed into the `shorten` function, which removes all of the characters
    of the string that exceed the size of the maximum-12 characters.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 聊天顶部`h2`标签内显示的标题是用户的名称。为此，我实现了`usernamesToString`方法，该方法遍历所有用户名并将它们连接成一个长字符串。结果传递给`shorten`函数，该函数移除超过最大12个字符的所有字符串字符。
- en: One thing you may notice is that these helper functions are not within the actual
    component. I personally recommend having helper functions outside of the component
    as they will be recreated on every render of the component. If the helper function
    needs the scope of the component, keep it inside, but if they are pure functions
    just doing transformations here, keep them outside.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能会注意到，这些辅助函数不在实际组件内部。我个人建议将辅助函数放在组件外部，因为它们将在组件每次渲染时被重新创建。如果辅助函数需要组件的作用域，请将其保留在内部，但如果它们只是在这里进行转换的纯函数，请将其放在外部。
- en: Our new component needs some styling. Copy the new CSS to our `style.css` file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新组件需要一些样式。将新的CSS复制到我们的`style.css`文件中。
- en: 'To save the file size in our CSS file, replace the two `.post .header` styles
    to also cover the style of the chats, as follows:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在我们的CSS文件中节省文件大小，将两个`.post .header`样式替换为也覆盖聊天的样式，如下所示：
- en: '[PRE27]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We must append the following CSS to the bottom of the `style.css` file:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须在`style.css`文件的底部追加以下CSS：
- en: '[PRE28]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To get the code working, we must also import the `Chats` component into our
    `App.js` file, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使代码正常工作，我们还必须在`App.js`文件中导入`Chats`组件，如下所示：
- en: '[PRE29]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Render the `Chats` component inside the return statement beneath the `Feed`
    component inside of the `App.js` file.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`文件中`Feed`组件下面的返回语句内渲染`Chats`组件。
- en: 'The current code generates the following screenshot:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前代码生成以下截图：
- en: '![Figure 4.3 – Chats panel'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 聊天面板]'
- en: '](img/Figure_4.03_B17337.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.3 – Chats panel](img/Figure_4.03_B17337.jpg)'
- en: Figure 4.3 – Chats panel
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 聊天面板
- en: On the right-hand side, you can see the chats panel that we have just implemented.
    Every chat is listed there as a separate row.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，您可以看到我们刚刚实现的聊天面板。每个聊天都作为单独的行列在那里。
- en: The result isn't bad, but it would be much more helpful to at least have the
    last message of every chat beneath the username so that you could directly see
    the last content of your conversations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 结果还不错，但至少在用户名下方显示每条聊天的最后一条消息会更有帮助，这样你就可以直接看到对话的最后内容。
- en: 'Just follow these instructions to get the last message into the chats panel:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明将最后一条消息添加到聊天面板中：
- en: 'The easiest way to do this would be to add the messages to our query again,
    but querying all of the messages for every chat that we want to display in the
    panel would not make much sense. Instead, we will add a new property to the chat
    entity, called `lastMessage`. That way, we will only get the newest message. We
    will add the new field to the GraphQL schema of our chat type, in the backend
    code, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是在查询中再次添加消息，但查询我们想在面板中显示的每个聊天的所有消息并没有太多意义。相反，我们将在聊天实体中添加一个新属性，称为`lastMessage`。这样，我们只会得到最新消息。我们将在后端代码中添加新字段到我们聊天类型的GraphQL模式中，如下所示：
- en: '[PRE30]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Of course, we must also implement a function that retrieves the `lastMessage`
    field.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们还需要实现一个函数来检索`lastMessage`字段。
- en: 'Adding our new `resolvers.js` function inside the `Chats` property of the `resolvers`
    object orders all of the chat messages by ID and takes the first one. By definition,
    this should be the latest message in our chat. We need to resolve the promise
    on our own and return the first element of the array since we expect to return
    only one `message` object. If you return the promise directly, you will receive
    `null` in the response from the server because an array is not a valid response
    for a single message entity. The code is illustrated in the following snippet:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resolvers`对象的`Chats`属性中添加我们的新`resolvers.js`函数将按ID对所有聊天消息进行排序并取第一个。根据定义，这应该是我们聊天中的最新消息。我们需要自己解析这个承诺并返回数组的第一个元素，因为我们期望只返回一个`message`对象。如果你直接返回承诺，你将收到来自服务器的`null`响应，因为数组不是一个有效的单个消息实体的响应。以下代码片段展示了代码：
- en: '[PRE31]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can add the new property to our static demo data inside `Chats.js`. for
    every array item or rerun the GraphQL query and copy the response again. The code
    is illustrated here:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`Chats.js`中的静态演示数据内部添加新的属性，对于每个数组项或重新运行GraphQL查询并再次复制响应。代码如下所示：
- en: '[PRE32]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can render the new message with a simple `span` tag beneath the `h2` header
    of the username. Copy it directly into the `return` statement, inside of our `Chats`
    component, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用一个简单的`span`标签在用户名的`h2`标题下方渲染新消息。直接将其复制到我们的`Chats`组件中的`return`语句中，如下所示：
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result of the preceding changes renders every chat row with the last message
    inside of the chat. It should now look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面更改的结果是渲染每行聊天中的最后一条消息。现在它应该看起来像这样：
- en: '![Figure 4.4 – Last message'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – 最后一条消息'
- en: '](img/Figure_4.04_B17337.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.04_B17337.jpg)'
- en: Figure 4.4 – Last message
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 最后一条消息
- en: 'Since everything is displayed correctly from our test data, we can introduce
    the `useQuery` Hook in order to fetch all of the data from our GraphQL API. We
    can remove the `chats` array. Then, we will import all of the dependencies and
    parse the GraphQL query, as in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试数据中的所有内容都显示正确，我们可以引入`useQuery`钩子来从我们的GraphQL API获取所有数据。我们可以删除`chats`数组。然后，我们将导入所有依赖项并解析GraphQL查询，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To make use of the preceding parsed GraphQL query we will execute the `useQuery`
    Hook in our functional component, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用前面解析的GraphQL查询，我们将在我们的功能组件中执行`useQuery`钩子，如下所示：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you have added the preceding lines of code to the beginning of the `Chats`
    function, it will then make use of the `chats` array returned within the GraphQL
    response. Before doing so it will, of course, check if the request is still loading
    or if there has been an error.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将前面的代码行添加到`Chats`函数的开始处时，它将使用GraphQL响应中返回的`chats`数组。在这样做之前，它当然会检查请求是否仍在加载或是否发生了错误。
- en: We render the loading and error state within the `div` tag with the `chats`
    class so that the messages are wrapped within the gray panel.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在具有`chats`类的`div`标签内渲染加载和错误状态，这样消息就会被包裹在灰色面板中。
- en: You should have run the `addChat` mutation from the previous chapter through
    Postman. Otherwise, there will be no chats to query for, and the panel will be
    empty. You have to also execute this mutation for any following chapter because
    we are not going to implement a special button for this functionality. The reason
    is that the logic behind it does not provide further knowledge about React or
    Apollo as it is just done by executing the `addChat` mutation at the correct location
    within Graphbook.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经通过Postman运行了上一章的`addChat`突变。否则，将没有可查询的聊天，面板将是空的。你还需要为任何后续章节执行此突变，因为我们不会为这个功能实现一个特殊的按钮。原因是它背后的逻辑并没有提供关于React或Apollo的更多知识，因为它只是在Graphbook的正确位置执行`addChat`突变。
- en: Next, we want to display chat messages after opening a specific chat.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望在打开特定聊天后显示聊天消息。
- en: Fetching and displaying messages
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和显示消息
- en: 'First, we have to store the chats that were opened by a click from the user.
    Every chat is displayed in a separate, small chat window, like on Facebook. Add
    a new state variable to save the IDs of all of the opened chats to the `Chats`
    component, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须存储用户通过点击打开的聊天。每个聊天都在一个单独的小聊天窗口中显示，就像在Facebook上一样。向`Chats`组件添加一个新的状态变量来保存所有打开的聊天ID，如下所示：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To let our component insert or remove something from the array of open chats,
    we will add the new `openChat` and `closeChat` functions, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的组件能够向打开的聊天数组中插入或删除内容，我们将添加新的`openChat`和`closeChat`函数，如下所示：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When a chat is clicked on, we will first check that it is not already open,
    by searching the ID using the `indexOf` function inside of the `openChats` array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击聊天时，我们将首先检查它是否尚未打开，通过在`openChats`数组中使用`indexOf`函数搜索ID。
- en: Every time a new chat is opened, we will check whether there are three or more
    chats. If that is the case, we will remove the first opened chat from the array
    and exchange it with the new one by appending it to the array with the `push`
    function. We will only save the chat IDs, not the whole **JavaScript Object Notation**
    (**JSON**) object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每次打开一个新的聊天时，我们将检查是否有三个或更多的聊天。如果是这样，我们将从数组中删除第一个打开的聊天，并通过使用`push`函数将其附加到数组中来交换它。我们只保存聊天ID，而不是整个**JavaScript对象表示法**（**JSON**）对象。
- en: For the `closeChat` function, we just revert this by removing the ID from the
    `openChats` array.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`closeChat`函数，我们只需通过从`openChats`数组中删除ID来撤销这个操作。
- en: 'The last step is to bind the `onClick` event to our component. In the `map`
    function, we can replace the wrapping `div` tag with the following line of code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将`onClick`事件绑定到我们的组件上。在`map`函数中，我们可以用以下代码行替换包装`div`标签：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we use `onClick` to call the `openChat` function, with the chat ID as
    the only parameter. At this point, the new function is already working but the
    updated state isn''t used. Let''s take care of that, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`onClick`来调用`openChat`函数，将聊天ID作为唯一参数。此时，新函数已经工作，但更新的状态没有被使用。让我们处理这个问题，如下所示：
- en: 'Add a surrounding wrapper `div` tag to the `div` tag with the `chats` class,
    as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个周围的包装`div`标签添加到具有`chats`类的`div`标签中，如下所示：
- en: '[PRE39]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In order to not mess up, the complete code we have written will introduce our
    first child component. To do so, create a file called `Chat.js` next to the `Chats.js`
    file.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了不搞乱，我们编写的完整代码将引入我们的第一个子组件。为此，在`Chats.js`文件旁边创建一个名为`Chat.js`的文件。
- en: 'In this new file, import React and Apollo and parse the GraphQL query to get
    all the chat messages that were just opened, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件中，导入React和Apollo，并解析GraphQL查询以获取刚刚打开的所有聊天消息，如下所示：
- en: '[PRE40]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see in the preceding code snippet, we are passing the chat ID as
    a parameter to the GraphQL query.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们将聊天ID作为参数传递给GraphQL查询。
- en: 'The actual component will then make use of the parsed query to get all the
    messages and render them inside a small container. The component should be added,
    as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际组件将利用解析的查询获取所有消息并在一个小容器中渲染它们。应该按照以下方式添加组件：
- en: '[PRE41]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We execute the `useQuery` Hook to send the GraphQL request. We pass the `chatId`
    property from the `props` property so that the chat ID must be passed to this
    child component from the parent component. We also extract the `closeChat` function
    to call it from the child component, as the actual close button is within the
    chat container and not within the parent component.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们执行 `useQuery` 钩子来发送 GraphQL 请求。我们传递 `props` 中的 `chatId` 属性，以便聊天 ID 必须从父组件传递到子组件。我们还提取了
    `closeChat` 函数，以便从子组件中调用它，因为实际的关闭按钮位于聊天容器中，而不是父组件中。
- en: Once the request arrives, we check again if the request is loading or has an
    error before actually rendering the complete chat. Then, we render a `div` tag
    with the `chatWindow` class name, in which all messages are displayed. Again,
    we are using the user ID to fake the class name of the messages. We will replace
    it when we get authentication running.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦请求到达，我们在实际渲染完整的聊天之前再次检查请求是否正在加载或是否有错误。然后，我们渲染一个带有 `chatWindow` 类名的 `div` 标签，其中显示所有消息。同样，我们再次使用用户
    ID 来伪造消息的类名。当我们开始运行身份验证时，我们将替换它。
- en: 'As we have prepared the child component, we only need to add one line to the
    `Chats.js` file to import it, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经准备好了子组件，我们只需要在 `Chats.js` 文件中添加一行来导入它，如下所示：
- en: '[PRE42]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, to make use of our new `Chat` component, just add these three lines of
    code inside the `div` tag with the `wrapper` class:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了使用我们新的 `Chat` 组件，只需在带有 `wrapper` 类的 `div` 标签内添加这三行代码：
- en: '[PRE43]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For each item in the `openChats` array, we will render the `Chat` component,
    which will then pass the `chatId` property and the `closeChat` function. The child
    component will then fetch the chat data on its own by the passed `chatId` property.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `openChats` 数组中的每个项目，我们将渲染 `Chat` 组件，然后传递 `chatId` 属性和 `closeChat` 函数。子组件将根据传递的
    `chatId` 属性自行获取聊天数据。
- en: 'The last thing missing is some styling. The CSS file is pretty big. Every message
    from the other users should be displayed on the left and our own messages on the
    right, to differentiate them. Insert the CSS code directly from the GitHub repository
    to save some time: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css).'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后缺少的是一些样式。CSS 文件相当大。其他用户的每条消息都应该显示在左侧，而我们的消息显示在右侧，以便区分它们。直接从 GitHub 仓库插入 CSS
    代码以节省时间：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-2nd-Edition/blob/main/Chapter04/assets/css/style.css)。
- en: 'Take a look at the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下截图：
- en: '![Figure 4.5 – Chat window'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 聊天窗口'
- en: '](img/Figure_4.05_B17337.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B17337.jpg)'
- en: Figure 4.5 – Chat window
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 聊天窗口
- en: We have forgotten something important. We can see all of the messages from our
    chat, but we are not able to add new messages, which is essential. Let's take
    a look at how to implement a chat message form in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记了一些重要的事情。我们可以看到聊天中的所有消息，但我们无法添加新的消息，这是至关重要的。让我们在下一节中看看如何实现聊天消息表单。
- en: Sending messages through mutations
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过突变发送消息
- en: 'The `addMessage` mutation already exists in our backend, so we can add it to
    our `Chat` component. To implement this feature completely, follow these instructions:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`addMessage` 突变已经存在于我们的后端，因此我们可以将其添加到我们的 `Chat` 组件中。要完全实现此功能，请按照以下说明操作：'
- en: 'Before adding it straightaway to the frontend too, we need to change the `import`
    statements so that we also have the `useMutation` and `useState` functions, as
    follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在直接将其添加到前端之前，我们需要更改 `import` 语句，以便我们也有 `useMutation` 和 `useState` 函数，如下所示：
- en: '[PRE44]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, parse the mutation at the top, next to the other requests, like this:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，像对待其他请求一样，在顶部解析突变，如下所示：
- en: '[PRE45]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For now, we will keep it simple and just add the text input to the `Chat` component
    directly, but we will take a look at a better way to do this in [*Chapter 5*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Reusable React Components and React Hooks*.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将保持简单，并直接将文本输入添加到 `Chat` 组件中，但我们将查看在 [*第 5 章*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123)，*可重用
    React 组件和 React 钩子*中更好的方法。
- en: 'Now, we need to create a state variable where we save the current value of
    our new text input that we still need to create. We need to execute the `useMutation`
    Hook to send the GraphQL request to create a new chat message. Just add the following
    code for that:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个状态变量来保存我们新创建的文本输入的当前值。我们需要执行`useMutation`钩子来发送GraphQL请求创建新的聊天消息。为此，只需添加以下代码：
- en: '[PRE46]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The state variable and mutation function look familiar, as you already know
    them. One special thing we do for the `useMutation` Hook is to again provide an
    `update` function to efficiently update the Apollo Client cache with the newest
    data. To do so, we must provide an `id` property to the `cache.modify` function.
    The reason we need to do that is that we want to update the `messages` array of
    one specific chat, but there could be multiple within our cache. To update the
    correct chat in the message, we use the `cache.identify` function and provide
    the current `chat` object, and it will automatically detect which chat to update.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 状态变量和突变函数看起来很熟悉，因为你已经知道了它们。我们为`useMutation`钩子做的特别之处是再次提供一个`update`函数，以有效地更新Apollo客户端缓存中的最新数据。为此，我们必须向`cache.modify`函数提供一个`id`属性。我们需要这样做的原因是我们想更新特定聊天的`messages`数组，但我们的缓存中可能有多个。为了更新消息中的正确聊天，我们使用`cache.identify`函数并提供当前的`chat`对象，它将自动检测要更新的聊天。
- en: The `handleKeyPress` function will handle the submission of the text input to
    trigger a mutation request.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`handleKeyPress`函数将处理文本输入的提交以触发突变请求。'
- en: 'We must insert the markup needed to render a fully functional input. Put the
    input below the messages list, inside of the chat window. The `onChange` property
    executes while typing and will update the state of the component with the value
    of the input. Insert the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须插入渲染一个完全功能性的输入所需的标记。将输入放在消息列表下方，在聊天窗口内。`onChange`属性在输入时执行，并将组件的状态更新为输入的值。插入以下代码：
- en: '[PRE47]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We use the `onKeyPress` event to handle *Enter* key hits so that we can send
    the chat message.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`onKeyPress`事件来处理*Enter*键的点击，以便我们可以发送聊天消息。
- en: 'Let''s quickly add some CSS to our `style.css` file to make the input field
    look good, as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速向`style.css`文件添加一些CSS，使输入字段看起来更好，如下所示：
- en: '[PRE48]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following screenshot shows the chat window, with a new message inserted
    through the chat window input:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了聊天窗口，其中通过聊天窗口输入插入了一条新消息：
- en: '![Figure 4.6 – Messaging in the chat window'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 聊天窗口中的消息'
- en: '](img/Figure_4.06_B17337.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.06_B17337.jpg)'
- en: Figure 4.6 – Messaging in the chat window
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 聊天窗口中的消息
- en: There are many features that we have not implemented and that we won't cover
    in this book—for example, it would make sense to have the username next to the
    chat message if it is a group chat, to show the avatar next to the message, and
    to update the `lastMessage` field in the chats panel once a new message is sent.
    The workload required to achieve a fully-fledged social network, such as Facebook,
    is impossible to cover in this book, but you are going to learn all of the required
    techniques, tools, and tactics so that you can approach this on your own. The
    next important feature that we are going to cover is pagination.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有实现并且不会在本书中涵盖的许多功能——例如，如果是一个群聊，在聊天消息旁边显示用户名，在消息旁边显示头像，以及在新消息发送后更新聊天面板中的`lastMessage`字段，这都有意义。要实现一个像Facebook这样的完整社交网络所需的工作量是无法在本书中涵盖的，但你将学习所有必需的技术、工具和策略，以便你可以自己着手进行。我们将要涵盖的下一个重要功能是分页。
- en: Pagination in React and GraphQL
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React和GraphQL中的分页
- en: By **pagination**, most of the time, we mean the batch querying of data. Currently,
    we query for all posts, chats, and messages in our database. If you think about
    how much data Facebook stores inside one chat with your friends, you will realize
    that it is unrealistic to fetch all of the messages and data ever shared at once.
    A better solution is to use pagination. With pagination, we always have a page
    size, or a limit, of how many items we want to fetch per request. We also have
    a page or offset number, from which we can start to select data rows.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说到**分页**时，大多数情况下，我们指的是数据的批量查询。目前，我们在数据库中查询所有帖子、聊天和消息。如果你想想Facebook中与朋友的一次聊天存储了多少数据，你就会意识到一次性获取所有消息和数据是不现实的。一个更好的解决方案是使用分页。使用分页，我们每次请求都有一个页面大小或限制，即我们想要获取多少项。我们还有一个页面或偏移量，从那里我们可以开始选择数据行。
- en: In this section, we're going to look at how to use pagination with the posts
    feed, as it is the most straightforward example. In [*Chapter 5*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Reusable React Components and React Hooks*, we will focus on writing efficient
    and reusable React code. Sequelize offers the pagination feature by default. We
    can first insert some more demo posts so that we can paginate in batches of 10.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用帖子源进行分页，因为这是最直接的例子。在 [*第 5 章*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123)，*可重用
    React 组件和 React 钩子* 中，我们将专注于编写高效且可重用的 React 代码。Sequelize 默认提供分页功能。我们首先插入一些更多的演示帖子，以便我们可以以每批
    10 个帖子进行分页。
- en: 'We need to adjust the backend a bit before implementing it on our frontend,
    as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现前端之前，我们需要对后端进行一些调整，如下所示：
- en: 'Add a new `RootQuery` to our GraphQL schema, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 GraphQL 模式中添加一个新的 `RootQuery`，如下所示：
- en: '[PRE49]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `PostFeed` type only holds the `posts` field. Later on, in the development
    of the application, you can return more information, such as the overall count
    of items, the page count, and so on. The code is illustrated in the following
    snippet:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PostFeed` 类型仅包含 `posts` 字段。在应用程序的开发过程中，您可以返回更多信息，例如项目总数、页面数等。以下代码片段展示了如何实现：'
- en: '[PRE50]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we must implement the `PostFeed` entity in our `resolvers.js` file. Copy
    the new resolver function over to the `resolvers` file, as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须在我们的 `resolvers.js` 文件中实现 `PostFeed` 实体。将新的解析函数复制到 `resolvers` 文件中，如下所示：
- en: '[PRE51]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We build a simple `query` object that Sequelize understands, which allows us
    to paginate our posts. The `page` number is multiplied by the `limit` parameter,
    to skip the calculated number of rows. The `offset` parameter skips the number
    of rows, and the `limit` parameter stops selecting rows after a specified number
    (which, in our case, is 10).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个 Sequelize 可以理解的简单 `query` 对象，这使得我们可以对帖子进行分页。`page` 数乘以 `limit` 参数，以跳过计算出的行数。`offset`
    参数跳过行数，而 `limit` 参数在指定数量（在我们的例子中是 10）之后停止选择行。
- en: 'Our frontend needs some adjustments to support pagination. Install a new React
    package with `npm`, which provides us with an infinite scroll implementation,
    as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前端需要一些调整以支持分页。使用 `npm` 安装一个新的 React 包，它为我们提供了无限滚动实现，如下所示：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Infinite scrolling is an excellent method to let a user load more content by
    scrolling to the bottom of the browser window.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动是一种让用户通过滚动到浏览器窗口底部来加载更多内容的优秀方法。
- en: 'You are free to program this on your own, but we are not going to cover that
    here. Go back to the `Feed.js` file, replace the `GET_POSTS` query, and import
    the `react-infinite-scroll-component` package with the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己编程实现，但在这里我们不会涉及。回到 `Feed.js` 文件，替换 `GET_POSTS` 查询，并使用以下代码导入 `react-infinite-scroll-component`
    包：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since the `postsFeed` query expects parameters other than the standard query
    from before, we need to edit our `useQuery` Hook and also introduce two new state
    variables. The changed lines are shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `postsFeed` 查询期望除了之前的标准查询之外的其他参数，我们需要编辑我们的 `useQuery` 钩子，并引入两个新的状态变量。更改的行如下所示：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code snippet, we extract the `fetchMore` function from the
    `useQuery` Hook, which is used to run the pagination request to load more post
    items. We also create a `hasMore` state variable that will identify if there is
    more data to load from the GraphQL API, and the `page` variable will save the
    current page—or, to be exact, the number of pages we already scrolled.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从 `useQuery` 钩子中提取了 `fetchMore` 函数，该函数用于运行分页请求以加载更多帖子项。我们还创建了一个
    `hasMore` 状态变量，它将确定是否还有更多数据可以从 GraphQL API 加载，而 `page` 变量将保存当前页——更确切地说，是已经滚动过的页数。
- en: 'According to the new data structure defined in our GraphQL schema, we extract
    the `posts` array from the `postsFeed` object. You can do that by replacing the
    code with these two lines:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在 GraphQL 模式中定义的新数据结构，我们从 `postsFeed` 对象中提取 `posts` 数组。您可以通过替换以下两行代码来实现：
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Replace the markup of the `div` tag of our current feed to make use of our
    new infinite scroll package, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们当前源中的 `div` 标签的标记替换为使用我们新的无限滚动包，如下所示：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The only thing that the infinite scroll package does is run the `loadMore` function
    provided in the `next` property, as long as `hasMore` is set to `true` and the
    user scrolls to the bottom of the browser window. When `hasMore` is set to `false`,
    the event listeners are unbound and no more requests are sent. This behavior is
    great when no further content is available, as we can stop sending more requests.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 无限滚动包所做的唯一事情是运行 `next` 属性中提供的 `loadMore` 函数，只要 `hasMore` 设置为 `true` 并且用户滚动到浏览器窗口的底部。当
    `hasMore` 设置为 `false` 时，事件监听器将被解绑，不再发送更多请求。当没有更多内容可用时，这种行为非常好，因为我们可以停止发送更多请求。
- en: 'We need to implement the `loadMore` function before running the infinite scroller.
    It relies on the `page` variable that we just configured. The `loadMore` function
    should look like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行无限滚动器之前，我们需要实现 `loadMore` 函数。它依赖于我们刚刚配置的 `page` 变量。`loadMore` 函数应如下所示：
- en: '[PRE57]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s quickly go through the preceding code, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下前面的代码，如下所示：
- en: The `fetchMore` function receives an object as a parameter.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fetchMore` 函数接收一个对象作为参数。'
- en: We specify the `variables` field, which is sent with our request, to query the
    correct page index of our paginated posts.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定了 `variables` 字段，它随我们的请求发送，以查询分页帖子正确的页面索引。
- en: The `updateQuery` function is defined to implement the logic to add the new
    data that needs to be included in our news feed. We can check whether any new
    data is included in the response by looking at the returned array length. If there
    are no posts, we can set the `hasMore` state variable to `false`, which unbinds
    all scrolling events. Otherwise, we can continue and build a new `postsFeed` object
    inside of the `newData` variable. The `posts` array is filled by the previous
    `posts` query result and the newly fetched posts. In the end, the `newData` variable
    is returned and saved in the client's cache.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updateQuery` 函数被定义为实现将需要包含在我们的新闻源中的新数据的逻辑。我们可以通过查看返回的数组长度来检查响应中是否包含任何新数据。如果没有帖子，我们可以将
    `hasMore` 状态变量设置为 `false`，这将解绑所有滚动事件。否则，我们可以继续，并在 `newData` 变量内部构建一个新的 `postsFeed`
    对象。`posts` 数组由之前的 `posts` 查询结果和刚刚获取的帖子填充。最后，`newData` 变量被返回并保存在客户端的缓存中。'
- en: When the `updateQuery` function is finished, the UI rerenders accordingly.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `updateQuery` 函数完成后，UI 将相应地重新渲染。
- en: At this point, your feed is able to load new posts whenever the user visits
    the bottom of the window. We no longer load all posts at once, but instead, we
    only get the 10 most recent from our database. Every time you build an application
    with large lists and many rows, you have to add some kind of pagination, with
    either infinite scrolling or simple page buttons.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的源能够在用户访问窗口底部时加载新帖子。我们不再一次性加载所有帖子，而是只从数据库中获取最新的 10 个帖子。每次您构建具有大量列表和许多行的应用程序时，您都必须添加某种分页，无论是无限滚动还是简单的页面按钮。
- en: 'We have now created a new problem. We can submit a new post with the GraphQL
    mutation if the React Apollo cache is empty, but the `update` function of the
    `Mutation` component will throw an error. Our new query is stored not only under
    its name but also under the variables used to send it. To read the data of a specific
    paginated `posts` request from our client''s cache, we must also pass variables,
    such as the page index. Furthermore, we have a second layer, `postsFeed`, as the
    parent of the `posts` array. Change the `update` function to get it working again,
    as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个新问题。如果 React Apollo 缓存为空，我们可以使用 GraphQL 变异提交一个新的帖子，但 `Mutation` 组件的
    `update` 函数将抛出错误。我们的新查询不仅存储在其名称下，还存储在发送它的变量下。要从我们客户端的缓存中读取特定分页 `posts` 请求的数据，我们必须也传递变量，例如页面索引。此外，我们还有一个第二层，`postsFeed`
    作为 `posts` 数组的父级。将 `update` 函数更改为使其再次工作，如下所示：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We actually just changed the `posts` property to `postsFeed` and updated the
    function to update the extracted `posts` array.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上只是将 `posts` 属性更改为 `postsFeed`，并更新了函数以更新提取的 `posts` 数组。
- en: Complex code such as this requires some useful tools to debug it. Continue reading
    to learn more about the Apollo Client Devtools.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如此复杂的代码需要一些有用的工具来调试。继续阅读以了解更多关于 Apollo Client Devtools 的信息。
- en: Debugging with the Apollo Client Devtools
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apollo Client Devtools 进行调试
- en: Whenever you write or extend your own application, you have to test, debug,
    and log different things during development. In [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*, we looked at the React Developer Tools
    for Chrome, while in [*Chapter 2*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032),
    *Setting Up GraphQL with Express.js*, we explored Postman for testing APIs. Now,
    let's take a look at another tool.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您编写还是扩展自己的应用程序，您都必须在开发过程中测试、调试和记录不同的事情。在[*第1章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017)，*准备您的开发环境*中，我们探讨了Chrome的React开发者工具，而在[*第2章*](B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032)，*使用Express.js设置GraphQL*中，我们探讨了Postman用于测试API。现在，让我们看看另一个工具。
- en: The **Apollo Client Devtools** is another Chrome extension, allowing you to
    send Apollo requests. While Postman is great in many ways, it does not integrate
    with our application and does not implement all GraphQL-specific features. The
    Apollo Client Devtools rely on the Apollo Client that we set up very early on
    in this chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apollo Client Devtools**是另一个Chrome扩展，允许您发送Apollo请求。虽然Postman在很多方面都很出色，但它不与我们的应用程序集成，并且没有实现所有GraphQL特定的功能。Apollo
    Client Devtools依赖于我们在本章早期设置的Apollo客户端。'
- en: Every request, either a query or mutation, is sent through the Apollo Client
    of our application. The developer tools also provide features such as autocomplete,
    for writing requests. They can show us the schema as it is implemented in our
    GraphQL API, and we also can view the cache. We will go over all four of the main
    windows offered by the extension.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求，无论是查询还是突变，都是通过我们应用程序的Apollo客户端发送的。开发者工具还提供了诸如自动完成等特性，用于编写请求。它们可以显示我们的GraphQL
    API中实现的模式，我们还可以查看缓存。我们将详细介绍扩展提供的四个主要窗口。
- en: 'Let''s take a look at an example here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里看看一个例子：
- en: '![Figure 4.7 – The Apollo Client Devtools'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – Apollo客户端开发者工具'
- en: '](img/Figure_4.07_B17337.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.07_B17337.jpg)'
- en: Figure 4.7 – The Apollo Client Devtools
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – Apollo客户端开发者工具
- en: 'The **GraphiQL** window is shown in the preceding screenshot. The three panels
    in the preceding screenshot are described as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphiQL**窗口如前截图所示。前一个截图中的三个面板描述如下：'
- en: You can enter a request that you want to send in the left-hand text area. It
    can be a mutation or query, including the markup for inputs, for example. You
    can also enter the variables at the bottom.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在左侧文本区域中输入您想要发送的请求。它可以是一个突变或查询，包括输入的标记，例如。您还可以在底部输入变量。
- en: When sending a request, the response is shown in the middle panel.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送请求时，响应将显示在中间面板中。
- en: In the panel on the right, you can find the schema against which you will run
    requests. You can search through the complete GraphQL schema or manually step
    into the tree by clicking on the root types. This feature is useful when you forget
    what a specific field or mutation is called or which parameters it accepts.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧面板中，您可以找到您将运行请求的模式。您可以通过点击根类型手动遍历整个GraphQL模式或搜索整个模式。当您忘记一个特定的字段或突变叫什么或它接受哪些参数时，这个特性非常有用。
- en: In the top bar, you will find the **Prettify** button, which tidies your query
    so that it is more readable. The **Load from cache** checkbox tries to retrieve
    any requested data directly from the cache, when possible. By clicking on the
    **Play** button, you run the query. These are all tools to test our GraphQL requests
    properly. The **Build** button will give you a small graphical interface to edit
    your query.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部栏中，您会找到**Prettify**按钮，它可以使您的查询更加整洁，便于阅读。**Load from cache**复选框尝试在可能的情况下直接从缓存中检索任何请求的数据。通过点击**Play**按钮，您可以运行查询。这些都是用来正确测试我们的GraphQL请求的工具。**Build**按钮将为您提供一个小型的图形界面来编辑您的查询。
- en: 'Next, there is the **Queries** window, which is a helpful display. All of the
    queries that were ever run through the client are listed here, including the query
    string and variables. If you want to, you can rerun a query by clicking on the
    button at the top, as illustrated in the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**Queries**窗口，这是一个有用的显示。这里列出了客户端运行过的所有查询，包括查询字符串和变量。如果您愿意，可以通过点击顶部的按钮重新运行一个查询，如下面的截图所示：
- en: '![Figure 4.8 – Apollo Queries window'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – Apollo Queries窗口'
- en: '](img/Figure_4.08_B17337.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08_B17337.jpg)'
- en: Figure 4.8 – Apollo Queries window
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – Apollo Queries窗口
- en: The **Mutations** window is actually the same as the **Queries** window, but
    for mutations. The list is empty, as long as you have not sent any mutations.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mutations**窗口实际上与**Queries**窗口相同，但用于突变。列表为空，只要您没有发送任何突变。'
- en: 'The last window is **Cache**. Here, you are able to see all of the data stored
    inside the Apollo cache, as illustrated in the following screenshot:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个窗口是 **缓存**。在这里，你可以看到存储在 Apollo 缓存中的所有数据，如下面的截图所示：
- en: '![Figure 4.9 – Apollo Cache window'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – Apollo 缓存窗口'
- en: '](img/Figure_4.09_B17337.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.09_B17337.jpg)'
- en: Figure 4.9 – Apollo Cache window
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – Apollo 缓存窗口
- en: In the left-hand panel, you can search through your data. The right-hand panel
    shows you the selected object in JSON.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板中，你可以搜索你的数据。右侧面板显示了所选对象在 JSON 中的显示。
- en: You can also see that I have tested the API a lot, as there are multiple `Post`
    objects in the left-hand panel.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到我已经对 API 进行了大量的测试，因为左侧面板中有多个 `Post` 对象。
- en: Resetting the Apollo Cache
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 重置 Apollo 缓存
- en: For testing purposes, I submitted multiple posts via a mutation, but I deleted
    them to make sure that the screenshots were clear. Apollo did not delete the old
    posts that were deleted in the database, so they are still inside of the cache.
    You should delete this data when a user logs out of your application so that unauthorized
    users cannot access it.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我通过突变提交了多个帖子，但后来删除了它们以确保截图清晰。Apollo 没有删除数据库中已删除的旧帖子，因此它们仍然存储在缓存中。你应该在用户退出你的应用程序时删除这些数据，以确保未经授权的用户无法访问。
- en: That is everything you need to know about the Apollo Client Devtools.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要了解的关于 Apollo 客户端 Devtools 的所有内容。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to connect your GraphQL API to React. To do
    this, we used Apollo Client to manage the cache and the state of our components
    and to update React and the actual DOM of the browser. We looked at how to send
    queries and mutations against our server. We also covered how to implement pagination
    with React and Apollo, and how to use the Apollo Client Devtools.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将你的 GraphQL API 连接到 React。为此，我们使用了 Apollo 客户端来管理组件的缓存和状态，并更新 React
    和浏览器的实际 DOM。我们探讨了如何向服务器发送查询和突变。我们还介绍了如何使用 React 和 Apollo 实现分页，以及如何使用 Apollo 客户端
    Devtools。
- en: After this chapter, you should be able to integrate the Apollo Client into your
    React application at any time. Furthermore, you should be able to make use of
    Apollo in every component of your application and be able to debug it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你应该能够随时将 Apollo 客户端集成到你的 React 应用程序中。此外，你应该能够在应用程序的每个组件中使用 Apollo，并能够对其进行调试。
- en: The next chapter will cover how to write reusable React components. Up to this
    point, we have written the code, but we haven't thought about readability or good
    practices very much. We will address these issues in the next chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何编写可重用的 React 组件。到目前为止，我们已经编写了代码，但并没有太多考虑可读性或良好的实践。这些问题将在下一章中解决。
