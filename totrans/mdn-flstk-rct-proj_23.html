<html><head></head><body>
<div id="_idContainer154" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-318"><a id="_idTextAnchor321" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">18</span></h1>
<h1 id="_idParaDest-319" class="calibre5"><a id="_idTextAnchor322" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Advanced Next.js Concepts and Optimizations</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Now that we’ve learned about the essential features of Next.js and </span><strong class="bold"><span class="kobospan" id="kobo.4.1">React Server Components</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">RSCs</span></strong><span class="kobospan" id="kobo.7.1">), let’s dive a</span><a id="_idIndexMarker967" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.8.1"> bit deeper into the Next.js framework. </span><span class="kobospan" id="kobo.8.2">In this chapter, we are going to learn how caching works in Next.js and how it can be used to optimize our applications. </span><span class="kobospan" id="kobo.8.3">We are also going to learn how to implement API routes in Next.js. </span><span class="kobospan" id="kobo.8.4">Then, we are going to learn how to optimize a Next.js app for search engines and social media by adding metadata. </span><span class="kobospan" id="kobo.8.5">Finally, we are going to learn how to optimally load images and fonts </span><span><span class="kobospan" id="kobo.9.1">in Next.js.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.10.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.11.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.12.1">Defining API routes </span><span><span class="kobospan" id="kobo.13.1">in Next.js</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Caching </span><span><span class="kobospan" id="kobo.15.1">in Next.js</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.16.1">Search engine optimization</span></strong><span class="kobospan" id="kobo.17.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.18.1">SEO</span></strong><span class="kobospan" id="kobo.19.1">) </span><span><span class="kobospan" id="kobo.20.1">with Next.js</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.21.1">Optimized image and font loading </span><span><span class="kobospan" id="kobo.22.1">in Next.js</span></span></li>
</ul>
<h1 id="_idParaDest-320" class="calibre5"><a id="_idTextAnchor323" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.23.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">Before we start, please install all the requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.25.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.26.1">, </span><em class="italic"><span class="kobospan" id="kobo.27.1">Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.28.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.29.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.30.1">, </span><em class="italic"><span class="kobospan" id="kobo.31.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.32.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.33.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">The versions listed in those chapters are the ones used in this book. </span><span class="kobospan" id="kobo.34.2">While installing a newer version should not be an issue, please note that certain steps might work differently. </span><span class="kobospan" id="kobo.34.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.35.1">Chapter 1</span></em></span></a> <span><span class="kobospan" id="kobo.36.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.37.1"> 2</span></em></span><span><span class="kobospan" id="kobo.38.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.40.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.41.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18</span></span></a><span><span class="kobospan" id="kobo.42.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.44.1">at: </span></span><a href="https://youtu.be/jzCRoJPGoG0" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.45.1">https://youtu.be/jzCRoJPGoG0</span></span></a><span><span class="kobospan" id="kobo.46.1">.</span></span></p>
<h1 id="_idParaDest-321" class="calibre5"><a id="_idTextAnchor324" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1">Defining API routes in Next.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.48.1">In the </span><a id="_idIndexMarker968" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.49.1">previous chapter, we used RSCs to access our database via</span><a id="_idIndexMarker969" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.50.1"> a data layer; no API routes were needed for that! </span><span class="kobospan" id="kobo.50.2">However, sometimes, it still makes sense to expose an external API. </span><span class="kobospan" id="kobo.50.3">As an example, we might want to allow third-party apps to query blog posts. </span><span class="kobospan" id="kobo.50.4">Thankfully, Next.js also has a feature to define API routes, called </span><span><span class="kobospan" id="kobo.51.1">Route Handlers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">Route Handlers are also defined inside the </span><strong class="source-inline"><span class="kobospan" id="kobo.53.1">src/app/</span></strong><span class="kobospan" id="kobo.54.1"> directory but in a </span><strong class="source-inline"><span class="kobospan" id="kobo.55.1">route.js</span></strong><span class="kobospan" id="kobo.56.1"> file instead of a </span><strong class="source-inline"><span class="kobospan" id="kobo.57.1">page.js</span></strong><span class="kobospan" id="kobo.58.1"> file (a path can only be either a route or a page, so only one of these files should be placed inside a folder). </span><span class="kobospan" id="kobo.58.2">Instead of exporting a page component, we need to export functions that handle various types of requests there. </span><span class="kobospan" id="kobo.58.3">For example, to handle a </span><strong class="source-inline"><span class="kobospan" id="kobo.59.1">GET</span></strong><span class="kobospan" id="kobo.60.1"> request, we must define and export the </span><span><span class="kobospan" id="kobo.61.1">following function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.62.1">
export async function GET() {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.63.1">Next.js supports the following HTTP methods for Route Handlers: </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">GET</span></strong><span class="kobospan" id="kobo.65.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.66.1">POST</span></strong><span class="kobospan" id="kobo.67.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.68.1">PUT</span></strong><span class="kobospan" id="kobo.69.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.70.1">PATCH</span></strong><span class="kobospan" id="kobo.71.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.72.1">DELETE</span></strong><span class="kobospan" id="kobo.73.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.74.1">HEAD</span></strong><span class="kobospan" id="kobo.75.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.76.1">OPTIONS</span></strong><span class="kobospan" id="kobo.77.1">. </span><span class="kobospan" id="kobo.77.2">For unsupported methods, Next.js will return a </span><strong class="source-inline"><span class="kobospan" id="kobo.78.1">405 Method Not </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.79.1">Allowed</span></strong></span><span><span class="kobospan" id="kobo.80.1"> response.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.81.1">Next.js supports the native </span><strong class="source-inline"><span class="kobospan" id="kobo.82.1">Request</span></strong><span class="kobospan" id="kobo.83.1"> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.84.1">https://developer.mozilla.org/en-US/docs/Web/API/Request</span></a><span class="kobospan" id="kobo.85.1">) and </span><strong class="source-inline"><span class="kobospan" id="kobo.86.1">Response</span></strong><span class="kobospan" id="kobo.87.1"> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.88.1">https://developer.mozilla.org/en-US/docs/Web/API/Response</span></a><span class="kobospan" id="kobo.89.1">) web APIs but extends them into </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">NextRequest</span></strong><span class="kobospan" id="kobo.91.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.92.1">NextResponse</span></strong><span class="kobospan" id="kobo.93.1"> APIs, which make handling cookies and headers easier. </span><span class="kobospan" id="kobo.93.2">We used the </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">cookies()</span></strong><span class="kobospan" id="kobo.95.1"> function from Next.js to easily create, get, and delete a cookie for the JWT in the previous chapter. </span><span class="kobospan" id="kobo.95.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.96.1">headers()</span></strong><span class="kobospan" id="kobo.97.1"> function makes it easy to get headers from a request. </span><span class="kobospan" id="kobo.97.2">These functions can be used in the same way in RSCs and </span><span><span class="kobospan" id="kobo.98.1">Route Handlers.</span></span></p>
<h2 id="_idParaDest-322" class="calibre7"><a id="_idTextAnchor325" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.99.1">Creating an API route for listing blog posts</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.100.1">Let’s start by </span><a id="_idIndexMarker970" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1">defining an API route for listing </span><span><span class="kobospan" id="kobo.102.1">blog posts:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.103.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.104.1">ch17</span></strong><span class="kobospan" id="kobo.105.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.106.1">ch18</span></strong><span class="kobospan" id="kobo.107.1"> folder, </span><span><span class="kobospan" id="kobo.108.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.109.1">$ cp -R ch17 ch18</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.110.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.111.1">ch18</span></strong><span class="kobospan" id="kobo.112.1"> folder in </span><span><span class="kobospan" id="kobo.113.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.114.1">To make the API routes easier to distinguish from pages on our app, create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.115.1">src/app/api/</span></strong></span><span><span class="kobospan" id="kobo.116.1"> folder.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.117.1">Inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.118.1">src/app/api/</span></strong><span class="kobospan" id="kobo.119.1"> folder, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.120.1">src/app/api/v1/</span></strong><span class="kobospan" id="kobo.121.1"> folder to</span><a id="_idIndexMarker971" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.122.1"> make sure our API is versioned for potential changes to the </span><span><span class="kobospan" id="kobo.123.1">API later.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.124.1">Next, create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.125.1">src/app/api/v1/posts/</span></strong><span class="kobospan" id="kobo.126.1"> folder for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.127.1">/</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.128.1">api/v1/posts</span></strong></span><span><span class="kobospan" id="kobo.129.1"> route.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.130.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.131.1">src/app/api/posts/route.js</span></strong><span class="kobospan" id="kobo.132.1"> file, where we import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.133.1">initDatabase</span></strong><span class="kobospan" id="kobo.134.1"> function and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.135.1">listAllPosts</span></strong><span class="kobospan" id="kobo.136.1"> function from the </span><span><span class="kobospan" id="kobo.137.1">data layer:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.138.1">
import { initDatabase } from '@/db/init'
import { listAllPosts } from '@/data/posts'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.139.1">Then, define and export a </span><strong class="source-inline1"><span class="kobospan" id="kobo.140.1">GET</span></strong><span class="kobospan" id="kobo.141.1"> function. </span><span class="kobospan" id="kobo.141.2">This is going to handle HTTP GET requests to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.142.1">/</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.143.1">api/v1/posts</span></strong></span><span><span class="kobospan" id="kobo.144.1"> route:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.145.1">
export async function GET() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.146.1">Inside it, we must initialize the database and get a list of </span><span><span class="kobospan" id="kobo.147.1">all posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.148.1">
  await initDatabase()
  const posts = await listAllPosts()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.149.1">Use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.150.1">Response</span></strong><span class="kobospan" id="kobo.151.1"> web API to generate a </span><span><span class="kobospan" id="kobo.152.1">JSON response:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.153.1">
  return Response.json({ posts })
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.154.1">Make sure Docker and the MongoDB container are </span><span><span class="kobospan" id="kobo.155.1">running properly!</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.156.1">Start the Next.js app, </span><span><span class="kobospan" id="kobo.157.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.158.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.159.1">Now, go </span><a id="_idIndexMarker972" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.160.1">to </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">http://localhost:3000/api/v1/posts</span></strong><span class="kobospan" id="kobo.162.1"> to see the posts being returned as </span><a id="_idIndexMarker973" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.163.1">JSON, as shown in the </span><span><span class="kobospan" id="kobo.164.1">following figure:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer150">
<span class="kobospan" id="kobo.165.1"><img alt="Figure 18.1 – JSON response with posts generated from the Next.js Route Handler" src="image/B19385_18_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.166.1">Figure 18.1 – JSON response with posts generated from the Next.js Route Handler</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.167.1">Now, third-party apps can also get the posts via our API! </span><span class="kobospan" id="kobo.167.2">Let’s continue by learning more about caching </span><span><span class="kobospan" id="kobo.168.1">in Next.js.</span></span></p>
<h1 id="_idParaDest-323" class="calibre5"><a id="_idTextAnchor326" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.169.1">Caching in Next.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.170.1">So far, we have always been using </span><a id="_idIndexMarker974" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.171.1">Next.js in dev mode. </span><span class="kobospan" id="kobo.171.2">In dev mode, most of the caching that Next.js does is turned off to make it easy for us to develop our apps with hot reloading and always up-to-date data. </span><span class="kobospan" id="kobo.171.3">However, once we switch to production mode, static rendering and caching are turned on by default. </span><span class="kobospan" id="kobo.171.4">Static rendering means that if a page only contains static components (such as an “About Us” or “Imprint” page, which only contains static content), it will be statically rendered and served as HTML, or as static text/JSON for routes. </span><span class="kobospan" id="kobo.171.5">Additionally, Next.js will try to cache data and server-side rendered components as much as possible to keep your </span><span><span class="kobospan" id="kobo.172.1">app performant.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.173.1">Next.js has four main types </span><span><span class="kobospan" id="kobo.174.1">of cache:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.175.1">Data cache</span></strong><span class="kobospan" id="kobo.176.1">: A server-side</span><a id="_idIndexMarker975" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.177.1"> cache for storing data across user requests and deployments. </span><span class="kobospan" id="kobo.177.2">This is persistent but can </span><span><span class="kobospan" id="kobo.178.1">be revalidated.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.179.1">Request memoization</span></strong><span class="kobospan" id="kobo.180.1">: A </span><a id="_idIndexMarker976" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.181.1">server-side cache for return values of functions if they are called multiple times in a </span><span><span class="kobospan" id="kobo.182.1">single request.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.183.1">Full route cache</span></strong><span class="kobospan" id="kobo.184.1">: A</span><a id="_idIndexMarker977" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1"> server-side cache of Next.js routes. </span><span class="kobospan" id="kobo.185.2">This cache is persistent but can </span><span><span class="kobospan" id="kobo.186.1">be revalidated.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.187.1">Router cache</span></strong><span class="kobospan" id="kobo.188.1">: A </span><a id="_idIndexMarker978" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.189.1">client-side cache of routes to reduce server requests on navigation, for a single user session </span><span><span class="kobospan" id="kobo.190.1">or time-based.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.191.1">The first two types of cache (data cache and request memoization) mainly apply to using the </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">fetch()</span></strong><span class="kobospan" id="kobo.193.1"> function on the server side to, for example, pull data from a third-party API. </span><span class="kobospan" id="kobo.193.2">However, recently, it is also possible to use these two types of caches for any function by wrapping them with the </span><strong class="source-inline"><span class="kobospan" id="kobo.194.1">unstable_cache()</span></strong><span class="kobospan" id="kobo.195.1"> function. </span><span class="kobospan" id="kobo.195.2">Despite its name, this function can already safely be used in production. </span><span class="kobospan" id="kobo.195.3">It is only called “unstable” because the API might change and require code changes when new Next.js versions are released. </span><span class="kobospan" id="kobo.195.4">See </span><a href="https://nextjs.org/docs/app/api-reference/functions/unstable_cache" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.196.1">https://nextjs.org/docs/app/api-reference/functions/unstable_cache</span></a><span class="kobospan" id="kobo.197.1"> for </span><span><span class="kobospan" id="kobo.198.1">more information.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.199.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.200.1">Alternatively, the React </span><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">cache()</span></strong><span class="kobospan" id="kobo.202.1"> function could be used to memoize return values of functions, but the Next.js </span><strong class="source-inline1"><span class="kobospan" id="kobo.203.1">unstable_cache()</span></strong><span class="kobospan" id="kobo.204.1"> function is more flexible, allowing us to dynamically revalidate the cache via a path or tag. </span><span class="kobospan" id="kobo.204.2">We are going to learn more about cache revalidation later in </span><span><span class="kobospan" id="kobo.205.1">this section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">The full route </span><a id="_idIndexMarker979" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.207.1">cache is an additional cache that makes sure that when data doesn’t change, we don’t even need to re-render pages on the server side so that Next.js can directly return pre-rendered static HTML and the RSC payload. </span><span class="kobospan" id="kobo.207.2">However, invalidating the data cache will also invalidate the corresponding full route cache and trigger </span><span><span class="kobospan" id="kobo.208.1">a re-render.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.209.1">The router cache is a client-side cache and is mainly used when the user navigates between pages, allowing us to instantly show pages that they have already visited without having to fetch them from the </span><span><span class="kobospan" id="kobo.210.1">server again.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">Additionally, if Next.js detects that a page or route only contains static content, it will pre-render and store it as static content. </span><span class="kobospan" id="kobo.211.2">Static content cannot be revalidated anymore, so we need to be careful and ensure that all dynamic content on our apps is considered “dynamic” by Next.js and not accidentally detected as “</span><span><span class="kobospan" id="kobo.212.1">static” content.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.213.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.214.1">In this book, we call this process </span><strong class="bold"><span class="kobospan" id="kobo.215.1">static rendering</span></strong><span class="kobospan" id="kobo.216.1">. </span><span class="kobospan" id="kobo.216.2">However, on other resources, it may also be called “automatic static optimization” or “static </span><span><span class="kobospan" id="kobo.217.1">site generation.”</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">Next.js will opt out of static rendering and consider a page or route dynamic in the </span><span><span class="kobospan" id="kobo.219.1">following instances:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.220.1">When using a dynamic function, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.221.1">cookies()</span></strong><span class="kobospan" id="kobo.222.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.223.1">headers()</span></strong><span class="kobospan" id="kobo.224.1">, </span><span><span class="kobospan" id="kobo.225.1">or </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.226.1">searchParams</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.227.1">When setting </span><strong class="source-inline1"><span class="kobospan" id="kobo.228.1">export const dynamic = 'force-dynamic'</span></strong><span class="kobospan" id="kobo.229.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.230.1">export const revalidate = 0</span></strong></li>
<li class="calibre11"><span class="kobospan" id="kobo.231.1">When a Route Handler handles a </span><span><span class="kobospan" id="kobo.232.1">non-GET request</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.233.1">For more in-depth information on the different types of caching, have a look at the Next.js documentation on </span><a id="_idIndexMarker980" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.234.1">caching: </span></span><a href="https://nextjs.org/docs/app/building-your-application/caching" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.235.1">https://nextjs.org/docs/app/building-your-application/caching</span></span></a><span><span class="kobospan" id="kobo.236.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.237.1">Now, let’s explore how static rendering works in practice by looking at how our route behaves in a production build of </span><span><span class="kobospan" id="kobo.238.1">our app.</span></span></p>
<h2 id="_idParaDest-324" class="calibre7"><a id="_idTextAnchor327" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.239.1">Exploring static rendering in API routes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.240.1">In this chapter, we implemented a </span><a id="_idIndexMarker981" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.241.1">Route Handler for getting blog posts. </span><span class="kobospan" id="kobo.241.2">Now, let’s explore </span><a id="_idIndexMarker982" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.242.1">how this route behaves in dev and </span><span><span class="kobospan" id="kobo.243.1">production mode:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.244.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.245.1">src/app/api/v1/posts/route.js</span></strong><span class="kobospan" id="kobo.246.1"> and add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.247.1">currentTime</span></strong><span class="kobospan" id="kobo.248.1"> value with </span><strong class="source-inline1"><span class="kobospan" id="kobo.249.1">Date.now()</span></strong><span class="kobospan" id="kobo.250.1"> to the response, </span><span><span class="kobospan" id="kobo.251.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.252.1">
  return Response.json({ posts, </span><strong class="bold1"><span class="kobospan1" id="kobo.253.1">currentTime: Date.now()</span></strong><span class="kobospan1" id="kobo.254.1"> })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.255.1">Refresh the page on </span><strong class="source-inline1"><span class="kobospan" id="kobo.256.1">http://localhost:3000/api/v1/posts</span></strong><span class="kobospan" id="kobo.257.1"> a couple of times; you will see that </span><strong class="source-inline1"><span class="kobospan" id="kobo.258.1">currentTime</span></strong><span class="kobospan" id="kobo.259.1"> is always the </span><span><span class="kobospan" id="kobo.260.1">latest timestamp.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.261.1">Quit the Next.js development server by using </span><em class="italic"><span class="kobospan" id="kobo.262.1">Ctrl</span></em><span class="kobospan" id="kobo.263.1"> + </span><span><em class="italic"><span class="kobospan" id="kobo.264.1">C</span></em></span><span><span class="kobospan" id="kobo.265.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.266.1">Build the Next.js app for production and start it, </span><span><span class="kobospan" id="kobo.267.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.268.1">$ npm run build</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.269.1">$ npm start</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.270.1">Refresh the page on </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">http://localhost:3000/api/v1/posts</span></strong><span class="kobospan" id="kobo.272.1"> a couple of times. </span><span class="kobospan" id="kobo.272.2">Now, </span><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">currentTime</span></strong><span class="kobospan" id="kobo.274.1"> doesn’t change at all! </span><span class="kobospan" id="kobo.274.2">Even if we restart the Next.js server, </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">currentTime</span></strong><span class="kobospan" id="kobo.276.1"> still doesn’t change. </span><span class="kobospan" id="kobo.276.2">The response of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">GET /api/v1/posts</span></strong><span class="kobospan" id="kobo.278.1"> route is statically rendered during </span><span><span class="kobospan" id="kobo.279.1">build time.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.280.1">Static rendering works similarly for routes and pages, so pages will also be statically rendered by default. </span><span class="kobospan" id="kobo.280.2">This means that RSCs do </span><em class="italic"><span class="kobospan" id="kobo.281.1">not</span></em><span class="kobospan" id="kobo.282.1"> require a server, per se; they can also run during build time. </span><span class="kobospan" id="kobo.282.2">We only need a Node.js server if we want to have dynamic pages/routes. </span><span class="kobospan" id="kobo.282.3">This means we could, for example, create a blog or website in Next.js and export a static bundle, allowing us to host it on a simple </span><span><span class="kobospan" id="kobo.283.1">web server.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.284.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.285.1">Exporting a Next.js app as a static bundle can be achieved by specifying the </span><strong class="source-inline1"><span class="kobospan" id="kobo.286.1">output: 'export'</span></strong><span class="kobospan" id="kobo.287.1"> option in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.288.1">next.config.js</span></strong></span><span><span class="kobospan" id="kobo.289.1"> file.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.290.1">Interestingly, if we create a new blog post, our home page </span><em class="italic"><span class="kobospan" id="kobo.291.1">does</span></em><span class="kobospan" id="kobo.292.1"> get updated. </span><span class="kobospan" id="kobo.292.2">However, that is only the case because </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">RootLayout</span></strong><span class="kobospan" id="kobo.294.1"> uses </span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">cookies()</span></strong><span class="kobospan" id="kobo.296.1"> to check if the user is logged in, making all pages on our blog app dynamic (and thus not statically rendered). </span><span class="kobospan" id="kobo.296.2">This can also</span><a id="_idIndexMarker983" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.297.1"> be seen by</span><a id="_idIndexMarker984" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.298.1"> looking at the output of </span><strong class="source-inline"><span class="kobospan" id="kobo.299.1">npm </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">run build</span></strong></span><span><span class="kobospan" id="kobo.301.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer151">
<span class="kobospan" id="kobo.302.1"><img alt="Figure 18.2 – Seeing which routes are statically and dynamically ﻿rendered in the build output" src="image/B19385_18_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.303.1">Figure 18.2 – Seeing which routes are statically and dynamically rendered in the build output</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.304.1">As can be seen from </span><span><em class="italic"><span class="kobospan" id="kobo.305.1">Figure 18</span></em></span><em class="italic"><span class="kobospan" id="kobo.306.1">.2</span></em><span class="kobospan" id="kobo.307.1">, the </span><strong class="source-inline"><span class="kobospan" id="kobo.308.1">/api/v1/posts</span></strong><span class="kobospan" id="kobo.309.1"> route is “prerendered as static content,” while all other routes are “server-rendered on demand </span><span><span class="kobospan" id="kobo.310.1">using Node.js.”</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.311.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.312.1">If we wanted to statically render some pages in our blog, we would have to make sure the user bar isn’t visible on those pages. </span><span class="kobospan" id="kobo.312.2">For example, we could</span><a id="_idIndexMarker985" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.313.1"> create a </span><strong class="bold"><span class="kobospan" id="kobo.314.1">route group</span></strong><span class="kobospan" id="kobo.315.1"> (</span><a href="https://nextjs.org/docs/app/building-your-application/routing/route-groups" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.316.1">https://nextjs.org/docs/app/building-your-application/routing/route-groups</span></a><span class="kobospan" id="kobo.317.1">) for all pages that have a user bar, with a separate layout that contains the user bar. </span><span class="kobospan" id="kobo.317.2">Then, we can remove the user bar from the root layout. </span><span class="kobospan" id="kobo.317.3">That way, we could create, for example, an About page that is statically rendered while keeping the rest of the </span><span><span class="kobospan" id="kobo.318.1">blog dynamic.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.319.1">As we have seen, in Next.js, pages </span><a id="_idIndexMarker986" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.320.1">and routes are statically rendered by </span><a id="_idIndexMarker987" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.321.1">default (if possible). </span><span class="kobospan" id="kobo.321.2">However, in the case of our API route, this is not what we want! </span><span class="kobospan" id="kobo.321.3">We want to be able to dynamically fetch posts from the API. </span><span class="kobospan" id="kobo.321.4">Static rendering and caching in Next.js can be confusing when we’re starting out developing apps with it, but it becomes a powerful tool for keeping our </span><span><span class="kobospan" id="kobo.322.1">apps optimized.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.323.1">Now, let’s learn how to properly handle the cache to make our pages and routes dynamic when they need to be while keeping them cached </span><span><span class="kobospan" id="kobo.324.1">whenever possible.</span></span></p>
<h2 id="_idParaDest-325" class="calibre7"><a id="_idTextAnchor328" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.325.1">Making the route dynamic</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.326.1">To make the route </span><a id="_idIndexMarker988" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.327.1">dynamic, we need to set the </span><strong class="source-inline"><span class="kobospan" id="kobo.328.1">export const dynamic = 'force-dynamic'</span></strong><span class="kobospan" id="kobo.329.1"> flag on it. </span><span class="kobospan" id="kobo.329.2">Follow </span><span><span class="kobospan" id="kobo.330.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.331.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.332.1">src/app/api/v1/posts/route.js</span></strong><span class="kobospan" id="kobo.333.1"> and add the </span><span><span class="kobospan" id="kobo.334.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.335.1">
export const dynamic = 'force-dynamic'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.336.1">Quit the currently running </span><span><span class="kobospan" id="kobo.337.1">Next.js server.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.338.1">Build the Next.js app for production and start it, </span><span><span class="kobospan" id="kobo.339.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.340.1">$ npm run build</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.341.1">$ npm start</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.342.1">Refresh the page on </span><strong class="source-inline1"><span class="kobospan" id="kobo.343.1">http://localhost:3000/api/v1/posts</span></strong><span class="kobospan" id="kobo.344.1"> a couple of times. </span><span class="kobospan" id="kobo.344.2">Now, the API route behaves the same way as it did on the </span><span><span class="kobospan" id="kobo.345.1">development </span></span><span><a id="_idIndexMarker989" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.346.1">server!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.347.1">Unfortunately, we now have completely disabled the cache, so we also don’t get any of the benefits of using a cache. </span><span class="kobospan" id="kobo.347.2">Next, we’ll learn how to turn on the cache for </span><span><span class="kobospan" id="kobo.348.1">specific functions.</span></span></p>
<h2 id="_idParaDest-326" class="calibre7"><a id="_idTextAnchor329" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.349.1">Caching functions in the data layer</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.350.1">To cache functions</span><a id="_idIndexMarker990" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.351.1"> from our data layer, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.352.1">unstable_cache()</span></strong><span class="kobospan" id="kobo.353.1"> function</span><a id="_idIndexMarker991" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.354.1"> from Next.js. </span><span class="kobospan" id="kobo.354.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.355.1">unstable_cache(fetchData, keyParts, options)</span></strong><span class="kobospan" id="kobo.356.1"> function accepts </span><span><span class="kobospan" id="kobo.357.1">three arguments:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.358.1">fetchData</span></strong><span class="kobospan" id="kobo.359.1">: The first argument is the function to be called. </span><span class="kobospan" id="kobo.359.2">The function can also </span><span><span class="kobospan" id="kobo.360.1">have arguments.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.361.1">keyParts</span></strong><span class="kobospan" id="kobo.362.1">: The second argument is an array of unique keys that identify the function in the cache. </span><span class="kobospan" id="kobo.362.2">Arguments that are passed to the function in the first argument will automatically be added to this array </span><span><span class="kobospan" id="kobo.363.1">as well.</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.364.1">options</span></strong><span class="kobospan" id="kobo.365.1">: The third argument is an object containing options for the cache, where we can specify </span><strong class="source-inline1"><span class="kobospan" id="kobo.366.1">tags</span></strong><span class="kobospan" id="kobo.367.1"> to revalidate the cache later, and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">revalidate</span></strong><span class="kobospan" id="kobo.369.1"> timeout to automatically revalidate the cache after a certain number </span><span><span class="kobospan" id="kobo.370.1">of seconds.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.371.1">Now, let’s enable this cache for all functions where it makes sense. </span><span class="kobospan" id="kobo.371.2">Follow these steps to </span><span><span class="kobospan" id="kobo.372.1">get started:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.373.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.374.1">src/data/posts.js</span></strong><span class="kobospan" id="kobo.375.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.376.1">unstable_cache()</span></strong><span class="kobospan" id="kobo.377.1"> function, aliasing it </span><span><span class="kobospan" id="kobo.378.1">as </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.379.1">cache()</span></strong></span><span><span class="kobospan" id="kobo.380.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.381.1">
import { unstable_cache as cache } from 'next/cache'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.382.1">Wrap the </span><strong class="source-inline1"><span class="kobospan" id="kobo.383.1">listAllPosts</span></strong><span class="kobospan" id="kobo.384.1"> function with </span><strong class="source-inline1"><span class="kobospan" id="kobo.385.1">cache()</span></strong><span class="kobospan" id="kobo.386.1">, </span><span><span class="kobospan" id="kobo.387.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.388.1">export const listAllPosts = cache(</span></strong><span class="kobospan1" id="kobo.389.1">
  async function listAllPosts() {
    return await Post.find({})
      .sort({ createdAt: 'descending' })
      .populate('author', 'username')
      .lean()
  }</span><strong class="bold1"><span class="kobospan1" id="kobo.390.1">,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.391.1">  ['posts', 'listAllPosts'],</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.392.1">  { tags: ['posts'] },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.393.1">)</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.394.1">As the </span><a id="_idIndexMarker992" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.395.1">cache key, we defined an array containing the</span><a id="_idIndexMarker993" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.396.1"> filename (</span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">posts</span></strong><span class="kobospan" id="kobo.398.1">) and the function name (</span><strong class="source-inline"><span class="kobospan" id="kobo.399.1">listAllPosts</span></strong><span class="kobospan" id="kobo.400.1">) to uniquely identify the function in our data layer. </span><span class="kobospan" id="kobo.400.2">Additionally, we added a </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">posts</span></strong><span class="kobospan" id="kobo.402.1"> tag, which we are going to use later to revalidate the cache when new posts </span><span><span class="kobospan" id="kobo.403.1">are created.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.404.1">Next, wrap the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.405.1">getPostById</span></strong></span><span><span class="kobospan" id="kobo.406.1"> function:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.407.1">export const getPostById = cache(</span></strong><span class="kobospan1" id="kobo.408.1">
  async function getPostById(postId) {
    return await Post.findById(postId).populate('author', 'username').lean()
  }</span><strong class="bold1"><span class="kobospan1" id="kobo.409.1">,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.410.1">  ['posts', 'getPostById'],</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.411.1">)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.412.1">You may notice that there is now an error when getting posts because </span><strong class="source-inline1"><span class="kobospan" id="kobo.413.1">ObjectId</span></strong><span class="kobospan" id="kobo.414.1"> from MongoDB is getting serialized into a string by the cache. </span><span class="kobospan" id="kobo.414.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.415.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.416.1"> and adjust </span><strong class="source-inline1"><span class="kobospan" id="kobo.417.1">propType</span></strong><span class="kobospan" id="kobo.418.1">, </span><span><span class="kobospan" id="kobo.419.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.420.1">
Post.propTypes = {
  _id: PropTypes.</span><strong class="bold1"><span class="kobospan1" id="kobo.421.1">string</span></strong><span class="kobospan1" id="kobo.422.1">.isRequired,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.423.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.424.1">src/data/users.js</span></strong><span class="kobospan" id="kobo.425.1"> and import </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.426.1">unstable_cache</span></strong></span><span><span class="kobospan" id="kobo.427.1"> there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.428.1">
import { unstable_cache as cache } from 'next/cache'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.429.1">Wrap the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.430.1">getUserInfoById</span></strong></span><span><span class="kobospan" id="kobo.431.1"> function:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.432.1">export const getUserInfoById = cache(</span></strong><span class="kobospan1" id="kobo.433.1">
  async function getUserInfoById(userId) {
    const user = await User.findById(userId)
    if (!user) throw new Error('user not found!')
    return { username: user.username }
  }</span><strong class="bold1"><span class="kobospan1" id="kobo.434.1">,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.435.1">  ['users', 'getUserInfoById'],</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.436.1">)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.437.1">Quit the currently running </span><span><span class="kobospan" id="kobo.438.1">Next.js server.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.439.1">Rebuild and start the app in production. </span><span class="kobospan" id="kobo.439.2">You will notice that after creating a new post, it does not update the home page (or the API </span><span><span class="kobospan" id="kobo.440.1">route) anymore:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.441.1">$ npm run build</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.442.1">$ npm start</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.443.1">That’s because our posts are </span><span><span class="kobospan" id="kobo.444.1">now cached!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.445.1">This cache even works in dev mode. </span><span class="kobospan" id="kobo.445.2">Quit the Next.js server and start it again, </span><span><span class="kobospan" id="kobo.446.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.447.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.448.1">Create </span><a id="_idIndexMarker994" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.449.1">a new post; you will see that neither the </span><a id="_idIndexMarker995" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.450.1">home page nor the API route has the newly created post in </span><span><span class="kobospan" id="kobo.451.1">the list.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.452.1">Now that caching has been configured, let’s learn how to deal with revalidating the cache (causing data in the cache to </span><span><span class="kobospan" id="kobo.453.1">be updated).</span></span></p>
<h2 id="_idParaDest-327" class="calibre7"><a id="_idTextAnchor330" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.454.1">Revalidating the cache via Server Actions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.455.1">The best way of</span><a id="_idIndexMarker996" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.456.1"> dealing with stale data is to revalidate the cache </span><a id="_idIndexMarker997" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.457.1">when new data comes in, for example, via Server Actions. </span><span class="kobospan" id="kobo.457.2">To do this, we have </span><span><span class="kobospan" id="kobo.458.1">two options:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.459.1">Revalidating all route segments at a specific path by using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.460.1">revalidatePath</span></strong></span><span><span class="kobospan" id="kobo.461.1"> function</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.462.1">Revalidating with a specific tag (and thus potentially revalidating multiple paths) by using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">revalidateTag</span></strong></span><span><span class="kobospan" id="kobo.464.1"> function</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.465.1">Revalidation means that the next time data is requested from the cached function, the function will be called, and new data will be returned and cached (instead of returning previously cached data). </span><span class="kobospan" id="kobo.465.2">Both functions revalidate the data cache and thus revalidate the full router cache and the client-side router cache </span><span><span class="kobospan" id="kobo.466.1">as well.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.467.1">Follow these steps to call the </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">revalidateTag</span></strong><span class="kobospan" id="kobo.469.1"> function after creating </span><span><span class="kobospan" id="kobo.470.1">new posts:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.471.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.472.1">src/app/create/page.js</span></strong><span class="kobospan" id="kobo.473.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.474.1">revalidateTag</span></strong></span><span><span class="kobospan" id="kobo.475.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.476.1">
import { revalidateTag } from 'next/cache'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.477.1">Inside </span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">createPostAction</span></strong><span class="kobospan" id="kobo.479.1">, call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">revalidateTag</span></strong><span class="kobospan" id="kobo.481.1"> function on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.482.1">posts</span></strong><span class="kobospan" id="kobo.483.1"> tag after creating the </span><span><span class="kobospan" id="kobo.484.1">new post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.485.1">
  async function createPostAction(formData) {
    'use server'
    const userId = getUserIdByToken(token?.value)
    await initDatabase()
    const post = await createPost(userId, {
      title: formData.get('title'),
      contents: formData.get('contents'),
    })
</span><strong class="bold1"><span class="kobospan1" id="kobo.486.1">    revalidateTag('posts')</span></strong><span class="kobospan1" id="kobo.487.1">
    redirect(`/posts/${post._id}`)
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.488.1">Now, create a </span><a id="_idIndexMarker998" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.489.1">new post and go to the home page. </span><span class="kobospan" id="kobo.489.2">You </span><a id="_idIndexMarker999" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.490.1">will see that the newly created post appears in the list! </span><span class="kobospan" id="kobo.490.2">The API route will also show the newly created </span><span><span class="kobospan" id="kobo.491.1">post now.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.492.1">Revalidating the cache when data is changed via Server Actions is the most direct way of updating the cache. </span><span class="kobospan" id="kobo.492.2">However, sometimes, we will be fetching data from third-party APIs, where revalidating is not possible. </span><span class="kobospan" id="kobo.492.3">We’ll explore this </span><span><span class="kobospan" id="kobo.493.1">case now.</span></span></p>
<h2 id="_idParaDest-328" class="calibre7"><a id="_idTextAnchor331" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.494.1">Revalidating the cache via a Webhook</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">If the data comes from a</span><a id="_idIndexMarker1000" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.496.1"> third-party source, we can revalidate the cache via a </span><a id="_idIndexMarker1001" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.497.1">Webhook. </span><span class="kobospan" id="kobo.497.2">Webhooks are APIs that can be used as callbacks. </span><span class="kobospan" id="kobo.497.3">For example, when data changes, the third-party source calls our API endpoint to let us know that we need to re-fetch </span><span><span class="kobospan" id="kobo.498.1">the data.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.499.1">Integrating a third-party API</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">Before we can start</span><a id="_idIndexMarker1002" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.501.1"> implementing a Webhook, let’s integrate a third-party API into our app. </span><span class="kobospan" id="kobo.501.2">For this example, we are going to use the WorldTimeAPI (</span><a href="https://worldtimeapi.org/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.502.1">https://worldtimeapi.org/</span></a><span class="kobospan" id="kobo.503.1">), but feel free to use any API of </span><span><span class="kobospan" id="kobo.504.1">your choice.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.505.1">Let’s start implementing a page that fetches from a </span><span><span class="kobospan" id="kobo.506.1">third-party API:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.507.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.508.1">src/app/time/</span></strong><span class="kobospan" id="kobo.509.1"> folder. </span><span class="kobospan" id="kobo.509.2">Inside it, create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.510.1">src/app/time/page.js</span></strong></span><span><span class="kobospan" id="kobo.511.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.512.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.513.1">src/app/time/page.js</span></strong><span class="kobospan" id="kobo.514.1"> and define an asynchronous </span><span><span class="kobospan" id="kobo.515.1">page component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.516.1">
export default async function TimePage() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.517.1">Inside the component, fetch the current time from the WorldTimeAPI and parse the response </span><span><span class="kobospan" id="kobo.518.1">as JSON:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.519.1">
  const timeRequest = await fetch('https://worldtimeapi.org/api/timezone/UTC')
  const time = await timeRequest.json()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.520.1">Render the </span><span><span class="kobospan" id="kobo.521.1">current timestamp:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.522.1">
  return &lt;div&gt;Current timestamp: {time?.datetime}&lt;/div&gt;
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.523.1">If you go to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.524.1">http://localhost:3000/time</span></strong><span class="kobospan" id="kobo.525.1"> page in your browser, you will see that it shows the current time. </span><span class="kobospan" id="kobo.525.2">However, when refreshing, the time never updates. </span><span class="kobospan" id="kobo.525.3">That is because requests with </span><strong class="source-inline1"><span class="kobospan" id="kobo.526.1">fetch</span></strong><span class="kobospan" id="kobo.527.1"> are cached by default, similar to </span><a id="_idIndexMarker1003" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.528.1">what happened after we added </span><strong class="source-inline1"><span class="kobospan" id="kobo.529.1">unstable_cache()</span></strong><span class="kobospan" id="kobo.530.1"> to our data </span><span><span class="kobospan" id="kobo.531.1">layer functions.</span></span></li>
</ol>
<h3 class="calibre9"><span class="kobospan" id="kobo.532.1">Implementing the Webhook</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.533.1">Now, let’s </span><a id="_idIndexMarker1004" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.534.1">create a Webhook API endpoint in our app that, when called, revalidates the cache for the </span><span><span class="kobospan" id="kobo.535.1">third-party data:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.536.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.537.1">src/app/api/v1/webhook/</span></strong><span class="kobospan" id="kobo.538.1"> folder. </span><span class="kobospan" id="kobo.538.2">Inside it, create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.539.1">src/app/api/v1/webhook/route.js</span></strong></span><span><span class="kobospan" id="kobo.540.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.541.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.542.1">src/app/api/v1/webhook/route.js</span></strong><span class="kobospan" id="kobo.543.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.544.1">revalidatePath</span></strong></span><span><span class="kobospan" id="kobo.545.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.546.1">
import { revalidatePath } from 'next/cache'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.547.1">Now, define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.548.1">GET</span></strong><span class="kobospan" id="kobo.549.1"> Route Handler that calls </span><strong class="source-inline1"><span class="kobospan" id="kobo.550.1">revalidatePath</span></strong><span class="kobospan" id="kobo.551.1"> on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.552.1">/time</span></strong><span class="kobospan" id="kobo.553.1"> page and then returns a response telling us that it </span><span><span class="kobospan" id="kobo.554.1">was successful:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.555.1">
export async function GET() {
  revalidatePath('/time')
  return Response.json({ ok: true })
}
export const dynamic = 'force-dynamic'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.556.1">Usually, Webhooks are defined as </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">POST</span></strong><span class="kobospan" id="kobo.558.1"> Route Handlers (because they influence the state of the app), but to make it simpler to trigger the Webhook by visiting the page in our browser, we defined it as a </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">GET</span></strong><span class="kobospan" id="kobo.560.1"> Route Handler. </span><span class="kobospan" id="kobo.560.2">A </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">POST</span></strong><span class="kobospan" id="kobo.562.1"> route would opt out of static rendering, but a </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">GET</span></strong><span class="kobospan" id="kobo.564.1"> route does not, so we need to </span><span><span class="kobospan" id="kobo.565.1">specify </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.566.1">force-dynamic</span></strong></span><span><span class="kobospan" id="kobo.567.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.568.1">Visit </span><strong class="source-inline1"><span class="kobospan" id="kobo.569.1">http://localhost:3000/api/v1/webhook</span></strong><span class="kobospan" id="kobo.570.1"> in your browser, then visit </span><strong class="source-inline1"><span class="kobospan" id="kobo.571.1">http://localhost:3000/time</span></strong><span class="kobospan" id="kobo.572.1"> again; you should see that the time has been updated! </span><span class="kobospan" id="kobo.572.2">In the real world, we would be adding our Webhook URL to the interface of the</span><a id="_idIndexMarker1005" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.573.1"> third-party website that provides </span><span><span class="kobospan" id="kobo.574.1">the API.</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.575.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.576.1">Alternatively, we could add a tag to the request by passing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.577.1">next.tags</span></strong><span class="kobospan" id="kobo.578.1"> option in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.579.1">fetch()</span></strong><span class="kobospan" id="kobo.580.1"> function, as follows: </span><strong class="source-inline1"><span class="kobospan" id="kobo.581.1">fetch('https://worldtimeapi.org/api/timezone/UTC', { next: { tags: ['time'] } })</span></strong><span class="kobospan" id="kobo.582.1">. </span><span class="kobospan" id="kobo.582.2">Then, we could revalidate the cache by </span><span><span class="kobospan" id="kobo.583.1">calling </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.584.1">revalidateTag('time')</span></strong></span><span><span class="kobospan" id="kobo.585.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.586.1">As we can see, revalidating the cache using Webhooks works great. </span><span class="kobospan" id="kobo.586.2">However, sometimes, we cannot even add a Webhook to a third-party API. </span><span class="kobospan" id="kobo.586.3">Let’s explore what to do when we have no control over the </span><span><span class="kobospan" id="kobo.587.1">third-party API.</span></span></p>
<h2 id="_idParaDest-329" class="calibre7"><a id="_idTextAnchor332" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.588.1">Revalidating the cache periodically</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.589.1">If we have no control whatsoever </span><a id="_idIndexMarker1006" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.590.1">over the third-party data source, we can tell Next.js to periodically revalidate the cache. </span><span class="kobospan" id="kobo.590.2">Let’s set that </span><span><span class="kobospan" id="kobo.591.1">up now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.592.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.593.1">src/app/time/page.js</span></strong><span class="kobospan" id="kobo.594.1"> and adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">fetch()</span></strong><span class="kobospan" id="kobo.596.1"> function, adding the </span><strong class="source-inline1"><span class="kobospan" id="kobo.597.1">next.revalidate</span></strong><span class="kobospan" id="kobo.598.1"> option </span><span><span class="kobospan" id="kobo.599.1">to it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.600.1">
  const timeRequest = await fetch('https://worldtimeapi.org/api/timezone/UTC'</span><strong class="bold1"><span class="kobospan1" id="kobo.601.1">, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.602.1">    next: { revalidate: 10 },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.603.1">  }</span></strong><span class="kobospan1" id="kobo.604.1">)</span></pre><p class="calibre3"><span class="kobospan" id="kobo.605.1">In this case, we told Next.js to revalidate the data cache the next time the API is requested if at least 10 seconds have passed since the </span><span><span class="kobospan" id="kobo.606.1">last request.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.607.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.608.1">With </span><strong class="source-inline1"><span class="kobospan" id="kobo.609.1">unstable_cache()</span></strong><span class="kobospan" id="kobo.610.1">, we can pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.611.1">revalidate</span></strong><span class="kobospan" id="kobo.612.1"> option in the third argument. </span><span class="kobospan" id="kobo.612.2">For routes and pages, we can specify </span><strong class="source-inline1"><span class="kobospan" id="kobo.613.1">export const revalidate = 10</span></strong><span class="kobospan" id="kobo.614.1">, which will revalidate the </span><span><span class="kobospan" id="kobo.615.1">corresponding route/page.</span></span></p>
<ol class="calibre15">
<li value="2" class="calibre11"><span class="kobospan" id="kobo.616.1">Refresh the </span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">http://localhost:3000/time</span></strong><span class="kobospan" id="kobo.618.1"> page in your browser. </span><span class="kobospan" id="kobo.618.2">You will see the time update. </span><span class="kobospan" id="kobo.618.3">Refresh the page again; the time will not update again. </span><span class="kobospan" id="kobo.618.4">If you</span><a id="_idIndexMarker1007" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.619.1"> refresh after at least 10 seconds, the time will </span><span><span class="kobospan" id="kobo.620.1">update again.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.621.1">Now that we have learned about revalidating the cache periodically, let’s learn about opting out </span><span><span class="kobospan" id="kobo.622.1">of caching.</span></span></p>
<h2 id="_idParaDest-330" class="calibre7"><a id="_idTextAnchor333" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.623.1">Opting out of caching</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.624.1">Sometimes, you may </span><a id="_idIndexMarker1008" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.625.1">want to opt out of caching completely for certain requests. </span><span class="kobospan" id="kobo.625.2">To do this, pass the following option to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.626.1">fetch</span></strong></span><span><span class="kobospan" id="kobo.627.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.628.1">
fetch('&lt;URL&gt;', </span><strong class="bold1"><span class="kobospan1" id="kobo.629.1">{ cache: 'no-store' }</span></strong><span class="kobospan1" id="kobo.630.1">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.631.1">For pages/routes, we can define </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">export const dynamic = 'force-dynamic'</span></strong><span class="kobospan" id="kobo.633.1"> to opt out of the full route cache (the data may still be </span><span><span class="kobospan" id="kobo.634.1">cached though!).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.635.1">Now that we’ve learned how to use the cache in Next.js to optimize our app, let’s learn about SEO </span><span><span class="kobospan" id="kobo.636.1">with Next.js.</span></span></p>
<h1 id="_idParaDest-331" class="calibre5"><a id="_idTextAnchor334" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.637.1">SEO with Next.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.638.1">In </span><a href="B19385_08.xhtml#_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.639.1">Chapter 8</span></em></span></a><span class="kobospan" id="kobo.640.1">, we learned about SEO in </span><a id="_idIndexMarker1009" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.641.1">full-stack apps. </span><span class="kobospan" id="kobo.641.2">Next.js provides functionality for SEO out of the box. </span><span class="kobospan" id="kobo.641.3">Let’s explore this functionality now, starting with adding dynamic titles and </span><span><span class="kobospan" id="kobo.642.1">meta tags.</span></span></p>
<h2 id="_idParaDest-332" class="calibre7"><a id="_idTextAnchor335" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.643.1">Adding dynamic titles and meta tags</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.644.1">In Next.js, we can statically </span><a id="_idIndexMarker1010" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.645.1">define metadata by exporting a </span><a id="_idIndexMarker1011" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.646.1">metadata object from a </span><strong class="source-inline"><span class="kobospan" id="kobo.647.1">page.js</span></strong><span class="kobospan" id="kobo.648.1"> file, or we can dynamically define metadata by exporting a </span><strong class="source-inline"><span class="kobospan" id="kobo.649.1">generateMetadata</span></strong><span class="kobospan" id="kobo.650.1"> function. </span><span class="kobospan" id="kobo.650.2">We have already added static metadata to the root layout, as can be seen </span><span><span class="kobospan" id="kobo.651.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.652.1">src/app/layout.js</span></strong></span><span><span class="kobospan" id="kobo.653.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.654.1">
export const metadata = {
  title: 'Full-Stack Next.js Blog',
  description: 'A blog about React and Next.js',
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.655.1">Now, let’s dynamically generate metadata for our </span><span><span class="kobospan" id="kobo.656.1">post pages:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.657.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.658.1">src/app/posts/[id]/page.js</span></strong><span class="kobospan" id="kobo.659.1"> and define the following function outside of the </span><span><span class="kobospan" id="kobo.660.1">page component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.661.1">
export async function generateMetadata({ params }) {
  const id = params.id</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.662.1">Fetch the post; if it does not exist, </span><span><span class="kobospan" id="kobo.663.1">call </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.664.1">notFound()</span></strong></span><span><span class="kobospan" id="kobo.665.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.666.1">
  const post = await getPostById(id)
  if (!post) notFound()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.667.1">Otherwise, return a title </span><span><span class="kobospan" id="kobo.668.1">and description:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.669.1">
  return {
    title: `${post.title} | Full-Stack Next.js Blog`,
    description: `Written by ${post.author.username}`,
  }
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.670.1">That’s all </span><a id="_idIndexMarker1012" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.671.1">there is to it! </span><span class="kobospan" id="kobo.671.2">Next.js will set the title and </span><a id="_idIndexMarker1013" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.672.1">meta tags appropriately </span><span><span class="kobospan" id="kobo.673.1">for us.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.674.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.675.1">Metadata is inherited from layouts. </span><span class="kobospan" id="kobo.675.2">So, it is possible to define defaults for metadata in the layout and then selectively override it for </span><span><span class="kobospan" id="kobo.676.1">specific pages.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.677.1">Now that we have successfully added a dynamic title and meta tags, let’s continue by creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.678.1">robots.txt</span></strong><span class="kobospan" id="kobo.679.1"> file so that search engines know they are allowed to index our </span><span><span class="kobospan" id="kobo.680.1">blog app.</span></span></p>
<h2 id="_idParaDest-333" class="calibre7"><a id="_idTextAnchor336" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.681.1">Creating a robots.txt file</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.682.1">Next.js has two ways of</span><a id="_idIndexMarker1014" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.683.1"> creating a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">robots.txt</span></strong></span><span><span class="kobospan" id="kobo.685.1"> file:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.686.1">Creating a static </span><strong class="source-inline1"><span class="kobospan" id="kobo.687.1">robots.txt</span></strong><span class="kobospan" id="kobo.688.1"> file </span><span><span class="kobospan" id="kobo.689.1">in </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.690.1">src/app/robots.txt</span></strong></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.691.1">Creating a dynamic </span><strong class="source-inline1"><span class="kobospan" id="kobo.692.1">robots.txt</span></strong><span class="kobospan" id="kobo.693.1"> file by creating a </span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">src/app/robots.js</span></strong><span class="kobospan" id="kobo.695.1"> script, which returns a special object that is turned into a </span><strong class="source-inline1"><span class="kobospan" id="kobo.696.1">robots.txt</span></strong><span class="kobospan" id="kobo.697.1"> file </span><span><span class="kobospan" id="kobo.698.1">by Next.js</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.699.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.700.1">If you need a refresher on what a </span><strong class="source-inline1"><span class="kobospan" id="kobo.701.1">robots.txt</span></strong><span class="kobospan" id="kobo.702.1"> file is and how search engines work, please check out </span><a href="B19385_08.xhtml#_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.703.1">Chapter 8</span></em></span></a><span><span class="kobospan" id="kobo.704.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.705.1">We are only going to create a static </span><strong class="source-inline"><span class="kobospan" id="kobo.706.1">robots.txt</span></strong><span class="kobospan" id="kobo.707.1"> file as there is no need for a dynamic file for now. </span><span class="kobospan" id="kobo.707.2">Follow these steps to </span><span><span class="kobospan" id="kobo.708.1">get started:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.709.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.710.1">src/app/robots.txt</span></strong></span><span><span class="kobospan" id="kobo.711.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.712.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.713.1">src/app/robots.txt</span></strong><span class="kobospan" id="kobo.714.1"> and add the following contents to allow all crawlers to index </span><span><span class="kobospan" id="kobo.715.1">all pages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.716.1">
User-agent: *
Allow: /</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.717.1">Now that we have created a </span><strong class="source-inline"><span class="kobospan" id="kobo.718.1">robots.txt</span></strong><span class="kobospan" id="kobo.719.1"> file, let’s create </span><span><span class="kobospan" id="kobo.720.1">meaningful URLs.</span></span></p>
<h2 id="_idParaDest-334" class="calibre7"><a id="_idTextAnchor337" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.721.1">Creating meaningful URLs (slugs)</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.722.1">Now, we are going to</span><a id="_idIndexMarker1015" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.723.1"> create slugs for our blog posts, similar to what we did in </span><a href="B19385_08.xhtml#_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.724.1">Chapter 8</span></em></span></a><span class="kobospan" id="kobo.725.1">. </span><span class="kobospan" id="kobo.725.2">Let’s </span><span><span class="kobospan" id="kobo.726.1">get started:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.727.1">Rename the </span><strong class="source-inline1"><span class="kobospan" id="kobo.728.1">src/app/posts/[id]/</span></strong><span class="kobospan" id="kobo.729.1"> folder to </span><strong class="source-inline1"><span class="kobospan" id="kobo.730.1">src/app/posts/[...path]/</span></strong><span class="kobospan" id="kobo.731.1">. </span><span class="kobospan" id="kobo.731.2">This turns it into a catch-all route, matching everything that comes </span><span><span class="kobospan" id="kobo.732.1">after </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.733.1">/posts</span></strong></span><span><span class="kobospan" id="kobo.734.1">.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.735.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.736.1">src/app/posts/[...path]/page.js</span></strong><span class="kobospan" id="kobo.737.1"> and adjust the code to get the first part of the URL (the </span><strong class="source-inline1"><span class="kobospan" id="kobo.738.1">id</span></strong><span class="kobospan" id="kobo.739.1"> value) from the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.740.1">path</span></strong></span><span><span class="kobospan" id="kobo.741.1"> param:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.742.1">
export default async function ViewPostPage({ params }) {
  await initDatabase()
</span><strong class="bold1"><span class="kobospan1" id="kobo.743.1">  const [id] = params.path</span></strong><span class="kobospan1" id="kobo.744.1">
  const post = await getPostById(</span><strong class="bold1"><span class="kobospan1" id="kobo.745.1">id</span></strong><span class="kobospan1" id="kobo.746.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.747.1">Also, adjust the code for the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.748.1">generateMetadata</span></strong></span><span><span class="kobospan" id="kobo.749.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.750.1">
export async function generateMetadata({ params }) {
</span><strong class="bold1"><span class="kobospan1" id="kobo.751.1">  const [id] = params.path</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.752.1">With that, our router has been set up to accept an optional slug in </span><span><span class="kobospan" id="kobo.753.1">the URL.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.754.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.755.1">slug</span></strong> <span><span class="kobospan" id="kobo.756.1">npm package:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.757.1">$ npm install slug@8.2.3</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.758.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.759.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.760.1"> and import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.761.1">slug</span></strong></span><span><span class="kobospan" id="kobo.762.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.763.1">
import slug from 'slug'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.764.1">Adjust the link to the blog post by adding the slug, </span><span><span class="kobospan" id="kobo.765.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.766.1">
        &lt;Link href={`/posts/${_id}</span><strong class="bold1"><span class="kobospan1" id="kobo.767.1">/${slug(title)}</span></strong><span class="kobospan1" id="kobo.768.1">`}&gt;{title}&lt;/Link&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.769.1">Open a </span><a id="_idIndexMarker1016" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.770.1">link from the post list; you will see that the URL now contains </span><span><span class="kobospan" id="kobo.771.1">the slug.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.772.1">Now that we’ve made sure our URLs are meaningful, we’ll wrap up this section by creating a sitemap for our </span><span><span class="kobospan" id="kobo.773.1">blog app.</span></span></p>
<h2 id="_idParaDest-335" class="calibre7"><a id="_idTextAnchor338" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.774.1">Creating a sitemap</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.775.1">As we learned </span><a id="_idIndexMarker1017" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.776.1">in </span><a href="B19385_08.xhtml#_idTextAnchor162" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.777.1">Chapter 8</span></em></span></a><span class="kobospan" id="kobo.778.1">, a sitemap contains a list of URLs that are part of an app so that crawlers can easily detect new content and crawl the app more efficiently, making sure that all content on our blog </span><span><span class="kobospan" id="kobo.779.1">is found.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.780.1">Follow these steps to set up a dynamic sitemap </span><span><span class="kobospan" id="kobo.781.1">in Next.js:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.782.1">First, define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.783.1">BASE_URL</span></strong><span class="kobospan" id="kobo.784.1"> for our app as an environment variable. </span><span class="kobospan" id="kobo.784.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.785.1">.env</span></strong><span class="kobospan" id="kobo.786.1"> and add the </span><span><span class="kobospan" id="kobo.787.1">following line:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.788.1">
BASE_URL=http://localhost:3000</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.789.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.790.1">src/app/sitemap.js</span></strong><span class="kobospan" id="kobo.791.1"> file, where we import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.792.1">initDatabase</span></strong><span class="kobospan" id="kobo.793.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.794.1">listAllPosts</span></strong><span class="kobospan" id="kobo.795.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.796.1">slug</span></strong></span><span><span class="kobospan" id="kobo.797.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.798.1">
import { initDatabase } from '@/db/init'
import { listAllPosts } from '@/data/posts'
import slug from 'slug'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.799.1">Define and export a new asynchronous function that will generate </span><span><span class="kobospan" id="kobo.800.1">the sitemap:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.801.1">
export default async function sitemap() {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.802.1">First, we list all the </span><span><span class="kobospan" id="kobo.803.1">static pages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.804.1">
  const staticPages = [
    {
      url: `${process.env.BASE_URL}`,
    },
    {
      url: `${process.env.BASE_URL}/create`,
    },
    {
      url: `${process.env.BASE_URL}/login`,
    },
    {
      url: `${process.env.BASE_URL}/signup`,
    },
    {
      url: `${process.env.BASE_URL}/time`,
    },
  ]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.805.1">Then, we get</span><a id="_idIndexMarker1018" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.806.1"> all the posts from </span><span><span class="kobospan" id="kobo.807.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.808.1">
  await initDatabase()
  const posts = await listAllPosts()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.809.1">Generate an entry for each post by building the URL and adding a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.810.1">lastModified</span></strong></span><span><span class="kobospan" id="kobo.811.1"> timestamp:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.812.1">
  const postsPages = posts.map((post) =&gt; ({
    url: `${process.env.BASE_URL}/posts/${post._id}/${slug(post.title)}`,
    lastModified: post.updatedAt,
  }))</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.813.1">Finally, return </span><strong class="source-inline1"><span class="kobospan" id="kobo.814.1">staticPages</span></strong><span class="kobospan" id="kobo.815.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.816.1">postsPages</span></strong><span class="kobospan" id="kobo.817.1"> in </span><span><span class="kobospan" id="kobo.818.1">an array:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.819.1">
  return [...staticPages, ...postsPages]
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.820.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.821.1">http://localhost:3000/sitemap.xml</span></strong><span class="kobospan" id="kobo.822.1"> in your browser; you will see that</span><a id="_idIndexMarker1019" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.823.1"> Next.js generated the XML for us from the array </span><span><span class="kobospan" id="kobo.824.1">of objects!</span></span></li>
</ol>
<p class="callout-heading"><span class="kobospan" id="kobo.825.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.826.1">It is best practice to add the sitemap to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">robots.txt</span></strong><span class="kobospan" id="kobo.828.1"> file, but we would need to turn it into a dynamic </span><strong class="source-inline1"><span class="kobospan" id="kobo.829.1">robots.js</span></strong><span class="kobospan" id="kobo.830.1"> file so that we can provide the full URL to the sitemap (using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.831.1">BASE_URL</span></strong><span class="kobospan" id="kobo.832.1"> environment variable). </span><span class="kobospan" id="kobo.832.2">Doing this is left as an exercise </span><span><span class="kobospan" id="kobo.833.1">for you.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.834.1">Now that we’ve optimized our blog app for search engines, let’s learn about optimized image and font loading </span><span><span class="kobospan" id="kobo.835.1">in Next.js.</span></span></p>
<h1 id="_idParaDest-336" class="calibre5"><a id="_idTextAnchor339" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.836.1">Optimized image and font loading in Next.js</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.837.1">Loading images and fonts in an optimized way can be tedious, but Next.js makes it very simple by providing the </span><strong class="source-inline"><span class="kobospan" id="kobo.838.1">Font</span></strong><span class="kobospan" id="kobo.839.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.840.1">Image</span></strong></span><span><span class="kobospan" id="kobo.841.1"> components.</span></span></p>
<h2 id="_idParaDest-337" class="calibre7"><a id="_idTextAnchor340" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.842.1">The Font component</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.843.1">Often, you’ll want to use a</span><a id="_idIndexMarker1020" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.844.1"> specific font for your page to make it unique and stand out. </span><span class="kobospan" id="kobo.844.2">If your font is on Google Fonts, you can have Next.js automatically self-host it for you. </span><span class="kobospan" id="kobo.844.3">No requests will be sent to Google by your browser if you use this feature. </span><span class="kobospan" id="kobo.844.4">Additionally, the fonts will be loaded optimally with zero </span><span><span class="kobospan" id="kobo.845.1">layout shift.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.846.1">Let’s find out how Google Fonts can be self-hosted </span><span><span class="kobospan" id="kobo.847.1">with Next.js:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.848.1">We are going to load the </span><strong class="source-inline1"><span class="kobospan" id="kobo.849.1">Inter</span></strong><span class="kobospan" id="kobo.850.1"> font by importing it from </span><strong class="source-inline1"><span class="kobospan" id="kobo.851.1">next/font/google</span></strong><span class="kobospan" id="kobo.852.1">. </span><span class="kobospan" id="kobo.852.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.853.1">src/app/layout.js</span></strong><span class="kobospan" id="kobo.854.1"> and add the </span><span><span class="kobospan" id="kobo.855.1">following import:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.856.1">
import { Inter } from 'next/font/google'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.857.1">Now, load the font, </span><span><span class="kobospan" id="kobo.858.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.859.1">
const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})</span></pre><p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.860.1">Inter</span></strong><span class="kobospan" id="kobo.861.1"> is a variable font, so we don’t need to specify the weight that we want to load. </span><span class="kobospan" id="kobo.861.2">If the font isn’t a variable font, don’t forget to specify the weight. </span><span class="kobospan" id="kobo.861.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.862.1">display: 'swap'</span></strong><span class="kobospan" id="kobo.863.1"> property means that the font gets an extremely small block period to be loaded. </span><span class="kobospan" id="kobo.863.2">If it does not load by then, a fallback font will be used. </span><span class="kobospan" id="kobo.863.3">Once the font has been loaded, it will be </span><span><span class="kobospan" id="kobo.864.1">swapped in.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.865.1">Specify the</span><a id="_idIndexMarker1021" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.866.1"> font in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.867.1">&lt;html&gt;</span></strong><span class="kobospan" id="kobo.868.1"> tag, </span><span><span class="kobospan" id="kobo.869.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.870.1">
    &lt;html lang='en'</span><strong class="bold1"><span class="kobospan1" id="kobo.871.1"> className={inter.className}</span></strong><span class="kobospan1" id="kobo.872.1">&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.873.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.874.1">http://localhost:3000/</span></strong><span class="kobospan" id="kobo.875.1"> in your browser; you will see that our blog app is now using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.876.1">Inter</span></strong><span class="kobospan" id="kobo.877.1"> font! </span><span class="kobospan" id="kobo.877.2">See the following screenshot </span><span><span class="kobospan" id="kobo.878.1">for reference:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer152">
<span class="kobospan" id="kobo.879.1"><img alt="Figure 18.3 – Our blog app rendered with the Inter font" src="image/B19385_18_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.880.1">Figure 18.3 – Our blog app rendered with the Inter font</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.881.1">As you can see, it’s</span><a id="_idIndexMarker1022" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.882.1"> very simple to use self-hosted Google Fonts </span><span><span class="kobospan" id="kobo.883.1">with Next.js!</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.884.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.885.1">If you want to use a font that is not on Google Fonts, use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.886.1">localFont</span></strong><span class="kobospan" id="kobo.887.1"> function from </span><strong class="source-inline1"><span class="kobospan" id="kobo.888.1">next/font/local</span></strong><span class="kobospan" id="kobo.889.1">. </span><span class="kobospan" id="kobo.889.2">This allows you to load a font from a file in your project. </span><span class="kobospan" id="kobo.889.3">For more information on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.890.1">Font</span></strong><span class="kobospan" id="kobo.891.1"> component, check</span><a id="_idIndexMarker1023" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.892.1"> out the Next.js </span><span><span class="kobospan" id="kobo.893.1">docs: </span></span><a href="https://nextjs.org/docs/app/building-your-application/optimizing/fonts" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.894.1">https://nextjs.org/docs/app/building-your-application/optimizing/fonts</span></span></a><span><span class="kobospan" id="kobo.895.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.896.1">Next, we are going to learn about the </span><strong class="source-inline"><span class="kobospan" id="kobo.897.1">Image</span></strong><span class="kobospan" id="kobo.898.1"> component, which allows us to easily load images in an </span><span><span class="kobospan" id="kobo.899.1">optimized way.</span></span></p>
<h2 id="_idParaDest-338" class="calibre7"><a id="_idTextAnchor341" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.900.1">The Image component</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.901.1">Images make up a </span><a id="_idIndexMarker1024" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.902.1">large portion of the download size of your web application, and can thus have a big impact on </span><a id="_idIndexMarker1025" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.903.1">the </span><strong class="bold"><span class="kobospan" id="kobo.904.1">Last Contentful Paint</span></strong><span class="kobospan" id="kobo.905.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.906.1">LCP</span></strong><span class="kobospan" id="kobo.907.1">) performance. </span><span class="kobospan" id="kobo.907.2">Next.js offers the </span><strong class="source-inline"><span class="kobospan" id="kobo.908.1">Image</span></strong><span class="kobospan" id="kobo.909.1"> component, which extends the </span><strong class="source-inline"><span class="kobospan" id="kobo.910.1">&lt;img&gt;</span></strong><span class="kobospan" id="kobo.911.1"> element by doing </span><span><span class="kobospan" id="kobo.912.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.913.1">Automatically serving resized images for each device </span><span><span class="kobospan" id="kobo.914.1">and resolution</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.915.1">Automatically preventing layout shift when images </span><span><span class="kobospan" id="kobo.916.1">are loading</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.917.1">Only loading images when they enter the viewport (“lazy loading”), with optional blurred </span><span><span class="kobospan" id="kobo.918.1">placeholder images</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.919.1">Offering on-demand resizing for images, even if they are </span><span><span class="kobospan" id="kobo.920.1">stored remotely</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.921.1">Using the </span><strong class="source-inline"><span class="kobospan" id="kobo.922.1">Image</span></strong><span class="kobospan" id="kobo.923.1"> component is simple – just import it and load your images as you would with the </span><strong class="source-inline"><span class="kobospan" id="kobo.924.1">&lt;img&gt;</span></strong><span class="kobospan" id="kobo.925.1"> element. </span><span class="kobospan" id="kobo.925.2">Let’s try it </span><span><span class="kobospan" id="kobo.926.1">out now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.927.1">Get an image to be used as a logo for your blog. </span><span class="kobospan" id="kobo.927.2">Any image can be used, but make sure it is a non-vector format (such as PNG). </span><span class="kobospan" id="kobo.927.3">For vector formats, resizing is not necessary, so you will not see </span><span><span class="kobospan" id="kobo.928.1">any effect.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.929.1">Save the image as a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.930.1">src/app/logo.png</span></strong></span><span><span class="kobospan" id="kobo.931.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.932.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.933.1">src/app/layout.js</span></strong><span class="kobospan" id="kobo.934.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.935.1">Image</span></strong><span class="kobospan" id="kobo.936.1"> component and </span><span><span class="kobospan" id="kobo.937.1">the logo:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.938.1">
import Image from 'next/image'
import logo from './logo.png'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.939.1">Above the </span><strong class="source-inline1"><span class="kobospan" id="kobo.940.1">&lt;nav&gt;</span></strong><span class="kobospan" id="kobo.941.1"> element, render the </span><strong class="source-inline1"><span class="kobospan" id="kobo.942.1">&lt;Image&gt;</span></strong><span class="kobospan" id="kobo.943.1"> component, </span><span><span class="kobospan" id="kobo.944.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.945.1">
  return (
    &lt;html lang='en' className={inter.className}&gt;
      &lt;body&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.946.1">        &lt;Image</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.947.1">          src={logo}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.948.1">          alt='Full-Stack Next.js Blog Logo'</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.949.1">          width={500}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.950.1">          height={47}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.951.1">        /&gt;</span></strong><span class="kobospan1" id="kobo.952.1">
        &lt;nav&gt;
          &lt;Navigation username={user?.username} logoutAction={logoutAction} /&gt;
        &lt;/nav&gt;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.953.1">It is important to specify the width and height of the image so that Next.js can infer the correct aspect ratio and prevent layout shift when the image </span><span><span class="kobospan" id="kobo.954.1">loads in.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.955.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.956.1">http://localhost:3000/</span></strong><span class="kobospan" id="kobo.957.1"> in your browser; you will see the logo being displayed </span><a id="_idIndexMarker1026" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.958.1">properly! </span><span class="kobospan" id="kobo.958.2">See the following screenshot </span><span><span class="kobospan" id="kobo.959.1">for reference:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer153">
<span class="kobospan" id="kobo.960.1"><img alt="Figure 18.4 – Using the Image component to display a logo for our blog" src="image/B19385_18_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.961.1">Figure 18.4 – Using the Image component to display a logo for our blog</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.962.1">If you inspect the image in the browser, you will see that it has the </span><strong class="source-inline"><span class="kobospan" id="kobo.963.1">srcset</span></strong><span class="kobospan" id="kobo.964.1"> property with different sizes provided so that the browser can choose which one to load depending on the </span><span><span class="kobospan" id="kobo.965.1">screen resolution.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.966.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.967.1">In this example, we loaded a local image, but the </span><strong class="source-inline1"><span class="kobospan" id="kobo.968.1">Image</span></strong><span class="kobospan" id="kobo.969.1"> component also supports loading images from a remote server, and it will still resize them properly! </span><span class="kobospan" id="kobo.969.2">To use external URLs, allow the remote server by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.970.1">images.remotePatterns</span></strong><span class="kobospan" id="kobo.971.1"> setting in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.972.1">next.config.js</span></strong><span class="kobospan" id="kobo.973.1"> file, then simply pass a URL instead of a local file to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.974.1">Image</span></strong></span><span><span class="kobospan" id="kobo.975.1"> component</span></span><span><span class="kobospan" id="kobo.976.1">.</span></span></p>
<h1 id="_idParaDest-339" class="calibre5"><a id="_idTextAnchor342" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.977.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.978.1">In this chapter, we learned how to define API routes in Next.js. </span><span class="kobospan" id="kobo.978.2">Then, we learned about caching, how to revalidate the cache, and how to opt out of the cache. </span><span class="kobospan" id="kobo.978.3">Next, we learned about SEO in Next.js by adding metadata to our pages, creating meaningful URLs, defining a </span><strong class="source-inline"><span class="kobospan" id="kobo.979.1">robots.txt</span></strong><span class="kobospan" id="kobo.980.1"> file, and generating a sitemap. </span><span class="kobospan" id="kobo.980.2">Finally, we learned about the </span><strong class="source-inline"><span class="kobospan" id="kobo.981.1">Font</span></strong><span class="kobospan" id="kobo.982.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.983.1">Image</span></strong><span class="kobospan" id="kobo.984.1"> components, which allowed us to load fonts and images easily and optimally in </span><span><span class="kobospan" id="kobo.985.1">our app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.986.1">There are still many more features that Next.js offers that we have not covered yet in this book, such as </span><span><span class="kobospan" id="kobo.987.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.988.1">Internationalization</span></strong><span class="kobospan" id="kobo.989.1">: Allows us to configure the process of routing and rendering content for </span><span><span class="kobospan" id="kobo.990.1">multiple languages</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.991.1">Middleware</span></strong><span class="kobospan" id="kobo.992.1">: Allows us to run code before requests are completed, similar to how middleware works </span><span><span class="kobospan" id="kobo.993.1">in Express</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.994.1">Serverless Node.js and Edge runtimes</span></strong><span class="kobospan" id="kobo.995.1">: Allow us to scale our apps even more by not running a full </span><span><span class="kobospan" id="kobo.996.1">Node.js server</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.997.1">Advanced routing</span></strong><span class="kobospan" id="kobo.998.1">: Allows us to model complex routing scenarios, such as parallel routes (displaying two pages </span><span><span class="kobospan" id="kobo.999.1">at once)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1000.1">In the next chapter, </span><a href="B19385_19.xhtml#_idTextAnchor343" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1001.1">Chapter 19</span></em></span></a><span class="kobospan" id="kobo.1002.1">, </span><em class="italic"><span class="kobospan" id="kobo.1003.1">Deploying a Next.js App</span></em><span class="kobospan" id="kobo.1004.1">, we are going to learn how to deploy a Next.js app using Vercel and a custom </span><span><span class="kobospan" id="kobo.1005.1">deployment setup.</span></span></p>
</div>
</body></html>