<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-71"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: Creating Reusable Templates</h1>
			<p>This chapter is where you will really begin to see the power that Gatsby brings to larger sites. You will learn about how we can programmatically create pages using reusable templates and data sourced via GraphQL. By the end of this chapter, you will have created lists of blog posts, blog pages, and tag pages. You'll also understand how to introduce pagination and search functionality to your site.</p>
			<p>All the pages we have created up until now have been single instances, meaning there is only one copy of that page on the site (for example, our index page, of which there will be only one copy ever). But what happens when we consider pages such as blog pages? It would be a very laborious process to create a single instance page for each post. So, instead, we can use <strong class="bold">templates</strong>. A template<a id="_idIndexMarker225"/> is a multi-instance of a page component that is mapped to data. For every node in a GraphQL query, we can create a page using this template and populate it with the data of that node.</p>
			<p>Now that we understand what we mean by templates in Gatsby, let's create our first few templates, and then <strong class="bold">programmatically</strong> create pages with them.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Defining templates</li>
				<li>Creating templates and programmatic page generation</li>
				<li>Search functionality</li>
			</ul>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have completed <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data (from Anywhere!)</em>. You'll get the most out of this chapter if you have a collection of blog posts that we can use to build our pages, ingested into Gatsby. The source doesn't matter – you'll be ready to start this chapter if you can see them in your GraphQL data layer. If you don't have any posts to hand, you can find some placeholder Markdown files that you can ingest in Gatsby here: <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown</a>.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04</a>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">To keep the code snippets at a manageable size, many of the examples in this chapter have styling omitted and comments pointing to code we've already written. To see a fully styled version of these components, please navigate to this book's code repository.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Creating templates and programmatic page generation</h1>
			<p>In this section, we will <a id="_idIndexMarker226"/>programmatically generate pages using templates. We will be creating blog pages, blog list preview pages, and tag pages. To make<a id="_idIndexMarker227"/> all of this <a id="_idIndexMarker228"/>work correctly, it is important to ensure that each node of data that you are ingesting to populate blog pages contains the <a id="_idIndexMarker229"/>following:</p>
			<ul>
				<li><strong class="bold">Title</strong>: The title of the blog post.</li>
				<li><strong class="bold">Description</strong>: A one-line description of what the blog post contains.</li>
				<li><strong class="bold">Date</strong>: The date that the post should be published.</li>
				<li><strong class="bold">Tags</strong>: A list of tags that the blog post is associated with.</li>
				<li><strong class="bold">Body</strong>: The main content of the post.</li>
			</ul>
			<p>If you are sourcing more than one type of content from the same source, it would be a good idea to also include a <strong class="bold">type</strong> field. This will allow you to filter out nodes that don't belong to this type. </p>
			<p>The method for adding these to your nodes will change, depending on the source. However, in the case of Markdown, you could create your posts in the following format:</p>
			<p class="source-code">---</p>
			<p class="source-code">type: Blog</p>
			<p class="source-code">title: My First Hackathon Experience</p>
			<p class="source-code">desc: This post is all about my learnings from my first</p>
			<p class="source-code">  hackathon experience in London.</p>
			<p class="source-code">date: 2020-06-20</p>
			<p class="source-code">tags: [hackathon, webdev, ux]</p>
			<p class="source-code">---</p>
			<p class="source-code"># Body Content</p>
			<p>Here, we <a id="_idIndexMarker230"/>added <strong class="source-inline">title</strong>, <strong class="source-inline">desc</strong>, <strong class="source-inline">date</strong>, and <strong class="source-inline">tags</strong> to <strong class="source-inline">frontmatter</strong>. Our body content would then be everything following <strong class="source-inline">frontmatter</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">I will be querying data from local Markdown files within this chapter. If you are sourcing content from another type of local or a remote source, you can still use all the code except the queries and node field manipulation, which you will have to modify to work with your source. If you are struggling to construct your queries, refer back to <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data (from Anywhere!)</em>.</p>
			<p>Regardless<a id="_idIndexMarker231"/> of your source, you should ensure that your content is populated with the same fields to ensure GraphQL queries for blog-related data are always consistent. </p>
			<p>Now that we have established the necessary blog node data fields, let's create blog post pages using our data.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Blog post template</h2>
			<p>In this <a id="_idIndexMarker232"/>section, we will create pages for each blog post we have. We<a id="_idIndexMarker233"/> will be creating and using our first template to do this with the help of the following steps:</p>
			<ol>
				<li>Modify your <strong class="source-inline">gatsby-node.js</strong> file so that it includes the following code:<p class="source-code">const { createFilePath } = require('gatsby-source-</p><p class="source-code"> filesystem');</p><p class="source-code">exports.onCreateNode = ({ node, getNode, actions }) =&gt; {</p><p class="source-code">  const { createNodeField } = actions;</p><p class="source-code">  if (node.internal.type === 'MarkdownRemark') {</p><p class="source-code">    const slug = createFilePath({ node, getNode,</p><p class="source-code">    basePath: 'pages' });</p><p class="source-code">    createNodeField({</p><p class="source-code">      node,</p><p class="source-code">      name: 'slug',</p><p class="source-code">      value: slug,</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">};</p><p>The <strong class="source-inline">onCreateNode</strong> function<a id="_idIndexMarker234"/> is called whenever a new node is created. Using this function, we can transform nodes by adding, removing, or manipulating their fields. In this specific case, we are adding a <strong class="source-inline">slug</strong> field if the node is of the <strong class="source-inline">MarkdownRemark</strong> type. A <strong class="source-inline">slug</strong> is an address for a specific page on our site, so in the case of our blog page, we want every blog post to have a unique <strong class="source-inline">slug</strong> where it <a id="_idIndexMarker235"/>will render on the site. Creating slugs from filenames can be complicated as you need to handle characters that would break URL formatting. Luckily, the <strong class="source-inline">gatsby-source-filesystem</strong> plugin ships with a function called <strong class="source-inline">createFilePath</strong> for creating them.</p></li>
				<li>Verify that each blog page has a <strong class="source-inline">slug</strong> by running your development server and using GraphiQL to explore your nodes. If you are using Markdown, you should find it within the <strong class="source-inline">fields</strong> object on <strong class="source-inline">MarkdownRemark</strong> nodes.</li>
				<li>Create a new folder inside <strong class="source-inline">src</strong> called <strong class="source-inline">templates</strong> to house our page templates.</li>
				<li>Create<a id="_idIndexMarker236"/> a new file inside <strong class="source-inline">templates</strong> called <strong class="source-inline">blog-page.js</strong>. This is the file where we will create our blog page template.</li>
				<li>Add the<a id="_idIndexMarker237"/> following code to the <strong class="source-inline">blog-page.js</strong> file:<p class="source-code">import React from "react";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import TagList from "../components/blog-posts/TagList"</p><p class="source-code">export default function BlogPage() {</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl space-y-4 mx-auto </p><p class="source-code">       py-6 md:py-12 overflow-x-hidden lg:overflow-x-</p><p class="source-code">       visible"&gt;</p><p class="source-code">        &lt;h1 className="text-4xl font-bold"&gt;Blog</p><p class="source-code">          Title&lt;/h1&gt;</p><p class="source-code">        &lt;div className="flex items-center space-x-2"&gt;</p><p class="source-code">          &lt;p className="text-lg opacity-50"&gt;Date&lt;/p&gt;</p><p class="source-code">          &lt;TagList tags={["ux"]} /&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">           Article Body</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p>Here, we are creating the blog post template with a static set of data that we will switch<a id="_idIndexMarker238"/> out for real content shortly. You can see<a id="_idIndexMarker239"/> that we have a heading containing our blog post title. We then follow it with the blog's <strong class="source-inline">Date</strong> and a <strong class="source-inline">TagList</strong> component, which we will make shortly. Finally, we have the main <strong class="source-inline">Article Body</strong>. </p></li>
				<li>Create a folder inside <strong class="source-inline">src/components</strong> called <strong class="source-inline">blog-posts</strong>, in which we will store any component related to the blog.</li>
				<li>Create a <strong class="source-inline">TagList</strong> component in the <strong class="source-inline">src/components/blog-posts</strong> file. We will use this component whenever we want to render a list of <strong class="source-inline">tag</strong> badges on the screen:<p class="source-code">import React, { Fragment } from "react";</p><p class="source-code">const TagList = ({ tags }) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;Fragment&gt;</p><p class="source-code">      {tags.map((tag) =&gt; (</p><p class="source-code">        &lt;div</p><p class="source-code">          key={tag}</p><p class="source-code">          className="rounded-full px-2 py-1 uppercase</p><p class="source-code">            text-xs bg-blue-600 text-white"</p><p class="source-code">        &gt;</p><p class="source-code">          &lt;p&gt;{tag}&lt;/p&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      ))}</p><p class="source-code">    &lt;/Fragment&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default TagList</p><p>This<a id="_idIndexMarker240"/> component takes in an array of <strong class="source-inline">tags</strong> as a prop, maps over them, and returns a styled <strong class="source-inline">div</strong> containing that <strong class="source-inline">tag</strong>. This is all wrapped<a id="_idIndexMarker241"/> up in a <strong class="source-inline">Fragment</strong> component. By using a <strong class="source-inline">Fragment</strong>, we can avoid enforcing the ordering and positioning of our <strong class="source-inline">tags</strong>, and can instead allow the parent element to decide.</p><p>Now that we have created a template file and its components, we can use it within our <strong class="source-inline">gatsby-node.js</strong> file.</p></li>
				<li>Add the following code to the top of your <strong class="source-inline">gatsby-node.js</strong> file:<p class="source-code"><strong class="bold">const path = require('path');</strong></p><p class="source-code">const { createFilePath } = require('gatsby-source-</p><p class="source-code">  filesystem');</p><p class="source-code"><strong class="bold">exports.createPages = async ({ actions, graphql,</strong></p><p class="source-code"><strong class="bold">  reporter }) =&gt; {</strong></p><p class="source-code"><strong class="bold">  const { createPage } = actions;</strong></p><p class="source-code"><strong class="bold">  const BlogPostTemplate =</strong></p><p class="source-code"><strong class="bold">    path.resolve('./src/templates/blog-page.js');</strong></p><p class="source-code"><strong class="bold">  const BlogPostQuery = await graphql('</strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">      allMarkdownRemark(filter: { frontmatter: { type:</strong></p><p class="source-code"><strong class="bold">        { eq: "Blog" } } }) {</strong></p><p class="source-code"><strong class="bold">        nodes {</strong></p><p class="source-code"><strong class="bold">          fields {</strong></p><p class="source-code"><strong class="bold">            slug</strong></p><p class="source-code"><strong class="bold">          }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  ');</strong></p><p class="source-code"><strong class="bold">  if (BlogPostQuery.errors) {</strong></p><p class="source-code"><strong class="bold">    reporter.panicOnBuild('Error while running GraphQL</strong></p><p class="source-code"><strong class="bold">      query.');</strong></p><p class="source-code"><strong class="bold">    return;</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold">  BlogPostQuery.data.allMarkdownRemark.nodes.forEach(({ </strong></p><p class="source-code"><strong class="bold">  fields: { slug } }) =&gt; {</strong></p><p class="source-code"><strong class="bold">    createPage({</strong></p><p class="source-code"><strong class="bold">      path: 'blog${slug}',</strong></p><p class="source-code"><strong class="bold">      component: BlogPostTemplate,</strong></p><p class="source-code"><strong class="bold">      context: {</strong></p><p class="source-code"><strong class="bold">        slug: slug,</strong></p><p class="source-code"><strong class="bold">      },</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
				<li>Here, we are utilizing the <strong class="source-inline">createPages</strong> function, which allows us to create pages dynamically. To ensure you can query all your data, this function is only run once all your data has been sourced. Inside this function, we first destructure the <strong class="source-inline">actions</strong> object to retrieve the <strong class="source-inline">createPage</strong> function.  Then, we tell Gatsby where to find our blog post template. With these two pieces in place, we are now ready to query our data. You should see a familiar GraphQL query for <a id="_idIndexMarker242"/>selecting the <strong class="source-inline">slug</strong> from all the Markdown where the type is <em class="italic">Blog</em>. We then have a small <strong class="source-inline">if</strong> statement to catch errors but, assuming it's successful, we then have all the data we need to create pages. We<a id="_idIndexMarker243"/> can loop through the result of our data and loop through every data node, creating a page for each one by specifying a path (using <strong class="source-inline">slug</strong>) and our template. You'll also notice that we are defining some <strong class="source-inline">context</strong> here. Data that's defined in <strong class="source-inline">context</strong> is available in page queries as GraphQL variables, which will make it easy to map the correct Markdown content to the correct pages in the following steps. Restart your development server and open the development 404 page by navigating to any non-existent route on the port. This will display a list of pages on your site, including the pages we have just created. Clicking on one should render the static content we defined when creating the template. Now that these pages have been created successfully, let's navigate back to the template and modify it to retrieve the correct content instead of the static content.</li>
				<li>Modify the <strong class="source-inline">src/templates/blog-post.js</strong> file with the following code:<p class="source-code">import React from "react";</p><p class="source-code"><strong class="bold">import { graphql } from "gatsby";</strong></p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import TagList from "../components/blog-posts/TagList"</p><p class="source-code">export default function BlogPage({<strong class="bold">data</strong>}) {</p><p class="source-code">  <strong class="bold">const {blogpost: {frontmatter: {date, tags, title},</strong></p><p class="source-code"><strong class="bold">    html}} = data</strong></p><p class="source-code">  <strong class="bold">const shortDate = date.split("T")[0]</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl space-y-4 mx-auto </p><p class="source-code">       py-6 md:py-12 overflow-x-hidden lg:overflow-x-</p><p class="source-code">       visible"&gt;</p><p class="source-code">        &lt;h1 className="text-4xl font-</p><p class="source-code">         bold"&gt;{<strong class="bold">title</strong>}&lt;/h1&gt;</p><p class="source-code">        &lt;div className="flex items-center space-x-2"&gt;</p><p class="source-code">            &lt;p className="text-lg opacity-</p><p class="source-code">              50"&gt;{<strong class="bold">shortDate</strong>}&lt;/p&gt;</p><p class="source-code">        &lt;TagList tags={tags} /&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code"><strong class="bold">        &lt;div className="prose max-w-5xl"</strong></p><p class="source-code"><strong class="bold">         dangerouslySetInnerHTML={{__html:html}}/&gt;</strong></p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code"><strong class="bold">export const pageQuery = graphql'</strong></p><p class="source-code"><strong class="bold">query($slug: String!) {</strong></p><p class="source-code"><strong class="bold">    blogpost: markdownRemark(fields: {slug: {eq:</strong></p><p class="source-code"><strong class="bold">      $slug}}) {</strong></p><p class="source-code"><strong class="bold">        frontmatter {</strong></p><p class="source-code"><strong class="bold">          date</strong></p><p class="source-code"><strong class="bold">          title</strong></p><p class="source-code"><strong class="bold">          tags</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">        html</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    }'</strong></p><p>You will <a id="_idIndexMarker244"/>see that our template has a page query appended to it; this is where the <strong class="source-inline">slug</strong> property we defined in the <strong class="source-inline">gatsby-node.js</strong> file comes in handy. We can use that <strong class="source-inline">slug</strong> to find the blog post where <strong class="source-inline">slug</strong> matches in the node's fields. We query for all the data that we need to populate<a id="_idIndexMarker245"/> this page with and retrieve <strong class="source-inline">date</strong>, <strong class="source-inline">title</strong>, <strong class="source-inline">tags</strong>, and the Markdown HTML. This is then passed into the template via the <strong class="source-inline">data</strong> prop, exactly like in our single instance pages. We can then use this content to swap out the static placeholder content we had previously.</p></li>
				<li>By restarting your development server and navigating to one of your blog pages again, you should now see it populated with its node data. You've successfully made your first programmatic pages!<p>As we only have a few blog posts, creating all of these pages won't take very long. However, what happens if you have thousands of pages to create? Instead of waiting for all your site pages to build, you can instruct Gatsby to defer the generation of some of these pages. You can do this by passing <strong class="source-inline">defer:true</strong> to the <strong class="source-inline">createPage</strong> function in <strong class="source-inline">gatsby-node.js</strong>, like so:</p><p class="source-code">  createPage({</p><p class="source-code">      path: 'blog${slug}',</p><p class="source-code">      component: BlogPostTemplate,</p><p class="source-code">      defer: true,</p><p class="source-code">      context: {</p><p class="source-code">        slug: slug,</p><p class="source-code">      },</p><p class="source-code">    });</p><p>With this change, any page that's created in this way will be built the first time that that<a id="_idIndexMarker246"/> page is requested instead of at build time. This <a id="_idIndexMarker247"/>feature changes the kind of build from a static build to a hybrid build. For more information on this difference, please read <a href="B15983_09_ePub_RK.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Hosting</em>.</p></li>
			</ol>
			<p>Now that we have created blog post pages, we must have some way of linking to them from our other pages. Let's create a blog preview template page, where we can have a list of our blog posts with previews and a link to the pages we have just created. </p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Blog preview template</h2>
			<p>While we <a id="_idIndexMarker248"/>could create a single list of blog posts and <a id="_idIndexMarker249"/>render it, it is a standard pattern for websites to divide lists of blog posts, articles, and products using <strong class="bold">pagination</strong>. Using pagination within your site has three<a id="_idIndexMarker250"/> main benefits:</p>
			<ul>
				<li><strong class="bold">Better page performance</strong>: If every article includes an image in the preview, then with every added item, we are increasing the amount of data we need to transfer to the client significantly. By introducing pagination, the client will only download small segments of data as they browse a group of items. This leads to faster page load times, which is particularly important in areas with low bandwidth.</li>
				<li><strong class="bold">Improved user experience</strong>: Displaying all the content on a single page could overwhelm the user, so instead, we must break down our content into small and manageable chunks. </li>
				<li><strong class="bold">Easier navigation</strong>: If we <a id="_idIndexMarker251"/>render hundreds of products in one continuous list, the user will have no idea how many products are there while scrolling through. By breaking content down into multiple pages with a set quantity of products on each, the user can understand the scale of your content better.</li>
			</ul>
			<p>With<a id="_idIndexMarker252"/> all that<a id="_idIndexMarker253"/> in mind, let's create a paginated blog preview page using a template:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Pagination</strong> component in the <strong class="source-inline">src/components/blog-posts</strong> file:<p class="source-code">import React from "react";</p><p class="source-code">import { Link } from "gatsby";</p><p class="source-code">const Pagination = ({ numPages, currentPage }) =&gt; {</p><p class="source-code"> var pageArray = [];</p><p class="source-code"> for (var i = 1; i &lt;= numPages; i++) pageArray[i] = i;</p><p class="source-code">  return (</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;ul&gt;</p><p class="source-code">        {currentPage !== 1 &amp;&amp; (</p><p class="source-code">          &lt;li&gt;</p><p class="source-code">            &lt;Link to={currentPage === 2 ? '/blog' :</p><p class="source-code">              '/blog/${currentPage - 1}'}&gt;</p><p class="source-code">              Previous</p><p class="source-code">            &lt;/Link&gt;</p><p class="source-code">          &lt;/li&gt;</p><p class="source-code">        )}</p><p class="source-code">        {pageArray.map((pageNum) =&gt; (</p><p class="source-code">          &lt;li key={'pageNum_${pageNum}'} &gt;</p><p class="source-code">            &lt;Link to={pageNum === 1 ? '/blog' :</p><p class="source-code">              '/blog/${pageNum}'}&gt;</p><p class="source-code">              {pageNum}</p><p class="source-code">            &lt;/Link&gt;</p><p class="source-code">          &lt;/li&gt;</p><p class="source-code">        ))}</p><p class="source-code">        {currentPage !== numPages &amp;&amp; (</p><p class="source-code">          &lt;li&gt;</p><p class="source-code">            &lt;Link to={'/blog/${currentPage +</p><p class="source-code">              1}'}&gt;Next&lt;/Link&gt;</p><p class="source-code">          &lt;/li&gt;</p><p class="source-code">        )}</p><p class="source-code">      &lt;/ul&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default Pagination;</p><p>Here, we have created the component that will allow us to access paginated blog <a id="_idIndexMarker254"/>preview pages. The component contains<a id="_idIndexMarker255"/> the number of pages and the current page as props. Using these two pieces of information, we can determine whether a user can navigate forward or back from their current page. How this component works is best explained by seeing how it renders:</p><div id="_idContainer025" class="IMG---Figure"><img src="image/Figure_4.1_B15983.jpg" alt="Figure 4.1 – Pagination component states&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 4.1 – Pagination component states</p><p>In the<a id="_idIndexMarker256"/> first case, the current page is <strong class="bold">1</strong>, so there is<a id="_idIndexMarker257"/> no need to render a <strong class="bold">Previous</strong> button. Instead, we only show the preceding pages and the <strong class="bold">Next</strong> button. In the second case, we are on page <strong class="bold">2</strong>, where the user can navigate both forward and back, and as such, we can render the <strong class="bold">Previous</strong> and <strong class="bold">Next</strong> buttons. In the last case, we are on the last page, so we don't need to render the <strong class="bold">Next</strong> button.  </p></li>
				<li>Create a new template in <strong class="source-inline">src/templates/</strong> called <strong class="source-inline">blog-preview.js</strong> and add the following page query:<p class="source-code">/*</p><p class="source-code">     Space for page component</p><p class="source-code">*/</p><p class="source-code">export const pageQuery = graphql'</p><p class="source-code">  query($skip: Int!, $limit: Int!) {</p><p class="source-code">    blogposts: allMarkdownRemark(</p><p class="source-code">      limit: $limit</p><p class="source-code">      skip: $skip</p><p class="source-code">      filter: { frontmatter: { type: { eq: "Blog" } } }</p><p class="source-code">      sort: { fields: frontmatter___date, order: DESC }</p><p class="source-code">    ) {</p><p class="source-code">      nodes {</p><p class="source-code">        frontmatter {</p><p class="source-code">          date</p><p class="source-code">          title</p><p class="source-code">          tags</p><p class="source-code">          desc</p><p class="source-code">        }</p><p class="source-code">        fields {</p><p class="source-code">          slug</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p>The <a id="_idIndexMarker258"/>query within this file sources data from <strong class="source-inline">allMarkdownRemark</strong> (which I have named <strong class="source-inline">blogposts</strong> in this query). The <strong class="source-inline">blogposts</strong> query retrieves all the Markdown where the <strong class="source-inline">frontmatter</strong> type is <a id="_idIndexMarker259"/>equal to <strong class="source-inline">Blog</strong>. It sorts the collection of posts by descending <strong class="source-inline">date</strong>. Here's where things get interesting – we also provide a <strong class="source-inline">skip</strong> and <strong class="source-inline">limit</strong> to the query. <strong class="source-inline">skip</strong> tells the query how many documents from the collection to skip over, while <strong class="source-inline">limit</strong> tells the query to limit the number of results to that quantity. We will be providing <strong class="source-inline">skip</strong> and <strong class="source-inline">limit</strong> to the page context, as well as <strong class="source-inline">numPages</strong> and <strong class="source-inline">currentPage</strong>, within our <strong class="source-inline">gatsby-config.js</strong> file.</p></li>
				<li>Create <a id="_idIndexMarker260"/>the page component before the query <a id="_idIndexMarker261"/>in the <strong class="source-inline">blog-preview.js</strong> file:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql, Link } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import Pagination from "../components/blog-</p><p class="source-code">  posts/Pagination";</p><p class="source-code">import TagList from "../components/blog-posts/TagList"</p><p class="source-code">export default function BlogPreview({ pageContext,</p><p class="source-code">  data }) {</p><p class="source-code">  const {</p><p class="source-code">    numPages,</p><p class="source-code">    currentPage</p><p class="source-code">  } = pageContext</p><p class="source-code">  const {</p><p class="source-code">    blogposts: { nodes },</p><p class="source-code">  } = data;</p><p class="source-code">  // return statement</p><p class="source-code">}</p><p>As with our other queries, when the query at the end of this file runs, it will provide <strong class="source-inline">data</strong> to our page via the <strong class="source-inline">data</strong> prop. Here, we are destructuring <strong class="source-inline">pageContext</strong> to access <strong class="source-inline">numPages</strong> and <strong class="source-inline">currentPage</strong>. We are also using destructuring <strong class="source-inline">data</strong> to get <strong class="source-inline">nodes</strong> from the <strong class="source-inline">blogposts</strong> query. We will add our render via the <strong class="source-inline">return</strong> statement in the following step.</p></li>
				<li>Create<a id="_idIndexMarker262"/> the <strong class="source-inline">return</strong> statement in this same<a id="_idIndexMarker263"/> file:<p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto space-y-8 py-6</p><p class="source-code">        md:py-12"&gt;</p><p class="source-code">        {nodes.map(</p><p class="source-code">          ({ frontmatter: { date, tags, title, desc },</p><p class="source-code">             fields: { slug } }) =&gt; (</p><p class="source-code">            &lt;div&gt;</p><p class="source-code">              &lt;Link to={'/blog${slug}'}&gt;</p><p class="source-code">                &lt;h2 className="text-2xl font-</p><p class="source-code">                  medium"&gt;{title}&lt;/h2&gt;</p><p class="source-code">                &lt;div className="flex items-center</p><p class="source-code">                  space-x-2"&gt;</p><p class="source-code">                  &lt;p className="text-lg opacity-</p><p class="source-code">                    50"&gt;{date.split("T")[0]}&lt;/p&gt;</p><p class="source-code">                  &lt;TagList tags={tags}/&gt;</p><p class="source-code">                &lt;/div&gt;</p><p class="source-code">                &lt;p&gt;{desc}&lt;/p&gt;</p><p class="source-code">              &lt;/Link&gt;</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">          )</p><p class="source-code">        )}</p><p class="source-code">        &lt;Pagination numPages={numPages}</p><p class="source-code">         currentPage={currentPage} /&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p>We<a id="_idIndexMarker264"/> use <strong class="source-inline">nodes</strong> from the two sources to map <a id="_idIndexMarker265"/>through posts, render a preview of each (making use of the <strong class="source-inline">TagList</strong> component), as well as render our <strong class="source-inline">Pagination</strong> component. Now that we have created our template, we can ingest it into our <strong class="source-inline">gatsby-config.js</strong> file.</p></li>
				<li>Modify your <strong class="source-inline">gatsby-config.js</strong> file's <strong class="source-inline">createPages</strong> function with the following code:<p class="source-code">exports.createPages = async ({ actions, graphql,</p><p class="source-code">  reporter }) =&gt; {</p><p class="source-code">  const { createPage } = actions;</p><p class="source-code">  const BlogPostTemplate =</p><p class="source-code">   path.resolve('./src/templates/blog-page.js');</p><p class="source-code">  <strong class="bold">const BlogPreviewTemplate =</strong></p><p class="source-code"><strong class="bold">   path.resolve('./src/templates/blog-preview.js');</strong></p><p class="source-code">  // BlogPostQuery </p><p class="source-code"><strong class="bold">  const BlogPosts = </strong></p><p class="source-code"><strong class="bold">    BlogPostQuery.data.allMarkdownRemark.nodes;</strong></p><p class="source-code"><strong class="bold">  const postsPerPage = 6;</strong></p><p class="source-code"><strong class="bold">  const numPages = Math.ceil(BlogPosts.length /</strong></p><p class="source-code"><strong class="bold">    postsPerPage);</strong></p><p class="source-code"><strong class="bold">  Array.from({ length: numPages }).forEach((_, i) =&gt; {</strong></p><p class="source-code"><strong class="bold">    createPage({</strong></p><p class="source-code"><strong class="bold">      path: i === 0 ? '/blog' : '/blog/${i + 1}',</strong></p><p class="source-code"><strong class="bold">      component: BlogPreviewTemplate,</strong></p><p class="source-code"><strong class="bold">      context: {</strong></p><p class="source-code"><strong class="bold">        limit: postsPerPage,</strong></p><p class="source-code"><strong class="bold">        skip: i * postsPerPage,</strong></p><p class="source-code"><strong class="bold">        numPages,</strong></p><p class="source-code"><strong class="bold">        currentPage: i + 1,</strong></p><p class="source-code"><strong class="bold">        slug: i === 0 ? '/blog' : '/blog/${i + 1}',</strong></p><p class="source-code"><strong class="bold">      },</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code"><strong class="bold">  // Blog Post Page Creation</strong></p><p class="source-code">  });</p><p class="source-code">  //</p><p class="source-code">};</p><p>First, we <a id="_idIndexMarker266"/>require our new <strong class="source-inline">BlogPreviewTemplate</strong>, then we run our Markdown query as normal. As we will <a id="_idIndexMarker267"/>be now using <strong class="source-inline">BlogPostQuery.data.allMarkdownRemark.nodes</strong> in two places (blog previews and blog post page creation), we can assign it to a constant. We will also assign two more constants – the number of posts per page (<strong class="source-inline">postsPerPage</strong>) and the number of pages (<strong class="source-inline">numPages</strong>) that we will need for pagination. <strong class="source-inline">postsPerPage</strong> specifies how many posts we want on each of our paginated blog post previews. <strong class="source-inline">numPages</strong> calculates how many preview pages are needed by dividing the total number of posts by <strong class="source-inline">postsPerPage</strong> and then rounding up to the nearest whole integer using the <strong class="source-inline">Math.ceil</strong> function. We then create an <strong class="source-inline">Array</strong> with a <strong class="source-inline">length</strong> equal to the number of pages and loop through it using the <strong class="source-inline">forEach</strong> function. For each index (<strong class="source-inline">i</strong>), we use the <strong class="source-inline">createPage</strong> action. We provide this action with the path to where the page should be located, which is <strong class="source-inline">/blog</strong> if <strong class="source-inline">i</strong> is <strong class="source-inline">0</strong> and <strong class="source-inline">/blog/i+1</strong> for anything higher. We also provide <strong class="source-inline">BlogPreviewTemplate</strong> and <strong class="source-inline">context</strong>, which contain <strong class="source-inline">limit</strong> and <strong class="source-inline">skip</strong>, which we utilize on the page.</p></li>
				<li>You<a id="_idIndexMarker268"/> are now ready to start your development <a id="_idIndexMarker269"/>server to verify that pagination is working. You should see your posts in descending date order located at <strong class="source-inline">/blog</strong>. If you have more posts than your <strong class="source-inline">postsPerPage</strong> value, you should also see your <strong class="source-inline">Pagination</strong> component, showing you that there are additional pages and allowing you to navigate there.</li>
			</ol>
			<p>Now that we have implemented a blog preview page, let's use what we have learned to create one more collection of pages – tag pages. </p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>Tag page template</h2>
			<p>As a<a id="_idIndexMarker270"/> user, seeing my posts in date order is not always enough – I <a id="_idIndexMarker271"/>may want to be able to find groups of posts associated with a single topic. Tag pages are pages you navigate to whenever you click on one of a blog post's tags. Navigating to one of these pages, you are presented with a list of posts that are associated with that tag.</p>
			<p>Let's programmatically create tag pages for each tag that's present in our articles:</p>
			<ol>
				<li value="1">Install <strong class="source-inline">lodash</strong>:<p class="source-code">npm i lodash</p><p><strong class="source-inline">lodash</strong> is a JavaScript utility library that we will be using to make tags URL-friendly. Because a single tag might consist of multiple words, we need a way to remove the spaces. While you could create a function yourself to do this, <strong class="source-inline">lodash</strong> has a <strong class="source-inline">.kebabCase()</strong> function that works well for this use case.</p></li>
				<li>Modify the <strong class="source-inline">TagList</strong> component to turn <a id="_idIndexMarker272"/>our <strong class="source-inline">tag</strong> badges<a id="_idIndexMarker273"/> into <strong class="source-inline">Link</strong> components:<p class="source-code">import React, { Fragment } from "react";</p><p class="source-code">import { Link } from "gatsby";</p><p class="source-code">import { kebabCase } from "lodash"</p><p class="source-code">const TagList = ({ tags }) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;Fragment&gt;</p><p class="source-code">      {tags.map((tag) =&gt; (</p><p class="source-code">        &lt;Link key={tag}</p><p class="source-code">           to={'/tags/${kebabCase(tag)}'}&gt;</p><p class="source-code">        &lt;div</p><p class="source-code">          key={tag}</p><p class="source-code">          className="rounded-full px-2 py-1 uppercase</p><p class="source-code">            text-xs bg-blue-600 text-white"</p><p class="source-code">        &gt;</p><p class="source-code">          &lt;p&gt;{tag}&lt;/p&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;/Link&gt;</p><p class="source-code">      ))}</p><p class="source-code">    &lt;/Fragment&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default TagList</p><p>As <strong class="source-inline">Link</strong> components, they need a <strong class="source-inline">to</strong> prop. This prop should point to where your <strong class="source-inline">tag</strong> pages will be created – in our case, <strong class="source-inline">/tags/tag-name</strong> is the location. We can use the <strong class="source-inline">kebabCase</strong> function from <strong class="source-inline">lodash</strong> to ensure that any spaces in tags <a id="_idIndexMarker274"/>are turned into hyphens. </p></li>
				<li>Create<a id="_idIndexMarker275"/> a <strong class="source-inline">tags.js</strong> file in the <strong class="source-inline">src/templates</strong> folder:<p class="source-code">/*</p><p class="source-code">     Space for page component</p><p class="source-code">*/</p><p class="source-code">export const pageQuery = graphql'</p><p class="source-code">  query($tag: String) {</p><p class="source-code">    blogposts: allMarkdownRemark(</p><p class="source-code">      sort: { fields: [frontmatter___date], order:</p><p class="source-code">        DESC }</p><p class="source-code">      filter: { frontmatter: { tags: { in: [$tag] },</p><p class="source-code">        type: { eq: "Blog" } } }</p><p class="source-code">    ) {</p><p class="source-code">      totalCount</p><p class="source-code">      nodes {</p><p class="source-code">        frontmatter {</p><p class="source-code">          date</p><p class="source-code">          title</p><p class="source-code">          tags</p><p class="source-code">          desc</p><p class="source-code">        }</p><p class="source-code">        fields {</p><p class="source-code">          slug</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p></li>
				<li>This component will appear very similar to our previously constructed <strong class="source-inline">blog-preview.js</strong> file in the <em class="italic">Blog preview template</em> section, except for a minor change to the query. In this query, we still source our Markdown content, but this time, we <a id="_idIndexMarker276"/>filter out the posts that do not contain the page's tag.</li>
				<li>Create<a id="_idIndexMarker277"/> the page component before the query in the <strong class="source-inline">tags.js</strong> file:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql, Link } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import TagList from "../components/blog-</p><p class="source-code">  posts/TagList";</p><p class="source-code">export default function Tags({ pageContext, data }) {</p><p class="source-code">  const { tag } = pageContext;</p><p class="source-code">  const {</p><p class="source-code">    blogposts: { nodes },</p><p class="source-code">  } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;p&gt;Posts tagged with "{tag}"&lt;/p&gt;</p><p class="source-code">        {nodes.map(</p><p class="source-code">          ({ frontmatter: { date, tags, title, desc },</p><p class="source-code">             fields: { slug } }) =&gt; (</p><p class="source-code">            &lt;div&gt;</p><p class="source-code">              &lt;Link to={'/blog${slug}'}&gt;</p><p class="source-code">                &lt;h2&gt;{title}&lt;/h2&gt;</p><p class="source-code">                &lt;div&gt;</p><p class="source-code">                  &lt;p&gt;{date.split("T")[0]}&lt;/p&gt;</p><p class="source-code">                  &lt;TagList tags={tags} /&gt;</p><p class="source-code">                &lt;/div&gt;</p><p class="source-code">                &lt;p&gt;{desc}&lt;/p&gt;</p><p class="source-code">              &lt;/Link&gt;</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">          )</p><p class="source-code">        )}</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p>The page<a id="_idIndexMarker278"/> then renders a paragraph containing the tag you are currently filtering posts<a id="_idIndexMarker279"/> with, followed by the filtered list of posts. Each post preview is rendered with its <strong class="source-inline">title</strong>, <strong class="source-inline">date</strong>, description (<strong class="source-inline">desc</strong>), and <strong class="source-inline">tags</strong>, just like in the <strong class="source-inline">blog-preview.js</strong> file. </p><p class="callout-heading">Important Note</p><p class="callout">If you intend to render the same items in the lists of both your <strong class="source-inline">blog-preview.js</strong> and <strong class="source-inline">tags.js</strong> files, then you should probably abstract the item preview component into a separate component. To keep these examples independent, I will not do this here.</p></li>
				<li>Import <strong class="source-inline">lodash</strong> into the top of your <strong class="source-inline">gatsby-config.js</strong> file, next to the other imports:<p class="source-code">const _ = require("lodash");</p><p>We will need to use lodash's <strong class="source-inline">kebabCase</strong> in this file as well.</p></li>
				<li>Add<a id="_idIndexMarker280"/> your tag<a id="_idIndexMarker281"/> template and query to your <strong class="source-inline">gatsby-config.js</strong> files' <strong class="source-inline">createPages</strong> function:<p class="source-code">exports.createPages = async ({ actions, graphql,</p><p class="source-code">   reporter }) =&gt; {</p><p class="source-code">// actions destructure &amp; other templates</p><p class="source-code"><strong class="bold">  const TagsTemplate =</strong></p><p class="source-code"><strong class="bold">    path.resolve('./src/templates/tags.js');</strong></p><p class="source-code">  const BlogPostQuery = await graphql('</p><p class="source-code">  {</p><p class="source-code">    allMarkdownRemark(filter: {frontmatter: {type:</p><p class="source-code">     {eq: "Blog"}}}) {</p><p class="source-code">      nodes {</p><p class="source-code">        fields {</p><p class="source-code">          slug</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">tagsGroup: allMarkdownRemark(filter: {frontmatter:</strong></p><p class="source-code"><strong class="bold">      {type: {eq: "Blog"}}}) {</strong></p><p class="source-code"><strong class="bold">      group(field: frontmatter___tags) {</strong></p><p class="source-code"><strong class="bold">        tag: fieldValue</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }');</p><p class="source-code">// Error Handling, Blog Preview &amp; Blog Post page</p><p class="source-code">   creation</p><p class="source-code"><strong class="bold">  BlogPostQuery.data.tagsGroup.group.forEach((group)</strong></p><p class="source-code"><strong class="bold"> =&gt; {</strong></p><p class="source-code"><strong class="bold">    createPage({</strong></p><p class="source-code"><strong class="bold">      path: 'tags/${_.kebabCase(group.tag)}/',</strong></p><p class="source-code"><strong class="bold">      component: TagsTemplate,</strong></p><p class="source-code"><strong class="bold">      context: {</strong></p><p class="source-code"><strong class="bold">        tag: group.tag,</strong></p><p class="source-code"><strong class="bold">      },</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">};</p><p>First, we<a id="_idIndexMarker282"/> acquire our new <strong class="source-inline">TagsTemplate</strong>. Then, we <a id="_idIndexMarker283"/>append our query with a new query to our Markdown source. This group (which we've named <strong class="source-inline">tagsGroup</strong>) retrieves an array containing every unique <strong class="source-inline">tag</strong> that is within <strong class="source-inline">frontmatter</strong> of our posts. </p><p>We can then use this new data to loop through every <strong class="source-inline">tag</strong> and create a <strong class="source-inline">tag</strong> page for each one. We pass a <strong class="source-inline">path</strong> to each <strong class="source-inline">createPages</strong> function, pointing to <strong class="source-inline">tags/</strong>, followed by the <strong class="source-inline">tag</strong> name that's parsed through the <strong class="source-inline">kebabCase</strong> function. We pass the <strong class="source-inline">component</strong> property we want it to build the page with, which in our case is <strong class="source-inline">TagsTemplate</strong>, at the beginning of this file. You will also notice that we are also passing <strong class="source-inline">tag</strong> to the page's <strong class="source-inline">context</strong> so that the page knows which <strong class="source-inline">tag</strong> it relates to.</p></li>
				<li>You are<a id="_idIndexMarker284"/> now ready to start your development server to verify that the tag pages are <a id="_idIndexMarker285"/>working. Navigate to the development 404 page; you should see a page starting with <strong class="source-inline">tags/</strong> for each tag. Clicking on one of these, you should be presented with our tag page template and a list of blog posts associated with that tag.<p class="callout-heading">Further Exercise</p><p class="callout">We've learned how to paginate blog lists, as well as create tag pages. Why not take this one step further and paginate your tag pages?</p></li>
			</ol>
			<p>With that, we have learned how to programmatically create pages for blog posts, blog lists, and tags. Now, let's turn our attention to how we might create a site search so that as the site expands, finding our blog's content is easier.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Search functionality</h1>
			<p>There are many different ways of integrating a site search. Many options are both hosted and local. For small projects, such as the site we are creating, it's often better to opt for a local index <a id="_idIndexMarker286"/>solution as the number of <a id="_idIndexMarker287"/>pages you are searching through is never that large. This also means that your site search will work in offline scenarios, which can be a real plus.</p>
			<p><strong class="bold">Elasticlunr</strong> (<a href="http://elasticlunr.com/">http://elasticlunr.com/</a>) is a <a id="_idIndexMarker288"/>lightweight full-text search engine <a id="_idIndexMarker289"/>in JavaScript for browser and offline search. Using the <strong class="source-inline">elasticlunr</strong> Gatsby plugin, content is indexed and then made available via GraphQL to <strong class="bold">rehydrate</strong> in an <strong class="source-inline">elasticlunr</strong> index. Search queries can then be made against this index to retrieve page information.</p>
			<p>Let's integrate<a id="_idIndexMarker290"/> a site search using <strong class="source-inline">elasticlunr</strong>: </p>
			<ol>
				<li value="1">Install the <strong class="source-inline">elasticlunr</strong> Gatsby plugin:<p class="source-code">npm install @gatsby-contrib/gatsby-plugin-elasticlunr-</p><p class="source-code">search</p></li>
				<li>Add <a id="_idIndexMarker291"/>the <strong class="source-inline">elasticlunr</strong> plugin to your <strong class="source-inline">gatsby-config.js</strong> plugins array:<p class="source-code">{</p><p class="source-code">      resolve: '@gatsby-contrib/gatsby-plugin-</p><p class="source-code">        elasticlunr-search',</p><p class="source-code">      options: {</p><p class="source-code">        fields: ['title', 'tags', 'desc'],</p><p class="source-code">        resolvers: {</p><p class="source-code">          MarkdownRemark: {</p><p class="source-code">            title: node =&gt; node.frontmatter.title,</p><p class="source-code">            tags: node =&gt; node.frontmatter.tags,</p><p class="source-code">            desc: node =&gt; node.frontmatter.desc,</p><p class="source-code">            path: node =&gt; '/blog'+node.fields.slug,</p><p class="source-code">          },</p><p class="source-code">        },</p><p class="source-code">        filter: (node, getNode) =&gt;</p><p class="source-code">        node.frontmatter.type === "Blog",</p><p class="source-code">      },</p><p class="source-code">    },</p><p>As part of <strong class="source-inline">options</strong>, we provide the plugin with a list of <strong class="source-inline">fields</strong> that we would like to index. Then, we give it a <strong class="source-inline">resolvers</strong> object, which explains how to resolve <strong class="source-inline">fields</strong> for a source. Within our blog posts, we can retrieve <strong class="source-inline">title</strong>, <strong class="source-inline">tags</strong>, and <strong class="source-inline">desc</strong> from <strong class="source-inline">frontmatter</strong>. We can construct <strong class="source-inline">path</strong> with that specific content with a string and the data's <strong class="source-inline">slug</strong>. Finally, we also pass a <strong class="source-inline">filter</strong>. This <strong class="source-inline">filter</strong> tells the plugin to only use nodes where the <strong class="source-inline">frontmatter</strong> type is of the <strong class="source-inline">Blog</strong> type, as it is only our blog pages that we want to be searchable at this moment.</p></li>
				<li>Create<a id="_idIndexMarker292"/> a <strong class="source-inline">Search.js</strong> component<a id="_idIndexMarker293"/> in the <strong class="source-inline">src/layout</strong> folder:<p class="source-code">import React, { useState, useEffect } from "react";</p><p class="source-code">import { Link } from "gatsby";</p><p class="source-code">import { Index } from "elasticlunr";</p><p class="source-code">const Search = ({ searchIndex }) =&gt; {</p><p class="source-code">  const [query, setQuery] = useState("");</p><p class="source-code">  let [index, setIndex] = useState();</p><p class="source-code">  let [results, setResults] = useState([]);</p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    setIndex(Index.load(searchIndex));</p><p class="source-code">  }, [searchIndex]);</p><p class="source-code">};</p><p class="source-code">export default Search</p><p>The <strong class="source-inline">Search</strong> component takes in <strong class="source-inline">searchIndex</strong> as a prop. One of the first things you will notice is a <strong class="source-inline">useEffect</strong> hook that loads the index into a state hook. Once we have loaded in the index, we can query it.</p></li>
				<li>Create a <strong class="source-inline">search</strong> function below <strong class="source-inline">useEffect</strong>:<p class="source-code">const search = (evt) =&gt; {</p><p class="source-code">    const query = evt.target.value;</p><p class="source-code">    setQuery(query);</p><p class="source-code">    setResults(</p><p class="source-code">      index</p><p class="source-code">        .search(query, { expand: query.length &gt; 2 })</p><p class="source-code">        .map(({ ref }) =&gt;</p><p class="source-code">     index.documentStore.getDoc(ref))</p><p class="source-code">    );</p><p class="source-code">  };  </p><p>You will<a id="_idIndexMarker294"/> see that whenever the <strong class="source-inline">search</strong> function is called, we <strong class="source-inline">search</strong> the index using our <strong class="source-inline">query</strong> string. You will notice that we are passing in <strong class="source-inline">expand: query.length &gt; 2</strong> as an option to the <strong class="source-inline">search</strong> function. This tells <strong class="source-inline">elasticlunr</strong> to allow partial matches if <a id="_idIndexMarker295"/>more than two characters have been entered. If you allow partial matches for fewer characters, you will often find that you get an abundance of results that are not related to what the user is looking for. Once we have searched the index, we can <strong class="source-inline">map</strong> over <strong class="source-inline">documentStore</strong> within <strong class="source-inline">index</strong> and return the document results, which are then passed to state via the <strong class="source-inline">useState</strong> hook. </p></li>
				<li>Create the <strong class="source-inline">search</strong> result render function:<p class="source-code">const searchResultSize = 3;</p><p class="source-code">return (</p><p class="source-code">    &lt;div className="relative w-64 text-gray-600"&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        type="search"</p><p class="source-code">        name="search"</p><p class="source-code">        placeholder="Search"</p><p class="source-code">        autoComplete="off"</p><p class="source-code">        aria-label="Search"</p><p class="source-code">        onChange={search}</p><p class="source-code">        value={query}</p><p class="source-code">      /&gt;</p><p class="source-code">      {results.length &gt; 0 &amp;&amp; (</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          {results</p><p class="source-code">            .slice(0, searchResultSize)</p><p class="source-code">            .map(({ title, description, path }) =&gt; (</p><p class="source-code">              &lt;Link key={path} to={path}&gt;</p><p class="source-code">                &lt;p&gt;{title}&lt;/p&gt;</p><p class="source-code">                &lt;p className="text-</p><p class="source-code">                 xs"&gt;{description}&lt;/p&gt;</p><p class="source-code">              &lt;/Link&gt;</p><p class="source-code">            ))}</p><p class="source-code">          {results.length &gt; searchResultSize &amp;&amp; (</p><p class="source-code">            &lt;Link to={'/search?q=${query}'}&gt;</p><p class="source-code">              &lt;p&gt;+ {results.length - searchResultSize}</p><p class="source-code">                more&lt;/p&gt;</p><p class="source-code">            &lt;/Link&gt;</p><p class="source-code">          )}</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      )}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p>We <strong class="source-inline">map</strong> over results from the state using the <strong class="source-inline">results</strong> value from the <strong class="source-inline">useState</strong> hook <a id="_idIndexMarker296"/>and render the results to the screen within our render function. For a slightly better user experience, it's often a good idea to include a <strong class="source-inline">searchResultSize</strong> constant. This value determines the maximum number of results to display. This stops cases where you have hundreds of results and see the overlay run off the page. Instead, if there are more results, we simply indicate to the user how many more results there are.</p></li>
				<li>Modify<a id="_idIndexMarker297"/> your <strong class="source-inline">Header.js</strong> file to retrieve the site index and pass it to your <strong class="source-inline">Search</strong> component:<p class="source-code">import React from "react";</p><p class="source-code">import { Link, <strong class="bold">StaticQuery, graphql</strong> } from "gatsby";</p><p class="source-code">import Search from "./Search";</p><p class="source-code">const Header = () =&gt; (</p><p class="source-code">  &lt;header className="px-2 border-b w-full max-w-7xl</p><p class="source-code">    mx-auto py-4 flex items-center justify-between"&gt;</p><p class="source-code">    &lt;Link to="/"&gt;</p><p class="source-code">      &lt;div className="flex items-center space-x-2</p><p class="source-code">       hover:text-blue-600"&gt;</p><p class="source-code">        &lt;p className="font-bold text-2xl"&gt;Site</p><p class="source-code">          Header&lt;/p&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Link&gt;</p><p class="source-code">   <strong class="bold"> &lt;StaticQuery</strong></p><p class="source-code"><strong class="bold">    query={graphql'</strong></p><p class="source-code"><strong class="bold">      query SearchIndexQuery {</strong></p><p class="source-code"><strong class="bold">        siteSearchIndex {</strong></p><p class="source-code"><strong class="bold">          index</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    '}</strong></p><p class="source-code"><strong class="bold">    render={data =&gt; (</strong></p><p class="source-code"><strong class="bold">      &lt;Search</strong></p><p class="source-code"><strong class="bold">       searchIndex={data.siteSearchIndex.index}/&gt;</strong></p><p class="source-code"><strong class="bold">    )} /&gt;</strong></p><p class="source-code">  &lt;/header&gt;</p><p class="source-code">);</p><p class="source-code">export default Header;</p><p>Because <strong class="source-inline">Header.js</strong> is not a page component, we cannot append the <strong class="source-inline">graphql</strong> query to the end <a id="_idIndexMarker298"/>of the page as <a id="_idIndexMarker299"/>Gatsby is not looking for it. However, we can still locate data with the component by using <strong class="source-inline">StaticQuery</strong>. Static queries differ from page queries as they cannot accept variables like our pages can via page context. In this scenario, that's not a constraint as the search <strong class="source-inline">index</strong> is always static.</p><p><strong class="source-inline">StaticQuery</strong> has two important props – <strong class="source-inline">query</strong> and <strong class="source-inline">render</strong>. <strong class="source-inline">query</strong> accepts a <strong class="source-inline">graphql</strong> query, while <strong class="source-inline">render</strong> tells the component what to render with the data from that query. In this particular instance, we are querying for the elasticlunr <strong class="source-inline">index</strong>, and then rendering our <strong class="source-inline">Search</strong> component using that <strong class="source-inline">data</strong>, passing <strong class="source-inline">index</strong> as a prop.</p></li>
				<li>Now<a id="_idIndexMarker300"/> that we have completed our search functionality, restart your development server. You should see that the header of <a id="_idIndexMarker301"/>our site now contains our <strong class="source-inline">Search</strong> component. Try typing in a few characters and click on one of the results. You should be navigated to the corresponding page.</li>
			</ol>
			<p>By adjusting the resolvers and using the same methodology and tools outlined here, we could add pages of different types to our results to create a true site-wide search. </p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Summary</h1>
			<p>In this chapter, you learned how to programmatically create pages using reusable templates. You should feel confident that you can now create pages using any GraphQL data source. We've implemented a list of blog posts with pagination, blog pages, tag pages, and created a site search for blog posts that even works offline. </p>
			<p>In the next chapter, we will master the art of adding images to our Gatsby site. First, we will learn why importing images is not that simple, before creating images that progressively load in and are performant. </p>
		</div>
	</body></html>