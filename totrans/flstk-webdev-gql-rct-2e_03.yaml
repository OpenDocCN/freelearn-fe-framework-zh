- en: '*Chapter 2*: Setting Up GraphQL with Express.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：使用Express.js设置GraphQL'
- en: The basic setup and prototype for our frontend are now complete. Now, we need
    to get our GraphQL server running to begin implementing the backend. Apollo and
    Express.js are going to be used to build the foundation of our backend.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前端基本设置和原型现在已完成。现在，我们需要启动我们的GraphQL服务器，以便开始实现后端。我们将使用Apollo和Express.js来构建后端的基础。
- en: This chapter will explain the installation process for Express.js, as well as
    the configuration for our GraphQL endpoint. We will quickly go through all the
    essential features of Express.js and the debugging tools for our backend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释Express.js的安装过程以及我们的GraphQL端点的配置。我们将快速浏览Express.js的所有基本功能以及我们后端的调试工具。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Express.js installation and explanation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express.js的安装和说明
- en: Routing in Express.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express.js中的路由
- en: Middleware in Express.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express.js中的中间件
- en: Binding Apollo Server to a GraphQL endpoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Apollo服务器绑定到GraphQL端点
- en: Sending our first GraphQL requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送我们的第一个GraphQL请求
- en: Backend debugging and logging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端调试和日志记录
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02)'
- en: Getting started with Node.js and Express.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Node.js和Express.js
- en: One of the primary goals of this book is to set up a GraphQL API, which is then
    consumed by our React frontend. To accept network requests – especially GraphQL
    requests – we are going to set up a Node.js web server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目标之一是设置一个GraphQL API，然后由我们的React前端消费。为了接受网络请求——特别是GraphQL请求——我们将设置一个Node.js网络服务器。
- en: The most significant competitors in the Node.js web server area are Express.js,
    Koa, and Hapi. In this book, we are going to use Express.js. Most tutorials and
    articles about Apollo rely on it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js网络服务器领域，最显著的竞争对手是Express.js、Koa和Hapi。在这本书中，我们将使用Express.js。大多数关于Apollo的教程和文章都依赖于它。
- en: Express.js is also the most used Node.js web server out there and describes
    itself as a Node.js web framework, offering all the main features needed to build
    web applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js也是目前最常用的Node.js网络服务器，它将自己描述为一个Node.js网络框架，提供了构建Web应用程序所需的所有主要功能。
- en: 'Installing Express.js is easy. We can use `npm` in the same way as we did in
    the previous chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Express.js很简单。我们可以像上一章一样使用`npm`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command adds the latest version of Express to `package.json`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将Express.js的最新版本添加到`package.json`中。
- en: 'In the previous chapter, we created all the JavaScript files directly in the
    `src/client` folder. Now, let''s create a separate folder for our server-side
    code. This separation gives us a tidy directory structure. We can create this
    folder with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们直接在`src/client`文件夹中创建了所有JavaScript文件。现在，让我们为我们的服务器端代码创建一个单独的文件夹。这种分离给我们一个整洁的目录结构。我们可以使用以下命令创建此文件夹：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we can continue configuring Express.js.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续配置Express.js。
- en: Setting up Express.js
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Express.js
- en: As always, we need a root file that's loaded with all the main components to
    combine them into a real application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要一个包含所有主要组件的根文件，以便将它们组合成一个真实的应用程序。
- en: 'Create an `index.js` file in the `server` folder. This file is the starting
    point for the backend. Here''s how we do this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server`文件夹中创建一个`index.js`文件。此文件是后端的起点。以下是我们的操作方法：
- en: 'First, we must import `express` from `node_modules`, which we just installed:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须从`node_modules`导入`express`，这是我们刚刚安装的：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can use `import` here since our backend gets transpiled by Babel. We are
    also going to set up webpack for the server-side code later in [*Chapter 9*](B17337_09_Final_ASB_ePub.xhtml#_idTextAnchor176),
    *Implementing Server-Side Rendering*.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在这里使用`import`，因为我们的后端将被Babel转换。我们还将计划在[*第9章*](B17337_09_Final_ASB_ePub.xhtml#_idTextAnchor176)中设置webpack用于服务器端代码，*实现服务器端渲染*。
- en: 'Next, we must initialize the server with the `express` command. The result
    is stored in the `app` variable. Everything our backend does is executed through
    this object:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用`express`命令初始化服务器。结果存储在`app`变量中。我们后端所做的所有操作都是通过此对象执行的：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we must specify the routes that accept requests. For this straightforward
    introduction, we accept all HTTP `GET` requests that match any path by using the
    `app.get` method. Other HTTP methods can be caught with `app.post` and `app.put`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须指定接受请求的路由。在这个简单的介绍中，我们使用`app.get`方法接受所有匹配任何路径的HTTP `GET`请求。其他HTTP方法可以用`app.post`和`app.put`捕获：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To match all the paths, you can use an asterisk, which generally stands for
    `any` in the programming field, as we did in the preceding `app.get` line.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配所有路径，你可以使用星号，它在编程领域中通常代表`任何`，正如我们在前面的`app.get`行中所做的那样。
- en: The first parameter for all the `app.METHOD` functions is the path to match.
    From here, you can provide an unlimited list of callback functions, which are
    executed one by one. We are going to look at this feature later in the *Routing
    with Express.js* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`app.METHOD`函数的第一个参数是要匹配的路径。从这里，你可以提供无限数量的回调函数，它们将依次执行。我们将在*使用Express.js进行路由*部分中稍后查看此功能。
- en: A callback always receives the client request as the first parameter and the
    response as the second parameter, which the server is going to send. Our first
    callback is going to use the `send` response method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数总是将客户端请求作为第一个参数接收，将响应作为第二个参数，这是服务器将要发送的。我们的第一个回调将使用`send`响应方法。
- en: The `send` function merely sends the HTTP response. It sets the HTTP body as
    specified. So, in our case, the body shows `Hello World!`, while the `send` function
    takes care of all the necessary standard HTTP headers, such as `Content-Length`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`函数仅仅发送HTTP响应。它将HTTP体设置为指定的内容。因此，在我们的例子中，体显示为`Hello World!`，而`send`函数则负责所有必要的标准HTTP头，例如`Content-Length`。'
- en: The last step is to tell Express.js which port the server should listen for
    requests on. In our code, we are using `8000` as the first parameter of `app.listen`.
    You can replace `8000` with any port or URL you want to listen on. The callback
    is executed when the HTTP server is bound to that port and requests can be accepted.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是告诉Express.js服务器应该在哪个端口上监听请求。在我们的代码中，我们使用`app.listen`的第一个参数`8000`。你可以将`8000`替换为你想要监听的任何端口或URL。当HTTP服务器绑定到该端口并且可以接受请求时，将执行回调。
- en: This is the easiest setup we can have for Express.js.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以为Express.js设置的 simplest 配置。
- en: Running Express.js in development
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发中运行Express.js
- en: To launch our server, we have to add a new script to our `package.json` file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的服务器，我们必须在我们的`package.json`文件中添加一个新的脚本。
- en: 'Let''s add the following line to the `scripts` property of the `package.json`
    file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`package.json`文件的`scripts`属性中添加以下行：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we are using a command called `nodemon`. We need to install
    it first:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们正在使用一个名为`nodemon`的命令。我们首先需要安装它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`nodemon` is an excellent tool for running a Node.js application. It can restart
    your server when the source changes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodemon`是一个运行Node.js应用程序的优秀工具。当源代码发生变化时，它可以重新启动你的服务器。'
- en: 'For example, to get the preceding command working, follow these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了使前面的命令生效，请按照以下步骤操作：
- en: 'First, we must install the `@babel/node` package since we are transpiling the
    backend code with Babel using the `--exec babel-node` option. This allows us to
    use the `import` statement:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装`@babel/node`包，因为我们正在使用Babel通过`--exec babel-node`选项转译后端代码。这允许我们使用`import`语句：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Providing the `--watch` option to `nodemon` when following a path or file will
    permanently track the changes on that file or folder and reload the server to
    represent the latest state of your application. The last parameter refers to the
    actual file being the starting execution point for the backend.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`nodemon`跟踪路径或文件时，提供`--watch`选项将永久跟踪该文件或文件夹上的更改，并重新加载服务器以表示应用程序的最新状态。最后一个参数指的是实际文件，它是后端启动执行的起点。
- en: 'Start the server:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, when you go to your browser and enter `http://localhost:8000`, you will
    see the text **Hello World!** from our Express.js callback function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你打开浏览器并输入`http://localhost:8000`时，你将看到来自我们的Express.js回调函数的文本**Hello World!**。
- en: '[*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054), *Connecting
    to the Database*, covers how Express.js routing works in detail.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第3章*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054)，*连接到数据库*，详细介绍了Express.js的路由工作原理。'
- en: Routing in Express.js
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Express.js中的路由
- en: Understanding routing is essential to extending our backend code. In this section,
    we are going to play through some simple routing examples.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 理解路由对于扩展我们的后端代码至关重要。在本节中，我们将通过一些简单的路由示例进行实践。
- en: In general, routing handles how and where an application responds to specific
    endpoints and methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，路由处理应用程序如何以及在哪里响应特定的端点和方法。
- en: In Express.js, one path can respond to different HTTP methods and can have multiple
    handler functions. These handler functions are executed one by one in the order
    they were specified in the code. A path can be a simple string, but also a complex
    regular expression or pattern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express.js中，一个路径可以响应不同的HTTP方法，并且可以有多个处理函数。这些处理函数按照它们在代码中指定的顺序依次执行。路径可以是简单的字符串，也可以是复杂的正则表达式或模式。
- en: When you're using multiple handler functions – either provided as an array or
    as multiple parameters – be sure to pass `next` to every callback function. When
    you call `next`, you hand over the execution from one callback function to the
    next function in the row. These functions can also be middleware. We'll cover
    this in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用多个处理函数时——无论是作为数组提供还是作为多个参数——确保将`next`传递给每个回调函数。当你调用`next`时，你将执行权从当前回调函数传递给行中的下一个函数。这些函数也可以是中间件。我们将在下一节中介绍这一点。
- en: 'Here is a simple example. Replace this with the current `app.get` line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。用当前的`app.get`行替换它：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you refresh your browser, look at the server logs in the Terminal; you
    will see that both `first function` and `second function` are printed. If you
    remove the execution of `next` and try to reload the browser tab, the request
    will time out and only `first function` will be printed. This problem occurs because
    neither `res.send` nor `res.end`, nor any alternative, is called. The second handler
    function is never executed when `next` is not run.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刷新浏览器时，查看终端中的服务器日志；你会看到`first function`和`second function`都被打印出来。如果你移除`next`的执行并尝试重新加载浏览器标签页，请求将超时，只有`first
    function`会被打印出来。这个问题发生是因为没有调用`res.send`、`res.end`或任何替代方法。当不运行`next`时，第二个处理函数永远不会执行。
- en: As we mentioned previously, the **Hello World!** message is nice but not the
    best we can get. In development, it is completely okay for us to run two separate
    servers – one for the frontend and one for the backend.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，**Hello World!**消息很好，但不是我们能得到的最好的。在开发中，运行两个独立的服务器——一个用于前端，一个用于后端——是完全可行的。
- en: Serving our production build
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供我们的生产构建
- en: We can serve our production build of the frontend through Express.js. This approach
    is not great for development purposes but is useful for testing the build process
    and seeing how our live application will act.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过Express.js提供我们的前端生产构建。这种方法对于开发目的来说不是很好，但对于测试构建过程和查看我们的实时应用程序将如何表现是有用的。
- en: 'Again, replace the previous routing example with the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，用以下代码替换之前的路由示例：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `path` module offers many functionalities for working with the directory
    structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`模块提供了许多用于处理目录结构的函数。'
- en: We use the global `__dirname` variable to get our project's root directory.
    The variable holds the path of the current file. Using `path.join` with `../../`
    and `__dirname` gives us the real root of our project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用全局的`__dirname`变量来获取我们的项目根目录。该变量包含当前文件的路径。使用`path.join`与`../../`和`__dirname`一起，我们可以得到我们项目的真实根目录。
- en: Express.js provides the `use` function, which runs a series of commands when
    a given path matches. When executing this function without a path, it is executed
    for every request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js提供了`use`函数，当给定的路径匹配时，它会运行一系列命令。当不指定路径执行此函数时，它会对每个请求执行。
- en: We use this feature to serve our static files (the avatar images) with `express.static`.
    They include `bundle.js` and `bundle.css`, which are created by `npm run client:build`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个特性通过`express.static`来提供我们的静态文件（头像图像），包括`bundle.js`和`bundle.css`，这些文件是通过`npm
    run client:build`创建的。
- en: In our case, first, we pass `'/'` with `express.static` following it. The result
    of this is that all the files and folders in `dist` are served beginning with
    `'/'`. The other paths in the first parameter of `app.use`, such as `'/example'`,
    would lead to our `bundle.js` file being able to be downloaded under `'/example/bundle.js'`
    instead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，首先，我们使用`express.static`跟随`'/'`。这样做的结果是，`dist`目录中的所有文件和文件夹都以`'/'`开头提供服务。`app.use`的第一个参数中的其他路径，例如`'/example'`，会导致我们的`bundle.js`文件能够在`'/example/bundle.js'`下被下载。
- en: For example, all the avatar images are served under `'/uploads/'`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有头像图像都在`'/uploads/'`下提供服务。
- en: We are now prepared to let the client download all the necessary files. The
    initial route for our client is `'/'`, as specified by `app.get`. The response
    to this path is `index.html`. We run `res.sendFile` and the file path to return
    this file – that is all we have to do here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好让客户端下载所有必要的文件。我们客户端的初始路由是 `'/'`，如 `app.get` 所指定。对这个路径的响应是 `index.html`。我们运行
    `res.sendFile` 和返回此文件的文件路径——这就是我们在这里要做的全部。
- en: Be sure to execute `npm run client:build` first. Otherwise, you will receive
    an error message, stating that these files were not found. Furthermore, when running
    `npm run client`, the `dist` folder is deleted, so you must rerun the build process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要先执行 `npm run client:build`。否则，你将收到一个错误消息，指出这些文件未找到。此外，当运行 `npm run client`
    时，`dist` 文件夹将被删除，因此你必须重新运行构建过程。
- en: Refreshing your browser now will present you with the *post* feed and form from
    [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Preparing Your
    Development Environment*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新浏览器将显示来自 [*第 1 章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017)，*准备你的开发环境*
    的 *后* 文件和表单。
- en: The next section focuses on the great functionality of middleware functions
    in Express.js.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将重点介绍 Express.js 中间件函数的强大功能。
- en: Using Express.js middleware
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Express.js 中间件
- en: Express.js provides us with great ways to write efficient backends without duplicating
    code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 提供了编写高效后端的方法，无需重复代码。
- en: Every middleware function receives a request, a response, and `next`. It needs
    to run `next` to pass control to the next handler function. Otherwise, you will
    receive a timeout. Middleware allows us to pre- or post-process the request or
    response object, execute custom code, and much more. Previously, we covered a
    simple example of handling requests in Express.js.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间件函数都会接收到一个请求、一个响应和 `next`。它需要运行 `next` 来将控制权传递给下一个处理函数。否则，你将收到一个超时。中间件允许我们预先或后处理请求或响应对象，执行自定义代码，等等。之前，我们已经介绍了
    Express.js 中处理请求的简单示例。
- en: Express.js can have multiple routes for the same path and HTTP method. The middleware
    can decide which function should be executed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 可以针对同一路径和 HTTP 方法拥有多个路由。中间件可以决定哪个函数应该被执行。
- en: 'The following code is an easy example that shows what can generally be accomplished
    with Express.js. You can test this by replacing the current `app.get` routes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的示例，展示了通常可以用 Express.js 完成的事情。你可以通过替换当前的 `app.get` 路由来测试它。
- en: 'The root path, `''/''`, is used to catch any requests:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根路径 `'/'` 用于捕获任何请求：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we will randomly generate a number with `Math.random` between 1 and 10:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 `Math.random` 在 1 和 10 之间随机生成一个数字：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the number is higher than `5`, we run the `next(''route'')` function to
    skip to the next `app.get` with the same path:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字大于 `5`，我们将运行 `next('route')` 函数跳转到下一个具有相同路径的 `app.get`：
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This route will log `'second'`.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个路由将记录 `'second'`。
- en: 'If the number is lower than `0.5`, we execute the `next` function without any
    parameters and go to the next handler function. This handler will log `''first''`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字小于 `0.5`，我们将不带任何参数执行 `next` 函数，并转到下一个处理函数。这个处理函数将记录 `'first'`：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You do not need to copy this code as it is just an explanatory example. This
    functionality can come in handy when we cover special treatments such as admin
    users and error handling.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要复制此代码，因为这只是一个解释示例。当涉及到特殊处理，如管理员用户和错误处理时，这个功能可能会很有用。
- en: Installing important middleware
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装重要的中间件
- en: 'For our application, we have already used one built-in Express.js middleware:
    `express.static`. Throughout this book, we will continue to install other pieces
    of middleware:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们已经在 Express.js 中使用了一个内置的中间件：`express.static`。在这本书中，我们将继续安装其他中间件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, add the `import` statement for the new packages inside the server''s `index.js`
    file so that all the dependencies are available within the file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在服务器的 `index.js` 文件中添加新包的 `import` 语句，以便在文件中提供所有依赖项：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's see what these packages do and how we can use them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些包的功能以及我们如何使用它们。
- en: Express Helmet
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express Helmet
- en: Helmet is a tool that allows you to set various HTTP headers to secure your
    application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Helmet 是一个工具，允许你设置各种 HTTP 头来保护你的应用程序。
- en: 'We can enable the Express.js Helmet middleware as follows in the server''s
    `index.js` file. Add the following code snippet directly beneath the `app` variable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在服务器的 `index.js` 文件中如下启用 Express.js Helmet 中间件。在 `app` 变量下方直接添加以下代码片段：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are doing multiple things here at once. In the preceding code, we added some
    `X-Powered-By` HTTP header, as well as some other useful things, just by using
    the `helmet()` function in the first line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里同时做了很多事情。在前面的代码中，我们仅通过在第一行使用`helmet()`函数，就添加了一些`X-Powered-By` HTTP头信息，以及一些其他有用的东西。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can look up the default parameters, as well as the other functionalities
    of Helmet, at [https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet).
    Always be conscious when implementing security features and do your best to verify
    your attack protection methods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet)查找默认参数以及Helmet的其他功能。在实现安全功能时，始终保持警觉，并尽你所能验证你的攻击防护方法。
- en: Furthermore, to ensure that no one can inject malicious code, we used the `Content-Security-Policy`
    HTTP header or CSP for short. This header prevents attackers from loading resources
    from external URLs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了确保没有人可以注入恶意代码，我们使用了`Content-Security-Policy` HTTP头信息，简称CSP。这个头信息阻止攻击者从外部URL加载资源。
- en: As you can see, we also specified the `imgSrc` field, which tells our client
    that only images from these URLs should be loaded, including **Amazon Web Services**
    (**AWS**). We will learn how to upload images to it in [*Chapter 7*](B17337_07_Final_ASB_ePub.xhtml#_idTextAnchor154),
    *Handling Image Uploads*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们还指定了`imgSrc`字段，这告诉我们的客户端只有来自这些URL的图片应该被加载，包括**亚马逊网络服务**（**AWS**）。我们将在[*第7章*](B17337_07_Final_ASB_ePub.xhtml#_idTextAnchor154)“处理图片上传”中学习如何将其上传。
- en: You can read more about CSP and how it can make your platform more secure at
    [https://helmetjs.github.io/docs/csp/](https://helmetjs.github.io/docs/csp/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://helmetjs.github.io/docs/csp/](https://helmetjs.github.io/docs/csp/)了解更多关于CSP以及它如何使你的平台更安全的信息。
- en: The last enhancement is to set the `Referrer` HTTP header, but only when making
    requests on the same host. When we're going from domain A to domain B, for example,
    we do not include the referrer, which is the URL the user is coming from. This
    enhancement stops any internal routing or requests from being exposed to the internet.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的增强是设置`Referrer` HTTP头信息，但仅在向同一主机发出请求时。例如，当我们从域名A转到域名B时，我们不包含引用者，即用户来自的URL。这个增强阻止了任何内部路由或请求暴露给互联网。
- en: It is important to initialize Helmet very high in your Express router so that
    all the responses are affected.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Express路由器中非常高地初始化Helmet非常重要，这样所有响应都会受到影响。
- en: Compression with Express.js
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Express.js进行压缩
- en: 'Enabling compression for Express.js saves you and your user bandwidth, and
    this is easy to do. The following code must also be added to the server''s `index.js`
    file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Express.js的压缩可以为你和你的用户节省带宽，而且这很容易做到。以下代码也必须添加到服务器的`index.js`文件中：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This middleware compresses all the responses going through it. Remember to add
    it very high in your routing order so that all the requests are affected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件压缩了所有通过它的响应。请记住，在你的路由顺序中将其添加得非常高，以便所有请求都受到影响。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever you have middleware like this or multiple routes that match the same
    path, you need to check the initialization order. Only the first matching route
    is executed unless you run the `next` command. All the routes that are defined
    afterward will not be executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你都有这样的中间件或多个匹配相同路径的路由，你都需要检查初始化顺序。除非你运行`next`命令，否则只有第一个匹配的路由会被执行。之后定义的所有路由将不会被执行。
- en: CORS in Express.js
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Express.js中的CORS
- en: We want our GraphQL API to be accessible from any website, app, or system. A
    good idea might be to build an app or offer the API to other companies or developers
    so that they can use it. When you're using APIs via Ajax, the main problem is
    that the API needs to send the correct `Access-Control-Allow-Origin` header.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的GraphQL API可以从任何网站、应用或系统中访问。一个不错的想法可能是构建一个应用或向其他公司或开发者提供API，以便他们可以使用它。当你通过Ajax使用API时，主要问题是API需要发送正确的`Access-Control-Allow-Origin`头信息。
- en: For example, if you build the API, publicize it under `https://api.example.com`,
    and try to access it from `https://example.com` without setting the correct header,
    it won't work. The API would need to set at least `example.com` inside the `Access-Control-Allow-Origin`
    header to allow this domain to access its resources. This seems a bit tedious,
    but it makes your API open to cross-site requests, which you should always be
    aware of.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你构建了API，在`https://api.example.com`下进行宣传，并且尝试在不设置正确头信息的情况下从`https://example.com`访问它，那么它将不会工作。API需要在`Access-Control-Allow-Origin`头信息中至少设置`example.com`以允许此域名访问其资源。这看起来有点繁琐，但它使你的API能够接受跨站请求，这一点你应该始终注意。
- en: 'Allow `index.js` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 `index.js` 文件：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command handles all the problems we usually have with cross-origin requests
    at once. It merely sets a wildcard with `*` inside of `Access-Control-Allow-Origin`,
    allowing anyone from anywhere to use your API, at least in the first instance.
    You can always secure your API by offering API keys or by only allowing access
    to logged-in users. Enabling CORS only allows the requesting site to receive the
    response.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令一次性处理了我们通常在跨源请求中遇到的所有问题。它仅仅在 `Access-Control-Allow-Origin` 中设置了一个带有 `*` 的通配符，允许来自任何地方的任何人使用您的
    API，至少在最初是这样。您始终可以通过提供 API 密钥或仅允许已登录用户访问来保护您的 API。启用 CORS 只允许请求网站接收响应。
- en: Furthermore, the command also implements the `OPTIONS` route for the whole application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该命令还实现了整个应用程序的 `OPTIONS` 路由。
- en: The `OPTIONS` method or request is made every time we use `CORS`. This action
    is what's called a `OPTIONS` preflight, the actual method, such as `POST`, will
    not be made by the browser at all.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用 `CORS` 时，都会进行 `OPTIONS` 方法或请求。这个动作被称为 `OPTIONS` 预检，实际的 `POST` 等方法根本不会被浏览器执行。
- en: Our application is now ready to serve all the routes appropriately and respond
    with the right headers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在已准备好适当地服务所有路由并响应正确的头信息。
- en: Now, let's set up a GraphQL server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一个 GraphQL 服务器。
- en: Combining Express.js with Apollo
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合 Express.js 和 Apollo
- en: 'First things first; we need to install the Apollo and GraphQL dependencies:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 Apollo 和 GraphQL 依赖项：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Apollo offers an Express.js-specific package that integrates itself into the
    web server. There is also a standalone version without Express.js. Apollo allows
    you to use the available Express.js middleware. In some scenarios, you may need
    to offer non-GraphQL routes to proprietary clients who do not implement GraphQL
    or are not able to understand JSON responses. There are still reasons to offer
    some fallbacks to GraphQL. In those cases, you can rely on Express.js since you
    are already using it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo 提供了一个特定于 Express.js 的包，该包将其自身集成到 web 服务器中。还有一个没有 Express.js 的独立版本。Apollo
    允许您使用可用的 Express.js 中间件。在某些情况下，您可能需要为不实现 GraphQL 或无法理解 JSON 响应的专有客户端提供非 GraphQL
    路由。仍然有一些原因要提供一些回退到 GraphQL。在这些情况下，您可以依赖 Express.js，因为您已经在使用它了。
- en: 'Create a separate folder for services. A service can be GraphQL or other routes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务创建一个单独的文件夹。一个服务可以是 GraphQL 或其他路由：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an `index.js` file in the `graphql` folder to act as the start point
    for our GraphQL service. It must handle multiple things for initialization. Let''s
    go through all of them one by one and add them to the `index.js` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `graphql` 文件夹中创建一个 `index.js` 文件，作为我们 GraphQL 服务的起点。它必须处理初始化的多项任务。让我们逐个过一遍它们，并将它们添加到
    `index.js` 文件中：
- en: 'First, we must import the `apollo-server-express` and `@graphql-tools/schema`
    packages:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须导入 `apollo-server-express` 和 `@graphql-tools/schema` 包：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we must combine the GraphQL schema with the `resolver` functions. We
    must import the corresponding schema and resolver functions at the top from separate
    files. The GraphQL schema is the representation of the API – that is, the data
    and functions a client can request or run. Resolver functions are the implementation
    of the schema. Both need to match. You cannot return a field or run a mutation
    that is not inside the schema:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须将 GraphQL 模式与 `resolver` 函数结合。我们必须从单独的文件中导入相应的模式和解析函数。GraphQL 模式是 API
    的表示——即客户端可以请求或运行的数据和函数。解析函数是模式的实现。两者都需要匹配。您不能返回不在模式中的字段或运行突变：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `makeExecutableSchema` function of the `@graphql-tools/schema` package
    merges the GraphQL schema and the resolver functions, resolving the data we are
    going to write. The `makeExecutableSchema` function throws an error when you define
    a query or mutation that is not in the schema. The resulting schema is executed
    by our GraphQL server resolving the data or running the mutations we request:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@graphql-tools/schema` 包中的 `makeExecutableSchema` 函数将 GraphQL 模式和解析函数合并，解析我们将要写入的数据。当您定义一个不在模式中的查询或突变时，`makeExecutableSchema`
    函数会抛出一个错误。生成的模式由我们的 GraphQL 服务器执行，解析数据或运行我们请求的突变：'
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We pass this as a `schema` parameter to the Apollo Server. The `context` property
    contains the `request` object of Express.js. In our resolver functions, we can
    access the request if we need to:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其作为 `schema` 参数传递给 Apollo 服务器。`context` 属性包含 Express.js 的 `request` 对象。在我们的解析函数中，如果我们需要，可以访问请求：
- en: '[PRE25]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This `index.js` file exports the initialized server object, which handles all
    GraphQL requests:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此 `index.js` 文件导出初始化的服务器对象，该对象处理所有 GraphQL 请求：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we are exporting the Apollo Server, it needs to be imported somewhere
    else. I find it convenient to have one `index.js` file on the services layer so
    that we only rely on this file if a new service is added.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在导出 Apollo Server，它需要在其他地方导入。我发现，在服务层有一个 `index.js` 文件很方便，这样我们只有在添加新服务时才依赖于这个文件。
- en: 'Create an `index.js` file in the `services` folder and enter the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `services` 文件夹中创建一个 `index.js` 文件，并输入以下代码：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code requires our `index.js` file from the `graphql` folder and
    re-exports all the services into one big object. We can define more services here
    if we need them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码需要从 `graphql` 文件夹中的 `index.js` 文件中导入，并将所有服务重新导出到一个大的对象中。如果我们需要，我们还可以在这里定义更多服务。
- en: To make our GraphQL server publicly accessible to our clients, we are going
    to bind the Apollo Server to the `/graphql` path.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 GraphQL 服务器对客户端公开可用，我们将 Apollo Server 绑定到 `/graphql` 路径。
- en: 'Import the services `index.js` file into the `server/index.js` file, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `index.js` 文件导入到 `server/index.js` 文件中，如下所示：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `services` object only holds the `graphql` index. Now, we must bind the
    GraphQL server to the Express.js web server with the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`services` 对象只包含 `graphql` 的索引。现在，我们必须使用以下代码将 GraphQL 服务器绑定到 Express.js 网络服务器：'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For convenience, we loop through all indexes of the `services` object and use
    the index as the name of the route the service will be bound to. The path would
    be `/example` for the `example` index in the `services` object. For a typical
    service, such as a REST interface, we rely on the standard `app.use` method of
    Express.js.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们遍历 `services` 对象的所有索引，并使用索引作为服务将被绑定的路由的名称。对于 `services` 对象中的 `example`
    索引，路径将是 `/example`。对于一个典型的服务，例如 REST 接口，我们依赖于 Express.js 的标准 `app.use` 方法。
- en: Since the Apollo Server is kind of special, when binding it to Express.js, we
    need to run the `applyMiddleware` function, which is provided by the initialized
    Apollo Server, and avoid using the `app.use` function from Express.js. Apollo
    automatically binds itself to the `/graphql` path because it is the default option.
    You could also include a `path` parameter if you want it to respond from a custom
    route.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Apollo Server 有其特殊性，当将其绑定到 Express.js 时，我们需要运行由初始化的 Apollo Server 提供的 `applyMiddleware`
    函数，并避免使用 Express.js 的 `app.use` 函数。Apollo 会自动将自己绑定到 `/graphql` 路径，因为这是默认选项。如果您希望它从自定义路由响应，也可以包含一个
    `path` 参数。
- en: The Apollo Server requires us to run the `start` command before applying the
    middleware. As this is an asynchronous function, we are wrapping the complete
    block into a wrapping `async` function so that we can use the `await` statement.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server 要求我们在应用中间件之前运行 `start` 命令。由于这是一个异步函数，我们将整个代码块包裹在一个包装的 `async`
    函数中，以便我们可以使用 `await` 语句。
- en: 'Two things are missing now: the schema and the resolvers. Once we''ve done
    that, we will execute some test GraphQL requests. The schema is next on our to-do
    list.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还缺少两件事：模式和解析器。一旦我们完成这些，我们将执行一些测试 GraphQL 请求。模式是我们待办事项列表中的下一个任务。
- en: Writing your first GraphQL schemas
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您的第一个 GraphQL 模式
- en: 'Let''s start by creating a `schema.js` inside the `graphql` folder. You can
    also stitch multiple smaller schemas into one bigger schema. This would be cleaner
    and would make sense when your application, types, and fields grow. For this book,
    one file is okay and we can insert the following code into the `schema.js` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `graphql` 文件夹内创建一个 `schema.js` 文件开始。您也可以将多个较小的模式缝合成一个较大的模式。这样做会更干净，当您的应用程序、类型和字段增长时，这会更有意义。对于这本书，一个文件就足够了，我们可以将以下代码插入到
    `schema.js` 文件中：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code represents a basic schema, which would be able to at least
    serve the fake posts array from [*Chapter 1*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017),
    *Preparing Your Development Environment*, excluding the users.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码代表了一个基本的模式，它至少能够从 [*第 1 章*](B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017)，*准备您的开发环境*，排除用户，提供伪造的帖子数组。
- en: First, we must define a new type called `Post`. A `Post` type has an `id` of
    `Int` and a `text` value of `String`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义一个新的类型，称为 `Post`。`Post` 类型有一个 `id` 为 `Int` 和一个 `text` 值为 `String`。
- en: For our GraphQL server, we need a type called `RootQuery`. The `RootQuery` type
    wraps all of the queries a client can run. It can be anything from requesting
    all posts, all users, posts by just one user, and so on. You can compare this
    to all `GET` requests as you find them with common REST APIs. The paths would
    be `/posts`, `/users`, and `/users/ID/posts` to represent the GraphQL API as a
    REST API. When using GraphQL, we only have one route, and we send the query as
    a JSON-like object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的GraphQL服务器，我们需要一个名为`RootQuery`的类型。`RootQuery`类型封装了客户端可以运行的所有查询。它可以是从请求所有帖子到所有用户，仅一个用户的帖子等等。你可以将其与你在常见REST
    API中找到的所有`GET`请求进行比较。路径将是`/posts`、`/users`和`/users/ID/posts`，以表示GraphQL API作为REST
    API。当使用GraphQL时，我们只有一个路由，并且我们以类似JSON的对象发送查询。
- en: The first query we will have is going to return an array of all of the posts
    we have got.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的第一个查询将返回所有我们拥有的帖子数组。
- en: If we query for all posts and want to return each user with its corresponding
    post, this would be a sub-query that would not be represented in our `RootQuery`
    type but in the `Post` type itself. You will see how this is done later.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查询所有帖子并希望返回每个用户及其对应的帖子，这将是一个子查询，它不会在我们的`RootQuery`类型中表示，而是在`Post`类型本身中。你稍后会看到这是如何实现的。
- en: At the end of the JSON-like schema, we add `RootQuery` to the `schema` property.
    This type is the starting point for the Apollo Server.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似JSON的模式末尾，我们将`RootQuery`添加到`schema`属性中。此类型是Apollo Server的起点。
- en: Later, we are going to add the mutation key to the schema, where we will implement
    a `RootMutation` type. It is going to serve all of the actions a user can run.
    Mutations are comparable to the `POST`, `UPDATE`, `PATCH`, and `DELETE` requests
    of a REST API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将向模式添加mutation键，我们将实现一个`RootMutation`类型。它将服务于用户可以运行的所有操作。突变与REST API的`POST`、`UPDATE`、`PATCH`和`DELETE`请求相当。
- en: At the end of the file, we export the schema as an array. If we wanted to, we
    could push other schemas to this array to merge them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，我们将模式作为一个数组导出。如果我们想的话，我们可以将其他模式推送到这个数组中合并它们。
- en: The last thing that's missing here is the implementation of our resolvers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里缺少的最后一件事情是我们解析器的实现。
- en: Implementing GraphQL resolvers
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现GraphQL解析器
- en: Now that the schema is ready, we need the matching resolver functions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模式已经准备好了，我们需要匹配的解析器函数。
- en: 'Create a `resolvers.js` file in the `graphql` folder, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`graphql`文件夹中创建一个`resolvers.js`文件，如下所示：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `resolvers` object holds all types as a property. Here, we set up `RootQuery`,
    holding the `posts` query in the same way as we did in our schema. The `resolvers`
    object must equal the schema but be recursively merged. If you want to query a
    subfield, such as the user of a post, you have to extend the `resolvers` object
    with a `Post` object containing a `user` function next to `RootQuery`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolvers`对象持有所有类型作为属性。在这里，我们设置了`RootQuery`，以与我们在模式中相同的方式持有`posts`查询。`resolvers`对象必须等于模式，但必须是递归合并的。如果你想查询子字段，例如帖子的用户，你必须通过包含`user`函数的`Post`对象扩展`resolvers`对象，放在`RootQuery`旁边。'
- en: If we send a query for all posts, the `posts` function is executed. There, you
    can do whatever you want, but you need to return something that matches the schema.
    So, if you have an array of `posts` as the response type of `RootQuery`, you cannot
    return something different, such as just one post object instead of an array.
    In that case, you would receive an error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发送查询所有帖子的请求，`posts`函数将被执行。在那里，你可以做任何你想做的事情，但你需要返回与模式匹配的东西。所以，如果你有一个`posts`数组作为`RootQuery`的响应类型，你不能返回不同的东西，比如只返回一个帖子对象而不是数组。在这种情况下，你会收到一个错误。
- en: Furthermore, GraphQL checks the data type of every property. If `id` is defined
    as `Int`, you cannot return a regular MongoDB `id` since these IDs are of the
    `String` type. GraphQL would throw an error too.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GraphQL检查每个属性的 数据类型。如果`id`被定义为`Int`，你不能返回一个常规的MongoDB `id`，因为这些ID是`String`类型。GraphQL也会抛出一个错误。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GraphQL will parse or cast specific data types for you if the value type is
    matching. For example, a `string` with a value of `2.1` is parsed to `Float` without
    any problems. On the other hand, an empty string cannot be converted into a `Float`,
    and an error would be thrown. It is better to directly have the correct data types
    because this saves you from casting and also prevents unwanted problems.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值类型匹配，GraphQL会为你解析或转换特定的数据类型。例如，一个值为`2.1`的`string`可以无问题地解析为`Float`。另一方面，一个空字符串不能转换为`Float`，并且会抛出一个错误。直接拥有正确的数据类型会更好，因为这可以节省你转换，并防止出现不希望的问题。
- en: To prove that everything is working, we will continue by performing a real GraphQL
    request against our server. Our `posts` query will return an empty array, which
    is a correct response for GraphQL. We will come back to the `resolver` functions
    later. You should be able to start the server again so that we can send a demo
    request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明一切正常工作，我们将通过向我们的服务器执行实际的 GraphQL 请求来继续。我们的 `posts` 查询将返回一个空数组，这是 GraphQL
    的正确响应。我们稍后会回到 `resolver` 函数。你应该能够重新启动服务器，这样我们就可以发送一个演示请求。
- en: Sending GraphQL queries
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送 GraphQL 查询
- en: We can test this query using any HTTP client, such as Postman, Insomnia, or
    any you are used to. The next section covers HTTP clients. If you want to send
    the following queries on your own, then you can read the next section and come
    back here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何 HTTP 客户端来测试这个查询，例如 Postman、Insomnia 或你习惯使用的任何客户端。下一节将介绍 HTTP 客户端。如果你想要自己发送以下查询，那么你可以阅读下一节，然后回到这里。
- en: 'You can test our new function when you send the following JSON as a `POST`
    request to `http://localhost:8000/graphql`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将以下 JSON 作为 `POST` 请求发送到 `http://localhost:8000/graphql` 时，你可以测试我们的新函数：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `operationName` field is not required to run a query, but it is great for
    logging purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`operationName` 字段不是运行查询所必需的，但它对于日志记录非常有用。'
- en: The `query` object is a JSON-like representation of the query we want to execute.
    In this example, we run the `RootQuery` posts and request the `id` and `text`
    fields of every post. We do not need to specify `RootQuery` because it is the
    highest layer of our GraphQL API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`query` 对象是我们想要执行的查询的类似 JSON 的表示。在这个例子中，我们运行 `RootQuery` 帖子并请求每个帖子的 `id` 和
    `text` 字段。我们不需要指定 `RootQuery`，因为它是我们 GraphQL API 的最高层。'
- en: The `variables` property can hold parameters such as the user IDs that we want
    to filter the posts by. If you want to use variables, they need to be defined
    in the query by their name too.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables` 属性可以存储我们想要通过它来过滤帖子的用户 ID 等参数。如果你想要使用变量，它们也需要通过它们的名称在查询中定义。'
- en: 'For developers who are not used to tools such as Postman, there is also the
    option to open the `/graphql` endpoint in a separate browser tab. You will be
    presented with a GraphQLi instance that''s made for sending queries easily. Here,
    you can insert the content of the `query` property and hit the play button. Because
    we set up Helmet to secure our application, we need to deactivate it in development.
    Otherwise, the GraphQLi instance is not going to work. Just wrap the complete
    Helmet initialization inside the `server/index.js` file with the following `if`
    statement in curly braces:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不习惯使用 Postman 等工具的开发者，还有一个选项可以在单独的浏览器标签页中打开 `/graphql` 端点。你将看到一个专为轻松发送查询而制作的
    GraphQLi 实例。在这里，你可以插入 `query` 属性的内容，然后点击播放按钮。由于我们设置了 Helmet 来保护我们的应用程序，我们需要在开发中将其停用。否则，GraphQLi
    实例将无法工作。只需将完整的 Helmet 初始化用以下花括号中的 `if` 语句包裹在 `server/index.js` 文件中：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This short condition only activates Helmet when the environment is in development.
    Now, you can send the request with GraphQLi or any HTTP client.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的条件只在开发环境中激活 Helmet。现在，你可以使用 GraphQLi 或任何 HTTP 客户端发送请求。
- en: 'The response of the `POST` request, when combined with the preceding body,
    should look as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当与前面的主体结合时，`POST` 请求的响应应该如下所示：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we received the empty posts array, as expected.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们收到了预期的空帖子数组。
- en: Going further, we want to respond with the fake data we statically wrote in
    our client so that it comes from our backend. Copy the `initialPosts` array from
    `App.js` above the `resolvers` object but rename it `posts`. We can respond to
    the GraphQL request with this filled `posts` array.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们想要以我们客户端中静态编写的假数据作为响应，使其看起来像是来自我们的后端。从上面的 `App.js` 中复制 `initialPosts`
    数组到 `resolvers` 对象上方，但将其重命名为 `posts`。我们可以用这个填充的 `posts` 数组来响应 GraphQL 请求。
- en: 'Replace the content of the `posts` function in the GraphQL resolvers with this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GraphQL resolvers 中的 `posts` 函数内容替换为以下内容：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can rerun the `POST` request and receive both fake posts. The response does
    not include the user object we have in our fake data, so we must define a user
    property on the `post` type in our schema to fix this issue.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新运行 `POST` 请求并接收两个假帖子。响应不包括我们假数据中的用户对象，因此我们必须在我们的模式中的 `post` 类型上定义一个用户属性来解决这个问题。
- en: Using multiple types in GraphQL schemas
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GraphQL 模式中使用多个类型
- en: 'Let''s create a `User` type and use it with our posts. First, add it to the
    schema:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `User` 类型并将其与我们的帖子一起使用。首先，将其添加到模式中：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have a `User` type, we need to use it inside the `Post` type. Add
    it to the `Post` type, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `User` 类型，我们需要在 `Post` 类型中使用它。按照以下方式将其添加到 `Post` 类型中：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `user` field allows us to have a sub-object inside our posts, along with
    the post's author information.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`字段允许我们在我们的帖子中有一个子对象，以及帖子的作者信息。'
- en: 'Our extended query to test this looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来测试这个功能的扩展查询看起来是这样的：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You cannot just specify the user as a property of the query. Instead, you need
    to provide a sub-selection of fields. This is required whenever you have multiple
    GraphQL types nested inside each other. Then, you need to select the fields your
    result should contain.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能仅仅指定用户作为查询的属性。相反，你需要提供一个字段的子选择。当你有多个GraphQL类型嵌套在一起时，这是必需的。然后，你需要选择结果应包含的字段。
- en: Running the updated query gives us the fake data, which we already have in our
    frontend code; just the `posts` array as-is.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行更新后的查询会给我们假数据，这些数据我们已经在我们的前端代码中有了；只是`posts`数组原样。
- en: We have made good progress with querying data, but we also want to be able to
    add and change data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查询数据方面已经取得了良好的进展，但我们还希望能够添加和更改数据。
- en: Writing your first GraphQL mutation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的第一个GraphQL突变
- en: One thing our client has already offered was adding new posts to the fake data
    temporarily. We can implement this in the backend by using GraphQL mutations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端已经提供的一项服务是暂时向假数据中添加新帖子。我们可以在后端通过使用GraphQL突变来实现这一点。
- en: 'Starting with the schema, we need to add the mutation, as well as the input
    types, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构开始，我们需要添加突变，以及输入类型，如下所示：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: GraphQL inputs are no more than types. Mutations can use them as parameters
    inside requests. They may look weird because our current output types look almost
    the same. However, it would be wrong to have an `id` property on `PostInput`,
    for example, since the backend chooses the ID and the client cannot provide it.
    Consequently, it does make sense to have separate objects for input and output
    types.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL输入不外乎是类型。突变可以在请求内部使用它们作为参数。它们可能看起来很奇怪，因为我们的当前输出类型看起来几乎相同。然而，在`PostInput`上有一个`id`属性，例如，这是不正确的，因为后端选择ID，客户端无法提供它。因此，为输入和输出类型保留单独的对象是有意义的。
- en: The `addPost` function receiving our two new required input types – `PostInput`
    and `UserInput` – is a new feature. Those functions are called mutations since
    they mutate the current state of the application. The response to this mutation
    is an ordinary `Post` object. When creating a new post with the `addPost` mutation,
    we will directly get the created post from the backend in response.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接收我们两个新必需输入类型`PostInput`和`UserInput`的`addPost`函数是一个新功能。这些函数被称为突变，因为它们会改变应用程序的当前状态。对此突变的响应是一个普通的`Post`对象。当使用`addPost`突变创建新帖子时，我们将直接从后端获取创建的帖子作为响应。
- en: The exclamation mark in the schema tells GraphQL that the field is a required
    parameter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 架构中的感叹号告诉GraphQL该字段是一个必需的参数。
- en: The `RootMutation` type corresponds to the `RootQuery` type and is an object
    that holds all GraphQL mutations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`RootMutation`类型对应于`RootQuery`类型，是一个包含所有GraphQL突变的对象。'
- en: 'The last step is to enable the mutations in our schema for the Apollo Server
    by applying the `RootMutation` type to the `schema` object:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启用Apollo Server的架构中的突变，通过将`RootMutation`类型应用到`schema`对象：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, the client does not send the user with the mutation. This is because
    the user is authenticated first, before adding a post, and through that, we already
    know which user initiated the Apollo request. However, we will ignore this for
    the moment and implement authentication later in [*Chapter 6*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Authentication with Apollo and React*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户端不会在突变中发送用户。这是因为用户在添加帖子之前先进行认证，通过这种方式，我们已经知道哪个用户发起了Apollo请求。然而，我们暂时忽略这一点，稍后在[*第6章*](B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141)中实现认证，*使用Apollo和React进行认证*。
- en: Now, the `addPost` resolver function needs to be implemented in the `resolvers.js`
    file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要在我们名为`resolvers.js`的文件中实现`addPost`解析器函数。
- en: 'Add the following `RootMutation` object to `RootQuery` in `resolvers.js`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`RootMutation`对象添加到`resolvers.js`中的`RootQuery`：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This resolver extracts the `post` and `user` objects from the mutation's parameters,
    which are passed in the second argument of the function. Then, we build the `postObject`
    variable. We want to add our `posts` array as a property by destructuring the
    `post` input and adding the `user` object. The `id` field is just the length of
    the `posts` array plus one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此解析器从突变参数中提取`post`和`user`对象，这些参数作为函数的第二个参数传入。然后，我们构建`postObject`变量。我们希望通过解构`post`输入并添加`user`对象来将我们的`posts`数组作为属性添加。`id`字段只是`posts`数组的长度加一。
- en: Now, the `postObject` variable looks like a `post` from the `posts` array. Our
    implementation does the same as the frontend is already doing. The return value
    of our `addPost` function is `postObject`. To get this working, you need to change
    the initialization of the `posts` array from `const` to `let`. Otherwise, the
    array will be static and unchangeable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`postObject`变量看起来就像`posts`数组中的`post`。我们的实现与前端已经做的相同。我们的`addPost`函数的返回值是`postObject`。为了使其工作，您需要将`posts`数组的初始化从`const`更改为`let`。否则，数组将是静态的，不可更改。
- en: 'You can run this mutation via your preferred HTTP client, like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过您喜欢的HTTP客户端运行此突变，如下所示：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we pass the word `mutation` and the actual function name – in this case,
    `addPost` – that we want to run, including a selection of response fields inside
    the `query` property, to the normal data query for the posts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将单词`mutation`和实际要运行的函数名——在这个例子中是`addPost`——包括在`query`属性内的响应字段选择，传递给用于帖子数据的常规数据查询。
- en: Second, we use the `variables` property to send the data we want to insert into
    our backend. We need to pass them as parameters within the `query` string. We
    can define both parameters with a dollar sign and the awaited data type inside
    the `operation` string. The variables marked with dollar signs are then mapped
    into the actual action we want to trigger on the backend.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们使用`variables`属性来发送我们想要插入后端的数据。我们需要将它们作为参数包含在`query`字符串中。我们可以在`operation`字符串中定义这两个参数，使用美元符号和期待的数据类型。带有美元符号的变量随后会被映射到我们希望在后端触发的实际操作。
- en: When we send this mutation, the request will have a `data` object, including
    an `addPost` field. The `addPost` field holds the post, which we send with our
    request.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送这个突变时，请求将包含一个`data`对象，包括一个`addPost`字段。`addPost`字段包含我们随请求发送的帖子。
- en: If you query the posts again, you will see that there are now three posts. Great
    – it worked!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次查询帖子，您将看到现在有三个帖子。太好了——它成功了！
- en: As with our client, this is only temporary until we restart the server. We'll
    cover how to persist data in a SQL database in [*Chapter 3*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054),
    *Connecting to the Database*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的客户端一样，这只是一个临时的，直到我们重启服务器。我们将在[*第3章*](B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054)“连接到数据库”中介绍如何在SQL数据库中持久化数据。
- en: Next, we'll cover the various ways you can debug your backend.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍您调试后端的各种方法。
- en: Backend debugging and logging
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端调试和日志记录
- en: Two things are very important for debugging. The first is that we need to implement
    logging for our backend in case we receive errors from our users, while the second
    is that we need to look into Postman to debug our GraphQL API efficiently.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 调试有两个非常重要的事情。首先，我们需要为后端实现日志记录，以防我们收到用户的错误，其次，我们需要查看Postman来有效地调试GraphQL API。
- en: So, let's get started with logging.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始记录日志。
- en: Logging in Node.js
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js中的日志记录
- en: 'The most popular logging package for Node.js is called `winston`. Install and
    configure `winston` by following these steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中最受欢迎的日志包叫做`winston`。按照以下步骤安装和配置`winston`：
- en: 'Install `winston` with `npm`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm`安装`winston`：
- en: '[PRE43]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, create a new folder for all of the helper functions from the backend:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为后端的所有辅助函数创建一个新的文件夹：
- en: '[PRE44]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, insert a `logger.js` file into the new folder with the following content:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在新的文件夹中插入一个`logger.js`文件，内容如下：
- en: '[PRE45]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This file can be imported everywhere we want to log.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件可以在我们想要记录日志的任何地方导入。
- en: In the preceding code, we defined the standard `transports` for `winston`. A
    transport is nothing more than how `winston` separates and saves various log types
    in different files.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为`winston`定义了标准的`transports`。传输不过是`winston`如何将不同的日志类型分开并保存到不同的文件中。
- en: The first `transport` generates an `error.log` file where only real errors are
    saved.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`transport`生成一个`error.log`文件，其中只保存真实错误。
- en: The second transport is a combined log where we save all the other log messages,
    such as warnings or information logs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个传输是一个组合日志，我们将保存所有其他日志消息，例如警告或信息日志。
- en: If we are running the server in a development environment, which we are currently
    doing, we must add a third transport. We will also directly log all the messages
    to the console while developing on the server.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在开发环境中运行服务器，我们现在就是这样做的，我们必须添加第三个传输。同时，我们将在服务器开发期间直接将所有消息记录到控制台。
- en: Most people who are used to JavaScript development know the difficulty with
    `console.log`. By directly using `winston`, we can see all the messages in the
    Terminal, but we do not need to clean the code from `console.log` either, so long
    as the things we log make sense.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数习惯于JavaScript开发的人都知道`console.log`的困难。通过直接使用`winston`，我们可以在终端中看到所有消息，但我们也无需从`console.log`中清理代码，只要我们记录的内容有意义即可。
- en: To test this out, we can try the `winston` logger in the only mutation we have.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以在唯一的变异中尝试`winston`记录器。
- en: 'In `resolvers.js`, add the following code to the top of the file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`resolvers.js`文件顶部添加以下代码：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can extend the `addPost` function by adding the following before the
    `return` statement:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`return`语句之前添加以下内容来扩展`addPost`函数：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you send the mutation now, you will see that the message was logged to
    the console.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在发送变异时，您将看到消息被记录到控制台。
- en: Furthermore, if you look in the root folder of your project, you will see the
    `error.log` and `combined.log` files. The `combined.log` file should contain the
    log from the console.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您查看项目的根目录，您将看到`error.log`和`combined.log`文件。`combined.log`文件应包含来自控制台的操作日志。
- en: Now that we can log all the operations on the server, we should explore Postman
    so that we can send requests comfortably.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够记录服务器上的所有操作，我们应该探索Postman，以便我们可以舒适地发送请求。
- en: Debugging with Postman
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Postman进行调试
- en: '**Postman** is one of the most widely used HTTP clients there is. It not only
    provides raw HTTP client functionality but also teams and collections, along with
    letting you synchronize all the requests you saved in Postman.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**Postman**是现有最广泛使用的HTTP客户端之一。它不仅提供了原始HTTP客户端功能，还提供了团队和集合，并允许您同步在Postman中保存的所有请求。'
- en: You can install Postman by downloading the appropriate file from [https://www.postman.com/downloads/](https://www.postman.com/downloads/).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从[https://www.postman.com/downloads/](https://www.postman.com/downloads/)下载适当的文件来安装Postman。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Numerous other HTTP client tools are useful for debugging your application.
    You are free to use your tool of choice. Some other great clients that I use are
    Insomnia, SoapUI, and Stoplight, but there are many more. In this book, we will
    use Postman, as it is the most popular from my point of view.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他HTTP客户端工具对调试您的应用程序很有用。您可以使用您选择的工具。我使用的其他一些优秀客户端包括Insomnia、SoapUI和Stoplight，但还有很多。在我看来，本书我们将使用Postman，因为它是最受欢迎的。
- en: 'When you have finished the installation, it should look something like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，它应该看起来像这样：
- en: '![Figure 2.1 – Postman screen after installing the Book collection'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 安装Book集合后的Postman屏幕'
- en: '](img/Figure_2.1_B17337.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B17337.jpg)'
- en: Figure 2.1 – Postman screen after installing the Book collection
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 安装Book集合后的Postman屏幕
- en: 'As you can see, I have already created a collection called **Book** in the
    left-hand panel. This collection includes our two requests: one to request all
    posts and one to add a new post.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我已在左侧面板中创建了一个名为**Book**的集合。这个集合包括我们的两个请求：一个请求所有帖子，一个添加新帖子。
- en: 'As an example, the following screenshot shows you what the **Add Post** mutation
    looks like in Postman:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下截图显示了在Postman中**添加帖子**变异的外观：
- en: '![Figure 2.2 – The Add Post mutation in Postman'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – Postman中的添加帖子变异'
- en: '](img/Figure_2.2_B17337.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.2_B17337.jpg)'
- en: Figure 2.2 – The Add Post mutation in Postman
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Postman中的添加帖子变异
- en: The URL is `localhost` and includes port `8000`, as expected.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: URL是`localhost`，包括预期的端口`8000`。
- en: The request body looks pretty much like what we saw previously. Be sure to select
    `application/json` as `Content-Type` next to the `raw` format.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体看起来与之前我们看到的基本相同。请确保在`raw`格式旁边选择`Content-Type`为`application/json`。
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In my case, I need to write the query inline because Postman is not able to
    handle multi-row text inside JSON. If this is not the case for you, please ignore
    it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我需要将查询内联编写，因为Postman无法处理JSON中的多行文本。如果您的情况不是这样，请忽略它。
- en: 'Since the newer version of Postman was released, there is also the option to
    select GraphQL instead of JSON. If you do that, you can write the GraphQL code
    in multiple lines and write the variables in a separate window. The result should
    look like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Postman的新版本发布，现在也有选择GraphQL而不是JSON的选项。如果您这样做，您可以在多行中编写GraphQL代码，并在单独的窗口中编写变量。结果应该看起来像这样：
- en: '![Figure 2.3 – Postman with GraphQL selected'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 选择GraphQL的Postman'
- en: '](img/Figure_2.3_B17337.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B17337.jpg)'
- en: Figure 2.3 – Postman with GraphQL selected
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 选择GraphQL的Postman
- en: If you add a new request, you can use the *Ctrl* + *S* shortcut to save it.
    You need to select a collection and a name to save it with. One major downfall
    of using Postman (at least with GraphQL APIs) is that we are only using `POST`.
    It would be great to have some kind of indication of what we are doing here –
    for example, a query or a mutation. We will learn how to use authorization in
    Postman once we have implemented it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了一个新的请求，你可以使用 *Ctrl* + *S* 快捷键来保存它。你需要选择一个集合和一个名称来保存。使用 Postman（至少在使用 GraphQL
    API 时）的一个主要缺点是我们只使用 `POST`。如果能有一种方式来表明我们在做什么那就太好了——例如，一个查询或一个变更。一旦我们实现了它，我们就会学习如何在
    Postman 中使用授权。
- en: Postman also has other great features, such as automated testing, monitoring,
    and mocking a fake server.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 还拥有其他一些出色的功能，例如自动化测试、监控和模拟假服务器。
- en: Later in this book, it will become more complicated to configure Postman for
    all requests. In such cases, I like to use the Apollo Client Developer Tools,
    which perfectly integrate into the frontend and make use of Chrome DevTools. What's
    great about the Apollo Client Developer Tools is that they use the Apollo Client
    we configure in the frontend code, which means they reuse the authentication we
    built into our frontend.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，为所有请求配置 Postman 将变得更加复杂。在这种情况下，我喜欢使用 Apollo Client 开发者工具，它们完美地集成到前端并利用
    Chrome 开发者工具。Apollo Client 开发者工具的伟大之处在于，它们使用我们在前端代码中配置的 Apollo Client，这意味着它们重用了我们嵌入到前端中的认证。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up our Node.js server with Express.js and bound the
    Apollo Server to respond to requests on a GraphQL endpoint. We can handle queries,
    return fake data, and mutate that data with GraphQL mutations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Express.js 设置了我们的 Node.js 服务器，并将 Apollo Server 绑定到响应 GraphQL 端点的请求。我们可以处理查询，返回假数据，并通过
    GraphQL 变更来修改数据。
- en: Furthermore, we can log every process in our Node.js server. Debugging an application
    with Postman leads to a well-tested API, which can be used later in our frontend.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在我们的 Node.js 服务器中记录每个进程。使用 Postman 调试应用程序会导致经过良好测试的 API，这可以在我们前端后续使用。
- en: In the next chapter, we will learn how to persist data in a SQL server. We will
    also implement models for our GraphQL types and cover migrations for our database.
    We need to replace our current `resolver` functions with queries via Sequelize.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 SQL 服务器中持久化数据。我们还将实现 GraphQL 类型的模型，并涵盖数据库迁移。我们需要用 Sequelize 通过查询替换我们当前的
    `resolver` 函数。
- en: There is a lot to do, so read on for more!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工作要做，所以请继续阅读以获取更多信息！
