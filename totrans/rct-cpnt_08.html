<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;React Design Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. React Design Patterns</h1></div></div></div><p>In the last chapter, we looked at React on the server. We created a simple HTTP server followed by multiple endpoints and web sockets.</p><p>In this chapter, we will take a step back and consider the component architecture we have built so far. We'll look at a couple of popular React design patterns and how we can make subtle improvements to our architecture.</p><div class="section" title="Where we are"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Where we are</h1></div></div></div><p>Let's take a look at the things we have created so far and how they interact with each other. If you've been following closely, this may all be familiar to you; but stick with it.</p><p>We will talk about how these interactions are failing us and how we can improve them. From the moment our interface begins to render, we start to see the following things happen:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We begin by creating <a id="id178" class="indexterm"/>a backend object. We use this as a store for the pages in our application. This has methods such as <code class="literal">add</code>, <code class="literal">edit</code>, <code class="literal">delete</code>, and <code class="literal">all</code>. It also acts as an event emitter, notifying listeners whenever pages change.</li><li class="listitem">We create a <code class="literal">PageAdmin</code> React component and pass the <code class="literal">Backend</code> object to it. The <code class="literal">PageAdmin</code> component uses the <code class="literal">Backend</code> object as a data source for other page components, all of which are created within the <code class="literal">PageAdmin</code> render method. The <code class="literal">PageAdmin</code> component listens for changes in <code class="literal">Backend</code> as soon as it is mounted. It stops listening after it is unmounted.</li><li class="listitem">The<code class="literal"> PageAdmin</code> component has a few callbacks, which it passes down to the other page components it creates. These provide a way for child components to trigger changes in the <code class="literal">Backend</code> object.</li><li class="listitem">Through user interaction, components such as <code class="literal">PageEditor</code> and <code class="literal">PageView</code> trigger the callback functions they receive from <code class="literal">PageAdmin</code>. These then trigger changes in the <code class="literal">Backend</code> object.</li><li class="listitem">Data changes in <code class="literal">Backend</code>. At the same time, <code class="literal">Backend</code> notifies event listeners that the data has changed and <code class="literal">PageAdmin</code> is one of those listeners.</li><li class="listitem">The <code class="literal">PageAdmin</code> component updates its internal state to the newest version of the <code class="literal">Backend</code> pages, which <a id="id179" class="indexterm"/>causes other page components to re-render.</li></ol></div><p>We can imagine this as follows:</p><div class="mediaobject"><img src="graphics/5268_08_01.jpg" alt="Where we are"/></div><p>We can even reduce our existing code to the essential parts of this architecture. Let's re-implement listing and adding pages without styles or the build chain. We can use this as a starting point for the architectural improvements later in this chapter. This will also be a good place to recap<a id="id180" class="indexterm"/> some of the new ES6 features we've seen so far and learn about a few new ones.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>I don't want to repeat the whole build chain here, but we do need some help to use ES6 and JSX in our code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save babel-cli babel-preset-react babel-preset-es2015 eventemitter3 react react-dom</strong></span>
</pre></div><p>We enable ES6/JSX transformers in <code class="literal">.babelrc</code>:</p><div class="informalexample"><pre class="programlisting">{
  "presets": ["react", "es2015"]
}</pre></div><p>We can run this code with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ node_modules/.bin/babel-node index.js</strong></span>
</pre></div><p>This will transform the ES6/JSX code in <code class="literal">index.js</code> and all the files it imports.</p></div></div><p>We began with the <code class="literal">src/backend.js</code> file:</p><div class="informalexample"><pre class="programlisting">import Emitter from "eventemitter3";

class Backend extends Emitter {
    constructor() {
        super();

        <span class="strong"><strong>this.id = 1;</strong></span>
        <span class="strong"><strong>this.pages = [];</strong></span>
    }

    add() {
        <span class="strong"><strong>const id = this.id++;</strong></span>
        <span class="strong"><strong>const title = `New Page ${id}`;</strong></span>

        <span class="strong"><strong>const page = {</strong></span>
            <span class="strong"><strong>id,</strong></span>
            <span class="strong"><strong>title</strong></span>
        <span class="strong"><strong>};</strong></span>

        <span class="strong"><strong>this.pages.push(page);</strong></span>
        <span class="strong"><strong>this.emit("onAdd", page);</strong></span>
    }

    getAll() {
        <span class="strong"><strong>return this.pages;</strong></span>
    }
}

export default Backend;</pre></div><p><code class="literal">Backend</code> is a class with internal <code class="literal">id</code> and <code class="literal">pages</code> properties. The <code class="literal">id</code> property acts as an auto-increment identity <a id="id181" class="indexterm"/>value for each new page object. It has the <code class="literal">add</code> and <code class="literal">getAll</code> methods, which add new pages and return all pages, respectively.</p><p>In ES6, we can define constants (variables which cannot be changed after they are defined and assigned). These are great for when we only need to define a variable once, as they guard against unintended changes.</p><p>We assign the next identity value and increment the internal <code class="literal">id</code> property so that the next identity value will be different. ES6 template strings allow us to interpolate variables (like we do with the identity value) and define multiline strings.</p><p>We can define objects with keys matching defined local variable names using the new ES6 object literal syntax. In other words, <code class="literal">{ title }</code> means the same as <code class="literal">{ title: title }</code>.</p><p>Each time a new page is added, <code class="literal">Backend</code> emits its <code class="literal">onAdd</code> event to any listeners. We can see all of this in action with the following code (in <code class="literal">index.js</code>):</p><div class="informalexample"><pre class="programlisting">import Backend from "./src/backend";

<span class="strong"><strong>let backend = new Backend();</strong></span>

<span class="strong"><strong>backend.on("onAdd", (page) =&gt; {</strong></span>
    <span class="strong"><strong>console.log("new page: ", page);</strong></span>
<span class="strong"><strong>});</strong></span>

console.log("all pages: ", <span class="strong"><strong>backend.getAll()</strong></span>);

<span class="strong"><strong>backend.add();</strong></span>
console.log("all pages: ", <span class="strong"><strong>backend.getAll()</strong></span>);</pre></div><p>In ES6, the <code class="literal">let</code> keyword works similarly to <code class="literal">var</code>. The difference is that <code class="literal">var</code> is scoped to the enclosing function, where <code class="literal">let</code> is scoped to the enclosing block:</p><div class="informalexample"><pre class="programlisting">function printPages(pages) {
    for (<span class="strong"><strong>var i = 0</strong></span>; i &lt; pages.length; i++) {
        console.log(pages[i]);
    }

    <span class="strong"><strong>// i == pages.length - 1 </strong></span>

    for (<span class="strong"><strong>let j = 0</strong></span>; j &lt; pages.length; j++) {
        console.log(pages[j]);
    }

    <span class="strong"><strong>// j == undefined</strong></span>
}</pre></div><p>If you run this <code class="literal">Backend</code> <a id="id182" class="indexterm"/>code, you should see the following output:</p><div class="informalexample"><pre class="programlisting">all pages:  []
new page:  { id: 1, title: 'New Page 1' }
all pages:  [ { id: 1, title: 'New Page 1' } ]</pre></div><p>We can combine this with the <code class="literal">PageAdmin</code> component (in <code class="literal">src/page-admin.js</code>):</p><div class="informalexample"><pre class="programlisting">import React from "react";

const PageAdmin = (props) =&gt; {
    return (
        &lt;div&gt;
            &lt;a href="#"
                onClick={(e) =&gt; {
                    e.preventDefault();
                    <span class="strong"><strong>props.backend.add();</strong></span>
                }}&gt;
                add page
            &lt;/a&gt;
            &lt;ol&gt;
                {<span class="strong"><strong>props.backend.all()</strong></span>.map((page) =&gt; {
                    return (
                        &lt;li key={page.id}&gt;
                            {page.title}
                        &lt;/li&gt;
                    );
                })}
            &lt;/ol&gt;
        &lt;/div&gt;
    );
};

export default PageAdmin;</pre></div><p>This is a stateless function <a id="id183" class="indexterm"/>version of our previous <code class="literal">PageAdmin</code> component. We can use it with the following code (in <code class="literal">index.js</code>):</p><div class="informalexample"><pre class="programlisting">import Backend from "./src/backend";
import PageAdmin from "./src/page-admin";
import React from "react";
import ReactDOMServer from "react-dom/server";

let backend = new Backend();

backend.add();
backend.add();
backend.add();

console.log(
    <span class="strong"><strong>ReactDOMServer.renderToString(</strong></span>
        <span class="strong"><strong>&lt;PageAdmin backend={backend} /&gt;</strong></span>
    <span class="strong"><strong>)</strong></span>
);</pre></div><p>This will generate the following output:</p><div class="informalexample"><pre class="programlisting">&lt;div data-reactid=".51gm9pfn5s" data-react-checksum="865425333"&gt;
    &lt;a href="#" data-reactid=".51gm9pfn5s.0"&gt;add page&lt;/a&gt;
    &lt;ol data-reactid=".51gm9pfn5s.1"&gt;
        &lt;li data-reactid=".51gm9pfn5s.1.$1"&gt;New Page 1&lt;/li&gt;
        &lt;li data-reactid=".51gm9pfn5s.1.$2"&gt;New Page 2&lt;/li&gt;
        &lt;li data-reactid=".51gm9pfn5s.1.$3"&gt;New Page 3&lt;/li&gt;
    &lt;/ol&gt;
&lt;/div&gt;</pre></div><p>Now, if we were rendering this into an HTML page, we would click on the <span class="strong"><strong>add page</strong></span> link and a new page would be added to the list of existing pages inside <code class="literal">Backend</code>. We also created <code class="literal">PageAdmin</code> as a class so that we could add an event listener in the <code class="literal">componentWillMount</code> life cycle method. This listener would then update the child <code class="literal">Page</code> components with an updated array of pages.</p><p>The <code class="literal">PageAdmin</code> component was used to render the <code class="literal">Page</code> components, which in turn rendered the <code class="literal">PageView</code> and <code class="literal">PageEditor</code> components to show and edit pages, respectively. We <a id="id184" class="indexterm"/>passed callback functions down through each layer so that every component could trigger changes in the <code class="literal">Backend</code> object without knowing how it stores or manipulates the data.</p></div></div>
<div class="section" title="Flux"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Flux</h1></div></div></div><p>At this stage, we encounter the first design pattern (and the improvements we can make). Flux is a pattern <a id="id185" class="indexterm"/>proposed by Facebook that defines the flow of data in an interface.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Flux is not a library, but<a id="id186" class="indexterm"/> Facebook has released a few tools that help implement the design pattern. You don't have to use those tools to implement Flux. To install it, run <code class="literal">npm install --save flux</code> in addition to the previous dependencies.</p></div></div><p>We implemented something very close to Flux, but our implementation is at a slight disadvantage. Our <code class="literal">Backend</code> class does too much. We call it directly to add and fetch pages. It emits events when new pages are added. It's tightly coupled with the components that use it.</p><p>So, we'd have a hard time replacing it with a new <code class="literal">Backend</code> class (unless the methods, events and return values were in the exact same format). We'd have a hard time using multiple data backends. We don't even really have unidirectional flow of data because we send <span class="emphasis"><em>and</em></span> receive data from <code class="literal">Backend</code>.</p><p>Flux differs here; it defines separate objects for <span class="emphasis"><em>making changes</em></span> and <span class="emphasis"><em>getting data</em></span>. Our <code class="literal">Backend</code> class becomes a <span class="emphasis"><em>dispatcher</em></span> for the former and a <span class="emphasis"><em>store</em></span> for the latter. What's more, instructions to change application state take the form of message objects (called <span class="emphasis"><em>actions</em></span>).</p><p>We can imagine this as follows:</p><div class="mediaobject"><img src="graphics/5268_08_02.jpg" alt="Flux"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>These code <a id="id187" class="indexterm"/>examples will require another library, which you can install with <code class="literal">npm install --save flux</code>.</p></div></div><p>We can implement this design change by creating a new <code class="literal">PageDispatcher</code> object (in <code class="literal">src/page-dispatcher.js</code>):</p><div class="informalexample"><pre class="programlisting">import { Dispatcher } from "flux";

const pageDispatcher = new Dispatcher();

export default pageDispatcher;</pre></div><p>The <code class="literal">Dispatcher</code> class isn't too complex. It has a couple of methods, which we will use shortly. What's important to note is that we are exporting an instance of the <code class="literal">Dispatcher</code> class, not a subclass. We only need one dispatcher for our page operations. So, we use it as a kind of singleton, even though we've not coded it specifically to be a singleton.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>If you're unfamiliar <a id="id188" class="indexterm"/>with the singleton pattern, you can learn about it at <a class="ulink" href="https://en.wikipedia.org/wiki/Singleton_pattern">https://en.wikipedia.org/wiki/Singleton_pattern</a>. The basic idea is that we create a class for something (or, in this case, use an existing class) but we only ever create and use a single instance of the class.</p></div></div><p>The second part of<a id="id189" class="indexterm"/> this change is a class called <code class="literal">PageStore</code>, which we create in <code class="literal">src/page-store.js</code>:</p><div class="informalexample"><pre class="programlisting">import Emitter from "eventemitter3";
import PageDispatcher from "./page-dispatcher";

class PageStore extends Emitter {
    constructor() {
        super();

        this.id = 1;
        this.pages = [];
    }

    add() {
        // ...add new page
    }

    getAll() {
        return this.pages;
    }
}

<span class="strong"><strong>const pageStore = new PageStore();</strong></span>

<span class="strong"><strong>PageDispatcher.register((payload) =&gt; {</strong></span>
    <span class="strong"><strong>if (payload.action === "ADD_PAGE") {</strong></span>
        <span class="strong"><strong>pageStore.add();</strong></span>
    <span class="strong"><strong>}</strong></span>

    <span class="strong"><strong>pageStore.emit("change");</strong></span>
<span class="strong"><strong>});</strong></span>

export default pageStore;</pre></div><p>This class closely resembles the <code class="literal">Backend</code> class. One notable change is that we no longer emit the <code class="literal">onAdd</code> event <a id="id190" class="indexterm"/>after adding new pages. Instead, we register a sort of event listener on <code class="literal">PageDispatcher</code>, which is how we know to add new pages to <code class="literal">PageStore</code>. It's possible to call <code class="literal">PageStore.add</code> directly, but here, we do that in response to actions being dispatched to <code class="literal">PageDispatcher</code>. This is how those actions look (in <code class="literal">src/index.js</code>):</p><div class="informalexample"><pre class="programlisting">import PageAdmin from "./src/page-admin";
<span class="strong"><strong>import PageDispatcher from "./src/page-dispatcher";</strong></span>
<span class="strong"><strong>import PageStore from "./src/page-store";</strong></span>

<span class="strong"><strong>PageStore.on("change", () =&gt; {</strong></span>
    <span class="strong"><strong>console.log("on change: ", PageStore.getAll());</strong></span>
<span class="strong"><strong>});</strong></span>

console.log("all pages: ", <span class="strong"><strong>PageStore.getAll()</strong></span>);

<span class="strong"><strong>PageDispatcher.dispatch({</strong></span>
    <span class="strong"><strong>"action": "ADD_PAGE"</strong></span>
<span class="strong"><strong>});</strong></span>

console.log("all pages: ", <span class="strong"><strong>PageStore.getAll()</strong></span>);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>Dispatchers trigger event listeners in all registered stores. If you dispatch an action through a dispatcher, all stores will be notified, no matter the payload.</p></div></div><p>Now, stores don't only manage collections of objects (like our pages). They're not an application database. They're meant to store all application states. Perhaps we should change a few methods to make this clearer, beginning in <code class="literal">src/page-store.js</code>:</p><div class="informalexample"><pre class="programlisting">class PageStore extends Emitter {
    constructor() {
        super();

        this.id = 1;
        this.pages = [];
    }

    <span class="strong"><strong>handle(payload) {</strong></span>
        <span class="strong"><strong>if (payload.action == "ADD_PAGE") {</strong></span>
            <span class="strong"><strong>// ...add new page</strong></span>
        <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>getState() {</strong></span>
        <span class="strong"><strong>return {</strong></span>
            <span class="strong"><strong>"pages": this.pages</strong></span>
        <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>}</strong></span>
}

const pageStore = new PageStore();

PageDispatcher.register((payload) =&gt; {
    <span class="strong"><strong>if (payload.action === "ADD_PAGE") {</strong></span>
        <span class="strong"><strong>pageStore.handle(payload);</strong></span>
    <span class="strong"><strong>}</strong></span>

    pageStore.emit("change");
});</pre></div><p>We're still calling this<a id="id191" class="indexterm"/> store <code class="literal">PageStore</code>, but it can hold many other kinds of state besides an array of pages. It could, for instance, store filter and sorting state as well. For each new action, we would just need to add some code to the <code class="literal">handle</code> method.</p><p>We also need to adjust the calling code in <code class="literal">index.js</code>:</p><div class="informalexample"><pre class="programlisting">PageStore.on(<span class="strong"><strong>"change"</strong></span>, () =&gt; {
    console.log(<span class="strong"><strong>"change: ", PageStore.getState()</strong></span>);
});

console.log("all state: ", <span class="strong"><strong>PageStore.getState()</strong></span>);

PageDispatcher.dispatch({
    "action": "ADD_PAGE"
});

console.log("all state: ", <span class="strong"><strong>PageStore.getState()</strong></span>);</pre></div><p>When we run this, we should see the following output:</p><div class="informalexample"><pre class="programlisting">all state:  { pages: [] }
change:  { pages: [ { id: 1, title: 'New Page 1' } ] }
all state:  { pages: [ { id: 1, title: 'New Page 1' } ] }</pre></div><p>Now, we need to<a id="id192" class="indexterm"/> implement these changes in <code class="literal">src/page-admin.js</code>:</p><div class="informalexample"><pre class="programlisting">import React from "react";
import PageDispatcher from "./page-dispatcher";
import PageStore from "./page-store";
class PageAdmin extends React.Component {
    constructor() {
        super();
        <span class="strong"><strong>this.state = PageStore.getState();</strong></span>
       <span class="strong"><strong>this.onChange = this.onChange.bind(this);</strong></span>
    }
    <span class="strong"><strong>componentDidMount() {</strong></span>
        <span class="strong"><strong>PageStore.on("change", this.onChange);</strong></span>
    <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>componentWillUnmount() {</strong></span>
        <span class="strong"><strong>PageStore.removeListener("change", this.onChange);</strong></span>
    <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>onChange() {</strong></span>
        <span class="strong"><strong>this.setState(PageStore.getState());</strong></span>
    <span class="strong"><strong>}</strong></span>
    render() {
        return (
            &lt;div&gt;
                &lt;a href="#"
                    onClick={(e) =&gt; {
                        e.preventDefault();

                        <span class="strong"><strong>PageDispatcher.dispatch({</strong></span>
                            <span class="strong"><strong>"action": "ADD_PAGE"</strong></span>
                        <span class="strong"><strong>});</strong></span>
                    }}&gt;
                    add page
                &lt;/a&gt;
                &lt;ol&gt;
                    {<span class="strong"><strong>this.state.pages</strong></span>.map((page) =&gt; {
                        return (
                            &lt;li key={page.id}&gt;
                                {page.title}
                            &lt;/li&gt;
                        );
                    })}
                &lt;/ol&gt;
            &lt;/div&gt;
        );
    }
};

export default PageAdmin;</pre></div><p>Finally, we can update <code class="literal">index.js</code> to reflect these new changes:</p><div class="informalexample"><pre class="programlisting">import PageAdmin from "./src/page-admin";
import PageDispatcher from "./src/page-dispatcher";
import PageStore from "./src/page-store";
import React from "react";
import ReactDOMServer from "react-dom/server";

<span class="strong"><strong>PageDispatcher.dispatch({</strong></span>
    <span class="strong"><strong>"action": "ADD_PAGE"</strong></span>
<span class="strong"><strong>});</strong></span>

<span class="strong"><strong>// ...dispatch the same thing a few more times</strong></span>

console.log(
    ReactDOMServer.renderToString(
        <span class="strong"><strong>&lt;PageAdmin /&gt;</strong></span>
    )
);</pre></div><p>If we run this code, we <a id="id193" class="indexterm"/>see very similar output to the code we had before implementing Flux.</p><div class="section" title="Benefits of using Flux"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec18"/>Benefits of using Flux</h2></div></div></div><p>In a sense, we're <a id="id194" class="indexterm"/>still tightly coupling the code that renders interface elements and the code that stores and manipulates state. We've just created a bit of a barrier between them. So, what do we gain from this approach?</p><p>To start with, Flux is a popular design pattern for React applications. We can talk about actions, dispatchers, and stores and be sure that other React developers will know exactly what we mean. This decreases the learning curve for bringing new developers into React projects.</p><p>We've also separated state storage from user and system actions. We have a single, universal object through which we can send actions. These may result in changes to multiple stores, which in turn can trigger changes in multiple parts of our interface. We don't need of multiple <a id="id195" class="indexterm"/>stores in our simple example, but complex interfaces can benefit from multiple stores. In these cases, a single dispatcher and multiple stores work well together.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>It's worth noting that while we've named the Flux dispatcher in such a way that we could have more than one dispatcher, apps usually only have one. It's also common to have the data backend and dispatcher act as singletons. I've chosen to deviate from this based on how we began our application and how we're going to end it.</p></div></div></div></div>
<div class="section" title="Redux"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Redux</h1></div></div></div><p>Flux leads us to separate<a id="id196" class="indexterm"/> our <code class="literal">Backend</code> class into a dispatcher and a store as a means of decoupling from a single state store and implementation. This leads to quite a bit of boilerplate, and we still have some coupling (to global dispatcher and store objects). It's great to have some terminology to work with, but it doesn't feel like the best solution.</p><p>What if we could decouple actions and storage and remove the global objects? This is what Redux seeks to <a id="id197" class="indexterm"/>do along with reducing boilerplate code and bringing about better standards overall.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>You can download the Redux tools by running <code class="literal">npm install --save redux react-redux</code> in addition to the previous dependences. Redux is also just a pattern, but the tools in these libraries will help greatly in setting things up.</p></div></div><p>Redux can be a lot to take in at first, but there are some simple underlying things which bind it all together. For a start, there's the idea that all state is held in immutable objects. This state should only be transformed by pure functions, which take in the current state, and produce a new state. These pure functions are also sometimes called idempotent, which means they can be run many times (with the same input) and produce the exact same output every time. Let's explore this idea with some code in <code class="literal">index.js</code>:</p><div class="informalexample"><pre class="programlisting">const transform = (state, action) =&gt; {
    let id = 1;
    let pages = state.pages;

    <span class="strong"><strong>if (action.type == "ADD_PAGE") {</strong></span>
        <span class="strong"><strong>pages = [</strong></span>
            <span class="strong"><strong>...state.pages,</strong></span>
            <span class="strong"><strong>{</strong></span>
                <span class="strong"><strong>"title": "New Page " + id,</strong></span>
                <span class="strong"><strong>"id": id++</strong></span>
            <span class="strong"><strong>}</strong></span>
        <span class="strong"><strong>];</strong></span>
    <span class="strong"><strong>}</strong></span>

    <span class="strong"><strong>return {</strong></span>
        <span class="strong"><strong>pages</strong></span>
    <span class="strong"><strong>};</strong></span>
};

console.log(
    <span class="strong"><strong>transform({ "pages": [] }, { "type": "ADD_PAGE" })</strong></span>
);</pre></div><p>Here, we have a<a id="id198" class="indexterm"/> function that takes an initial state value and modifies it in the presence of the same sort of action we created for Flux. This is a pure function with no side-effects. A new state object is returned, and we even use the ES6 spread operator as a way of concatenating the pages into a new array. It's really the same as doing the following:</p><div class="informalexample"><pre class="programlisting">pages = pages.concat({
    "title": "New Page " + id,
    "id": id++
});</pre></div><p>When we prefix an array with <code class="literal">...</code>, its values expand as if we wrote them all out in a row. This transformer function is <a id="id199" class="indexterm"/>called a <span class="emphasis"><em>reducer</em></span>, named after the reduce part of <span class="emphasis"><em>MapReduce</em></span> (<a class="ulink" href="https://en.wikipedia.org/wiki/MapReduce">https://en.wikipedia.org/wiki/MapReduce</a>). That is, Redux defines reducers as a <a id="id200" class="indexterm"/>way of reducing an initial state by passing it through one or more reducers to a new state.</p><p>We give this reducer to a store similar to the one we created for Flux:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import { createStore } from "redux";</strong></span>

const transform = (state = { "pages": [] }, action) =&gt; {
    // ...create a new state object, with a new page
};

<span class="strong"><strong>const store = createStore(transform);</strong></span>

<span class="strong"><strong>store.dispatch({ "type": "ADD_PAGE" });</strong></span>

console.log(
    <span class="strong"><strong>store.getState()</strong></span>
);</pre></div><p>The store also acts as<a id="id201" class="indexterm"/> a dispatcher, so this is much closer to our original code. We register listeners on the store, so we can be notified of changes to state. We can use a <code class="literal">PageAdmin</code> component similar to the one we make for Flux (in <code class="literal">src/page-admin.js</code>):</p><div class="informalexample"><pre class="programlisting">import React from "react";

class PageAdmin extends React.Component {
    constructor(props) {
        super(props);
        <span class="strong"><strong>this.state = this.props.store.getState();</strong></span>
<span class="strong"><strong>        this.onChange = this.onChange.bind(this);</strong></span>
    }
    componentDidMount() {
        <span class="strong"><strong>this.removeListener =  </strong></span>
            <span class="strong"><strong>this.props.store.register(this.onChange);</strong></span>
    }
    componentWillUnmount() {
        <span class="strong"><strong>this.removeListener();</strong></span>
    }
    onChange() {
        <span class="strong"><strong>this.setState(this.props.store.getState());</strong></span>
    }
    render() {
        return (
            &lt;div&gt;
                &lt;a href="#"
                    onClick={(e) =&gt; {
                        e.preventDefault();

                        <span class="strong"><strong>this.props.store.dispatch({</strong></span>
                            <span class="strong"><strong>"type": "ADD_PAGE"</strong></span>
                        <span class="strong"><strong>});</strong></span>
                    }}&gt;
                    add page
                &lt;/a&gt;
                &lt;ol&gt;
                    {<span class="strong"><strong>this.state.pages</strong></span>.map((page) =&gt; {
                        // ...render each page
                    })}
                &lt;/ol&gt;
            &lt;/div&gt;
        );
    }
};

export default PageAdmin;</pre></div><p>Also, we can render <a id="id202" class="indexterm"/>all of this with a few small changes to <code class="literal">index.js</code>:</p><div class="informalexample"><pre class="programlisting">import { createStore } from "redux";
import PageAdmin from "./src/page-admin";
import React from "react";
import ReactDOMServer from "react-dom/server";

const transform = (<span class="strong"><strong>state = { "pages": [] }</strong></span>, action) =&gt; {
    let id = 1;
    <span class="strong"><strong>let pages = state.pages;</strong></span>

    <span class="strong"><strong>if (action.type == "ADD_PAGE") {</strong></span>
        pages = [
            ...state.pages,
            {
                "title": "New Page " + id,
                "id": id++
            }
        ];
    <span class="strong"><strong>}</strong></span>

    return {
        pages
    };
};

<span class="strong"><strong>const store = createStore(transform);</strong></span>

<span class="strong"><strong>store.dispatch({ "type": "ADD_PAGE" });</strong></span>

console.log(
    ReactDOMServer.renderToString(
        <span class="strong"><strong>&lt;PageAdmin store={store} /&gt;</strong></span>
    )
);</pre></div><p>We can imagine<a id="id203" class="indexterm"/> a Redux application like this:</p><div class="mediaobject"><img src="graphics/5268_08_03.jpg" alt="Redux"/></div><p>So, we've removed the global dependencies. We've almost come full-circle—from our original code to<a id="id204" class="indexterm"/> Flux to Redux.</p><div class="section" title="Using context"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec19"/>Using context</h2></div></div></div><p>As you build increasingly <a id="id205" class="indexterm"/>complex components, you may discover a frustrating side-effect to all this. In Redux, the store acts as a dispatcher. So, if you want to dispatch from components deep within a component hierarchy, you need to pass the store through multiple components that may not even need it themselves.</p><p>Consider, for a moment, building our CMS interface components to dispatch actions directly to the store. We may arrive at a hierarchy similar to this:</p><div class="informalexample"><pre class="programlisting">React.render(
    &lt;PageAdmin <span class="strong"><strong>store={store}</strong></span>&gt;
        {<span class="strong"><strong>store.getState().pages</strong></span>.map((page) =&gt; {
            &lt;Page key={page.id} <span class="strong"><strong>store={store}</strong></span>&gt;
                &lt;PageView {...page} <span class="strong"><strong>store={store}</strong></span> /&gt;
                &lt;PageEditor {...page} <span class="strong"><strong>store={store}</strong></span> /&gt;
            &lt;/Page&gt;
        })}
    &lt;/PageAdmin&gt;
    document.querySelector(".react")
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>Those nested components could also be part of a <code class="literal">render</code> method.</p></div></div><p>It becomes tiresome passing these stores down to each component level in the interface. Fortunately, there is a solution to this problem. It's called <span class="emphasis"><em>context</em></span>, and it works like this. First, we create a new component and modify how things are rendered in <code class="literal">index.js</code>:</p><div class="informalexample"><pre class="programlisting">class Provider extends React.Component {
    <span class="strong"><strong>getChildContext() {</strong></span>
        <span class="strong"><strong>return {</strong></span>
            <span class="strong"><strong>"store": this.props.store</strong></span>
        <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>}</strong></span>
    render() {
        <span class="strong"><strong>return this.props.children;</strong></span>
    }
}

<span class="strong"><strong>Provider.childContextTypes = {</strong></span>
    <span class="strong"><strong>"store": React.PropTypes.object</strong></span>
<span class="strong"><strong>};</strong></span>

console.log(
    ReactDOMServer.renderToString(
        <span class="strong"><strong>&lt;Provider store={store}&gt;</strong></span>
            <span class="strong"><strong>&lt;PageAdmin /&gt;</strong></span>
        <span class="strong"><strong>&lt;/Provider&gt;</strong></span>
    )
);</pre></div><p>The new component is called <code class="literal">Provider</code>, and it renders all nested components without modification. However, it does<a id="id206" class="indexterm"/> define a new life cycle method called <code class="literal">getChildContext</code>. This returns an object with the property values that we want nested components to be given. These values are similar to <code class="literal">props</code>; however, they are implicitly provided to nested components.</p><p>Along with <code class="literal">getChildContext</code>, we also need to define <code class="literal">Provider.childContextTypes</code>. These <code class="literal">React.PropTypes</code> should match what we want to return from <code class="literal">getChildContext</code>. Similarly, we need to modify <code class="literal">PageAdmin</code>:</p><div class="informalexample"><pre class="programlisting">class PageAdmin extends React.Component {
    constructor(props, <span class="strong"><strong>context</strong></span>) {
        super(props, <span class="strong"><strong>context</strong></span>);
        this.state = <span class="strong"><strong>context.store</strong></span>.getState();
        this.onChange = this.onChange.bind(this);
    }
    componentDidMount() {
        this.removeListener =
            <span class="strong"><strong>this.context.store</strong></span>.register(this.onChange);
    }
    componentWillUnmount() {
        this.removeListener();
    }
    onChange() {
        this.setState(<span class="strong"><strong>this.context.store</strong></span>.getState());
    }
    render() {
        return (
            &lt;div&gt;
                &lt;a href="#"
                    onClick={(e) =&gt; {
                        e.preventDefault();

                        <span class="strong"><strong>this.context.store</strong></span>.dispatch({
                            "type": "ADD_PAGE"
                        });
                    }}&gt;
                    add page
                &lt;/a&gt;
                &lt;ol&gt;
                    {<span class="strong"><strong>this.state.pages</strong></span>.map((page) =&gt; {
                        // ...render each page
                    })}
                &lt;/ol&gt;
            &lt;/div&gt;
        );
    }
};

<span class="strong"><strong>PageAdmin.contextTypes = {</strong></span>
    <span class="strong"><strong>"store": React.PropTypes.object</strong></span>
<span class="strong"><strong>};</strong></span>
</pre></div><p>When we define <code class="literal">PageAdmin.contextTypes</code>, we allow components higher up in the hierarchy to provide their context to <code class="literal">PageAdmin</code>. In this case, context will contain a reference to the store. To that <a id="id207" class="indexterm"/>end, we change <code class="literal">props.store</code> to <code class="literal">context.store</code>.</p><p>This is a common occurrence in Redux architecture. It is so common that such a <code class="literal">Provider</code> component comes standard with the Redux tools. We can replace our <code class="literal">Provider</code> implementation with the one imported from <span class="emphasis"><em>ReactRedux</em></span>:</p><div class="informalexample"><pre class="programlisting">import { Provider } from "react-redux";

console.log(
    ReactDOMServer.renderToString(
        &lt;Provider store={store}&gt;
            &lt;PageAdmin /&gt;
        &lt;/Provider&gt;
    )
);</pre></div><p>We don't even need to define <code class="literal">Provider.childContextTypes</code>. We do, however, still need to define <code class="literal">PageAdmin.contextTypes</code> to opt in to the provided context though.</p></div><div class="section" title="Benefits of Redux"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec20"/>Benefits of Redux</h2></div></div></div><p>Redux is growing in popularity, and it's no surprise. It has all the benefits of Flux (such as true unidirectional flow<a id="id208" class="indexterm"/> of data and less coupling to a single backend implementation) without all of the boilerplate. There's much more to learn about it, but what we've covered will set you in great stead to begin architecting better applications!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>You can learn<a id="id209" class="indexterm"/> more about Redux at <a class="ulink" href="https://egghead.io/series/getting-started-with-redux">https://egghead.io/series/getting-started-with-redux</a>. It's a fantastic video course by the creator of Redux.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, you learned about modern architectural design patterns that we can use to build better React applications. We began with the Flux pattern and moved on to Redux.</p><p>In the next chapter, we will look at how to create plugin-based components to allow our interfaces to be extended by others.</p></div></body></html>