- en: Chapter 6. The Builder and Factory Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。生成器和工厂模式
- en: In this chapter, we will showcase the Builder and Factory Patterns, two of the
    most commonly used Creational Design Patterns. These two design patterns have
    some similarities with each other, share some common goals, and are dedicated
    to easing the creation of complex results. We will analyze the benefits that their
    adoption can bring to our implementations and also the ways in which they differ.
    Finally, we will learn how to use them properly and choose the most appropriate
    one for the different use cases of our implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将展示生成器模式和工厂模式，这两种最常用的创建型设计模式之一。这两种设计模式彼此之间有一些相似之处，共享一些共同的目标，并致力于简化复杂结果的创建。我们将分析它们的采用对我们实现的好处，以及它们之间的区别。最后，我们将学习如何正确使用它们，并为我们实现的不同用例选择最合适的模式。
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将：
- en: Introduce the Factory Pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍工厂模式
- en: See how the Factory Pattern is used by jQuery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 jQuery 如何使用工厂模式
- en: Have an example of the Factory Patten in a jQuery application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 jQuery 应用程序中有一个工厂模式示例
- en: Introduce the Builder Pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍生成器模式
- en: Compare the Builder and Factory Patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较生成器模式和工厂模式
- en: See how the Builder Pattern is used by jQuery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 jQuery 如何使用生成器模式
- en: Have an example of the Builder Patten in a jQuery application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 jQuery 应用程序中有一个生成器模式示例
- en: Introducing the Factory Pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍工厂模式
- en: The Factory Pattern is part of the group of Creational Patterns and overall
    it describes a generic way for object creation and initialization. It is commonly
    implemented as an object or function that is used to generate other objects. According
    to the majority of Computer Science resources, the reference implementation of
    the Factory Pattern is described as a class that provides a method that returns
    newly created objects. The returned objects are commonly the instances of a specific
    class or subclass, or they expose a set of specific characteristics.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是创建型模式组中的一部分，总体上描述了一种用于对象创建和初始化的通用方式。它通常实现为一个用于生成其他对象的对象或函数。根据大多数计算机科学资源，工厂模式的参考实现描述为一个提供返回新创建的对象的方法的类。返回的对象通常是特定类或子类的实例，或者它们公开一组特定的特性。
- en: '![Introducing the Factory Pattern](img/00023.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![介绍工厂模式](img/00023.jpeg)'
- en: The key concept of the Factory pattern is to abstract the way an object or a
    group of related objects are created and initialized for a specific purpose. The
    point of this abstraction is to avoid coupling an implementation with specific
    classes or the way that each object instance needs to be created and configured.
    The result is an implementation that works as an abstract way for object creation
    and initialization, which follows the concept of Separation of Concerns.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式的关键概念是抽象出为特定目的创建和初始化对象或一组相关对象的方式。这种抽象的目的是避免将实现与特定类或每个对象实例需要创建和配置的方式耦合在一起。结果是一种按照关注点分离的概念来进行对象创建和初始化的实现。
- en: The resulting implementations are only based on the object methods and properties
    that are required by their algorithm or business logic. Such an approach can benefit
    the modularity and extensibility of an implementation, by following the concept
    of programming over Object Features and Functionality instead of Object Classes.
    This gives us the flexibility to change the used classes with any other object
    that exposes the same functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的实现仅基于其算法或业务逻辑所需的对象方法和属性。这种方法可以通过遵循编程的概念而不是对象类的功能和功能来受益于实现的模块化和可扩展性。这使我们可以灵活地将所使用的类更改为任何其他公开相同功能的对象。
- en: How it is adopted by jQuery
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何被 jQuery 采用的
- en: As we have already noted in the earlier chapters, one of the early goals of
    jQuery was to provide a solution that worked the same across all browsers. The
    1.12.x version series of jQuery are focused on providing support for browsers
    as old as Internet Explorer 6 (IE6), while maintaining the same API with the newer
    v2.2.x versions that only focus on modern browsers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在早期章节中已经注意到的那样，jQuery 的早期目标之一是提供一种在所有浏览器上都能够正常工作的解决方案。jQuery 1.12.x 版本系列专注于为老旧的
    Internet Explorer 6（IE6）提供支持，同时保持与仅关注现代浏览器的较新版本 v2.2.x 相同的 API。
- en: In order to have a similar structure and maximize the common code between the
    two versions, the jQuery team tried to abstract most compatibility mechanisms
    in a different implementation layer. Such a development practice greatly improves
    the readability of the code and reduces the complexity of the main implementation,
    encapsulating it into different smaller pieces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有类似的结构并最大化两个版本之间的公共代码，jQuery 团队试图在不同的实现层中抽象出大部分兼容性机制。这样的开发实践极大地提高了代码的可读性，并减少了主要实现的复杂性，将其封装成不同的较小的片段。
- en: 'A great example of this is the implementation of the AJAX-related methods that
    jQuery provides. Specifically, in the following code, you can find a part of it,
    as found in version 1.12.0 of jQuery:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很好的例子是 jQuery 提供的与 AJAX 相关方法的实现。具体来说，在以下代码中，您可以找到它的一部分，就像在 jQuery 的 1.12.0
    版本中找到的那样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every time a new AJAX request is issued on jQuery, the `jQuery.ajaxSettings.xhr`
    method is used as a Factory that creates a new instance of the appropriate XHR
    object based on the support of the current browser. Looking in more detail, we
    can see that the `jQuery.ajaxSettings.xhr` method orchestrates the use of two
    smaller Factory functions, with each responsible for a specific implementation
    of AJAX. Moreover, we can see that it actually tries to avoid running the compatibility
    tests on every call by directly wiring up its reference to the smaller `createStandardXHR`
    Factory function when appropriate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在 jQuery 上发出新的 AJAX 请求时，`jQuery.ajaxSettings.xhr`方法被用作一个工厂，根据当前浏览器的支持创建一个新的适当的
    XHR 对象的实例。更详细地看，我们可以看到`jQuery.ajaxSettings.xhr`方法协调使用两个更小的工厂函数，每个函数负责特定的 AJAX
    实现。此外，我们可以看到它实际上试图避免在每次调用时都运行兼容性测试，而是在适当时直接将其引用连接到较小的`createStandardXHR`工厂函数。
- en: Using Factories in our applications
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用工厂
- en: As an example use case of Factories, we will create a data-driven form where
    our users will be able to fill some fields that are dynamically created and inserted
    into the page. We will assume the existence of an array containing objects that
    describe each form field that needs to be presented. Our Factory method will encapsulate
    the way in which each form field needs to be constructed, and properly handle
    each specific case, based on the characteristics defined on the related objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为工厂的一个示例用例，我们将创建一个数据驱动的表单，其中我们的用户将能够填写一些动态创建并插入到页面中的字段。我们将假设存在一个包含描述每个需要呈现的表单字段的对象的数组。我们的工厂方法将封装每个表单字段需要被构建的方式，并根据相关对象上定义的特征正确处理每个特定的情况。
- en: '![Using Factories in our applications](img/00024.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的应用程序中使用工厂](img/00024.jpeg)'
- en: 'The HTML code for this page is quite simple:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的 HTML 代码非常简单：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It only contains an `<h1>` element with the page heading and an empty `<form>`
    element that will host the generated fields. As for the CSS used, we only style
    the `<button>` elements in the same way as we did in the previous chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它只包含一个`<h1>`元素，用于页面标题，以及一个空的`<form>`元素，用于承载生成的字段。至于使用的 CSS，我们只对`<button>`元素进行了样式化，与之前的章节中所做的方式相同。
- en: 'As for the JavaScript implementation of the application, we create a module
    and declare `dataDrivenForm` as the namespace of this example. This module will
    contain the data that describes our form, the Factory method that will generate
    the HTML of each form element and, of course, the initialization code that will
    combine the aforementioned parts to create the resulting form:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 至于应用程序的 JavaScript 实现，我们创建一个模块，并声明`dataDrivenForm`为这个示例的命名空间。这个模块将包含描述我们表单的数据，生成每个表单元素的
    HTML 的工厂方法，当然还有将上述部分组合起来创建结果表单的初始化代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our Factory method will be invoked with three parameters. Starting from the
    most important one, it accepts the `type` and the `name` of the form field and
    also the `title` that will be used as its description. Since most form fields
    share some common characteristics, like their title, the Factory method tries
    to abstract them in order to have less code repetition. As you can see, the Factory
    method also contains some sensible extra configuration for each field type, like
    the `maxlength` attribute of the text fields, that is specific for this use case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂方法将被调用三个参数。从最重要的开始，它接受表单字段的`类型`和`名称`，以及将用作其描述的`标题`。由于大多数表单字段共享一些共同的特征，比如它们的标题，工厂方法试图将它们抽象出来，以减少代码重复。正如您所见，工厂方法还为每种字段类型包含一些合理的额外配置，比如文本字段的`maxlength`属性，这是特定用例的特定属性。
- en: 'The object structure that will be used to represent each form element will
    be a plain JavaScript object that has a `type`, `name`, and `title` property.
    The collection of objects that describe the form fields will be grouped in an
    array and be available on the `dataDrivenForm.parts` property of our module. In
    a real-world application, these fields would commonly either be retrieved with
    an AJAX request or be injected into some part of the HTML of the page. In the
    following code snippet, we can see the data that will be used to drive the creation
    of our form:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将用于表示每个表单元素的对象结构将是一个简单的JavaScript对象，它具有`type`、`name`和`title`属性。描述表单字段的对象集合将被分组在一个数组中，并在我们的模块的`dataDrivenForm.parts`属性上可用。在实际应用中，这些字段通常会通过AJAX请求检索，或者被注入到页面的某个部分中。在以下代码片段中，我们可以看到将用于驱动我们的表单创建的数据：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we define and immediately invoke an `init` method for our module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义并立即调用了一个`init`方法来初始化我们的模块：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The initialization code waits until the DOM of the page is fully loaded and
    then uses the Factory method to create the form elements and attach them to the
    `<form>` element of our page. An extra concern of the preceding code is to check
    the result of the Factory method invocation before actually starting to use it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化代码会等待页面的DOM完全加载，然后使用工厂方法创建表单元素并将它们附加到页面的`<form>`元素上。在实际使用之前，上述代码的一个额外关注点是检查工厂方法调用的结果是否有效。
- en: Most Factories, when invoked with parameters for a case they can't handle, return
    `null` or empty objects. As a result, it's a good common practice, when using
    Factories, to check whether the result of each invocation is actually valid.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工厂在使用不能处理的情况下被调用时，会返回`null`或空对象。因此，使用工厂时，检查每次调用的结果是否实际有效是一个很好的常见做法。
- en: As you can see, having Factories that accept only simple parameters (for example,
    strings and numbers), in many cases, leads to an increased number of parameters.
    Even though these parameters may only be used in specific cases, the API of our
    Factory starts to be awkwardly long and needs proper documentation for each special
    case in order to be usable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，仅接受简单参数（例如字符串和数字）的工厂，在许多情况下会导致参数数量增加。即使这些参数只在特定情况下使用，我们的工厂的API也开始变得尴尬而冗长，并且需要针对每个特殊情况进行适当的文档编写，以便可用。
- en: Ideally, a Factory method should accept as few arguments as possible, otherwise
    it will start looking like a Facade that only provides a different API. Since,
    in some cases, using a single string or numeric argument does not suffice, in
    order to avoid using a huge number of parameters, we can follow a practice where
    the Factory is designed to accept a single object as its parameter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，工厂方法应尽量接受尽可能少的参数，否则它将开始看起来像一个仅提供不同API的Facade。由于在某些情况下，仅使用单个字符串或数值参数不足以满足要求，为了避免使用大量参数，我们可以遵循一种做法，即设计工厂以接受单个对象作为其参数。
- en: 'For example, in our case, we can just pass the whole object that describes
    the form field as a parameter to the Factory method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的情况下，我们可以将描述表单字段的整个对象作为参数传递给工厂方法：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This practice is suggested for the following cases:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法适用于以下情况：
- en: When we create generic Factories that are not focused on specific use cases
    and we need to configure their results differently for each specific use case.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们创建的工厂是不专注于特定用例的通用工厂，并且我们需要为每个特定用例分别配置它们的结果时。
- en: When the constructed objects have many optional configuration parameters that
    largely differ. In this case, adding them as separate parameters to the Factory
    method would lead to invocations that have a number of `null` arguments, depending
    on which exact argument we are interested in defining.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构造的对象具有许多可选配置参数且差异很大时。在这种情况下，将它们作为单独的参数添加到工厂方法中将导致调用具有一些`null`参数，具体取决于我们想要定义哪个确切的参数。
- en: Another practice, especially in JavaScript programming, is to create a Factory
    method that accepts a simple string or numeric value as its first argument and
    optionally provide a complementary object as a second parameter. This enables
    us to have a simple generic API that can be use-case-specific and also gives us
    some extra points of freedom to configure some special cases. This approach is
    used by the `$.ajax( url [, settings ] )` method that allows us to generate simple
    GET requests by just providing a URL and also accepts an optional `settings` parameter
    that allows us to configure any aspect of the request. Changing the above implementation
    to use this variation is left as an exercise for the reader, in order to experiment
    and get familiar with the use of Factory methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法，特别是在JavaScript编程中，是创建一个工厂方法，该方法接受一个简单的字符串或数字值作为其第一个参数，并可选地提供一个补充对象作为第二个参数。这使我们能够拥有一个简单的通用API，可以特定于用例，并且还为我们提供了一些额外的自由度来配置一些特殊情况。这种方法被`$.ajax(
    url [, settings ] )`方法所使用，该方法允许我们通过只提供URL来生成简单的GET请求，还接受一个可选的`settings`参数，允许我们配置请求的任何方面。将上述实现更改为使用此变体留作读者的练习，以便进行实验并熟悉工厂方法的使用。
- en: Introducing the Builder Pattern
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍建造者模式
- en: The Builder Pattern is part of the group of Creational Patterns and provides
    us a way to create objects that require a lot of configuration before they reach
    the point where they can be used. The Builder Pattern is often used for objects
    that accept many optional parameters in order to define their operation. Another
    matching case is for the creation of objects where their configuration needs to
    be done in several steps or in a specific order.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式是创建模式组中的一部分，为我们提供了一种在达到可以使用的点之前需要大量配置的对象的创建方法。建造者模式通常用于接受许多可选参数以定义其操作的对象。另一个匹配的案例是创建需要在几个步骤或特定顺序中完成配置的对象。
- en: The common paradigm for the Builder Pattern according to Computer Science is
    that there is a Builder Object that provides one or more setter methods (`setA(...)`,
    `setB(...)`) and a single generation method that constructs and returns the newly
    created result object (`getResult()`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据计算机科学的共同范例，建造者模式的常见范式是有一个建造者对象，提供一个或多个设置方法（`setA（...）`，`setB（...）`），以及一个单独的生成方法，用于构建并返回新创建的结果对象（`getResult（）`）。
- en: '![Introducing the Builder Pattern](img/00025.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![介绍建造者模式](img/00025.jpeg)'
- en: This pattern has two important concepts. The first one is that the Builder Object
    exposes a number of methods as a way to configure the different parts of the object
    that is under construction. During the configuration phase, the Builder Object
    preserves an internal state that reflects the effects of the invocations of the
    provided setter methods. This can be beneficial when used to create objects that
    accept a large number of configuration parameters, solving the problem of Telescopic
    Constructors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式有两个重要概念。第一个是建造者对象公开一些方法作为配置正在构建的对象的不同部分的一种方式。在配置阶段，建造者对象保留一个内部状态，反映了所提供的设置方法的调用的效果。当用于创建接受大量配置参数的对象时，这可能是有益的，解决了拖尾构造函数的问题。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Telescopic Constructors is an anti-pattern of object-oriented programming that
    describes the situation where a class provides several constructors that tend
    to differ on the number, the type, and the combination of the arguments that they
    require. Object classes with several parameters that can be used in many different
    combinations can often lead to implementations falling into this anti-pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拖尾构造函数是面向对象编程的反模式，描述了一个类提供了几个构造函数，这些构造函数往往在所需参数的数量，类型和组合上有所不同。具有多个参数可以以许多不同组合使用的对象类通常会导致实现落入这种反模式中。
- en: The second important concept is that it also provides a generation method that
    returns the actual constructed object based on the preceding configuration. Most
    of the time, the instantiation of the requested object is done lazily and actually
    takes place at the moment that this method is invoked. In some cases, the Builder
    Object allows us to invoke the generation method more than once, allowing us to
    generate several objects with the same configuration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要概念是它还提供了一个生成方法，根据前述配置返回实际构造的对象。大多数情况下，请求对象的实例化是惰性进行的，并且实际上是在调用此方法的时候发生的。在某些情况下，建造者对象允许我们调用生成方法超过一次，从而使我们能够使用相同配置生成多个对象。
- en: How it is adopted by jQuery's API
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何被 jQuery 的 API 接受
- en: 'The Builder Pattern can also be found as part of the API that jQuery exposes.
    Specifically, the jQuery `$()` function can also be used to create new DOM elements
    by invoking it with an HTML string as an argument. As a result, we can create
    new DOM elements and set their different parts as we need them, instead of having
    to create the exact HTML string that is needed for the final result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者模式也可以作为 jQuery 公开的 API 的一部分找到。具体来说，jQuery 的 `$()` 函数也可以通过使用 HTML 字符串作为参数来创建新的
    DOM 元素。因此，我们可以创建新的 DOM 元素并根据需要设置它们的不同部分，而不必创建所需的最终结果的确切 HTML 字符串：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `$('<input />')` call returns a Composite Object containing an element that
    is not attached to the DOM tree of the page. This unattached element is only an
    in-memory object that is neither fully constructed nor fully functional until
    we attach it to the page. In this case, this Composite Object acts like a Builder
    Object Instance having an internal state of objects that are not yet finalized.
    Right after this, we do a series of manipulations on it using some jQuery methods
    that act like the setter methods described by the Builder Pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''<input />'')` 调用返回一个包含未附加到页面的 DOM 树的元素的复合对象。这个未附加的元素只是一个内存对象，直到我们将其附加到页面为止，它既不完全构造也不完全功能。在这种情况下，此复合对象就像一个具有尚未最终化的对象内部状态的构建对象实例。在此之后，我们使用一些
    jQuery 方法对其进行一系列操作，这些方法就像建造者模式描述的设置器方法一样。'
- en: Finally, after we apply all the required configurations, so that the resulting
    object behaves in the desired way, we invoke the `$.fn.appendTo()` method. The
    `$.fn.appendTo()` method works as the generation method of the Builder Pattern,
    by attaching the in-memory element of the `$input` variable to the DOM tree of
    the page, transforming it into an actual attached DOM element.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们应用所有必需的配置之后，使得生成的对象以期望的方式行为，我们调用 `$.fn.appendTo()` 方法。`$.fn.appendTo()`
    方法作为建造者模式的生成方法，将 `$input` 变量的内存元素附加到页面的 DOM 树上，将其转换为实际附加的 DOM 元素。
- en: 'Of course, the above example can get more readable and less repetitive by utilizing
    the Fluent API that jQuery provides for its methods, and also combine the `$.fn.attr()`
    method invocations. Moreover, jQuery allows us to use almost all its methods to
    do traversals and manipulations on the elements that are under construction, just
    as we can on normal DOM element Composite Objects. As a result, the above example
    can get a little more complete as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过利用 jQuery 为其方法提供的流式 API，并组合 `$.fn.attr()` 方法调用，以上示例可以变得更易读且不太重复。此外，jQuery
    允许我们使用几乎所有其方法来在构建中的元素上执行遍历和操作，就像我们可以在普通 DOM 元素的复合对象上执行的那样。因此，以上示例可以更完整地如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result will look as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![How it is adopted by jQuery''s API](img/00026.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![它如何被 jQuery 的 API 接受](img/00026.jpeg)'
- en: 'The criteria that allow us to categorize this overloaded way of invoking the
    `$()` function as an implementation that adopts the Builder Pattern, is the fact
    that:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们将调用 `$()` 函数的这种过载方式归类为采用建造者模式的实现的标准是：
- en: It returns an object with an internal state containing partially constructed
    elements. The contained elements are only in-memory objects that are not part
    of the page's DOM tree.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个具有包含部分构造元素的内部状态的对象。所包含的元素仅是内存对象，不是页面 DOM 树的一部分。
- en: It provides us methods to manipulate its internal state. Most jQuery methods
    can be used for this purpose.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为我们提供了操作其内部状态的方法。大多数 jQuery 方法都可以用于此目的。
- en: It provides us method(s) to generate the final result. We can use jQuery methods
    such as `$.fn.appendTo()` and `$.fn.insertAfter()`, as a way to complete the construction
    of the internal elements and make them part of the DOM tree with properties that
    reflect their earlier in-memory representation.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为我们提供了生成最终结果的方法。我们可以使用 jQuery 方法，例如 `$.fn.appendTo()` 和 `$.fn.insertAfter()`，作为完成内部元素构造并使其成为具有反映其较早内存表示的属性的
    DOM 树的一部分的方法。
- en: 'As we have already seen in [Chapter 1](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef
    "Chapter 1. A Refresher on jQuery and the Composite Pattern"), *A Refresher on
    jQuery and the Composite Pattern*, the primary way to use the `$()` function is
    to invoke it with a CSS selector as a string parameter and in turn it will retrieve
    the matching page elements and return them in a Composite Object. On the other
    hand, when the `$()` function detects that it has been invoked with a string parameter
    that looks like a piece of HTML, it works as a DOM element Builder. This overloaded
    way of invoking the `$()` function bases its detection on the assumption that
    the provided HTML code starts and ends with the inequality symbols `<` and `>`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经在[第 1 章](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef
    "Chapter 1. A Refresher on jQuery and the Composite Pattern") *jQuery 和组合模式的复习*中看到的，使用
    `$()` 函数的主要方法是将其与 CSS 选择器作为字符串参数调用，然后它将检索匹配的页面元素并以组合对象返回它们。另一方面，当 `$()` 函数检测到它已被调用的字符串参数看起来像一个
    HTML 片段时，它将作为 DOM 元素生成器。这种重载的 `$()` 函数的调用方式基于提供的 HTML 代码以 `<` 和 `>` 不等号符号开始和结束的假设：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see in the preceding code, this overload uses the `jQuery.parseHTML()`
    helper method that ultimately leads to a call of the `createDocumentFragment()`
    method. The created **Document Fragment** is then used as a host of the under
    construction tree structure of elements. After jQuery finishes converting the
    HTML into elements, the Document Fragment is discarded and only it''s hosted elements
    are returned:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，这个重载使用了 `jQuery.parseHTML()` 辅助方法，最终导致调用 `createDocumentFragment()`
    方法。创建的**文档片段**然后被用作正在构建的元素树结构的宿主。在 jQuery 完成将 HTML 转换为元素之后，文档片段被丢弃，只返回其托管的元素：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This results in the creation of a new jQuery Composite Object containing an
    in-memory tree structure of elements. Even though these elements are not attached
    to the actual DOM tree of the page, we can still do traversals and manipulations
    on them like any other jQuery Composite Object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致创建一个包含内存中元素树结构的新 jQuery 组合对象。尽管这些元素未附加到页面的实际 DOM 树上，我们仍然可以像对待任何其他 jQuery
    组合对象一样对它们进行遍历和操作。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on Document Fragments, you can visit: [https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关文档片段的更多信息，您可以访问：[https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment)。
- en: How it is used by jQuery internally
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部使用 jQuery 的方法
- en: 'An undoubtedly big part of jQuery is its AJAX-related implementation, which
    aims to provide a simple API for asynchronous calls that is also configurable
    to a large degree. Using the jQuery Source Viewer and searching for `jQuery.ajax`,
    or directly searching jQuery''s source code for `"ajax:"`, will bring us the aforementioned
    implementation. In order to make its implementation more straightforward and also
    allow it to be configurable, jQuery internally uses a special object structure
    that acts as a Builder Object for the creation and handling of each AJAX request.
    As we will see, this is not the most common way of using a Builder Object, but
    it is actually a special variant with some modifications in order to fit the requirements
    of this complex implementation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的一个毫无疑问的重要部分是其与 AJAX 相关的实现，其目标是提供一个简单的 API 用于异步调用，同时也可以在很大程度上进行配置。使用
    jQuery 源代码查看器并搜索 `jQuery.ajax`，或直接在 jQuery 的源代码中搜索 `"ajax:"`，将带来上述实现。为了使其实现更加直接并允许其进行配置，jQuery
    内部使用一种特殊的对象结构，该结构充当了用于创建和处理每个 AJAX 请求的生成器对象。正如我们将看到的，这不是使用生成器对象的最常见方式，但实际上是一种具有一些修改以适应这个复杂实现要求的特殊变体：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main method that the `jqXHR` object exposes to configure the generated asynchronous
    request is the `setRequestHeader()` method. The implementation of this method
    is quite generic, enabling jQuery to set all the different HTTP headers for the
    request, using only one method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`jqXHR` 对象公开用于配置生成的异步请求的主要方法是 `setRequestHeader()` 方法。这个方法的实现相当通用，使得 jQuery
    可以使用一个方法设置请求的所有不同 HTTP 标头。'
- en: 'In order to provide an even greater degree of flexibility and abstraction,
    jQuery internally uses a separate `transport` object as a wrapper of the `jqXHR`
    object. This transport object handles the part of actually sending the AJAX request
    to the server, working like a *partner builder object* that cooperates with the
    `jqXHR` object for the creation of the final result. This way, jQuery can fetch
    Scripts, XML, JSON, and JSONP responses from the same or cross-origin servers,
    using the same API and overall implementation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '为了提供更大程度的灵活性和抽象性，jQuery 内部使用一个单独的`transport`对象作为`jqXHR`对象的包装器。这个传输对象处理实际将 AJAX
    请求发送到服务器的部分，像一个与`jqXHR`对象合作创建最终结果的*合作构建器对象*。这样，jQuery 可以使用相同的 API 和整体实现从相同或跨域服务器获取脚本、XML、JSON
    和 JSONP 响应：  '
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another special thing about this implementation of the Builder Pattern is that
    it should be able to operate in both synchronous and asynchronous manner. As a
    result, the `send()` method of the `transport` object that acts as the result
    generator method of the wrapped `jqXHR` object can't just return a result object,
    but it is instead invoked with a callback.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构建器模式的实现的另一个特殊之处是，它应该能够以同步和异步方式操作。因此，`transport`对象的`send()`方法，它作为包装的`jqXHR`对象的结果生成方法，不能只返回一个结果对象，而是需要使用回调来调用它。
- en: Finally, after the request is complete, jQuery uses the `getResponseHeader()`
    method to retrieve all the required response headers. Right after this, the headers
    are used to properly convert the received response that is stored in the `responseText`
    property of the `jqXHR` object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在请求完成后，jQuery 使用`getResponseHeader()`方法检索所有必需的响应标头。紧接着，标头被用于正确转换存储在`jqXHR`对象的`responseText`属性中的接收到的响应。
- en: How to use it in our applications
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在我们的应用程序中使用它
- en: As an example use case of the Builder Pattern in a client-side application that
    uses jQuery, we will create a simple data-driven multiple-choice quiz. The main
    reason that the Builder Pattern is a better match for this case, as compared to
    the Factory Pattern example that we saw earlier, is that the result is more complex
    and has more degrees of configuration. Each question will be generated based on
    a model object that will represent its desired properties.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在使用 jQuery 的客户端应用程序中使用构建器模式的示例用例，我们将创建一个简单的数据驱动多选题测验。与我们之前看到的工厂模式示例相比，构建器模式更适合这种情况的主要原因是结果更复杂，具有更多的配置度。每个问题都将基于一个模型对象生成，该对象将表示其所需的属性。
- en: '![How to use it in our applications](img/00027.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的应用程序中如何使用它](img/00027.jpeg)'
- en: 'Once again, the required HTML is very simple, containing just an `<h1>` element
    with the header of the page, an empty `<form>` tag, and some references to our
    CSS and JavaScript resources:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所需的 HTML 非常简单，只包含一个页面标题的`<h1>`元素，一个空的`<form>`标签，以及对我们的 CSS 和 JavaScript
    资源的一些引用：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Besides the common, simple styles that we have seen in the previous chapters,
    the CSS of this example additionally defines:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在之前章节中看到的常见的简单样式之外，这个示例的 CSS 还额外定义了：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the needs of this example, we will create a module with a new namespace
    named `dataDrivenQuiz`. As we saw earlier in this chapter, we will assume the
    existence of an array containing the model objects that describe each multiple-choice
    question that needs to be presented. Each of these model objects will have:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子的需要，我们将创建一个带有新命名空间`dataDrivenQuiz`的模块。正如我们在本章前面看到的，我们将假设存在一个数组，其中包含描述需要呈现的每个多选题的模型对象。每个这些模型对象都将具有：
- en: A `title` property that will hold the question
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`title`属性，将保存问题
- en: An `options` property that will be an array with the available answers to choose
    from
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`options`属性，将是一个包含可供选择的答案的数组
- en: An optional `acceptsMultiple` property to signify whether we should use radio
    or check boxes
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`acceptsMultiple`属性，表示我们应该使用单选按钮还是复选框
- en: 'The array with the model objects that describe the form questions will be available
    at the `dataDrivenQuiz.parts` property of our module, while keeping in mind that
    our implementation could easily be modified to fetch the models with an AJAX request:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 描述表单问题的模型对象数组将在我们的模块的`dataDrivenQuiz.parts`属性中可用，同时要牢记我们的实现可以轻松地修改为使用 AJAX 请求获取模型：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Defining the data structures that are required to describe a problem, before
    starting the actual implementation, allows us to focus on the needs of the application
    and get an estimate of its overall complexity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际实现之前，定义描述问题所需的数据结构使我们能够专注于应用程序的需求，并对其整体复杂性进行估算。
- en: 'Given the preceding sample data, let''s now proceed to the implementation of
    our Builder:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前述示例数据，现在让我们继续实现我们的构建器：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the Prototypical Object-Oriented approach of JavaScript, we firstly define
    the Constructor Function for our `MultipleChoiceBuilder` class. When the Constructor
    Function is invoked using the `new` operator, it will create a new instance of
    the Builder and initialize its `title` property to `"Untitled"` and the `options`
    property to an empty array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript的原型面向对象方法，我们首先为我们的`MultipleChoiceBuilder`类定义构造函数。当使用`new`运算符调用构造函数时，它将创建一个新的构建器实例，并将其`title`属性初始化为`"Untitled"`，将`options`属性初始化为空数组。
- en: Right after this, we complete the definition of the Constructor Function of
    our Builder, we attach it as a member of our module, and continue with the definition
    of its setter methods. Following the Prototypical Class paradigm, the `setTitle()`,
    `setAcceptsMultiple()`, and `addOption()` methods are defined as properties of
    our Builder's Prototype and are used to modify the internal state of the under
    construction element. Additionally, in order to enable us to chain several invocations
    of these methods, which results in a more readable implementation, all of them
    end with the `return this;` statement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，我们完成了构建器的构造函数的定义，将其作为模块的成员附加，并继续定义其设置器方法。遵循原型类范例，`setTitle()`、`setAcceptsMultiple()`和`addOption()`方法被定义为构建器原型的属性，并用于修改正在构建的元素的内部状态。另外，为了使我们能够链式调用这些方法的多个调用，从而获得更可读的实现，它们都以`return
    this;`语句结束。
- en: We complete the implementation of the Builder with the `getResult()` method
    that has the duty of gathering all the parameters that are applied on the Builder
    object instance and generating the resulting element wrapped inside a jQuery Composite
    Object. In its first line, it creates a header of the question. Right after this,
    it creates a `<ul>` element with the `unstyled` CSS class to hold the possible
    answers to the question and a unique identifier that will be used as the `name`
    of the generated `<input>` of the question.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getResult()`方法完成构建器的实现，该方法负责收集应用于构建器对象实例的所有参数，并生成包装在jQuery组合对象中的结果元素。在其第一行，它创建了一个问题的标题。紧接着，它创建一个带有`unstyled`
    CSS类的`<ul>`元素，用于容纳问题的可能答案，并使用一个唯一标识符作为问题生成的`<input>`的`name`。
- en: 'In the for loop that follows, we will:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的`for`循环中，我们将：
- en: Create an `<input />` element for each option of the question
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问题的每个选项创建一个`<input />`元素。
- en: Properly set its `type` as a `checkbox` or a `radio` button, based on the value
    of the `acceptsMultiple` property
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据`acceptsMultiple`属性的值，将其`type`适当设置为`checkbox`或`radio`按钮。
- en: Use the for loop's iteration number as its `value`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环的迭代编号作为其`value`。
- en: Set the unique identifier that we generated earlier for the question as the
    input's `name` in order to group the answers
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们之前生成的问题的唯一标识符设置为输入的`name`，以便将答案分组。
- en: Finally, add a `<label>` with the option's text, which wraps all of them inside
    an `<li>`, and append it to the question's `<ul>`.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在问题的`<ul>`中添加包含选项文本的`<label>`，并将其全部包装在一个`<li>`中。
- en: Lastly, the header and the list of options are wrapped in an `<article>` element,
    which is then returned as the final result of the Builder.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，标题和选项列表都被包装在一个`<article>`元素中，并作为构建器的最终结果返回。
- en: In the above implementation, we use the `$.fn.text()` method to assign the content
    of the question's header and its available choices instead of string concatenation,
    in order to properly escape the `<` and `>` characters that are found in their
    descriptions. As an extra note, since some of the answers also contain single
    quotes, we need to escape them in the model objects using a backslash (`\'`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述实现中，我们使用`$.fn.text()`方法为问题的标题及其可用选择分配内容，而不是使用字符串连接，以便正确转义其中的`<`和`>`字符。额外说明，由于一些答案也包含单引号，我们需要在模型对象中使用反斜杠(`\'`)对它们进行转义。
- en: 'Finally, in our module''s implementation, we define and immediately invoke
    the `init` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们模块的实现中，我们定义并立即调用`init`方法：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The execution of the initialization code is delayed until the DOM tree of the
    page is fully loaded. Then the `init()` method iterates over the model objects
    array and uses the Builder to create each question and populate the `<form>` element
    of our page.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化代码的执行被延迟，直到页面的 DOM 树完全加载完成。然后，`init()` 方法遍历模型对象数组，并使用 Builder 创建每个问题，并填充我们页面的`<form>`元素。
- en: A good exercise for the reader would be to extend the above implementation in
    order to support the client-side evaluation of the quiz. Firstly, this would require
    you to extend the question objects to contain information about the validity of
    each choice. Then, it would be suggested that you create a Builder that would
    retrieve the answers from the form, evaluate them, and create a result object
    with the user choices and the overall success on the quiz.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读者来说，一个很好的练习是扩展上述实现，以支持对测验的客户端评估。首先，这需要您扩展问题对象以包含有关每个选项有效性的信息。然后，建议您创建一个 Builder，该
    Builder 将从表单中获取答案，评估它们，并创建一个包含用户选择和测验总体成功的结果对象。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the concepts of the Builder and Factory Patterns,
    two of the most commonly used Creational Design Patterns. We analyzed their common
    goals, their different approaches on abstracting the process of generating and
    initializing new objects for specific use cases, and how their adoption can benefit
    our implementations. Finally, we learned how to use them properly and how to choose
    the most appropriate one for the different use cases of any given implementations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Builder 和 Factory 模式的概念，这两种是最常用的创建型设计模式之一。我们分析了它们的共同目标，它们在抽象生成和初始化特定用例的新对象过程方面的不同方法，以及它们的采用如何使我们的实现受益。最后，我们学习了如何正确使用它们，并如何为任何给定实现的不同用例选择最合适的模式。
- en: Now that we have completed our introduction to the most important Creational
    Design Patterns, we can move on to the next chapter where we will be introduced
    to the development patterns that are used to program asynchronous and concurrent
    procedures. In more detail, we will learn how to orchestrate the execution of
    asynchronous procedures that run either in order or parallel to each other, by
    using callbacks and jQuery Deferred and Promises APIs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对最重要的创建型设计模式的介绍，我们可以继续下一章，介绍用于编写异步和并发程序的开发模式。更详细地说，我们将学习如何通过使用回调和 jQuery
    Deferred 和 Promises API 来编排顺序或并行运行的异步程序的执行。
