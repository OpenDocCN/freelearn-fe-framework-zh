- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Writing Your First Cucumber Test
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个Cucumber测试
- en: Test-driven development is primarily a process for developers. Sometimes, customers
    and product owners want to see the results of automated tests too. Unfortunately,
    the humble unit test that is the foundation of TDD is simply too low-level to
    be helpful to non-developers. That’s where the idea of **Behavior Driven Development
    (BDD)** comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发主要是一个面向开发者的过程。有时，客户和产品所有者也想看到自动化测试的结果。不幸的是，作为TDD基础的谦逊的单元测试太低级，对非开发者没有帮助。这就是**行为驱动开发（BDD）**理念出现的地方。
- en: 'BDD tests have a few characteristics that set them apart from the unit tests
    you’ve seen so far:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: BDD测试有一些特性，使它们与您迄今为止看到的单元测试有所不同：
- en: They are **end-to-end tests** that operate across the entire system.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是**端到端测试**，在整个系统中运行。
- en: They are written in natural language rather than code, which is understandable
    by non-coders and coders alike.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是用自然语言而不是代码编写的，既可被非编码者理解，也可被编码者理解。
- en: They avoid making references to internal mechanics, instead focusing on the
    outward behavior of the system.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们避免提及内部机制，而是专注于系统的外部行为。
- en: The test definition describes itself (with unit tests, you need to write a test
    description that matches the code).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试定义描述了自身（与单元测试不同，您需要编写一个与代码匹配的测试描述）。
- en: The syntax is designed to ensure that your tests are written as examples, and
    as discrete specifications of behavior.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法设计是为了确保您的测试被编写为示例，并且作为行为的离散规范。
- en: BDD tools vs TDD vs unit tests
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: BDD工具与TDD和单元测试的比较
- en: The style of TDD you’ve seen so far in this book treats (for the most part)
    its tests as examples that specify behavior. Also, our tests were always written
    in the **Arrange-Act-Assert (AAA)** pattern. However, notice that unit test tools
    such as Jest do not force you to write tests this way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这本书中迄今为止看到的TDD风格将测试（在大多数情况下）视为指定行为的示例。此外，我们的测试始终遵循**安排-行动-断言（AAA）**模式。然而，请注意，单元测试工具如Jest并不强迫您以这种方式编写测试。
- en: 'This is one reason why BDD tools exist: to force you to be very clear when
    you specify the behavior of your system.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么存在BDD工具的原因之一：在您指定系统行为时，迫使您非常明确。
- en: 'This chapter introduces two new software packages: Cucumber and Puppeteer.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两个新的软件包：Cucumber和Puppeteer。
- en: We’ll use Cucumber to build our BDD tests. Cucumber is a system that exists
    for many different programming environments, including Node.js. It consists of
    a test runner that runs tests contained within **feature files**. Features are
    written in a plain-English language known as **Gherkin**. When Cucumber runs your
    tests, it translates these feature files into function calls; these function calls
    are written in JavaScript **support scripts**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Cucumber来构建我们的BDD测试。Cucumber是一个存在于许多不同编程环境中的系统，包括Node.js。它由一个测试运行器组成，该运行器运行包含在**特性文件**中的测试。特性是用一种称为**Gherkin**的普通英语编写的。当Cucumber运行您的测试时，它将这些特性文件转换为函数调用；这些函数调用是用JavaScript
    **支持脚本**编写的。
- en: Since Cucumber has its own test runner, it doesn’t use Jest. However, we will
    make use of Jest’s `expect` package in some of our tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cucumber有自己的测试运行器，因此它不使用Jest。然而，我们将在一些测试中利用Jest的`expect`包。
- en: Cucumber is not the only way to write system tests
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber不是编写系统测试的唯一方式
- en: Another popular testing library is Cypress, which may be a better choice for
    you and/or your team. Cypress puts the emphasis on the visual presentation of
    results. I tend to avoid it because its API is very different from industry-standard
    testing patterns, which increases the amount of knowledge developers need to have.
    Cucumber is cross-platform and tests look very similar to the standard unit tests
    you’ve seen throughout this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的测试库是Cypress，它可能更适合您和/或您的团队。Cypress强调结果的视觉呈现。我倾向于避免使用它，因为它的API与行业标准测试模式非常不同，这增加了开发者需要具备的知识量。Cucumber是跨平台的，测试看起来与您在这本书中看到的标准单元测试非常相似。
- en: '**Puppeteer** performs a similar function to the JSDOM library. However, while
    JSDOM implements a fake DOM API within the Node.js environment, Puppeteer uses
    a real web browser, Chromium. In this book, we’ll use it in *headless* mode, which
    means you won’t see the app running onscreen; but you can, if you wish, turn headless
    mode off. Puppeteer comes with all sorts of bolt-ons, such as the ability to take
    screenshots.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Puppeteer**与JSDOM库执行类似的功能。然而，虽然JSDOM在Node.js环境中实现了一个假的DOM API，Puppeteer则使用真实的网络浏览器Chromium。在这本书中，我们将以*无头*模式使用它，这意味着你不会在屏幕上看到应用程序的运行；但如果你愿意，你也可以关闭无头模式。Puppeteer附带了许多附加功能，例如截图功能。'
- en: Cross-browser testing
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 跨浏览器测试
- en: If you wish to test cross-browser support for your application, you may be better
    off looking at an alternative such as Selenium, which isn’t covered in this book.
    However, the same testing principles apply when writing tests for Selenium.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试你应用程序的跨浏览器支持，你可能更倾向于查看像Selenium这样的替代方案，这本书中没有涵盖Selenium。然而，当为Selenium编写测试时，相同的测试原则同样适用。
- en: 'This chapter covers the following topics:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Integrating Cucumber and Puppeteer into your code base
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Cucumber和Puppeteer集成到你的代码库中
- en: Writing your first Cucumber test
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个Cucumber测试
- en: Using data tables to perform setup
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据表进行设置
- en: By the end of the chapter, you’ll have a good idea of how a Cucumber test is
    built and run.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地了解Cucumber测试是如何构建和运行的。
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter17)'
- en: Integrating Cucumber and Puppeteer into your code base
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Cucumber和Puppeteer集成到你的代码库中
- en: 'Let’s add the necessary packages to our project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的项目添加必要的包：
- en: 'Start by installing the packages we’re after. As well as Cucumber and Puppeteer,
    we’ll also pull in `@babel/register`, which will enable us to use ES6 features
    within our support files:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装我们需要的包。除了Cucumber和Puppeteer，我们还将引入`@babel/register`，这将使我们能够在支持文件中使用ES6功能：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, create a new file named `cucumber.json` with the following content. This
    has two settings; `publishQuiet` turns off a bunch of noise that would otherwise
    appear when you run tests, and `requireModule` hooks up `@babel/register` before
    tests are run:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`cucumber.json`的新文件，并包含以下内容。这有两个设置；`publishQuiet`关闭了在运行测试时出现的许多噪音，而`requireModule`在运行测试之前连接`@babel/register`：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a new folder called `features`. This should live at the same level as
    `src` and `test`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`features`的新文件夹。这个文件夹应该与`src`和`test`处于同一级别。
- en: Create another folder within that called `features/support`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建一个名为`features/support`的文件夹。
- en: 'You can now run tests with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用以下命令运行测试：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You’ll see output like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到如下输出：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Throughout this chapter and the following one, it may be helpful to narrow
    down the tests you’re running. You can run a single scenario by providing the
    test runner with the filename and starting line number of the scenario:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，缩小你正在运行的测试范围可能会有所帮助。你可以通过提供测试运行器的场景文件名和起始行号来运行单个场景：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s all there is to getting set up with Cucumber and Puppeteer—now it’s time
    to write a test.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用Cucumber和Puppeteer设置的全部内容——现在是我们编写测试的时候了。
- en: Writing your first Cucumber test
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个Cucumber测试
- en: In this section, you’ll build a Cucumber feature file for a part of the Spec
    Logo application that we’ve already built.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为我们已经构建的Spec Logo应用程序的一部分构建一个Cucumber功能文件。
- en: Warning on Gherkin code samples
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Gherkin代码样本的警告
- en: If you’re reading an electronic version of this book, be careful when copying
    and pasting feature definitions. You may find extra line breaks are inserted into
    your code that Cucumber won’t recognise. Before running your tests, please look
    through your pasted code snippets and remove any line breaks that shouldn’t be
    there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书的电子版，在复制粘贴功能定义时要小心。你可能会发现代码中插入了Cucumber无法识别的额外换行符。在运行测试之前，请检查你粘贴的代码片段，并删除任何不应该存在的换行符。
- en: Let’s get started!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Before running any Cucumber tests, it’s important to ensure that your build
    output is up to date by running `npm run build`. Your Cucumber specs are going
    to run against the code built in the `dist` directory, not your source in the
    `src` directory.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行任何 Cucumber 测试之前，确保通过运行 `npm run build` 来更新你的构建输出是很重要的。你的 Cucumber 规范将针对
    `dist` 目录中构建的代码运行，而不是 `src` 目录中的源代码。
- en: Use package.json scripts to your advantage
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 package.json 脚本的优势
- en: You could also modify your `package.json` scripts to invoke a build before Cucumber
    specs are run, or to run webpack in watch mode.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以修改 `package.json` 脚本来在运行 Cucumber 规范之前调用构建，或者以监视模式运行 webpack。
- en: 'Create a new file named `features/sharing.feature` and enter the following
    text. A feature has a name and a short description, as well as a bunch of scenarios
    listed one after another. We’ll start with just one scenario for now:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `features/sharing.feature` 的新文件，并输入以下文本。一个功能有一个名称和简短描述，以及一系列按顺序列出的场景。我们现在只从一个场景开始：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Gherkin syntax
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 语法
- en: '**Given**, **When**, and **Then** are analogous to the **Arrange**, **Act**,
    and **Assert** phases of your Jest tests: *given* all these things are true, *when*
    I perform this action, *then* I expect all these things to happen.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Given**, **When**, 和 **Then** 与你的 Jest 测试的 **Arrange**, **Act**, 和 **Assert**
    阶段类似：*given* 所有这些条件都为真，*when* 我执行这个操作，*then* 我期望所有这些事情发生。'
- en: Ideally, you’d have a single **When** clause in each of your scenarios.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你每个场景中只有一个 **When** 子句。
- en: You’ll notice that I’ve written the **Given** clauses in past tense and the
    **When** clause in the present tense, and the **Then** clause has a “should” in
    there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我已经将 **Given** 子句写成过去时，**When** 子句写成现在时，而 **Then** 子句中有一个“should”。
- en: 'Go ahead and run the feature by typing `npx cucumber-js` at the command line.
    You’ll see a warning printed, as shown in the following code block. Cucumber has
    stopped processing at the first `Given...` statement because it can’t find the
    JavaScript support function that maps to it. In the warning, Cucumber has helpfully
    given you a starting point for the definition:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中键入 `npx cucumber-js` 来运行该功能。你会看到一条警告信息，如下面的代码块所示。Cucumber 在第一个 `Given...`
    语句处停止处理，因为它找不到与之对应的 JavaScript 支持函数。在警告信息中，Cucumber 有助于为你提供了定义的起点：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s do exactly what it suggested. Create the `features/support/sharing.steps.js`
    file and add the following code. It defines a step definition that calls Puppeteer’s
    API to launch a new browser, then open a new page, and then navigate to the URL
    provided. The step definition description matches up with the **Given** clause
    in our test scenario.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照它建议的去做。创建一个名为 `features/support/sharing.steps.js` 的文件，并添加以下代码。它定义了一个步骤定义，该定义调用
    Puppeteer 的 API 来启动一个新的浏览器，然后打开一个新页面，然后导航到提供的 URL。步骤定义描述与我们的测试场景中的 **Given** 子句相匹配。
- en: 'The second parameter to `async` keyword. This is an addition to what Cucumber
    tells us in its suggested function definition. We need `async` because Puppeteer’s
    API calls all return promises that we’ll need to `await`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`async` 关键字的第二个参数。这是对 Cucumber 在其建议函数定义中告诉我们的内容的补充。我们需要 `async`，因为 Puppeteer
    的 API 调用都返回 promises，我们需要对它们进行 `await`：'
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Anonymous functions, not lambda expressions
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数，而非 lambda 表达式
- en: You may be wondering why we are defining anonymous functions (`async function
    (...) { ... }`) rather than lambda expressions (`async (...) => { ... }`). It
    allows us to take advantage of the implicit context binding that occurs with anonymous
    functions. If we used lambdas, we’d need to call `.bind(this)` on them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们定义匿名函数（`async function (...) { ... }`）而不是 lambda 表达式（`async (...)
    => { ... }`）。这使我们能够利用匿名函数发生的隐式上下文绑定。如果我们使用 lambda 表达式，我们就需要在它们上调用 `.bind(this)`。
- en: 'Run your tests again. Cucumber now dictates the next clause that needs work.
    For this clause, `And the presenter clicked the button ''startSharing''`, we need
    to get access to the `page` object we just created in the previous step. The way
    to do this is by accessing what’s known as the `World` object, which is the context
    for all the clauses in the current scenario. We must build this now. Create the
    `features/support/world.js` file and add the following content. It defines two
    methods, `setPage` and `getPage`, which allow us to save multiple pages within
    the world. The ability to save multiple pages is important for this test, where
    we have at least two pages—the presenter page and the observer page:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的测试。Cucumber现在指定了下一个需要工作的子句。对于这个子句，`并且演示者点击了按钮 'startSharing'`，我们需要访问我们在上一个步骤中刚刚创建的`page`对象。要做到这一点，我们需要访问所谓的`World`对象，它是当前场景中所有子句的上下文。我们必须现在构建它。创建`features/support/world.js`文件并添加以下内容。它定义了两个方法，`setPage`和`getPage`，允许我们在世界中保存多个页面。对于这个测试来说，能够保存多个页面是非常重要的，因为我们至少有两个页面——演示者页面和观察者页面：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now use the `setPage` and `getPage` functions from within our step definitions.
    Our approach will be to call `setPage` from the first step definition—the one
    we wrote in *step 3*—and then use `getPage` to retrieve it in subsequent steps.
    Modify the first step definition now to include the call to `setPage`, as shown
    in the following code block:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的步骤定义中使用`setPage`和`getPage`函数。我们的方法将是首先从第一个步骤定义——我们在*步骤3*中编写的——调用`setPage`，然后使用`getPage`在后续步骤中检索它。现在修改第一个步骤定义，包括对`setPage`的调用，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Moving on to the next step, `the presenter clicked the button ''startSharing''`,
    we’ll solve this by using the `Page.click` Puppeteer function to find a button
    with an ID of `startSharing`. As in the last test, we use a `buttonId` parameter
    so that this step definition can be used with other buttons in future scenarios:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来进行下一步，`演示者点击了按钮 'startSharing'`，我们将通过使用`Page.click` Puppeteer函数来查找一个ID为`startSharing`的按钮来解决此问题。就像上一个测试一样，我们使用`buttonId`参数，这样这个步骤定义就可以在未来场景中用于其他按钮：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step, `the observer navigates to the presenter''s sharing link`, is
    like the first step in that we want to open a new browser. The difference is that
    it’s for the observer, and we first need to look up the path to follow. The path
    is given to us through the URL that the presenter is shown once they start searching.
    We can look that up using the `Page.$eval` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，`观察者导航到演示者的分享链接`，就像第一步那样，我们想要打开一个新的浏览器。不同的是，这是为观察者准备的，我们首先需要查找要遵循的路径。路径是通过演示者在开始搜索时显示的URL给出的。我们可以使用`Page.$eval`函数来查找：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Step definition duplication
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤定义重复
- en: There’s some duplication building up between our step definitions. Later on,
    we’ll extract this commonality into its own function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的步骤定义之间正在积累一些重复。稍后，我们将把这个共性提取到它自己的函数中。
- en: 'The final step definition uses the `Page.$eval` Puppeteer function again, this
    time to find an HTML node and then transform it into a plain JavaScript object.
    We then test that object using the `expect` function in the normal way. Make sure
    to place the listed `import` statement at the top of your file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个步骤定义再次使用`Page.$eval` Puppeteer函数，这次是为了找到一个HTML节点并将其转换为一个普通的JavaScript对象。然后我们使用`expect`函数以正常方式测试该对象。确保将列出的`import`语句放置在文件顶部：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run your tests with `npx cucumber-js`. The output from your test run will look
    as follows. While our step definitions are complete, something is amiss:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npx cucumber-js`运行你的测试。你的测试运行输出将如下所示。虽然我们的步骤定义是完整的，但似乎有些不对劲：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Although our app has loaded, we still need to spin up the server to process
    our requests. To do that, add the following two functions to the `World` class
    in `features/support/world.js`, including the `import` statement for the app at
    the top of the file. The `startServer` function is equivalent to how we start
    the server in `server/src/server.js`. The `closeServer` function stops the server,
    but before it does this, it closes all Puppeteer browser instances. It’s important
    to do this before closing the server. That’s because the server does not kill
    any live websocket connections when the `close` method is called. We need to ensure
    they are closed first; otherwise, the server won’t stop:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们的应用已经加载，但我们仍然需要启动服务器来处理我们的请求。为此，将以下两个函数添加到 `features/support/world.js` 中的
    `World` 类，包括在文件顶部添加对应用的 `import` 语句。`startServer` 函数相当于我们在 `server/src/server.js`
    中启动服务器的方式。`closeServer` 函数停止服务器，但在这样做之前，它会关闭所有 Puppeteer 浏览器实例。这样做很重要，因为当调用 `close`
    方法时，服务器不会杀死任何活跃的 websocket 连接。我们需要确保它们首先关闭；否则，服务器将无法停止：
- en: Starting a server from within the same project
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一项目中启动服务器
- en: We are lucky that all our code lives within the same project, so it can be started
    within the same process. If your code base is split over multiple projects, you
    may find yourself dealing with multiple processes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运，所有代码都位于同一个项目中，因此可以在同一个进程中启动。如果你的代码库分布在多个项目中，你可能会发现自己需要处理多个进程。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Make use of these new functions with the `Before` and `After` hooks. Create
    a new file, `features/support/hooks.js`, and add the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用这些新函数通过 `Before` 和 `After` 钩子。创建一个新文件 `features/support/hooks.js` 并添加以下代码：
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the `npx cucumber-js` command and observe the output. Your scenario should
    now be passing (if it isn’t, double-check you’ve run `npm run build`):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `npx cucumber-js` 命令并观察输出。你的场景现在应该通过（如果没有通过，请再次检查你是否已经运行了 `npm run build`）：
- en: '[PRE16]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s go back and tidy up that repeated code. We’ll extract a function called
    `browseToPageFor` and place it within our `World` class. Open `features/support/world.js`
    and add the following method at the bottom of the class:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到代码中，整理一下重复的部分。我们将提取一个名为 `browseToPageFor` 的函数，并将其放置在我们的 `World` 类中。打开 `features/support/world.js`
    并在类底部添加以下方法：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, move the Puppeteer `import` statement across from `features/support/sharing.steps.js`
    into `features/support/world.js`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将 Puppeteer 的 `import` 语句从 `features/support/sharing.steps.js` 移动到 `features/support/world.js`：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, rewrite the two navigation steps in terms of `browseToPageFor`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，用 `browseToPageFor` 重新编写两个导航步骤：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Observing within a browser and with console logging
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器内和通过控制台日志进行观察
- en: 'The tests we’ve written run Puppeteer in headless mode, meaning that an actual
    Chrome browser window doesn’t launch. If you’d like to see that happen, you can
    turn headless mode off by modifying the launch commands (remember there are two
    in the previous step definitions) to read as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的测试以无头模式运行 Puppeteer，这意味着不会启动实际的 Chrome 浏览器窗口。如果你想看到这种情况发生，可以通过修改启动命令（记住在之前的步骤定义中有两个）来关闭无头模式，如下所示：
- en: '`const browser = await puppeteer.launch(`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`const browser = await puppeteer.launch(`'
- en: '`{ headless: false }`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ headless: false }`'
- en: '`);`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`);`'
- en: 'If you’re using console logging to assist in your debugging, you’ll need to
    provide another parameter to dump console output to `stdout`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用控制台日志来协助调试，你需要提供另一个参数来将控制台输出重定向到 `stdout`：
- en: '`const browser = await puppeteer.launch(`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`const browser = await puppeteer.launch(`'
- en: '`{ dumpio: true }`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ dumpio: true }`'
- en: '`);`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`);`'
- en: You’ve now written a BDD test with Cucumber and Puppeteer. Next, let’s look
    at a more advanced Cucumber scenario.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经使用 Cucumber 和 Puppeteer 编写了一个 BDD 测试。接下来，让我们看看一个更高级的 Cucumber 场景。
- en: Using data tables to perform setup
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据表进行设置
- en: 'In this section, we’ll look at a useful time-saving feature of Cucumber: data
    tables. We’ll write a second scenario that, as with the previous one, will already
    pass given the existing implementation of Spec Logo:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Cucumber 的一个有用的节省时间特性：数据表。我们将编写第二个场景，就像之前的场景一样，将已经通过 Spec Logo 的现有实现：
- en: 'Create a new feature file called `features/drawing.feature` with the following
    content. It contains a set of instructions to draw a square using a Logo function.
    A small side length of `10` is used; that’s to make sure the animation finishes
    quickly:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `features/drawing.feature` 的新功能文件，内容如下。它包含一系列使用 Logo 函数绘制正方形的指令。使用小的边长
    `10`，以确保动画快速完成：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first phrase does the same thing as our previous step definition, except
    we’ve renamed `presenter` to `user`. Being more generic makes sense in this case
    as the role of the presenter is no longer relevant to this test. We can use the
    `World` function `browseToPageFor` for this first step. In the sharing feature,
    we used this function together with an `appPage` constant that contained the URL
    to navigate to. Let’s pull that constant into `World` now. In `features/support/world.js`,
    add the following constant at the top of the file, above the `World` class:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个短语与我们的上一个步骤定义做的是同样的事情，只是我们将 `presenter` 重命名为 `user`。在这种情况下，使用更通用的名称是有意义的，因为演示者的角色对这个测试不再相关。我们可以使用
    `World` 函数 `browseToPageFor` 来完成这个第一步。在共享功能中，我们使用了这个函数与一个包含要导航到的 URL 的 `appPage`
    常量。现在让我们将这个常量拉入 `World`。在 `features/support/world.js` 文件中，在 `World` 类之上添加以下常量：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following method to the `World` class:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `World` 类中：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `features/support/sharing.steps.js`, remove the definitions for `port` and
    `appPage` and update the first step definition, as shown:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `features/support/sharing.steps.js` 文件中，删除 `port` 和 `appPage` 的定义，并更新第一个步骤定义，如下所示：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It’s time to create a new step definition for a user page. Open the `features/support/drawing.steps.js`
    file and add the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候为用户页面创建一个新的步骤定义了。打开 `features/support/drawing.steps.js` 文件并添加以下代码：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, what about the second line, with the data table? What should our step
    definition look like? Well, let’s ask Cucumber. Run the `npx cucumber-js` command
    and have a look at the output. It gives us the starting point of our definition:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，关于带有数据表的第二行，我们的步骤定义应该是什么样子呢？让我们问问 Cucumber。运行 `npx cucumber-js` 命令并查看输出。它给出了我们定义的起点：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Go ahead and add the suggested code to `features/supports/drawing.steps.js`.
    If you run `npx cucumber-js` at this point, you’ll notice that Cucumber successfully
    notices that the step definition is pending:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将建议的代码添加到 `features/supports/drawing.steps.js` 文件中。如果你现在运行 `npx cucumber-js`，你会注意到
    Cucumber 成功地注意到步骤定义是挂起的：
- en: '[PRE26]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `dataTable` variable is a `DataTable` object with a `raw()` function that
    returns an array of arrays. The outer array represents each row, and the inner
    arrays represent the columns of each row. In the next step definition, we want
    to take every single line and insert it into the edit prompt. Each line should
    be followed by a press of the *Enter* key. Create that now:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dataTable` 变量是一个具有 `raw()` 函数的 `DataTable` 对象，该函数返回一个数组的数组。外层数组代表每一行，内层数组代表每一行的列。在下一步定义中，我们希望将每一行都插入到编辑提示中。每一行后面应该跟着一个按下
    *Enter* 键的操作。现在就创建它：'
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The final step requires us to look for line elements with the right attribute
    values and compare them to the values in our second data table. The following
    code does exactly that. Copy it out now and run your tests to ensure that it works
    and that the test will pass. An explanation of all the detailed points will follow:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步需要我们查找具有正确属性值的行元素，并将它们与我们的第二个数据表中的值进行比较。以下代码正是这样做的。现在复制这段代码并运行你的测试，以确保它工作并且测试能够通过。所有详细点的解释将会随后提供：
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That last test contained some complexity that’s worth diving into:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试包含了一些值得深入研究的复杂性：
- en: We used `Page.waitForTimeout` to wait for 2 seconds, which gives the system
    time to complete animations. Including a timeout like this is not a great practice,
    but it’ll work for now. We’ll look at a way of making this more specific in the
    next chapter.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 `Page.waitForTimeout` 来等待 2 秒，这给了系统完成动画的时间。包含这样的超时并不是一个好的做法，但暂时它是可行的。我们将在下一章中探讨使其更具体的方法。
- en: The `Page.$$eval` function is like `Page.$eval` but returns an array under the
    hood, and calls `document.querySelector` rather than `document.querySelectorAll`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Page.$$eval` 函数类似于 `Page.$eval`，但在底层返回一个数组，并且调用 `document.querySelector` 而不是
    `document.querySelectorAll`。'
- en: It’s important that we do all of the attribute transformation logic—moving from
    HTML line elements and attributes to “plain” integer values of `x1`, `y1`, and
    so on—within the `transform` function of `Page.$$eval`. This is because Puppeteer
    will garbage collect any DOM node objects once the `$$eval` call is done.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，我们所有的属性转换逻辑——从 HTML 行元素和属性移动到“纯”整数 `x1`、`y1` 等值——都应该在 `Page.$$eval` 的 `transform`
    函数内完成。这是因为 Puppeteer 会在 `$$eval` 调用完成后回收任何 DOM 节点对象。
- en: Our line values need to be parsed with `parseFloat` because the `requestAnimationFrame`
    logic we coded doesn’t perfectly line up with the integer endpoints—they are out
    by very slight fractional amounts.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的行值需要用 `parseFloat` 来解析，因为我们所编写的 `requestAnimationFrame` 逻辑与整数端点不完全对齐——它们有非常微小的分数差异。
- en: That also means we need to use the `toBeCloseTo` Jest matcher rather than `toBe`,
    which we need because of the fractional value difference described previously.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也意味着我们需要使用 `toBeCloseTo` Jest 匹配器而不是 `toBe`，这是因为我们之前描述的分数值差异所必需的。
- en: Finally, we use the `DataTable` `hashes()` function here to pull out an array
    of objects that has a key for each of the columns in the data table, based on
    the header row that we provided in the feature definition. So, for example, we
    can call `hashes()[0].x1` to pull out the value in the `x1` column for the first
    row.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在这里使用 `DataTable` 的 `hashes()` 函数来提取一个对象数组，该数组具有数据表中每列的一个键，基于我们在功能定义中提供的标题行。例如，我们可以调用
    `hashes()[0].x1` 来提取第一行 `x1` 列的值。
- en: Go ahead and run your tests again with `npx cucumber-js`. Everything should
    be passing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用 `npx cucumber-js` 运行你的测试。一切都应该通过。
- en: You’ve now got a good understanding of using Cucumber data tables to make more
    compelling BDD tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经很好地理解了如何使用 Cucumber 数据表来制作更具说服力的 BDD 测试。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Cucumber tests (and BDD tests in general) are similar to the unit tests we’ve
    been writing in the rest of the book. They are focused on specifying *examples*
    of behavior. They should make use of real data and numbers as means to test a
    general concept, like we’ve done in the two examples in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 测试（以及一般的 BDD 测试）与我们在这本书的其余部分所编写的单元测试类似。它们专注于指定行为的 *示例*。它们应该使用真实的数据和数字作为测试一般概念的手段，就像我们在本章的两个例子中所做的那样。
- en: BDD tests differ from unit tests in that they are system tests (having a much
    broader test surface area) and they are written in natural language.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 测试与单元测试的不同之处在于，它们是系统测试（具有更广泛的测试范围）并且使用自然语言编写。
- en: Just as with unit tests, it’s important to find ways to simplify the code when
    writing BDD tests. The number one rule is to try to write generic `World` class
    or some other module. We’ve seen an example of how to do that in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单元测试一样，在编写 BDD 测试时，找到简化代码的方法很重要。首要规则是尝试编写通用的 `World` 类或其它模块。我们已经在本章中看到了如何做到这一点的例子。
- en: In the next chapter, we’ll use a BDD test to drive the implementation of a new
    feature in Spec Logo.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 BDD 测试来驱动 Spec Logo 中新功能的实现。
