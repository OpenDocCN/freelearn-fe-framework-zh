["```js\nnpm create vuetify\n```", "```js\nVITE_APP_SPOONACULAR_API=Replace this with the key\n```", "```js\n<script setup lang=\"ts\"></script>\n<template>\n  <v-layout>\n    <v-container class=\"main\">\n      <main>\n        <router-view />\n      </main>\n    </v-container>\n    <v-footer app><span class=\"text-light-green\">My Meal Planner</span>&nbsp;- &copy; {{ new Date().getFullYear() }}</v-footer>\n  </v-layout>\n</template>\n```", "```js\n<template>  <v-table>\n    <thead>\n      <tr>\n        <th class=\"text-left\">Upcoming days</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr v-for=\"card in cards\" :key=\"card.date.toString()\">\n        <td class=\"py-4\">\n          {{ card.content }}\n        </td>\n      </tr>\n    </tbody>\n  </v-table>\n</template>\n```", "```js\n<script setup  lang=\"ts\">import CalendarDays from './CalendarDays.vue';\n</script>\n<template>\n    <calendar-days :date=\"new Date()\" :days=\"7\" />\n</template>\n```", "```js\nconst getOrdinalSuffix = (day: number): string => {    const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n    const remainder = day % 100;\n    return suffixes[(remainder - 20) % 10] || suffixes[remainder] || suffixes[0];\n};\nexport const useFormatDate = (date: Date): string => {\n    const day = date.getDate();\n    const month = date.toLocaleString(\"default\", { month: \"long\" });\n    const ordinal = getOrdinalSuffix(day);\n    return ${day}${ordinal} of ${month};\n};\n```", "```js\n<template>  <v-app-bar flat>\n    <v-app-bar-title>\n      <v-icon icon=\"mdi-silverware-fork-knife\" />\n      Meal planner\n    </v-app-bar-title>\n  </v-app-bar>\n</template>\n```", "```js\n<script setup lang=\"ts\">import { useFormatDate } from \"@/composables/formatters\";\ninterface Card {\n  date: Date;\n}\nconst props = defineProps<{\n  card: Card;\n}>();\n</script>\n<template>\n  <v-sheet class=\"d-flex justify-space-between\">\n    <v-sheet class=\"ma-2 pa-2\">\n      <h2 class=\"text-h2\">{{ useFormatDate(card.date) }}</h2>\n    </v-sheet>\n  </v-sheet>\n</template>\n```", "```js\n<script setup lang=\"ts\">import { ref } from \"vue\";\nimport CalendarCard from \"@/components/CalendarCard.vue\";\n// …abbreviated\n```", "```js\n<template>  <v-table>\n    // … abbreviated\n    <tbody>\n      <tr v-for=\"card in cards\" :key=\"card.date.toString()\">\n        <td class=\"py-4\">\n          <calendar-card :card=\"card\" />\n        </td>\n      </tr>\n    </tbody>\n  </v-table>\n</template>\n```", "```js\n<script setup lang=\"ts\">import RecipesList from \"@/components/RecipesList.vue\";\n</script>\n<template>\n  <RecipesList />\n</template>\n```", "```js\nimport { createRouter, createWebHistory } from 'vue-router'const routes = [\n  {\n    path: '/',\n    component: () => import('@/layouts/default/Default.vue'),\n    children: [\n      {\n        path: '',\n        name: 'Home',\n        component: () => import(/* webpackChunkName: \"home\" */ '@/views/Home.vue'),\n      },\n      {\n        path: 'recipes',\n        name: 'Recipes',\n        component: () => import('@/views/RecipesView.vue')\n      },\n    ],\n  },\n]\n// …abbreviated\n```", "```js\n<template>  <v-app-bar flat>\n    <v-btn id=\"hamburger-activator\" icon=\"mdi-menu\"> </v-btn>\n    <v-menu activator=\"#hamburger-activator\">\n      <v-list>\n        <v-list-item>\n          <v-btn flat block><router-link to=\"/\">Home</router-link></v-btn>\n          <v-btn flat block\n            ><router-link to=\"/recipes\">Recipes</router-link></v-btn\n          >\n        </v-list-item>\n      </v-list>\n    </v-menu>\n    <v-app-bar-title>\n      <v-icon icon=\"mdi-silverware-fork-knife\" />\n      Meal planner\n    </v-app-bar-title>\n  </v-app-bar>\n</template>\n```", "```js\n<template>  <v-container class=\"fill-height\" fluid>\n    <v-row align=\"center\" justify=\"center\">\n      <v-col cols=\"12\" sm=\"8\" md=\"4\">\n        <div class=\"text-center my-8\">\n          <v-progress-circular\n            indeterminate\n            color=\"light-blue\"\n            :size=\"80\"\n            :width=\"10\"\n          ></v-progress-circular>\n        </div>\n      </v-col>\n    </v-row>\n  </v-container>\n</template>\n```", "```js\n<script setup lang=\"ts\">const props = defineProps({\n  to: {\n    type: String,\n    required: true,\n  },\n});\n</script>\n<template>\n    <router-link :to=\"to\" class=\"text-light-blue\">\n        <slot></slot>\n    </router-link>\n</template>\n```", "```js\n<script setup lang=\"ts\">import AppLink from '@/components/AppLink.vue';\n</script>\n<template>\n  <v-app-bar flat>\n    <v-btn id=\"hamburger-activator\" icon=\"mdi-menu\"> </v-btn>\n    <v-menu activator=\"#hamburger-activator\">\n      <v-list>\n        <v-list-item>\n          <v-btn flat block><app-link to=\"/\">Home</app-link></v-btn>\n          <v-btn flat block\n            ><app-link to=\"/recipes\">Recipes</app-link></v-btn\n          >\n        </v-list-item>\n      </v-list>\n    </v-menu>\n<!-- ... abbreviated -–>\n</template>\n```", "```js\n<script setup lang=\"ts\">import { useFormatDate } from \"@/composables/formatters\";\nconst emits = defineEmits([\"daySelected\"]);\nconst addRecipeToDay = (card: Card): void => {\n  emits(\"daySelected\", card);\n}\ninterface Card {\n  date: Date;\n}\nconst props = defineProps<{\n  card: Card;\n}>();\n</script>\n<template>\n  <v-sheet class=\"d-flex justify-space-between\">\n    <v-sheet class=\"ma-2 pa-2\">\n      <h2 class=\"text-h2\">{{ useFormatDate(card.date) }}</h2>\n    </v-sheet>\n    <v-sheet class=\"ma-2 pa-2\">\n      <v-btn text @click=\"addRecipeToDay(card)\" icon=\"mdi-plus\"></v-btn>\n    </v-sheet>\n  </v-sheet>\n</template>\n```", "```js\n<script setup lang=\"ts\">import { ref } from \"vue\";\nimport type { Ref } from \"vue\";\nimport CalendarCard from \"@/components/CalendarCard.vue\";\nconst props = defineProps({\n  date: {\n    type: Date,\n    required: true,\n  },\n  days: {\n    type: Number,\n    required: false,\n    default: 7,\n  },\n});\ninterface Card {\n  date: Date;\n  content: string;\n}\nconst generateCards = (startDate: Date, numberOfDays: number): Card[] => {\n  const cards: Card[] = [];\n  const currentDate = new Date(startDate);\n  for (let i = 0; i < numberOfDays; i++) {\n    const date = new Date(currentDate.getTime());\n    const content = Card ${i + 1};\n    cards.push({ date, content });\n    currentDate.setDate(currentDate.getDate() + 1);\n  }\n  return cards;\n};\nconst cards = ref<Card[]>(generateCards(props.date, props.days));\nconst dialogVisible: Ref<boolean> = ref(false);\nconst dateSelected: Ref<Date | null> = ref(null);\nconst recipeDialogOpen = (card: Card): void => {\n  dateSelected.value = card.date;\n  dialogVisible.value = true;\n};\nconst recipeDialogClose = (): void => {\n  dateSelected.value = null;\n  dialogVisible.value = false;\n};\n</script>\n<template>\n  <v-table>\n    <thead>\n      <tr>\n        <th class=\"text-left\">Upcoming days</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr v-for=\"card in cards\" :key=\"card.date.toString()\">\n        <td class=\"py-4\">\n          <calendar-card :card=\"card\" @daySelected=\"recipeDialogOpen\" />\n        </td>\n      </tr>\n    </tbody>\n  </v-table>\n  <v-dialog v-model=\"dialogVisible\" scrollable>\n    <v-card>\n      <v-card-title> Search for a recipe to add to this day </v-card-title>\n      <v-card-actions>\n        <v-btn color=\"primary\" block @click=\"recipeDialogClose\"\n          >Close Dialog</v-btn\n        >\n      </v-card-actions>\n    </v-card>\n  </v-dialog>\n</template>\n```", "```js\n<script setup lang=\"ts\">import { ref, watch } from \"vue\";\nimport type { Ref } from \"vue\";\nimport { useRecipeSearch } from \"@/composables/recipeApi\";\nimport type { RecipeResults } from \"@/types/spoonacular\";\nconst emits = defineEmits([\"recipeSelected\"]);\nconst searchQuery: Ref<string> = ref(\"\");\nconst searchResults: Ref<RecipeResults[] | []> = ref([]);\nconst getSearchResults = async () => {\n  const result = await useRecipeSearch(searchQuery.value);\n  searchResults.value = result.results;\n};\nlet timeout: ReturnType<typeof setTimeout>;\nconst debouncedSearch = (): void => {\n  clearTimeout(timeout);\n  timeout = setTimeout(async () => {\n    getSearchResults();\n  }, 500);\n};\nwatch(searchQuery, (): void => {\n  debouncedSearch();\n});\nconst recipeSelected = (result: RecipeResults): void => {\n  emits(\"recipeSelected\", result);\n};\n</script>\n<template>\n  <v-car flat>\n    <v-card-text>\n      <v-text-field v-model=\"searchQuery\" label=\"Search\"></v-text-field>\n    </v-card-text>\n    <v-divider></v-divider>\n    <v-list v-if=\"searchResults\">\n      <v-list-item v-for=\"(result, index) in searchResults\" :key=\"index\">\n        <v-list-item-title @click=\"recipeSelected(result)\" class=\"list-item\">{{\n          result.title\n        }}</v-list-item-title>\n      </v-list-item>\n    </v-list>\n  </v-car>\n</template>\n<style scoped>\n.list-item {\n  cursor: pointer;\n}\n.list-item:hover,\n.list-item:active {\n  text-decoration: underline;\n}\n</style>\n```", "```js\n<script setup lang=\"ts\">import { ref } from \"vue\";\nimport type { Ref } from \"vue\";\nimport type { RecipeResults } from \"@/types/spoonacular\";\nimport CalendarCard from \"@/components/CalendarCard.vue\";\nimport RecipeSearch from \"@/components/RecipeSearch.vue\";\ninterface Today {\n  id: number;\n  title: string;\n  readyInMinutes: number;\n}\ninterface Card {\n  date: Date;\n  content: string;\n  today: Today[];\n}\n// …abbreviated\nconst insertRecipeOnDay = (recipe: RecipeResults): void => {\n  if (dateSelected.value) {\n    cards.value = cards.value.map((card) => {\n      if (card.date.getTime() === dateSelected.value?.getTime()) {\n        return { ...card, today: [...card.today, recipe] };\n      }\n      return card;\n    });\n    recipeDialogClose();\n  }\n};\n</script>\n<template>\n  <v-table>\n    <!-- abbreviated -->\n  </v-table>\n  <v-dialog v-model=\"dialogVisible\" scrollable>\n    <v-card>\n      <v-card-title> Search for a recipe to add to this day </v-card-title>\n      <recipe-search @recipeSelected=\"insertRecipeOnDay\" />\n      <v-card-actions>\n        <v-btn color=\"primary\" block @click=\"recipeDialogClose\"\n          >Close Dialog</v-btn\n        >\n      </v-card-actions>\n    </v-card>\n  </v-dialog>\n</template>\n```", "```js\nconst removeRecipeFromDay = (recipe: { id: number }, date: Date): void => {  cards.value = cards.value.map((card) => {\n    if (card.date.getTime() === date.getTime()) {\n      return {\n        ...card,\n        today: card.today.filter((today) => today.id !== recipe.id),\n      };\n    }\n    return card;\n  });\n};\n```", "```js\n<calendar-card :card=\"card\" @daySelected=\"recipeDialogOpen\" CalendarCard.vue component so that it shows the recipes for a day and then add the option to remove them:\n\n```", "```js\n\nIn the template, we’ve just added an emitter to emit the `recipeRemoved` event that provides the recipe and date as context. Here, we use Vuetify components to create a repeating card layout to show any recipes that are added for that day.\nAs you can see, we also provide a link to the details page of the recipe, so we need to build one! But before we do that, let’s take a look at our app at this point. You should be able to use the app interface to show several upcoming days. When selecting a date, we can search for a recipe using the Spoonacular API and add one or more recipes to our meal planner. We can also remove recipes from our meal planner.\nWe are not saving anything yet, which means that refreshing the browser or navigating to a different page empties the meal planner! That’s something we will work on in the next chapter, but before we do that, we must add the cooking instructions to a separate route.\nLet’s create a `CookingInstructions.vue` component in the `components` folder with the following contents:\n\n```", "```js\n\nNote that we are using our `AppLoader` component because the contents will come directly from the API. Other than that, most of the layout uses Vuetify components to display the details coming from the endpoint.\nNext, we’ll create the view to load this component. In the `views` folder, we’ll create a `RecipeView.vue` file:\n\n```", "```js\n\nLet’s add it to the router (`src/router/index.ts`) with a new entry, using `id` as a parameter:\n\n```", "```js\n\nThat’s it for this section. While we have some functionality, it isn’t usable because our data is not persistent. We need to build a stateful application. And since managing state can be tedious to do by hand, we’ll make use of Pinia to help us with that!\nYou may have noticed that, by using Vuetify components, we have less logic in our application to deal with the state of the user interface. Our `script` tags now contain mostly functions that are tied to the features of the application.\nThis is one of the benefits of using a component library in your application: you can focus on the specific features rather than on building interactive user interface elements.\nUsing Pinia for state management\nIn this section, we’ll focus on making our application stateful using Pinia. This means we will have to refactor existing code, optimize certain flows, and add new features to our application.\nStateful applications\nWe use the term *stateful applications* to describe applications that can use, save, and persist data for a certain amount of time. A state can be temporary (while a session lasts) or of a more permanent nature when stored in a database.\nThe state is contextual to the current user and is typically not shared between users. In short, it is representative of the current user's state of interacting with an application.\nAdding Pinia\n**Pinia** is a framework for managing states of applications built using Vue.js 3\\. It aims to facilitate sharing and interacting with a state or store by leveraging composables and simple syntax.\nLet’s add Pinia to our project by installing it using the command line:\n\n```", "```js\n\n Next, we need to create our Pinia instance and pass it to the app as a plugin. Open the `main.ts` file to make the following changes:\n\n```", "```js\n\nThat’s it! We can now create our stores and make our app even better.\nThe first store\nWe’ll start with something small. If you’ve opened the cooking instructions for a recipe, you may have noticed the loading indicator. That’s because the data is coming from an external API. If you refresh the page, you will notice that you have to wait for data to load again. You can see it in the **Network** tab of your developer tools as well. We can use a store to at least cache requests once they’ve been resolved, to prevent additional requests to the same resource and improve the performance of the app.\nFor stores, we’ll create a folder called `stores` in the `src` folder. Let’s add a `cache` folder and create an `index.ts` file. In this file, we’ll use the `defineStore` method to create a store called `cache` (the names need to be unique):\n\n```", "```js\n\nThis is how you define any store – we use composable use notation. The composable consists of a (now empty) object that we will complement with the functions we want to expose. We need a function to cache data and one to return cached data, which will look like this:\n\n```", "```js\n\nWe can define functions and choose which functions we want to return. In this case, we’ll return both of the functions.\nIn our store, we can use native functions from Vue, such as `reactivity`! We’ll define a constant named `cache` and, using both of our functions, read from the cache or add data to the cache:\n\n```", "```js\n\nNow, this is a very simplistic design, but for our purposes, it works. Let’s see how we can implement this in our `CookingInstructions.vue` component.\nIn our `script` tag, we need to import the cache store and initialize the store on a `store` constant:\n\n```", "```js\n\nThat’s all we need to do to use the methods in our store. Now, we’ll modify the `getRecipeDetails` function so that it only uses the external API if no data is found on the cache by the unique key per response:\n\n```", "```js\n\nThe cache is not stored on the user’s machine but stored in the session of the Vue application. On refresh, the data will be lost, but when navigating backward or forward in the app, the cache will be available. When the data is stored on a unique identifier, and using the store, we can reach the contents of the store from anywhere within the Vue.js application.\nDo you remember the incomplete features of the meal planner? Let’s build a store to centralize the way we manage those recipes.\nThe meal planner store\nIn this section, we’ll create a dedicated store for our meal planner capabilities. So, create a folder called `planner` in the `stores` folder and create an `index.ts` file where we’ll define our store:\n\n```", "```js\n\nWe’re going to add some functions to interact with recipes. In this case, we would like persistence so that the information is stored for longer periods. We’ll use the `useLocalStorage` composable from `VueUse` by installing the dependency in our project:\n\n```", "```js\n\n We want our planner to be persistent (and reactive), so let’s add that functionality first:\n\n```", "```js\n\nWhen using the store, we can access the recipes from anywhere by accessing the store and requesting the recipes. We’ll add two more methods, for adding and removing recipes:\n\n```", "```js\n\nWith this in place, we can retrieve the recipes in the `MealPlanner.vue` file:\n\n```", "```js\n\nUsing `storeToRefs` from Pinia ensures that the values from our store are automatically converted into reactive properties! We’re passing the recipes down to `CalendarDays.vue`, so let’s continue with the implementation.\nNow, in the `CalendarDays.vue` component, we’re receiving the recipes as a property, but we’ll also make sure we can add and remove recipes from the planner. First, we’ll focus on processing the recipes by adding the property definition and updating the `generateCards` function, where we’ll map the recipes to each generated day:\n\n```", "```js\n\nWe can’t see it in action yet because we have no means of adding recipes to our store. Let’s add the store to the component and modify the `insertRecipeOnDay` function so that we can save the recipes in our planner store:\n\n```", "```js\n\nIf you open the app and add a recipe to a date, it gets added just as before, with the difference that on refresh, the item is preserved!\nNow, we can do something nifty using our cache store: we can preload the data to the cache to speed up the user experience when opening the cooking instructions after adding them. With our stores combined, it’s just a couple of lines.\nWe’ll import the cache store and, using the predetermined key, load the information and write it to the cache store. I tend to move the store references to the top of the file so that I can quickly glance over the capabilities that a component has at its disposal:\n\n```", "```js\n\nNow, if you’ve selected a recipe, if you visit the cooking instructions, you’ll notice that the content is there instantly! The added value of this approach depends on a couple of factors. If we expect that, on average, users want to navigate to a detailed view after adding a recipe, it makes perfect sense.\nIn other cases, it only adds an additional API call. So, use this pattern only when needed. In our case, it serves as a demonstration of using the cache store from multiple entry points in our application.\nWe have to make sure that we can remove the recipe as well. We’re going to apply that logic to the card that holds the recipe. We don’t have to centralize these functions since we have the store to take care of this for us! Therefore, we can remove the `removeRecipeFromDay` method (highlighted in the following code) from the `CalendarDays` component, as well as the event listener in the template:\n\n```", "```js\n\nNow, we can zoom in on the `CalendarCard.vue` component to add the ability to remove recipes to/from this component. We’ll start by removing the `recipeRemoved` event (highlighted in the following code) and function:\n\n```", "```js\n\nWe’ll create a new function after importing the planner store in this component. In the function, we’ll call `removeRecipeByIdDate` from the store and pass the current context:\n\n```", "```js\n\nIn the template, we’ll modify the removal button by calling the new function with the correct parameters:\n\n```", "```js\n\nWith this, we can document and use actions in places that make sense within the context of the app. With the store, we’ve created a central state where we can access and manipulate different components without needing to pass properties from one component to the next. Having a library such as Pinia integrated with the Vue environment makes it a straightforward choice since it can fully leverage the reactive capabilities of Vue out of the box!\nComputed store values\nTo stress the reusability aspect, we will finally take a look at `RecipesList.vue`, which we’ve filled with static content. Since the meal planner only shows the upcoming few days, we may want to show the full extent of past and future planned recipes.\nWe have two tabs in `RecipesList` – one for showing upcoming recipes and one for past recipes. While we could ingest all the recipes from the store and apply some sorting with a centralized store, it makes more sense to handle it close to the source.\nWe can use computed values in stores, just like Vue components! To display them, we’ll internally sort the recipes and provide two values:\n\n```", "```js\n\nAs I mentioned earlier, it is perfectly fine to have non-exposed methods in our store. With the final `return` statement, we can decide what methods to expose on the module. The functions are nothing extraordinary. After sorting by date, they filter and return dates from the past or future.\nLet’s connect the dates to the `RecipesList.vue` component. We will focus on the `script` tag since we built the interface previously. We’ll remove the highlighted parts from the following code:\n\n```", "```js\n\nWithout the mockup code, it looks a lot more readable already! We’ll also connect the `openPreview` event to another dialog. We’ll just reuse the existing `CookingInstructions.vue` component, but you could also consider creating a specific preview of your own.\nLet’s change the `script` tag so that it matches the following:\n\n```", "```js\n\nThen, we’ll add a dialog from Vuetify to the template code to show `CookingInstructions`:\n\n```", "```js\n\nWith this in place, navigating from the preview to the Cooking instructions page is almost instant again since we’re caching the contents and only have to load them on the first request. Using the store, we can interact with the date in a centralized and reusable way. Let’s try and solidify this by adding a final component to our app.\nRating the recipes\nAs a final addition, we’ll demonstrate the reusability of composables by adding a rating feature to every recipe. It will store the recipe ID and a rating of 1 through 5 stars. We should be able to read and update the rating from anywhere in the application.\nFirst, we’ll create the store. For that, we’ll add a folder called `rating` with the following contents in the `index.ts` file:\n\n```", "```js\n\nNow, we’ll create a component called `RecipeRating.vue`. It will use the rating store and, based on a provided ID, retrieve any ratings for that ID. It will also allow you to add a new rating for that particular ID, overwriting the old value.\nVuetify has a premade component for this, so when we’re combining stores and a component library, we can quickly build interactive components:\n\n```", "```js\n\nThe important parts are highlighted, although you should be familiar with them by now. We can add this component anywhere in our application where we have access to a recipe ID.\nLet’s start with `CookingInstructions.vue`. We need to import the component and then add it to our template:\n\n```", "```js\n\nFeel free to add the `rating` component on other mentions as well. It’s just two lines of code!\nWith that, we’ve iterated over our Marvel app by utilizing a component library to speed up development time. It allows us to build interfaces with relative ease. We’ve also refactored and updated our code since our needs have changed. This situation reflects how real-world code bases evolve.\nSummary\nIn this chapter, we combined two concepts to build an application that scales well in development. As we’ve seen, by adopting more and more of the principles of both the component library as well as a centralized store, the more readable and simplified our code becomes.\nUsing a component library such as Vuetify provides us with a quick way of adding interactive elements to a user interface that are well tested and easy to use out of the box. Coming with means of customization and theming, we can make sure that our implementation follows any style guide.\nThis would be a good time to try your hand at customizing the user interface, either by setting up themes and styles or just by using the classes and properties on existing components.\nBy adding state to our app, we’ve made it usable and reusable for our users. In our example, we’ve stored our data in the browser, which isn’t as portable. However, it does give us a practical look at dealing with data and caching resources. With the methods in a central place, it becomes easier to refactor the way we would store data.\nWe’ve deliberately not built a perfect app from the beginning and instead demonstrated how a refactoring process evolves with the needs and features of app development. Admittedly, it’s still not perfect at this point. As an extra exercise, you could try and see whether you can apply some of the lessons we’ve learned so far.\nIn the next chapter, we’ll solidify our Vuetify knowledge by building another application using the component library. We’ll make things more interesting by building a data resource. We’ll learn about not just reading from an endpoint but also writing and storing data by building a simple fitness tracker!\n\n```"]