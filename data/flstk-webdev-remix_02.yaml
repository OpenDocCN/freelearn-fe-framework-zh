- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Creating a New Remix App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的 Remix 应用程序
- en: Getting started with a new framework means familiarizing yourself with its primitives,
    conventions, and levers. This book uses a demo application that we will build
    from start to finish. Each chapter focuses on one specific topic of full stack
    web development with Remix. In this chapter, we will explore explore the breadth
    of Remix’s `create-remix` CLI script, introduce Remix’s file and folder structure,
    and familiarize ourselves with Remix’s runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用一个新的框架意味着熟悉其原语、约定和杠杆。本书使用一个从零开始构建的演示应用程序。每一章都专注于 Remix 全栈 Web 开发的一个特定主题。在本章中，我们将探索
    Remix 的 `create-remix` CLI 脚本的广度，介绍 Remix 的文件和文件夹结构，并熟悉 Remix 的运行时。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Creating a “Hello World!” Remix app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个“Hello World!” Remix 应用程序
- en: Understanding Remix’s file and folder structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Remix 的文件和文件夹结构
- en: Exploring the client and server environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索客户端和服务器环境
- en: Troubleshooting Remix applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Remix 应用程序的故障排除
- en: 'First, we will walk through the setup of a new Remix project using the `create-remix`
    CLI script. The chapter then introduces you to Remix’s folder structure. We will
    investigate each file and learn about its function. Next, we will discuss Remix’s
    two environments: the client and the server. You will learn how to manage client
    and server code in Remix. Finally, we will introduce a troubleshooting guide that
    will help us debug Remix applications.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过使用 `create-remix` CLI 脚本设置一个新的 Remix 项目。然后，章节将向您介绍 Remix 的文件夹结构。我们将调查每个文件并了解其功能。接下来，我们将讨论
    Remix 的两个环境：客户端和服务器。您将学习如何在 Remix 中管理客户端和服务器代码。最后，我们将介绍一个故障排除指南，帮助我们调试 Remix 应用程序。
- en: By the end of this chapter, you will know how to create a Remix project and
    will have familiarized yourself with Remix’s file and folder structure. You will
    also learn more about Remix’s client and server environments and how to troubleshoot
    Remix applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何创建 Remix 项目，并熟悉 Remix 的文件和文件夹结构。您还将了解更多关于 Remix 的客户端和服务器环境以及如何故障排除
    Remix 应用程序的信息。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need a computer that can run Node.js. All
    common operation systems should suffice. Please install both Node.js and `npm`
    on your machine. An editor such as VS Code is recommended.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要一个可以运行 Node.js 的计算机。所有常见的操作系统都足够使用。请在您的机器上安装 Node.js 和 `npm`。推荐使用 VS
    Code 等编辑器。
- en: 'You can download Node.js and `npm` here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里下载 Node.js 和 `npm`：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)。
- en: 'The solution for this chapter can be found here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app).
    Try to read through this chapter first before peeking at the final code.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的解决方案可以在以下位置找到：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app)。请在查看最终代码之前先阅读这一章。
- en: Creating a “Hello World!” Remix app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个“Hello World!” Remix 应用程序
- en: 'This section walks you through the creation of a new Remix application using
    the `create-remix` CLI script. The script is maintained by the Remix team and
    used to bootstrap new Remix projects:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您使用 `create-remix` CLI 脚本创建一个新的 Remix 应用程序。该脚本由 Remix 团队维护，用于启动新的 Remix
    项目：
- en: 'Open a new terminal window and run the following command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口并运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use `npx` to execute the `create-remix` script. `npm` and stands for `create-remix`
    v2\. The examples in this book are based on Remix v2\. By adding the `@2` postfix
    to the package name, we ensure that our first demo application installs a Remix
    v2 application.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `npx` 来执行 `create-remix` 脚本。`npm` 代表 `create-remix` v2。本书中的示例基于 Remix v2。通过在包名后添加
    `@2` 后缀，我们确保我们的第一个演示应用程序安装的是 Remix v2 应用程序。
- en: 'For projects outside of this book, we recommend using the following command
    instead to work with the latest stable version of Remix:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于本书外的项目，我们建议使用以下命令来使用 Remix 的最新稳定版本：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are asked by `npx` to install `create-remix`, enter `y` to answer with
    yes.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `npx` 要求您安装 `create-remix`，请输入 `y` 以回答“是”。
- en: 'After installing the `create-remix` script, we are prompted to provide a valid
    location for our Remix project:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `create-remix` 脚本后，系统会提示我们提供一个有效的 Remix 项目位置：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pick an install location on your machine or use the default install location
    offered by the CLI tool.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的机器上选择一个安装位置或使用 CLI 工具提供的默认安装位置。
- en: After hitting *Enter*, the script informs us that it selected the basic template,
    also called **Remix App Server**. The script defaults to the basic template if
    no other template is specified. We will learn more about templates in the next
    section.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按下 *Enter* 后，脚本会告诉我们它选择了基本模板，也称为 **Remix App Server**。如果没有指定其他模板，脚本默认使用基本模板。我们将在下一节中了解更多关于模板的内容。
- en: 'The script prompts us to initialize a new Git repository. Select **Yes**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本提示我们初始化一个新的 Git 仓库。选择 **是**：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install dependencies with npm? npm install has finished. Next, use the terminal
    to navigate into the newly created project folder:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 npm 安装依赖项？npm install 已完成。接下来，使用终端导航到新创建的项目文件夹：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations on bootstrapping your first Remix project! Let’s start the local
    development server.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 恭喜你初始化了你的第一个 Remix 项目！让我们启动本地开发服务器。
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command starts our Remix application locally:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令启动我们的 Remix 应用程序本地运行：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note how fast Remix builds. Built in 204 ms – that is the power of esbuild.
    The exact number of milliseconds varies based on your system, but it’s amazing
    that we can speak about build times in milliseconds!
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意 Remix 构建的速度有多快。在 204 毫秒内构建完成——这就是 esbuild 的力量。确切的毫秒数会根据你的系统而变化，但令人惊讶的是，我们可以在毫秒级别讨论构建时间！
- en: 'Open the specified URL in your browser: `http://localhost:3000`. It should
    render a simple HTML page.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开指定的 URL：`http://localhost:3000`。它应该渲染一个简单的 HTML 页面。
- en: Congratulations on running your first Remix application locally! However, it
    wouldn’t be a “Hello World!” project without printing “Hello World” on the screen.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 恭喜你在本地运行了你的第一个 Remix 应用程序！然而，如果没有在屏幕上打印“Hello World”，那就不是一个“Hello World”项目。
- en: 'Open the Remix project in an editor of your choice. In the editor, open the
    `_index.tsx` file, located in `app/routes`. You will find it exports a React component.
    Remove the existing JSX code and replace it with the following:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你选择的编辑器打开 Remix 项目。在编辑器中，打开位于 `app/routes` 的 `_index.tsx` 文件。你会找到一个导出 React
    组件的文件。删除现有的 JSX 代码，并用以下代码替换：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that Remix ships with TypeScript by default. Don’t be worried if you haven’t
    used TypeScript before. There are only a few instances where we will have to deal
    with TypeScript directly. Mostly, we can enjoy type inference and autocompletion
    without having to write types ourselves.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，Remix 默认使用 TypeScript。如果你之前没有使用过 TypeScript，请不要担心。我们只有少数几个地方需要直接处理 TypeScript。大多数情况下，我们可以享受类型推断和自动完成，而无需自己编写类型。
- en: 'Save the file changes. Your browser tab should now automatically reload and
    display the updated HTML: **Hello World!**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件更改。现在，你的浏览器标签应该会自动重新加载并显示更新后的 HTML：**Hello World!**
- en: The `create-remix` CLI script makes it easy to create new Remix applications.
    In this section, we bootstrapped a simple Remix application using the default
    template and rendered **Hello World!** to the screen. Next, let’s inspect the
    bootstrapped folder structure. We will inspect each file and study its function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-remix` CLI 脚本使得创建新的 Remix 应用程序变得简单。在本节中，我们使用默认模板初始化了一个简单的 Remix 应用程序，并在屏幕上渲染了
    **Hello World!**。接下来，让我们检查初始化的文件夹结构。我们将检查每个文件并研究其功能。'
- en: Understanding Remix’s file and folder structure
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Remix 的文件和文件夹结构
- en: Remix takes on the responsibilities of a compiler, router, and runtime. It provides
    the foundations and framing for the application. As such, it proposes a skeleton
    folder structure for the application. Some files serve as entry points that you
    can hook into. Others can be used to configure Remix. Let’s review our bootstrapped
    Remix app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 承担了编译器、路由器和运行时的责任。它为应用程序提供了基础和框架。因此，它为应用程序提出了一个骨架文件夹结构。一些文件作为入口点，你可以将其连接到应用程序中。其他文件可以用来配置
    Remix。让我们回顾一下我们的初始化 Remix 应用程序。
- en: 'Which files and folders are present depends on the selected configuration options
    during the creation process. However, most files are part of all setups. Selecting
    the basic Remix App Server template yields the following file and folder structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 存在哪些文件和文件夹取决于创建过程中的所选配置选项。然而，大多数文件都是所有设置的组成部分。选择基本 Remix App Server 模板会产生以下文件和文件夹结构：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s have a look at each file and folder. Remix ships with a `.eslintrc` file,
    which configures ESLint to extend Remix’s ESLint extensions. You can adapt or
    remove this file based on your linting and formatting preferences.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个文件和文件夹。Remix 随带一个 `.eslintrc` 文件，该文件配置 ESLint 以扩展 Remix 的 ESLint 扩展。你可以根据你的代码检查和格式化偏好调整或删除此文件。
- en: When initializing a new Git repository, Remix also creates a `.gitignore` file.
    It is set up to ignore Remix’s build artifacts, temporary files such as the `.cache`
    folder, and other commonly ignored files and folders. You can update this file
    based on your application’s requirements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化一个新的 Git 仓库时，Remix 也会创建一个 `.gitignore` 文件。该文件被设置为忽略 Remix 的构建工件、临时文件，例如
    `.cache` 文件夹，以及其他常见的被忽略的文件和文件夹。你可以根据你应用程序的需求更新此文件。
- en: Every newly created project comes with a `README.md` file. The file contains
    important information on how to run and deploy your application. The documentation
    varies based on the selected template. Make sure to read through the `README.md`
    file whenever you bootstrap a new Remix application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新创建的项目都附带一个 `README.md` 文件。该文件包含有关如何运行和部署你的应用程序的重要信息。文档根据所选模板而有所不同。确保在启动新的
    Remix 应用程序时阅读 `README.md` 文件。
- en: 'Next, let’s continue with the `package.json` file. If you have worked with
    Node.js-based projects before, you will be familiar with the content. Remix’s
    `package.json` file comes with all the sections you would expect:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续看 `package.json` 文件。如果你之前已经与基于 Node.js 的项目合作过，你应该熟悉其内容。Remix 的 `package.json`
    文件包含你预期的所有部分：
- en: '`scripts`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`'
- en: '`dependencies`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`'
- en: '`devDependencies`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`'
- en: The `scripts` section includes a set of scripts to run your Remix application
    locally, build your application, and run your application in production. Usually,
    those scripts are named `dev`, `build`, and `start`. Your application might come
    with additional scripts depending on the selected template.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts` 部分包含一组脚本来在本地运行你的 Remix 应用程序、构建你的应用程序以及在生产中运行你的应用程序。通常，这些脚本的名称为 `dev`、`build`
    和 `start`。你的应用程序可能根据所选模板包含额外的脚本。'
- en: Take a moment to investigate the `dependencies` and `devDependencies` sections.
    You might notice that Remix is split into several packages. Some are dependencies,
    and others are `dev` dependencies. One dependency to highlight is the adapter
    in use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 抽时间调查 `dependencies` 和 `devDependencies` 部分。你可能会注意到 Remix 被分割成几个包。一些是依赖项，而其他是
    `dev` 依赖项。一个值得强调的依赖项是正在使用的适配器。
- en: We learned in the previous chapter that Remix can run anywhere where JavaScript
    can be executed. Remix’s server-side HTTP request handler uses adapters to run
    on different JavaScript runtime and server environments. Each Remix application
    uses an adapter that sits between Remix and the web server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中学到，Remix 可以在任何可以执行 JavaScript 的地方运行。Remix 的服务器端 HTTP 请求处理器使用适配器在不同的 JavaScript
    运行时和服务器环境中运行。每个 Remix 应用程序使用一个位于 Remix 和网络服务器之间的适配器。
- en: The basic template uses the `@remix-run/serve` package to run on a Node.js server
    environment. The package implements the Remix App Server, a production-ready Express.js
    server. In contrast to other templates, the Remix App Server does not expose the
    Node.js server setup. Perfect to get started.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模板使用 `@remix-run/serve` 包在 Node.js 服务器环境中运行。该包实现了 Remix 应用服务器，一个生产就绪的 Express.js
    服务器。与其他模板相比，Remix 应用服务器不暴露 Node.js 服务器设置。非常适合开始使用。
- en: Next, let’s have a look at the `public` folder. The `public` folder contains
    static files and assets that are exposed over the internet. Currently, the folder
    includes a `favicon.ico` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `public` 文件夹。`public` 文件夹包含在互联网上公开的静态文件和资产。目前，该文件夹包含一个 `favicon.ico`
    文件。
- en: After running the app locally (`npm run dev`), the folder should further include
    a `build` folder. The folder is one of two `build` folders that contain your bundled
    app code. To build your application, locate your terminal and run `npm run build`.
    This will generate the two bundles for production based on your latest code changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行应用程序 (`npm run dev`) 之后，文件夹应进一步包含一个 `build` 文件夹。该文件夹是包含你的捆绑应用程序代码的两个 `build`
    文件夹之一。要构建你的应用程序，定位你的终端并运行 `npm run build`。这将根据你最新的代码更改生成两个用于生产的捆绑包。
- en: Remix includes a client and a server application. When writing your Remix application,
    you write code for two different environments, runtimes, and applications. The
    client-side application code is bundled into the `public/build` folder. These
    files are exposed over the internet and can be fetched from a browser.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 包含一个客户端和一个服务器应用程序。在编写你的 Remix 应用程序时，你需要为两个不同的环境、运行时和应用编写代码。客户端应用程序代码被打包到
    `public/build` 文件夹中。这些文件通过互联网公开，并且可以从浏览器中获取。
- en: If you peek inside the `public/build` folder, you can notice that each JavaScript
    module filename ends with a hash. The hash is referred to as the file’s fingerprint.
    There cannot be two files with the same name and different content. This simplifies
    caching. Since a new version of a file means a new file is generated, we can cache
    each file forever without having to deal with cache invalidations. If the content
    of a module changes in a new version of your application, then it will have a
    different unique filename and will be freshly loaded.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `public/build` 文件夹，你会注意到每个 JavaScript 模块文件名都以哈希结尾。这个哈希被称为文件的指纹。不能有两个文件名相同但内容不同的文件。这简化了缓存。由于文件的新版本意味着生成了一个新文件，因此我们可以永久缓存每个文件，而无需处理缓存失效问题。如果你的应用程序的新版本中模块的内容发生了变化，那么它将有一个不同的唯一文件名，并且将被重新加载。
- en: Inside the `public/build` folder, you can also locate a manifest file (`manifest-*.js`).
    Remix compiles an asset manifest, which is used to route requests and locate assets.
    Since the manifest must be accessed by the client, it is also part of the `public/build`
    bundle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `public/build` 文件夹中，你还可以找到清单文件（`manifest-*.js`）。Remix 编译一个资产清单，用于路由请求和定位资产。由于清单必须由客户端访问，它也是
    `public/build` 包的一部分。
- en: Let’s have a look at the `remix.config.js` file. This JavaScript file exports
    an `AppConfig` configuration object. This file can be used to configure Remix,
    enable future flags, and override Remix's default behavior. Normally, you won’t
    need to touch this file. However, since its content might change depending on
    what template and adapter you choose, it may be relevant when switching between
    templates or adapters. We will learn more about switching adapters later in this
    book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `remix.config.js` 文件。这个 JavaScript 文件导出一个 `AppConfig` 配置对象。这个文件可以用来配置
    Remix、启用未来标志和覆盖 Remix 的默认行为。通常，你不需要修改这个文件。然而，由于其内容可能取决于你选择的模板和适配器，因此在切换模板或适配器时可能相关。我们将在本书的后面部分学习如何切换适配器。
- en: Next, let’s inspect the `remix.env.d.ts` file. This file includes information
    for the TypeScript compiler. The file contains triple-slash directives that declare
    packages that the application is dependent on. The declarations tell TypeScript
    that your application is dependent on Remix’s packages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `remix.env.d.ts` 文件。这个文件包含 TypeScript 编译器的信息。该文件包含三斜杠指令，声明了应用程序所依赖的包。这些声明告诉
    TypeScript 你的应用程序依赖于 Remix 的包。
- en: Finally, there is the `tsconfig.json` file – or `jsconfig.json` file if you
    picked a template without TypeScript. These config files contain configuration
    options for the TypeScript compiler and are used to bundle and compile your Remix
    application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是 `tsconfig.json` 文件——或者如果你选择了一个没有 TypeScript 的模板，则是 `jsconfig.json` 文件。这些配置文件包含
    TypeScript 编译器的配置选项，并用于打包和编译你的 Remix 应用程序。
- en: Now that we have visited all top-level files and folders, let’s have a look
    inside the `app` folder. This is where the Remix application lives and where we
    write our application code. Remix populates the folder with a set of starter files.
    The `entry.server.tsx` and `entry.client.tsx` files serve as entry points for
    the client and server frameworks, respectively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经访问了所有顶级文件和文件夹，让我们来看看 `app` 文件夹。这是 Remix 应用程序所在的地方，也是我们编写应用程序代码的地方。Remix
    会用一系列启动文件填充这个文件夹。`entry.server.tsx` 和 `entry.client.tsx` 文件分别作为客户端和服务器框架的入口点。
- en: The `entry.client.ts` file contains the code that serves as an entry point for
    the client. Its responsibility is to hydrate React and, hence, initialize the
    SPA-like experience on the client. Remix exposes the entry file so that you can
    adapt it based on your use case. The file can serve as a great place for any code
    that has to be executed only once when the application first loads on the client.
    You can also delete the file, in which case Remix will fall back to the default
    implementation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry.client.ts` 文件包含作为客户端入口点的代码。其职责是使 React 保持活性，从而在客户端初始化类似 SPA 的体验。Remix
    提供了入口文件，以便您根据您的用例进行适配。该文件可以作为一个很好的地方来放置任何在客户端应用程序首次加载时只需执行一次的代码。您也可以删除该文件，在这种情况下，Remix
    将回退到默认实现。'
- en: 'The `entry.server.tsx` file exports the `handleRequest` function as its default
    export. The `handleRequest` function is called on incoming requests and generates
    the HTTP response. The general flow of `handleRequest` looks as follows: `handleRequest`
    is invoked with a request object and some additional parameters. The function
    renders React on the server side. The rendered markup is returned, wrapped in
    a new `Response` object, and returned to the adapter code, which passes the response
    to the server to serve the response to the client.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry.server.tsx` 文件将其默认导出为 `handleRequest` 函数。`handleRequest` 函数在传入的请求上被调用，并生成
    HTTP 响应。`handleRequest` 的一般流程如下：`handleRequest` 使用请求对象和一些附加参数被调用。该函数在服务器端渲染 React。渲染的标记被返回，并包装在一个新的
    `Response` 对象中，然后返回给适配器代码，适配器代码将响应传递给服务器以向客户端提供服务。'
- en: Let’s have a look at the `root.tsx` file and the `routes` folder. Remix utilizes
    a file-based routing solution. Every file inside the `routes` folder is considered
    a nested route module within the route tree. The file and folder hierarchy of
    the folder maps to the routing hierarchy. Every document/UI route must export
    a React component.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `root.tsx` 文件和 `routes` 文件夹。Remix 使用基于文件的路由解决方案。`routes` 文件夹中的每个文件都被视为路由树中的嵌套路由模块。文件夹的文件和文件夹层次结构映射到路由层次结构。每个文档/UI
    路由都必须导出一个 React 组件。
- en: 'The `root.tsx` file contains the root document route module. As such, it also
    exports a React component as its default export:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`root.tsx` 文件包含根文档路由模块。因此，它也将其默认导出为一个 React 组件：'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that Remix manages the full HTML document, including the `<html />` tag
    and the `<head />` tag in React. This gives us full control over the structure
    of our HTML document. With Remix, you can conditionally render meta tags, change
    the `lang` attribute, or add and remove client-side JavaScript (`<Scripts />`)
    conditionally.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Remix 管理整个 HTML 文档，包括 `<html />` 标签和 React 中的 `<head />` 标签。这使我们能够完全控制 HTML
    文档的结构。使用 Remix，您可以有条件地渲染元标签，更改 `lang` 属性，或有条件地添加和删除客户端 JavaScript (`<Scripts />`)。
- en: 'The route component in `root.tsx` renders several of Remix’s built-in components:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`root.tsx` 文件中的路由组件渲染了 Remix 的几个内置组件：'
- en: '`Meta`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Meta`'
- en: '`Links`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Links`'
- en: '`Outlet`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Outlet`'
- en: '`ScrollRestoration`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollRestoration`'
- en: '`Scripts`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scripts`'
- en: '`LiveReload`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveReload`'
- en: The `Meta` component adds meta tags defined in `meta` exports to the HTML document.
    Similarly, the `Links` component adds links defined in `links` exports. You will
    learn more about the `Meta` and `Links` components in [*Chapter 9*](B17399_09.xhtml#_idTextAnchor137),
    *Assets and* *Metadata Handling*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meta` 组件将定义在 `meta` 导出中的元标签添加到 HTML 文档中。同样，`Links` 组件将定义在 `links` 导出中的链接添加到
    HTML 文档中。您将在 [*第 9 章*](B17399_09.xhtml#_idTextAnchor137) 中了解更多关于 `Meta` 和 `Links`
    组件的信息，*资源和* *元数据管理*。'
- en: Instead of `{children}` – which you might have expected – Remix provides an
    `Outlet` component to specify where to render the child route. You will learn
    more about the `Outlet` component and nesting of child routes in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057),
    *Routing* *in Remix*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与您可能预期的 `{children}` 不同，Remix 提供了一个 `Outlet` 组件来指定渲染子路由的位置。您将在 [*第 4 章*](B17399_04.xhtml#_idTextAnchor057)
    中了解更多关于 `Outlet` 组件和子路由嵌套的信息，*Remix 中的* *路由*。
- en: The `ScrollRestoration` component manages scroll positions for all client-side
    navigations. SPAs avoid full page reloads and instead render a new page with JavaScript
    on the client. The `ScrollRestoration` component is used to emulate the browser’s
    default behavior and restore the scroll position when the browser’s back and forward
    buttons are used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollRestoration` 组件管理所有客户端导航的滚动位置。SPA 避免完整的页面重新加载，而是使用 JavaScript 在客户端渲染新的页面。`ScrollRestoration`
    组件用于模拟浏览器的默认行为，并在使用浏览器的后退和前进按钮时恢复滚动位置。'
- en: The `Scripts` component might be one of the most fascinating components that
    Remix exposes. The component adds all script tags of the bundled Remix application
    to the HTML document. By removing the `Scripts` component, we can remove all client-side
    JavaScript from our Remix application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scripts` 组件可能是 Remix 提供的最迷人的组件之一。该组件将捆绑的 Remix 应用程序的所有脚本标签添加到 HTML 文档中。通过移除
    `Scripts` 组件，我们可以从 Remix 应用程序中移除所有客户端 JavaScript。'
- en: The `LiveReload` component triggers page reloads during development whenever
    the development server detects any file changes. `LiveReload` is part of Remix’s
    development server setup and is not used in production environments.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveReload` 组件在开发过程中触发页面重新加载，每当开发服务器检测到任何文件更改时。`LiveReload` 是 Remix 开发服务器设置的一部分，在生产环境中不使用。'
- en: Notice that Remix offers us control over its inner workings by exposing when
    and how its built-in components are rendered. For instance, if we are not interested
    in live reloads during development, we can just remove the `LiveReload` component.
    If we want to develop static pages without client-side JavaScript, we can remove
    the `Scripts` component.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Remix 通过公开其内置组件何时以及如何渲染来提供对其内部工作的控制。例如，如果我们对开发过程中的实时重新加载不感兴趣，我们只需移除 `LiveReload`
    组件。如果我们想在没有客户端 JavaScript 的情况下开发静态页面，我们可以移除 `Scripts` 组件。
- en: The `routes` folder contains all other routes of your Remix application. As
    of now, it only contains an `_index` route. An `_index` route is the default child
    of its parent route and shares the same URL. The present `_index` route maps to
    the `/` pathname. We will learn all about routing in [*Chapter 4*](B17399_04.xhtml#_idTextAnchor057),
    *Routing* *in Remix*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes` 文件夹包含您的 Remix 应用程序的所有其他路由。到目前为止，它只包含一个 `_index` 路由。`_index` 路由是其父路由的默认子路由，并共享相同的
    URL。当前 `_index` 路由映射到 `/` 路径名。我们将在 [*第 4 章*](B17399_04.xhtml#_idTextAnchor057)，*Remix
    中的路由* 中了解所有关于路由的内容。'
- en: That was quite a few files! Remix acts as your compiler, router, and runtime.
    As such, Remix must be aware of your compiler configurations and the location
    of your code. Remix must further know about all your route modules. As your runtime,
    it also must own the entry points of your application. Since Remix is not a server,
    it must expose these entry points to the server environment. Most of the time,
    you don’t have to touch these entry points and configuration files. However, it
    is great that you can easily alter the content of those files and hook application
    logic into these places if needed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那是相当多的文件！Remix 充当您的编译器、路由器和运行时。因此，Remix 必须了解您的编译器配置和代码的位置。此外，作为您的运行时，它还必须了解所有您的路由模块。由于
    Remix 不是一个服务器，它必须将这些入口点暴露给服务器环境。大多数时候，您不需要触摸这些入口点和配置文件。然而，如果您需要，可以轻松地更改这些文件的内容并将应用程序逻辑钩入这些位置。
- en: Now that we have gone through Remix’s folder structure and investigated Remix’s
    configuration and project files, we will learn more about the two environments
    of your Remix application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 Remix 的文件夹结构，并调查了 Remix 的配置和项目文件，我们将进一步了解您的 Remix 应用程序的两种环境。
- en: Exploring the client and server environments
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索客户端和服务器环境
- en: 'In this section, you will learn about the two environments of every Remix application:
    the client and the server. First, we will learn more about how code is executed
    during runtime. Next, you will learn where to write your client and server code
    and how to help Remix’s compiler recognize what belongs in the client bundle and
    what belongs in the server bundle.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解每个 Remix 应用程序的两种环境：客户端和服务器。首先，我们将了解代码在运行时是如何执行的。接下来，您将了解在哪里编写您的客户端和服务器代码，以及如何帮助
    Remix 的编译器识别哪些属于客户端捆绑包，哪些属于服务器捆绑包。
- en: The two bundles of your Remix application
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的 Remix 应用程序的两个捆绑包
- en: The Remix App Server does not expose its server setup, but most other templates
    do. In this section, we will use the Express.js template to review how Remix interacts
    with the web server.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 应用程序服务器不公开其服务器设置，但大多数其他模板都这样做。在本节中，我们将使用 Express.js 模板来回顾 Remix 如何与 Web
    服务器交互。
- en: 'Follow these steps to bootstrap an Express.js Remix app:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤启动 Express.js Remix 应用程序：
- en: 'Run the following `create-remix` command in a terminal:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下 `create-remix` 命令：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pick a new folder location for this Remix application and follow the prompts
    as practiced in the previous section.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此 Remix 应用程序选择一个新的文件夹位置，并按照上一节中练习的提示进行操作。
- en: Review the new Remix application. Compare the `package.json` file with the Remix
    App Server `package.json` file from the last section. How do the `dependencies`
    and `scripts` sections differ?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾新的Remix应用程序。将`package.json`文件与上一节中的Remix App Server的`package.json`文件进行比较。`dependencies`和`scripts`部分有何不同？
- en: Next, open the `server.js` file. The file contains code to set up a new Express.js
    application. Let's go over the code together and discuss the most important aspects.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`server.js`文件。该文件包含设置新Express.js应用程序的代码。让我们一起来审查这段代码，并讨论最重要的方面。
- en: Notice that `createRequestHandler` is imported from Remix’s Express.js adapter
    (`@``remix-run/express`).
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`createRequestHandler`是从Remix的Express.js适配器（`@remix-run/express`）导入的。
- en: 'Next, the server build of the Remix application is dynamically imported:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，Remix应用程序的服务器构建是动态导入的：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'app.all(  "*",  process.env.NODE_ENV === "development"    ? createDevRequestHandler()    :
    build folder to the createRequestHandler function, using the `initialBuild` object
    we defined earlier.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app.all("*", process.env.NODE_ENV === "development" ? createDevRequestHandler()
    : createRequestHandler(initialBuild));`'
- en: '[PRE12]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the server environment is informed about both the client and server
    bundle of the Remix application. The client bundle is exposed over the internet.
    The server bundle is passed to the Remix adapter and called on incoming requests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，服务器环境被通知了Remix应用程序的客户端和服务器包。客户端包通过互联网暴露。服务器包传递给Remix适配器，并在传入的请求上调用。
- en: Remix is an HTTP request handler
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Remix是一个HTTP请求处理器
- en: Remix is not a web server but an HTTP request handler that runs on a server
    environment. Remix uses adapters to communicate with the underlying server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Remix不是一个Web服务器，而是一个在服务器环境中运行的HTTP请求处理器。Remix使用适配器与底层服务器进行通信。
- en: Remix’s adapter code is used within the server environment. The adapter passes
    requests from the server environment to our Remix application and manages our
    HTTP handler’s response using the primitives of the server environment. Depending
    on the selected template and deployment target, the server code differs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Remix的适配器代码在服务器环境中使用。适配器将来自服务器环境的请求传递给我们的Remix应用程序，并使用服务器环境的原语来管理我们的HTTP处理器的响应。根据所选模板和部署目标，服务器代码会有所不同。
- en: With Remix, we have full control over the `server.js` file. If necessary, we
    can hook into the server code and add additional logic. For instance, we could
    add a WebSocket server to our Express.js application and let it run next to our
    Remix application. Remix’s architecture offers full control over the runtime of
    our application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Remix，我们对`server.js`文件拥有完全的控制权。如果需要，我们可以将钩子插入到服务器代码中并添加额外的逻辑。例如，我们可以在我们的Express.js应用程序中添加一个WebSocket服务器，并让它与我们的Remix应用程序并行运行。Remix的架构为我们应用程序的运行时提供了完全的控制权。
- en: Next, let’s write some application code inside the `app` folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`app`文件夹内编写一些应用程序代码。
- en: Client and server code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端和服务器代码
- en: With Remix, you can take advantage of the full stack of the web platform. In
    this section, we will learn more about how to write client and server code in
    Remix.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Remix，你可以充分利用整个Web平台。在本节中，我们将学习如何在Remix中编写客户端和服务器代码。
- en: 'Earlier in this chapter, we printed **Hello World!** on the home page of our
    first Remix application. We used the following code to render a React component
    onto the screen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们在第一个Remix应用程序的首页上打印了**Hello World!**。我们使用了以下代码在屏幕上渲染一个React组件：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s investigate Remix’s client and server runtimes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查Remix的客户端和服务器运行时：
- en: 'Open your `Hello World!` Remix application in an editor and add a `console.log`
    statement into the `function` component in `app/_index.tsx`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开你的`Hello World!` Remix应用程序，并在`app/_index.tsx`中的`function`组件里添加一个`console.log`语句：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Start the Remix application locally. In your terminal window, execute `npm run
    dev` at the root of the project. Can you guess how many times the `console.log`
    statement will be run?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地启动Remix应用程序。在你的终端窗口中，在项目根目录下执行`npm run dev`。你能猜到`console.log`语句会被运行多少次吗？
- en: Open the application in a new browser tab.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新浏览器标签页中打开应用程序。
- en: Next, review the terminal where you executed npm run dev. You will see that
    Another hello to the world! is printed in the terminal.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，回顾你执行`npm run dev`命令的终端。你将看到终端中打印了“Another hello to the world!”。
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The terminal is connected to our server-side environment. Visiting the web page
    in a browser tab creates a `GET` request for the web server. `GET / 200` – the
    `GET` request to the `/` – path is responded to with status code `200`.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终端连接到我们的服务器端环境。在浏览器标签中访问网页会创建一个针对网络服务器的 `GET` 请求。`GET / 200` – 对 `/` 路径的 `GET`
    请求以状态码 `200` 响应。
- en: First, the request is received by the underlying server environment. The web
    server calls Remix’s adapter callback and the adapter forwards the request to
    Remix’s `handleRequest` function. Remix then renders the React application on
    the server. While our `Index` React component is executed, the `console.log` statement
    is called, printing the statement to the terminal. Conclusively, `console.log`
    is executed once on the server. But is that all?
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，请求被底层服务器环境接收。网络服务器调用 Remix 的适配器回调，适配器将请求转发到 Remix 的 `handleRequest` 函数。然后
    Remix 在服务器上渲染 React 应用程序。当我们的 `Index` React 组件执行时，`console.log` 语句被调用，将语句打印到终端。最终，`console.log`
    在服务器上只执行了一次。但这就是全部吗？
- en: Navigate to your browser window and open the developer tools in the tab that
    shows the Remix application. In the developer tools, navigate to the `entry.client.ts`
    file. Here, Remix rehydrates your React application. React re-renders on the client
    and renders the `Index` component again. Hence, the `console.log` statement is
    run once on the server and then also on the client.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的浏览器窗口，并在显示 Remix 应用的标签中打开开发者工具。在开发者工具中，导航到 `entry.client.ts` 文件。在这里，Remix
    重新激活你的 React 应用程序。React 在客户端重新渲染并再次渲染 `Index` 组件。因此，`console.log` 语句在服务器上执行一次，然后在客户端也执行一次。
- en: The React code of your Remix application is run on the server and on the client.
    However, some code should only ever run on the server or the client. For instance,
    the `entry.client.tsx` module should only run on the client, and the `entry.server.tsx`
    module should only ever be executed on the server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Remix 应用程序的 React 代码在服务器和客户端上运行。然而，有些代码应该只运行在服务器或客户端上。例如，`entry.client.tsx`
    模块应该只运行在客户端，而 `entry.server.tsx` 模块应该始终只在服务器上执行。
- en: It is also important that no server-side code makes it into the client bundle.
    The code in the client bundle is exposed over the internet. Think about your API
    tokens and other secrets that may be present in your backend logic. Moreover,
    the browser and server environments differ. Node.js APIs are not available on
    the client, and the browser’s global `window` object is not available in Node.js.
    Server-side code may throw errors when executed on the client, and vice versa.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，没有任何服务器端代码会进入客户端包。客户端包中的代码在互联网上暴露。想想你的 API 令牌和其他可能存在于你的后端逻辑中的秘密。此外，浏览器和服务器环境不同。Node.js
    API 在客户端不可用，而浏览器的全局 `window` 对象在 Node.js 中不可用。服务器端代码在客户端执行时可能会抛出错误，反之亦然。
- en: Remix is your compiler and bundles your code into a server and a client bundle.
    But how do we tell Remix what to bundle for the server and what to bundle for
    the client? Most of the time, Remix can figure it out by itself. Remix uses “tree
    shaking” to filter your code and aims to infer which code belongs to which bundle.
    However, you can also explicitly tell the compiler – and developers working on
    your project – that code should only be executed in one of the two environments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 是你的编译器，将你的代码打包成服务器和客户端包。但我们如何告诉 Remix 为服务器打包什么，为客户端打包什么？大多数时候，Remix 可以自己找出答案。Remix
    使用“摇树”来过滤你的代码，并试图推断哪些代码属于哪个包。然而，你也可以明确地告诉编译器——以及正在你项目上工作的开发者——代码应该只在两个环境中的一个中执行。
- en: Remix offers a convention to mark files as purely server-side or client-side
    modules. Adding `.client.` or `.server.` to the end of the filename tells Remix’s
    compiler to avoid including these files in the server or client bundle, respectively.
    For instance, you can name your database setup file `db.server.ts` to explicitly
    exclude it from the client bundle. Similarly, you can name a file that imports
    client-only libraries `libs.client.ts` to explicitly avoid importing these packages
    on the server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了一种约定来标记文件为纯服务器端或客户端模块。在文件名末尾添加 `.client.` 或 `.server.` 告诉 Remix 的编译器分别避免将这些文件包含在服务器或客户端包中。例如，你可以将你的数据库设置文件命名为
    `db.server.ts` 以明确排除它从客户端包中。同样，你可以将导入客户端库的文件命名为 `libs.client.ts` 以明确避免在服务器上导入这些包。
- en: You might have noticed that both entry files (`entry.server` and `entry.client`)
    follow this convention. Feel free to add `console.log` statements to both entry
    files and recognize where each statement is executed – the terminal window or
    the browser **Console** tab.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，入口文件（`entry.server` 和 `entry.client`）都遵循这个约定。你可以随意在两个入口文件中添加 `console.log`
    语句，并识别每个语句的执行位置——终端窗口或浏览器 **控制台** 选项卡。
- en: Note that some files cannot be declared as server or client files. For instance,
    route modules in the `/routes` folder must not be declared as client or server
    files as they may include both client and server code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些文件不能声明为服务器或客户端文件。例如，`/routes` 文件夹中的路由模块不能声明为客户端或服务器文件，因为它们可能包含客户端和服务器代码。
- en: In this section, you learned more about the code flow of a `GET` request through
    your Remix application. You learned that Remix receives `GET` requests on the
    server and renders your React application on both the client and the server. Some
    code in your Remix application is run on both environments, while other code should
    only run on one environment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了更多关于通过你的 Remix 应用程序进行 `GET` 请求的代码流程。你了解到 Remix 在服务器上接收 `GET` 请求并在客户端和服务器上渲染你的
    React 应用程序。你的 Remix 应用程序中的一些代码在两个环境中运行，而其他代码则应该只在其中一个环境中运行。
- en: Remix runs on both the client and the server. Learning how to troubleshoot across
    the two environments is crucial. In the next section, you will learn more about
    how to interpret error messages in your Remix application and where to get help.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 在客户端和服务器上运行。学习如何在两个环境中进行故障排除至关重要。在下一节中，你将了解更多关于如何解释 Remix 应用程序中的错误消息以及在哪里获得帮助。
- en: Troubleshooting Remix applications
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除 Remix 应用
- en: In this section, you will learn more about debugging Remix applications. First,
    we will provide you with a general process to approach issues while developing
    with Remix. Next, we will document how to best search for answers and get help
    from the community.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解更多关于调试 Remix 应用程序的知识。首先，我们将为你提供一个在开发 Remix 时处理问题的通用流程。接下来，我们将记录如何最好地搜索答案并从社区中获得帮助。
- en: A Remix troubleshooting process
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 Remix 故障排除过程
- en: Remix is not a server but runs on top of a web server and an underlying server
    runtime environment. Remix acts as an HTTP request handler, orchestrates your
    routes, executes your code during runtime, and acts as your compiler. Quite a
    few things can go wrong. That’s why it’s important to practice the process of
    debugging in Remix.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 不是一个服务器，而是在一个网络服务器和底层服务器运行时环境之上运行。Remix 作为 HTTP 请求处理器，编排你的路由，在运行时执行你的代码，并作为你的编译器。可能会有很多问题发生。这就是为什么在
    Remix 中练习调试过程很重要。
- en: 'In the last section, we learned more about Remix’s two environments, the client
    and the server. Remix runs on the server and then executes logic inside the browser.
    Hence, when debugging your Remix application, we must investigate both the client
    and the server environment. Let’s break the `Hello` `World!` App:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们了解了 Remix 的两个环境，客户端和服务器。Remix 在服务器上运行，然后在浏览器中执行逻辑。因此，在调试你的 Remix 应用程序时，我们必须调查客户端和服务器环境。让我们分解
    `Hello World!` 应用程序：
- en: 'Add the following troublesome code to the `app/routes/_index.tsx` file in your
    `Hello` `World!` app:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下有问题的代码添加到你的 `Hello World!` 应用程序中的 `app/routes/_index.tsx` 文件：
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run `npm run dev` to start the app if it is not already running.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序尚未运行，请运行 `npm run dev` 来启动应用程序。
- en: Visit the Remix app in a new browser window or refresh an existing one. Unfortunately,
    you will notice that the application throws an error. The page should show the
    headline **Application Error**. Snap! Let’s start debugging.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新浏览器窗口中访问 Remix 应用或刷新现有窗口。不幸的是，你会注意到应用程序抛出一个错误。页面应该显示标题 **应用程序错误**。哎呀！让我们开始调试。
- en: 1\. Trust the error message
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1. 信任错误消息
- en: 'If something goes wrong, the first thing you should do is inspect the terminal
    that is running Remix locally. You should be able to see the following error message
    in the terminal:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，你应该首先检查运行 Remix 的本地终端。你应该能够在终端中看到以下错误消息：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might have to scroll a bit to find the relevant line above the stack trace.
    Additionally, the error message should also be rendered in the browser tab. Remix
    displays a fallback error page in case something goes wrong. The error message
    on the page is more readable than on the terminal, but consider the terminal the
    source of truth when it comes to troubleshooting. In this case, both errors are
    matching. It seems like the `navigator` object is undefined.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要滚动一下才能找到堆栈跟踪上面的相关行。此外，错误消息也应该在浏览器标签页中显示。当出现问题时，Remix 会显示一个回退错误页面。页面上的错误消息比终端上的更易读，但考虑终端是故障排除的真相来源。在这种情况下，两个错误都是匹配的。看起来
    `navigator` 对象未定义。
- en: 2\. Locate the line
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2. 定位到该行
- en: Let’s investigate the error message in the terminal in more detail. We can utilize
    the stack trace to learn which file threw the error and follow the stack trace
    downward across the stack of function calls. You should be able to see that the
    `app/routes/_index.tsx` file threw the error. Seems like that’s an application
    error and not an error with Remix or a dependency since it’s our code that broke.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地调查终端中的错误消息。我们可以利用堆栈跟踪来了解哪个文件抛出了错误，并沿着函数调用堆栈向下跟踪堆栈跟踪。你应该能够看到 `app/routes/_index.tsx`
    文件抛出了错误。看起来这是一个应用程序错误，而不是 Remix 或依赖项的错误，因为是我们自己的代码出了问题。
- en: 3\. Build time or runtime
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3. 构建时间或运行时
- en: Next, note that the error occurs only after we request a page from the web server.
    As `npm run dev` succeeded without throwing any errors, this is a runtime issue,
    not a build time issue. The server also started without throwing errors. This
    indicates that the error occurred within the request handlers and not in the server
    startup code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意错误仅在我们从网络服务器请求页面后发生。由于 `npm run dev` 成功而没有抛出任何错误，这是一个运行时问题，而不是构建时问题。服务器启动时也没有抛出错误。这表明错误发生在请求处理器中，而不是在服务器启动代码中。
- en: 4\. The Console and Network tabs
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4. 控制台和网络标签页
- en: 'Let’s open the developer tools in the browser window. Click on the **Console**
    tab to view any logged client-side errors. The following error should show up:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器窗口中打开开发者工具。点击 **控制台** 标签以查看任何记录的客户端错误。以下错误应该显示出来：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A `GET` request failed with an internal server error. We investigate further
    by navigating to the **Network** tab, as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `GET` 请求因内部服务器错误而失败。我们进一步调查，通过导航到 **网络** 标签，如下所示：
- en: '![Figure 2.1 – Introducing the Network tab](img/Figure_2.01_B17399.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 介绍网络标签页](img/Figure_2.01_B17399.jpg)'
- en: Figure 2.1 – Introducing the Network tab
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 介绍网络标签页
- en: The `500`. In the **Response** tab (not shown in *Figure 2**.1*), we can further
    see that Remix returned an HTML document – the **Application Error** document
    we see on the screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**500**。在 **响应** 标签页（*图 2.1* 中未显示），我们可以进一步看到 Remix 返回了一个 HTML 文档 – 我们在屏幕上看到的
    **应用程序错误** 文档。'
- en: What happened? The web server attempted to handle the `GET` request but threw
    a `ReferenceError`. The error was caught by Remix. Remix returned an error response
    document to the browser. Remix uses the status code `500` – the status code for
    internal server errors – to tell us and the browser that the response is an error
    response.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？网络服务器尝试处理 `GET` 请求，但抛出了 `ReferenceError`。错误被 Remix 捕获。Remix 向浏览器返回了一个错误响应文档。Remix
    使用状态码 `500` – 内部服务器错误的状态码 – 来告诉我们和浏览器，响应是一个错误响应。
- en: 5\. Turn it off and on again
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5. 关闭并重新启动
- en: 'If we can’t identify the error thus far, it is a good idea to clean up any
    temporary files that might affect our local development server. Stop the development
    server if it is still running. Then run the following command to clean up all
    temporary `build` artifacts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到目前为止无法识别错误，清理可能影响我们本地开发服务器的任何临时文件是一个好主意。如果开发服务器仍在运行，请停止它。然后运行以下命令来清理所有临时的
    `build` 艺术品：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This removes all temporary files and folders. Next, restart the development
    server by executing `npm run dev` in the terminal. This triggers a new build and
    results in a cleaned-up local environment. Does the error persist? In our case,
    it does, but we are able to verify that the error is not due to a broken build.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除所有临时文件和文件夹。接下来，在终端中执行 `npm run dev` 来重新启动开发服务器。这将触发新的构建，并导致本地环境清理。错误仍然存在吗？在我们的情况下，它确实存在，但我们能够验证错误不是由于构建损坏造成的。
- en: 6\. Google the issue
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6. 在 Google 上搜索这个问题
- en: 'What would be your Google search query for this issue? Maybe see whether you
    can find the issue on Google. I would probably use one of the following searches:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，你会使用什么 Google 搜索查询？也许看看是否能在 Google 上找到这个问题。我可能会使用以下搜索之一：
- en: '`Navigator undefined` `server-rendered React`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Navigator undefined` `服务器渲染的 React`'
- en: '`Server throws with` `navigator undefined`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`服务器抛出` `navigator undefined`'
- en: '`Remix throws navigator not defined on` `the server`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remix 在服务器上抛出 navigator not defined`'
- en: The gotcha is that the `window` element and other browser globals do not exist
    in Node.js. Since we attempt to execute the React component on the server, it
    throws `ReferenceError` – not really a Remix issue but a common pitfall when rendering
    React code on the server. Case solved!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是 `window` 元素和其他浏览器全局变量在 Node.js 中不存在。由于我们尝试在服务器上执行 React 组件，它抛出 `ReferenceError`
    – 这不是 Remix 的问题，但在服务器上渲染 React 代码时的一个常见陷阱。问题解决！
- en: 'A quick fix for this type of error is to wrap references to browser APIs in
    `useEffect` calls:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误的快速修复方法是使用 `useEffect` 调用包裹对浏览器 API 的引用：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`useEffect` only runs after the initial render. Since we only render once on
    the server, we know that `useEffect` is only executed on the client and never
    on the server. We can safely call browser APIs in `useEffect`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 仅在初始渲染后运行。由于我们在服务器上只渲染一次，我们知道 `useEffect` 只在客户端执行，永远不会在服务器上执行。我们可以在
    `useEffect` 中安全地调用浏览器 API。'
- en: Can you think of any disadvantages of this approach? Reload your application
    and have a look at the terminal. It logs `Another hello to the world!`. On the
    server, we do not have access to the `navigator` object and instead use the default
    value of the React state. We only re-render the appropriate greeting message on
    the client.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到这种方法的任何缺点吗？重新加载你的应用程序并查看终端。它记录了 `Another hello to the world!`。在服务器上，我们没有访问
    `navigator` 对象的权限，而是使用 React 状态的默认值。我们只在客户端重新渲染适当的问候消息。
- en: What if JavaScript fails to load or is disabled? What if the request is made
    by a web crawler that doesn’t run JavaScript? On slow internet connections, the
    layout might flicker, and the user might first see the server value before it
    is updated once JavaScript is loaded. This is not a great user experience.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JavaScript 加载失败或被禁用怎么办？如果请求是由不运行 JavaScript 的网络爬虫发起的怎么办？在慢速互联网连接上，布局可能会闪烁，用户可能会先看到服务器值，然后在
    JavaScript 加载后更新一次。这不是一个好的用户体验。
- en: 'Remix provides utilities to work with user data right on the server – no need
    to use `useEffect` at all. Most of the time, we can avoid client-server state
    mismatches. For now, we can be pleased that we fixed the issue and learned how
    to investigate errors in Remix. We can summarize the described troubleshooting
    process as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了在服务器上处理用户数据的实用工具 – 完全不需要使用 `useEffect`。大多数时候，我们可以避免客户端-服务器状态不匹配。目前，我们可以满意地认为我们解决了问题，并学会了如何在
    Remix 中调查错误。我们可以将描述的故障排除过程总结如下：
- en: Find and read the error message in the terminal.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查找并阅读错误消息。
- en: Locate the file that produces the error.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位产生错误的文件。
- en: Understand whether it’s a build time or runtime error.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解这是构建时错误还是运行时错误。
- en: Check the browser developer tools to get more context.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查浏览器开发者工具以获取更多上下文。
- en: Remove all build artifacts and retry.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有构建工件并重试。
- en: Google the issue.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google 上搜索问题。
- en: Next, we will focus on *step 6*. Successful debugging takes practice and experience.
    Often, you just have to use Google. In the next section, we document where to
    find answers when working with Remix.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于 *第 6 步*。成功的调试需要练习和经验。通常，你只需要使用 Google。在下一节中，我们将记录在处理 Remix 时如何找到答案。
- en: Looking for answers
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找答案
- en: Successful debugging takes practice. Once you encounter an issue once or twice,
    you will get faster at figuring out the root cause. Until then, it is good practice
    to search for a solution online. In this section, you will learn how to get help
    when working with Remix.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调试需要练习。一旦你遇到一次或两次问题，你将更快地找出根本原因。在此之前，在网上寻找解决方案是良好的实践。在本节中，你将学习如何在处理 Remix
    时获得帮助。
- en: Follow the troubleshooting process as laid out in the last section. It is important
    that you gather as much information as possible. Once you start formulating your
    issue or question, you will find that a thorough investigation might already yield
    the answer. At least it will help identify the right keywords for your online
    search.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上一节中概述的故障排除过程进行操作。收集尽可能多的信息非常重要。一旦你开始制定你的问题或疑问，你会发现彻底的调查可能已经提供了答案。至少它将帮助你确定在线搜索的正确关键词。
- en: Most issues we encounter during development are not related to Remix. Most errors
    occur because of rendering React on the server, accidentally running server code
    on the client, or because of issues with node packages. In these cases, Stack
    Overflow, GitHub, and other places might have the answers we seek.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开发过程中遇到的大多数问题都与Remix无关。大多数错误发生是因为在服务器上渲染React、意外在客户端运行服务器代码，或者因为node包的问题。在这些情况下，Stack
    Overflow、GitHub和其他地方可能包含我们寻求的答案。
- en: If that is not the case, then I can only encourage you to join the Remix Discord
    server ([https://discord.com/invite/xwx7mMzVkA](https://discord.com/invite/xwx7mMzVkA)).
    The Remix community is very supportive.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这样，那么我只能鼓励你加入Remix Discord服务器([https://discord.com/invite/xwx7mMzVkA](https://discord.com/invite/xwx7mMzVkA))。Remix社区非常支持。
- en: Before asking a question, make sure to use Discord’s search feature to see whether
    the question has already been asked and answered. This saves everyone time. By
    following the troubleshooting process, you should be able to provide plenty of
    context that can help the community debug your code. Providing code snippets (or,
    better, a code sandbox or public repository) will also greatly improve the likelihood
    that the community can assist you. The Remix community is amazing, and Discord
    is a great place to seek help.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在提问之前，请确保使用Discord的搜索功能查看问题是否已经被提出并解答。这样可以节省每个人的时间。通过遵循故障排除过程，你应该能够提供足够多的上下文，以帮助社区调试你的代码。提供代码片段（或者更好的是，一个代码沙盒或公共仓库）也将大大提高社区帮助你解决问题的可能性。Remix社区非常棒，Discord是一个寻求帮助的好地方。
- en: 'If you have issues with Remix primitives or conventions, refer to the Remix
    documentation. The following page compiles a list of common pitfalls: [https://remix.run/docs/en/2/guides/gotchas](https://remix.run/docs/en/2/guides/gotchas).
    These are issues that are harder to debug. Being aware of them ahead of time can
    save you costly debugging time.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到Remix原语或约定的相关问题，请参考Remix文档。以下页面汇总了常见的问题：[https://remix.run/docs/en/2/guides/gotchas](https://remix.run/docs/en/2/guides/gotchas)。这些问题更难调试。提前了解它们可以节省你昂贵的调试时间。
- en: In this section, you learned how to troubleshoot issues while working with Remix.
    You went through an example error and applied the proposed debugging process to
    uncover the root cause. You further learned more about how to search for answers
    and where to ask questions online.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何在处理Remix时解决问题。你通过一个示例错误并应用提出的调试过程来揭示根本原因。你还进一步学习了如何在线搜索答案以及在哪里提问。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created our first Remix application. We used Remix’s `create-remix`
    CLI script to bootstrap one Remix app with the basic template and one using Remix’s
    Express.js template.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了我们的第一个Remix应用程序。我们使用Remix的`create-remix` CLI脚本来启动一个带有基本模板的Remix应用程序，以及使用Remix的Express.js模板。
- en: By following this chapter, you have learned how to build and run Remix applications
    locally using `npm run dev` and `npm run build`. More importantly, you understand
    where to find all available scripts (`package.json`) and additional information
    for running a specific template (`README.md`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本章，你学习了如何使用`npm run dev`和`npm run build`在本地构建和运行Remix应用程序。更重要的是，你了解了如何找到所有可用的脚本（`package.json`）以及运行特定模板的附加信息（`README.md`）。
- en: 'We reviewed Remix’s file and folder structure. After reading this chapter,
    you know about the client and server entry points: `entry.client.tsx` and `entry.server.tsx`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了Remix的文件和文件夹结构。阅读本章后，你了解了客户端和服务器入口点：`entry.client.tsx`和`entry.server.tsx`。
- en: We also spent some time investigating the `root.tsx` file. The `root.tsx` file
    acts as the root of the route tree. Remix utilizes React to render the full HTML
    document, including the head, bundled scripts, links, and meta tags. This provides
    full control over what is rendered on the screen.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也花了一些时间调查了`root.tsx`文件。`root.tsx`文件作为路由树的根。Remix利用React渲染完整的HTML文档，包括头部、打包的脚本、链接和元标签。这提供了对屏幕上渲染内容的完全控制。
- en: 'We changed the code of the `_index` route and rendered `Hello World!` to the
    screen. Next, we studied Remix’s two environments: the client and the server.
    You learned that Remix runs in the browser and on a web server. Remix compiles
    the application code into a client and a server build. The web server exposes
    the client code as static files while calling the server bundle during runtime
    to handle incoming requests.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了 `_index` 路由的代码，并在屏幕上渲染了 `Hello World!`。接下来，我们研究了 Remix 的两个环境：客户端和服务器。您了解到
    Remix 在浏览器和 Web 服务器上运行。Remix 将应用程序代码编译成客户端和服务器构建。Web 服务器在运行时将客户端代码作为静态文件暴露，同时调用服务器包来处理传入的请求。
- en: Remix uses adapters to run on different web servers and server runtimes. The
    adapter manages the communication between our Remix app and the underlying server
    code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 使用适配器在不同的 Web 服务器和服务器运行时上运行。适配器管理我们的 Remix 应用与底层服务器代码之间的通信。
- en: Finally, we practiced troubleshooting Remix applications by solving an example
    error. You learned how to investigate errors by looking both at the server’s terminal
    and the **Console** tab in the browser. You also practiced searching for issues
    online, and you found out where to ask the Remix community for help.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过解决一个示例错误来练习了 Remix 应用的故障排除。您学习了如何通过查看服务器的终端和浏览器中的 **控制台** 选项卡来调查错误。您还练习了在线搜索问题，并发现可以向
    Remix 社区寻求帮助的地方。
- en: In the next chapter, you will learn more about different templates, deployment
    targets, adapters, and Remix stacks. We will compare different server runtimes
    and deployment environments so you can pick the right one for your Remix apps.
    You will also be introduced to `Bee-Rich`, the demo application of this book.
    Get ready to build a Remix application start to finish following the chapters
    of this book!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解有关不同模板、部署目标、适配器和 Remix 栈的更多信息。我们将比较不同的服务器运行时和部署环境，以便您为您的 Remix 应用选择正确的选项。您还将被介绍到
    `Bee-Rich`，这是本书的演示应用程序。准备好按照本书的章节从头到尾构建一个 Remix 应用程序吧！
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You don’t need to use `create-remix` to bootstrap a new Remix project. You
    can also start from scratch by installing Remix’s dependencies and setting up
    the file and folder structure yourself. If you are curious about this approach,
    follow the 5-minute tutorial from the Remix documentation: [https://remix.run/docs/en/2/start/quickstart](https://remix.run/docs/en/2/start/quickstart).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用 `create-remix` 来引导新的 Remix 项目。您也可以通过安装 Remix 的依赖项并自行设置文件和文件夹结构从头开始。如果您对这个方法感兴趣，请遵循
    Remix 文档中的 5 分钟教程：[https://remix.run/docs/en/2/start/quickstart](https://remix.run/docs/en/2/start/quickstart)。
- en: 'We introduced you to the Remix App Server. You can read more about the Remix’s
    basic template here: [https://remix.run/docs/en/2/other-api/serve](https://remix.run/docs/en/2/other-api/serve).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您介绍了 Remix 应用服务器。您可以在以下链接中了解更多关于 Remix 基本模板的信息：[https://remix.run/docs/en/2/other-api/serve](https://remix.run/docs/en/2/other-api/serve)。
- en: 'As mentioned earlier in the chapter, refer to Remix’s own troubleshooting guide
    to get help with common gotchas: [https://remix.run/docs/en/2/guides/gotchas](https://remix.run/docs/en/2/guides/gotchas).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，请参考 Remix 的自身故障排除指南以获得常见问题的帮助：[https://remix.run/docs/en/2/guides/gotchas](https://remix.run/docs/en/2/guides/gotchas)。
