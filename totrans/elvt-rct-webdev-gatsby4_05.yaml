- en: '*Chapter 4*: Creating Reusable Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is where you will really begin to see the power that Gatsby brings
    to larger sites. You will learn about how we can programmatically create pages
    using reusable templates and data sourced via GraphQL. By the end of this chapter,
    you will have created lists of blog posts, blog pages, and tag pages. You'll also
    understand how to introduce pagination and search functionality to your site.
  prefs: []
  type: TYPE_NORMAL
- en: All the pages we have created up until now have been single instances, meaning
    there is only one copy of that page on the site (for example, our index page,
    of which there will be only one copy ever). But what happens when we consider
    pages such as blog pages? It would be a very laborious process to create a single
    instance page for each post. So, instead, we can use **templates**. A template
    is a multi-instance of a page component that is mapped to data. For every node
    in a GraphQL query, we can create a page using this template and populate it with
    the data of that node.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what we mean by templates in Gatsby, let's create our
    first few templates, and then **programmatically** create pages with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating templates and programmatic page generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need to have completed [*Chapter 3*](B15983_03_ePub_RK.xhtml#_idTextAnchor057),
    *Sourcing and Querying Data (from Anywhere!)*. You''ll get the most out of this
    chapter if you have a collection of blog posts that we can use to build our pages,
    ingested into Gatsby. The source doesn''t matter â€“ you''ll be ready to start this
    chapter if you can see them in your GraphQL data layer. If you don''t have any
    posts to hand, you can find some placeholder Markdown files that you can ingest
    in Gatsby here: [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04/placeholder-markdown).'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To keep the code snippets at a manageable size, many of the examples in this
    chapter have styling omitted and comments pointing to code we've already written.
    To see a fully styled version of these components, please navigate to this book's
    code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating templates and programmatic page generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will programmatically generate pages using templates. We
    will be creating blog pages, blog list preview pages, and tag pages. To make all
    of this work correctly, it is important to ensure that each node of data that
    you are ingesting to populate blog pages contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Title**: The title of the blog post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A one-line description of what the blog post contains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date**: The date that the post should be published.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tags**: A list of tags that the blog post is associated with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**: The main content of the post.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are sourcing more than one type of content from the same source, it would
    be a good idea to also include a **type** field. This will allow you to filter
    out nodes that don't belong to this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method for adding these to your nodes will change, depending on the source.
    However, in the case of Markdown, you could create your posts in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added `title`, `desc`, `date`, and `tags` to `frontmatter`. Our body
    content would then be everything following `frontmatter`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: I will be querying data from local Markdown files within this chapter. If you
    are sourcing content from another type of local or a remote source, you can still
    use all the code except the queries and node field manipulation, which you will
    have to modify to work with your source. If you are struggling to construct your
    queries, refer back to [*Chapter 3*](B15983_03_ePub_RK.xhtml#_idTextAnchor057),
    *Sourcing and Querying Data (from Anywhere!)*.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of your source, you should ensure that your content is populated
    with the same fields to ensure GraphQL queries for blog-related data are always
    consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established the necessary blog node data fields, let's create
    blog post pages using our data.
  prefs: []
  type: TYPE_NORMAL
- en: Blog post template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create pages for each blog post we have. We will be
    creating and using our first template to do this with the help of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `gatsby-node.js` file so that it includes the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `onCreateNode` function is called whenever a new node is created. Using
    this function, we can transform nodes by adding, removing, or manipulating their
    fields. In this specific case, we are adding a `slug` field if the node is of
    the `MarkdownRemark` type. A `slug` is an address for a specific page on our site,
    so in the case of our blog page, we want every blog post to have a unique `slug`
    where it will render on the site. Creating slugs from filenames can be complicated
    as you need to handle characters that would break URL formatting. Luckily, the
    `gatsby-source-filesystem` plugin ships with a function called `createFilePath`
    for creating them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that each blog page has a `slug` by running your development server and
    using GraphiQL to explore your nodes. If you are using Markdown, you should find
    it within the `fields` object on `MarkdownRemark` nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder inside `src` called `templates` to house our page templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file inside `templates` called `blog-page.js`. This is the file
    where we will create our blog page template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `blog-page.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are creating the blog post template with a static set of data that
    we will switch out for real content shortly. You can see that we have a heading
    containing our blog post title. We then follow it with the blog's `Date` and a
    `TagList` component, which we will make shortly. Finally, we have the main `Article
    Body`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a folder inside `src/components` called `blog-posts`, in which we will
    store any component related to the blog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `TagList` component in the `src/components/blog-posts` file. We will
    use this component whenever we want to render a list of `tag` badges on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component takes in an array of `tags` as a prop, maps over them, and returns
    a styled `div` containing that `tag`. This is all wrapped up in a `Fragment` component.
    By using a `Fragment`, we can avoid enforcing the ordering and positioning of
    our `tags`, and can instead allow the parent element to decide.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have created a template file and its components, we can use it within
    our `gatsby-node.js` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to the top of your `gatsby-node.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are utilizing the `createPages` function, which allows us to create
    pages dynamically. To ensure you can query all your data, this function is only
    run once all your data has been sourced. Inside this function, we first destructure
    the `actions` object to retrieve the `createPage` function. Then, we tell Gatsby
    where to find our blog post template. With these two pieces in place, we are now
    ready to query our data. You should see a familiar GraphQL query for selecting
    the `slug` from all the Markdown where the type is *Blog*. We then have a small
    `if` statement to catch errors but, assuming it's successful, we then have all
    the data we need to create pages. We can loop through the result of our data and
    loop through every data node, creating a page for each one by specifying a path
    (using `slug`) and our template. You'll also notice that we are defining some
    `context` here. Data that's defined in `context` is available in page queries
    as GraphQL variables, which will make it easy to map the correct Markdown content
    to the correct pages in the following steps. Restart your development server and
    open the development 404 page by navigating to any non-existent route on the port.
    This will display a list of pages on your site, including the pages we have just
    created. Clicking on one should render the static content we defined when creating
    the template. Now that these pages have been created successfully, let's navigate
    back to the template and modify it to retrieve the correct content instead of
    the static content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `src/templates/blog-post.js` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By restarting your development server and navigating to one of your blog pages
    again, you should now see it populated with its node data. You've successfully
    made your first programmatic pages!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we only have a few blog posts, creating all of these pages won''t take very
    long. However, what happens if you have thousands of pages to create? Instead
    of waiting for all your site pages to build, you can instruct Gatsby to defer
    the generation of some of these pages. You can do this by passing `defer:true`
    to the `createPage` function in `gatsby-node.js`, like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this change, any page that's created in this way will be built the first
    time that that page is requested instead of at build time. This feature changes
    the kind of build from a static build to a hybrid build. For more information
    on this difference, please read [*Chapter 9*](B15983_09_ePub_RK.xhtml#_idTextAnchor127),
    *Deployment and Hosting*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have created blog post pages, we must have some way of linking to
    them from our other pages. Let's create a blog preview template page, where we
    can have a list of our blog posts with previews and a link to the pages we have
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: Blog preview template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we could create a single list of blog posts and render it, it is a standard
    pattern for websites to divide lists of blog posts, articles, and products using
    **pagination**. Using pagination within your site has three main benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better page performance**: If every article includes an image in the preview,
    then with every added item, we are increasing the amount of data we need to transfer
    to the client significantly. By introducing pagination, the client will only download
    small segments of data as they browse a group of items. This leads to faster page
    load times, which is particularly important in areas with low bandwidth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved user experience**: Displaying all the content on a single page could
    overwhelm the user, so instead, we must break down our content into small and
    manageable chunks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier navigation**: If we render hundreds of products in one continuous
    list, the user will have no idea how many products are there while scrolling through.
    By breaking content down into multiple pages with a set quantity of products on
    each, the user can understand the scale of your content better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all that in mind, let''s create a paginated blog preview page using a
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Pagination` component in the `src/components/blog-posts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have created the component that will allow us to access paginated
    blog preview pages. The component contains the number of pages and the current
    page as props. Using these two pieces of information, we can determine whether
    a user can navigate forward or back from their current page. How this component
    works is best explained by seeing how it renders:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1 â€“ Pagination component states'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B15983.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.1 â€“ Pagination component states
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first case, the current page is **1**, so there is no need to render
    a **Previous** button. Instead, we only show the preceding pages and the **Next**
    button. In the second case, we are on page **2**, where the user can navigate
    both forward and back, and as such, we can render the **Previous** and **Next**
    buttons. In the last case, we are on the last page, so we don't need to render
    the **Next** button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new template in `src/templates/` called `blog-preview.js` and add
    the following page query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The query within this file sources data from `allMarkdownRemark` (which I have
    named `blogposts` in this query). The `blogposts` query retrieves all the Markdown
    where the `frontmatter` type is equal to `Blog`. It sorts the collection of posts
    by descending `date`. Here's where things get interesting â€“ we also provide a
    `skip` and `limit` to the query. `skip` tells the query how many documents from
    the collection to skip over, while `limit` tells the query to limit the number
    of results to that quantity. We will be providing `skip` and `limit` to the page
    context, as well as `numPages` and `currentPage`, within our `gatsby-config.js`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the page component before the query in the `blog-preview.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with our other queries, when the query at the end of this file runs, it will
    provide `data` to our page via the `data` prop. Here, we are destructuring `pageContext`
    to access `numPages` and `currentPage`. We are also using destructuring `data`
    to get `nodes` from the `blogposts` query. We will add our render via the `return`
    statement in the following step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `return` statement in this same file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use `nodes` from the two sources to map through posts, render a preview of
    each (making use of the `TagList` component), as well as render our `Pagination`
    component. Now that we have created our template, we can ingest it into our `gatsby-config.js`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your `gatsby-config.js` file''s `createPages` function with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are now ready to start your development server to verify that pagination
    is working. You should see your posts in descending date order located at `/blog`.
    If you have more posts than your `postsPerPage` value, you should also see your
    `Pagination` component, showing you that there are additional pages and allowing
    you to navigate there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have implemented a blog preview page, let's use what we have learned
    to create one more collection of pages â€“ tag pages.
  prefs: []
  type: TYPE_NORMAL
- en: Tag page template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a user, seeing my posts in date order is not always enough â€“ I may want to
    be able to find groups of posts associated with a single topic. Tag pages are
    pages you navigate to whenever you click on one of a blog post's tags. Navigating
    to one of these pages, you are presented with a list of posts that are associated
    with that tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s programmatically create tag pages for each tag that''s present in our
    articles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `lodash`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`lodash` is a JavaScript utility library that we will be using to make tags
    URL-friendly. Because a single tag might consist of multiple words, we need a
    way to remove the spaces. While you could create a function yourself to do this,
    `lodash` has a `.kebabCase()` function that works well for this use case.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `TagList` component to turn our `tag` badges into `Link` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As `Link` components, they need a `to` prop. This prop should point to where
    your `tag` pages will be created â€“ in our case, `/tags/tag-name` is the location.
    We can use the `kebabCase` function from `lodash` to ensure that any spaces in
    tags are turned into hyphens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `tags.js` file in the `src/templates` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component will appear very similar to our previously constructed `blog-preview.js`
    file in the *Blog preview template* section, except for a minor change to the
    query. In this query, we still source our Markdown content, but this time, we
    filter out the posts that do not contain the page's tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the page component before the query in the `tags.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The page then renders a paragraph containing the tag you are currently filtering
    posts with, followed by the filtered list of posts. Each post preview is rendered
    with its `title`, `date`, description (`desc`), and `tags`, just like in the `blog-preview.js`
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you intend to render the same items in the lists of both your `blog-preview.js`
    and `tags.js` files, then you should probably abstract the item preview component
    into a separate component. To keep these examples independent, I will not do this
    here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import `lodash` into the top of your `gatsby-config.js` file, next to the other
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need to use lodash's `kebabCase` in this file as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add your tag template and query to your `gatsby-config.js` files'' `createPages`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are now ready to start your development server to verify that the tag pages
    are working. Navigate to the development 404 page; you should see a page starting
    with `tags/` for each tag. Clicking on one of these, you should be presented with
    our tag page template and a list of blog posts associated with that tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Exercise
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We've learned how to paginate blog lists, as well as create tag pages. Why not
    take this one step further and paginate your tag pages?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, we have learned how to programmatically create pages for blog posts,
    blog lists, and tags. Now, let's turn our attention to how we might create a site
    search so that as the site expands, finding our blog's content is easier.
  prefs: []
  type: TYPE_NORMAL
- en: Search functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways of integrating a site search. Many options are
    both hosted and local. For small projects, such as the site we are creating, it's
    often better to opt for a local index solution as the number of pages you are
    searching through is never that large. This also means that your site search will
    work in offline scenarios, which can be a real plus.
  prefs: []
  type: TYPE_NORMAL
- en: '`elasticlunr` Gatsby plugin, content is indexed and then made available via
    GraphQL to `elasticlunr` index. Search queries can then be made against this index
    to retrieve page information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s integrate a site search using `elasticlunr`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `elasticlunr` Gatsby plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `elasticlunr` plugin to your `gatsby-config.js` plugins array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As part of `options`, we provide the plugin with a list of `fields` that we
    would like to index. Then, we give it a `resolvers` object, which explains how
    to resolve `fields` for a source. Within our blog posts, we can retrieve `title`,
    `tags`, and `desc` from `frontmatter`. We can construct `path` with that specific
    content with a string and the data's `slug`. Finally, we also pass a `filter`.
    This `filter` tells the plugin to only use nodes where the `frontmatter` type
    is of the `Blog` type, as it is only our blog pages that we want to be searchable
    at this moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Search.js` component in the `src/layout` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Search` component takes in `searchIndex` as a prop. One of the first things
    you will notice is a `useEffect` hook that loads the index into a state hook.
    Once we have loaded in the index, we can query it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `search` function below `useEffect`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see that whenever the `search` function is called, we `search` the
    index using our `query` string. You will notice that we are passing in `expand:
    query.length > 2` as an option to the `search` function. This tells `elasticlunr`
    to allow partial matches if more than two characters have been entered. If you
    allow partial matches for fewer characters, you will often find that you get an
    abundance of results that are not related to what the user is looking for. Once
    we have searched the index, we can `map` over `documentStore` within `index` and
    return the document results, which are then passed to state via the `useState`
    hook.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `search` result render function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We `map` over results from the state using the `results` value from the `useState`
    hook and render the results to the screen within our render function. For a slightly
    better user experience, it's often a good idea to include a `searchResultSize`
    constant. This value determines the maximum number of results to display. This
    stops cases where you have hundreds of results and see the overlay run off the
    page. Instead, if there are more results, we simply indicate to the user how many
    more results there are.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your `Header.js` file to retrieve the site index and pass it to your
    `Search` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have completed our search functionality, restart your development
    server. You should see that the header of our site now contains our `Search` component.
    Try typing in a few characters and click on one of the results. You should be
    navigated to the corresponding page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By adjusting the resolvers and using the same methodology and tools outlined
    here, we could add pages of different types to our results to create a true site-wide
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to programmatically create pages using reusable
    templates. You should feel confident that you can now create pages using any GraphQL
    data source. We've implemented a list of blog posts with pagination, blog pages,
    tag pages, and created a site search for blog posts that even works offline.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will master the art of adding images to our Gatsby site.
    First, we will learn why importing images is not that simple, before creating
    images that progressively load in and are performant.
  prefs: []
  type: TYPE_NORMAL
