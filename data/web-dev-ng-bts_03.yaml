- en: Bootstrap - Grid Layout and Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap - 网格布局和组件
- en: 'Hey—you made it to [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components.* Awesome! Next on the agenda is to pour
    yourself a cup, or glass, of your favorite beverage, because this is a big and
    important chapter—and so you''re going to want to be awake for it. However, it''s
    not going to be all work and no play, because this chapter is where we''re going
    to start building our example application together and we should be able to have
    some fun with it. Along the way, we''ll also be covering quite a bit of material
    in various areas. Here''s the list of things that we''re going to cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿——您已经到达[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)，*Bootstrap – 网格布局和组件*。太棒了！接下来的议程是倒一杯您最喜欢的饮料，因为这是一个重要的章节，您会希望保持清醒。然而，这并不全是工作，因为这一章是我们一起开始构建示例应用程序的地方，我们应该能够在其中玩得开心。在这个过程中，我们还将涵盖各个领域的相当多的材料。以下是我们将要涵盖的内容列表：
- en: We're going to formally introduce our example application, called Listing Carousel,
    and this includes some suggestions for how you may leverage this application into
    something else that you may prefer doing—either alongside this book (instead of
    building Listing Carousel), or after finishing the book, if you'll first be building
    Listing Carousel along with me.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将正式介绍我们的示例应用程序，名为Listing Carousel，并提出一些建议，说明您可以如何将此应用程序转化为您可能更喜欢的其他事情——可以是在本书旁边（而不是构建Listing
    Carousel），或者在完成本书后，如果您首先与我一起构建Listing Carousel。
- en: We're going to cover our game plan for how we're going to incrementally build
    our application throughout the book, and you will also see that we have a few
    alternative technologies to choose from for building Listing Carousel—or for an
    application of your choice that you may be inspired to build by the end of the
    book.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将介绍我们在整本书中如何逐步构建我们的应用程序的计划，并且您还将看到我们有一些备选技术可供选择，用于构建Listing Carousel，或者您可能会在本书结束时受到启发，选择构建自己喜欢的应用程序。
- en: We're also going to take a look at Sass, which is a technology for making writing
    your CSS for your projects a little easier, and even more organized.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将研究Sass，这是一种使编写项目中的CSS变得更容易、更有组织的技术。
- en: 'We''ll definitely be looking at Bootstrap—at both of its major parts: its responsive
    grid, and a few of its components.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们肯定会研究Bootstrap——它的两个主要部分：响应式网格和一些组件。
- en: In [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start*, we
    took a sneak peek at some of the wireframes that will make up our example application.
    Well, this chapter is where we're going to write the HTML code, leveraging Bootstrap,
    to bring the wireframes to life.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)，*快速入门*中，我们偷偷看了一些将构成我们示例应用程序的线框图。好吧，这一章是我们将编写HTML代码，利用Bootstrap，将线框图变为现实的地方。
- en: As bonus material, we'll also be looking at the process in which software projects
    go from inception to realization, using a real-life case study, Listing Carousel.
    This includes project phases, such as analysis, requirement gathering, use cases
    diagrams, wireframing, and implementation.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为额外材料，我们还将研究软件项目从构思到实现的过程，使用一个真实的案例研究，即Listing Carousel。这包括项目阶段，如分析、需求收集、用例图、线框图和实施。
- en: By the end of this chapter, our web pages will be hardcoded, and won't have
    any Angular code in them whatsoever. As we progress through the book, we will
    start to slowly bring them to life by gradually converting our Bootstrap application
    into a fully fledged Angular application by adding routing, Angular components,
    templates, data, and more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们的网页将是硬编码的，不会有任何Angular代码。随着我们在书中的进展，我们将逐渐将它们转变为一个完全成熟的Angular应用程序，通过添加路由、Angular组件、模板、数据等。
- en: A word about what this chapter is not
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于本章不包括的内容
- en: This chapter covers a lot of ground, including Sass, and Bootstrap's responsive
    grid and several of its components. However, this chapter is not comprehensive
    coverage of all you need to know about either of these things. The reasoning for
    this is simple—not only are there books devoted to Bootstrap, but Bootstraps's
    website is the ideal place for where to look up documentation on Bootstrap. Duplicating
    their documentation would not have been a good use of this book's pages, nor would
    it have been a good use of your time and hard-earned money. Instead, the smarter
    thing to do is to introduce Bootstrap's grid and components in a practical way—such
    as by building an application together in this book—and to just refer you to the
    official documentation as needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了很多内容，包括Sass和Bootstrap的响应式网格以及其中的一些组件。然而，本章并不全面涵盖您需要了解的这些内容。原因很简单——不仅有专门讲解Bootstrap的书籍，而且Bootstrap的官方网站是查找Bootstrap文档的理想地方。重复他们的文档不是这本书页面的好用处，也不是您的时间和辛苦赚来的钱的好用处。相反，更明智的做法是以实际的方式介绍Bootstrap的网格和组件——比如在本书中一起构建一个应用程序，并在需要时参考官方文档。
- en: By the way, the same thing applies to [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-Layout
    – Angular's Responsive Layout Engine*, [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working
    with NG Bootstrap*, and [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working
    with Angular Material*,because each of these technologies has their own official
    documentation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，同样的情况也适用于[第5章]，*Flex-Layout – Angular's Responsive Layout Engine*，[第8章]，*使用NG
    Bootstrap*，和[第9章]，*使用Angular Material*，因为每种技术都有它们自己的官方文档。
- en: 'My job is to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我的工作是做以下事情：
- en: Introduce these technologies to you (and point you to their official documentation)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您介绍这些技术（并指向它们的官方文档）
- en: Demonstrate how they can be applied in a practical, interesting, and, hopefully,
    engaging way
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示它们如何以实际、有趣和引人入胜的方式应用
- en: Encourage you to work through the entire book, so you can be well on your way
    to becoming an Angular web development guru
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼓励您通读整本书，这样您就可以成为一个Angular网页开发大师
- en: By the way, Angular, of course, also has its own official documentation, but
    there's so much to it that it can be intimidating to even get started. In my experience,
    a far more interesting way to learn a new technology is by following a tutorial—and
    that is exactly what this book is—a comprehensive tutorial for building an application,
    with the added explanations and some bonus material sprinkled in throughout the
    chapters in the appropriate sections. If I did my job well, you should be able
    to build almost any application you are likely to need (or want) to build with
    Angular. That's the goal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，Angular当然也有自己的官方文档，但其中包含的内容太多，甚至开始都可能让人望而却步。根据我的经验，学习新技术的更有趣的方法是通过教程，而这本书正是这样一本全面的教程，通过构建一个应用程序来学习，每章节中都有额外的解释和一些额外的材料。如果我做得好的话，您应该能够使用Angular构建几乎任何您可能需要（或想要）构建的应用程序。这就是目标。
- en: Let's now take a look at Listing Carousel, which is the example application
    we'll be building together.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看“列表轮播”，这是我们将一起构建的示例应用。
- en: Our example application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的示例应用
- en: Listing Carousel, our example application for this book, is a real-life online
    application that provides realtors (that is, professional real-estate salespeople)
    with an opportunity to share their listings to their contacts on social media
    in an engaging and informative way. One of my companies owns and operates it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “列表轮播”是我们这本书的示例应用，它是一个真实的在线应用，为房地产经纪人（即专业的房地产销售人员）提供了一个机会，以引人入胜和信息丰富的方式与他们在社交媒体上的联系人分享他们的房源。我的一家公司拥有并运营它。
- en: The reason I chose this application is not so you can steal my code and try
    to compete with me (which would be totally uncool and not recommended), but rather
    because with some tweaks here and there, you can turn the application into your
    very own online service if you wanted to. For example, you can easily turn this
    application into a classified application (such as Craigslist, or Kijiji) by just
    adding search capability, or even into a dating/matchmaking site by adding search,
    and just a bit more code. Or, if you love food, how about turning it into a restaurant
    site? Sign up restaurants to list their menus in the carousel—one meal or appetizer
    per slide—and then the restaurant owners can share their menus with their social
    media circles. Or, if you like having new ways to share photo albums, you can
    turn the application into something like that. One idea I had a while ago was
    to create a site where people can showcase their portfolios (such as for artists,
    architects, and photographers)—feel free to build something like that and run
    with it. The options are truly endless. The point is, I wanted to come up with
    a fun application for the book—one that would give you some motivation to work
    through the entire book. Why? Simple—because I know that this book would not be
    as valuable as it can be to you if all you were to do is to read it. So, commit
    to dive into the code with me and build something that you would enjoy. Who knows,
    maybe you will come up with a great idea for a profitable online business! My
    goal is to make the time you invest in working through this book as time well
    spent and, if I succeed, you can then give this book a five-star review (wink). Does
    this sound good?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这个应用的原因并不是让你偷我的代码，然后试图和我竞争（这样做完全不酷，也不推荐），而是因为通过一些调整，你可以把这个应用变成你自己的在线服务。例如，你可以很容易地把这个应用变成一个分类广告应用（比如Craigslist或Kijiji），只需添加搜索功能，或者通过添加搜索功能，甚至可以变成一个约会/婚介网站，再加一点代码。或者，如果你喜欢美食，可以把它变成一个餐厅网站。让餐厅注册并在轮播中列出他们的菜单——每张幻灯片上放一道菜或开胃菜，然后餐厅老板可以与他们的社交媒体圈分享他们的菜单。或者，如果你喜欢有新的方式分享相册，你可以把这个应用变成类似的东西。我以前想过一个主意，就是创建一个人们可以展示他们的作品集的网站（比如艺术家、建筑师和摄影师）——随意去建立类似的东西并且发挥它。选择真的是无限的。重点是，我想为这本书想出一个有趣的应用——一个能给你一些动力来完成整本书的应用。为什么？很简单——因为我知道如果你只是读它，这本书对你来说就不会像它本来可以给你的那样有价值。所以，承诺和我一起深入代码并构建一些你会喜欢的东西。谁知道，也许你会想出一个有利可图的在线业务的好主意！我的目标是让你在阅读这本书的时间投资变得有意义，如果我成功了，你就可以给这本书一个五星好评（眨眼）。这听起来不错吗？
- en: Game plan
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏计划
- en: There's a step-by-step game plan for using Listing Carousel as our focal point
    for our discussions as we cover the material in this book together. Though this
    book was not explicitly broken up into parts (that is, groupings of chapters),
    we can loosely group them now by partitioning the work we need to do for building
    our application into three main stages. Follow along with me, and this will all
    make sense—giving us a way to marry the material (that is, the book's chapters)
    to the application we'll be building together, as well as to give ourselves a
    target for what we're shooting for.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个逐步的游戏计划，以Listing Carousel作为我们一起讨论这本书材料的焦点。虽然这本书并没有明确地分成部分（也就是说，章节的分组），但我们现在可以通过将我们需要为构建应用程序做的工作分成三个主要阶段来松散地将它们分组。跟着我一起做，这一切都会有意义——给我们一个将材料（也就是书的章节）与我们将一起构建的应用程序相结合的方法，同时给我们一个我们的目标。
- en: 'It''s nice to know where you''re going before you start driving and to be able
    to recognize where you are at all times. Having a roadmap/game plan like that
    makes the entire process more enjoyable, thereby maximizing the chances that you''ll
    work through the book instead of just using it to look things up here and there.
    This book wasn''t designed to be like a cookbook. Instead, it was designed to
    teach you how to cook. You will learn to cook by fire (pun intended), by preparing
    a meal of the right complexity—which demands a certain level of knowledge and
    skill to cook it properly. There are four main benefits of this book:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始驾驶之前知道你要去哪里，随时能够认清自己的位置是很好的。像这样拥有一份路线图/游戏计划会让整个过程更加愉快，从而最大程度地增加你会完整地阅读这本书的机会，而不仅仅是偶尔查找一些内容。这本书的设计并不像一本食谱书，而是旨在教你如何烹饪。你将通过实践学会烹饪（这是一种双关语），通过准备一道适当复杂的菜肴来要求一定水平的知识和技能来正确烹饪。这本书有四个主要的好处：
- en: It gives you all the ingredients and even substitutes ingredients (that is,
    choices) that you need to prepare the meal.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为你提供了所有的食材，甚至是你准备这道菜所需的替代食材（也就是选择）。
- en: It gives you the knowledge and teaches you the process and skills required of
    the chef in order to cook the meal.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为你提供了厨师所需的知识、教授了烹饪餐点所需的过程和技能。
- en: It does these things in a methodological way so you learn it effectively and
    as efficiently as possible.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以一种系统的方式做这些事情，让你尽可能有效和高效地学习。
- en: The meal selection is a dish representative of the complexity of the majority
    of dishes you're likely to need to cook up. In other words, if you learn how to
    cook this meal (that is, our example application), you should be confident in
    being able to prepare any meal that you will be asked to prepare.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐点的选择是代表你可能需要烹饪的大多数菜肴复杂性的一道菜。换句话说，如果你学会了如何烹饪这道菜（也就是我们的示例应用程序），你应该有信心能够准备任何你被要求准备的菜肴。
- en: Cooking analogies aside, this book's promise is to teach you how to build a
    practical application using Angular through a methodological process. After all,
    if you think about it, that's why you bought this book—isn't it? Otherwise, you
    could have just tried to Google things here and there, hoping to be able to eventually
    piece everything together. That's not fun, nor is it an intelligent way to go
    about learning Angular. When you want to learn something new, or take rudimentary
    skills to the next level—in anything, not just Angular—you need to have a target
    in mind, and a roadmap/game plan to get there. Well, we know our target, which
    is to build Listing Carousel, learning Angular, and a bunch of other goodies,
    along the way. So let's now take a look at our game plan.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 撇开烹饪类比不谈，这本书的承诺是教会你如何通过一种方法论的过程来使用Angular构建一个实际的应用程序。毕竟，如果你想一想，这就是你买这本书的原因，不是吗？否则，你可以试图在这里那里搜索，希望最终能把一切拼凑在一起。那既不有趣，也不是学习Angular的聪明方式。当你想学习新东西，或者把基本技能提升到更高水平——无论是什么，不仅仅是Angular——你都需要有一个明确的目标，并制定一个到达目标的路线图/计划。好吧，我们知道我们的目标，那就是构建列表轮播、学习Angular，以及一大堆其他好东西。所以现在让我们来看看我们的计划。
- en: In phase 1 of building our application, we need to decide what to build, what
    features it will have, and what it will look like. Once we have that all scoped
    out and wireframed, the next step is to build out the skeleton for our application.
    By the end of this stage, our application is likely to just be hardcoded—being
    nothing more than some HTML and CSS. Our only components will be the ones we select
    to use from Bootstrap's library of components. You can think of this as our application
    having skin and bones, but not yet having guts or a beating heart.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序的第一阶段，我们需要决定要构建什么，它将具有什么功能，以及它将是什么样子。一旦我们确定了所有范围和线框图，下一步就是为我们的应用程序建立骨架。到这个阶段结束时，我们的应用程序很可能只是硬编码的——只是一些HTML和CSS。我们唯一的组件将是我们从Bootstrap组件库中选择使用的组件。你可以把这看作是我们的应用程序有了皮肤和骨骼，但还没有内在或跳动的心脏。
- en: In phase 2 of building our application, well, you guessed it, we're going to
    start giving our skin and bones application some guts! Specifically, it will be
    Angular guts! Remember, in the first phase, we're not even using Angular at all—not
    a single ounce of it—which is intentional. Though our application will surely
    be more lively by the end of this second phase than what it will be in its first
    phase, it'll behave more like a robot—very mechanical. If you remember the movie, *The
    Wizard of Oz*, it will be like the Tin Man–very much alive, but with no heart.
    This second phase (that is, giving our application some guts) will be comprised
    of [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml), *Routing, *[Chapter
    7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives, and Pipes*,
    and [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular
    Components*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序的第二阶段，嗯，你猜对了，我们将开始给我们的皮肤和骨骼应用程序添加一些内在！具体来说，它将是Angular的内在！请记住，在第一阶段，我们根本没有使用Angular——一点也没有——这是有意的。虽然我们的应用程序在第二阶段结束时肯定会比第一阶段更有活力，但它的行为会更像一个机器人——非常机械化。如果你记得电影《绿野仙踪》，它会像铁皮人一样——非常活跃，但没有心脏。这个第二阶段（也就是给我们的应用程序一些内在）将包括[第4章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)，“路由”，[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)，“模板，指令和管道”，以及[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)，“构建Angular组件”。
- en: Last, but not least, in phase 3 of building our application, we'll finally be
    giving our Tin Man a heart! Yeah! OK—what gives our application a heart? The answer
    is data and APIs! The data is like blood for our application, and the APIs are
    like the heart—taking data in and pushing data back out. I bet you never thought
    of web applications in this way, and, from now on, you won't be able to think
    of them in any other way (smiling). This third phase will comprise [Chapter 10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml),
    *Working with Forms,* [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*, [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml),
    *Dependency Injection and Services, *and [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml),
    *Advanced Angular Topics*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在构建应用的第3阶段，我们将最终给我们的铁皮人一个心脏！是的！好了，是什么让我们的应用有了心脏？答案是数据和API！数据就像是我们应用的血液，而API就像是心脏——接收数据并推送数据。我打赌你从来没有以这种方式思考过Web应用，从现在开始，你将无法以其他方式思考它们（微笑）。这第三阶段将包括[第10章](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml)，*使用表单*，[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)，*集成后端数据服务*，[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)，*依赖注入和服务*，以及[第14章](485921eb-86e2-4068-b314-5c62a1545c22.xhtml)，*高级Angular主题*。
- en: '[Chapter 13](0e54e15a-bc1a-402b-adaa-28f877c68323.xhtml), *Unit Testing*, and
    [Chapter 15](f81ae891-b2dc-4620-bb4a-ad099c96e8a0.xhtml), *Deploying Angular Applications*,
    are not really parts of any of the phases *per se,* but they play a very important
    supporting role. In these two chapters, we will learn how to test the code we
    write for our application, and how to deploy it in a couple of different ways.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[第13章](0e54e15a-bc1a-402b-adaa-28f877c68323.xhtml)，*单元测试*，和[第15章](f81ae891-b2dc-4620-bb4a-ad099c96e8a0.xhtml)，*部署Angular应用程序*，实际上并不是任何阶段的一部分，但它们发挥着非常重要的支持作用。在这两章中，我们将学习如何测试我们为应用程序编写的代码，以及如何以几种不同的方式部署它。'
- en: That's our big picture look at our game plan. Let's zoom in a little, and take
    a look at our five-step game plan for our first phase of building our application,
    and we'll then be on our way to our first technology topic, SASS.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对我们的整体规划的大致了解。让我们再仔细看一下我们构建应用程序第一阶段的五步游戏计划，然后我们将进入我们的第一个技术主题，SASS。
- en: '**Step 1**: In this chapter, we''re going to look at Bootstrap''s responsive
    grid, as well as several of Bootstrap''s components:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤1**：在本章中，我们将研究Bootstrap的响应式网格，以及几个Bootstrap的组件：'
- en: I'll be explaining how Bootstrap's grid works and can help us lay out our web
    pages.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将解释Bootstrap的网格如何工作，并如何帮助我们布置网页。
- en: I'll cover the Bootstrap components that we'll be using on our pages as we build
    out the pages—and we'll be using our wireframes to guide us, in conjunction with
    Bootstrap's grid.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建页面时，我将介绍我们将在页面上使用的Bootstrap组件，并且我们将使用我们的线框图来指导我们，结合Bootstrap的网格。
- en: '**Step 2**: In [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-Layout
    – Angular''s Powerful Responsive Layout Engine,* we''re going to replace Bootstrap''s
    grid system with Flex-layout. We''ll only be doing this with a couple of web pages,
    leaving all the others with the Bootstrap grid. There are two reasons why we''ll
    be doing this:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤2**：在[第5章](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml)中，*Flex-Layout –
    Angular''s Powerful Responsive Layout Engine*，我们将用Flex-layout替换Bootstrap的网格系统。我们只会在一些网页上这样做，其他网页仍然会使用Bootstrap的网格。我们这样做有两个原因：'
- en: To show you that there are always alternate options available—and you can often
    mix and match these alternatives.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您展示总是有备选方案可用，并且您通常可以混合和匹配这些备选方案。
- en: Being able to mix and match provides us with a path to replace one technology
    with another without the need to do it all in one shot. We don't want to keep
    rebuilding things in their entirety—we just want to redo enough of a couple of
    pieces of what we built originally in order to learn how to apply that specific
    alternate technology.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够混合和匹配为我们提供了一条路径，可以在不需要一次完成所有工作的情况下用另一种技术替换另一种技术。我们不想完全重建所有东西，我们只想重新做一些最初构建的东西的一部分，以学习如何应用特定的替代技术。
- en: '**Step 3**: In [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components,* we''ll be looking at how we can build our own components
    for use in our web pages. Since we are in control of the HTML and CSS when creating
    our components, we can leverage Bootstrap''s components for the look and feel
    when creating our own Angular components. Note: [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml),
    *Templates, Directives, and Pipes*, is a part of this as well, since these two
    chapters go together.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤3**：在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)中，*构建Angular组件*，我们将看看如何构建自己的组件以在网页中使用。由于在创建我们自己的组件时，我们控制HTML和CSS，我们可以利用Bootstrap的组件来创建我们自己的Angular组件的外观和感觉。注意：[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)，*模板、指令和管道*，也是其中的一部分，因为这两章是相关的。'
- en: '**Step 4**: In [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working
    with NG Bootstrap,* we will discover that there are ready-made *Angular-ready* Bootstrap
    components. Just as we will replace Bootstrap''s grid with Flex-layout for a couple
    of our pages, we will do the same thing with components—that is, to replace a
    couple of Bootstrap components with components from the NG Bootstrap project.
    Our motivation for doing this is to realize that there are many different third-party
    components that we can readily use for our Angular applications—including ones
    that are based on Bootstrap''s components.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤4**：在[第8章](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml)中，*使用NG Bootstrap*，我们将发现有现成的*Angular-ready*
    Bootstrap组件。就像我们将为我们的一些页面用Flex-layout替换Bootstrap的网格一样，我们也将用NG Bootstrap项目的组件做同样的事情——即用NG
    Bootstrap项目的组件替换一些Bootstrap组件。我们这样做的动机是意识到有许多不同的第三方组件可以方便地用于我们的Angular应用程序，包括基于Bootstrap组件的组件。'
- en: '**Step 5**: In [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working
    with Angular Material,* we will once again replace a couple of our Bootstrap components,
    but this time, they will not have any relation to Bootstrap components. The Angular
    Material project has beautifully designed components that are tailor-made for
    use in Angular applications and we''ll learn how to incorporate a couple of those
    into our application.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤5**：在[第9章](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml)中，*使用Angular Material*，我们将再次替换一些Bootstrap组件，但这一次，它们与Bootstrap组件没有任何关系。Angular
    Material项目有精美设计的组件，专门为在Angular应用程序中使用而设计，我们将学习如何将其中一些组件整合到我们的应用程序中。'
- en: Again, the important thing to note here is that we have choices in terms of
    technologies for both laying out our web pages, and as to which components we
    use—including creating our own custom components—when building our Angular applications.
    Furthermore, as you'll see in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*, you have virtually unlimited choices as to server-side
    and database technology stacks. And, in [Chapter 14](485921eb-86e2-4068-b314-5c62a1545c22.xhtml), *Advanced
    Angular Topics*, we will explore a couple of third-party authentication APIs we
    may want to leverage for our application instead of writing our own from scratch.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里需要注意的重要事情是，我们在布置网页和选择使用的组件方面有技术选择，包括创建我们自己的自定义组件，当构建我们的Angular应用程序时。此外，正如你将在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中看到的，*集成后端数据服务*，你在服务器端和数据库技术栈方面几乎有无限选择。而且，在[第14章](485921eb-86e2-4068-b314-5c62a1545c22.xhtml)中，*高级Angular主题*，我们将探索一些第三方身份验证API，我们可能希望利用它们来代替从头开始编写我们自己的应用程序。
- en: Yup! We have a ton of interesting stuff to cover in this book together. That
    said, let's focus on first things first, and get started with the goodies this
    chapter has to offer: Sass, Bootstrap, the typical evolution of software projects
    (that is, inception to realization), and building out our pages for Listing Carousel
    using Bootstrap (that is, Phase 1 of building our application). I'll provide a
    similar game plan for phase 2 of building our application at the start of [Chapter
    7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml), *Templates, Directives, and Pipes*,
    and one final game plan for phase 3 of building our application at the start of
    [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend
    Data Services*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们有很多有趣的东西要一起在这本书中讨论。也就是说，让我们先专注于首要的事情，开始利用本章提供的好东西：Sass，Bootstrap，软件项目的典型演变（即，从构思到实现），并使用Bootstrap构建我们的列表轮播页面（即，构建应用程序的第一阶段）。我将在[第7章](cd8509d5-4bce-4056-8156-557186df18cd.xhtml)的开头为构建应用程序的第二阶段提供类似的计划，*模板，指令和管道*，并在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)的开头为构建应用程序的第三阶段提供最终计划，*集成后端数据服务*。
- en: I know that was a lot of ground to cover, but reviewing our game plan was an
    important thing for us to do—it's always helpful to know where we are and where
    we're going. Now, let's pick up the pace and rip through the Sass crash course
    before our coverage of Bootstrap.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道要涵盖的内容很多，但回顾我们的计划是我们要做的重要事情——知道我们在哪里，我们要去哪里总是有帮助的。现在，让我们加快速度，在我们讨论Bootstrap之前迅速过一遍Sass速成课程。
- en: Sass crash course
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sass速成课程
- en: As is the case for most technologies, including all the ones mentioned in this
    book, such as ES6, Bootstrap, Node, and MongoDB, entire books can be written about
    them. Sass is no different. The goal of this crash course is not to turn you into
    a Sass expert, nor is it to regurgitate Sass's official documentation. Due to
    space constraints, the goal of the crash course is to merely introduce Sass to
    you, and to motivate you to explore it further on your own, either after you complete
    this book, or in parallel with it, because Sass is a really cool technology.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数技术来说，包括本书中提到的所有技术，如ES6，Bootstrap，Node和MongoDB，都可以写成整本书。Sass也不例外。这个速成课程的目标不是让你成为Sass专家，也不是为了重复Sass的官方文档。由于空间限制，速成课程的目标只是向你介绍Sass，并激励你自己进一步探索它，无论是在你完成这本书之后，还是与之并行进行，因为Sass是一个非常酷的技术。
- en: The Bootstrap team has adopted Sass for the Bootstrap project, and other technologies
    (such as Compass) are built on top of it. Strictly speaking, you don't have to
    know how to use Sass in order to write Angular applications—or even to work through
    this book—but it's a worthwhile technology to learn, and so I encourage you to
    take a closer look on your own. Let's cover some Sass basics together now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap团队已经采用了Sass来进行Bootstrap项目的开发，而其他技术（比如Compass）也是基于Sass构建的。严格来说，你不必知道如何使用Sass来编写Angular应用程序，甚至不需要通过本书来学习，但这是一项值得学习的技术，所以我鼓励你自己更仔细地了解一下。现在让我们一起来学习一些Sass的基础知识。
- en: What is Sass?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Sass？
- en: Sass is an acronym for Syntactically Awesome StyleSheets—but, of course, there's
    more sassiness to Sass than the acronym! Sass is an extension to CSS, which gives
    us additional power and flexibility when writing our CSS for our web applications. Sass,
    when compiled, generates well-formatted CSS for us. Specifically, the additions
    to CSS that Sass brings to the table include things such as nested rules, variables,
    conditional logic, mathematics, mixins, and more. Additionally, Sass makes it
    easier to maintain and organize the style sheets in our web projects. We'll be
    taking a look at many of these things in this crash course.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass是Syntactically Awesome StyleSheets的缩写，但当然，Sass比缩写更有趣味！Sass是CSS的扩展，为我们编写Web应用程序的CSS提供了额外的功能和灵活性。编译后，Sass会为我们生成格式良好的CSS。具体来说，Sass为CSS带来的附加功能包括嵌套规则、变量、条件逻辑、数学运算、混合等。此外，Sass还使得在Web项目中更容易维护和组织样式表。在这个速成课程中，我们将学习这些内容。
- en: Sass is compatible with all versions of CSS, not just CSS3 and CSS4.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass与所有版本的CSS兼容，不仅仅是CSS3和CSS4。
- en: Thanks to the Angular CLI, Sass fits nicely into our Angular applications because
    the CLI compiles the SASS in our components for us by default.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Angular CLI的存在，Sass可以很好地融入我们的Angular应用程序中，因为CLI默认为我们编译组件中的Sass。
- en: Sass's official website can be found here: [https://sass-lang.com/](https://sass-lang.com/).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sass的官方网站可以在这里找到：[https://sass-lang.com/](https://sass-lang.com/)。
- en: Compass framework
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Compass框架
- en: Compass is a CSS authoring framework that is built on top of Sass, providing
    some neat additions, and will also compile your Sass to CSS. A compass is an option
    for you if you're working on non-Angular projects (remember, the Angular CLI takes
    care of compiling Sass to CSS for us for our Angular projects). We won't be covering
    Compass in this book, but I wanted to at least bring the technology to your attention
    because I know that Angular is not the only technology you'll be using as a web
    developer—however, as web developers, we can't avoid using CSS!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Compass是一个构建在Sass之上的CSS编写框架，提供了一些不错的附加功能，并且还会将你的Sass编译成CSS。如果你在非Angular项目上工作，Compass是一个选择（记住，Angular
    CLI会为我们的Angular项目编译Sass为CSS）。我们不会在本书中涵盖Compass，但我至少想让你注意到这项技术，因为我知道作为Web开发人员，你不仅会使用Angular这项技术。然而，作为Web开发人员，我们无法避免使用CSS！
- en: The takeaway point here is that you can simply use the Angular CLI for Sass
    for Angular projects, but do take a look at leveraging Compass for your non-Angular
    projects, especially if your project tends to be CSS heavy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，你可以简单地在Angular项目中使用Angular CLI来使用Sass，但是对于非Angular项目，尤其是如果你的项目倾向于使用大量CSS，可以考虑使用Compass。
- en: Large companies use Compass. Two of them that I know of, and whose online services
    I utilize on a daily bases, are LinkedIn ( [https://www.linkedin.com/](https://www.linkedin.com/)),
    the world's largest employment-oriented social networking service, and Heroku
    ([https://www.heroku.com](https://www.heroku.com/)), a super popular cloud application
    platform.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大公司使用Compass。我知道其中两家，并且我每天都在使用它们的在线服务，它们分别是LinkedIn（[https://www.linkedin.com/](https://www.linkedin.com/)），这是世界上最大的面向就业的社交网络服务，以及Heroku（[https://www.heroku.com](https://www.heroku.com/)），这是一个非常受欢迎的云应用平台。
- en: You can learn all you want to about Compass at their official website, which
    can be found here: [http://compass-style.org/](http://compass-style.org/). Another
    nice online reference that provides tutorials on Sass and Compass is named *The
    Sass Way*, and can be found here: [http://www.thesassway.com/](http://www.thesassway.com/).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方网站[http://compass-style.org/](http://compass-style.org/)上了解有关Compass的所有信息。另一个提供有关Sass和Compass教程的不错的在线参考资料名为*The
    Sass Way*，网址为[http://www.thesassway.com/](http://www.thesassway.com/)。
- en: Two SASS styles
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两种SASS样式
- en: 'Sass has two flavors of syntax: the older syntax that relies on indentation,
    and the newer syntax that uses curly braces as opposed to indentation. Another
    difference between the two syntactical styles is that the old-style does not require
    semicolons at the end of the lines, where as the new style does require them.
    The file extensions between these two styles also differ—the older style''s file
    extension is `.sass`, and the current style''s file extension is `.scss`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Sass有两种语法风格：旧语法依赖缩进，而新语法使用大括号而不是缩进。两种语法风格之间的另一个区别是，旧风格不需要在行末加上分号，而新风格需要。这两种风格的文件扩展名也不同——旧风格的文件扩展名是`.sass`，而当前风格的文件扩展名是`.scss`。
- en: Let's now look at a quick example of each one's CSS syntax. The first code block
    is the older style (`.sass`), and the second code block produces the same effect
    in the newer syntactical style (`.scss`). We'll be using the new style throughout
    the book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们快速看一下每种CSS语法的一个示例。第一个代码块是旧风格（`.sass`），第二个代码块以新的语法风格（`.scss`）产生相同的效果。我们将在整本书中都使用新风格。
- en: 'The sample code given here is for writing `.sass` syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的示例代码是用于编写`.sass`语法的：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The sample code given here is for writing `.scss` syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出的示例代码是用于编写`.scss`语法的：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main difference between the two syntactical styles is that the older style
    aims to be terse, while the newer style aims to be more familiar to developers
    used to traditional CSS syntax.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语法风格之间的主要区别在于，旧风格旨在简洁，而新风格旨在更符合传统CSS语法的开发人员的习惯。
- en: In the preceding code blocks, you may have noticed `$blue` and `$margin`. These
    are not CSS items, but rather they are examples of variables. You've probably
    also noticed division operators. Variables and mathematical evaluation are just
    a couple of things that can be in your Sass code. We'll see these and more Sass
    features a bit later in the sections that follow.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，您可能已经注意到了`$blue`和`$margin`。这些不是CSS项目，而是变量的示例。您可能还注意到了除法运算符。变量和数学计算只是您的Sass代码中可能包含的一些内容。我们将在接下来的部分中看到这些以及更多Sass功能。
- en: 'Regardless of which syntax you use—old or new—the compiled result is the same.
    If you were to take either of the preceding code blocks and run them through an
    online compiler, such as Sass* Meister* (I''ll mention this tool shortly as well),
    the resultant CSS will be the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种语法——旧的还是新的——编译结果都是相同的。如果您将前面的任何一个代码块运行到在线编译器，比如*Sass* Meister*（我马上也会提到这个工具），生成的CSS将是以下内容：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing Ruby
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ruby
- en: Sass is written in Ruby, and so we need Ruby installed on our computers. To
    download and install the latest version navigate to Ruby's official site: [https://www.ruby-lang.org/en/downloads/](https://www.ruby-lang.org/en/downloads/).
    To find out if you already have Ruby installed on your machine, run this command
    on your command line or Terminal: `$ ruby -v`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Sass是用Ruby编写的，因此我们需要在计算机上安装Ruby。要下载并安装最新版本，请转到Ruby的官方网站：[https://www.ruby-lang.org/en/downloads/](https://www.ruby-lang.org/en/downloads/)。要查看您的计算机上是否已安装Ruby，请在命令行或终端上运行此命令：`$
    ruby -v`。
- en: If Ruby is installed, the output will display the version number. For example,
    the output in my Terminal when I execute `$ ruby -v` is `ruby 2.4.1p111 (2017-03-22
    revision 58053) [x86_64-darwin16]`. Any version from 2.3 onward is more than good
    enough for our purposes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Ruby已安装，输出将显示版本号。例如，当我执行`$ ruby -v`时，我的终端输出是`ruby 2.4.1p111 (2017-03-22 revision
    58053) [x86_64-darwin16]`。从2.3版本开始的任何版本都足够满足我们的需求。
- en: Installing Sass
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Sass
- en: Once you have Ruby installed, installing Sass is a breeze. Head on over to [https://sass-lang.com/install](https://sass-lang.com/install)
    and follow the directions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Ruby后，安装Sass就非常简单。请前往[https://sass-lang.com/install](https://sass-lang.com/install)并按照说明操作。
- en: 'Just like you can get the version of Ruby by running `$ ruby -v` at your Terminal
    or command line, you can do the same thing with Sass. Execute this following command, `$
    sass -v`, to see what version of Sass you have on your system at your Terminal
    or command line. The output on my system shows the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以通过在终端或命令行中运行`$ ruby -v`来获取Ruby的版本一样，您也可以使用Sass执行相同的操作。在终端或命令行中执行以下命令`$
    sass -v`，以查看您系统上的Sass版本。我的系统输出如下：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Online tools for Sass
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sass的在线工具
- en: There are several online tools that we can use to compile our Sass files down
    to CSS files. One of the ones I like is named *Sass Meister*, and you can access
    it here: [http://www.sassmeister.com](https://www.sassmeister.com/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个在线工具可以用来将Sass文件编译成CSS文件。我喜欢的一个工具叫做*Sass Meister*，您可以在这里访问：[http://www.sassmeister.com](https://www.sassmeister.com/)。
- en: I like it because it is super easy to use and provides decent help when there
    is a problem with your Sass syntax. It also supports both Sass syntaxes, the older
    style, and the newer style, and it also allows you to choose from a few different
    Sass compilers. You can find these settings under the Options menu option at the
    top of the window panes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢它，因为它非常易于使用，并且在Sass语法出现问题时提供了不错的帮助。它还支持旧样式和新样式的Sass语法，并允许您从几种不同的Sass编译器中进行选择。您可以在窗格顶部的Options菜单选项下找到这些设置。
- en: To use the tool, simply write your Sass code in the left pane, and the compiled
    CSS will appear in the right pane. Pay attention to the selected options so that
    the ones that are activated are the ones you want.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该工具，只需在左窗格中编写您的Sass代码，编译后的CSS将显示在右窗格中。注意所选的选项，确保激活的选项是您想要的。
- en: Offline tools for Sass
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sass的离线工具
- en: Just as with online tools, we have several options that we can choose from to
    compile our Sass files down to CSS files using offline tools. I've used Koala
    because it's easy to use, is cross-platform, and is free. You can download Koala
    for free from the project's website: [http://koala-app.com/](http://koala-app.com/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在线工具一样，我们有几个选项可以选择使用离线工具将Sass文件编译成CSS文件。我使用Koala，因为它易于使用，跨平台，并且免费。您可以从项目网站免费下载Koala：[http://koala-app.com/](http://koala-app.com/)。
- en: Koala gives you the ability to work with more than just Sass. You can also use
    Koala to compile and/or compress Less, JavaScript, CoffeeScript, and you can even
    use the Compass framework with it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Koala让您不仅可以处理Sass，还可以用它来编译和/或压缩Less、JavaScript、CoffeeScript，甚至可以与Compass框架一起使用。
- en: The best way to learn how to use Koala is to read the official documentation,
    which can be found at [https://github.com/oklai/koala/wiki#docs](https://github.com/oklai/koala/wiki#docs).
    But if you'll just be using Koala to compile your Sass files (at least for now),
    let me quickly outline the steps for you here to save you from needing to jump
    back and forth between the book and the online docs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用Koala的最佳方法是阅读官方文档，可以在[https://github.com/oklai/koala/wiki#docs](https://github.com/oklai/koala/wiki#docs)找到。但是，如果您只是暂时使用Koala来编译您的Sass文件，让我在这里快速概述一下步骤，以免您需要在书本和在线文档之间来回跳转。
- en: 'All you need to do is to create a web project using any text editor of your
    choice—such as Sublime Text or Visual Studio Code—and create a CSS folder as well
    as a Sass folder in your project''s root folder. You don''t need a completed project,
    of course—all you need is the very basic folder structure. Once the project structure
    is created, you can open Koala to get started, using it to compile your Sass files
    for you. Here are the basic steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的就是使用您选择的任何文本编辑器（如Sublime Text或Visual Studio Code）创建一个Web项目，并在项目的根文件夹中创建一个CSS文件夹和一个Sass文件夹。当然，您不需要一个完成的项目，您只需要非常基本的文件夹结构。创建项目结构后，您可以打开Koala开始使用它为您编译Sass文件。以下是基本步骤：
- en: 'Create an empty project structure, which, as a minimum, has the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的项目结构，至少包括以下内容：
- en: A root folder with an empty `index.html` page in it
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件夹中有一个空的`index.html`页面
- en: A CSS folder in the root folder with an empty `styles.css` file in it
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根文件夹中有一个CSS文件夹，其中有一个空的`styles.css`文件
- en: A Sass folder in the root folder with an empty style `.scss` file in it
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根文件夹中有一个Sass文件夹，其中有一个空的style `.scss`文件
- en: Open the Koala application.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Koala应用程序。
- en: Click the large plus sign (+) in the top-left corner, navigate to your project's
    root folder, and select it. At this point, Koala will find your `styles.scss`
    and `styles.css` files.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击左上角的大加号（+），导航到您项目的根文件夹，并选择它。此时，Koala将找到您的`styles.scss`和`styles.css`文件。
- en: Right-click on your `styles.scss` file in Koala's right-hand pane, select Set
    Output Path, and then navigate to, and select, your `styles.css` file in your
    file explorer
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Koala的右侧窗格中右键单击`styles.scss`文件，选择设置输出路径，然后在文件资源管理器中导航到并选择您的`styles.css`文件
- en: Observing the preceding steps is all you need to do to set Koala up to compile
    your Sass files for you. The output of the compilation will be inserted into your
    `styles.css` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循上述步骤就是您需要做的一切，以便设置Koala来为您编译Sass文件。编译的输出将被插入到您的`styles.css`文件中。
- en: Sass features and syntax
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sass功能和语法
- en: Let's now take a look at some of Sass's features that you are most likely to
    use in your applications. We won't be using all of these in our example application,
    but I wanted to show you some of the cool stuff that Sass has to offer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看一些Sass的功能，这些功能在您的应用程序中最有可能使用。我们不会在我们的示例应用程序中使用所有这些功能，但我想向您展示一些Sass提供的很酷的东西。
- en: Nesting
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套
- en: 'Using Sass, you can nest CSS rules within each other. Sass is not only easier
    to read, but it helps to avoid a lot of duplication of the CSS selectors. This
    is especially true for highly-nested CSS rules. Let''s look at a simple example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sass，您可以将CSS规则嵌套在彼此之内。Sass不仅更易于阅读，而且有助于避免大量重复的CSS选择器。这对于高度嵌套的CSS规则尤其有效。让我们看一个简单的例子：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding Sass code will be compiled and the equivalent CSS code will be
    generated:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Sass代码将被编译，生成相应的CSS代码：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Variables
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Sass variables are just like you would expect them to be: they store information
    that you''d like to reuse throughout your style sheet. This saves time and annoying
    errors. And just like global variables in other languages, you only need to define
    them in one place—so if they ever need to change, you just have to change the
    variable in one place, rather than change all of the occurrences in your CSS styles.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Sass变量就像你期望的那样：它们存储您想要在整个样式表中重用的信息。这样可以节省时间和烦人的错误。就像其他语言中的全局变量一样，您只需要在一个地方定义它们，所以如果它们需要更改，您只需要在一个地方更改变量，而不是更改CSS样式中的所有出现。
- en: 'You can store almost anything. Here is an example where we store the font information
    and a font color:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎可以存储任何东西。这是一个示例，我们在其中存储了字体信息和字体颜色：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding Sass code will be compiled and the equivalent CSS code will be
    generated:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Sass代码将被编译，生成相应的CSS代码：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Mathematical operations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算
- en: 'Since Sass compiles down to CSS, you can have it do mathematical calculations
    for you instead of doing them yourself. You can also have the math be run on variables,
    as opposed to hardcoded numbers as in the following example, which, of course,
    is super handy to be able to do:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sass编译为CSS，您可以让它为您执行数学计算，而不是自己执行。您还可以让数学运行在变量上，而不是像下面的例子中的硬编码数字一样。当然，这样做非常方便：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding Sass code will be compiled and the equivalent CSS code will be
    generated:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Sass代码将被编译，生成相应的CSS代码：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Imports
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入
- en: 'Sass enables you to import one style sheet into another one using the `@import` directive.
    This does as it sounds, and is very straightforward. Let''s look at an example.
    In the following three code listings, the first one is the base style (`base.scss`)
    sheet that is applied to the entire site, and the second is the style sheet that
    is used for the report pages (`reports.scss`). The third is the resultant CSS
    style sheet we would get when the reports style sheet imports the base style sheet
    during Sass compilation. Note that the file extension is not required when using
    the `@import` directive in Sass:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Sass使您能够使用`@import`指令将一个样式表导入到另一个样式表中。这就像它听起来的那样，非常简单。让我们来看一个例子。在以下三个代码列表中，第一个是基本样式（`base.scss`）表，适用于整个站点，第二个是用于报告页面（`reports.scss`）的样式表。第三个是在Sass编译期间报告样式表导入基本样式表时得到的结果CSS样式表。请注意，在Sass中使用`@import`指令时不需要文件扩展名：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding Sass code will be compiled and the equivalent CSS code will be
    generated:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Sass代码将被编译，生成相应的CSS代码：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Extend
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Using `@extend` lets you share a set of CSS properties from one selector to
    another. One selector can extend (that is, inherit) from another one using the
    `@extend` Sass directive. The following example shows a common set of style attributes
    for a set of three related styles—active, inactive, and terminated:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@extend`让您可以从一个选择器向另一个选择器共享一组CSS属性。一个选择器可以使用`@extend` Sass指令从另一个选择器继承。以下示例显示了一组三个相关样式（活动的，非活动的和终止的）的常见样式属性。
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the preceding Sass code gets compiled, it turns into the following CSS:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的Sass代码被编译时，它会变成以下CSS：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Mixins
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: Mixins are like named templates. They are Sass's way to allowing you of group
    CSS or Sass declarations (that is, CSS styles) together and give it a name. This
    way, you can include these declarations in other CSS classes as needed, without
    copying and pasting—which causes a bit of a mess should anything need to change
    later on. In a sense, they are also like variables because you only need to change
    something in one place (that is, in the mixin itself), but they are more powerful
    than variables, which is why I mentioned that they are like templates. In fact,
    mixins can even be parameterized using variables. Let's look at an example, and
    the preceding description should become clear as to what I mean when I say that
    mixins are like templates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 混合器就像命名模板。它们是Sass允许您将CSS或Sass声明（即CSS样式）分组并为其命名的方式。这样，您可以根据需要在其他CSS类中包含这些声明，而无需复制和粘贴-这样做会在以后需要更改时造成一些混乱。在某种意义上，它们也像变量，因为您只需要在一个地方更改某些内容（即在混合器本身），但它们比变量更强大，这就是为什么我提到它们像模板。实际上，混合器甚至可以使用变量进行参数化。让我们看一个例子，前面的描述应该清楚地说明了我所说的混合器就像模板的意思。
- en: 'Here is an example of styling a dropdown that I like to use in my websites.
    We''ll parameterize the width so that we can create different sizes of dropdowns.
    Note the use of the `@mixin` directive:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我喜欢在我的网站中使用的下拉菜单的样式示例。我们将参数化宽度，以便我们可以创建不同大小的下拉菜单。请注意使用`@mixin`指令：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And here is how we can use the mixin (note the use of the `@include` directive):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用混合器（请注意使用`@include`指令）：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will compile to the following CSS:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译为以下CSS：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By now, you can see how cool Sass is and how much time it can save you, as well
    as how you can use it to avoid code duplication and avoid making the silly cut
    and paste mistakes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以看到Sass有多酷，它可以为您节省多少时间，以及您如何使用它来避免代码重复和避免犯愚蠢的剪切和粘贴错误。
- en: And as if all this wasn't cool enough, Sass gives you a lot of power with its
    built-in functions. There are a ton of them, which is what gives Sass so much
    power and utility. You can take a look at them here: [http://sass-lang.com/documentation/Sass/Script/Functions.html](http://sass-lang.com/documentation/Sass/Script/Functions.html).
    We'll only be covering one, just to show you an example of how to use a function
    in the *Built-in Functions* section that follows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些还不够酷的话，Sass还通过其内置函数为您提供了很多强大的功能。有很多内置函数，这就是为什么Sass如此强大和实用。您可以在这里查看它们：[http://sass-lang.com/documentation/Sass/Script/Functions.html](http://sass-lang.com/documentation/Sass/Script/Functions.html)。我们只会涵盖一个，只是为了向您展示如何在接下来的*内置函数*部分中使用函数的示例。
- en: Placeholders
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 占位符
- en: Placeholders are intended to be used with the `@extend` directive. Rulesets
    that do make use of placeholders, but which do not use the `@extend` directive,
    will not get rendered to CSS. A valid use case of using placeholders is if you
    are writing a Sass library for code reuse. You can write a Sass file that has
    placeholders, and which is meant to be included in another Sass file that you
    or someone else writes. If a ruleset in the Sass file imports the other Sass file
    that acts as a library, and the ruleset extends the placeholder in your library,
    it will be rendered to the CSS file when the Sass files are compiled. And, if
    no rulesets extend the placeholder, the placeholder will not be rendered/printed
    to the CSS file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符旨在与`@extend`指令一起使用。使用占位符的规则集，但不使用`@extend`指令，将不会呈现为CSS。使用占位符的一个有效用例是，如果您正在编写一个用于代码重用的Sass库。您可以编写一个包含占位符的Sass文件，该文件旨在包含在您或其他人编写的另一个Sass文件中。如果Sass文件中的规则集导入了作为库的其他Sass文件，并且规则集扩展了您的库中的占位符，则在编译Sass文件时，它将呈现为CSS文件。如果没有规则集扩展占位符，则占位符将不会呈现/打印到CSS文件中。
- en: 'Let''s take a look at an example. Note that the placeholder is prefixed by
    a percent sign (`%`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。注意，占位符前缀为百分号（`%`）：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding Sass code compiles down to the following CSS:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Sass代码编译为以下CSS：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Built-in functions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: When we covered Sass's extend feature, the border colors for each class were
    20% darker than their corresponding background colors. In order to find a color
    that is 20% darker than another, you have to do some tedious math—and if you decide
    to later change that percentage, it'll require more tedious math. Fortunately,
    Sass has built-in functions for us to do all sorts of things, including darkening
    and lightening colors and a whole lot more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍Sass的扩展功能时，每个类的边框颜色比其对应的背景颜色暗20%。为了找到比另一个颜色暗20%的颜色，你需要进行一些繁琐的数学运算，如果以后决定更改百分比，就需要进行更多繁琐的数学运算。幸运的是，Sass为我们提供了内置函数，可以做各种事情，包括变暗和变亮颜色等等。
- en: 'Now, let''s revisit the Sass code we had seen in the previous *Extend* section,
    and this time write it more flexibly using variables and the built-in darken function
    in order to have Sass do the math for us. This way, it makes it easy to change
    the percentage later on if we choose to. The compiled output of the following
    Sass code would be the exact same as the compiled output in the previous *Extend*
    section, and so we won''t repeat that here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视之前在*扩展*部分看到的Sass代码，并且这次使用变量和内置的变暗函数来更灵活地编写它，以便让Sass为我们做数学运算。这样，如果以后选择更改百分比，就会变得很容易。以下Sass代码的编译输出将与之前*扩展*部分的编译输出完全相同，因此我们不会在这里重复。
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Custom functions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义函数
- en: Sass gives us a lot of power through using its ready-to-use, built-in functions,
    but sometimes, there's no substitute for custom functions—functions that do exactly
    what you want for the project at hand. The folks on the Sass team knew this and
    thus gave us a way to add custom functions to our Sass files.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Sass通过使用其现成的内置函数为我们提供了很大的能力，但有时，没有什么能替代自定义函数——为手头的项目做出你想要的功能。Sass团队的成员知道这一点，因此为我们提供了一种在Sass文件中添加自定义函数的方法。
- en: To wrap up this Sass crash course, let's take a quick look at how we can create
    a custom function. Our function will compute the width as a percentage given two
    parameters, the number of columns for the target width, and the total number of
    columns we have.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这个Sass速成课程，让我们快速看一下如何创建自定义函数。我们的函数将根据两个参数计算宽度百分比，目标宽度的列数和我们拥有的总列数。
- en: 'In this short example, you''ll notice that we do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的例子中，你会注意到我们做了以下几点：
- en: Make use of variables
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Perform some simple math
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行一些简单的数学运算
- en: Use a built-in Sass function (that is, percentage)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的Sass函数（即百分比）
- en: 'Introduce two new Sass commands: `@function`, and `@return:`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入两个新的Sass命令：`@function`和`@return:`
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This compiles to the following CSS:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译为以下CSS：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's my hope that you'll find a place in your web development for Sass. It may
    seem like it's all just overkill at the moment, but when you take some time to
    play with it, I'm confident that you'll discover clever ways to use Sass to help
    you better organize your CSS, and have it help trim the fat of code duplication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能在网页开发中找到Sass的用武之地。现在看起来可能有点多余，但当你花些时间去尝试时，我相信你会发现聪明的方法来利用Sass帮助你更好地组织你的CSS，并帮助减少代码重复的问题。
- en: Let's now shift gears and take a quick look at Bootstrap.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转变一下方向，快速看一下Bootstrap。
- en: Bootstrap crash course
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap速成课程
- en: In this section, we're going to take a look at Bootstrap, in particular, its
    responsive grid and its components. We're going to cover just enough of Bootstrap's
    grid to give you a solid start on how to use it. We're also going to cover just
    five of Bootstrap's components to get you started. Bootstrap has a lot more than
    five components, and there are many ways you can customize each one of them. However,
    this is a crash course on Bootstrap and not a comprehensive manual—which is what
    would be needed to even attempt to cover Bootstrap in any level of detail. Bootstrap
    is a vast library with tons of options for its use, and thus it is far more important
    to just show you the basics and to show you where to go for further information
    on Bootstrap than it is to attempt to cover it exhaustively. The good news is
    that this crash course on Bootstrap is the fastest way to get you up and running
    with it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍Bootstrap，特别是其响应式网格和组件。我们将只介绍足够多的Bootstrap网格，让您对如何使用它有一个坚实的开始。我们还将只介绍Bootstrap的五个组件，让您开始。Bootstrap拥有远远超过五个组件，而且您可以以许多方式自定义每一个组件。然而，这是Bootstrap的速成课程，而不是详尽的手册——要试图详尽地介绍Bootstrap，需要的是一本全面的手册。Bootstrap是一个庞大的库，有大量的选项供您使用，因此重要的是向您展示基础知识，并告诉您在哪里获取有关Bootstrap的更多信息，而不是试图详尽地介绍它。好消息是，这个Bootstrap的速成课程是让您快速上手的最快方法。
- en: 'The reasoning for taking this approach is the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 采取这种方法的原因如下：
- en: We won't be using all of the Bootstrap components for our example application
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会在示例应用程序中使用所有的Bootstrap组件
- en: 'Our example application will also be made from ng-bootstrap components, and
    Angular Material components (which we''ll be covering in later chapters anyway:
    [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml), *Working with NG Bootstrap*,
    and [Chapter 9](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml), *Working with Angular
    Material*)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的示例应用程序也将使用ng-bootstrap组件和Angular Material组件进行制作（我们将在后面的章节中介绍：[第8章](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml)，*使用NG
    Bootstrap*，和[第9章](1a222c0e-7130-4ac2-959d-ae9d6cc1ca7d.xhtml)，*使用Angular Material*）
- en: The most important part of Bootstrap for us will be Bootstrap's Grid—and we'll
    be covering the grid in more detail than the five components we'll be looking
    at
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们来说，Bootstrap最重要的部分将是Bootstrap的网格——我们将对网格进行比我们将要查看的五个组件更详细的介绍
- en: However, unlike the Sass crash course, we will see how to use Bootstrap in a
    practical way, since we'll be using it directly in our example application as
    we lay out the home page in this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与Sass速成课程不同，我们将看到如何实际使用Bootstrap，因为我们将直接在本章中的主页布局中使用它。
- en: What is Bootstrap?
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Bootstrap？
- en: 'Bootstrap is a CSS framework for building responsive websites, with an emphasis
    on being mobile-first. While there are other frontend presentation frameworks,
    Bootstrap is still the king of the hill in this arena—not only due to being the
    one with the most mind share, but it probably has the most *runtime*. What I mean
    by runtime is the number of times it''s been used in websites, and thus it has
    been put through its paces more than the other CSS frameworks. Bootstrap''s leading
    mind share (that is, popularity) is primarily due to three things:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是一个用于构建响应式网站的CSS框架，重点是移动优先。虽然还有其他前端呈现框架，但Bootstrap仍然是这个领域的霸主，不仅因为它拥有最多的关注度，而且它可能拥有最多的*运行次数*。我所说的运行次数是指它在网站中被使用的次数，因此它比其他CSS框架更加经受考验。Bootstrap的领先关注度（即流行程度）主要是由于以下三个原因：
- en: It was one of the very first frameworks of its kind (so the competition was
    virtually non-existent)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是其类别中最早的框架之一（因此竞争几乎不存在）
- en: It came with the backing of one of the top social websites in the world (that
    is, Twitter)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它得到了世界顶级社交网站（即Twitter）的支持
- en: It has been around since August 2011, and so is mature
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该项目自2011年8月开始存在，因此非常成熟。
- en: Additionally, as we'll see in [Chapter 8](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml),
    *Working with NG Bootstrap*, the ng-bootstrap project is all about creating Angular
    widgets using Bootstrap 4, which says a lot about what the Angular community thinks
    of Bootstrap.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如我们将在[第8章](784689d5-c12c-4a1d-b2a4-dfcdbe7e6d38.xhtml)中看到的，*使用NG Bootstrap*，ng-bootstrap项目的目标是使用Bootstrap
    4创建Angular小部件，这充分说明了Angular社区对Bootstrap的看法。
- en: There is a reason that this third edition remains true to the relationship between
    Angular and Bootstrap, and that is because they are each leaders in their respective
    niches, as well as being symbiotically compatible and complimentary. In fact,
    these two frameworks are all you need to build the frontend part of powerful web
    applications—choosing just about anything you like for building out the backend,
    since all backend frameworks these days can produce and consume JSON, including
    mainframes still running COBOL programs. This is because JSON has become the most
    popular way to integrate systems through messaging.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第三版保持了Angular和Bootstrap之间的关系之所以如此真实的原因是因为它们各自在各自的领域都是领导者，并且它们之间是共生兼容和互补的。事实上，这两个框架就足以构建强大的Web应用程序的前端部分——只需选择任何你喜欢的后端构建，因为如今所有的后端框架都可以生成和消费JSON，包括仍在运行COBOL程序的大型机。这是因为JSON已经成为通过消息集成系统的最流行方式。
- en: Motivation
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: If you've ever tried to build a website that works well on different viewport
    sizes (that is, form factors/screen sizes) without the use of a framework to help
    you along, the motivation for Bootstrap is pretty easy to see—building something
    like that from scratch is both tedious and difficult. Mobile computing really
    escalated the need for something like Bootstrap to come along, and it was inevitable
    that it would. While the same can be said for just about any framework, in that
    you probably shouldn't spend time reinventing the wheel unless you have an extremely
    good set of reasons for doing so, it can be argued that (for the vast majority
    of websites, and even web applications) the frontend has become more important
    than the backend. It's been a fact for the last several years that the client
    side is the new black. I'm not suggesting that the backend is not important—nothing
    could be further from the truth, and [i](9610f27b-03db-4258-8a68-24eb3901117b.xhtml),
    *Integrating Backend Data Services*, is completely devoted to building out the
    backend. However, I am suggesting that when mobile computing came to be, we already
    had more than enough backend technologies and scores of frameworks to choose from,
    but were lacking in frontend frameworks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经尝试过在不使用框架的情况下构建一个在不同视口大小（即，形态因素/屏幕大小）上运行良好的网站，那么你很容易就能理解使用Bootstrap的动机——从头开始构建这样的东西既乏味又困难。移动计算确实加剧了对类似Bootstrap的需求，而它的出现是不可避免的。虽然对于几乎任何框架都可以说同样的话，即你可能不应该花时间重新发明轮子，除非你有极好的理由这样做，但可以说（对于绝大多数网站，甚至Web应用程序）前端比后端更加重要。在过去几年里，客户端已经成为了新宠。我并不是在暗示后端不重要——事实恰恰相反，[i](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)，*集成后端数据服务*，完全致力于构建后端。然而，我建议的是，当移动计算出现时，我们已经有了足够多的后端技术和大量的框架可供选择，但缺乏前端框架。
- en: The final comment I will add to conclude this motivation section is that killing
    two birds with one stone in the business world can give companies a competitive
    advantage (that is, speed to market) and/or financial advantage (that is, cost
    savings)—and so it isn't any different with software development. If you can build
    something once, in this case, a series of web pages, and use the same client-side
    code for both mobile and desktop instead of building two sets of everything (or
    even three sets, considering tablets as well), you should realize savings of both
    time and money. That is the promise—unfortunately, it is not always fulfilled.
    However, getting some advantage in these areas is certainly better than getting
    none at all.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在结束这个动机部分时添加的最后一条评论是，在商业世界中一举两得可以为公司带来竞争优势（即，市场速度）和/或财务优势（即，成本节约）—因此在软件开发中也不例外。如果你可以构建一次东西，在这种情况下是一系列网页，并且在移动和桌面上使用相同的客户端代码，而不是构建两套一切（甚至考虑到平板电脑，甚至三套），你应该意识到节约了时间和金钱。这就是承诺—不幸的是，它并不总是兑现。然而，在这些领域获得一些优势肯定比没有获得任何优势要好。
- en: Bootstrap's role in our example application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap在我们示例应用程序中的作用
- en: 'For our example application, Bootstrap will be used for only two purposes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例应用程序，Bootstrap将仅用于两个目的：
- en: To lay out the web page using its responsive grid
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其响应式网格布局网页
- en: To leverage, some of it's read-to-use components for quickly building a nicely
    styled UI
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用一些现成的组件快速构建样式良好的UI
- en: Installing Bootstrap
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Bootstrap
- en: Installing Bootstrap, for the purposes of learning it, will be different from
    how we'll install ng-bootstrap in our Angular application. This chapter focuses
    on Bootstrap's grid system as well as some of its components, and so we're going
    to keep things simple for now by not creating an Angular application—or make any
    use of Angular at all, just yet. By the end of this chapter, we'll just have our
    skin and bones application (as previously mentioned), which we will then be converting
    into a fully-fledged Angular application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 出于学习目的，安装Bootstrap与我们将在Angular应用程序中安装ng-bootstrap是不同的。本章重点介绍Bootstrap的网格系统以及一些组件，因此我们将通过暂时不创建Angular应用程序或完全不使用Angular来保持简单。在本章结束时，我们将只有我们的皮肤和骨头应用程序（如前所述），然后将其转换为一个完整的Angular应用程序。
- en: Let's get started with the minimal, and fastest, way to integrate Bootstrap
    into our HTML. To use all Bootstrap has to offer, we only need to add resource
    links to one style sheet, and three JavaScript files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将Bootstrap集成到我们的HTML中的最小且最快的方式开始。要使用Bootstrap提供的所有功能，我们只需要添加一个样式表和三个JavaScript文件的资源链接。
- en: 'The following is the HTML code that creates an empty HTML page that demonstrates
    the bare essentials to wire in Bootstrap:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建演示如何将Bootstrap引入的空HTML页面的HTML代码：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following the order of the linked files in the previous HTML code, here are
    what the one CSS file and the three JavaScript files are for:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根据先前HTML代码中链接文件的顺序，以下是一个CSS文件和三个JavaScript文件的用途：
- en: The `bootstrap.min.css` file is the minified style sheet for Bootstrap, which
    is where all the default styles are defined
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.min.css`文件是Bootstrap的压缩样式表，其中定义了所有默认样式'
- en: The `jquery-3.2.1.slim.min.js` file is the minified JavaScript file containing
    the jQuery library and is referenced because Bootstrap itself relies on jQuery
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-3.2.1.slim.min.js`文件是包含jQuery库的压缩JavaScript文件，并且被引用，因为Bootstrap本身依赖于jQuery'
- en: The `popper.min.js` file is the minified JavaScript file for yet another third-party
    library called Popper and is referenced because Bootstrap makes use of the functionality
    therein for its Tooltip components
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popper.min.js`文件是另一个名为Popper的第三方库的压缩JavaScript文件，并且被引用，因为Bootstrap利用其中的功能来实现其工具提示组件'
- en: And, finally, the `bootstrap.min.js` file is the minified JavaScript file for Bootstrap
    itself and is used for various components, such as the modal and drop-down components,
    which require JavaScript to function
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`bootstrap.min.js`文件是Bootstrap本身的压缩JavaScript文件，用于各种组件，如模态和下拉组件，这些组件需要JavaScript来运行
- en: 'You''ll also notice that the links are resources to CDNs (that is, content
    delivery networks). Although there are other ways of installing Bootstrap in our
    website, the advantages of using CDNs are threefold:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到这些链接是指向CDN（即内容传送网络）的资源。虽然有其他安装Bootstrap在我们网站上的方法，但使用CDN的优点有三个：
- en: We don't need to download and include the files in our web project
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要在我们的网页项目中下载和包含文件
- en: The load time for the clients loading our web pages is minimized on account
    of the fact that these resources may have already been downloaded to their browsers
    while visiting other sites before ours
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户加载我们的网页的时间被最小化，因为这些资源可能在他们访问我们之前的其他网站时已经被下载到他们的浏览器中
- en: The servers are optimized for delivering those assets (using caching and other
    hosting strategies)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器经过优化，用于传送这些资产（使用缓存和其他托管策略）
- en: We will look at adding our navigation bar on our home page when we take a look
    at the Navs and the Navbar components later in this chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章后面看Navs和Navbar组件时，我们将考虑在我们的主页上添加导航栏。
- en: Bootstrap's responsive grid system
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap的响应式网格系统
- en: From my perspective, especially as a web developer that focuses on Angular,
    the most important thing that Bootstrap offers is a responsive grid. The reason
    for this is that there are many web / HTML components from many different libraries
    to choose from for web development (such as NG Bootstrap and Angular Material,
    both of which we'll be covering in later chapters) and, hence, we're not at all
    limited to just using Bootstrap's components. However, no matter which components
    you end up using, or if you create your own (as we'll learn how to do in [Chapter
    6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building Angular Components*),
    the Bootstrap grid can still be used for building responsive layouts and greatly
    simplifying our laborious task of creating well-designed web applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，特别是作为一个专注于Angular的Web开发人员，Bootstrap提供的最重要的东西是响应式网格。原因是有许多来自许多不同库的Web
    / HTML组件可供选择进行Web开发（例如NG Bootstrap和Angular Material，我们将在后面的章节中介绍），因此，我们并不仅仅局限于只使用Bootstrap的组件。然而，无论您最终使用哪些组件，或者如果您创建自己的组件（正如我们将在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)中学习的那样，*构建Angular组件*），Bootstrap网格仍然可以用于构建响应式布局，并极大地简化我们创建设计良好的Web应用程序的繁重任务。
- en: Bootstrap's grid makes it really easy for us to lay out our pages for use with
    various viewport (that is, screen) sizes. We simply use special Bootstrap classes
    to dictate how things get positioned on our pages for the different viewport sizes
    that our applications may be running on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的网格使我们能够轻松地为各种视口（即屏幕）大小布局我们的页面。我们只需使用特殊的Bootstrap类来指示在我们的页面上为我们的应用程序可能运行的不同视口大小定位事物。
- en: If you've ever wondered if Bootstrap is built on top of anything else, the answer
    is, unsurprisingly, *yes*. Libraries and frameworks often piggy-back on one another.
    This is how modern software in the open-source world is built. After all, why
    reinvent the wheel when there are perfectly sound wheels already available for
    our use? We have already seen (from the previous section on installing Bootstrap)
    that Bootstrap relies on jQuery and Popper. Bootstrap's responsive grid system
    is built on top of the CSS Flexbox, which was introduced in CSS3.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经想知道Bootstrap是否是建立在其他东西之上的，答案是，毫不奇怪地，“是”。库和框架经常相互依赖。这就是开源世界中现代软件的构建方式。毕竟，当我们已经有完全可靠的轮子可供使用时，为什么要重新发明轮子呢？我们已经从之前关于安装Bootstrap的部分中看到，Bootstrap依赖于jQuery和Popper。Bootstrap的响应式网格系统是建立在CSS3中引入的CSS
    Flexbox之上的。
- en: There is a newer grid system in CSS4, called the CSS Grid, but Bootstrap 4 does
    not use it. Bootstrap uses CSS Flexbox. This does not mean that Bootstrap is behind
    the times because newer does not necessarily mean better. Some things are made
    easier using the CSS Grid, and other things remain easier using CSS Flexbox.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS4中有一个更新的网格系统，称为CSS Grid，但Bootstrap 4没有使用它。Bootstrap使用CSS Flexbox。这并不意味着Bootstrap落后于时代，因为更新并不一定意味着更好。使用CSS
    Grid可以使一些事情变得更容易，而使用CSS Flexbox可以使其他事情变得更容易。
- en: A bit later on, when we discuss Bootstrap's predefined classes that are used
    for aligning things vertically and horizontally within the grid, the class names
    may seem familiar to you if you are familiar with CSS Flexbox. This is because
    Bootstrap uses CSS Flexbox under the covers, and the class names were inspired
    by its class names.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当我们讨论Bootstrap预定义的用于在网格内垂直和水平对齐事物的类时，如果你熟悉CSS Flexbox，这些类名可能会让你感到熟悉。这是因为Bootstrap在内部使用CSS
    Flexbox，并且类名是受其类名启发而来的。
- en: The grid itself has three main parts to it (container, row, and column), and
    each one of these is a class defined in Bootstrap's CSS file—which is why it needs
    to be referenced in our pages.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 网格本身有三个主要部分（容器、行和列），每个部分都是在Bootstrap的CSS文件中定义的类，这就是为什么需要在我们的页面中引用它。
- en: 'This is where the vernacular gets a little confusing, so let me explain something
    real quick. As you may know, there are no HTML elements named `container`, `row`,
    or `column`. We do, however, have the `div` element in HTML, and, in Bootstrap,
    we decorate it with a class—particularly, with a class of container, row, or column.
    But when we are talking about Bootstrap, it would be easier to pretend that there
    are HTML elements of these types. Let me clarify this because I''ll be referring
    to the Bootstrap row as the row element, and the Bootstrap column as the column
    element from here on. Here''s what I mean:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是俗语变得有点混乱的地方，所以让我快速解释一下。正如你所知，HTML中没有名为“容器”、“行”或“列”的元素。但是，在HTML中我们有div元素，在Bootstrap中，我们用一个类来装饰它，特别是用容器、行或列的类。但是当我们谈论Bootstrap时，假装这些类型的HTML元素会更容易。让我澄清一下，因为从现在开始我将把Bootstrap行称为行元素，把Bootstrap列称为列元素。我的意思是：
- en: It is easier to say *the container element*, rather than have to say *the div
    element with a class of container* (in code, this is what *the container element* looks
    like: `<div class="container">` )
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说“容器元素”比说“具有容器类的div元素”更容易（在代码中，这就是“容器元素”的样子：`<div class="container">`）
- en: 'It is easier to say *the row element*, rather than have to say *the div element
    with a class of row* (in code, this is what *the row element* looks like: `<div
    class="row">` )'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说“行元素”比说“具有行类的div元素”更容易（在代码中，这就是“行元素”的样子：`<div class="row">`）
- en: It is easier to say *the column element*, rather than have to say *the div element
    with a class of column* (in code, this is what *the column element* looks like: `<div
    class="col">` )
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易说“列元素”，而不是不得不说“具有列类的div元素”（在代码中，这就是“列元素”的样子：`<div class="col">`）
- en: OK, I hope that makes sense.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，希望这样说得通。
- en: The container
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: The container is the root, or top-level element, in the grid. It holds one or
    more rows, which must be nested within the container, and the rows, in turn, can
    contain zero or more columns. To create a Bootstrap grid, we start off by creating
    a container—and to do that, we simply create a set of HTML `div` elements and
    assign the container class to the first `div` element.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是网格中的根元素，或顶层元素。它包含一个或多个行，这些行必须嵌套在容器内，而行又可以包含零个或多个列。要创建一个Bootstrap网格，我们首先创建一个容器，为此，我们只需创建一组HTML
    `div`元素，并将容器类分配给第一个`div`元素。
- en: 'Here is what this looks like in code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中看起来是这样的：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ha! Do you see why I mentioned the previous stuff about a container element?
    It's a messy way to try and explain it. So, let's rephrase that now using our
    new vernacular.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 哈！你明白我为什么提到前面关于容器元素的东西了吗？这是一个混乱的方式来尝试解释它。所以，现在让我们用我们的新术语来重新表达一下。
- en: 'To create a Bootstrap grid, start off by adding a container element like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Bootstrap网格，首先添加一个容器元素，就像这样：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Ah, that is much easier to say and read! OK, back to our regular scheduled program...
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，这样说和读起来容易多了！好了，回到我们正常的节目安排…
- en: 'There are two types of containers that you can have—and it is their class name
    that differentiates them from one another:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有两种类型的容器，它们的类名使它们彼此区分开来：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The row
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行
- en: The row element must be nested within the container element. (Ha! I love this
    element stuff. Just try and explain it in writing without doing something like
    this!) A Bootstrap grid must contain at least one row and can contain as many
    rows as are needed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 行元素必须嵌套在容器元素中。（哈！我喜欢这个元素的东西。试着在写作中解释它而不做类似的事情！）Bootstrap网格必须至少包含一行，并且可以包含所需的行数。
- en: 'Adding to the previous container code, here is what the code for a grid looks
    like that has two rows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个容器代码的基础上，以下是具有两行的网格代码的样子：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A row does not have to contain a column at all—for example, you may simply just
    want empty space between two rows in your grid—but it can have a maximum width
    of 12 columns within it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一行不一定要包含一列——例如，你可能只是想在网格中的两行之间留出空白，但它最多可以包含12列。
- en: However, it is important to note that the number of columns a row has is not
    proportional to the number of nested column elements (we'll look at Bootstrap's
    notion of a column in the next section). This is because the total number of columns
    in a row is independent of the number of column elements in that row.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，一行中的列数与嵌套列元素的数量不成比例（我们将在下一节中看一下Bootstrap对列的概念）。这是因为一行中的总列数与该行中的列元素数量是独立的。
- en: Let me show you three examples to clarify this notion by adding to the previous
    row code. I will explain what `class="col-4"` , `class="col-6"`, and, generally
    speaking, `class="col-x"` (where x is an integer ranging from 1 to 12), all mean
    right after the following three grid examples.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我通过在上一行代码中添加三个示例来澄清这个概念。我将解释`class="col-4"`，`class="col-6"`，以及一般来说，`class="col-x"`（其中x是从1到12的整数）的含义，紧接着是以下三个网格示例。
- en: 'In the first example, the grid has two rows, each of which has three columns
    of equal width:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，网格有两行，每行都有三列等宽：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the second example, the grid only has one row with two columns of equal
    width:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，网格只有一行，有两列等宽：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the third example, the grid also only has one row with two columns, but
    they are not of equal width. In fact, the first column only takes up 25% of the
    row''s total available width, and the second column takes up the remaining 75%:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，网格也只有一行，有两列，但它们的宽度不相等。事实上，第一列只占总宽度的25%，第二列占了剩下的75%。
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: OK, now that we've seen three grid examples, we can discuss what on earth the `"col-x"` class
    names mean. The grid allows up to 12 columns per row, and each column element
    you embed in the row can span 1 to 12 columns—and is what the x represents. As
    a quick example, if we have a column element in our row, and we'd like for it
    to span eight of the available 12 columns, our class name would be `col-8` and
    our column element would look like this: `<div class="col-8">`. The key is that
    the total number of columns in our row (which is the addition of the x's in our
    class names) should not surpass 12\. However, it can be less than 12.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经看过三个网格示例，我们可以讨论一下 `"col-x"` 类名到底是什么意思。网格允许每行最多有12列，你在行中嵌入的每个列元素可以跨越1到12列——这就是x代表的意思。举个例子，如果我们在行中有一个列元素，并且希望它跨越可用的12列中的8列，我们的类名将是`col-8`，我们的列元素将如下所示：`<div
    class="col-8">`。关键是我们行中的列的总数（也就是我们类名中x的总和）不应该超过12。但是，它可以少于12。
- en: 'Additionally, each row in your grid can have different numbers of columns,
    where each column is also a different width to the other columns within the same
    row. Let''s quickly look at an example before discussing some interesting ways
    that you can align columns within the row by adding pre-defined Bootstrap classes
    to the row element:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的网格中的每一行可以有不同数量的列，每个列的宽度也可以不同。在讨论一些有趣的方法之前，让我们快速看一个例子，你可以通过向行元素添加预定义的Bootstrap类来对齐行内的列。
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The grid in the preceding code has two rows, where the first row has two columns
    of unequal widths, and the second row has three columns of unequal widths.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中的网格有两行，第一行有两列宽度不等，第二行有三列宽度不等。
- en: Whenever you have a grid, you need to concern yourself with how things align
    up within it. Bootstrap has pre-defined classes that can be used on the row elements
    in order to align the column elements within them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个网格时，你需要关心的是如何在其中对齐。Bootstrap有预定义的类，可以用于行元素，以便对其中的列元素进行对齐。
- en: 'Here are a few of these classes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其中一些类：
- en: justify-content-center (centers the columns)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: justify-content-center（居中对齐列）
- en: justify-content-start (left-justifies the columns)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: justify-content-start（左对齐列）
- en: justify-content-end (right-justifies the columns)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: justify-content-end（右对齐列）
- en: justify-around-end (spaces the columns evenly)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: justify-around-end（均匀间隔列）
- en: justify-between-end (puts all the available space between the two columns)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: justify-between-end（将所有可用空间放在两列之间）
- en: The interesting thing about these classes—which affect the horizontal alignment
    of the columns in the encapsulating row—is that you can only see their effect
    when the total spanned columns of all the column elements amount to a number less
    than 12\. This is precisely why having fewer than 12 spanned columns is allowed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类的有趣之处在于它们影响封装行中列的水平对齐，只有当所有列元素跨越的列数总和少于12时，你才能看到它们的效果。这正是为什么允许少于12列的跨度的原因。
- en: 'Here is an example of what a row element that contains fewer than 12 spanned
    rows looks like:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含少于12列跨度的行元素的例子：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this previous example, we have a grid that has one row and that row contains
    two columns. However, since the total spanned columns are fewer than 12, the horizontal
    alignment that will be applied (due to the `justify-around-end` class) will have
    a visible effect—which is to center the columns while inserting the available
    unused space (a third of the row's width in this case) around the columns. This
    will have the appearance of margins on either side of the columns, with double
    the margin between them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，我们有一个包含两列的一行网格。然而，由于跨度的列少于12列，将应用水平对齐（由于`justify-around-end`类），这将产生可见效果，即将列居中，并在列周围插入可用的未使用空间（在这种情况下为行宽的三分之一）。这将使列两侧出现边距，它们之间的边距加倍。
- en: The other classes mentioned have different horizontal alignment effects than
    the description beside them in the bullet list. I encourage you to play around
    with these classes to get used to them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其他提到的类别具有不同的水平对齐效果，与它们旁边的项目描述不同。我鼓励你尝试使用这些类别来熟悉它们。
- en: The column
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列
- en: The column elements must be nested within the row elements, as the previous
    examples showed. We've already seen how many column elements can fit in a row,
    which depends on their respective column widths.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列元素必须嵌套在行元素中，就像之前的示例所示。我们已经看到了多少列元素可以放入一行中，这取决于它们各自的列宽度。
- en: The columns in the grid are basically your cells in the grid and are where your
    content (that is, text, images, and so on) is to be inserted. If you have a grid
    that has six rows of four-column elements each, you have 24 cells in which to
    place your content.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的列基本上是网格中的单元格，是您的内容（即文本、图像等）要插入的位置。如果您有一个包含六行四列元素的网格，您有24个单元格可供放置您的内容。
- en: Just as you can align the column elements within the row elements, using special
    classes on the row elements, you can also align the content within your column
    elements, using special classes on the column elements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用行元素上的特殊类别来对齐列元素一样，你也可以使用列元素上的特殊类别来对齐列元素内的内容。
- en: 'Here are some of the classes you can use on the column elements in order to
    align your content within them:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以在列元素上使用的一些类别，以便对齐其中的内容：
- en: '`align-self-start` will force that specific cell''s content to the top of the
    cell'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`align-self-start`将强制特定单元格的内容位于单元格顶部'
- en: '`align-self-end` will force that specific cell''s content to the bottom of
    the cell'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`align-self-end`将强制特定单元格的内容位于单元格底部'
- en: '`align-self-center` will force that specific cell''s content to the vertical
    center of the cell'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`align-self-center`将强制特定单元格的内容位于单元格的垂直中心'
- en: Differing viewport sizes
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的视口大小
- en: The final thing that I would like to cover regarding Bootstrap's grid is probably
    the most important one of all. What makes the grid responsive? That is to say,
    how does the grid adapt to different viewport sizes? The answer to this is two-fold.
    Firstly, most HTML layouts (even vanilla layouts that were not at all designed
    to be responsive) have some built-in leeway on how they react when viewed on screens
    of varying sizes. However, while the layout of a standard web page may still be
    acceptable in the way a browser renders it on a tablet versus a regular 19-inch
    monitor, things tend to break down and not work at all for a website that looks
    decent on a tablet, but is currently being viewed on a standard mobile phone,
    such as the iPhone 7, or a similarly sized Android device. This is where we need
    some design intervention, and what leads to the second way in which a Bootstrap
    grid adapts to the device's viewport size—namely, special tweaks to the classes,
    and class names for the column.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Bootstrap的网格，我想要讨论的最后一件事可能是最重要的。什么使得网格具有响应性？也就是说，网格如何适应不同的视口尺寸？这个问题有两个方面的答案。首先，大多数HTML布局（甚至是那些根本没有设计为响应式的普通布局）在不同尺寸的屏幕上查看时都有一定的灵活性。然而，虽然标准网页的布局在平板电脑和普通19英寸显示器上的渲染可能仍然可以接受，但对于一个在平板上看起来不错，但目前正在普通手机上查看的网站来说，情况往往会变得混乱，甚至根本无法使用，比如iPhone
    7或类似尺寸的Android设备。这就是我们需要一些设计干预的地方，也是Bootstrap网格适应设备视口尺寸的第二种方式，即对类和列的类名进行特殊调整。
- en: 'You''ll remember that the class name we''ve been using for the column element
    has the following general form:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们一直在为列元素使用的类名具有以下一般形式：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Well, in order to make the grid responsive, Bootstrap has included the ability
    for us to tweak the classes by adding a symbol to the class name between the `col` and
    the `x` (that is, an integer from 1 to 12).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使网格具有响应性，Bootstrap包含了让我们通过在`col`和`x`之间的类名中添加一个符号来调整类的能力（即从1到12的整数）。
- en: 'For example, here is what the column element''s class would look like with
    one of these symbols (in actuality, it''s not a symbol but rather a new class
    name—however, for the purposes of explaining it, you can think of it as a symbol):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是带有其中一个这些符号的列元素类的样子（实际上，它不是一个符号，而是一个新的类名，但是为了解释起见，你可以把它看作是一个符号）：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I''ll explain what the `sm` in `col-sm-4` means in a moment, but, in practice,
    you''ll see more than one class name on a column element. For instance, here is
    a likely set of class names on a column element:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我将解释一下`col-sm-4`中的`sm`是什么意思，但实际上，在实践中，你会在列元素上看到不止一个类名。例如，以下是列元素上可能的一组类名：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'OK, let''s decipher what this set of classes is for. To do that, let me first
    list the available symbols and what they mean:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们解释一下这组类是用来做什么的。为了做到这一点，让我首先列出可用的符号及其含义：
- en: '| **Viewport size** | **Extra-small** | **Small** | **Medium** | **Large**
    | **Extra large** |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **视口尺寸** | **超小** | **小** | **中** | **大** | **超大** |'
- en: '| Grid breakpoint | <576px | >=576px | >=768px | >=992px | >=1200px |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 网格断点 | <576px | >=576px | >=768px | >=992px | >=1200px |'
- en: '| Max container width | None | 540px | 720px | 960px | 1140px |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 最大容器宽度 | 无 | 540px | 720px | 960px | 1140px |'
- en: '| Symbol | xs | sm | md | lg | xl |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | xs | sm | md | lg | xl |'
- en: '| Typical devices | iPhone, iPod, Android phone | iPad 1, iPad 2, iPad Mini
    | Older monitor (low res, 800x600), a few older Android tablets | Regular modern
    monitor, most modern Android tablets | Hi-res modern monitor, iPad 3, iPad 4,
    Android tablets |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 典型设备 | iPhone、iPod、Android手机 | iPad 1、iPad 2、iPad Mini | 旧显示器（低分辨率，800x600）、一些旧Android平板
    | 普通现代显示器、大多数现代Android平板 | 高分辨率现代显示器、iPad 3、iPad 4、Android平板 |'
- en: '| Class prefix | .col-xs- | .col-xs- | .col-md- | .col-lg- | .col-xl- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 类前缀 | .col-xs- | .col-xs- | .col-md- | .col-lg- | .col-xl- |'
- en: In the preceding table, in the third row from the bottom, I've listed the five
    symbols that are available to you. In the secondrow from the bottom, I have listed
    the typical target devices for which the symbol, and thus the grid-breakpoint,
    applies. I'll discuss the grid-breakpoint in a moment, but I just wanted to say
    that these target devices I've listed are rules of thumb—they are not set in stone.
    For instance, Android tablets are listed in three of the five viewport size columns.
    This is because there are many Android tablet manufacturers and even more sizes
    of displays (that is, viewports) that they come in. The same can be said for laptops.
    However, the viewport sizes on Apple-based products are well known, and fewer
    in number—and is why I listed them by name. Suffice it to say, by taking a look
    at the typical device's row, you can get a fairly good idea of what column class
    you probably want to use.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，从底部的第三行开始，我列出了对你可用的五个符号。在倒数第二行，我列出了符号和网格断点适用的典型目标设备。我将在一会儿讨论网格断点，但我只想说我列出的这些目标设备是经验法则——它们并非一成不变。例如，Android平板电脑在五个视口大小列中出现了三次。这是因为有许多Android平板电脑制造商，甚至更多尺寸的显示器（即视口）可供选择。笔记本电脑也是如此。然而，基于苹果产品的视口大小是众所周知的，数量较少——这就是我按名称列出它们的原因。可以说，通过查看典型设备的行，你可以相当清楚地了解你可能想要使用哪个列类。
- en: 'Armed with this knowledge of viewport sizes and the previous table, let''s
    now decipher what this column element and set of classes mean:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了视口大小和之前的表格的知识，现在让我们解密这个列元素和类别的含义：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This column element contains a set of three classes, and each class basically
    instructs the browser on how to render the column and its contents depending on
    the viewport size. As an aside, technically speaking, the viewport size is the
    maximum dimensions (in pixels) of the display. Taking the case of a 13-inch laptop
    monitor with its resolution set to 1600 x 900, its viewport size is 1600px wide
    by 900px high. Practically, however, the viewport size is the dimensions of the
    browser window, and not the laptop's display itself. This is an important distinction
    when we talk about responsive web design because, when using a desktop or laptop
    computer, people can resize their browsers—which forces the web page to be re-rendered—and,
    hence, this is truly what the viewport size is, from Bootstrap's perspective,
    and for our purposes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列元素包含一组三个类，每个类基本上指示浏览器如何根据视口大小呈现列和其内容。从技术上讲，视口大小是显示器的最大尺寸（以像素为单位）。以分辨率设置为1600
    x 900的13英寸笔记本电脑显示器为例，其视口大小为1600像素宽，900像素高。然而，在实际情况下，视口大小是浏览器窗口的尺寸，而不是笔记本电脑显示器本身的尺寸。这在我们谈论响应式网页设计时是一个重要的区别，因为在使用台式机或笔记本电脑时，人们可以调整他们的浏览器大小——这会强制网页重新呈现——因此，这确实是Bootstrap的视角和我们的目的所在的视口大小。
- en: 'Coming back to the deciphering of the previous column element, while referencing
    the previous viewport size table, and having mentioned how the resizing of the
    browser dictates the viewport size that we, as developers, care about, we can
    now decipher what these three classes are instructing the browser to do:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 回到解密上一列元素的过程，参考上一个视口大小表，并提到浏览器调整大小如何决定我们作为开发者关心的视口大小，我们现在可以解密这三个类别指示浏览器要做什么：
- en: '`col-xs-12`: This tells the browser that when the viewport is fewer than 576
    pixels in width, the column should span all 12 columns. In other words, the column
    should consume the entire available width of the row.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col-xs-12`：这告诉浏览器，当视口宽度小于576像素时，该列应跨越所有12列。换句话说，该列应占据整个行的可用宽度。'
- en: '`col-sm-4`: This tells the browser that when the viewport is between 576 and
    767 pixels in width, the column should span four of the 12 available columns.
    In other words, the column should consume 1/3 of the row''s width.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col-sm-4`：这告诉浏览器，当视口宽度在576到767像素之间时，该列应占用12个可用列中的四列。换句话说，该列应占据行宽的1/3。'
- en: '`col-md-3`: This tells the browser that when the viewport is 768 or more pixels
    in width, the column should span three of the 12 available columns. In other words,
    the column should consume 1/4th of the row''s width.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`col-md-3`：这告诉浏览器，当视口宽度为768像素或更多时，该列应占用12个可用列中的三列。换句话说，该列应占据行宽的1/4。'
- en: We could have controlled the rendering of the column for viewport sizes 992
    or more pixels in width by adding the classes with the class prefixes `.col-lg-`
    and `.col-xl-`, but, in the example we've just seen, we didn't seem to care—which
    is to say, no matter how wide the viewport is (even 2400px!), our column's width
    would scale to consume 25% of the row's width.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过添加带有类前缀`.col-lg-`和`.col-xl-`的类来控制视口宽度为992像素或更多时列的呈现，但在我们刚刚看到的例子中，我们似乎并不在乎——也就是说，无论视口有多宽（甚至是2400像素！），我们的列宽都会按比例占据行宽的25%。
- en: And that, ladies and gentlemen, is how you can design a web page while maintaining
    how the contents in your grid's cells are to be rendered on thousands of viewport
    sizes. By leveraging Bootstrap's grid, we no longer need to code up several variations
    of our web pages to get them to display the way we want on different sized displays.
    Pretty darn cool, ain't it?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 各位先生女士，这就是你如何设计一个网页，同时保持网格单元格中内容在成千上万个视口尺寸上的呈现方式。通过利用Bootstrap的网格，我们不再需要编写多个版本的网页来让它们在不同尺寸的显示器上显示我们想要的样子。相当酷，不是吗？
- en: Bootstrap components
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap组件
- en: As previously mentioned near the beginning of this chapter, I did not want to
    simply regurgitate Bootstrap's documentation when covering components. Instead,
    I will briefly discuss five of Bootstrap's components that we'll be using, showing
    some basic code for them, and pointing you to Bootstrap's official documentation
    for these components so you can learn more about their options, of which there
    are many—far too numerous to cover in a book such as this fine example you are
    currently reading.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头提到的，我不想在讲解组件时简单地重复Bootstrap的文档。相反，我将简要讨论我们将使用的Bootstrap的五个组件，展示它们的一些基本代码，并指向Bootstrap官方文档，让你可以了解更多关于这些组件的选项，其中有很多——远远超出了这本书的覆盖范围。
- en: Button components
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮组件
- en: Buttons are all around us—and no, I'm not referring to the buttons on your favorite
    dress shirt. If you've ever been on an elevator (hey, some people absolutely refuse
    to step into one), you will no doubt see buttons—and pressing one of them will
    transport you to a place you want to go. The same thing goes with your TV remote—but
    instead of transporting you (at least not quite yet—but maybe in the future, y'all
    just never know), it transports your mind to another place from the very comfort
    of your living room. These buttons perform functional, meaningful tasks. How about
    buttons on a web page? Well, arguably, they also transport things—such as information,
    when you click the submit button on a form that you fill out. But perhaps an equally
    important feature of buttons is to help make your web pages attractive, and intuitive.
    Luckily, Bootstrap makes it super easy to add beautifully styled buttons to our
    web pages—100 times more refined than the default gray button that a browser renders
    when you add a button element.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮无处不在——不，我指的不是你最喜欢的衬衫上的按钮。如果你曾经乘坐电梯（嘿，有些人绝对拒绝进入电梯），你肯定会看到按钮，并按下其中一个按钮会把你带到你想去的地方。电视遥控器也是一样的——但是它不是把你带到另一个地方（至少目前还没有，但也许在未来，你们永远不知道），它是把你的思绪从舒适的客厅带到另一个地方。这些按钮执行功能性、有意义的任务。网页上的按钮呢？可以说，它们也传输东西——比如，当你点击表单上的提交按钮时，它传输信息。但也许按钮同样重要的功能是帮助使你的网页更具吸引力和直观。幸运的是，Bootstrap让我们可以轻松地向我们的网页添加漂亮的样式按钮——比浏览器在添加按钮元素时呈现的默认灰色按钮精致100倍。
- en: Let's take a look at a few of these while exploring some of Bootstrap's pre-defined
    button classes (that is, styles).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些这些类，同时探索一些Bootstrap预定义的按钮类（即样式）。
- en: 'Out of the box, without any tweaking necessary, we can easily insert a beautifully
    styled button by assigning two classes to the button element like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 无需任何调整，我们可以通过给按钮元素分配两个类来轻松插入一个漂亮的样式按钮，就像这样：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That button is blue in color, but there are other default colors we have access
    to via these other classes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那个按钮是蓝色的，但是我们可以通过其他类来访问其他默认颜色：
- en: '`btn-secondary`: Light charcoal gray, with white font'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-secondary`: 浅炭灰色，白色字体'
- en: '`btn-success`: Light green, with white font'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-success`: 浅绿色，白色字体'
- en: '`btn-danger`: Red, with white font'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-danger`: 红色，白色字体'
- en: '`btn-warning`: Goldenrod, with black font'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-warning`: 金黄色，黑色字体'
- en: '`btn-info`: Teal, with white font'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-info`: 蓝绿色，白色字体'
- en: '`btn-light`: Light gray, with black font'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-light`: 浅灰色，黑色字体'
- en: '`btn-dark`: Almost black, with white font'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-dark`: 几乎是黑色，白色字体'
- en: There's also a class for turning a button into a link: `btn-link`
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个将按钮变成链接的类：`btn-link`
- en: If you prefer something more white, or less heavy on the color, Bootstrap has
    a set of classes that match the preceding classes called *Outline buttons*. The
    colors and class names are the same, with the only difference being the word *outline* between
    *btn* and *secondary, success, dan**ger,* and so on. The buttons are transparent
    except for the outline, or border, and of course, the font color for the text
    on the button.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢白色一些，或者颜色更轻一些，Bootstrap有一组与前面的类匹配的类，称为*轮廓按钮*。颜色和类名是相同的，唯一的区别是在*btn*和*secondary,
    success, danger*等之间加上*outline*这个词。按钮是透明的，除了轮廓或边框，当然，按钮上的文本的字体颜色也是不同的。
- en: 'Here''s what these class names look like:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类名看起来是这样的：
- en: '`btn-outline-secondary`: Light charcoal gray outline, with the same color for
    the font'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-secondary`: 浅炭灰色轮廓，字体颜色相同'
- en: '`btn-outline-success`: Light green outline, with the same color for the font'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-success`: 浅绿色轮廓，字体颜色相同'
- en: '`btn-outline-danger`: Red outline, with the same color for the font'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-danger`: 红色轮廓，字体颜色相同'
- en: '`btn-outline-warning`: Goldenrod outline, with the same color for the font'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-warning`：金菊色轮廓，字体颜色相同'
- en: '`btn-outline-info`: Teal outline, with the same color for the font'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-info`：青色轮廓，字体颜色相同'
- en: '`btn-outline-light`: Light gray outline, with the same color for the font'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-light`：浅灰色轮廓，字体颜色相同'
- en: '`btn-outline-dark`: Almost black outline, with the same color for the font'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn-outline-dark`：几乎黑色轮廓，字体颜色相同'
- en: 'All these buttons come in a default size in terms of height, and font size.
    However, as you may have guessed, Bootstrap has a way in which to make the default
    button larger or smaller by adding the `.btn-lg` or `.btn-sm` class, respectively.
    Here is what that would look like:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些按钮都有默认的高度和字体大小。但是，正如您可能已经猜到的那样，Bootstrap有一种方法可以通过分别添加`.btn-lg`或`.btn-sm`类来使默认按钮变大或变小。以下是它的样子：
- en: '`<button type="button" class="btn btn-primary btn-lg">I''m large</button>`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<button type="button" class="btn btn-primary btn-lg">我很大</button>`'
- en: '`<button type="button" class="btn btn-primary btn-sm">I''m small</button>`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<button type="button" class="btn btn-primary btn-sm">我很小</button>`'
- en: You can read all you care to about Bootstrap's buttons here: [https://getbootstrap.com/docs/4.0/components/buttons/](https://getbootstrap.com/docs/4.0/components/buttons/)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里阅读有关Bootstrap按钮的所有信息：[https://getbootstrap.com/docs/4.0/components/buttons/](https://getbootstrap.com/docs/4.0/components/buttons/)
- en: Alert components
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警报组件
- en: When a user takes an action on a web page, such as updating their phone number
    on their user profile, it's always nice to let them know if the update was successful
    or not. Sometimes these user feedback messages are referred to as "flash messages"
    (because they often only appear for a few moments, and then fade away so as to
    not clutter the screen). Bootstrap calls them "alerts", and they are created by
    adding the predefined alert classes and a role attribute to a `div` element.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在网页上执行操作，例如在其用户资料中更新其电话号码时，让他们知道更新是否成功或不成功总是很好。有时这些用户反馈消息被称为“闪现消息”（因为它们通常只出现片刻，然后消失，以免使屏幕混乱）。Bootstrap称它们为“警报”，通过向`div`元素添加预定义的警报类和role属性来创建它们。
- en: 'For the most part, their coloring and naming scheme is fairly consistent with
    the button components. Here are the alerts that are available:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，它们的着色和命名方案与按钮组件相当一致。以下是可用的警报：
- en: '`<div class="alert alert-primary" role="alert">This is a primary alert</div>`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-primary" role="alert">这是一个主要警报</div>`'
- en: '`<div class="alert alert-secondary" role="alert">This is a secondary alert</div>`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-secondary" role="alert">这是一个次要警报</div>`'
- en: '`<div class="alert alert-success" role="alert">This is a success alert</div>`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-success" role="alert">这是一个成功警报</div>`'
- en: '`<div class="alert alert-danger" role="alert">This is a danger alert</div>`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-danger" role="alert">这是一个危险警报</div>`'
- en: '`<div class="alert alert-warning" role="alert">This is a warning alert</div>`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-warning" role="alert">这是一个警告警报</div>`'
- en: '`<div class="alert alert-info" role="alert">This is a info alert</div>`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-info" role="alert">这是一个信息警报</div>`'
- en: '`<div class="alert alert-light" role="alert">This is a light alert</div>`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-light" role="alert">这是一个浅色警报</div>`'
- en: '`<div class="alert alert-dark" role="alert">This is a dark alert</div>`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div class="alert alert-dark" role="alert">这是一个黑暗警报</div>`'
- en: Not only do Bootstrap's alerts look pretty, but they are quite neat. You can
    embed links in them (since it's just HTML, after all), and even insert an optional
    dismiss button. The alert component is a good example of why Bootstrap depends
    on the jQuery library, since it's required for the dismissal of the alert component.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap的警报不仅外观漂亮，而且非常整洁。您可以在其中嵌入链接（毕竟它只是HTML），甚至插入一个可选的关闭按钮。警报组件是Bootstrap依赖jQuery库的一个很好的例子，因为它需要用于关闭警报组件。
- en: Alerts are worth the time to learn so that you can utilize them in your applications.
    Here is the link to Bootstrap's documentation on its alert components: [https://getbootstrap.com/docs/4.0/components/alerts/](https://getbootstrap.com/docs/4.0/components/alerts/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 警报值得学习，这样您就可以在应用程序中利用它们。这是Bootstrap关于其警报组件的文档链接：[https://getbootstrap.com/docs/4.0/components/alerts/](https://getbootstrap.com/docs/4.0/components/alerts/)。
- en: Navbar component
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航栏组件
- en: 'The Navbar component is very rich — you can do a lot with it—but, in essence,
    it''s Bootstrap''s way to give you a nicely styled navigation bar across the top
    of your web page. The richness comes from the fact that there are a few sub-components
    that can be used. These include the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏组件非常丰富 - 您可以做很多事情 - 但本质上，它是Bootstrap为您提供一个漂亮样式的网页顶部导航栏的方式。丰富性来自于可以使用的一些子组件。这些包括以下内容：
- en: '`.navbar-brand` for your company, product, or project name'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.navbar-brand` 用于您公司、产品或项目名称'
- en: '`.navbar-nav` for a full-height and lightweight navigation (including support
    for dropdowns)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.navbar-nav` 用于全高度和轻量级导航（包括对下拉菜单的支持）'
- en: '`.navbar-toggler` for use with our collapse plugin and other navigation toggling behaviors'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.navbar-toggler` 用于与我们的折叠插件和其他导航切换行为一起使用'
- en: '`.form-inline` for any form controls and actions'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.form-inline` 用于任何表单控件和操作'
- en: '`.navbar-text` for adding vertically centered strings of text'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.navbar-text` 用于添加垂直居中的文本字符串'
- en: '`.collapse.navbar-collapse` for grouping and hiding `navbar` contents by a
    parent breakpoint'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.collapse.navbar-collapse` 用于通过父断点对`navbar`内容进行分组和隐藏'
- en: Showing examples of all these items here would be too costly, with little associated
    benefit. Rather than do that here, I will show you how to use Bootstrap to build
    the navigation menu for our example application later in this chapter. The code
    can be found in the code listings at the end of the chapter. The first wireframe
    in the pages that follow shows a logo placeholder, a menu, and Login and Try Now
    buttons. The wireframes represent drafts of the pages we're aiming to build. Our
    navigation bar will look slightly different, but will encompass all the parts
    that are shown on the wireframe.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示所有这些项目的示例将成本过高，而受益甚微。与其在这里这样做，不如在本章后面向您展示如何使用Bootstrap来构建我们示例应用程序的导航菜单。代码可以在本章末尾的代码列表中找到。接下来的页面中的第一个线框显示了一个标志占位符、一个菜单以及登录和立即尝试按钮。线框代表我们打算构建的页面的草稿。我们的导航栏看起来可能会有所不同，但将包含线框上显示的所有部分。
- en: 'More documentation on Bootstrap''s Navs and Navbar components can be found:
    [https://getbootstrap.com/docs/4.0/components/navs/](https://getbootstrap.com/docs/4.0/components/navs/)
    and [https://getbootstrap.com/docs/4.0/components/navbar/](https://getbootstrap.com/docs/4.0/components/navbar/).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Bootstrap的Navs和Navbar组件的更多文档可以在这里找到：[https://getbootstrap.com/docs/4.0/components/navs/](https://getbootstrap.com/docs/4.0/components/navs/)
    和 [https://getbootstrap.com/docs/4.0/components/navbar/](https://getbootstrap.com/docs/4.0/components/navbar/)。
- en: Modal components
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态组件
- en: Modal components are great ways to draw your user's attention to things by using
    them for creating lightboxes, user notifications, and more. I like to use them
    for popping up forms for users to add items and edit them as well, directly from
    the page that lists those items. This way, all the functionality (that is, view,
    add, edit, and delete) for a listing of items is all done on one page. Using the
    modal component in this way leads to a clean design that is intuitive to users.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 模态组件是吸引用户注意力的好方法，可以用它们来创建灯箱、用户通知等。我喜欢用它们来弹出表单，让用户直接从列出这些项目的页面上添加和编辑项目。这样，所有项目列表的功能（即查看、添加、编辑和删除）都在一个页面上完成。以这种方式使用模态组件会导致直观的清晰设计。
- en: As with the Navbar component, showing examples here is not the best way to demonstrate
    modals. Rather than show contrived examples, I will show you through code (by
    referencing the code listings at the appropriate time) how we'll achieve creating
    the modal forms shown in the following wireframes. When you take a look at the
    wireframes, you'll see that I've used modals quite generously throughout the pages.
    I've even used them for the login and the sign-up functionality of the site.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与导航栏组件一样，这里展示示例并不是展示模态框的最佳方式。我将通过代码（在适当的时候引用代码清单）来向你展示我们将如何创建下面线框中显示的模态表单。当你看到线框时，你会发现我在页面中非常慷慨地使用了模态框。我甚至用它们来实现网站的登录和注册功能。
- en: There are several demos on Bootstrap's modal component that you can check out
    here: [https://getbootstrap.com/docs/4.0/components/modal/](https://getbootstrap.com/docs/4.0/components/modal/)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个关于 Bootstrap 模态组件的演示，你可以在这里查看：[https://getbootstrap.com/docs/4.0/components/modal/](https://getbootstrap.com/docs/4.0/components/modal/)
- en: We've only covered four commonly used components that Bootstrap offers, but
    they are enough for us to get a glimpse of what can be done with pre-defined components.
    There are many other components that can be used, and you can find them on the
    official Bootstrap website here: [https://getbootstrap.com/docs/4.0/components/](https://getbootstrap.com/docs/4.0/components/)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只涵盖了 Bootstrap 提供的四个常用组件，但这已经足够让我们一窥预定义组件的功能。还有许多其他可以使用的组件，你可以在官方 Bootstrap
    网站上找到它们：[https://getbootstrap.com/docs/4.0/components/](https://getbootstrap.com/docs/4.0/components/)
- en: Again, we're not covering all of Bootstrap's components because the official
    documentation has done that job already — and has done it well. Additionally,
    we'll be using NG Bootstrap components, Angular Material components, and custom
    components that we'll be creating together in later chapters.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们没有涵盖所有 Bootstrap 的组件，因为官方文档已经完成了这项工作，并且做得很好。此外，我们将在后面的章节中使用 NG Bootstrap
    组件、Angular Material 组件和我们将一起创建的自定义组件。
- en: Listing Carousel – a formal introduction
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单轮播 - 正式介绍
- en: 'The evolution of a software project is a very interesting thing, and it follows
    a very logical series of stages. Here are the stages that we will cover—which
    are true of any software project:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目的演变是一件非常有趣的事情，它遵循一系列非常合乎逻辑的阶段。以下是我们将涵盖的阶段 - 这对于任何软件项目都是真实的：
- en: Idea generation/concept.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创意生成/概念。
- en: 'Analysis/feasibility study: The purpose of conducting a feasibility study on
    the product concept is to vet the ROI (that is, return on investment) for the
    project. In other words, is the project worth the company''s investment of its
    resources (time, money, talent, and so on)?'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析/可行性研究：对产品概念进行可行性研究的目的是审查项目的投资回报率（即投资回报率）。换句话说，这个项目是否值得公司投入资源（时间、金钱、人才等）？
- en: Requirement gathering.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求收集。
- en: Use cases.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用案例。
- en: Wireframes.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线框。
- en: Implementation.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施。
- en: With these software project stages outlined, let's look at a real-life example
    using Listing Carousel.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些软件项目阶段的概述，让我们来看一个使用清单轮播的真实例子。
- en: Idea generation/concept
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创意生成/概念
- en: Ideas for software projects can come from anywhere and at any time, but for
    the vast majority of the time, the ideas are inspired by a need to solve problems
    that organizations will invariably have from time to time throughout their lifetimes.
    The two main categories of problems areaddressing an inefficiency and creating
    an opportunity for itself in the market via creating a competing product that
    is better than (that is, differentiated from) those of its competitors. Stated
    in other terms, software projects can often be viewed as either being an efficient play
    or a competitive advantage play. Solving these two types of problems are the needs
    that every growing organization will have at some point, or at many points, in
    time throughout its existence.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目的想法可以来自任何地方，任何时间，但在绝大多数情况下，这些想法都是受到解决组织在其生命周期中不可避免地遇到的问题的启发。主要的问题类别有解决低效和通过创建一个比竞争对手更好（即与众不同）的竞争产品在市场上创造机会。换句话说，软件项目通常可以被视为是一个高效的举措或竞争优势的举措。解决这两种类型的问题是每个不断发展的组织在其存在的某个时刻，或者在其整个存在期间都会遇到的需求。
- en: 'So, how was Listing Carousel conceived? Having been a real estate salesperson
    in a previous life, turned IT pro, it was easy for me to think of a way to develop
    a better way for real estate agents to spread the word of their new listings (that
    is, properties for sale) to their social media circles, and to showcase their
    listings in a more informative way than the other primary options currently available
    to them. While there are several ways a real estate agent can market their listings,
    I found they lacked two basic things:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Listing Carousel是如何构想出来的呢？作为前房地产销售员，转行成为IT专业人员，我很容易想到一种更好的方式，让房地产经纪人能够更好地向他们的社交媒体圈子传播他们的新房源，并以比目前其他主要选项更具信息性的方式展示他们的房源。虽然房地产经纪人可以通过多种方式推广他们的房源，但我发现他们缺乏两个基本的东西：
- en: A way to easily spread the word of their listings to their social media circles
    (that is, Instagram and Facebook)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的房源可以轻松地在他们的社交媒体圈子（即Instagram和Facebook）中传播
- en: A way to present the properties in a slightly more engaging way, while also
    better describing the properties at the same time
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种稍微更具吸引力的方式呈现房产，同时更好地描述房产
- en: So, the problem I had was that I had to create a software product that was markedly
    differentiated from other software services. The solution was to think of the
    two product differentiators listed previously and to assume that I can get access
    to the technology required to make it happen. Thus, for Listing Carousel, you
    can say that the software project was conceived as a competitive advantage play.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我的问题是我必须创建一个与其他软件服务明显不同的软件产品。解决办法是考虑之前列出的两个产品差异化因素，并假设我可以获得所需的技术来实现它。因此，对于Listing
    Carousel来说，可以说这个软件项目是作为竞争优势的举措构想出来的。
- en: Great! I had a potential software project to work on! What's next? Well, as
    mentioned at the start of this section, the next stage was to do a feasibility
    study. Recall that the purpose of conducting a feasibility study on the product
    concept is to vet the ROI for the project, and to also do the research to see
    whether the required technology was readily available—or, if not, can it be created?
    Let's briefly look at this next.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我有一个潜在的软件项目要做！接下来呢？嗯，正如本节开头提到的，下一个阶段是进行可行性研究。回想一下，对产品概念进行可行性研究的目的是审查项目的投资回报率，并进行研究，看所需技术是否已经可获得，或者是否可以创建？让我们简要地看一下接下来的内容。
- en: Analysis — feasibility study
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 - 可行性研究
- en: This stage in the project analysis is where the go / no-go decision will be
    made. The proper way to conduct a feasibility study is to prepare a business plan,
    and present it to investors. Why? The reason why managers of a company go through
    the process of writing a business plan, and showing it to investors (or to the
    VP, President, or CEO of the company—for internal software projects), is because
    they need a document that they can share with an investor to gauge the interest
    in the project. If the investors would be interested in making an investment,
    then it means that the project has merit.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 项目分析的这个阶段将决定是否继续进行。进行可行性研究的正确方法是准备一个商业计划，并向投资者展示。为什么？公司经理编写商业计划并向投资者（或公司的副总裁、总裁或首席执行官——对于内部软件项目）展示的原因是因为他们需要一份可以与投资者分享以衡量项目兴趣的文件。如果投资者有兴趣进行投资，那么这意味着该项目具有价值。
- en: 'The perfect document for this is a formal business plan because it contains
    summary information on all the important things investors would want to see, namely:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完美的文件是正式的商业计划，因为它包含了投资者想要看到的所有重要信息的摘要，即：
- en: '**Market analysis**: Is there room in the market for yet another similar product?
    What is the market potential?'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场分析：市场是否有空间容纳另一个类似产品？市场潜力是多少？
- en: '**Competitive analysis**: How is our product/service going to be different?
    Are we going to compete on cost, quality, or features?'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争分析：我们的产品/服务将如何不同？我们将在成本、质量还是功能上竞争？
- en: '**Required resources**: What personnel does the project need? And how many
    man-hours to build it and deliver it to market?'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需资源：项目需要什么人员？需要多少人时来构建并推向市场？
- en: '**Budgets**: How much money in total should be budgeted for the project (IT,
    sales, operating costs, and so on)?'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预算：项目总共需要多少资金预算（IT、销售、运营成本等）？
- en: '**Financial projections**: What revenues can be expected over the next 12 months,
    two years, three years, and five years? What is the break-even point?'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 财务预测：在接下来的12个月、两年、三年和五年内可以预期的收入是多少？何时达到盈亏平衡点？
- en: '**Exit strategies**: How long do we operate the company for? How do we get
    our investment out?'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出策略：我们要经营公司多久？如何收回我们的投资？
- en: 'You may be asking yourself if I actually prepared a detailed business plan
    for a software project that was fairly small in size. The answer—of course! Why?
    In short, I needed to see whether implenting the project was worth my time and
    money. Specifically, I spent the necessary time preparing a business plan for
    the following reasons:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我是否真的为一个规模相当小的软件项目准备了详细的商业计划。答案是——当然！为什么？简而言之，我需要看看实施该项目是否值得我的时间和金钱。具体来说，我花了必要的时间准备商业计划，原因如下：
- en: '**Market analysis**: As good as an idea may sound to you, you need to do your
    due diligence in being reasonably sure that there is a need for yet another product
    or service in the market you are entering. If there is room, then you have a potential
    opportunity. In my case, I believed that room existed for Listing Carousel and
    that it was sufficiently differentiated to give me a competitive advantage over
    the competing products in the market.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场分析：无论你觉得一个想法有多好，你都需要尽职调查，以合理确定市场对你即将进入的产品或服务是否有需求。如果有市场空间，那么你就有潜在的机会。在我的情况下，我相信Listing
    Carousel有市场空间，并且它在竞争激烈的市场中具有足够的差异化，可以给我带来竞争优势。
- en: '**Cost and time to develop**: Time and money are valuable commodities—and developing
    a software product or service will take both. Every dollar you invest in one project
    means that you can''t invest it in another. And the same is true of your time.
    Every hour you spend on doing something means you gave that time up for doing
    something else instead. So, choose where you place your resources wisely! In my
    case, I had some money earmarked for a fun project to do—so the money part was
    taken care of. How about the time? This was a difficult decision for me. While
    I did not really have the time, I liked the project and I have friends that are
    real-estate agents—and so I decided, what the hell, let''s go for it. So, I knew
    how much money I needed to invest, and roughly how much time I had to invest as
    well.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发成本和时间**：时间和金钱都是宝贵的资源——开发软件产品或服务都需要。你在一个项目上投资的每一美元意味着你不能在另一个项目上投资。你的时间也是如此。你在做某事上花费的每个小时意味着你放弃了做其他事情的时间。所以，明智地选择你投入资源的地方！在我的情况下，我有一些钱用于一个有趣的项目——所以金钱部分已经得到解决。时间呢？这对我来说是一个困难的决定。虽然我实际上没有时间，但我喜欢这个项目，我有一些朋友是房地产经纪人——所以我决定，去他妈的，让我们试试吧。所以，我知道我需要投入多少钱，大致需要投入多少时间。'
- en: '**Projected revenues**: Just because the required resources (that is, time
    and money) I had to invest were acceptable to me, it wasn''t a done deal yet.
    The next step was to make some calculations to see whether I would make a profit
    over time, and how much. If the ROI was high enough, it was a go-ahead. In my
    case, the ROI was actually not as good as I wanted it to be—in fact, it was almost
    zero! In other words, I would just break even if I was lucky. However, you also
    have to listen to your gut, and my gut was telling me that I may be able to sell
    the software service at some point, which would make the project worthwhile. At
    the time of writing, I have not yet sold Listing Carousel, but it did start to
    make a little bit of a profit.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预期收入**：仅仅因为我要投入的必要资源（即时间和金钱）对我来说是可以接受的，并不意味着一切已成定局。下一步是进行一些计算，看看我是否会随着时间获利，以及能赚多少。如果投资回报率足够高，那就可以继续进行。在我的情况下，投资回报率实际上并不如我希望的那么好，事实上几乎为零！换句话说，我可能只能勉强保本。然而，你也必须听从直觉，而我的直觉告诉我，也许我最终能够出售软件服务，这将使项目变得有价值。在撰写本文时，我尚未出售Listing
    Carousel，但它开始有了一点点利润。'
- en: '**Exit strategy**: Before you embark on building any business—and I treated
    Listing Carousel as a standalone business—you have to think of an exit strategy.
    What is an exit strategy? It basically defines how you will divorce yourself of
    your obligations of operating and/or servicing the company. Companies don''t run
    themselves, and so unless you want to stay married to the company forever, you
    need to have an exit strategy from the start. I can''t take more space in this
    book to outline this in detail, but suffice it to say, I structured the company
    in such a way where my exit strategy was baked in.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出策略**：在着手建立任何业务之前——我把Listing Carousel视为一个独立的业务——你必须考虑一个退出策略。什么是退出策略？它基本上定义了你如何摆脱经营和/或服务公司的义务。公司不会自己运行，所以除非你想永远与公司结婚，你需要从一开始就有一个退出策略。我无法在这本书中再多花时间详细阐述这一点，但可以说的是，我构建了公司的结构，使我的退出策略早已考虑在内。'
- en: Requirement gathering
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**需求收集**'
- en: This stage of the software project forms the basis of your project plan, which
    is what a project manager uses to keep the project on schedule and on budget.
    Requirements are typically gathered from the end client (internal or external),
    but can also come from an idea board if you are building something new that does
    not yet exist in the market.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目的这个阶段构成了项目计划的基础，项目经理使用该计划来确保项目按计划和预算进行。需求通常是从最终客户（内部或外部）那里收集的，但如果您正在构建市场上尚不存在的新产品，需求也可以来自想法板。
- en: 'For instance, for Listing Carousel, I picked the brains of a few real-estate
    agent friends, telling them what I wanted to build, and how I wanted to make it
    different from what they were already using. Here is a partial list of what we
    came up with as requirements:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于列表走马灯，我向一些房地产经纪朋友请教，告诉他们我想要构建什么，以及我想要使它与他们已经在使用的东西不同。以下是我们提出的部分需求清单：
- en: The ability to create a carousel-style photo viewer (one per listing/property,
    with any number of photos in it)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建走马灯式照片查看器（每个列表/属性一个，其中可以包含任意数量的照片）
- en: The ability for the user to upload photos
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有能力上传照片
- en: The ability to annotate each photo (that is, a caption at the bottom of the
    photo)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为每张照片做注释（即，在照片底部添加说明）
- en: The ability to flip the photo around to show a detailed description of what
    is shown on the photo
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够翻转照片，显示照片上所示内容的详细描述
- en: The ability for the user to link a photo to a carousel
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有能力将照片链接到走马灯
- en: The ability for the user to order/re-order the photos within a carousel
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有能力在走马灯中订购/重新订购照片
- en: The ability for the user to post the carousel of the listing on Facebook
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有能力在Facebook上发布列表的走马灯
- en: The ability for the user to post the carousel of the listing on Instagram
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有能力在Instagram上发布列表的走马灯
- en: The ability to have a magic link manually placed on any website that the user
    has access to, which opens the listing's carousel in a modal lighthouse in place
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户有能力在他们可以访问的任何网站上手动放置一个魔术链接，以在模态灯塔中打开列表的走马灯
- en: The ability to have a soundtrack play while the listing's carousel auto-scrolls
    through the photos in it
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的走马灯自动滚动显示照片时播放背景音乐的能力
- en: Each carousel will have a unique short permalink assigned to it so that the
    user can email or text it to whomever they like
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个走马灯都将被分配一个唯一的短链接，以便用户可以通过电子邮件或短信发送给任何他们喜欢的人
- en: We won't build all these features into our example application because there
    just isn't the space in the book to do so—but we will build the important ones.
    The two features that we'll omit are the magic link and the playing of the music
    soundtrack. I won't make any promises, but I may create a blog post on how to
    build the magic link on my blog, *AngularMotion.io, *in the near future.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将所有这些功能都构建到我们的示例应用程序中，因为书中没有足够的空间来这样做，但我们将构建重要的功能。我们将省略的两个功能是魔术链接和播放音乐背景音轨。我不会做任何承诺，但我可能会在不久的将来在我的博客*AngularMotion.io*上发布有关如何构建魔术链接的博文。
- en: Wireframes
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线框图
- en: This stage of the process is where the look and feel of the application are
    planned and laid out.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段是规划和布局应用程序的外观和感觉的阶段。
- en: 'The following are the 12 wireframes for the pages we''ll be building (note:
    a couple of the wireframes were too long to have as one screenshot, such as for
    the Welcome page, and so there is more than one screenshot for them).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要构建的页面的12个线框图（注意：有几个线框图太长，无法作为一个屏幕截图，比如欢迎页面，因此它们有多个屏幕截图）。
- en: We will be implementing some of these wireframes in the following sections,
    and we will learn to implement some of the layouts and components in chapters
    to follow.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中实施其中一些线框图，并学习如何实施一些布局和组件。
- en: Implementation
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: This is where the rubber hits the road. We're going to code up some of our web
    pages using the wireframes we just reviewed to help guide us. We're also going
    to need a web server so we can serve up our new pages in our browser as we build
    them out.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关键所在。我们将使用刚刚审查过的线框图编写一些网页代码，以帮助我们进行指导。我们还需要一个网络服务器，这样我们就可以在构建页面时在浏览器中提供我们的新页面。
- en: Installing our interim web server
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装我们的临时网络服务器
- en: We'll be using Node's built-in web server for our project from [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services,* onward. But, since we've got a little while to go before
    we get to that point, we need to have a simple interim solution.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中使用Node的内置网络服务器，*集成后端数据服务*。但是，由于在达到那一点之前我们还有一段时间，我们需要一个简单的临时解决方案。
- en: We've not spoken about browsers before because there wasn't a need to do so—but
    now, there's a need. While it doesn't matter which browser you use for viewing
    Angular applications, it would be easier—though not essential — for us to use
    the same browser while we work through this book together. My browser of choice,
    while I develop web applications, is Chrome. As with most browsers, Chrome has
    a ton of extensions that other developers have created that do everything from
    providing subscription notifications to debugging tools and more. You can download
    Chrome for the operating system of your choice from here: [https://www.google.com/chrome/](https://www.google.com/chrome/).
    You can search for and install extensions for Chrome from the Chrome Web Store
    at [https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions). We'll
    be using Chrome, and specifically, a few of its extensions, for a few things in
    this book.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前没有讨论过浏览器，因为没有必要这样做，但现在有必要了。虽然使用哪种浏览器查看Angular应用程序并不重要，但在我们一起阅读本书时，使用相同的浏览器会更容易，尽管不是必需的。我在开发Web应用程序时首选的浏览器是Chrome。与大多数浏览器一样，Chrome有许多其他开发人员创建的扩展，可以提供从订阅通知到调试工具等各种功能。您可以从这里下载适合您选择操作系统的Chrome：[https://www.google.com/chrome/](https://www.google.com/chrome/)。您可以在Chrome
    Web Store中搜索并安装Chrome的扩展：[https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions)。在本书中，我们将使用Chrome，特别是它的一些扩展，来完成一些任务。
- en: The first order of business is to install a Chrome extension that will help
    us serve up the pages we build for our application. It's called, *Web Server for
    Chrome* and you can search for it and install it from the Chrome Web Store. I
    didn't include the link to it directly because the URL was incredibly long.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是安装一个Chrome扩展，它将帮助我们为我们的应用程序构建页面。它被称为*Web Server for Chrome*，您可以在Chrome
    Web Store中搜索并安装它。我没有直接包含链接，因为URL非常长。
- en: This extension allows you to select a folder for where the files you wish to
    be served are located, as well as a port to listen on. There are other options
    that you can select as well. One common case option that is enabled by default
    is to have the extension automatically show the `index.html` file. For example,
    assuming you enter `8887` for the port number, you would point your browser to
    `http://127.0.0.1:8887` and would see that your `index.html` page in the folder
    you specify would automatically be served up in your browser. Once you have these
    two settings configured, you're off to the races and can view the pages we create.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展允许您选择文件所在的文件夹以及要监听的端口。您还可以选择其他选项。默认情况下启用的一个常见选项是自动显示`index.html`文件。例如，假设您为端口号输入`8887`，您将指向`http://127.0.0.1:8887`，并且您指定的文件夹中的`index.html`页面将自动在浏览器中提供。一旦您配置了这两个设置，您就可以查看我们创建的页面。
- en: Welcome page
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎页面
- en: The first wireframe we will implement using the Bootstrap components and grid
    layout is the Welcome home page.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Bootstrap组件和网格布局来实现的第一个线框是欢迎首页。
- en: 'Take a look at the following wireframe screenshot. We have a header section
    that contains our application logo placeholder, navigation menu, and Login and
    Try Now buttons on the right. This is followed by a jumbotron header that showcases
    the title of the application. Then, our content sections are divided so that we
    can add our content to the page:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的线框截图。我们有一个包含应用程序logo占位符、导航菜单以及右侧的登录和立即尝试按钮的页眉部分。然后是一个展示应用程序标题的巨幕页眉。接下来，我们的内容部分被划分，以便我们可以将内容添加到页面上：
- en: '![](assets/3b8dbb53-1641-4561-84be-84a0a6588cc9.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b8dbb53-1641-4561-84be-84a0a6588cc9.png)'
- en: 'We will now proceed to implement our code implementation of the preceding wireframe
    screenshot. We are first going to implement the header section, and we will use
    the `<nav>` tag to categorize all of our header section code, including the logo,
    menu, and action buttons:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续实现上述线框截图的代码实现。我们首先将实现页眉部分，并使用`<nav>`标签来对所有页眉部分的代码进行分类，包括logo、菜单和操作按钮：
- en: '[PRE37]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we are implementing a `nav` tag element and using the
    Bootstrap navbar classes, `navbar-default`, `navbar-fixed-top`, `navbar-brand`,
    `navbar-collapse`, and so on. These classes come with default functionality that
    covers almost all aspects of a navigation section. One of the interesting things
    to note in the preceding code is the `navbar-collapse` class, which helps in rendering
    various device screen resolutions automatically. We have also added a few menu
    links for features, pricing, and about. We have also added our action items, Login
    and Try Now.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们正在实现一个`nav`标签元素，并使用Bootstrap导航栏类，`navbar-default`，`navbar-fixed-top`，`navbar-brand`，`navbar-collapse`等。这些类具有默认功能，几乎涵盖了导航部分的所有方面。在上面的代码中值得注意的一点是`navbar-collapse`类，它有助于自动呈现各种设备屏幕分辨率。我们还添加了一些菜单链接，如功能、定价和关于。我们还添加了我们的操作项目，登录和立即尝试。
- en: 'Launch the page in the browser and we should see the output, as shown in the
    following screenshot:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中启动页面，我们应该看到如下截图所示的输出：
- en: '![](assets/a1caaa12-0c6c-4e0d-94ee-7e0151a8acd0.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1caaa12-0c6c-4e0d-94ee-7e0151a8acd0.png)'
- en: 'Next, we have to make our layouts for the content sections. The jumbotron and
    content sections. We will use the `jumbotron` class with a `div` section and,
    for the content sections, the Bootstrap grid column classes, `row`, `col-sm-8`,
    and `col-sm-4`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为内容部分制作布局。巨幕和内容部分。我们将使用`jumbotron`类与`div`部分，对于内容部分，我们将使用Bootstrap网格列类，`row`，`col-sm-8`和`col-sm-4`：
- en: '[PRE38]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s analyze the preceding code to understand some of the important
    points. We are making use of the awesome Bootstrap grid utilities to create our
    application layout, using the column classes to create the layout, which will
    render on various screen resolutions. Run the application in the browser and we
    should see the output as shown in the following screenshot:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析上面的代码，以了解一些重要的要点。我们正在利用强大的Bootstrap网格工具来创建我们的应用程序布局，使用列类来创建在各种屏幕分辨率上呈现的布局。在浏览器中运行应用程序，我们应该能看到如下截图所示的输出：
- en: '![](assets/151afb29-603e-4200-8204-4132136db743.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/151afb29-603e-4200-8204-4132136db743.png)'
- en: Nice work, fellas, so far. We have just created our first Welcome page layout
    using the Bootstrap layout components. We will continue to use the same and build
    some more wireframes to make you comfortable. In the next section, we will learn
    to create signup and login screens using the Bootstrap modal component.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，干得不错，伙计们。我们刚刚使用Bootstrap布局组件创建了我们的第一个欢迎页面布局。我们将继续使用相同的组件，并构建更多的线框，以使您感到舒适。在下一节中，我们将学习如何使用Bootstrap模态组件创建注册和登录界面。
- en: Signup
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册
- en: Next up, we will implement our signup and login pages using Bootstrap's awesome
    modal component.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Bootstrap的模态组件来实现我们的注册和登录页面。
- en: 'Take a look at the following wireframe. It''s a simple modal window with some
    form field input elements:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下面的线框。这是一个简单的模态窗口，带有一些表单字段输入元素：
- en: '![](assets/b30a1548-dbf1-458d-ae51-e04661c3810f.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b30a1548-dbf1-458d-ae51-e04661c3810f.png)'
- en: 'Let''s go ahead and implement the code. The following is the sample code for
    creating the modal window:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现代码。以下是创建模态窗口的示例代码：
- en: '[PRE39]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, we have used Bootstrap''s modal component and modal
    classes modal and modal-dialog. Inside the modal dialog content, we have created
    our signup form with the input form elements—first name, last name, brokerage,
    user, and pass. Launch the page in the browser and we should see the output, as
    shown in the following screenshot:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用了Bootstrap的模态组件和模态类modal和modal-dialog。在模态对话框内容中，我们使用输入表单元素——名字、姓氏、经纪人、用户和密码创建了注册表单。在浏览器中启动页面，我们应该能看到如下截图所示的输出：
- en: '![](assets/ab5b6c84-f6db-4922-a26c-5aac47d00937.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab5b6c84-f6db-4922-a26c-5aac47d00937.png)'
- en: That's a great start to building our application. In the next section, we will
    build our login page using the same Bootstrap modal component.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建我们应用程序的一个很好的开端。在下一节中，我们将使用相同的Bootstrap模态组件来构建我们的登录页面。
- en: Login
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录
- en: In the previous section, we have learned about creating the signup form inside
    a modal window. In this section, we will learn about creating a login screen inside
    the modal window. The methodology and principle are exactly the same as how we
    created the signup page.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经学习了如何在模态窗口内创建注册表单。在本节中，我们将学习如何在模态窗口内创建登录界面。方法和原则与我们创建注册页面的方式完全相同。
- en: 'Take a look at the following login wireframe, which we are going to implement
    in just a bit:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下面的登录线框，我们马上就要实现它：
- en: '![](assets/e3ffa4f9-84c6-42c5-b190-aefa7fad371e.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3ffa4f9-84c6-42c5-b190-aefa7fad371e.png)'
- en: 'Time for some action. We are going to create a modal window first and we can
    bind a click event to open the dialog window:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候行动起来了。我们将首先创建一个模态窗口，然后可以绑定一个点击事件来打开对话框窗口：
- en: '[PRE40]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we have implemented a modal window with yet another
    form, this time for a login feature with a number of form elements—a username
    and password with a submit button. Launch the page in the browser and we should
    see the following output:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们实现了一个带有另一个表单的模态窗口，这次是用于登录功能，包括一些表单元素——用户名和密码以及一个提交按钮。在浏览器中启动页面，我们应该能看到以下输出：
- en: '![](assets/36f91418-ece6-4d7a-82de-4638980d0afd.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36f91418-ece6-4d7a-82de-4638980d0afd.png)'
- en: Our application is almost taking shape now. I am sure you are as excited as
    I am. Let's go ahead and implement the listings page.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在几乎成形了。我相信你和我一样兴奋。让我们继续实现列表页面。
- en: Listings
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'In previous sections, we have created our home page, signup, and login pages
    using the Bootstrap components. In this section, we will create our listings page.
    Take a look at the following wireframe. We have to loop through our listings and
    display a grid section, where we will display all the listings we have so far.
    Simple enough? You bet:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用Bootstrap组件创建了我们的主页、注册和登录页面。在本节中，我们将创建我们的列表页面。看一下以下线框图。我们需要循环遍历我们的列表，并显示一个网格部分，在那里我们将显示到目前为止所有的列表。简单吗？当然：
- en: '![](assets/eb4e8f31-a686-4c64-8049-36c5bb68c327.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eb4e8f31-a686-4c64-8049-36c5bb68c327.png)'
- en: 'We will need to use Bootstrap''s advanced layout and grid components to create
    the preceding layout. Take a look at the following sample code. We can achieve
    the preceding layout in multiple ways. We can either use the Bootstrap grid columns
    to design the layout or, alternatively, we can make use of table elements to design
    the structure. In this example, I will show you how to do it using the table elements
    and I will leave the grid structure to you as homework:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用Bootstrap的高级布局和网格组件来创建上述布局。看一下以下示例代码。我们可以以多种方式实现上述布局。我们可以使用Bootstrap网格列来设计布局，或者我们可以使用表格元素来设计结构。在这个例子中，我将向您展示如何使用表格元素来做到这一点，网格结构留给您作业：
- en: '[PRE41]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code, we have created a container using the `container-fluid`
    class and, inside the container, we have created a table and rows structure to
    display our listings. In a more practical scenario, the data will always come
    from the backend APIs or services. For our example, and for learning purposes,
    we have stubbed the data here. Launch the page in the browser and we should see
    the output as shown in the following screenshot:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用`container-fluid`类创建了一个容器，在容器内部，我们创建了一个表格和行结构来显示我们的列表。在更实际的情况下，数据将始终来自后端API或服务。对于我们的示例和学习目的，我们在这里存根化了数据。在浏览器中启动页面，我们应该看到如下截图所示的输出：
- en: '![](assets/91f2114f-1fee-41c7-ac65-24ffb176a614.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91f2114f-1fee-41c7-ac65-24ffb176a614.png)'
- en: If you see the output as shown in the preceding screenshot, give yourself a
    pat on the back. We have made great progress in our learning. So far, we have
    created four pages using various different Bootstrap components and grid layouts.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到前面截图中显示的输出，请给自己一个鼓励。我们在学习中取得了很大的进步。到目前为止，我们已经使用各种不同的Bootstrap组件和网格布局创建了四个页面。
- en: In the next section, we will explore some of the other wireframes for the application,
    which I will leave it for you to practice. Most of the wireframes will use the
    same components, layouts, and grid layouts.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索应用程序的一些其他线框图，我会留给你练习。大多数线框图将使用相同的组件、布局和网格布局。
- en: Create listing
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建列表
- en: 'In this section, I am sharing with you the wireframe for the **Create Listing**
    page. The Create Listing page can be easily created using the Bootstrap components
    and layout. Instead, we will learn to implement this using Flex-layout in the
    next chapter. The following is the wireframe for your reference:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将与您分享**创建列表**页面的线框图。可以使用Bootstrap组件和布局轻松创建创建列表页面。相反，我们将在下一章中学习如何使用Flex-layout来实现这一点。以下是您参考的线框图：
- en: '![](assets/3fad0b31-b358-46f4-ac6f-87b2810d5cec.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3fad0b31-b358-46f4-ac6f-87b2810d5cec.png)'
- en: In the next section, we will see the design and wireframe details of the **Edit
    Listing** page.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到**编辑列表**页面的设计和线框图细节。
- en: Edit listing
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑列表
- en: In this section, we will learn about the design and wireframes for the **Edit
    Listing** screen. If you look carefully, the **Edit Listing** page is similar
    to the **Create Listing** page, except, the data is populated on load.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习**编辑列表**屏幕的设计和线框图。如果您仔细观察，**编辑列表**页面与**创建列表**页面类似，只是数据在加载时被填充。
- en: Again, like the **Cre****ate Listing** screen, we will design the **Edit Listing**
    page using Flex-layout in the next chapter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 与**创建列表**屏幕一样，我们将在下一章中使用Flex-layout设计**编辑列表**页面。
- en: '![](assets/88211f05-0260-4f98-babc-3d926dbd0f4b.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88211f05-0260-4f98-babc-3d926dbd0f4b.png)'
- en: Wireframes collection
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线框图集合
- en: In this section, we will see the design wireframes for other pages, which we
    will create in chapters to come.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到其他页面的设计线框图，这些页面将在接下来的章节中创建。
- en: 'The following is the design wireframe for the **Listing Preview** page:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**列表预览**页面的设计线框图：
- en: '![](assets/6bbb42b9-7b02-44c7-b50e-1eb95824119f.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bbb42b9-7b02-44c7-b50e-1eb95824119f.png)'
- en: 'The following is the design wireframe for the property details. If you notice,
    we are going to use the same Bootstrap''s modal window component. When we open
    the modal window, we should see the property details:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是物业详情的设计线框图。如果您注意到，我们将使用相同的Bootstrap模态窗口组件。当我们打开模态窗口时，我们应该看到物业详情：
- en: '![](assets/5dc78645-6b9d-4855-b4c9-16c9e8f97c39.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5dc78645-6b9d-4855-b4c9-16c9e8f97c39.png)'
- en: 'Now, we will learn how to design the wireframe for the **Photos** page. If
    you look carefully, the layout structure looks familiar to the **Listings** page.
    We will have to create a reusable design using the common libraries, which can
    be reused across various pages and templates:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何为**照片**页面设计线框图。如果您仔细观察，布局结构看起来与**列表**页面相似。我们将不得不使用常见库创建可重用的设计，这些设计可以在各种页面和模板中重复使用：
- en: '![](assets/0d1c9343-7c17-4fb7-b0cb-1e03a3e9d6c6.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0d1c9343-7c17-4fb7-b0cb-1e03a3e9d6c6.png)'
- en: 'Next up is the **Upload Photo** page. We will again have to create a modal
    window component and provide a file upload option through which we can upload
    photos easily:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**上传照片**页面。我们将再次创建一个模态窗口组件，并通过它提供文件上传选项，以便我们可以轻松上传照片：
- en: '![](assets/75b135a2-459c-4949-b173-8cc9d27e150b.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75b135a2-459c-4949-b173-8cc9d27e150b.png)'
- en: 'Now, let''s move on to the **Edit Photo** wireframe. Yet again, we are making
    use of Bootstrap''s modal window component to design our **Edit Photo** page.
    We will use Angular''s data binding to bind the data in the modal window:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续**编辑照片**线框图。我们再次利用Bootstrap的模态窗口组件来设计我们的**编辑照片**页面。我们将使用Angular的数据绑定来绑定模态窗口中的数据：
- en: '![](assets/60c0a802-b564-4754-8ccf-18230392c61e.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60c0a802-b564-4754-8ccf-18230392c61e.png)'
- en: 'Last, but not least, we will explore the **Photo Preview** page. We can display
    the photos using the modal window Bootstrap component. We will close the common
    action buttons to close or edit the modal windows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探索**照片预览**页面。我们可以使用模态窗口Bootstrap组件显示照片。我们将关闭常见的操作按钮以关闭或编辑模态窗口：
- en: '![](assets/25228d46-9c71-4e17-b473-b0bf193d8420.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/25228d46-9c71-4e17-b473-b0bf193d8420.png)'
- en: That was quite a bit of work we have done in this chapter, as we learned about
    the Bootstrap grid and layout components. We have created a few pages as part
    of our hands-on learning examples and designed our wireframes that we will use
    in our application.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了相当多的工作，学习了Bootstrap网格和布局组件。作为实际学习示例的一部分，我们创建了一些页面并设计了我们将在应用程序中使用的线框图。
- en: Summary
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was packed with all kinds of goodies. You should now understand
    the example application that we'll be building, the high-level game plan for the
    phases of our build, and the five-step process we're going to take for the first
    phase of our build.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章充满了各种好东西。你现在应该了解我们将要构建的示例应用程序，我们构建阶段的高层游戏计划，以及我们将采取的第一阶段构建的五个步骤过程。
- en: We then moved on to what Sass is, and a few of its features that help us with
    creating our CSS for the application. We will study the tools to help you when
    you're writing the Sass for your applications. Next, we saw what Bootstrap is
    and how to integrate it into your applications. We studied what Bootstrap's grid
    is, and the basics for how to use it, along with some of Bootstrap's components
    and how to use them.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了Sass是什么，以及它的一些功能如何帮助我们创建应用程序的CSS。我们将研究一些工具，帮助你在编写应用程序的Sass时。接下来，我们了解了Bootstrap是什么，以及如何将其集成到你的应用程序中。我们学习了Bootstrap的网格是什么，以及如何使用它的基础知识，以及一些Bootstrap的组件以及如何使用它们。
- en: Lastly, we studied the evolution of software projects, from inception to implementation.
    Here, we covered the different types of analysis, the gathering of the requirements
    and some use cases. We also covered wireframes, went into detail on the goal of
    each wireframe, and the basic design principles (that were mentioned during the
    description of the wireframes).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了软件项目的演变，从构思到实施。在这里，我们涵盖了不同类型的分析，需求的收集以及一些用例。我们还涵盖了线框图，详细介绍了每个线框图的目标，以及基本的设计原则（在描述线框图时提到）。
- en: So far in the book, with the exception of the quick to-do app we've built in
    [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start*, we have
    not even touched Angular. This will change—starting with the next chapter, [Chapter
    4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml), *Routing*. In this chapter, we
    will create the Angular shell for our application using the CLI (as we did at
    the beginning of the book). However, we're going to be adding routing to it. I'll
    explain what routing is, and how to configure routing for our application as we
    work through it.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，除了我们在[第一章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)中构建的快速待办事项应用程序外，我们甚至还没有接触过Angular。这将会改变——从下一章开始，[第四章](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml)，*路由*。在这一章中，我们将使用CLI创建应用程序的Angular外壳（就像我们在书的开头所做的那样）。但是，我们将为其添加路由。我将在我们逐步进行的过程中解释什么是路由，以及如何为我们的应用程序配置路由。
- en: So, before you turn the page, pat yourself on the back, stretch a little, and
    maybe pour yourself another glass of your favorite beverage. Well done, my fellow
    budding Angular gurus. With these first three chapters behind you, you are now
    ready to meet Angular!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在你翻页之前，给自己一个鼓励，伸展一下，也许倒一杯你最喜欢的饮料。干得好，我的Angular初学者同伴们。通过了这前三章，你现在已经准备好迎接Angular了！
