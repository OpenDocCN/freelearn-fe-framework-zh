- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Building PWAs with Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 构建 PWA
- en: '**Progressive Web Apps** (**PWAs**) are far more than just web applications;
    they’re the next evolution in web technology. Combining the best of web and mobile
    applications, PWAs provide an unparalleled user experience, even in less-than-ideal
    network conditions. But what makes them truly compelling is their graceful degradation
    — while they harness the full power of modern browsers, they also ensure a seamless,
    core experience in older browsers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**渐进式 Web 应用**（**PWAs**）远不止是 Web 应用；它们是 Web 技术的下一进化阶段。结合了 Web 和移动应用的最佳特性，PWAs
    在不理想的网络条件下也能提供无与伦比的用户体验。但真正让它们引人入胜的是它们的优雅降级——虽然它们利用了现代浏览器的全部功能，同时也确保在旧浏览器中提供无缝的核心体验。'
- en: 'In this chapter, we dive deep into the world of PWAs through the lens of Angular.
    Angular has built-in PWA support that makes it an ideal candidate for crafting
    resilient and performant web applications. You’ll learn how to make your apps
    installable, capable, fast, and reliable building them as progressive web apps.
    The following are the recipes we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过 Angular 的视角深入探索 PWA 的世界。Angular 内置了 PWA 支持，使其成为构建健壮和性能卓越的 Web 应用的理想选择。你将学习如何将你的应用构建为可安装、功能强大、快速且可靠的渐进式
    Web 应用。以下是本章将要涵盖的食谱：
- en: Converting an existing Angular app into a PWA with the Angular CLI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 将现有的 Angular 应用转换为 PWA
- en: Modifying the theme color for your PWA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改你的 PWA 的主题颜色
- en: Using dark mode in your PWA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 PWA 中使用暗黑模式
- en: Providing a custom installable experience in your PWA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 PWA 中提供定制的可安装体验
- en: Precaching requests using an Angular service worker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 服务工作者进行预缓存请求
- en: Creating an app shell for your PWA
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的 PWA 创建一个应用外壳
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter13](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter13).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保你的设置符合 'Angular-Cookbook-2E' GitHub 仓库中的 'Technical Requirements'。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter13](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter13)。
- en: Converting an existing Angular app into a PWA with the Angular CLI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 将现有的 Angular 应用转换为 PWA
- en: A **PWA** comprises several intriguing components, with two standout features
    being the service worker and the web manifest file. The service worker plays a
    vital role in caching static resources and handling caching requests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**PWA** 包含几个引人入胜的组件，其中两个突出的特性是服务工作者和 Web 清单文件。服务工作者在缓存静态资源和处理缓存请求中扮演着至关重要的角色。'
- en: Meanwhile, the web manifest file holds essential information such as app icons
    and the app’s theme color. In this guide, we’ll transform an existing Angular
    application into a PWA. These principles are also applicable if you were to start
    a new Angular app from scratch. Throughout this walkthrough, we’ll convert an
    existing Angular app, highlighting the changes made and showcasing the transformation
    process using the `@angular/pwa` package. This package not only enables PWA functionality
    but also facilitates effective static resource caching.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Web 清单文件包含诸如应用图标和应用的主体颜色等关键信息。在本指南中，我们将把现有的 Angular 应用转换为 PWA。如果你从头开始创建一个新的
    Angular 应用，这些原则同样适用。在整个演练过程中，我们将转换一个现有的 Angular 应用，突出显示所做的更改，并使用 `@angular/pwa`
    包展示转换过程。这个包不仅使 PWA 功能化，还促进了静态资源的有效缓存。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter13/ng-pwa-conversion`
    inside the cloned repository. This is not part of our NX workspace and is rather
    a **standalone Angular** app with its own `package.json`, `node_modules`, etc.
    Perform the following steps to get started:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter13/ng-pwa-conversion` 目录下。这不是我们 NX 工作空间的一部分，而是一个独立的
    **Angular** 应用，拥有自己的 `package.json`、`node_modules` 等。按照以下步骤开始：
- en: Open the code repository in your code editor.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: Open the terminal and navigate to the cloned code repository folder.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到克隆的代码仓库文件夹。
- en: 'Navigate to `start/apps/chapter13/ng-pwa-conversion` and run the following
    commands to serve the project:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`start/apps/chapter13/ng-pwa-conversion`并运行以下命令以提供项目服务：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open a new tab in the browser and navigate to `http://localhost:8080`. You
    should see the following:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器中打开一个新标签页，并导航到`http://localhost:8080`。你应该能看到以下内容：
- en: '![](img/B18469_13_01.png)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_01.png)'
- en: 'Figure 13.1: ng-pwa-conversion app running on http://localhost:8080'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.1：ng-pwa-conversion应用在http://localhost:8080上运行
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，接下来让我们看看下一节中食谱的步骤。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The app we’re working with is a game built using the Angular CDK in *Chapter
    9*, *Angular and the Angular CDK*. You can enter your name, then guess the dice’s
    next value, and get a score leaderboard. The value of the leaderboard is persisted
    using the local storage. But the app is not a PWA yet. Let’s convert it into a
    PWA:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的应用是使用*第9章*中提到的Angular CDK构建的游戏，即*Angular和Angular CDK*。你可以输入你的名字，然后猜测骰子的下一个值，并获得分数排行榜。排行榜的值是通过本地存储持久化的。但是，该应用还不是PWA。让我们将其转换为PWA：
- en: First, let’s see if our application works offline at all, because that is one
    of the traits of PWAs. Open **Chrome Dev Tools** for the app. Go to the **Network**
    tab and change **Throttling** to **Offline**, as follows:![](img/B18469_13_02.png)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们的应用是否完全支持离线工作，因为这是PWA的一个特性。打开应用的**Chrome开发者工具**。转到**网络**选项卡，并将**限制**改为**离线**，如下所示：![](img/B18469_13_02.png)
- en: 'Figure 13.2: Changing network throttling to Offline to see the offline experience'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.2：将网络限制改为离线以查看离线体验
- en: Make sure that the **Disable cache** option is ticked too.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保勾选了**禁用缓存**选项。
- en: Now stop the `http` server by exiting the process from your terminal. Once done,
    refresh the app’s page. You should see that the app doesn’t work anymore, as shown
    in the following figure:![](img/B18469_13_03.png)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过从终端退出进程来停止`http`服务器。完成后，刷新应用的页面。你应该能看到应用不再工作，如图所示：![](img/B18469_13_03.png)
- en: 'Figure 13.3: App not working offline'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.3：离线时应用无法工作
- en: 'To convert this app into a PWA, open a new terminal window/tab and make sure
    you’re inside the `start/apps/chapter13/ng-pwa-conversion` folder. Once inside,
    run the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此应用转换为PWA，打开一个新的终端窗口/标签页，并确保你位于`start/apps/chapter13/ng-pwa-conversion`文件夹内。一旦进入，运行以下命令：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should see a bunch of files created and updated as the process from the
    command finishes.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在命令行进程结束的过程中，你应该会看到创建和更新了一大批文件。
- en: Now build and serve the app again by running `npm run build && npx http-server
    dist/ng-pwa-conversion`. Once done, navigate to `http://localhost:8080`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行`npm run build && npx http-server dist/ng-pwa-conversion`再次构建并提供服务应用。完成后，导航到`http://localhost:8080`。
- en: Now make sure you have turned off throttling by switching to the **Network**
    tab and setting **No throttling** as the selection option, as shown in *Figure
    13.4*. Also, notice that the **Disable cache** option is turned off:![Figure 13.4
    – Turning off network throttling ](img/B18469_13_04.png)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，确保你已经关闭了限制，通过切换到**网络**选项卡并将选择设置为**无限制**，如图*图13.4*所示。同时，注意**禁用缓存**选项已被关闭：![图13.4
    – 关闭网络限制](img/B18469_13_04.png)
- en: 'Figure 13.4: Turning off network throttling'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.4：关闭网络限制
- en: Now refresh the app once. You should see the app working and the network logs
    showing that assets such as JavaScript files were loaded from the server, as shown
    in *Figure 13.5*:![](img/B18469_13_05.png)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在刷新一次应用。你应该能看到应用正在运行，并且网络日志显示从服务器加载了诸如JavaScript文件等资源，如图*图13.5*所示：![](img/B18469_13_05.png)
- en: 'Figure 13.5: Assets downloaded from the source (Angular server)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.5：从源（Angular服务器）下载的资源
- en: Now, refresh the app once again and you’ll see that the same assets are now
    downloaded from the cache using the service worker, as shown in *Figure 13.6*:![](img/B18469_13_06.png)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次刷新应用一次，你会看到相同的资源现在是通过服务工作者从缓存中下载的，如图*图13.6*所示：![](img/B18469_13_06.png)
- en: 'Figure 13.6: Assets downloaded from the cache using the service worker'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.6：使用服务工作者从缓存中下载的资源
- en: Now is the moment we’ve been waiting for. Change the network throttling back
    to **Offline** to go into the **Offline** mode and refresh the app. You should
    still see the app working in **Offline** mode because of the service worker, as
    shown in *Figure 13.7*:![](img/B18469_13_07.png)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是我们一直等待的时刻。将网络限制改为**离线**以进入**离线**模式并刷新应用程序。你应该仍然看到应用程序在**离线**模式下工作，这是由于服务工作者，如图*图13.7*所示：![图片](img/B18469_13_07.png)
- en: 'Figure 13.7: Angular app working offline as a PWA using a service worker'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.7：使用服务工作者作为PWA的离线运行的Angular应用程序
- en: Now you can install this PWA on your machine. Since I’m using a MacBook, it
    is installed as a Mac app. If you’re using Chrome, the installation option should
    be around the address bar, as shown in *Figure 13.8*:![](img/B18469_13_08.png)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以将这个PWA安装到你的机器上。由于我使用的是MacBook，它被安装为Mac应用程序。如果你使用Chrome，安装选项应该在地址栏附近，如图*图13.8*所示：![图片](img/B18469_13_08.png)
- en: 'Figure 13.8: Installing the Angular PWA from Chrome'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.8：从Chrome安装Angular PWA
- en: 'Kaboom! Just by using the `@angular/pwa` package, with zero configuration done
    ourselves, we converted our existing Angular app into a PWA. We are now able to
    run our application offline, and we can install it as a PWA on our devices. See
    *Figure 13.9* to see how the app looks—just like a native app on Mac OS X:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！仅仅通过使用`@angular/pwa`包，我们无需自己进行任何配置，就将现有的 Angular 应用程序转换成了 PWA。现在我们能够离线运行我们的应用程序，并且可以在我们的设备上将其安装为
    PWA。见图*图13.9*来查看应用程序的外观——就像 Mac OS X 上的原生应用程序一样：
- en: '![](img/B18469_13_09.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_13_09.png)'
- en: 'Figure 13.9: How our Angular PWA looks as a native app on Mac OS X'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：我们的Angular PWA作为Mac OS X上的原生应用程序的外观
- en: Cool, *right?* Now that you know how to build a PWA with the Angular CLI, see
    the next section to understand how it works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，*对吧？* 现在你已经知道了如何使用Angular CLI构建PWA，请查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Angular core team and the community have done an amazing job with the `@angular/pwa`
    package and, in general, with the `ng add` command, which allows us to add different
    packages to our applications using Angular schematics. In this recipe, when we
    run `ng add @angular/pwa`, it uses schematics to generate the app icons along
    with the web app manifest. If you look at the changed files, you can see the new
    files, as shown in *Figure 13.10*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 核心团队和社区在`@angular/pwa`包以及通常的`ng add`命令方面做了惊人的工作，该命令允许我们使用 Angular 模板添加不同的包到我们的应用程序中。在这个配方中，当我们运行`ng
    add @angular/pwa`时，它使用模板生成应用程序图标以及网络应用程序清单。如果你查看更改的文件，你可以看到新文件，如图*图13.10*所示：
- en: '![](img/B18469_13_10.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_13_10.png)'
- en: 'Figure 13.10: Web manifest file and the app icon files'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：网络清单文件和应用程序图标文件
- en: The `manifest.webmanifest` file is a file that contains a JSON object. This
    object defines the manifest for the PWA and contains some information. The information
    includes the name of the app, the short name, the theme color, and the configuration
    for different icons, for different devices. Imagine this PWA is installed on your
    Android phone. You need an icon in your home drawer to tap on to open the app.
    This file holds the information regarding which icon to use based on different
    device sizes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`manifest.webmanifest`文件是一个包含JSON对象的文件。该对象定义了PWA的清单并包含一些信息。信息包括应用程序的名称、简称、主题颜色以及不同设备的图标配置。想象一下这个PWA安装在你的安卓手机上。你需要在主抽屉中有一个图标来点击以打开应用程序。此文件包含有关根据不同设备尺寸使用哪个图标的信息。'
- en: 'We also see the file `ngsw-config.json`, which contains the configuration for
    the service worker. Behind the scenes, while the `ng add` command is running the
    schematics, it also installs the `@angular/service-worker` package in our project.
    If you open the `app.config.ts` file, you’ll see the code to register our service
    worker as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了文件`ngsw-config.json`，它包含服务工作者的配置。在幕后，当`ng add`命令运行模板时，它也在我们的项目中安装了`@angular/service-worker`包。如果你打开`app.config.ts`文件，你会看到以下代码来注册我们的服务工作者：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break down the code to understand what’s happening here. We’re creating
    the configuration for our standalone application here along with some providers.
    We have used the `provideRouter` method to provide all the routes for the application
    already. In the recipe, we add the `provideServiceWorker` method to register a
    new service worker for us. It takes two arguments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码来理解这里发生了什么。在这里，我们正在创建独立应用程序的配置，以及一些提供者。我们已经使用了`provideRouter`方法来提供应用程序的所有路由。在配方中，我们添加了`provideServiceWorker`方法来为我们注册一个新的服务工作者。它需要两个参数：
- en: The first argument is the filename of the service worker script, `'``ngsw-worker.js'`.
    This is the built-in Angular service worker that handles the caching and other
    offline behaviors.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是服务工作者脚本的文件名，`'ngsw-worker.js'`。这是内置的Angular服务工作者，它处理缓存和其他离线行为。
- en: 'The second argument is a configuration object for the service worker. Let’s
    review the properties of this configuration object:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是服务工作者的配置对象。让我们回顾一下这个配置对象的属性：
- en: '`enabled: !isDevMode()` tells the application to enable the service worker
    only when the application is not in development mode.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled: !isDevMode()`告诉应用程序仅在应用程序不在开发模式下时启用服务工作者。'
- en: '`registrationStrategy:''registerWhenStable:3000''` specifies the strategy for
    registering the service worker. In this case, the service worker will be registered
    when the application is stable (no ongoing tasks) after 30 seconds.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registrationStrategy:''registerWhenStable:3000''`指定了注册服务工作者的策略。在这种情况下，服务工作者将在应用稳定（没有正在进行的任务）30秒后注册。'
- en: The code registers a new service worker file named `ngsw-worker.js`. This file
    uses the configuration from the `ngsw-config.json` file to decide which resource
    to cache and using which strategies. This is linked in the `angular.json` file
    using the `ngswConfigPath` property. Note that the application we have is a standalone
    application. This means we don’t have an `NgModule` for the application’s bootstrapping
    process. If this was rather a non-standalone application, we would see the changes
    in the `app.module.ts` file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注册了一个名为`ngsw-worker.js`的新服务工作者文件。此文件使用`ngsw-config.json`文件中的配置来决定缓存哪些资源以及使用哪些策略。这是通过`angular.json`文件中的`ngswConfigPath`属性链接的。请注意，我们拥有的应用程序是一个独立的应用程序。这意味着我们没有为应用程序的引导过程创建`NgModule`。如果这是一个非独立应用程序，我们会在`app.module.ts`文件中看到这些更改。
- en: Now that you know how the recipe works, see the next section for further reading.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了食谱是如何工作的，请查看下一节以获取更多阅读内容。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular service worker intro: [https://angular.io/guide/service-worker-intro](https://angular.io/guide/service-worker-intro)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 服务工作者简介：[https://angular.io/guide/service-worker-intro](https://angular.io/guide/service-worker-intro)
- en: 'What are PWAs?: [https://web.dev/what-are-pwas/](https://web.dev/what-are-pwas/)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是PWA？：[https://web.dev/what-are-pwas/](https://web.dev/what-are-pwas/)
- en: Modifying the theme color for your PWA
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改你的 PWA 主题颜色
- en: In the previous recipe, we learned how to convert an Angular app into a PWA.
    When we do so, the `@angular/pwa` package creates the web app manifest file with
    the default theme color, as shown in *Figure 13.9*. However, almost every web
    app has its own branding and style. If you want to theme your PWA’s title bar
    according to your branding, this is the recipe for you. We’ll learn how to modify
    the web app manifest file to customize the PWA’s theme color.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们学习了如何将Angular应用转换为PWA。当我们这样做时，`@angular/pwa`包会创建一个带有默认主题颜色的web应用清单文件，如图*图13.9*所示。然而，几乎每个web应用都有自己的品牌和风格。如果你想根据你的品牌定制PWA的标题栏，这就是你的食谱。我们将学习如何修改web应用清单文件来自定义PWA的主题颜色。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter13/ng-pwa-theme-color`
    inside the cloned repository:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆仓库中的`start/apps/chapter13/ng-pwa-theme-color`：
- en: Open the code repository in your code editor.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the cloned code repository folder, and run the
    following command (from the workspace’s root folder) to serve the project in production
    mode:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到克隆的代码仓库文件夹，并从工作区的根目录运行以下命令（以生产模式运行项目）：
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This should open the app in a new browser tab at `https://localhost:5300`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，地址为`https://localhost:5300`。
- en: Install the application as shown in *Figure 13.8*.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如图*图13.8*所示安装应用程序。
- en: 'This should open the app in a native OS window, and you should see the following:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在原生操作系统窗口中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_13_11.png)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_13_11.png)'
- en: 'Figure 13.11: ng-pwa-theme-color app running as a PWA'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.11：ng-pwa-theme-color应用作为PWA运行
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As you can see in *Figure 13.11*, the header of the app has a bit of a different
    color than the app’s native header (or toolbar). Due to this difference, the app
    looks a bit weird. We’ll modify the web app manifest to update the theme color.
    Let’s get started:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*图13.11*中看到的，应用的头部的颜色与应用的本地头部（或工具栏）略有不同。由于这种差异，应用看起来有点奇怪。我们将修改web应用清单来更新主题颜色。让我们开始吧：
- en: 'Open the `src/manifest.webmanifest` file in your editor and change the theme
    color as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开 `src/manifest.webmanifest` 文件，并按照以下方式更改主题颜色：
- en: '[PRE4]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also have `theme-color` set in our `index.html` file. By default, that has
    precedence over the web app manifest file. Therefore, we need to update it. Open
    the `index.html` file and update it as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在我们的 `index.html` 文件中设置了 `theme-color`。默认情况下，它比 web 应用程序清单文件具有优先级。因此，我们需要更新它。打开
    `index.html` 文件，并按照以下方式更新：
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the PWA again and uninstall it, as shown in *Figure 13.12*. Make sure to
    check the box that says **Also clear data from Chrome (...)** when prompted:![](img/B18469_13_12.png)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开 PWA 并按照图 13.12 所示卸载它。当提示时，确保勾选表示 **也从 Chrome 中清除数据 (...)** 的复选框：![img/B18469_13_12.png]
- en: 'Figure 13.12: Uninstalling the ng-pwa-theme-color app'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.12：卸载 ng-pwa-theme-color 应用程序
- en: 'Now, build the app again using the following commands:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次使用以下命令构建应用程序：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now go to `http://localhost:5300` and install the app again as a PWA, as shown
    in *Figure 13.8*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到 `http://localhost:5300` 并按照图 13.8 所示再次作为 PWA 安装应用程序。
- en: The PWA should already be opened. If not, open it from your applications and
    you should see the updated theme color, as shown in *Figure 13.13*:![](img/B18469_13_13.png)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PWA 应该已经打开。如果没有，从你的应用程序中打开它，你应该看到更新的主题颜色，如图 13.13 所示：![img/B18469_13_13.png]
- en: 'Figure 13.13: PWA with the updated theme color'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.13：更新主题颜色后的 PWA
- en: Awesomesauce! You’ve just learned how to update the theme color for an Angular
    PWA. Now that you’ve finished the recipe, see the next section for further reading.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Awesomesauce! 你刚刚学会了如何更新 Angular PWA 的主题颜色。现在你已经完成了这个食谱，请查看下一节以获取更多阅读材料。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Creating a PWA with the Angular CLI: [https://web.dev/creating-pwa-with-angular-cli/](https://web.dev/creating-pwa-with-angular-cli/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 创建 PWA：[https://web.dev/creating-pwa-with-angular-cli/](https://web.dev/creating-pwa-with-angular-cli/)
- en: Using dark mode in your PWA
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的 PWA 中使用暗黑模式
- en: In the modern age of devices and applications, the preferences of end users
    have evolved a bit as well. With the increased usage of screens and devices, health
    is a major concern. Almost all screen devices now support dark mode. Considering
    this fact, if you’re building a web app, you might want to provide dark mode support
    for it. If it is a PWA that presents itself as a native app, the responsibility
    is much greater. In this recipe, you’ll learn how to provide dark mode for your
    Angular PWA. You’ll learn three different ways to implement styles for dark mode,
    including `prefers-color-scheme` (which is the default/native CSS way) and two
    ways to implement it with Tailwind CSS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代设备和应用程序的时代，最终用户的偏好也发生了一些变化。随着屏幕和设备使用量的增加，健康成为了一个主要关注点。现在几乎所有的屏幕设备都支持暗黑模式。考虑到这一点，如果你正在构建一个
    web 应用程序，你可能希望为它提供暗黑模式支持。如果它是一个以原生应用程序形式呈现的 PWA，那么责任就更大了。在这个食谱中，你将学习如何为你的 Angular
    PWA 提供暗黑模式。你将学习三种不同的方法来实现暗黑模式样式，包括 `prefers-color-scheme`（这是默认/原生的 CSS 方法）以及两种使用
    Tailwind CSS 实现它的方法。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter13/ng-pwa-dark-mode`
    inside the cloned repository:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter13/ng-pwa-dark-mode`：
- en: Open the code repository in your code editor.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the cloned code repository folder, and run the
    following command (from the workspace’s root folder) to serve the project in production
    mode:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到克隆的代码仓库文件夹，并从工作区的根目录运行以下命令以在生产模式下运行项目：
- en: '[PRE7]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This should open the app in a new browser tab at `https://localhost:6400`.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，在 `https://localhost:6400`。
- en: Install the application as shown in *Figure 13.8*.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照图 13.8 所示安装应用程序。
- en: 'This should open the app in a native OS window, and you should see the following:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在原生操作系统窗口中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_13_14.png)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B18469_13_14.png]'
- en: 'Figure 13.14: ng-pwa-dark-mode app running on http://localhost:6400'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.14：ng-pwa-dark-mode 应用程序在 http://localhost:6400 上运行
- en: Now make sure you have the **Dark** theme enabled on your machine. If you’re
    running Mac OS X, you can open **Settings** | **General** and select the **Dark**
    appearance, as shown in *Figure 13.15*:![Figure 13.14 – Changing the system appearance
    to Dark mode in macOS X ](img/B18469_13_15.png)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，确保你的机器上启用了 **暗黑** 主题。如果你正在运行 Mac OS X，你可以打开 **设置** | **通用** 并选择 **暗黑** 外观，如图
    13.15 所示：![Figure 13.14 – 在 macOS X 中更改系统外观为暗黑模式](img/B18469_13_15.png)
- en: 'Figure 13.15: Changing the system appearance to dark mode in Mac OS X'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.15：在 Mac OS X 中将系统外观更改为暗黑模式
- en: If you run the app now, you should be able to see that the app looks the same
    as shown in *Figure 13.4*. However, for dark mode, we should not have a white
    background, etc.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该能够看到应用程序看起来与*图13.4*中显示的相同。然而，对于暗色模式，我们不应该有白色背景等。
- en: Now that we have the PWA running as a native app, and the **dark** mode applied
    to the system, let’s see the steps of the recipe in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将PWA作为原生应用程序运行，并且将**暗色**模式应用于系统，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As you can see, our Angular app doesn’t have complete support for dark mode
    at the moment. That is, the UI is still too bright and looks exactly the same
    as what we see in light mode. We’ll begin by serving the app in development mode
    and adding different colors for dark mode. Let’s get started:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的Angular应用程序目前还没有完全支持暗色模式。也就是说，UI仍然太亮，看起来与亮色模式下的完全一样。我们将从以开发模式提供服务应用程序并添加暗色模式的不同颜色开始。让我们开始吧：
- en: 'Serve the app in development mode by running the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令以开发模式提供服务应用程序：
- en: '[PRE8]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should serve the app in a new browser tab at `http://localhost:4200`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中在`http://localhost:4200`上为应用程序提供服务。
- en: 'Now, open the `styles.scss` file to use the `prefers-color-scheme` media query.
    We’ll use a different value for our global CSS variables to create a different
    view for dark mode. Update the file as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`styles.scss`文件以使用`prefers-color-scheme`媒体查询。我们将为我们的全局CSS变量使用不同的值来为暗色模式创建不同的视图。更新文件如下：
- en: '[PRE9]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you refresh the app again in the browser tab, you’ll see that the background
    has changed but the text is still dark and is not easily visible, as shown in
    *Figure 13.16*:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你再次在浏览器标签页中刷新应用程序，你会看到背景已更改，但文本仍然是暗色且不易看清，如图*图13.16*所示：
- en: '![](img/B18469_13_16.png)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_16.png)'
- en: 'Figure 13.16: Dark text and a dark background for dark mode'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.16：暗色文本和暗色背景用于暗色模式
- en: To fix the styles, we need to provide the styles for dark mode individually
    to the necessary elements.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了修复样式，我们需要为必要的元素分别提供暗色模式的样式。
- en: 'Since we are using Tailwind CSS, we are going to use the Tailwind way of applying
    dark mode to the input label and the input element. Update `src/app/game/game.component.html`
    as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在使用Tailwind CSS，我们将使用Tailwind将暗色模式应用于输入标签和输入元素的方式。更新`src/app/game/game.component.html`如下：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that for the input, we’re using an exclamation sign in the `dark:!text-white`
    statement. This is to mark the `text-white Tailwind` CSS class as important which
    results in the relevant CSS style having the `!` important statement.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，对于输入，我们在`dark:!text-white`语句中使用感叹号。这是为了标记`text-white Tailwind` CSS类为重要，从而使得相关的CSS样式具有`!`重要声明。
- en: 'Now let’s change the `game-stepper.component.html` file to update the style
    for the step heading as well, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将`game-stepper.component.html`文件更改为更新步骤标题的样式，如下所示：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you refresh the application, you should be able to see the heading in white,
    since we’re using dark mode on our device, as follows:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你刷新应用程序，你应该能够看到标题为白色，因为我们正在设备上使用暗色模式，如下所示：
- en: '![](img/B18469_13_17.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_17.png)'
- en: 'Figure 13.17: Heading and input colors fixed for dark mode'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.17：暗色模式中标题和输入颜色已修复
- en: Now let’s fix the numbered cards on the dice-rolling screen. You can see that
    in dark mode, the backgrounds on the cards are not visible, as shown in *Figure
    13.18*:![](img/B18469_13_18.png)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修复投掷屏幕上的编号卡片。你可以看到，在暗色模式下，卡片的背景不可见，如图*图13.18*所示：![](img/B18469_13_18.png)
- en: 'Figure 13.18: Cards’ backgrounds not visible in dark mode'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.18：卡片背景在暗色模式下不可见
- en: Let’s simulate the dark and light modes using Chrome DevTools as it provides
    a really nice way to do so. Open Chrome DevTools and then open the **Command**
    menu. On macOS X, the keys are *Cmd + Shift + P*. On Windows, they are *Ctrl +
    Shift + P*. Then type `Render` and select the **Show Rendering** option, as we
    can see in *Figure 13.19*:![](img/B18469_13_19.png)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用Chrome DevTools来模拟暗色和亮色模式，因为它提供了这样做的一种非常好的方式。打开Chrome DevTools，然后打开**命令**菜单。在macOS
    X上，按键是*Cmd + Shift + P*。在Windows上，它们是*Ctrl + Shift + P*。然后输入`Render`并选择**显示渲染**选项，正如我们在*图13.19*中看到的那样：![](img/B18469_13_19.png)
- en: 'Figure 13.19: Open the rendering view using the Show Rendering option'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.19：使用显示渲染选项打开渲染视图
- en: Now, in the **Rendering** tab, toggle the **prefers-color-scheme** emulation
    for light and dark modes, as shown in *Figure 13.20*:![](img/B18469_13_20.png)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**渲染**选项卡中，切换**prefers-color-scheme**模拟亮色和暗色模式，如图*图13.20*所示：![](img/B18469_13_20.png)
- en: 'Figure 13.20: Simulate prefers-color-scheme modes'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.20：模拟prefers-color-scheme模式
- en: 'Now let us update the numbered cards’ backgrounds. Since the styles for these
    are being applied from the `.scss` file, we’re going to use another technique
    of Tailwind CSS to apply the styles in the `.scss` file. Update `value-guesser.component.scss`
    as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在让我们更新编号卡的背景。由于这些样式是从 `.scss` 文件中应用的，我们将使用 Tailwind CSS 的另一种技术来在 `.scss` 文件中应用样式。按照以下方式更新
    `value-guesser.component.scss`:'
- en: '[PRE12]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you look at the dice-rolling view now, you should see the changed colors,
    as shown in *Figure 13.21*:![](img/B18469_13_21.png)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在查看掷骰子视图，你应该会看到更改后的颜色，如图 *图 13.21* 所示：![](img/B18469_13_21.png)
- en: 'Figure 13.21: Cards’ backgrounds in dark mode'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.21：暗黑模式下的卡片背景
- en: Now test both modes using the Chrome DevTools.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在测试两种模式使用 Chrome 开发者工具。
- en: Uninstall the existing PWA by opening it and then selecting the **Uninstall**
    option from the **More** menu, as shown in *Figure 13.12*. Make sure to check
    the box that says **Also clear data from Chrome (...)** when prompted.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开它并从 **更多** 菜单中选择 **卸载** 选项来卸载现有的 PWA，如图 *图 13.12* 所示。当提示时，请确保勾选表示 **也从 Chrome
    中清除数据 (...)** 的复选框。
- en: 'Run the following command to serve the production app on the browser and then
    navigate to `http://localhost:6400`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '运行以下命令以在浏览器中提供生产应用，然后导航到 `http://localhost:6400`:'
- en: '[PRE13]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may need to clear your cache when this opens in the browser. You can press
    *Ctrl + Shift + R* on Windows and *Cmd + Shift + R* on Mac OS X to do a hard reload.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当它在浏览器中打开时，你可能需要清除你的缓存。你可以在 Windows 上按 *Ctrl + Shift + R*，在 Mac OS X 上按 *Cmd
    + Shift + R* 来进行强制刷新。
- en: Wait for a few seconds for the **Install** button to show up in the address
    bar. Then install the PWA like in *Figure 13.8*.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，直到地址栏中出现 **安装** 按钮。然后像 *图 13.8* 中所示那样安装 PWA。
- en: As soon as you run the PWA now, you should see the dark mode view, as shown
    in *Figure 13.22*, if your system’s appearance is set to dark mode:![](img/B18469_13_22.png)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你现在运行了 PWA，你应该会看到暗黑模式视图，如图 *图 13.22* 所示，如果你的系统外观设置为暗黑模式：![](img/B18469_13_22.png)
- en: 'Figure 13.22: Our PWA supporting dark mode out of the box'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.22：我们的 PWA 支持开箱即用的暗黑模式
- en: Awesome! If you switch your system appearance from dark mode to light mode or
    vice versa, you should see the PWA reflecting the appropriate colors. You now
    know three ways to implement styles for dark mode, including the native CSS way
    and the Tailwind CSS way. Now that you know how to support dark mode in your PWA,
    refer to the next section to see links for further reading.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果你将系统外观从暗黑模式切换到亮模式或反之亦然，你应该会看到 PWA 反映适当的颜色。你现在知道三种实现暗黑模式样式的方法，包括原生 CSS
    方法和 Tailwind CSS 方法。现在你知道如何在你的 PWA 中支持暗黑模式，请参考下一节以查看进一步阅读的链接。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Prefers color scheme: [https://web.dev/prefers-color-scheme/](https://web.dev/prefers-color-scheme/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏好颜色方案：[https://web.dev/prefers-color-scheme/](https://web.dev/prefers-color-scheme/)
- en: 'Using color scheme with `prefers-color-scheme`: [https://web.dev/color-scheme/](https://web.dev/color-scheme/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `prefers-color-scheme` 颜色方案：[https://web.dev/color-scheme/](https://web.dev/color-scheme/)
- en: Providing a custom installable experience in your PWA
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的 PWA 中提供自定义的可安装体验
- en: We know that PWAs are installable. This means they can be installed on your
    devices like a native application. However, when you first open the app in the
    browser, it totally depends on the browser as to how it shows the **Install**
    option; it varies from browser to browser. It also It also might not be clearly
    visible or clearly visible. Also, you might want to show the **Install** prompt
    at some special point in the app instead of the app launch, Consider displaying
    the Install prompt at a specific, user-friendly point within the app, rather than
    right at the app’s launch, as this can be perceived as annoying by some users.
    Luckily, we have a way to provide our own custom dialog/prompt for the installation
    option for our PWAs. And that is what we’ll learn about in this recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 PWA 是可安装的。这意味着它们可以像原生应用一样安装到你的设备上。然而，当你第一次在浏览器中打开应用时，它完全取决于浏览器如何显示 **安装**
    选项；这因浏览器而异。它也可能不明显或难以辨认。此外，你可能想在应用的一些特殊点显示 **安装** 提示，而不是在应用启动时，考虑在应用内的一个特定、用户友好的点显示安装提示，而不是直接在应用启动时，因为这可能会被一些用户视为烦人。幸运的是，我们有一种方法为我们的
    PWA 提供自定义的对话框/提示来选择安装选项。这正是我们将在这道菜谱中学习的。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter13/ng-pwa-cust-installation`
    inside the cloned repository:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter13/ng-pwa-cust-installation` 目录下：
- en: Open the code repository in your code editor.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the cloned code repository folder, and run the
    following command (from the workspace’s root folder) to serve the project in production
    mode:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到克隆的代码仓库文件夹，并运行以下命令（从工作区的根目录）以在生产模式下运行项目：
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This should open the app in a new browser tab at `https://localhost:7000`.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，地址为`https://localhost:7000`。
- en: Install the application as shown in *Figure 13.8*.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照图13.8所示安装应用程序。
- en: 'This should open the app in a native OS window, and you should see the following:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在原生OS窗口中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_13_23.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_23.png)'
- en: 'Figure 13.23: ng-pwa-cust-installation running at http://localhost:7000'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.23：ng-pwa-cust-installation在http://localhost:7000上运行
- en: Now that we have the app running, let’s see the steps of the recipe in the next
    section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了应用程序，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have the Dice Guesser application in which you roll the dice and guess the
    output. For this recipe, we’ll prevent the default installation prompt and will
    show it only when the user has made a correct guess. Let’s begin:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个Dice Guesser应用程序，在这个应用程序中你可以掷骰子并猜测输出。对于这个食谱，我们将阻止默认的安装提示，并且只有在用户做出了正确的猜测时才显示它。让我们开始吧：
- en: 'First, create a service that will show our custom installable prompt in the
    next steps. In the project root, run the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个服务，将在下一步显示我们的自定义可安装提示。在项目根目录中运行以下命令：
- en: '[PRE15]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When asked, use the `@schematics/angular:service` schematics.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被要求时，使用`@schematics/angular:service`脚手架。
- en: 'Next, open the created file, `installable-prompt.service.ts`, and update the
    code as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开创建的文件`installable-prompt.service.ts`，并按以下方式更新代码：
- en: '[PRE16]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will notice that TypeScript isn’t happy with our code.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到TypeScript对我们的代码并不满意。
- en: 'In this step, we need to define the `BeforeInstallPrompt` event type. Let’s
    create a folder named `types` inside the `src` folder. Create a file named `installation-prompt.d.ts`
    and add the following code to it:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们需要定义`BeforeInstallPrompt`事件类型。让我们在`src`文件夹内创建一个名为`types`的文件夹。创建一个名为`installation-prompt.d.ts`的文件，并将以下代码添加到其中：
- en: '[PRE17]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We must add the `types` folder in `tsconfig.json` so we can load the types.
    Update the `tsconfig.json` file as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须在`tsconfig.json`中添加`types`文件夹，以便我们可以加载类型。更新`tsconfig.json`文件如下：
- en: '[PRE18]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let’s build the custom installation banner we’ll show to the user to
    trigger the installation prompt. Update `app.component.html` and add the following
    code AFTER the `<main>`, tag as shown here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建我们将向用户显示以触发安装提示的自定义安装横幅。更新`app.component.html`并在`<main>`标签之后添加以下代码，如下所示：
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***   Now run the application again using the following command to see the
    installation prompt, as shown in *Figure 13.24*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '***   现在再次使用以下命令运行应用程序以查看安装提示，如图13.24所示：'
- en: '[PRE20]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/B18469_13_24.png)'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_24.png)'
- en: 'Figure 13.24: Custom installation prompt being displayed in the PWA'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.24：在PWA中显示的自定义安装提示
- en: Sometimes you will see cached versions of the application due to running multiple
    PWAs on the same port, for instance. In this case, open the Chrome DevTools, go
    to the **Application** tab, click the **Service Workers** option from the left
    menu, and check the **Bypass for network** option.**
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时你会因为在同一端口上运行多个PWA而看到应用程序的缓存版本，例如。在这种情况下，打开Chrome开发者工具，转到**应用程序**标签，从左侧菜单中选择**服务工作者**选项，并检查**绕过网络**选项。
- en: '**1.  We’re now going to create a `signal` inside the `InstallablePromptService`
    class, based on which we’ll show or hide the custom installation banner. Update
    the `installable-prompt.service.ts` file as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 我们现在将在`InstallablePromptService`类内部创建一个`signal`，根据这个`signal`我们将显示或隐藏自定义安装横幅。更新`installable-prompt.service.ts`文件如下：'
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s import the `InstallationPromptService` class in the app component so
    we can use it in the template for the custom installation banner. Update the `app.component.ts`
    file as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在应用程序组件中导入`InstallationPromptService`类，以便我们可以在自定义安装横幅的模板中使用它。更新`app.component.ts`文件如下：
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the template now to use the `signal` from the injected `InstallablePromptService`
    in the app component. Update the `app.component.html` file as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新模板以使用应用程序组件中注入的`InstallablePromptService`的`signal`。更新`app.component.html`文件如下：
- en: '[PRE23]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Restart the server by running `npm run serve:static chapter13 ng-pwa-cust-installation
    7000` and you’ll notice that the custom installation banner doesn’t show anymore.
    That’s because now we have to flip the `signal` in the `InstallationPromptService`
    class when the user guesses the score correctly.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过运行`npm run serve:static chapter13 ng-pwa-cust-installation 7000`来重新启动服务器，你会注意到自定义安装横幅不再显示。这是因为现在当用户正确猜测分数时，我们必须在`InstallationPromptService`类中翻转`signal`。
- en: Uninstall the existing PWA by opening it and then selecting the **Uninstall**
    option from the **More** menu, as shown in *Figure 13.12*. Make sure to check
    the box that says **Also clear data from Chrome (...)** when prompted.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开它并从**更多**菜单中选择**卸载**选项来卸载现有的PWA，如图*图13.12*所示。当提示时，请确保勾选表示**也从Chrome中清除数据(...)**的复选框。
- en: 'Update the `src/app/game/game.component.ts` file to flip the `signal`, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/app/game/game.component.ts`文件，以翻转`signal`，如下所示：
- en: '[PRE24]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you now run the app again, as shown in *step 6*, and guess the dice rolls,
    and you guess the correct one, you should be able to see the custom installation
    banner, as shown in *Figure 13.25*:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在再次运行应用程序，如*步骤6*所示，猜测骰子的点数，并且你猜对了，你应该能看到自定义安装横幅，如图*图13.25*所示：
- en: '![](img/B18469_13_25.png)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_25.png)'
- en: 'Figure 13.25: Custom installation banner being displayed after guessing'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.25：猜测后显示的自定义安装横幅
- en: 'Now we’ll implement what happens when we click the **Install it!** link from
    the custom installation banner. Create a new method in the file `installable-prompt.service.ts`
    as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现当从自定义安装横幅中点击**安装它！**链接时会发生什么。在`installable-prompt.service.ts`文件中创建一个新方法，如下所示：
- en: '[PRE25]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now call this method from the custom installation banner to show the
    browser’s installation prompt. Update the `app.component.html` file, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将从自定义安装横幅调用此方法以显示浏览器的安装提示。更新`app.component.html`文件，如下所示：
- en: '[PRE26]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, if you rerun the app in the browser and guess the dice’s next value, you
    can click on the **Install it!** link to see the browser prompt, as shown in *Figure
    13.26*:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你在浏览器中重新运行应用程序并猜测骰子的下一个值，你可以点击**安装它！**链接来查看浏览器提示，如图*图13.26*所示：
- en: '![](img/B18469_13_26.png)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_26.png)'
- en: 'Figure 13.26: Browser installation prompt being displayed'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.26：浏览器安装提示正在显示
- en: 'Finally, we don’t want to show the custom installation banner when the app
    is running as a PWA. And right now, it does. To fix that, we’ll add some styles
    to `app.component.scss`, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们不想在应用程序作为PWA运行时显示自定义安装横幅。而现在它确实如此。为了解决这个问题，我们将在`app.component.scss`中添加一些样式，如下所示：
- en: '[PRE27]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you install the PWA now and guess the dice’s next value correctly, you won’t
    see the custom installation banner anymore.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在安装PWA并正确猜测骰子的下一个值，你将不再看到自定义安装横幅。
- en: Awesome! You can now play around with the app by installing and uninstalling
    the PWA a few times and trying out all the combinations of the user choosing to
    install or not to install the app. It’s all fun and games. Now that you know how
    to implement a custom installation banner for an Angular PWA, move on to the next
    section to understand how it works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在可以通过安装和卸载PWA几次来玩转应用程序，并尝试用户选择安装或不安装应用程序的所有组合。这全是乐趣和游戏。现在你了解了如何为Angular
    PWA实现自定义安装横幅，接下来继续下一节了解它是如何工作的。
- en: How it works…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The heart of this recipe is the `beforeinstallprompt` event. It is a standard
    browser event that is supported in the latest versions of Chrome, Firefox, Safari,
    Opera, UC Browser (Android version), and Samsung Internet, that is, almost all
    major browsers. The event has a `prompt` method, which shows the browser’s default
    prompt on the device. In the recipe, we create `InstallablePromptService` and
    store the event in a property called `installPromptEvent`. This is so we can use
    it later on demand when the user has guessed a correct dice-roll value. Note that
    as soon as we receive the `beforeinstallprompt` event, we remove the event listener
    from the `window` object, so we only save the event once. That is when the app
    starts. If the user chooses not to install the app, we don’t show the prompt again
    within the same session. However, if the user refreshes the app, they will still
    get the prompt one time for the first correct guess. We could go one step further
    to save this state in `localStorage` to avoid showing the prompt after the page
    refreshes, but that’s not part of this recipe.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的核心是`beforeinstallprompt`事件。这是一个标准浏览器事件，在Chrome、Firefox、Safari、Opera、UC浏览器（Android版本）和三星Internet的最新版本中都有支持，也就是说，几乎所有的主流浏览器都支持这个事件。该事件有一个`prompt`方法，它会在设备上显示浏览器的默认提示。在食谱中，我们创建`InstallablePromptService`并将事件存储在一个名为`installPromptEvent`的属性中。这样我们就可以在用户猜对了骰子滚动值后按需使用它。请注意，一旦我们收到`beforeinstallprompt`事件，我们就从`window`对象中移除事件监听器，所以我们只保存一次事件。那就是应用开始的时候。如果用户选择不安装应用，我们不会在同一个会话中再次显示提示。然而，如果用户刷新应用，他们仍然会在第一次正确猜测时收到一次提示。我们可以更进一步，将这个状态保存在`localStorage`中，以避免页面刷新后再次显示提示，但这不是本食谱的一部分。
- en: For the custom installation banner, we use a template based on Tailwind CSS.
    Note that on the custom installation banner, we have a link. When we click this
    link, the `showInstallPrompt` method from the `InstallablePromptService` class
    is called. In that method, we use the event, that is, the `this.installPromptEvent`
    property’s `prompt` method to show the browser’s prompt. Note that after we’ve
    displayed the browser’s prompt, we set the signal `isPromptBannerShown` value
    to `false`, so it hides the custom install banner. This is also so we don’t show
    the prompt again in the same session until the user refreshes the page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义安装横幅，我们使用基于Tailwind CSS的模板。请注意，在自定义安装横幅上，我们有一个链接。当我们点击这个链接时，`InstallablePromptService`类的`showInstallPrompt`方法会被调用。在这个方法中，我们使用事件，即`this.installPromptEvent`属性的`prompt`方法来显示浏览器的提示。请注意，在我们显示浏览器的提示后，我们将信号`isPromptBannerShown`的值设置为`false`，这样就会隐藏自定义安装横幅。这也是为了确保在用户刷新页面之前，不会在同一个会话中再次显示提示。
- en: 'Finally, we also use some CSS to not show the custom installation banner at
    all if the app is launched as a PWA. This is important because if it is already
    a PWA, it doesn’t make sense to show an install prompt. Therefore, we use an `@media`
    query with `display-mode: standalone`, which checks if the app is running as a
    PWA. In that CSS rule, we hide the custom installation banner.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，如果应用以PWA的形式启动，我们也会使用一些CSS来完全不显示自定义安装横幅。这很重要，因为如果它已经是PWA，显示安装提示就没有意义了。因此，我们使用`@media`查询和`display-mode:
    standalone`，来检查应用是否作为PWA运行。在这个CSS规则中，我们隐藏自定义安装横幅。'
- en: Now that you understand how it all works, refer to the next section to see links
    for further reading.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了所有的工作原理，请参考下一节以查看进一步阅读的链接。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'How to provide your own app-install experience (`web.dev`): [https://web.dev/customize-install/](https://web.dev/customize-install/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提供自己的应用安装体验（`web.dev`）：[https://web.dev/customize-install/](https://web.dev/customize-install/)
- en: Precaching requests using an Angular service worker
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular service worker预缓存请求
- en: With the addition of service workers in our previous recipes, we’ve seen that
    they already cache the assets and serve them using the service worker if we go
    into Offline mode. But what about network requests? If the user goes offline and
    refreshes the application right now, the network requests fail because they’re
    not cached with the service worker. This results in a broken offline user experience.
    In this recipe, we’ll configure the service worker to precache network requests,
    so the app works fluently in Offline mode as well.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的食谱中添加了service workers之后，我们已经看到它们已经缓存了资源，并在离线模式下通过service worker提供服务。但是网络请求怎么办？如果用户离线并立即刷新应用，网络请求会失败，因为它们没有被service
    worker缓存。这导致离线用户体验中断。在这个食谱中，我们将配置service worker来预缓存网络请求，这样应用在离线模式下也能流畅运行。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter13/ng-pwa-precaching`
    inside the cloned repository:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter13/ng-pwa-precaching` 目录内：
- en: Open the code repository in your code editor.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the cloned code repository folder, and run the
    following command (from the workspace’s root folder) to serve the project in production
    mode:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到克隆的代码仓库文件夹，并运行以下命令（从工作区的根目录）以在生产模式下提供项目：
- en: '[PRE28]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This should open the app in a new browser tab at `https://localhost:7600`.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开 `https://localhost:7600`。
- en: Refresh the page once.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面一次。
- en: Now, switch to Offline mode as shown in *Figure 13.2*. If you go to the **Network**
    tab and filter the requests using the query results, you should see that the requests
    fail, as shown in *Figure 13.27*:![](img/B18469_13_27.png)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到离线模式，如图 *图 13.2* 所示。如果你转到 **网络** 选项卡并使用查询结果过滤请求，你应该看到请求失败，如图 *图 13.27*
    所示：![](img/B18469_13_27.png)
- en: 'Figure 13.27: Offline experience broken due to not caching the network requests'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.27：由于未缓存网络请求而导致的离线体验中断
- en: Now that we see the network requests failing, let us see the steps of the recipe
    to fix this in the next section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到网络请求失败，让我们在下一节中查看修复此问题的步骤。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As you can see in *Figure 13.27*, the app still loads. We can see the header
    and the loader. However, the API (fetch) calls do not work since we are simulating
    an offline network situation using Chrome DevTools. This is because the service
    worker is not configured yet to cache the data request. Let us get started with
    the recipe to fix this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *图 13.27* 中所见，应用仍然可以加载。我们可以看到页眉和加载器。然而，API（fetch）调用不工作，因为我们正在使用 Chrome DevTools
    模拟离线网络情况。这是因为服务工作者尚未配置为缓存数据请求。让我们开始修复此问题的配方：
- en: 'To cache the network requests, open the `ngsw-config.json` file inside the
    `start/apps/chapter13/ng-pwa-precaching` folder and update it as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要缓存网络请求，打开 `start/apps/chapter13/ng-pwa-precaching` 目录内的 `ngsw-config.json`
    文件，并按以下方式更新它：
- en: '[PRE29]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let us test the application now. Build and run the app in production mode using
    the following command:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在测试这个应用。使用以下命令在生产模式下构建和运行应用：
- en: '[PRE30]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now navigate to `http://localhost:7600`. Make sure **Network throttling** is
    not enabled, that is, you are not in **Offline** mode.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到 `http://localhost:7600`。确保**网络限制**没有启用，也就是说，你不在**离线**模式。
- en: Clear the app data using Chrome DevTools using the **Application** tab | the
    **Storage** panel. Or press *Cmd + Shift + R* (macOS X) or *Ctrl + Shift + R*
    (Windows) to do a hard reload.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Chrome DevTools 的 **应用** 选项卡 | **存储** 面板清除应用数据。或者按 *Cmd + Shift + R*（macOS
    X）或 *Ctrl + Shift + R*（Windows）进行强制刷新。
- en: Refresh the app once more to let the service worker cache the API requests.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次刷新应用，让服务工作者缓存 API 请求。
- en: In Chrome DevTools, go to the **Network** tab and switch to Offline mode, as
    shown in *Figure 13.2*. Refresh the app again. You should see the data from Swapi
    despite being offline. The network calls are served from the service worker, as
    shown in *Figure 13.28*:![](img/B18469_13_28.png)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Chrome DevTools 中，转到 **网络** 选项卡并切换到离线模式，如图 *图 13.2* 所示。再次刷新应用。即使离线，你也应该看到
    Swapi 的数据。网络调用由服务工作者提供，如图 *图 13.28* 所示：![](img/B18469_13_28.png)
- en: 'Figure 13.28: Network calls being cached by the service worker'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.28：服务工作者正在缓存网络调用
- en: And boom! You have just learned how to configure a service worker in an Angular
    app to cache network/data requests. And you can install the PWA and use it even
    if you are offline. Awesome, right?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你刚刚学会了如何在 Angular 应用中配置服务工作者以缓存网络/数据请求。即使离线，你也可以安装 PWA 并使用它。太棒了，对吧？
- en: Now that we have finished the recipe, let’s see how it all works in the next
    section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配方，让我们在下一节中看看这一切是如何工作的。
- en: How it works…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The heart of this recipe is the `ngsw-config.json` file. This file is used
    by the `@angular/service-worker` package when generating the service worker file.
    The file already contains a JSON object out of the box when we use the `@angular/pwa`
    schematics by running `ng add @angular/pwa`. This JSON contains a property called
    `assetGroups`, which configures the caching of the assets based on the provided
    configuration. For this recipe, we wanted to cache network requests along with
    the assets. Therefore, we added the new property `dataGroups` in the JSON object.
    Let us have a look at the configuration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的核心是`ngsw-config.json`文件。当使用`ng add @angular/pwa`命令运行`@angular/pwa`脚手架时，该文件被`@angular/service-worker`包用于生成服务工作者文件。当我们使用`@angular/pwa`脚手架时，该文件默认包含一个JSON对象。这个JSON对象包含一个名为`assetGroups`的属性，它根据提供的配置来配置资源的缓存。对于这个食谱，我们希望缓存网络请求以及资源。因此，我们在JSON对象中添加了新的属性`dataGroups`。让我们看看配置：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, `dataGroups` is an array. We can provide different configuration
    objects as elements to it. Each configuration has a `name`, an array of `urls`,
    and a `cacheConfig` that defines the caching strategy. For our configuration,
    we use a wildcard with the API URL, that is, we use `urls`: ["`https://swapi.dev/api/*`"].
    For the `cacheConfig`, we are using the `freshness` strategy, which means the
    app will always fetch the data from its origin first. If the network is unavailable,
    then it will use the response from the service worker cache. An alternate strategy
    is `performance`, which first looks up the service worker for a cached response.
    If there is nothing in the cache for the URL (or URLs), then it fetches the data
    from the actual origin. The `maxSize` property defines how many requests can be
    cached for the same pattern (or set of URLs). The `maxAge` property defines how
    long the cached data would live in the service worker cache.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，`dataGroups`是一个数组。我们可以向其中提供不同的配置对象作为元素。每个配置都有一个`name`，一个`urls`数组，以及一个定义缓存策略的`cacheConfig`。在我们的配置中，我们使用了一个通配符与API
    URL，即我们使用`urls`: ["`https://swapi.dev/api/*`"]。对于`cacheConfig`，我们使用的是`freshness`策略，这意味着应用将始终首先从其源获取数据。如果网络不可用，则它将使用服务工作者缓存的响应。另一种策略是`performance`，它首先在服务工作者中查找缓存的响应。如果对于URL（或URLs）没有缓存，则从实际源获取数据。`maxSize`属性定义了可以缓存多少个请求以相同的模式（或URL集合）。`maxAge`属性定义了缓存数据在服务工作者缓存中存活的时间。'
- en: Now that you know how the recipe works, see the next section for links to further
    reading.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了这个食谱的工作原理，请查看下一节以获取进一步阅读的链接。
- en: See also
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Angular service worker intro: [https://angular.io/guide/service-worker-intro](https://angular.io/guide/service-worker-intro)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 服务工作者简介：[https://angular.io/guide/service-worker-intro](https://angular.io/guide/service-worker-intro)
- en: 'Angular service worker config: [https://angular.io/guide/service-worker-config](https://angular.io/guide/service-worker-config)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 服务工作者配置：[https://angular.io/guide/service-worker-config](https://angular.io/guide/service-worker-config)
- en: 'Creating an offline fallback page (`web.dev`): [https://web.dev/offline-fallback-page/](https://web.dev/offline-fallback-page/)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建离线回退页面（`web.dev`）：[https://web.dev/offline-fallback-page/](https://web.dev/offline-fallback-page/)
- en: Creating an App Shell for your PWA
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的PWA创建App Shell
- en: When it comes to building fast user experiences for web apps, one of the major
    challenges is minimizing the critical rendering path. This includes loading the
    most critical resources for the target page, parsing, executing JavaScript, and
    so on. With an App Shell, we can render a page, or a portion of the app, at build
    time rather than runtime. This means the user will see the minimal pre-rendered
    content initially, until JavaScript and Angular kick in. This means the browser
    does not have to work and wait a while for the first meaningful paint. This not
    only provides a good user experience but also helps rank the website higher in
    search engines, i.e., results in better SEO. In this recipe, you will create an
    App Shell for an Angular PWA.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为Web应用构建快速的用户体验时，一个主要挑战是尽量减少关键渲染路径。这包括加载目标页面的最关键资源，解析，执行JavaScript等。使用App
    Shell，我们可以在构建时而不是运行时渲染一个页面或应用的一部分。这意味着用户最初将看到最小的预渲染内容，直到JavaScript和Angular介入。这意味着浏览器不需要工作并等待一段时间以进行第一次有意义的绘制。这不仅提供了良好的用户体验，还有助于将网站在搜索引擎中的排名提高，即实现更好的SEO。在这个食谱中，你将为Angular
    PWA创建一个App Shell。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter13/ng-pwa-app-shell`
    inside the cloned repository:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter13/ng-pwa-app-shell`目录下：
- en: Open the code repository in your code editor.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the cloned code repository folder, and run the
    following command (from the workspace’s root folder) to serve the project in production
    mode:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到克隆的代码仓库文件夹，然后从工作区根目录运行以下命令以在生产模式下运行项目：
- en: '[PRE32]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This should open the app in a new browser tab at `http://localhost:4200`, and
    you should see the following:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，并在`http://localhost:4200`显示以下内容：
- en: '![](img/B18469_13_29.png)'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_29.png)'
- en: 'Figure 13.29: ng-pwa-app-shell running on http://localhost:4200'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.29：ng-pwa-app-shell 在 http://localhost:4200 上运行
- en: 'Now we’ll disable JavaScript to simulate taking a lot of time to parse JavaScript,
    or to simulate that there’s no App Shell in place yet. Now open Chrome DevTools.
    Then open the command panel. The shortcut for opening the command panel is *Cmd
    + Shift + P* on Mac OS X and *Ctrl + Shift + P* on Windows. Type **Disable JavaScript**,
    select the option, and hit *Enter*. Refresh the page while Chrome DevTools is
    still open, and you should see a message as follows:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将禁用 JavaScript 来模拟解析 JavaScript 所花费的大量时间，或者模拟尚未安装 App Shell。现在打开 Chrome
    DevTools。然后打开命令面板。在 Mac OS X 上打开命令面板的快捷键是 *Cmd + Shift + P*，在 Windows 上是 *Ctrl
    + Shift + P*。输入**Disable JavaScript**，选择选项，然后按 *Enter*。在 Chrome DevTools 仍然打开的情况下刷新页面，你应该会看到以下消息：
- en: '![](img/B18469_13_30.png)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_13_30.png)'
- en: 'Figure 13.30: No App Shell present in the app'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.30：应用中没有 App Shell
- en: Now that we have checked for the absence of the App Shell, let’s see the steps
    of the recipe in the next section.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了 App Shell 的不存在，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'We have an Angular application that fetches some users from an API. We will
    create an App Shell for this app so it can provide the first meaningful paint
    faster as a PWA. Let’s get started:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个从 API 获取一些用户的 Angular 应用程序。我们将为这个应用创建一个 App Shell，以便它作为 PWA 提供更快的首次有意义的绘制。让我们开始吧：
- en: 'First, create the App Shell for the app by running the following command from
    the project root:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过从项目根目录运行以下命令为应用创建 App Shell：
- en: '[PRE33]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This adds some new files to our project but also updates `project.json`. Since
    we’re using a unique folder structure for the recipes, you need to update the
    `project.json` file by replacing all the `dist/ng-pwa-app-shell` instances with
    `dist/apps/chapter13/ng-pwa-app-shell`.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为我们的项目添加一些新文件，但也会更新`project.json`。由于我们为食谱使用独特的文件夹结构，您需要通过将所有`dist/ng-pwa-app-shell`实例替换为`dist/apps/chapter13/ng-pwa-app-shell`来更新`project.json`文件。
- en: 'Update the `src/app/app-shell/app-shell.component.ts` file to import the `UsersComponent`
    class so we can render the `users` page in the App Shell. The code should look
    as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/app/app-shell/app-shell.component.ts`文件以导入`UsersComponent`类，这样我们就可以在
    App Shell 中渲染`users`页面。代码应如下所示：
- en: '[PRE34]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now open the `app-shell.component.html` file and use the `<app-users>` element
    so we render the whole `UsersComponent` in the App Shell. The code should look
    as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`app-shell.component.html`文件，并使用`<app-users>`元素来在 App Shell 中渲染整个`UsersComponent`。代码应如下所示：
- en: '[PRE35]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, update `users.component.ts` to show the skeleton loader when the App
    Shell is being generated. Update the file as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`users.component.ts`文件，在 App Shell 正在生成时显示骨架加载器。文件更新如下：
- en: '[PRE36]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have the code written for the App Shell, let’s create it. Run the
    following command from the `workspace root` to generate the App Shell in `production`
    mode:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为 App Shell 编写了代码，让我们创建它。从`工作区根目录`运行以下命令以在`production`模式下生成 App Shell：
- en: '[PRE37]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the App Shell is generated in *step 5*, run the following command from
    the `workspace root` (not from the `start` folder) to serve it using the `http-server`
    package:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在*步骤 5*中生成了 App Shell，从`工作区根目录`（而不是从`start`文件夹）运行以下命令，使用`http-server`包来运行它：
- en: '[PRE38]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Make sure that JavaScript is still turned off for the app. If not, open Chrome
    DevTools and press *Cmd + Shift + P* for Mac OS X to open the command panel (*Ctrl
    + Shift + P* on Windows). Then type `Disable Javascript` and hit *Enter*, selecting
    the option as shown in *Figure 13.31*:![Figure 13.27 – Disable JavaScript using
    Chrome DevTools ](img/B18469_13_31.png)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用中的 JavaScript 仍然处于关闭状态。如果不是，请打开 Chrome DevTools 并按 Mac OS X 的 *Cmd + Shift
    + P* 或 Windows 的 *Ctrl + Shift + P* 打开命令面板。然后输入`Disable Javascript`并按 *Enter*，选择如图
    13.31 所示的选项![Figure 13.27 – 使用 Chrome DevTools 禁用 JavaScript](img/B18469_13_31.png)
- en: 'Figure 13.31: Disable JavaScript using Chrome DevTools'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.31：使用 Chrome DevTools 禁用 JavaScript
- en: Refresh the app while JavaScript is disabled. You should now see the app still
    showing the pre-rendered users page with the skeleton loaders, despite JavaScript
    being disabled, as shown in *Figure 13.32*. Woohoo!![](img/B18469_13_32.png)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在禁用 JavaScript 的同时刷新应用。现在你应该看到应用仍然显示带有骨架加载器的预渲染用户页面，尽管 JavaScript 已被禁用，如图 *图
    13.32* 所示。哇哦!![](img/B18469_13_32.png)
- en: 'Figure 13.32: App Shell showing the pre-rendered Users page'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.32：显示预渲染用户页面的 App Shell
- en: To verify that we are pre-rendering the **Users** page at build time, inspect
    the generated code at `<workspace-root>/start/dist/apps/chapter13/ng-pwa-app-shell/browser/index.html`.
    You should see the entire rendered page inside the `<body>` tag.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们在构建时预渲染了 **用户** 页面，请检查 `<workspace-root>/start/dist/apps/chapter13/ng-pwa-app-shell/browser/index.html`
    中的生成代码。你应该在 `<body>` 标签内看到整个渲染的页面。
- en: 'Create the production build with the App Shell and serve it on port `1020`
    by running the following commands:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 App Shell 创建生产构建，并通过运行以下命令在端口 `1020` 上提供服务：
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Navigate to `http://localhost:1020` in your browser and install the app as a
    PWA, as shown in *Figure 13.8*. Once done, run the PWA and it should look as follows:![](img/B18469_13_33.png)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中导航到 `http://localhost:1020` 并将应用作为 PWA 安装，如图 *图 13.8* 所示。完成后，运行 PWA，它应该看起来如下所示：![](img/B18469_13_33.png)
- en: 'Figure 13.33: ng-pwa-app-shell running as a PWA'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.33：ng-pwa-app-shell 作为 PWA 运行
- en: Great! You now know how to create an App Shell for your Angular PWAs. Now that
    you’ve finished the recipe, see the next section on how it works.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在知道如何为你的 Angular PWAs 创建 App Shell。现在你已经完成了这个配方，请查看下一节了解它是如何工作的。
- en: How it works…
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The recipe begins with disabling JavaScript for our application. This means
    when the app runs, we only show static HTML and CSS since there’s no JavaScript
    execution. We see a message about JavaScript not being supported, as shown in
    *Figure 13.30*. The code comes from the `src/index.html` file having the following
    code inside the `<body>` element:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方从禁用我们应用程序的 JavaScript 开始。这意味着当应用运行时，我们只显示静态 HTML 和 CSS，因为没有 JavaScript 执行。我们看到了关于
    JavaScript 不受支持的提示，如图 *图 13.30* 所示。代码来自 `src/index.html` 文件，其中 `<body>` 元素内部有如下代码：
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then run the command `nx g app-shell--project=ng-pwa-app-shell`. Since we
    are in an NX workspace, the command requires the right project. If this were a
    regular Angular project, you could just run `ng generate app-shell` and it would
    create the App Shell for you. In either case, the command does the following things
    for us:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行命令 `nx g app-shell--project=ng-pwa-app-shell`。由于我们处于一个 NX 工作区，该命令需要正确的项目。如果这是一个常规的
    Angular 项目，你只需运行 `ng generate app-shell`，它就会为你创建 App Shell。在任何情况下，该命令都会为我们执行以下操作：
- en: Creates a new component named `AppShellComponent` and generates its relevant
    files.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AppShellComponent` 的新组件并生成其相关文件。
- en: Installs the `@angular/platform-server` package in the project.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目中安装 `@angular/platform-server` 包。
- en: Adds some new files, namely, `main.server.ts`, to enable server-side rendering
    (build-time rendering for our App Shell, to be exact).
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些新文件，即 `main.server.ts`，以启用服务器端渲染（确切地说，为我们的 App Shell 进行构建时渲染）。
- en: Most importantly, it updates the `project.json` (`angular.json` for an Angular
    project not in the NX workspace) file to add a bunch of schematics for server-side
    rendering as well as for generating the `app-shell`. Notice that it overrides
    the `build` object (specifically the `outputPath`) property to remove the `apps`
    folder and chapter name. We don’t want that as we want the bundle to be generated
    in `dist/apps/chapter13/<project-name>`, and that is why we updated it manually
    in the recipe. Notice that it also adds a new `"server"` object for SSR and an
    `"app-shell"` object with configuration to generate the App Shell.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，它更新了 `project.json`（对于不在 NX 工作区的 Angular 项目是 `angular.json`）文件，添加了一组用于服务器端渲染以及生成
    `app-shell` 的脚图。请注意，它覆盖了 `build` 对象（特别是 `outputPath` 属性），以删除 `apps` 文件夹和章节名称。我们不想这样，因为我们希望将包生成在
    `dist/apps/chapter13/<project-name>`，这就是为什么我们在配方中手动更新了它。请注意，它还添加了一个新的 `"server"`
    对象用于 SSR，以及一个配置了生成 App Shell 的 `"app-shell"` 对象。
- en: In the recipe, we create the App Shell, and then we import the `UsersComponent`
    class to the `AppShellComponent` class’s `imports` array. Since `AppShellComponent`
    is a `standalone` component (not part of any `NgModule`), and so is `UsersComponent`,
    we need to link them together via the `imports` array in `AppShellComponent`.
    After importing the `UsersComponent` class, we update the `app-shell.component.html`
    (the App Shell template) to use the `<app-users>` selector, which reflects the
    `UsersComponent` class. That is the entire **Users** page. Finally, we make sure
    that we only render the skeleton elements when the Browser is being created (and
    the same for SSR). Therefore, we use the `PLATFORM_ID` token in the `users.component.ts`
    file. The token’s value contains the name of the platform our application is running
    on. When the app shell is being generated, it is the server-side environment,
    and the value of `PLATFORM_ID` is `"server"`. Instead of comparing it with the
    string `"server"`, i.e., using the condition `this.platformId !== "server")`,
    we use the `isPlatformBrowser` function from the `@angular/common` package to
    only fetch the data if the platform is `browser` (which is not the case when generating
    the app shell).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们创建 App Shell，然后我们将 `UsersComponent` 类导入到 `AppShellComponent` 类的 `imports`
    数组中。由于 `AppShellComponent` 是一个 `standalone` 组件（不是任何 `NgModule` 的部分），`UsersComponent`
    也是如此，因此我们需要通过 `AppShellComponent` 中的 `imports` 数组将它们链接在一起。在导入 `UsersComponent`
    类之后，我们更新 `app-shell.component.html`（App Shell 模板）以使用 `<app-users>` 选择器，这反映了 `UsersComponent`
    类。这就是整个 **用户** 页面。最后，我们确保只有在浏览器正在创建时（以及对于 SSR 也是如此）才渲染骨架元素。因此，我们在 `users.component.ts`
    文件中使用 `PLATFORM_ID` 令牌。令牌的值包含我们应用程序正在运行的平台的名称。当 App Shell 正在生成时，它是服务器端环境，`PLATFORM_ID`
    的值为 `"server"`。我们不是将其与字符串 `"server"` 进行比较，即使用条件 `this.platformId !== "server"`，而是使用
    `@angular/common` 包中的 `isPlatformBrowser` 函数，仅在平台是 `browser` 时获取数据（在生成 App Shell
    时不是这种情况）。
- en: We then verify the App Shell in *step 4* and *step 5*. These commands generate
    an Angular build in production mode with the App Shell (non-minified code), and
    then serve the project on port `4200`, respectively. Note that the `ng-pwa-app-shell`
    folder in the `start/dist/apps/chapter13/ng-pwa-app-shell` folder has two folders
    inside, that is, the `browser` folder and the `server` folder, and our `index.html`
    resides in the `browser` folder. The code inside `index.html` is pre-rendered
    at build time. This means Angular opens the app and renders the `UsersComponent`,
    including the search input and skeleton loaders, at build time. So, as soon as
    the app opens, the content is pre-rendered. Once we’re done with all these steps,
    we install the PWA to test it out.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在 *步骤 4* 和 *步骤 5* 中验证 App Shell。这些命令分别生成带有 App Shell 的 Angular 生产模式构建（非最小化代码），并在端口
    `4200` 上提供项目。请注意，`start/dist/apps/chapter13/ng-pwa-app-shell` 文件夹中的 `ng-pwa-app-shell`
    文件夹有两个文件夹，即 `browser` 文件夹和 `server` 文件夹，我们的 `index.html` 位于 `browser` 文件夹中。`index.html`
    中的代码在构建时预渲染。这意味着 Angular 在构建时打开应用程序并渲染 `UsersComponent`，包括搜索输入和骨架加载器。因此，一旦应用程序打开，内容就被预渲染。完成所有这些步骤后，我们安装
    PWA 以进行测试。
- en: Now that you know how the recipe works, see the next section for links to further
    reading.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了配方的工作原理，请查看下一节以获取进一步阅读的链接。
- en: See also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular App Shell guide: [https://angular.io/guide/app-shell](https://angular.io/guide/app-shell)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular App Shell 指南：[https://angular.io/guide/app-shell](https://angular.io/guide/app-shell)
- en: 'The App Shell model (web fundamentals by Google): [https://developers.google.com/web/fundamentals/architecture/app-shell](https://developers.google.com/web/fundamentals/architecture/app-shell)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Shell 模型（谷歌的 Web 基础）：[https://developers.google.com/web/fundamentals/architecture/app-shell](https://developers.google.com/web/fundamentals/architecture/app-shell)
- en: '**Critical Rendering Path** (**CRP**): [https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path](https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键渲染路径**（**CRP**）：[https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path](https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path)'
- en: Learn more on Discord
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_13.xhtml)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_13.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/QR_Code1388317275422265.png)**'
