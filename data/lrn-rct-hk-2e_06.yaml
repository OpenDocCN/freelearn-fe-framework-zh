- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Using the Reducer and Effect Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Reducer 和 Effect Hooks
- en: After developing our own blog application using the State Hook, we are now going
    to learn about two other very important Hooks that are provided by React—the **Reducer**
    and **Effect** Hooks. We will first learn when we should use a Reducer Hook instead
    of a State Hook. Then, we will learn how to turn our existing State Hook into
    a Reducer Hook to get a grasp on the concept in practice. Finally, we are going
    to learn about Effect Hooks and what they are used for and implement them in our
    blog application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 State Hook 开发我们自己的博客应用程序之后，我们现在将学习 React 提供的另外两个非常重要的 Hooks——**Reducer**
    和 **Effect** Hooks。我们首先将学习何时应该使用 Reducer Hook 而不是 State Hook。然后，我们将学习如何将现有的 State
    Hook 转换为 Reducer Hook，以便在实践中掌握这个概念。最后，我们将学习 Effect Hooks 的用途以及如何在我们的博客应用程序中实现它们。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Reducer Hooks versus State Hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer Hooks 与 State Hooks 的比较
- en: Using Reducer Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Reducer Hooks
- en: Using Effect Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Effect Hooks
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了相当新的 Node.js 版本。Node 包管理器 (`npm`) 也需要安装（它应该与 Node.js 一起提供）。有关如何安装 Node.js
    的更多信息，请查看他们的官方网站：[https://nodejs.org/](https://nodejs.org/)。
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的指南中，我们将使用 **Visual Studio Code** （**VS Code**），但在任何其他编辑器中都应该以类似的方式工作。有关如何安装
    VS Code 的更多信息，请参阅他们的官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)。
- en: 'In this book, we use the following versions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: npm v10.9.2
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm v10.9.2
- en: Visual Studio Code v1.97.2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code v1.97.2
- en: While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安装新版本不应该有问题，但请注意，某些步骤在较新版本上可能会有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter04).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter04)。
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided in the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Reducer Hooks versus State Hooks
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducer Hooks 与 State Hooks 的比较
- en: In the previous chapter, we learned about dealing with local and global states.
    We used State Hooks for both cases, which is fine for simple state changes. However,
    if our state logic becomes more complicated, we are going to need to ensure that
    we keep the state consistent. To do so, we should use a Reducer Hook, instead
    of multiple State Hooks, because it is harder to maintain synchronicity between
    multiple State Hooks that depend on each other. As an alternative, we could keep
    all states in one State Hook, but then we have to make sure that we don’t accidentally
    overwrite parts of our state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了处理局部和全局状态。我们在这两种情况下都使用了 State Hooks，这对于简单的状态更改来说是可行的。然而，如果我们的状态逻辑变得更加复杂，我们需要确保保持状态的一致性。为此，我们应该使用
    Reducer Hook，而不是多个 State Hooks，因为维护多个相互依赖的 State Hooks 之间的同步性更困难。作为替代方案，我们可以将所有状态保存在一个
    State Hook 中，但这时我们必须确保不会意外地覆盖我们的状态的一部分。
- en: Limitations of the State Hook
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: State Hook 的局限性
- en: 'The State Hook already supports passing complex objects and arrays to it, and
    it can handle their state changes perfectly fine. However, we are always going
    to have to change the state directly, which means that we need to use a lot of
    destructuring to make sure that we are not overwriting other parts of the state.
    For example, imagine that we have a State Hook like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 状态钩子已经支持传递复杂对象和数组给它，并且它可以完美地处理它们的状态变化。然而，我们始终需要直接更改状态，这意味着我们需要使用大量的解构来确保我们没有覆盖状态的其他部分。例如，想象我们有一个如下所示的状态钩子：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s say we want to change the filter, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想按照以下方式更改过滤器：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we simply did this, we would be removing the `expandPosts` setting from
    our state object! So, we need to use the spread operator, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是这样做，我们就会从状态对象中删除`expandPosts`设置！因此，我们需要使用扩展运算符，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we wanted to change the `fromDate` filter to a different date, we would
    need to use the spread operator twice, to avoid accidentally removing the `author`
    filter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想将`fromDate`过滤器更改为不同的日期，我们需要使用两次扩展运算符，以避免意外删除`author`过滤器：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But what happens if we do this when the `filter` state is still a string, as
    it was in the original object (`filter: ''all''`)? We are going to get the following
    result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '但如果我们这样做时`filter`状态仍然是字符串，就像原始对象中那样（`filter: ''all''`），会发生什么？我们将得到以下结果：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What? Why are there suddenly three new keys—`'0'`, `'1'`, and `'2'`? The answer
    is, the spread operator also works on strings, which are spread in a way where
    each letter gets a key, based on its index in the string.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？为什么突然出现了三个新的键——`'0'`、`'1'`和`'2'`？答案是，扩展运算符也适用于字符串，字符串以这种方式展开，每个字母都根据其在字符串中的索引获得一个键。
- en: As you can imagine, using the spread operator and changing the state object
    directly can become very tedious for larger state objects. Additionally, we always
    need to make sure that we don’t introduce any bugs, and we need to check for bugs
    in multiple places across our app.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，使用扩展运算符和直接改变状态对象对于较大的状态对象来说可能会变得非常繁琐。此外，我们始终需要确保不会引入任何错误，并且我们需要在我们的应用程序的多个地方检查错误。
- en: Reducers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reducers
- en: 'Instead of changing the state directly, we could make a function that deals
    with state changes. Such a function is called a **reducer**, and works as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接改变状态，而是可以创建一个处理状态变化的函数。这样的函数被称为**reducer**，它的工作方式如下：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, instead of directly changing the state object, we are calling
    a function that takes the current state and an action object and returns a new
    state object. Before we define the function, let’s first take a closer look at
    actions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不是直接改变状态对象，而是调用一个函数，该函数接受当前状态和动作对象，并返回一个新的状态对象。在我们定义函数之前，让我们首先更详细地看看动作。
- en: Actions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Actions
- en: '**Actions** are objects that have a `type` property that contains the action
    name, and optionally some additional info about the action.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作**是具有包含动作名称的`type`属性的对象，并且可以包含有关动作的一些附加信息。'
- en: 'Let’s revisit our state object from earlier:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前的状态对象：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we wanted to change the `expandPosts` state, we would use a `TOGGLE_EXPAND`
    action, which does not need any additional info. The action would then look as
    follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想改变`expandPosts`状态，我们会使用`TOGGLE_EXPAND`动作，这个动作不需要任何额外的信息。动作将如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we would like to change the filter instead, we would use a `CHANGE_FILTER`
    action, which additionally contains information about the filter that should be
    changed. For example, we could use the following actions to change the filter
    in different ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想改变过滤器，我们会使用`CHANGE_FILTER`动作，该动作还包含有关应更改的过滤器的信息。例如，我们可以使用以下动作以不同的方式更改过滤器：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second, third, and fourth actions would change the `filter` state from
    a string to an object and then set the respective key. If the object already exists,
    it would simply adjust the keys that were defined in the action. After each of
    these actions, the state would change as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二、第三和第四个动作会将`filter`状态从字符串更改为对象，并设置相应的键。如果对象已经存在，它将简单地调整动作中定义的键。在这些动作之后，状态将按以下方式改变：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let’s imagine that we applied the following action:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们应用了以下动作：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After this action, the filter would go back to the `'all'` string, as it was
    in its initial state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动作之后，过滤器将回到初始状态的`'all'`字符串。
- en: If you have worked with the Redux library before, you will already be familiar
    with the concepts of state, actions, and reducers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过Redux库，你将已经熟悉状态、动作和reducer的概念。
- en: Defining reducers
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义reducer
- en: 'A reducer function for the actions we defined could look as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的动作的reducer函数可能看起来如下：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we defined the function and are deciding what to do to the state based
    on the `action.type`. First, we handle the `TOGGLE_EXPAND` action:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了函数，并根据`action.type`决定对状态进行什么操作。首先，我们处理`TOGGLE_EXPAND`动作：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, the `CHANGE_FILTER` function is handled, where we reset the filter to
    the string `''all''` if the action defined the `all: true` filter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，处理`CHANGE_FILTER`函数，其中如果动作定义了`all: true`过滤器，我们将过滤器重置为字符串`''all''`：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the filter is still a string, we initialize an empty object; otherwise,
    we reuse the existing object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过滤器仍然是一个字符串，我们初始化一个空对象；否则，我们重用现有的对象：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can set the `fromDate` and `author` filters, depending on which ones
    were defined in the action:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据动作中定义的设置`fromDate`和`author`过滤器：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, the state is returned with the new filter:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，状态被返回为新的过滤器：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the case where an action type is unknown, we throw an error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动作类型未知，我们将抛出一个错误：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Throwing an error in the default case is different from what we would do with
    Redux reducers, where we would simply return the current state in the default
    case. React Reducer Hooks do not store all states in one global object and we
    are only going to handle certain actions for certain state objects, so we can
    throw an error for unknown action types.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认情况下抛出错误与我们在Redux reducer中做的不同，在Redux reducer中，我们会在默认情况下简单地返回当前状态。React Reducer
    Hooks不会在单个全局对象中存储所有状态，我们只为某些状态对象处理某些动作，因此我们可以为未知动作类型抛出错误。
- en: While we are still using some spread operators in the reducer function, it is
    not as deeply nested. Additionally, all the state handling is in one place and
    we are only changing one part of the state at a time through actions, making the
    code much easier to maintain and less error-prone.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仍在reducer函数中使用一些扩展运算符时，它并不像之前那样深层嵌套。此外，所有状态处理都在一个地方，我们通过动作一次只更改状态的一部分，这使得代码更容易维护且更少出错。
- en: The Reducer Hook
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reducer Hook
- en: 'Now that we have a reducer function, we just need to define an initial state:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了reducer函数，我们只需要定义一个初始状态：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the reducer function and the initial state, we can create a Reducer Hook:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用reducer函数和初始状态，我们可以创建一个Reducer Hook：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The current state can now be accessed via the `state` object returned from
    the Hook. Using the `dispatch` function allows us to invoke the reducer function
    that we passed to the Reducer Hook. Actions can be **dispatched** via the `dispatch`
    function. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过从Hook返回的`state`对象访问当前状态。使用`dispatch`函数允许我们调用传递给Reducer Hook的reducer函数。动作可以通过`dispatch`函数**分发**。例如：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dispatching an action will call the reducer function with the current state
    and the dispatched action, and set the returned state as the new state of the
    Reducer Hook.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 分发一个动作将调用reducer函数，并带上当前状态和分发的动作，并将返回的状态设置为Reducer Hook的新状态。
- en: 'If we want to add additional info to the action, we can simply add it to the
    object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在动作中添加额外的信息，我们只需将其添加到对象中：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see, dealing with state changes using actions and reducers is much
    easier to read and maintain than having to adjust the state object directly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用动作和reducer处理状态变化比直接调整状态对象更容易阅读和维护。
- en: Now that we have learned about Reducer Hooks and when to use them instead of
    State Hooks, let’s get started with using them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Reducer Hooks以及何时使用它们而不是State Hooks，让我们开始使用它们。
- en: Using Reducer Hooks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reducer Hooks
- en: After learning about actions, reducers, and the Reducer Hook, we are going to
    use it in our blog app. Any existing State Hook can be turned into a Reducer Hook
    when the state or state changes become too complex.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解动作、reducer和Reducer Hook之后，我们将在我们的博客应用中使用它。任何现有的State Hook都可以在状态或状态变化变得过于复杂时转换为Reducer
    Hook。
- en: If there are multiple `setState` functions that are always called at the same
    time, it is a good hint that they should be grouped together in a single Reducer
    Hook.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个`setState`函数总是在同一时间被调用，这是一个很好的提示，它们应该被组合在一个单独的Reducer Hook中。
- en: Global state is usually a good candidate for using a Reducer Hook, rather than
    a State Hook, because changes to it can happen anywhere in the app. It is much
    easier to deal with state changes when they only get processed in one function
    and the components dispatch actions instead of directly modifying the state. Having
    all the state-changing logic in one place makes it easier to maintain and fix
    bugs, without introducing new ones by forgetting to update the logic everywhere.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态通常适合使用 Reducer Hook，而不是 State Hook，因为它的更改可以在应用的任何地方发生。当状态更改只在一个函数中处理，并且组件分发动作而不是直接修改状态时，处理状态更改要容易得多。将所有状态更改逻辑放在一个地方使得维护和修复错误变得更容易，而不会因为忘记更新逻辑而在任何地方引入新的错误。
- en: Turning a State Hook into a Reducer Hook
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 State Hook 转换为 Reducer Hook
- en: 'In our blog app, we have two global State Hooks:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客应用中，我们有两个全局 State Hook：
- en: The `username` state – containing the username of the currently logged-in user
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username` 状态 – 包含当前登录用户的用户名'
- en: The `posts` state – containing all the posts in our feed
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`posts` 状态 – 包含我们动态中的所有帖子'
- en: 'The `username` state is quite simple, it only contains a string of the username.
    So, at the moment, it does not make sense to turn this into a Reducer Hook, as
    the state changes are straightforward:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`username` 状态相当简单，它只包含一个用户名的字符串。因此，目前将此转换为 Reducer Hook 没有意义，因为状态更改是直接的：'
- en: 'On login/register: Set the username'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在登录/注册时：设置用户名
- en: 'On logout: Clear the username'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注销时：清除用户名
- en: For the `posts` state, however, we already needed to use the spread operator
    to avoid accidentally removing posts from the feed when creating a new post. So,
    it seems like a good candidate for a Reducer Hook, especially considering that
    it might be extended in the future (fetching new posts, updating posts, deleting
    posts, etc.).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `posts` 状态，我们之前已经需要使用扩展运算符来避免在创建新帖子时意外地从动态中删除帖子。因此，它似乎是一个很好的 Reducer Hook
    候选，特别是考虑到它可能在未来扩展（获取新帖子、更新帖子、删除帖子等）。
- en: Now, let’s get started with replacing the `posts` State Hook with a Reducer
    Hook.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始用 Reducer Hook 替换 `posts` State Hook。
- en: Defining actions
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义动作
- en: 'We start by defining actions for our Reducer Hook. For now, we are only going
    to consider a `CREATE_POST` action:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为我们的 Reducer Hook 定义动作。目前，我们只考虑 `CREATE_POST` 动作：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we are going to implement the reducer function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 reducer 函数。
- en: Implementing the reducer
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 reducer
- en: For now, we are going to place our reducer in a `src/reducers.js` file. Later,
    if we have many reducers, it might make sense to create a separate `src/reducers/`
    folder, with separate files for each reducer function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将把我们的 reducer 放在 `src/reducers.js` 文件中。稍后，如果我们有多个 reducer，可能有必要创建一个单独的
    `src/reducers/` 文件夹，并为每个 reducer 函数创建单独的文件。
- en: 'Let’s get started with implementing the reducer function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现 reducer 函数：
- en: 'Copy the `Chapter03_2` folder to a new `Chapter04_1` folder by executing the
    following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter03_2` 文件夹复制到新的 `Chapter04_1` 文件夹：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open the new `Chapter04_1` folder in VS Code.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter04_1` 文件夹。
- en: 'Create a new `src/reducers.js` file, in which we define and export the `postsReducer`
    function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/reducers.js` 文件，在其中定义并导出 `postsReducer` 函数：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use a `switch` statement to handle the different action types:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `switch` 语句来处理不同的动作类型：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, handle the `CREATE_POST` action, inserting the new post (from `action.post`)
    into the beginning of the array, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，处理 `CREATE_POST` 动作，将新帖子（来自 `action.post`）插入数组的开头，如下所示：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For now, this will be the only action type that we handle, so we can define
    the `default` statement now, throwing an error when we encounter an unknown action
    type:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，这将是我们要处理的唯一动作类型，因此我们现在可以定义 `default` 语句，当遇到未知动作类型时抛出错误：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After defining the reducer function, we can now use it to define a Reducer Hook.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 reducer 函数后，我们现在可以使用它来定义 Reducer Hook。
- en: Defining the Reducer Hook
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 Reducer Hook
- en: 'To define a Reducer Hook, follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义 Reducer Hook，请按照以下步骤操作：
- en: 'Edit `src/App.jsx` and import the `useReducer` and `postsReducer` functions:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/App.jsx` 并导入 `useReducer` 和 `postsReducer` 函数：
- en: '[PRE28]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Remove* the following State Hook:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 以下 State Hook：'
- en: '[PRE29]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Replace* it with a Reducer Hook:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为 Reducer Hook：'
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, instead of `setPosts`, pass the `dispatch` function to the `CreatePost`
    component, and *remove* the `setPosts` prop:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，而不是 `setPosts`，将 `dispatch` 函数传递给 `CreatePost` 组件，并 *删除* `setPosts` 属性：
- en: '[PRE31]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, edit `src/post/CreatePost.jsx` and *replace* the `setPosts` prop with
    the `dispatch` prop:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑 `src/post/CreatePost.jsx` 并将 `setPosts` 属性替换为 `dispatch` 属性：
- en: '[PRE32]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of imperatively adding the new post, we dispatch an action inside the
    `handleSubmit` function now:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在不再以命令式的方式添加新帖子，而是在 `handleSubmit` 函数内部分发一个动作：
- en: '[PRE33]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For more complex actions, it might make sense to define functions that will
    create the action object, so-called **action creators**. For example, a `createPostAction(post)`
    function could create and return the `CREATE_POST` action object. Action creators
    can help ensure a consistent structure of action objects, make it easier for us
    to create them, and allow for this structure to be adjusted easily in the future.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的动作，定义将创建动作对象的函数（所谓的 **动作创建器**）可能是有意义的。例如，一个 `createPostAction(post)` 函数可以创建并返回
    `CREATE_POST` 动作对象。动作创建器可以帮助确保动作对象的一致结构，使我们更容易创建它们，并允许在未来轻松调整这种结构。
- en: Now the `posts` state uses a Reducer Hook instead of a State Hook, but it works
    the same way as before! If we want to add more logic for managing posts later,
    such as deleting and editing posts, it will be much easier to do so now.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的 `posts` 状态使用 Reducer 钩子而不是 State 钩子，但它的功能与之前相同！如果我们想在以后添加更多用于管理帖子的逻辑，例如删除和编辑帖子，现在将更容易做到这一点。
- en: '**Example code**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter04/Chapter04_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter04/Chapter04_1` 文件夹中找到。请检查文件夹内的 `README.md` 文件，以获取设置和运行示例的说明。
- en: After learning about the Reducer Hook, let’s continue learning about the Effect
    Hook.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了 Reducer 钩子之后，让我们继续学习 Effect 钩子。
- en: Using Effect Hooks
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Effect 钩子
- en: The Effect Hook is an important Hook to synchronize your components with external
    systems, such as external APIs or the browser APIs. However, it is often overused
    in React code. If there is no external system involved, you should not use an
    Effect Hook.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Effect 钩子是一个重要的钩子，用于将组件与外部系统（如外部 API 或浏览器 API）同步。然而，在 React 代码中它经常被过度使用。如果没有外部系统参与，你不应该使用
    Effect 钩子。
- en: In the case of our blog, we are going to implement a way to check whether the
    user has an admin role in the `Logout` component. For simplicity, and to focus
    on the Effect Hook itself, we are simply going to mock this check, but imagine
    that this is being done by an external API.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们博客的例子中，我们将在 `Logout` 组件中实现一种检查用户是否有管理员角色的方法。为了简单起见，并专注于 Effect 钩子本身，我们只是简单地模拟这个检查，但想象一下这是由外部
    API 完成的。
- en: Remember componentDidMount and componentDidUpdate?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记得 componentDidMount 和 componentDidUpdate 吗？
- en: 'If you have worked with older React versions before, you have probably used
    the `componentDidMount` and `componentDidUpdate` life cycle methods. For example,
    if we wanted to set the title of a web page to a given prop using React class
    components, we would need to add the following life cycle method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过较老的 React 版本，你可能已经使用过 `componentDidMount` 和 `componentDidUpdate` 生命周期方法。例如，如果我们想使用
    React 类组件将网页标题设置为给定的属性，我们需要添加以下生命周期方法：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This works fine. However, when the `title` prop updates, the change does not
    get reflected in the title of our web page. To solve this problem, we need to
    define the `componentDidUpdate` life cycle method, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好。然而，当 `title` 属性更新时，变化并没有反映在我们的网页标题上。为了解决这个问题，我们需要定义 `componentDidUpdate`
    生命周期方法，如下所示：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You might have noticed that we are doing the exact same thing twice; therefore,
    we could create a new method to deal with updates to the title, and then call
    it from both life cycle methods. In the following code block, the updated code
    is highlighted in bold:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们正在做完全相同的事情两次；因此，我们可以创建一个新的方法来处理标题的更新，然后从两个生命周期方法中调用它。在下面的代码块中，更新的代码以粗体显示：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, we still need to call `this.updateTitle()` twice. When we update the
    code later on, and, for example, pass an argument to `this.updateTitle()`, we
    always need to remember to pass it to both calls to the function. If we forget
    to update one of the life cycle methods, we might introduce bugs. Additionally,
    we need to add an `if` condition to `componentDidUpdate`, in order to avoid calling
    `this.updateTitle()` when the `title` prop did not change.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要调用 `this.updateTitle()` 两次。当我们稍后更新代码，例如向 `this.updateTitle()` 传递一个参数时，我们始终需要记得将其传递给函数的两个调用。如果我们忘记更新其中一个生命周期方法，我们可能会引入错误。此外，我们需要在
    `componentDidUpdate` 中添加一个 `if` 条件，以避免在 `title` 属性没有变化时调用 `this.updateTitle()`。
- en: From life cycle methods to Effect Hooks
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从生命周期方法到 Effect 钩子
- en: In the world of Hooks, the `componentDidMount` and `componentDidUpdate` life
    cycle methods are combined in the `useEffect` Hook, which—when not specifying
    a **dependency array**—triggers on every re-render. We will learn more about the
    dependency array in the next sub-section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hooks 的世界中，`componentDidMount` 和 `componentDidUpdate` 生命周期方法被合并到 `useEffect`
    钩子中，当不指定 **依赖数组** 时，它会在每次重新渲染时触发。我们将在下一小节中了解更多关于依赖数组的内容。
- en: 'So, instead of using a class component, we can now define a function component
    with an Effect Hook, which would do the same thing as before:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不再需要使用类组件，现在我们可以定义一个带有 Effect 钩子的函数组件，它将完成与之前相同的事情：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: And that’s all we need to do! The Effect Hook will call the provided function
    every time when the component re-renders.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的全部！每当组件重新渲染时，Effect 钩子都会调用提供的函数。
- en: Since React 19, it is possible to change the title (or any metadata tags) of
    a web page by defining a `<title>` (or `<link>` or `<meta>`) element in any component.
    These elements will then automatically be hoisted up into the `<head>` section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 自 React 19 以来，通过在任意组件中定义 `<title>`（或 `<link>` 或 `<meta>`）元素，可以更改网页的标题（或任何元数据标签）。然后，这些元素将自动提升到
    `<head>` 部分。
- en: Triggering an effect only when certain props change
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅在特定 props 发生变化时触发效果
- en: 'If we want to make sure that our effect function only gets called when the
    `title` prop changes, we can specify which values should trigger the changes,
    as a second argument to the `useEffect` Hook—the dependency array:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想确保我们的效果函数仅在 `title` prop 发生变化时被调用，我们可以指定应该触发变化的值，作为 `useEffect` 钩子的第二个参数——依赖数组：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The dependency array is not just restricted to props; we can use any value
    that is available from inside the component body here, even variables defined
    inside the component and values from other Hooks, such as a State Hook or a Reducer
    Hook:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖数组不仅限于 props；我们还可以使用从组件体内可用的任何值，包括在组件内部定义的变量和其他 Hook 的值，例如 State Hook 或 Reducer
    Hook：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, using an Effect Hook is much more straightforward than dealing
    with life cycle methods. All we need to specify is which values the Effect Hook
    should depend on. Whenever any of these values change, the effect function automatically
    gets called again.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 Effect 钩子比处理生命周期方法要简单得多。我们只需要指定 Effect 钩子应依赖于哪些值。每当这些值中的任何一个发生变化时，效果函数会自动再次被调用。
- en: Triggering an effect only on mount
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅在挂载时触发效果
- en: 'If we want to replicate the behavior of only adding a `componentDidMount` life
    cycle Hook, without triggering when the props change, we can do this by passing
    an empty array as the second argument to the `useEffect` Hook:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想添加 `componentDidMount` 生命周期钩子的行为，而不在 props 发生变化时触发，我们可以通过将空数组作为 `useEffect`
    钩子的第二个参数来做到这一点：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Passing an empty array means that our effect function will only trigger once
    when the component mounts, and it will not trigger when props change. However,
    instead of thinking about the mounting of components, with Hooks, we should think
    about the dependencies of the effects. In this case, the effect does not have
    any dependencies, which means it will only trigger once. If an effect has dependencies
    specified, it will trigger again when any of the dependencies change.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 传递空数组意味着我们的效果函数仅在组件挂载时触发一次，并且当 props 发生变化时不会触发。然而，与组件的挂载相比，使用 Hooks，我们应该考虑效果依赖。在这种情况下，效果没有依赖，这意味着它只会触发一次。如果一个效果有指定的依赖，那么当任何依赖发生变化时，它将再次触发。
- en: Cleaning up effects
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理效果
- en: 'Sometimes effects need to be cleaned up when the component unmounts. To do
    so, we can return a function from the Effect Hook. This returned function works
    similarly to the `componentWillUnmount` life cycle method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在组件卸载时需要清理效果。为此，我们可以从 Effect 钩子中返回一个函数。这个返回的函数与 `componentWillUnmount` 生命周期方法的工作方式类似：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The highlighted code is called the **cleanup function**. The cleanup function
    will be called when the component unmounts and before running the effect again.
    This avoids bugs when, for example, the `updateTime` prop changes. In that case,
    the previous effect will be cleaned up and an interval with the new `updateTime`
    will be defined.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码被称为 **清理函数**。当组件卸载并再次运行效果之前，清理函数会被调用。这避免了例如 `updateTime` prop 发生变化时的错误。在这种情况下，先前的效果将被清理，并定义一个新的
    `updateTime` 间隔。
- en: Implementing an Effect Hook in our blog app
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的博客应用中实现 Effect 钩子
- en: Now that we have learned how the Effect Hook works, we are going to use it in
    our blog app, to implement a way to check the user role when the user is already
    logged in.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Effect Hook 的工作原理，我们将在我们的博客应用中使用它，以实现当用户已经登录时检查用户角色的方法。
- en: 'Let’s implement an Effect Hook by following these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤实现一个 Effect Hook：
- en: 'Copy the `Chapter04_1` folder to a new `Chapter04_2` folder by executing the
    following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter04_1` 文件夹复制到新的 `Chapter04_2` 文件夹：
- en: '[PRE42]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open the new `Chapter04_2` folder in VS Code.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter04_2` 文件夹。
- en: 'Edit `src/user/Logout.jsx` and import the `useState` and `useEffect` functions:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/user/Logout.jsx` 并导入 `useState` 和 `useEffect` 函数：
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, define a function that simulates an external API that checks the role
    of a user:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个函数，该函数模拟一个检查用户角色的外部 API：
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the sake of simplicity, we say that any user called `admin` has the `admin`
    role. All others have the `user` role:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化，我们说任何名为 `admin` 的用户都具有 `admin` 角色。所有其他用户都具有 `user` 角色：
- en: '[PRE45]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we need to define a State Hook for the role:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为角色定义一个 State Hook：
- en: '[PRE46]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, define an Effect Hook that sets the role by calling the “external API”
    and using its response:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个通过调用“外部 API”并使用其响应来设置角色的 Effect Hook：
- en: '[PRE47]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is best practice to list all values (and functions) that are used within
    an Effect Hook in the dependency array. This ensures that there are no accidental
    bugs when values that seem static at the moment become dynamic later on. Thankfully,
    the React Hooks ESLint plugin (which is already set up in our project) will warn
    us if we forget to add a dependency.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是在依赖数组中列出所有在 Effect Hook 中使用的值（和函数）。这确保了在值看起来是静态的当前时刻，它们在以后变得动态时不会出现意外的错误。幸运的是，React
    Hooks ESLint 插件（已经在我们的项目中设置）会警告我们，如果我们忘记添加依赖项。
- en: 'Finally, we display the role if a user has a special role:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示用户具有特殊角色时的角色：
- en: '[PRE48]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Start the blog app by executing the following command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令启动博客应用：
- en: '[PRE49]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Try logging in with the username `admin`. You will see that the role is now
    being displayed next to the username!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用用户名 `admin` 登录。你会看到角色现在显示在用户名旁边！
- en: '**Example code**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter04/Chapter04_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码位于 `Chapter04/Chapter04_2` 文件夹中。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned about actions, reducers, and Reducer Hooks.
    We also learned when we should use Reducer Hooks instead of State Hooks. Then,
    we replaced our existing global State Hook for the `posts` state with a Reducer
    Hook. Next, we learned about Effect Hooks, and how they can be used instead of
    `componentDidMount` and `componentDidUpdate` life cycle methods. Finally, we implemented
    role verification in our blog app by using an Effect Hook.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了动作、reducer 和 Reducer Hook。我们还学习了何时应该使用 Reducer Hook 而不是 State Hook。然后，我们将现有的
    `posts` 状态的全局 State Hook 替换为 Reducer Hook。接下来，我们学习了 Effect Hook，以及它们如何替代 `componentDidMount`
    和 `componentDidUpdate` 生命周期方法。最后，我们通过使用 Effect Hook 在我们的博客应用中实现了角色验证。
- en: In the next chapter, we are going to learn about React Context, and how to use
    it with Hooks. Then, we are going to add Context Hooks to our app, to avoid having
    to pass down props over multiple layers of components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 React Context 以及如何使用 Hooks。然后，我们将向我们的应用添加 Context Hooks，以避免在多个组件层传递
    props。
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章所学内容，尝试回答以下问题：
- en: What are the common problems with State Hooks?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: State Hook 常见的问题有哪些？
- en: What are actions?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作是什么？
- en: What are reducers?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reducer 是什么？
- en: When should we use a Reducer Hook instead of a State Hook?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么情况下使用 Reducer Hook 而不是 State Hook？
- en: Which steps are needed to turn a State Hook into a Reducer Hook?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要哪些步骤才能将 State Hook 转换为 Reducer Hook？
- en: How could we create actions more easily?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更轻松地创建动作？
- en: What is the equivalent of Effect Hooks in class components?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Effect Hook 在类组件中的等效物是什么？
- en: What are the advantages of using an Effect Hook, versus class components?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与类组件相比，使用 Effect Hook 的优点是什么？
- en: What is the dependency array and how does it work?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖数组是什么，它是如何工作的？
- en: How can cleanup functions be used with Effect Hooks?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 Effect Hooks 与清理函数一起使用？
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in learning more about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章学到的概念感兴趣，想了解更多，请查看以下链接：
- en: 'Official docs regarding the Reducer Hook: [https://react.dev/reference/react/useReducer](https://react.dev/reference/react/useReducer)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Reducer Hook的官方文档：[https://react.dev/reference/react/useReducer](https://react.dev/reference/react/useReducer)
- en: 'Official docs and tips for using Effect Hooks: [https://react.dev/reference/react/hooks#effect-hooks](https://react.dev/reference/react/hooks#effect-hooks)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Effect Hooks的官方文档和技巧：[https://react.dev/reference/react/hooks#effect-hooks](https://react.dev/reference/react/hooks#effect-hooks)
- en: 'More information on when an Effect Hook should not be used: [https://react.dev/learn/you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于何时不应使用Effect Hook的更多信息：[https://react.dev/learn/you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)
- en: 'More information about Redux, a library that offers a more extensive version
    of actions and reducers: [https://redux.js.org](https://redux.js.org)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Redux的更多信息，这是一个提供更广泛动作和reducer版本的库：[https://redux.js.org](https://redux.js.org)
- en: Learn more on Discord
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_04.xhtml)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_04.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_%283%29.png)'
