- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Deployment Targets, Adapters, and Stacks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署目标、适配器和栈
- en: During runtime, Remix runs on an underlying web server and handles incoming
    HTTP requests. Starting a new Remix project also means selecting a web server
    and JavaScript runtime. The Remix team and its community maintain starter templates
    and adapters for many popular deployment targets. In this chapter, we will review
    different deployment targets, templates, and Remix stacks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Remix在底层Web服务器上运行并处理传入的HTTP请求。启动一个新的Remix项目也意味着选择一个Web服务器和JavaScript运行时。Remix团队及其社区为许多流行的部署目标维护了入门模板和适配器。在本章中，我们将回顾不同的部署目标、模板和Remix
    Stacks。
- en: 'We’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Picking a deployment target
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择部署目标
- en: Switching between adapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适配器之间切换
- en: Using Remix Stacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Remix Stacks
- en: Working with BeeRich
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与BeeRich合作
- en: First, we will provide an overview of popular templates, deployment targets,
    JavaScript runtimes, and hosting environments. Next, will practice switching adapters
    and introduce you to Remix Stacks. At the end of this chapter, we will bootstrap
    a new Remix application using the custom template for this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述流行的模板、部署目标、JavaScript运行时和托管环境。接下来，我们将练习切换适配器，并介绍Remix Stacks。在本章结束时，我们将使用本书的定制模板启动一个新的Remix应用程序。
- en: After working through this chapter, you will know what to consider when picking
    a deployment target and template for a new Remix app. You will also learn more
    about different JavaScript runtimes and understand the main differences between
    long-running server, serverless, and edge environments. Additionally, you will
    gain practical experience switching between adapters and learn how to work with
    Remix Stacks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章学习后，你将了解在选择新的Remix应用程序的部署目标和模板时需要考虑的因素。你还将了解更多关于不同的JavaScript运行时，并理解长期运行的服务器、无服务器和边缘环境之间的主要区别。此外，你将获得在适配器之间切换的实践经验，并学习如何与Remix
    Stacks一起工作。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need a computer that can run Node.js. All
    popular operating systems should suffice. Please install both Node.js and npm
    on your machine. An editor such as VS Code is recommended.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章，你需要一台可以运行Node.js的计算机。所有流行的操作系统都足够使用。请在您的机器上安装Node.js和npm。推荐使用VS Code等编辑器。
- en: 'You can download Node.js and npm here: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载Node.js和npm：[https://nodejs.org/en/download/](https://nodejs.org/en/download/).
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下链接找到：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks).
- en: Picking a deployment target
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择部署目标
- en: One of Remix’s most significant features is its flexibility. Remix supports
    many different web servers and runtime environments, including serverless and
    edge environments. Selecting a template also means choosing a JavaScript runtime,
    a hosting environment (server, serverless, edge), and potentially a hosting provider
    platform. To decide which template to pick for a project, we need to know the
    pros and cons of the different deployment targets to make an informed decision.
    In this section, we provide an overview of popular templates and adapters and
    review their differences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Remix最显著的特点之一是其灵活性。Remix支持许多不同的Web服务器和运行时环境，包括无服务器和边缘环境。选择模板也意味着选择JavaScript运行时、托管环境（服务器、无服务器、边缘）以及可能的主机提供商平台。为了决定为项目选择哪个模板，我们需要了解不同部署目标的优缺点，以便做出明智的决定。在本节中，我们概述了流行的模板和适配器，并回顾了它们之间的区别。
- en: In the previous chapter, we created a new Remix application using the `create-remix`
    CLI script. In the process, we had to specify a template or use Remix’s basic
    template. The Remix team and community maintain adapters and templates for many
    different deployment targets. A template bootstraps a new Remix app with the required
    web server code. The web server code is not part of the Remix framework but is
    shipped with a Remix application to ease the development journey.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用`create-remix` CLI脚本来创建一个新的Remix应用程序。在这个过程中，我们必须指定一个模板或使用Remix的基本模板。Remix团队和社区为许多不同的部署目标维护了适配器和模板。一个模板会使用所需的Web服务器代码启动一个新的Remix应用程序。Web服务器代码不是Remix框架的一部分，但它与Remix应用程序一起分发，以简化开发过程。
- en: In the following, we provide an overview of popular deployment targets for Remix.
    *Table 3.1* lists templates that are maintained by the Remix team and community
    or by hosting provider companies. If a template is not set up for a specific hosting
    provider, then the **Hosting provider** column will show **Generic**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们提供了 Remix 常见部署目标的概述。*表 3.1* 列出了由 Remix 团队和社区或托管提供商公司维护的模板。如果一个模板没有为特定的托管提供商设置，那么**托管提供商**列将显示**通用**。
- en: 'All referenced templates are also listed in the Remix documentation: [https://remix.run/docs/en/dev/other-api/adapter](https://remix.run/docs/en/dev/other-api/adapter).
    Additionally, you can find all templates maintained by the Remix team on GitHub
    in the Remix repository: [https://github.com/remix-run/remix/tree/main/templates](https://github.com/remix-run/remix/tree/main/templates).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引用的模板也列在 Remix 文档中：[https://remix.run/docs/en/dev/other-api/adapter](https://remix.run/docs/en/dev/other-api/adapter)。此外，你还可以在
    GitHub 上的 Remix 仓库中找到 Remix 团队维护的所有模板：[https://github.com/remix-run/remix/tree/main/templates](https://github.com/remix-run/remix/tree/main/templates)。
- en: '| **Deployment target** | **Hosting provider** | **JavaScript runtime** | **Hosting
    environment** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **部署目标** | **托管提供商** | **JavaScript 运行时** | **托管环境** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Architect (Arc) | AWS | Node.js | Serverless |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Architect (Arc) | AWS | Node.js | Serverless |'
- en: '| Cloudflare Pages | Cloudflare | **Workers runtime** | Edge **Isolate** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Cloudflare Pages | Cloudflare | **Workers runtime** | Edge **Isolate** |'
- en: '| Cloudflare Workers | Cloudflare | **Workers runtime** | Edge **Isolate**
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Cloudflare Workers | Cloudflare | **Workers runtime** | Edge **Isolate**
    |'
- en: '| Deno | **Generic** | Deno | Edge **Isolate** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Deno | **Generic** | Deno | Edge **Isolate** |'
- en: '| Express.js | **Generic** | Node.js | Server |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Express.js | **Generic** | Node.js | Server |'
- en: '| Fastify | **Generic** | Node.js | Server |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| Fastify | **Generic** | Node.js | Server |'
- en: '| Fastly Compute@Edge | Fastly | Wasmtime | Edge **Isolate** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Fastly Compute@Edge | Fastly | Wasmtime | Edge **Isolate** |'
- en: '| Fly.io | Fly.io | Node.js | **Distributed Server** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Fly.io | Fly.io | Node.js | **Distributed Server** |'
- en: '| Netlify | Netlify | Node.js | Serverless |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Netlify | Netlify | Node.js | Serverless |'
- en: '| Remix App Server | **Generic** | Node.js | Server |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Remix App Server | **Generic** | Node.js | Server |'
- en: '| Vercel | Vercel | Node.js | Serverless |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Vercel | Vercel | Node.js | Serverless |'
- en: Table 3.1 – Remix’s deployment targets
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – Remix 的部署目标
- en: As visible in the preceding table, many of the deployment targets are tied to
    specific hosting providers. The great thing about hosting service-specific adapters
    is the ease of deployment. You will find that you can get up and running with
    most of these services in a matter of minutes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '如前表所示，许多部署目标都与特定的托管提供商相关联。托管服务特定适配器的优点是部署简单。你会发现，你可以在几分钟内启动并运行这些服务中的大多数。 '
- en: The advantage of generic adapters is the additional flexibility. For example,
    selecting the Express.js deployment target creates an Express.js server that can
    be hosted anywhere where Node.js server can run. This includes cloud computing
    platforms such as AWS, Azure, and Google Cloud Platform and popular hosting platforms
    such as Railway.app and Render.com.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通用适配器的优势在于额外的灵活性。例如，选择 Express.js 部署目标将创建一个 Express.js 服务器，可以在任何 Node.js 服务器可以运行的地方托管。这包括
    AWS、Azure 和 Google Cloud Platform 等云计算平台以及 Railway.app 和 Render.com 等流行的托管平台。
- en: Note that *Table 3.1* is incomplete, as the number of available deployment targets,
    templates, and adapters changes over time. The goal of this chapter is to help
    you effectively pick a deployment target by learning how to categorize and characterize
    them. First, let’s see what is different between the various JavaScript runtimes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*表 3.1* 并不完整，因为可用的部署目标、模板和适配器的数量会随时间变化。本章的目标是通过学习如何分类和描述它们，帮助你有效地选择部署目标。首先，让我们看看各种
    JavaScript 运行时之间的区别。
- en: Picking a JavaScript runtime
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 JavaScript 运行时
- en: JavaScript can be executed in different runtime environments. In this section,
    we list popular JavaScript runtimes and discuss what to consider when selecting
    a runtime.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可以在不同的运行时环境中执行。在本节中，我们列出了流行的 JavaScript 运行时，并讨论了在选择运行时时应考虑的因素。
- en: 'Some popular JavaScript runtime environments are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的 JavaScript 运行时环境如下：
- en: Browser environments
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器环境
- en: Node.js
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: Deno
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deno
- en: Workers runtime
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Workers runtime
- en: Bun
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bun
- en: The browser is JavaScript’s most native environment. However, different browsers
    use different engines to execute JavaScript. Hence, they are technically different
    runtime environments. Luckily, they mostly adhere to the Open Web Platform and
    support the standard JavaScript APIs and runtime behavior. Since we are trying
    to pick a server-side deployment target, we are currently more interested in server-side
    runtimes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器是JavaScript最原生环境。然而，不同的浏览器使用不同的引擎来执行JavaScript。因此，它们在技术上构成了不同的运行时环境。幸运的是，它们大多遵循开放网络平台，并支持标准的JavaScript
    API和运行时行为。由于我们正在尝试选择服务器端部署目标，我们目前对服务器端运行时更感兴趣。
- en: The most prominent server-side runtime for JavaScript is Node.js. Node.js has
    a rich ecosystem of packages and libraries and is widely used and supported. However,
    there are also other server-side JavaScript runtimes, such as Bun, Deno, and Cloudflare’s
    Workers runtime (workerd).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最突出的服务器端运行时是Node.js。Node.js拥有丰富的包和库生态系统，被广泛使用和支持。然而，也存在其他服务器端JavaScript运行时，如Bun、Deno和Cloudflare的Workers运行时（workerd）。
- en: As visible in *Table 3.1*, some deployment targets use Deno or workerd under
    the hood. It is important to understand what this entails for your application
    development. If you are interested in starting a project with Deno or workerd,
    make sure to first familiarize yourself with the underlying runtime.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如*表3.1*所示，一些部署目标在底层使用Deno或workerd。了解这对你的应用程序开发意味着什么非常重要。如果你对使用Deno或workerd开始一个项目感兴趣，请确保首先熟悉底层运行时。
- en: When comparing JavaScript runtimes, we must ensure they support the APIs and
    functionality we require for our application. For instance, workerd is an edge
    runtime that powers Cloudflare Workers. workerd does not support the execution
    of Node.js standard libraries. Consequently, you can use npm packages only if
    these packages do not use Node.js standard libraries. In contrast, most Node.js
    packages work in Deno as Deno aims to be Node.js compatible. You will also be
    able to use most Node.js standard libraries in Deno. However, this requires a
    special import syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 比较JavaScript运行时，我们必须确保它们支持我们应用程序所需的API和功能。例如，workerd是一个边缘运行时，为Cloudflare Workers提供动力。workerd不支持Node.js标准库的执行。因此，只有当这些包不使用Node.js标准库时，你才能使用npm包。相比之下，大多数Node.js包在Deno中都能工作，因为Deno旨在与Node.js兼容。你也将能够在Deno中使用大多数Node.js标准库。然而，这需要特殊的导入语法。
- en: As a Remix developer, it is important to understand that some deployment targets
    are based on different JavaScript runtimes than Node.js. Each runtime comes with
    limitations and considerations. Next, we will investigate the differences between
    different hosting environments.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Remix开发者，了解一些部署目标基于与Node.js不同的JavaScript运行时非常重要。每个运行时都带有限制和考虑因素。接下来，我们将研究不同托管环境之间的差异。
- en: Picking a hosting environment
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择托管环境
- en: The way we host web applications has changed over time. Deploying can be as
    easy as pointing to a GitHub repository and branch or providing a Docker image.
    We rarely manage the underlying server infrastructure ourselves anymore. Instead,
    hosting providers and cloud platforms manage the infrastructure for us and provide
    the environment for our applications to run in.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们托管Web应用的方式随着时间的推移而改变。部署可以简单到指向GitHub仓库和分支或提供Docker镜像。我们很少再自己管理底层服务器基础设施。相反，托管提供商和云平台为我们管理基础设施，并提供我们的应用程序运行的环境。
- en: 'Cloud platforms and hosting providers offer different hosting environments.
    These provide various advantages and disadvantages. As visible in *Table 3.1*,
    the different deployment targets each fit into one of the following three hosting
    environment categories:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台和托管提供商提供不同的托管环境。这些环境各有优缺点。如*表3.1*所示，不同的部署目标适合以下三个托管环境类别之一：
- en: Server
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器
- en: Serverless
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器
- en: Edge
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘
- en: 'Let’s see how the three different hosting environments differ. The following
    table provides an overview of the most important differences:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看三种不同的托管环境有何不同。以下表格概述了最重要的差异：
- en: '| **Trait** | **Server** | **Serverless** | **Edge** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **服务器** | **无服务器** | **边缘** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Long-running | Yes | No | No |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 长运行 | 否 | 是 | 否 |'
- en: '| Filesystem access | Yes (depends) | No | No |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统访问 | 是（视情况而定） | 否 | 否 |'
- en: '| Isolated requests | No | Yes | Yes |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 独立请求 | 否 | 是 | 是 |'
- en: '| Scale by default | No | Yes | Yes |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 默认可扩展 | 否 | 是 | 是 |'
- en: '| Distributed by default | No | No | Yes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 默认分布式 | 否 | 否 | 是 |'
- en: Table 3.2 – Traits of different hosting environments
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 – 不同托管环境的特征
- en: Web servers are considered long-running environments. A web server is usually
    started once and only stops running in case of an upgrade, re-deployment, or when
    the service is sunset. Depending on the hosting provider, web servers have access
    to the filesystem. Long-running servers do not isolate individual requests. This
    means requests share global application states.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器被认为是长期运行的环境。Web服务器通常只启动一次，只有在升级、重新部署或服务停用时才会停止运行。根据托管提供商的不同，Web服务器可以访问文件系统。长期运行的服务器不会隔离单个请求。这意味着请求共享全局应用程序状态。
- en: Serverless environments are fundamentally different from long-running servers.
    Serverless is a cloud computing model in which an application is treated as a
    function and orchestrated by the cloud platform provider. A serverless function
    is started specifically for an incoming request. After a designated timeout, the
    serverless function is terminated, and any application context, such as closures,
    cached application state, and global variables, is lost.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器环境在本质上与长期运行的服务器不同。无服务器是一种云计算模型，其中应用程序被视为一个函数，并由云平台提供商进行编排。无服务器函数专门为传入请求启动。在指定超时后，无服务器函数被终止，并且任何应用程序上下文，如闭包、缓存的程序状态和全局变量，都会丢失。
- en: Serverless environments usually offer pay-per-use pricing. We are only charged
    for the time when our function is handling requests. Since the infrastructure
    provider can spawn multiple duplicate serverless functions in parallel, serverless
    is also inherently highly scalable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器环境通常提供按使用付费的定价。我们只为函数处理请求的时间付费。由于基础设施提供商可以在并行中生成多个重复的无服务器函数，因此无服务器本质上也是高度可扩展的。
- en: It is important to note that serverless environments come with a very different
    set of requirements than web servers. Some things that are easily solved on long-running
    servers require more involvement on serverless. However, the solutions provided
    by serverless are designed to be scalable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，无服务器环境与Web服务器的要求非常不同。在长期运行的服务器上容易解决的问题在无服务器上可能需要更多的参与。然而，无服务器提供的解决方案旨在可扩展。
- en: For instance, web servers create database connections during startup and share
    these connections across all incoming requests. Serverless functions must create
    a new database connection for every incoming request. Creating a new database
    connection can become a bottleneck for incoming requests and may lead to delays
    or timeouts. Additionally, database servers only support a limited number of open
    connections at a time. Opening a new connection per serverless function may exceed
    the maximum number of connections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Web服务器在启动时创建数据库连接，并将这些连接共享给所有传入的请求。无服务器函数必须为每个传入请求创建一个新的数据库连接。创建新的数据库连接可能会成为传入请求的瓶颈，并可能导致延迟或超时。此外，数据库服务器一次只能支持有限数量的打开连接。为每个无服务器函数打开新的连接可能会超过最大连接数。
- en: Serverless offers connection pooling as one way to counteract these issues.
    Connection pooling allows different functions to share connections across different
    instances. This is a common pattern with serverless. Things that work with long-running
    servers require more consideration with serverless. Serverless is designed to
    scale, but scaling also introduces complexity as a byproduct.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器提供连接池作为解决这些问题的方法之一。连接池允许不同的函数在不同实例之间共享连接。这是无服务器中的一种常见模式。与长期运行的服务器一起工作的事物在无服务器中需要更多的考虑。无服务器旨在进行扩展，但扩展也带来了复杂性作为副产品。
- en: Scaling inevitably introduces complexity. Once you need to think about scaling
    long-running servers, you may run into many problems that serverless already solves
    for you. For instance, serverless environments implement load balancing out of
    the box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展不可避免地会引入复杂性。一旦你需要考虑长期服务器的扩展，你可能会遇到许多无服务器已经为你解决的问题。例如，无服务器环境默认实现负载均衡。
- en: Where serverless focus lies on scalability, edge computing focuses on providing
    geographic proximity. Most edge environments are serverless and share the same
    advantages, such as scalability and pay-per-use pricing. What makes edge environments
    special is their proximity to the end users. Edge functions are regionally distributed
    – for instance, on the servers of a CDN. The created proximity can significantly
    decrease response times.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器无服务器关注的是可扩展性，而边缘计算关注的是提供地理邻近性。大多数边缘环境都是无服务器的，并且共享相同的优势，如可扩展性和按使用付费定价。使边缘环境特殊的是它们与最终用户的邻近性。边缘函数是区域分布的——例如，在CDN的服务器上。这种创建的邻近性可以显著减少响应时间。
- en: Most server and serverless environments do not automatically distribute your
    application across different regions, at least not without additional configuration
    overhead and additional costs. Edge computing allows you to distribute your web
    application across the globe out of the box.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务器和无服务器环境不会自动将你的应用程序分布到不同的区域，至少不是在没有额外的配置开销和额外成本的情况下。边缘计算允许你“开箱即用”地将你的Web应用程序分布到全球各地。
- en: Edge environments come with their own limitations and considerations. In general,
    edge functions are the most limiting regarding their runtime capabilities. One
    limitation is that deploying on the edge requires a distributed database solution.
    Otherwise, response times will be delayed by the communication between the edge
    functions and your database server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘环境有其自身的局限性和考虑因素。一般来说，边缘函数在运行时能力方面是最受限制的。一个限制是，在边缘部署需要分布式数据库解决方案。否则，边缘函数与你的数据库服务器之间的通信将导致响应时间延迟。
- en: Different runtime environments also use different container technologies to
    deploy and run your code. Long-running servers can run directly on a physical
    or virtual machine. However, most cloud providers use lightweight container technologies
    to run your app. It's important to note that the container landscape is diverse.
    There are several different container technologies and standards, such as V8 isolates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的运行时环境也使用不同的容器技术来部署和运行你的代码。长期运行的服务器可以直接在物理或虚拟机上运行。然而，大多数云提供商使用轻量级的容器技术来运行你的应用程序。需要注意的是，容器领域是多样化的。有几种不同的容器技术和标准，例如V8隔离。
- en: V8 is the JavaScript engine that powers Chrome and is also used by Node.js and
    Deno. V8 isolates are isolated V8 instances that reuse the same language runtime,
    avoiding the slow cold start of starting a new language runtime on an incoming
    request. Because they're lighter than most container technologies, V8 isolates
    are used in edge environments where computing is sparse in comparison to centralized
    cloud data centers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: V8是Chrome背后的JavaScript引擎，也被Node.js和Deno使用。V8隔离是重用相同语言运行时的隔离V8实例，避免了在接收到的请求上启动新的语言运行时的缓慢冷启动。由于它们比大多数容器技术更轻量级，V8隔离在计算相对于集中式云数据中心稀疏的边缘环境中被使用。
- en: When choosing a hosting provider and runtime, research the restrictions tied
    to their container technologies. These limitations could affect your app’s size
    or the maximum running time before timing out.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择托管提供商和运行时环境时，研究与其容器技术相关的限制。这些限制可能会影响你的应用程序的大小或超时前的最大运行时间。
- en: There are many trade-offs to consider. Each environment comes with its own set
    of considerations. Next, we will connect the dots and conclude how to select the
    right deployment target for a given use case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到权衡取舍，每个环境都伴随着其自身的考虑因素。接下来，我们将连接这些点，总结如何为特定用例选择正确的部署目标。
- en: Making the final decision
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做出最终决定
- en: In this section, we will conclude how to pick a deployment target based on what
    we learned about JavaScript runtimes and different hosting environments (server,
    serverless, edge).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将总结如何根据我们对JavaScript运行时和不同托管环境（服务器、无服务器、边缘）的了解来选择部署目标。
- en: In my experience, a long-running server environment provides a great amount
    of flexibility and introduces less complexity than its alternatives. That said,
    hosting providers such as Netlify and Vercel offer a great developer experience
    and complementary services for their serverless and edge offerings. If you are
    looking for a provider that can regionally distribute both your long-running web
    server and database, then maybe Fly.io could be a great fit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，长期运行的服务器环境提供了大量的灵活性，并且比其替代方案引入的复杂性要少。话虽如此，像Netlify和Vercel这样的托管提供商为他们的无服务器和边缘服务提供了极佳的开发者体验和补充服务。如果你在寻找一个能够区域性地分配你的长期运行Web服务器和数据库的提供商，那么Fly.io可能是一个不错的选择。
- en: Serverless provides many advantages but also introduces complexity. Edge computing
    may significantly improve response times but introduces further complexity. The
    additional complexity of serverless and edge environments is a byproduct of scale
    and regional distribution. Once you think about scale and regional distribution
    for your long-running web server, you will face similar challenges.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器提供了许多优势，但也引入了复杂性。边缘计算可以显著提高响应时间，但引入了更多的复杂性。无服务器和边缘环境的额外复杂性是规模和区域分布的副产品。一旦你考虑了长期运行的Web服务器的规模和区域分布，你将面临类似的挑战。
- en: Personally, picking the right deployment target is more about avoiding unnecessary
    obstacles than anything else. The deployment target must fit the use case and
    fulfill the system requirements. Let’s go over some examples.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，选择正确的部署目标更多的是避免不必要的障碍，而不是其他任何事情。部署目标必须符合用例并满足系统要求。让我们来看一些例子。
- en: If you want to utilize Node.js libraries or reuse Node.js code, you probably
    want to stick with a Node-based environment. The Express.js deployment target
    is an obvious choice. But what about serverless environments? If you use a conventional
    database without built-in solutions for serverless environments, then you will
    have to create a new database connection for every new incoming request. This
    might lead to longer response times or even timeouts. However, if you are already
    using a serverless-first database and are looking for scalability, then picking
    a serverless environment might be a great idea.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要利用Node.js库或重用Node.js代码，你可能想坚持使用基于Node的环境。Express.js的部署目标是显而易见的选择。但是，对于无服务器环境呢？如果你使用的是没有为无服务器环境提供内置解决方案的传统数据库，那么你将不得不为每个新的传入请求创建一个新的数据库连接。这可能会导致响应时间更长，甚至超时。然而，如果你已经使用了一个以无服务器为先的数据库，并且正在寻找可扩展性，那么选择一个无服务器环境可能是一个很好的主意。
- en: If you have one single database server in Oregon, then having your web app deployed
    all over the world won’t bring you much benefit. Each instance of your app will
    have to request data from your database server in Oregon. In that case, you should
    pick a web server or serverless environment that is located as close as possible
    to your database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有一个位于俄勒冈州的数据库服务器，那么将你的Web应用程序部署到世界各地并不会给你带来太多好处。你的应用程序的每个实例都将不得不从俄勒冈州的数据库服务器请求数据。在这种情况下，你应该选择一个尽可能靠近你的数据库的Web服务器或无服务器环境。
- en: If you want to build a blog you are likely looking for easy access to your blog
    posts. Blog posts are usually stored as files. Using a hosting provider and enviroment
    that lets you access the filesystem allows you to host your blog posts together
    with your code. Unless you run into issues with this approach (there are disadvantages
    to any approach), you might want to start with a simple web server architecture.
    In that case, you could pick the Express.js template. This will grant you access
    to the underlying filesystem with most hosting providers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要建立一个博客，你很可能会寻找轻松访问你的博客文章。博客文章通常以文件的形式存储。使用允许你访问文件系统的托管提供商和环境，你可以将你的博客文章与你的代码一起托管。除非你遇到这个问题（任何方法都有缺点），你可能想从一个简单的Web服务器架构开始。在这种情况下，你可以选择Express.js模板。这将让你通过大多数托管提供商访问底层文件系统。
- en: On the other hand, you might find that some serverless providers offer attractive
    free tiers and competitive pay-as-you-go pricing. Selecting the right runtime
    depends on your priorities and requirements. Picking a hosting environment without
    access to the filesystem doesn’t mean that you won’t be able to work with files.
    It just means you must store files somewhere else – such as in a file storage
    service. Therefore, it’s more about making an informed decision to avoid obstacles
    down the road.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可能发现一些无服务器提供商提供了有吸引力的免费层和具有竞争力的按使用付费定价。选择正确的运行时取决于你的优先级和需求。选择一个没有文件系统访问权限的托管环境并不意味着你不能与文件一起工作。这仅仅意味着你必须将文件存储在其他地方——例如在文件存储服务中。因此，这更多的是关于做出明智的决定，以避免未来遇到障碍。
- en: Finally, deciding on a deployment target also means deciding on a hosting provider.
    Each deployment provider comes with its own advantages and disadvantages. For
    instance, Fly.io hosts long-running Node.js servers but offers distribution to
    different regions. Fly.io might be a great alternative to serverless edge deployment.
    On the other hand, AWS and Cloudflare each provide rich ecosystems of services
    that can be used together with their serverless and edge offerings. For complex
    applications, hosting on AWS or Cloudflare might be the right call.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，决定部署目标也意味着选择一个托管提供商。每个部署提供商都有自己的优缺点。例如，Fly.io托管长时间运行的Node.js服务器，但提供不同地区的分发。Fly.io可能是一个很好的无服务器边缘部署的替代方案。另一方面，AWS和Cloudflare各自提供丰富的服务生态系统，可以与他们的无服务器和边缘产品一起使用。对于复杂的应用程序，托管在AWS或Cloudflare可能是正确的选择。
- en: The line between long-running servers, serverless, and edge environments is
    blurry. Different providers further offer geographical distribution for both serverless
    and server environments that achieve edge-like proximity to users. Some may provide
    the best of both worlds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 长运行服务器、无服务器和边缘环境之间的界限模糊。不同的提供商进一步为无服务器和服务器环境提供地理分布，以实现类似边缘的用户接近度。一些可能提供两者的最佳结合。
- en: Picking a deployment target heavily depends on your application’s use case.
    Luckily, Remix is flexible enough to support a wide variety of different use cases.
    After all, Remix can run anywhere where JavaScript can be executed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择部署目标在很大程度上取决于您的应用程序用例。幸运的是，Remix足够灵活，可以支持各种不同的用例。毕竟，Remix可以在任何可以执行JavaScript的地方运行。
- en: Fortunately, it is straightforward to swap the underlying server environment
    and adapter in your Remix project if needed. In the next section, we will practice
    how to do so.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果需要，可以轻松地在Remix项目中交换底层的服务器环境和适配器。在下一节中，我们将练习如何这样做。
- en: Switching between adapters
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在适配器之间切换
- en: We sometimes have to migrate from one template to another one. To do so, we
    must switch our Remix app’s setup. In this chapter, we will walk through the process
    of switching templates and adapters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时必须从一个模板迁移到另一个模板。为此，我们必须切换Remix应用程序的设置。在本章中，我们将介绍切换模板和适配器的过程。
- en: 'The process of switching between templates and adapters can be summarized as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板和适配器之间切换的过程可以总结如下：
- en: Locate your Remix project and open it in an editor or file explorer.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位您的Remix项目，并在编辑器或文件资源管理器中打开它。
- en: Create a new Remix project using the new template and adapter.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的模板和适配器创建一个新的Remix项目。
- en: Open the new Remix project side by side with your old project.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新Remix项目与您的旧项目并排打开。
- en: Rename the `app` folder in the new project to `temp`. Move the `app` folder
    from your old project to the new project.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新项目中的`app`文件夹重命名为`temp`。将旧项目中的`app`文件夹移动到新项目中。
- en: Replace the code in `app/entry.client.tsx` with the code in `temp/entry.client.tsx`
    and integrate any custom code previously added to the file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app/entry.client.tsx`中的代码替换为`temp/entry.client.tsx`中的代码，并整合之前添加到文件中的任何自定义代码。
- en: Replace the code in `app/entry.server.tsx` with the code in `temp/entry.server.tsx`
    and integrate any custom code previously added to the file.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app/entry.server.tsx`中的代码替换为`temp/entry.server.tsx`中的代码，并整合之前添加到文件中的任何自定义代码。
- en: 'For every Remix-specific file and folder in the root of your old project:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于您旧项目中根目录下的每个Remix特定文件和文件夹：
- en: Investigate whether you made any changes.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查您是否进行了任何更改。
- en: Copy-paste any changes over to the new project.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何更改复制粘贴到新项目中。
- en: Resolve any conflicts (if any).
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决任何冲突（如果有）。
- en: Follow the instructions in the new project’s `README.md` file to run, build,
    and deploy the application.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照新项目中的`README.md`文件中的说明来运行、构建和部署应用程序。
- en: Troubleshoot any remaining issues using the troubleshooting process from [*Chapter
    2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New* *Remix App*.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[*第2章*](B17399_02.xhtml#_idTextAnchor030)中描述的故障排除过程，即*创建新的* *Remix应用程序*，来解决任何剩余的问题。
- en: 'Let’s practice the described process using the "Hello World!" Remix app that
    we created in [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New
    Remix App*. If you are looking for a challenge, see whether you can figure it
    out by yourself by following the nine steps listed before. Otherwise, let’s walk
    through it together:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们在[*第2章*](B17399_02.xhtml#_idTextAnchor030)中创建的"Hello World!" Remix应用程序来练习描述的过程。如果您想挑战自己，看看您是否可以通过遵循之前列出的九个步骤自己解决这个问题。否则，让我们一起来完成它：
- en: 'Open your “Hello World!” Remix app in an editor or file explorer. You can also
    find the code here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app/hello-world](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app/hello-world).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器或文件资源管理器中打开您的“Hello World!” Remix应用。您也可以在这里找到代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app/hello-world](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/02-creating-a-new-remix-app/hello-world)。
- en: In [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), we used the basic template,
    but this process works for other templates as well.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[*第2章*](B17399_02.xhtml#_idTextAnchor030)，我们使用了基本模板，但这个过程也适用于其他模板。
- en: Run `npm install` and `npm run dev` to ensure that the project is running locally
    without any issues.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install`和`npm run dev`以确保项目在本地运行且无任何问题。
- en: 'Now, create a new Remix project using the `create-remix` CLI script. Run the
    following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`create-remix` CLI脚本创建一个新的Remix项目。运行以下命令：
- en: '[PRE0]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After finishing the `create-remix` CLI script, we run `npm install` and `npm
    run dev` to ensure that the new project runs locally.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成创建`create-remix` CLI脚本后，我们运行`npm install`和`npm run dev`以确保新项目可以在本地运行。
- en: After asserting that both projects run without errors, we open the new Remix
    app in an editor or file explorer. It is easiest to have both editors/file explorers
    open side by side.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认两个项目都能无错误运行后，我们在编辑器或文件资源管理器中打开新的Remix应用。同时打开两个编辑器/文件资源管理器是最方便的。
- en: Let’s rename the `app` folder in the new project to `temp`. Next, copy the `app`
    folder from your old “Hello World!” project to the new project. This allows us
    to inspect both `temp` and `app` side by side.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新项目中的`app`文件夹重命名为`temp`。接下来，将旧“Hello World!”项目中的`app`文件夹复制到新项目中。这样我们可以并排检查`temp`和`app`文件夹。
- en: 'Run `npm run dev` in the new project. Remix will attempt to build and run the
    project using the “Hello World!” `app` folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新项目中运行`npm run dev`。Remix将尝试使用“Hello World!”的`app`文件夹构建和运行项目：
- en: '[PRE1]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compare the code in `app/entry.server.tsx` with the code in `temp/entry.server.tsx`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`app/entry.server.tsx`中的代码与`temp/entry.server.tsx`中的代码进行比较。
- en: The Express.js template used in the “Hello World!” app uses Remix’s node adapter
    (`@remix-run/node`), while the Cloudflare Worker template uses the `@``remix-run/cloudflare`
    adapter.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “Hello World!”应用中使用的Express.js模板使用Remix的node适配器(`@remix-run/node`)，而Cloudflare
    Worker模板使用`@remix-run/cloudflare`适配器。
- en: The Cloudflare Workers environment runs on workerd, which does not support Node.js
    libraries. To run on Node.js and workerd, Remix needs to set up two different
    entry point implementations and use different adapters.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cloudflare Workers环境在workerd上运行，不支持Node.js库。要在Node.js和workerd上运行，Remix需要设置两个不同的入口点实现并使用不同的适配器。
- en: Since we have no custom code in `entry.server.tsx`, replace the code in `app/entry.server.tsx`
    with the code in `temp/entry.server.tsx`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在`entry.server.tsx`中没有自定义代码，我们将`app/entry.server.tsx`中的代码替换为`temp/entry.server.tsx`中的代码。
- en: Sure there is no other usage of `@remix-run/node`. Search for the package name
    in your editor’s code search.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，没有其他使用`@remix-run/node`的地方。在您的编辑器的代码搜索中搜索包名。
- en: 'You should find two matches: `app/root.tsx` and `app/routes/_index.tsx`.'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该找到两个匹配项：`app/root.tsx`和`app/routes/_index.tsx`。
- en: Make sure to find and replace the imports with `@remix-run/cloudflare`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保找到并替换导入为`@remix-run/cloudflare`。
- en: Remix exposes its server-side types and primitives through the different adapter
    packages. When switching adapters, we must find and replace all imports of the
    old adapter with the new one.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Remix通过不同的适配器包公开其服务器端类型和原语。当切换适配器时，我们必须找到并替换所有旧适配器的导入为新适配器。
- en: Next, compare and then replace the code in `app/entry.client.tsx` with the code
    in `temp/entry.client.tsx` as well. Different templates may use different versions
    of React or implement additional logic in the client entry file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，比较并替换`app/entry.client.tsx`中的代码，以及`temp/entry.client.tsx`中的代码。不同的模板可能使用不同的React版本或在客户端入口文件中实现额外的逻辑。
- en: Run `npm run dev` again. It should now successfully build and run the new project!
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`npm run dev`。现在它应该能够成功构建和运行新项目！
- en: Let’s investigate the root folder of the old application. Are there any files
    that we did create or adapt? We should move all custom files and folders over
    to the new project.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调查旧应用的根文件夹。是否有我们创建或修改的文件？我们应该将所有自定义文件和文件夹移动到新项目中。
- en: Check the `package.json` file. We did not install any additional packages for
    our “Hello World!” app, but usually, we would now move any app dependencies over
    and install them in our new project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`package.json`文件。我们没有为我们的“Hello World！”应用程序安装任何额外的包，但通常，我们现在会将任何应用程序依赖项移动到我们的新项目中并安装它们。
- en: We should also compare the scripts of both `package.json` files. We have to
    make sure that any custom or adapted scripts are merged with the new scripts of
    our new project. In our case, there is nothing to do. We did not add any custom
    logic, which we would need to take over.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还应该比较两个`package.json`文件的脚本。我们必须确保任何自定义或修改过的脚本与我们的新项目的新脚本合并。在我们的案例中，我们不需要做任何事情。我们没有添加任何需要继承的自定义逻辑。
- en: We did it! We moved from **Remix App Server** to **Cloudflare Workers** – a
    long-running server to an edge environment!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们从**Remix应用程序服务器**移动到了**Cloudflare Workers**——从长期运行的服务器到边缘环境！
- en: The two entry files in the `app` folder are bootstrapped by Remix and custom
    for each deployment target. Hence, we must make sure to update the code in these
    files. We also must merge our custom dependencies with the dependencies of the
    new project. This requires us to manually review the `package.json` files. Finally,
    we have to take over any other changes made to files and folders in the project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`文件夹中的两个入口文件是由Remix启动的，并且针对每个部署目标进行了自定义。因此，我们必须确保更新这些文件中的代码。我们还必须将我们的自定义依赖项与新项目的依赖项合并。这需要我们手动审查`package.json`文件。最后，我们必须接管对项目中文件和文件夹所做的任何其他更改。'
- en: In this section, we successfully moved from one adapter to another. In the next
    section, we will learn about Remix Stacks to bootstrap a production-ready Remix
    app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们成功地将一个适配器移动到另一个适配器。在下一节中，我们将学习关于Remix栈的内容，以及如何为生产就绪的Remix应用程序进行初始化。
- en: Using Remix Stacks
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Remix栈
- en: In this section, you will learn about Remix Stacks. First, we will have a look
    at Remix’s official stacks and how to use them. Next, you will learn how to use
    community templates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解Remix栈。首先，我们将查看Remix的官方栈以及如何使用它们。接下来，你将学习如何使用社区模板。
- en: Working with Remix official stacks
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Remix官方栈一起工作
- en: 'Remix also offers pre-configured templates ready for production. These templates
    are referred to as Remix Stacks. As of now, Remix provides three official stacks:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Remix还提供了预配置的生产就绪模板。这些模板被称为Remix栈。截至目前，Remix提供了三个官方栈：
- en: '| **Stack** | **Deployment target** | **Comes with** | **Use case** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **栈** | **部署目标** | **包含** | **使用场景** |'
- en: '| Blues | Fly.io | PostgreSQL database | Large-scale applications and regional
    distribution |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Blues | Fly.io | PostgreSQL数据库 | 大规模应用程序和区域分布 |'
- en: '| Indie | Express.js | SQLite database | Small-scale projects with dynamic
    data |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Indie | Express.js | SQLite数据库 | 具有动态数据的小规模项目 |'
- en: '| Grunge | Architect (AWS Lambda) | DynamoDB database | Large-scale applications
    on AWS infrastructure |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Grunge | Architect (AWS Lambda) | DynamoDB数据库 | 在AWS基础设施上的大规模应用程序 |'
- en: Table 3.3 – Official Remix stacks
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3 – 官方Remix栈
- en: Stacks are opinionated project starters. They are more complex than Remix’s
    basic templates but also have more features. As visible in *Table 3.3*, the starters
    are built with different use cases in mind and utilize different deployment targets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是具有偏见的工程启动器。它们比Remix的基本模板更复杂，但同时也提供了更多功能。如*表3.3*所示，启动器是根据不同的使用场景构建的，并利用不同的部署目标。
- en: The **Blues stack** runs on Fly.io. From *Table 3.1*, you can infer that Fly.io
    hosts long-running servers. Fly.io offers regional distribution of long-running
    servers to achieve edge-like proximity. The Blues stack also ships with code to
    set up a PostgreSQL database. The stack is designed to scale and enable regional
    distribution out of the box.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blues栈**运行在Fly.io上。从*表3.1*中，你可以推断出Fly.io托管长期运行的服务器。Fly.io提供了长期运行服务器的区域分布，以实现边缘环境般的接近。Blues栈还包含设置PostgreSQL数据库的代码。该栈旨在可扩展并能够开箱即用地实现区域分布。'
- en: The **Indie stack** uses the Express.js adapter and does not target a specific
    hosting provider. It ships with an SQLite database. The Indie stack is perfect
    for starting projects that work with smaller amounts of dynamic data. From *Table
    3.2*, you can infer that this stack – depending on the hosting provider – can
    access the filesystem and will be able to share application states across different
    requests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**Indie栈**使用Express.js适配器，不针对特定的托管提供商。它包含一个SQLite数据库。Indie栈非常适合启动处理较小动态数据量的项目。从*表3.2*中，你可以推断出这个栈——取决于托管提供商——可以访问文件系统，并且能够在不同的请求之间共享应用程序状态。'
- en: The **Grunge stack** serves similar use cases to the Blues stack but is set
    up using Architect, an AWS Lambda-based framework. From *Table 3.1*, you can derive
    that Architect runs on a serverless environment. AWS infrastructure is intended
    to support large-scale applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grunge 堆栈**服务于与 Blues 堆栈类似的使用案例，但使用的是基于 AWS Lambda 的框架 Architect。从 *表 3.1*
    中，您可以得出结论，Architect 在无服务器环境中运行。AWS 基础设施旨在支持大规模应用程序。'
- en: 'Let’s try out one of the Remix Stacks Run the following command in the terminal:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行一个 Remix Stacks。在终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We again use `create-remix` to bootstrap a new Remix app. This time, we refer
    to one of Remix’s three official stack templates: the Indie stack. Feel free to
    select another stack based on your personal preferences.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `create-remix` 来启动一个新的 Remix 应用程序。这次，我们引用了 Remix 的三个官方堆栈模板之一：Indie 堆栈。根据您的个人喜好，您也可以选择另一个堆栈。
- en: Note that we point to a GitHub repository named `indie-stack` in the `@remix-run`
    GitHub organization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `@remix-run` GitHub 组织中指向了一个名为 `indie-stack` 的 GitHub 仓库。
- en: 'Investigate the bootstrapped folder structure and refer to the `README.md`
    file to get an overview of all the technologies and packages in use. A few noteworthy
    things come with the Indie stack:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 调查启动文件夹结构，并参考 `README.md` 文件以了解所有使用的技术和包的概述。Indie 堆栈有几个值得注意的特点：
- en: A registration and login setup (`app/session.server.ts`).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个注册和登录设置 (`app/session.server.ts`)。
- en: A convention for where to place your database logic (`app/models/`).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个放置您的数据库逻辑的约定 (`app/models/`)。
- en: A route for health checks (`app/routes/healthcheck.tsx`).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于健康检查的路由 (`app/routes/healthcheck.tsx`)。
- en: Remix Stacks implement styling, testing, authentication, and additional features
    out of the box. Where Remix’s basic templates provide simple server and adapter
    setups, Remix Stacks are production-ready applications that ship with an opinionated
    setup. On top of that, Remix also supports the creation of custom templates. In
    the next section, we will learn how to use and create custom templates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Remix Stacks 默认实现样式、测试、身份验证和附加功能。Remix 的基本模板提供简单的服务器和适配器设置，而 Remix Stacks 是生产就绪的应用程序，附带了一个有见地的设置。除此之外，Remix
    还支持创建自定义模板。在下一节中，我们将学习如何使用和创建自定义模板。
- en: Working with custom templates
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义模板
- en: We can utilize community-developed templates or create our own to get up and
    running quickly with our preferred stack. Custom templates are also a great way
    to develop opinionated templates for an organization.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用社区开发的模板或创建自己的模板，快速使用我们偏好的堆栈开始工作。自定义模板也是为组织开发有见地的模板的绝佳方式。
- en: Any Remix project can be used as a template. The only limitation is that the
    template must be a valid Remix project with a `package.json` file in the root
    folder. The easiest way to access a template is via GitHub, but Remix can also
    access a template via a URL, a local path on your machine, a subfolder in a GitHub
    repository, or a local or remote tarball.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Remix 项目都可以用作模板。唯一的限制是模板必须是一个有效的 Remix 项目，根目录中有一个 `package.json` 文件。访问模板的最简单方法是通过
    GitHub，但 Remix 也可以通过 URL、您机器上的本地路径、GitHub 仓库的子文件夹或本地或远程的 tarball 访问模板。
- en: 'Let’s try out the custom template from this book’s GitHub repository. Run the
    `create-remix` command with the template flag in the terminal:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试本书 GitHub 仓库中的自定义模板。在终端中使用带有模板标志的 `create-remix` 命令：
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure to select `remix.init` script.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择 `remix.init` 脚本。
- en: 'After running the `init` script, you should see a short message in the terminal:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `init` 脚本后，你应该在终端看到一个简短的消息：
- en: '[PRE4]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This message originates from the `remix.init/index.js` script in the project’s
    root folder. The script allows template authors to implement custom setup steps.
    You can also run the script again by calling `npx remix init` in the project root.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息源自项目根目录中的 `remix.init/index.js` 脚本。该脚本允许模板作者实现自定义设置步骤。您也可以通过在项目根目录中调用 `npx
    remix init` 再次运行该脚本。
- en: Conveniently, I just sneaked you into setting up the BeeRich application, which
    will be used as a demo application for the rest of this book. Next, we will kick
    off our development journey with BeeRich.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我刚刚偷偷地帮你设置了 BeeRich 应用程序，它将作为本书其余部分的演示应用程序。接下来，我们将用 BeeRich 开始我们的开发之旅。
- en: Working with BeeRich
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BeeRich
- en: Welcome to BeeRich! BeeRich is a dashboard-like application that mimics both
    personal and enterprise use cases. BeeRich is a personal finance management application
    that helps you stay on top of your bee – pardon me – bookkeeping. Well, at least
    that’s the goal. There is nothing much there yet. In every chapter, we will add
    more code to this application. In this section, we will run BeeRich locally and
    review the folder structure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 BeeRich！BeeRich 是一个类似于仪表盘的应用程序，它模仿了个人和企业用例。BeeRich 是一个个人财务管理应用程序，帮助你管理好你的蜜蜂——请原谅我——账目。嗯，至少那是目标。目前还没有太多内容。在每一章中，我们将向这个应用程序添加更多代码。在本节中，我们将本地运行
    BeeRich 并审查文件夹结构。
- en: 'We bootstrapped BeeRich in the preceding section using the `create-remix` script.
    BeeRich is nothing more than a simple skeleton application on top of Remix’s Express.js
    template that we tried out in [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030),
    *Creating a New Remix App*. You can also find the BeeRich Remix template in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用 `create-remix` 脚本启动了 BeeRich。BeeRich 仅仅是在 Remix 的 Express.js 模板上构建的一个简单骨架应用程序，我们在
    [*第 2 章*](B17399_02.xhtml#_idTextAnchor030)，*创建新的 Remix 应用程序* 中尝试了它。你还可以在本书的 GitHub
    仓库中找到 BeeRich Remix 模板：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix)。
- en: 'Let''s run BeeRich locally. Open the terminal and navigate to the project''s
    root folder. Then execute the following command in the terminal:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们本地运行 BeeRich。打开终端并导航到项目的根目录。然后在终端中执行以下命令：
- en: '[PRE5]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The application should now be running on port `3000`: `http://localhost:3000/`.
    Welcome to BeeRich!'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在应该已经在端口 `3000` 上运行：`http://localhost:3000/`。欢迎来到 BeeRich！
- en: The `npm run dev` command starts Remix's development server to build and watch
    the development environment. You can find a list of all available scripts in the
    `package.json` file. Also, review the `README.md` file in the root of the BeeRich
    project for additional information about BeeRich.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run dev` 命令启动 Remix 的开发服务器以构建和监视开发环境。你可以在 `package.json` 文件中找到所有可用脚本的列表。此外，请查看
    BeeRich 项目的根目录下的 `README.md` 文件以获取有关 BeeRich 的更多信息。'
- en: Tailwind CSS has been included so we can quickly add some styling without the
    need to leave our JavaScript modules. You can also find some styled reusable components
    in `app/components`. Visit the `/demo` route to inspect some of the reusable components
    ([http://localhost:3000/demo](http://localhost:3000/demo)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了 Tailwind CSS，这样我们就可以快速添加一些样式，而无需离开我们的 JavaScript 模块。你还可以在 `app/components`
    中找到一些样式化的可重用组件。访问 `/demo` 路由来检查一些可重用组件（[http://localhost:3000/demo](http://localhost:3000/demo)）。
- en: Feel free to deviate from the lessons in this book and explore alternative solutions.
    If you get stuck, you can always reset your application and use the application
    in the current chapter’s folder on GitHub as a baseline.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随意偏离本书中的课程并探索替代方案。如果你遇到困难，你总是可以重置你的应用程序并使用 GitHub 上当前章节文件夹中的应用程序作为基准。
- en: In the next chapter, we will add pages and routes to BeeRich.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向 BeeRich 添加页面和路由。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what to consider when selecting a deployment target
    for your Remix application. You learned more about different hosting providers,
    environments, and runtimes. You now understand that Remix runs on long-running
    servers, serverless environments, and edge runtimes. Each environment has advantages
    and disadvantages that you must consider when selecting a template and deployment
    target.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了在选择 Remix 应用程序的部署目标时需要考虑什么。你了解了不同的托管提供商、环境和运行时。你现在明白 Remix 可以在长期运行的服务器、无服务器环境和边缘运行时上运行。每个环境都有其优势和劣势，在选择模板和部署目标时你必须考虑这些因素。
- en: Remix’s different deployment targets operate on different JavaScript runtimes,
    such as Node.js, workerd, and Deno. Different JavaScript runtimes support different
    web standards and either support or do not support Node.js standard libraries.
    When picking a template, you must consider what JavaScript runtime you want to
    work with.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的不同部署目标运行在不同的 JavaScript 运行时上，例如 Node.js、workerd 和 Deno。不同的 JavaScript
    运行时支持不同的网络标准，并且可能支持或不支持 Node.js 标准库。在挑选模板时，你必须考虑你想要使用的 JavaScript 运行时。
- en: This chapter introduces you to a nine-step process to migrate from one adapter
    to another. Switching out adapters enables you to try out different hosting providers
    and environments and to stay agile in case your requirements change over time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了一个九步过程，用于从一种适配器迁移到另一种适配器。更换适配器使您能够尝试不同的托管提供商和环境，并在您的需求随时间变化时保持敏捷。
- en: Remix offers basic templates for different deployment targets that set up Remix’s
    adapters. However, Remix also offers production-ready stacks. In this chapter,
    you practiced using the `create-remix` script to bootstrap a new Remix app using
    Remix’s Indie Stack.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Remix为不同的部署目标提供了基本模板，用于设置Remix的适配器。然而，Remix还提供了生产就绪的堆栈。在本章中，您练习了使用`create-remix`脚本来使用Remix的Indie
    Stack启动一个新的Remix应用程序。
- en: Next, we utilized a custom template to bootstrap the demo application, BeeRich,
    which we will use in the following chapters to practice our Remix skills. In the
    next chapter, we will learn about routing in Remix and add pages to BeeRich.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用自定义模板启动了演示应用程序BeeRich，我们将在接下来的章节中使用它来练习我们的Remix技能。在下一章中，我们将学习Remix中的路由并添加BeeRich的页面。
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find a list of available adapters in the Remix documentation: [https://remix.run/docs/en/2/other-api/adapter](https://remix.run/docs/en/2/other-api/adapter).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Remix文档中找到可用适配器的列表：[https://remix.run/docs/en/2/other-api/adapter](https://remix.run/docs/en/2/other-api/adapter)。
- en: 'The Remix documentation also provides more explanations about available templates
    here: [https://remix.run/docs/en/2/discussion/runtimes](https://remix.run/docs/en/2/discussion/runtimes).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Remix文档还提供了更多关于可用模板的解释，请在此处查看：[https://remix.run/docs/en/2/discussion/runtimes](https://remix.run/docs/en/2/discussion/runtimes)。
- en: 'The official announcement post for Remix stacks can be found here: [https://remix.run/blog/remix-stacks](https://remix.run/blog/remix-stacks).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到Remix堆栈的官方公告帖子：[https://remix.run/blog/remix-stacks](https://remix.run/blog/remix-stacks)。
- en: 'Listen to Wes Bos and Scott Tolinski talk about the limitations of serverless
    on Syntax.fm: [https://syntax.fm/show/542/serverless-limitations](https://syntax.fm/show/542/serverless-limitations).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 听Wes Bos和Scott Tolinski在Syntax.fm上讨论无服务器限制：[https://syntax.fm/show/542/serverless-limitations](https://syntax.fm/show/542/serverless-limitations)。
- en: 'Learn more about the distinction between serverless computing and containers
    here: [https://www.cloudflare.com/learning/serverless/serverless-vs-containers/](https://www.cloudflare.com/en-gb/learning/serverless/serverless-vs-containers/).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处了解更多关于无服务器计算和容器之间区别的信息：[https://www.cloudflare.com/learning/serverless/serverless-vs-containers/](https://www.cloudflare.com/en-gb/learning/serverless/serverless-vs-containers/)。
- en: 'You can find more information about V8 isolates here: [https://developers.cloudflare.com/workers/learning/how-workers-works/#isolates](https://developers.cloudflare.com/workers/learning/how-workers-works/#isolates).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到有关V8隔离器的更多信息：[https://developers.cloudflare.com/workers/learning/how-workers-works/#isolates](https://developers.cloudflare.com/workers/learning/how-workers-works/#isolates)。
