- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Deferring Loader Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载器数据
- en: Executing data loading on the server can speed up initial page load times and
    improve core web vitals such as **Largest Contentful Paint** (**LCP**). However,
    server-side data fetching can also become a bottleneck if a request is particularly
    slow. For such cases, Remix provides an alternative data-fetching approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上执行数据加载可以加快初始页面加载时间并提高核心 Web 性能指标，如 **最大内容渲染**（**LCP**）。然而，如果请求特别慢，服务器端数据获取也可能成为瓶颈。对于这种情况，Remix
    提供了一种替代的数据获取方法。
- en: 'In this chapter, we will work with Remix’s `defer` function and learn how to
    utilize HTTP and React streaming, React `Suspense`, and Remix’s `Await` component
    to defer slow loader data requests. This chapter is split into two sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Remix 的 `defer` 函数，并学习如何利用 HTTP 和 React 流式传输、React `Suspense` 以及
    Remix 的 `Await` 组件来延迟慢速加载器数据请求。本章分为两个部分：
- en: Streaming data to the client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户端流式传输数据
- en: Deferring loader data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟加载器数据
- en: First, we will discuss the trade-offs of server-side data fetching and review
    the requirements for working with Remix’s `defer` function. Next, we will utilize
    Remix’s `defer` function in BeeRich and practice working with React `Suspense`
    and Remix’s `Await` component.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论服务器端数据获取的权衡，并回顾使用 Remix 的 `defer` 函数的要求。接下来，我们将在 BeeRich 中使用 Remix 的
    `defer` 函数，并练习使用 React `Suspense` 和 Remix 的 `Await` 组件。
- en: After reading this chapter, you will know how to use `defer` to improve the
    performance of your Remix applications. You will have also learned the requirements
    for working with HTTP and React streaming. Finally, you will understand the trade-offs
    of deferring loader data and know when to utilize `defer` in Remix.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您将了解如何使用 `defer` 来提高您的 Remix 应用程序的性能。您还将学习与 HTTP 和 React 流式传输一起工作的要求。最后，您将理解延迟加载器数据的权衡，并知道何时在
    Remix 中使用 `defer`。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We need to update some code before we can get started with this chapter. Please
    follow the steps in the `README.md` file in this chapter’s folder on GitHub before
    continuing. You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本章之前，我们需要更新一些代码。请在继续之前遵循 GitHub 上的本章文件夹中 `README.md` 文件中的步骤。您可以在以下位置找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data)。
- en: Streaming data to the client
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向客户端流式传输数据
- en: There are several different data-fetching strategies. We can initiate data fetching
    on the client using client-side `fetch` requests or execute data fetching on the
    server to take advantage of server-side rendering. We can even fetch data during
    build time for static site generations. In this section, we will discuss the trade-offs
    of server-side data fetching and review the requirements of HTTP streaming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种不同的数据获取策略。我们可以使用客户端 `fetch` 请求在客户端启动数据获取，或者执行服务器端数据获取以利用服务器端渲染。我们甚至可以在构建时获取数据以用于静态站点生成。在本节中，我们将讨论服务器端数据获取的权衡，并回顾
    HTTP 流式传输的要求。
- en: Motivating server-side data fetching and streaming
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 促使服务器端数据获取和流式传输
- en: Remix promotes fetching data on the server using `loader` functions for each
    route, as opposed to fetching data at the component level. During the initial
    page load, the `loader` functions are called before React renders on the server.
    This guarantees that the loader data is available for the server-side rendering
    step, eliminating the need for client-side data-fetching logic and loading states.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 推崇使用 `loader` 函数在每个路由上从服务器获取数据，而不是在组件级别获取数据。在初始页面加载期间，`loader` 函数在 React
    在服务器上渲染之前被调用。这保证了加载器数据可用于服务器端渲染步骤，消除了客户端数据获取逻辑和加载状态的需求。
- en: When initiating data fetching on the client, we first need to load the HTML
    document and then wait for the JavaScript bundles to download and execute before
    executing the required fetch requests. This results in three client-server roundtrips
    before the LCP is finalized. In comparison, we can paint the LCP after one client-server
    roundtrip with server-side data fetching and rendering. Reducing the number of
    client-server roundtrips almost always results in faster response times and improved
    core web vitals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端初始化数据获取时，我们首先需要加载HTML文档，然后等待JavaScript包下载并执行，之后才能执行所需的获取请求。这导致在LCP最终确定之前，需要进行三次客户端到服务器的往返。相比之下，我们可以通过服务器端数据获取和渲染，在客户端到服务器的单次往返后绘制LCP。减少客户端到服务器的往返次数几乎总是会导致更快的响应时间和改进的核心Web
    Vitals。
- en: Let’s run through an example to understand how server-side data fetching can
    improve the LCP of the initial page load. Assume we maintain an e-commerce web
    page for a product. The site shows an image of the product and some additional
    information about the product, such as the name of the product and its price.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解服务器端数据获取如何提高初始页面加载的LCP。假设我们维护一个电子商务网页，展示产品的图片和一些关于产品的附加信息，如产品名称和价格。
- en: First, let’s assume we operate a client-side-only SPA. What happens once a user
    visits our web page?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们假设我们只操作客户端SPA。当用户访问我们的网页时会发生什么？
- en: "![Figure 13.1 – Client-side dat\uFEFFa-fetching waterfall](img/Figure_13.1_B17399.jpg)"
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 客户端数据获取瀑布图](img/Figure_13.1_B17399.jpg)'
- en: Figure 13.1 – Client-side data-fetching waterfall
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 客户端数据获取瀑布图
- en: 'As visible in *Figure 13**.1*, the following requests are executed from the
    browser:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 13.1*所示，以下请求是从浏览器执行的：
- en: The browser requests the HTML document.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器请求HTML文档。
- en: The browser requests scripts and other assets referenced in the document.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器请求文档中引用的脚本和其他资源。
- en: The React app is running and fetches the product information. The browser executes
    the fetch requests.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React应用正在运行并获取产品信息。浏览器执行获取请求。
- en: The React app re-renders with the fetched data, and the browser requests assets
    linked in the HTML, such as the product images. The downloaded assets are used
    to paint the LCP.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React应用使用获取的数据重新渲染，浏览器请求HTML中链接的资产，如产品图片。下载的资产用于绘制LCP。
- en: We execute four subsequent requests to display the product image and finalize
    the LCP, each request adding to the request waterfall and delaying the LCP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了四个后续请求来显示产品图片并最终确定LCP，每个请求都增加了请求瀑布并延迟了LCP。
- en: Now, let’s assume we use Remix to render the product page. How many client requests
    are necessary to finalize the LCP?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们使用Remix来渲染产品页面。需要多少个客户端请求才能最终确定LCP？
- en: "![Figure 13.2 – Server-side dat\uFEFFa-fetching waterfall](img/Figure_13.2_B17399.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 服务器端数据获取瀑布图](img/Figure_13.2_B17399.jpg)'
- en: Figure 13.2 – Server-side data-fetching waterfall
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 服务器端数据获取瀑布图
- en: 'As visible in *Figure 13**.2*, the following requests are executed from the
    browser:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 13.2*所示，以下请求是从浏览器执行的：
- en: The browser requests the HTML document. The received document already includes
    the product information and image HTML element.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器请求HTML文档。接收到的文档已经包含了产品信息和图像HTML元素。
- en: The browser requests the product image together with the other linked assets.
    The downloaded assets are used to paint the LCP.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器请求产品图片以及其他链接资源。下载的资源用于绘制LCP。
- en: With server-side data fetching, we only require two client-server roundtrips
    to render the product page. This is a significant improvement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务器端数据获取，我们只需要两个客户端到服务器的往返来渲染产品页面。这是一个显著的改进。
- en: What changed? Remix flattens the request waterfall by moving the data fetching
    to the server. This way, images and other assets can load parallel to the JavaScript
    bundles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么变化？Remix通过将数据获取移动到服务器来简化请求瀑布。这样，图像和其他资源可以与JavaScript包并行加载。
- en: Unfortunately, this model may not work well when executing particularly slow
    requests in `loader` functions. Since we wait for all `loader` functions to finish
    before server-side rendering our React application, a slow request can become
    a bottleneck for our application and slow down initial page loads. In this case,
    we might want to look for alternative approaches.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当在`loader`函数中执行特别慢的请求时，这种模型可能不起作用。由于我们在服务器端渲染我们的React应用之前等待所有`loader`函数完成，慢速请求可能成为我们应用的瓶颈并减慢初始页面加载。在这种情况下，我们可能需要寻找替代方法。
- en: One solution could be fetching the slow request from the client after the initial
    page has been downloaded from the server. However, this results in the request
    waterfall outlined earlier – further delaying the slow data response. Luckily,
    Remix provides a simple set of primitives to defer loading a promise and instead
    stream the response to the client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是在从服务器下载初始页面之后从客户端获取慢速请求。然而，这会导致前面概述的请求瀑布效应——进一步延迟慢速数据响应。幸运的是，Remix
    提供了一套简单的原语来延迟获取承诺，并改为将响应流式传输到客户端。
- en: Streaming allows us to send bytes to the client, even if the full response has
    not been finalized. React provides utilities to stream server-side-rendered content
    to the client. React will start sending pieces of the rendered content to the
    client while still awaiting other pieces. With `Suspense`, React can suspend component
    subtrees from rendering until a promise resolves. Remix builds on React `Suspense`
    to defer specific loader data requests using the `defer` function and the `Await`
    component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 流允许我们在完整响应尚未最终确定的情况下向客户端发送字节。React 提供了将服务器端渲染的内容流式传输到客户端的实用工具。React 将在等待其他部分的同时开始向客户端发送渲染内容的片段。使用
    `Suspense`，React 可以挂起组件子树直到承诺解决。Remix 通过使用 `defer` 函数和 `Await` 组件构建在 React `Suspense`
    之上，以延迟特定的 loader 数据请求。
- en: Remix `loader` functions fetch data at the route level to avoid network waterfalls.
    If a request is particularly slow and in danger of becoming a bottleneck, we can
    pull another lever to defer that request. This is made possible by HTTP streaming
    and the web streaming API. In the next section, we will discuss the requirements
    to utilize HTTP streaming with Remix.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的 `loader` 函数在路由级别获取数据以避免网络瀑布效应。如果一个请求特别慢，有成为瓶颈的危险，我们可以拉另一个杠杆来延迟该请求。这是通过
    HTTP 流和 Web 流 API 实现的。在下一节中，我们将讨论使用 Remix 利用 HTTP 流的要求。
- en: Understanding HTTP streaming requirements
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 HTTP 流的要求
- en: Since Remix’s `defer` function uses HTTP and React streaming, we can only utilize
    it on a server environment that supports HTTP streaming responses. In this section,
    we will discuss the requirements for HTTP streaming and `defer`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Remix 的 `defer` 函数使用 HTTP 和 React 流，我们只能在支持 HTTP 流式响应的服务器环境中使用它。在本节中，我们将讨论
    HTTP 流和 `defer` 的要求。
- en: In [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043), *Deployment Targets, Adapters,
    and Stacks*, we learned how Remix utilizes adapters to run on different JavaScript
    runtimes and server environments. Some environments, such as traditional serverless
    environments, may not support streaming responses. This is important to remember
    when evaluating hosting providers and runtimes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B17399_03.xhtml#_idTextAnchor043)，*部署目标、适配器和堆栈*，我们学习了 Remix 如何利用适配器在不同的
    JavaScript 运行时和服务器环境中运行。某些环境，例如传统的无服务器环境，可能不支持流式响应。在评估托管提供商和运行时时要记住这一点。
- en: Fortunately, a growing number of environments do support HTTP streaming, and
    by default, Remix is set up with React streaming. This is great even without using
    `defer` as it speeds up the initial document request. With HTTP streaming, the
    client can start receiving parts of the response without needing to wait for the
    full response to be finalized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，越来越多的环境支持 HTTP 流，并且默认情况下，Remix 已配置为使用 React 流。即使不使用 `defer`，这也是一件好事，因为它可以加快初始文档请求的速度。使用
    HTTP 流，客户端可以在不需要等待完整响应最终确定的情况下开始接收响应的部分。
- en: 'To find out whether your Remix project is set up with React streaming, you
    can check the `app/entry.server.tsx` file in your Remix project. Search for the
    `renderToPipeableStream` function. If it is in use, you can be certain that React
    streaming is set up. Otherwise, you can follow Remix’s `defer` guide to set up
    React streaming: [https://remix.run/docs/en/2/guides/streaming](https://remix.run/docs/en/2/guides/streaming)
    (if your runtime and hosting environment supports it).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定你的 Remix 项目是否已配置为使用 React 流，你可以检查 Remix 项目中的 `app/entry.server.tsx` 文件。搜索
    `renderToPipeableStream` 函数。如果正在使用，你可以确信 React 流已配置。否则，你可以遵循 Remix 的 `defer` 指南来设置
    React 流：[https://remix.run/docs/en/2/guides/streaming](https://remix.run/docs/en/2/guides/streaming)（如果你的运行时和托管环境支持的话）。
- en: 'If you can’t locate the `app/entry.server.tsx` file, it may be that you are
    using Remix''s default implementation and that you need to reveal it by executing
    the `npx remix reveal` command. You can learn more about the `entry.server.tsx`
    file in [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New Remix
    Project*, or in the Remix documentation: [https://remix.run/docs/en/2/file-conventions/entry.server](https://remix.run/docs/en/2/file-conventions/entry.server).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到 `app/entry.server.tsx` 文件，可能是因为您正在使用 Remix 的默认实现，并且需要通过执行 `npx remix
    reveal` 命令来揭示它。您可以在 [*第 2 章*](B17399_02.xhtml#_idTextAnchor030) “创建新的 Remix 项目”
    或 Remix 文档中了解更多关于 `entry.server.tsx` 文件的信息：[https://remix.run/docs/en/2/file-conventions/entry.server](https://remix.run/docs/en/2/file-conventions/entry.server)。
- en: Now that you understand how Remix uses HTTP and React streaming, let’s try it
    out in BeeRich. In the next section, we will practice working with Remix’s `defer`
    function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Remix 如何使用 HTTP 和 React 流，让我们在 BeeRich 中尝试一下。在下一节中，我们将练习使用 Remix 的
    `defer` 函数。
- en: Deferring loader data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载器数据
- en: Not all payloads are equally important to the user. Some data may only appear
    below the page’s fold and is not immediately visible to the user. Other information
    may not be of primary content of the page but slow down the initial page load.
    For example, we may want to prioritize displaying the product information for
    an e-commerce site as fast as possible. However, we might be okay deferring the
    loading of the comments section to speed up the initial page load time. For this,
    Remix provides the `defer` and `Await` primitives. In this section, we will utilize
    Remix’s primitives with React `Suspense` in BeeRich to defer specific loader data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有有效载荷对用户来说都同等重要。某些数据可能只出现在页面下方，并且对用户来说不是立即可见的。其他信息可能不是页面的主要内容，但会减慢初始页面加载速度。例如，我们可能希望尽可能快地显示电子商务网站的产品信息。然而，我们可能对延迟加载评论部分以加快初始页面加载时间持开放态度。为此，Remix
    提供了 `defer` 和 `Await` 原语。在本节中，我们将利用 Remix 的原语与 React `Suspense` 在 BeeRich 中延迟特定的加载器数据。
- en: 'Please review the `README.md` file on GitHub for this chapter if you haven’t
    already: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md).
    This file will guide you through setting up the new expense and invoice changelog.
    Now, let’s allow users to see the full history of all changes to their expenses
    and invoices:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有查看，请查阅 GitHub 上的此章节的 `README.md` 文件：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md)。此文件将指导您设置新的费用和发票变更日志。现在，让我们允许用户查看他们费用和发票的所有变更的完整历史记录：
- en: 'Let’s start by fetching the changelog data in the `dashboard.expenses.$id._index.tsx`
    route module’s `loader` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `dashboard.expenses.$id._index.tsx` 路由模块的 `loader` 函数中获取变更日志数据开始：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, create an `ExpenseLogs` component:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `ExpenseLogs` 组件：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update the `useLoaderData` call in the route module component to access the
    `expenseLog` array:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新路由模块组件中的 `useLoaderData` 调用以访问 `expenseLog` 数组：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'import { H2, ExpenseLogs component below the edit expense form:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 `{ H2, ExpenseLogs }` 组件位于编辑费用表单下方：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To avoid delaying the initial page load, utilize Remix’s `defer` function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免延迟初始页面加载，使用 Remix 的 `defer` 函数：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: return defer acts just as json when called with resolved data. The magic only
    starts happening once we defer an unresolved Promise.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`return defer` 在调用具有解析数据时表现得就像 json 一样。魔法只有在我们将未解析的 Promise 延迟时才开始发生。'
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Remove the `await` keyword before the `expenseLog.findMany` call:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `expenseLog.findMany` 调用之前删除 `await` 关键字：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we also chain a `then` call at the end of the query. This is a trick
    to map `PrismaPromise`, which is returned by `findMany`, to an actual `Promise`
    object, as Remix’s `defer` function requires `Promise` instances.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们在查询的末尾也链式调用了 `then` 调用。这是一个技巧，将 `PrismaPromise`（由 `findMany` 返回）映射到实际的
    `Promise` 对象，因为 Remix 的 `defer` 函数需要 `Promise` 实例。
- en: 'Snap! We broke the page as `expenseLogs` is now of the `Promise` type. We need
    to update our React code so that it can work with deferred loader data. First,
    import `Suspense` from React and `Await` from Remix:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嘭！我们破坏了页面，因为 `expenseLogs` 现在是 `Promise` 类型。我们需要更新我们的 React 代码，使其能够与延迟加载的数据一起工作。首先，从
    React 中导入 `Suspense` 和从 Remix 中导入 `Await`：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <expenseLogs request. To inform Remix which promise we are awaiting, we must
    pass the expenseLogs loader data to Await. We can also pass Await an errorElement
    component in case the promise is rejected.We pass `Await` a callback function
    as its child component. Once the promise is resolved, `Await` will call the callback
    with the resolved data. This ensures that the `ExpenseLogs` component has access
    to the resolved `expenseLogs` data.Alternatively, we can access the resolved data
    by using Remix’s `useDeferredValue` hook within the child component.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <expenseLogs请求。为了通知Remix我们正在等待哪个承诺，我们必须将expenseLogs加载器数据传递给Await。我们还可以向Await传递一个错误元素组件，以防承诺被拒绝。我们将回调函数作为`Await`的子组件传递。一旦承诺解决，`Await`将使用解决的数据调用回调。这确保了`ExpenseLogs`组件可以访问解决的`expenseLogs`数据。或者，我们可以在子组件中使用Remix的`useDeferredValue`钩子来访问解决的数据。
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run BeeRich locally and notice how the initial page load does not include the
    `expenseLogs` data.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地运行BeeRich并注意初始页面加载不包括`expenseLogs`数据。
- en: Note that you may need to delay the `expenseLogs` query for better visibility.
    Otherwise, the deferred loading might be too fast on localhost to capture.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可能需要延迟`expenseLogs`查询以获得更好的可见性。否则，在本地主机上延迟加载可能太快而无法捕捉。
- en: 'Update the `then` statement of the `expenseLogs` query in the `loader` function:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`loader`函数中`expenseLogs`查询的`then`语句：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, inspect the deferred data loading in the UI and the `expenseLogs` data.
    Instead, the suspense fallback string is rendered. Once the `expenseLogs` promise
    resolves, the page re-renders with the `expenseLogs` data.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查UI中的延迟数据加载和`expenseLogs`数据。相反，渲染了suspense回退字符串。一旦`expenseLogs`承诺解决，页面将使用`expenseLogs`数据重新渲染。
- en: Note that `defer` introduces a pending state in the UI. It is important to understand
    that this impacts the user experience. Introducing loading spinners should be
    considered a trade off for deferring loader data. We may introduce layout shifts
    once the data resolves that affect SEO as web crawlers may now parse the fallback
    UI.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`defer`在UI中引入了一个待处理状态。重要的是要理解这会影响用户体验。引入加载旋转器应被视为延迟加载器数据的权衡。一旦数据解决，我们可能会引入布局变化，这会影响SEO，因为网络爬虫现在可以解析回退UI。
- en: 'Next, optimize the call order in the `loader` function. Move the expense logs
    query above the expense query:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，优化`loader`函数中的调用顺序。将费用日志查询移动到费用查询之上：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From this, we can summarize that Remix provides us with a way to defer loader
    data per request. We can decide for each request whether we want to await or defer
    in the `loader` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以总结出Remix为我们提供了一种按请求延迟加载器数据的方法。我们可以在`loader`函数中为每个请求决定是否要等待或延迟。
- en: Remember that we broke the page before adding `Await` and `Suspense`. It is
    good practice to first add the `Await` and `Suspense` components to the page before
    returning promises with `defer` in the `loader` function. This will help you avoid
    errors while implementing `Await` and `Suspense`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在添加`Await`和`Suspense`之前破坏了页面。在`loader`函数中返回带有`defer`的承诺之前，首先将`Await`和`Suspense`组件添加到页面中是一种良好的实践。这将帮助你在实现`Await`和`Suspense`时避免错误。
- en: Practice using `defer` by applying the same changes to the income routes. Copy-paste
    and adapt the `ExpenseLogs` component into the `dashboard.income.$id._index.tsx`
    route module. Utilize the component and implement the same `defer`, `Suspense`,
    and `Await` flow as practiced in this chapter. Use `setTimeout` to test the user
    experience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将相同的更改应用到收入路由来练习使用`defer`。复制粘贴并将`ExpenseLogs`组件适应到`dashboard.income.$id._index.tsx`路由模块中。利用该组件并实现本章中练习的相同`defer`、`Suspense`和`Await`流程。使用`setTimeout`来测试用户体验。
- en: If you want more practice, add a `defer` and optimistic UI if you need more
    guidance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更多练习，添加`defer`和乐观UI，如果你需要更多指导。
- en: Remix provides levers
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Remix提供了杠杆
- en: Remix provides levers so that we can optimize the user experience based on our
    app’s requirements. When considering `defer`, it is important to remember that
    deferred data loading may also degrade the user experience by adding a pending
    UI and introducing loading spinners.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Remix提供了杠杆，使我们能够根据我们的应用需求优化用户体验。在考虑`defer`时，重要的是要记住，延迟数据加载也可能通过添加待处理UI和引入加载旋转器来降低用户体验。 '
- en: In this section, you practiced working with Remix’s `defer` and `Await` primitives.
    You now know how to use deferred response data streaming to optimize slow or secondary
    data requests but are aware that `defer` is a lever that impacts the user experience
    by introducing pending UIs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您练习了使用Remix的`defer`和`Await`原语进行操作。您现在知道如何使用延迟响应数据流来优化缓慢或次要数据请求，但您也意识到`defer`是一个通过引入挂起UI来影响用户体验的杠杆。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that Remix supports different data-fetching strategies.
    Deferring loader data can be utilized to resolve performance bottlenecks in your
    Remix apps when fetching from slow endpoints. Remix’s `defer` function detects
    unresolved promises in the loader data and streams them to the client once resolved.
    React `Suspense` and Remix’s `Await` component are used to manage the deferred
    loader data in React.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到Remix支持不同的数据获取策略。在从缓慢的端点获取数据时，可以通过延迟加载数据来利用Remix解决Remix应用的性能瓶颈。Remix的`defer`函数检测加载数据中的未解决承诺，并在解决后将其流式传输到客户端。React
    `Suspense`和Remix的`Await`组件用于在React中管理延迟加载数据。
- en: You also learned that using `defer` requires fallback UIs to communicate loading
    states. You now understand that using `defer` comes with trade-offs that impact
    the user experience. On one hand, deferring loader data can speed up the initial
    document request. On the other hand, using `defer` creates loading UIs, which
    results in a different user experience.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您还了解到使用`defer`需要回退UI来传达加载状态。现在您理解了使用`defer`会带来影响用户体验的权衡。一方面，延迟加载数据可以加快初始文档请求。另一方面，使用`defer`会创建加载UI，这会导致不同的用户体验。
- en: After reading this chapter, you know that Remix uses React streaming to speed
    up document requests. However, React and HTTP streaming are not supported on all
    server runtimes and environments. Conclusively, not all Remix adapters support
    React streaming. Since Remix’s `defer` function takes advantage of React `Suspense`
    and React streaming, deferring loader data only works when React streaming is
    supported and set up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您了解到Remix使用React流来加速文档请求。然而，React和HTTP流并不支持所有服务器运行时和环境。最终，并非所有Remix适配器都支持React流。由于Remix的`defer`函数利用了React
    `Suspense`和React流，因此只有当React流被支持并设置时，延迟加载数据才有效。
- en: Finally, you practiced deferring loader data by implementing an expense changelog
    in BeeRich.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您通过在BeeRich中实现支出变更日志来练习了延迟加载数据。
- en: In the next chapter, we will extend the changelog implementation and add real-time
    data responses with **Server-Sent** **Events** (**SSE**).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展变更日志实现，并添加使用**服务器发送事件**（**SSE**）的实时数据响应。
- en: Further reading
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can read more about the Streams API via MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Web/API/Streams_API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过MDN Web Docs了解有关Streams API的更多信息：[https://developer.mozilla.org/en-US/docs/Web/API/Streams_API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).
- en: 'The Remix documentation includes a guide for streaming and `defer`: [https://remix.run/docs/en/2/guides/streaming](https://remix.run/docs/en/2/guides/streaming).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Remix文档包括关于流式传输和`defer`的指南：[https://remix.run/docs/en/2/guides/streaming](https://remix.run/docs/en/2/guides/streaming).
- en: 'The `defer` function’s documentation can be found here: [https://remix.run/docs/en/2/utils/defer](https://remix.run/docs/en/2/utils/defer).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`函数的文档可以在以下位置找到：[https://remix.run/docs/en/2/utils/defer](https://remix.run/docs/en/2/utils/defer).'
- en: 'In this chapter, we discussed core web vitals. You can read more about core
    web vitals, such as LCP, here: [https://web.dev/vitals/](https://web.dev/vitals/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了核心网页关键指标。您可以在以下链接中了解更多关于核心网页关键指标的信息，例如LCP：[https://web.dev/vitals/](https://web.dev/vitals/).
