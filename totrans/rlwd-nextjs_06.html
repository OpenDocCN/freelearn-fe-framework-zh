<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-54"><em class="italic"><a id="_idTextAnchor053"/>Chapter 4</em>: Organizing the Code Base and Fetching Data in Next.js</h1>
			<p>Next.js initially became popular thanks to its ability to make it easy to render React pages on the server instead of the client only. However, to render specific components, we often need some data coming from external sources such as APIs and databases.</p>
			<p>In this chapter, we will first see how to organize our folder structure, as this will be the determinant for keeping the Next.js dataflow neat when managing the application state (as we will see in <a href="B16985_05_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Local and Global States in Next.js</em>), and then we will see how to integrate external REST and GraphQL APIs, both on client and server-side.</p>
			<p>As our application grows, its complexity will inevitably increase, and we need to be prepared for this since the bootstrapping phase of the project. As soon as we implement new features, we will need to add new components, utilities, styles, and pages. For that reason, we will take a closer look at organizing our components on the basis of the atomic design principles, utility functions, styles, and how to make your code base ready for handling the application state quickly and neatly.</p>
			<p>We will cover the following topics in detail:</p>
			<ul>
				<li>Organizing our components using the atomic design principle</li>
				<li>Organizing our utility functions</li>
				<li>Organizing static assets neatly</li>
				<li>An introduction to organizing styling files</li>
				<li>What <strong class="source-inline">lib</strong> files are and how to organize them</li>
				<li>Consuming REST APIs on the server side only</li>
				<li>Consuming REST APIs on the client side only</li>
				<li>Setting Apollo to consume GraphQL APIs both on client and server</li>
			</ul>
			<p>By the end of this chapter, you will know how to organize your code base by following the atomic design principles for your components and how to split up different utility files logically. You will also learn how to consume REST and GraphQL APIs.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine. If you prefer, you can use an online IDE such as <a href="https://repl.it">https://repl.it</a> or <a href="https://codesandbox.io">https://codesandbox.io</a>, as they both support Next.js and you don't need to install any dependency on your computer.</p>
			<p>You can find the code base for this chapter on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Next.js">https://github.com/PacktPublishing/Real-World-Next.js</a>.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Organizing the folder structure</h1>
			<p>Organizing your<a id="_idIndexMarker152"/> new project's folder structure neatly and clearly is incredibly important in terms of keeping your code base scalable and maintainable.</p>
			<p>As we've already seen, Next.js forces you to place some files and folders in particular locations of your code base (think of <strong class="source-inline">_app.js</strong> and <strong class="source-inline">_documents.js</strong> files, the <strong class="source-inline">pages/</strong> and <strong class="source-inline">public/</strong> directories, and so on), but it also provides a way to customize their placement inside your project repository.</p>
			<p>We've already seen that, but let's do a quick recap on a default Next.js folder structure:</p>
			<p class="source-code">next-js-app</p>
			<p class="source-code">  - node_modules/</p>
			<p class="source-code">  - package.json</p>
			<p class="source-code">  - pages/</p>
			<p class="source-code">  - public/</p>
			<p class="source-code">  - styles/</p>
			<p>Reading from top to bottom, when we create a new Next.js app using <strong class="source-inline">create-next-app</strong>, we get the following folders:</p>
			<ul>
				<li><strong class="source-inline">node_modules/</strong>: The default folder for Node.js project dependencies</li>
				<li><strong class="source-inline">pages/</strong>: The directory where we place our pages and build the routing system for our web app</li>
				<li><strong class="source-inline">public/</strong>: The directory where we place files to be served as static assets (compiled CSS and JavaScript files, images, and icons)</li>
				<li><strong class="source-inline">styles/</strong>: The directory where we place our styling modules, regardless of their format (CSS, SASS, LESS)</li>
			</ul>
			<p>From here, we can start customizing our repository structure to make it easier to navigate through. The first thing to know is that Next.js allows us to move our <strong class="source-inline">pages/</strong> directory inside an <strong class="source-inline">src/</strong> folder. We can also move all the other directories (except for the <strong class="source-inline">public/</strong> one and <strong class="source-inline">node_modules</strong>, of course) inside <strong class="source-inline">src/</strong>, making our root directory a bit tidier.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Remember that if you have both <strong class="source-inline">pages/</strong> and <strong class="source-inline">src/pages/</strong> directories in your project, Next.js will ignore <strong class="source-inline">src/pages/</strong>, as the root level <strong class="source-inline">pages/</strong> directory takes precedence.</p>
			<p>We will now<a id="_idIndexMarker153"/> take a look at some popular conventions for organizing the whole code base, starting with React components, in the next section.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Organizing the components</h2>
			<p>Now, let's see<a id="_idIndexMarker154"/> an example of a real-world folder structure, including some styling assets (<a href="B16985_06_Final_SB_epub.xhtml#_idTextAnchor075"><em class="italic">Chapter 6</em></a>, <em class="italic">CSS and Built-In Styling Methods)</em> and test files (<a href="B16985_09_Final_SB_epub.xhtml#_idTextAnchor096"><em class="italic">Chapter 9</em></a>, <em class="italic">Testing Next.js</em>).</p>
			<p>As for now, we will only discuss a folder structure that can help us write and find configuration files, components, tests, and styles with ease. We will dig into the previously quoted technologies in their respective chapters.</p>
			<p>We have different ways of setting up our folder structure. We can start by separating components into three different categories and then putting styles and tests in the same folder for each component.</p>
			<p>To do that, create a new <strong class="source-inline">components/</strong> folder inside our root directory. Then, by moving inside it, create the following folders:</p>
			<p class="source-code">mkdir components &amp;&amp; cd components</p>
			<p class="source-code">mkdir atoms</p>
			<p class="source-code">mkdir molecules</p>
			<p class="source-code">mkdir organisms</p>
			<p class="source-code">mkdir templates</p>
			<p>As you may have <a id="_idIndexMarker155"/>noticed, we're following the <em class="italic">atomic design principle</em>, where we want to divide our components into different levels so as to organize our code base better. This is just a popular convention, and you're free to follow any other approach for organizing your code. </p>
			<p>We will divide our components into four categories:</p>
			<ul>
				<li><strong class="source-inline">atoms</strong>: These are the <a id="_idIndexMarker156"/>most basic components that we will ever write in our code base. Sometimes, they act as a wrapper for standard HTML elements such as <strong class="source-inline">button</strong>, <strong class="source-inline">input</strong>, and <strong class="source-inline">p</strong>, but we can also add animations, color palettes, and so on, to this category of components.</li>
				<li><strong class="source-inline">molecules</strong>: These are a small group of atoms combined to create slightly more complex structures with a minimum of utility. The input atom and the label atom together can be a straightforward example of what a molecule is.</li>
				<li><strong class="source-inline">organisms</strong>: Molecules and atoms combine to create complex structures, such as a registration form, a footer, and a carousel.</li>
				<li><strong class="source-inline">templates</strong>: We can think of templates as the skeleton of our pages. Here, we decide where to put organisms, atoms, and molecules together to create the final page that the user will browse.</li>
			</ul>
			<p>If you're interested in learning more about atomic design, here's a good article explaining it in detail: <a href="https://bradfrost.com/blog/post/atomic-web-design">https://bradfrost.com/blog/post/atomic-web-design</a>.</p>
			<p>Now, let's pretend that we want to create a <strong class="source-inline">Button</strong> component. When we create a new component, we often need at least three different files: the component itself, its style, and a test file. We can create those files by moving inside <strong class="source-inline">components/atoms/</strong> and then creating a new folder called <strong class="source-inline">Button/</strong>. Once we create this folder, we can move on to creating the components' files:</p>
			<p class="source-code">cd components/atoms/Button</p>
			<p class="source-code">touch index.js</p>
			<p class="source-code">touch button.test.js</p>
			<p class="source-code">touch button.styled.js # or style.module.css</p>
			<p>Organizing our components that way will help us a lot when we need to search, update, or fix a given component. Let's say that we spot a bug in production that involves our <strong class="source-inline">Button</strong> component. We can easily find the component inside our code base, find its test and styling files, and fix them.</p>
			<p>Of course, following<a id="_idIndexMarker157"/> the atomic design principle is not a must, but I'd personally recommend it as it helps keep the project structure tidy and easy to maintain over time. </p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Organizing utilities</h2>
			<p>There are<a id="_idIndexMarker158"/> specific files that don't export any component; they're just modular scripts used for many different purposes. We're talking here about the utility scripts.</p>
			<p>Let's pretend that we have several components whose purpose is to check whether a particular hour of the day has passed to display certain information. It wouldn't make any sense to write the same function inside every component. We can therefore write a generic utility function and then import it inside every component that needs that kind of feature.</p>
			<p>We can put all of our utility functions inside a <strong class="source-inline">utility/</strong> folder and then divide our utilities into different files according to their purpose. For example, let's say that we need four utility functions: the first one will make computations based on the current time, the second will execute certain operations on <strong class="source-inline">localStorage</strong>, the third will work with <strong class="bold">JWT (JSON Web Token)</strong>, and the last one will help us to write better logs for our<a id="_idIndexMarker159"/> applications.</p>
			<p>We can proceed by creating four different files inside the <strong class="source-inline">utilities/</strong> directory:</p>
			<p class="source-code">cd utilities/</p>
			<p class="source-code">touch time.js</p>
			<p class="source-code">touch localStorage.js</p>
			<p class="source-code">touch jwt.js</p>
			<p class="source-code">touch logs.js</p>
			<p>Now that we've created our files, we can proceed by creating their respective test files:</p>
			<p class="source-code">touch time.test.js</p>
			<p class="source-code">touch localStorage.test.js</p>
			<p class="source-code">touch jwt.test.js</p>
			<p class="source-code">touch logs.test.js</p>
			<p>At this point, we have our utilities grouped by their scope, which makes it easy to remember from which file we need to import a specific function during the development process.</p>
			<p>There might <a id="_idIndexMarker160"/>be other approaches for organizing utility files. You may want to create a folder for each utility file so that you can put tests, styles, and other stuff inside it, thereby making your code base even more organized. It's totally up to you!</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Organizing static assets</h2>
			<p>As seen in the<a id="_idIndexMarker161"/> previous chapter, Next.js makes it easy to serve static files, as you only need to put them inside the <strong class="source-inline">public/</strong> folder, and the framework will do the rest.</p>
			<p>From this point, we need to figure out which static files we need to serve from our Next.js application.</p>
			<p>In a standard website, we may want to serve at least the following static assets:</p>
			<ul>
				<li>Images</li>
				<li>Compiled JavaScript files</li>
				<li>Compiled CSS files</li>
				<li>Icons (including favicon and web app icons)</li>
				<li><strong class="source-inline">manifest.json</strong>, <strong class="source-inline">robot.txt</strong>, and other static files</li>
			</ul>
			<p>Moving inside our <strong class="source-inline">public/</strong> folder, we can create a new directory called <strong class="source-inline">assets/</strong>:</p>
			<p class="source-code">cd public &amp;&amp; mkdir assets</p>
			<p>And inside that newly created directory, we will be creating a new folder for each type of static asset:</p>
			<p class="source-code">cd assets</p>
			<p class="source-code">mkdir js</p>
			<p class="source-code">mkdir css</p>
			<p class="source-code">mkdir icons</p>
			<p class="source-code">mkdir images</p>
			<p>We will place<a id="_idIndexMarker162"/> our compiled vendor JavaScript files inside the <strong class="source-inline">js/</strong> directory and do the same with compiled vendor CSS files (inside the <strong class="source-inline">css/</strong> directory, of course). When starting our Next.js server, we will be able to reach those public files under http://localhost:3000/assets/js/&lt;any-js-file&gt; and http://localhost:3000/assets/css/&lt;any-css-file&gt;. We will also be able to reach every public image by calling the following URL, http://localhost:3000/assets/image/&lt;any-image-file<span class="hidden">&gt;</span>, but I suggest that you serve those kinds of assets using the built-in <strong class="source-inline">Image</strong> component, as seen in the previous chapter.</p>
			<p>The <strong class="source-inline">icons/</strong> directory will primarily be used to serve our <em class="italic">web app manifest</em> icons. The web app manifest is a JSON file that includes some useful information about the progressive web app that you're building, such as the app name and the icons to use when installing it on a mobile device. You can learn more about the web app manifest on <a href="https://web.dev/add-manifest">https://web.dev/add-manifest</a>.</p>
			<p>We can easily create this manifest file by entering the <strong class="source-inline">public/</strong> folder and adding a new file called <strong class="source-inline">manifest.json</strong>:</p>
			<p class="source-code">cd public/ &amp;&amp; touch manifest.json</p>
			<p>At this point, we can fill the JSON file with some basic information. Let's take the following JSON <a id="_idIndexMarker163"/>as an example:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "My Next.js App",</p>
			<p class="source-code">  "short_name": "Next.js App",</p>
			<p class="source-code">  "description": "A test app made with next.js",</p>
			<p class="source-code">  "background_color": "#a600ff",</p>
			<p class="source-code">  "display": "standalone",</p>
			<p class="source-code">  "theme_color": "#a600ff",</p>
			<p class="source-code">  "icons": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "src": <strong class="bold">"/assets/icons/icon-192.png"</strong>,</p>
			<p class="source-code">      "type": "image/png",</p>
			<p class="source-code">      "sizes": "192x192"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "src": <strong class="bold">"/assets/icons/icon-512.png"</strong>,</p>
			<p class="source-code">      "type": "image/png",</p>
			<p class="source-code">      "sizes": "512x512"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>We can include that file using an HTML meta tag, as seen in <a href="B16985_03_Final_SB_epub.xhtml#_idTextAnchor038"><em class="italic">Chapter 3</em></a>, <em class="italic">Next.js Basics and Built-In Components</em>:</p>
			<p class="source-code">&lt;link rel="manifest" href=<strong class="bold">"/manifest.json"</strong>&gt;</p>
			<p>That way, users browsing your Next.js app from a mobile device will be able to install it on their <a id="_idIndexMarker164"/>smartphones or tablets.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Organizing styles</h2>
			<p>Style organization <a id="_idIndexMarker165"/>can really depend on the stack you want to use to style your Next.js application.</p>
			<p>Starting from <em class="italic">CSSinJS</em> frameworks such as <em class="italic">Emotion</em>, <em class="italic">styled-components</em>, <em class="italic">JSS</em>, and similar ones, one common approach is to create a specific styling file for each component; that way, it will be easier for us to find a particular component style inside our code base when we need to make some changes.</p>
			<p>However, even though separating styling files depending on their respective components can help us keep our code base organized, we may need to create some common styles or utility files, such as color palettes, themes, and media queries.</p>
			<p>In that case, it can be useful to reuse the default <strong class="source-inline">styles/</strong> directory shipped with a default Next.js installation. We can put our common styles inside that folder and import them inside other styling files only when we need them.</p>
			<p>That said, there isn't really a standard way to organize styling files. We will take a closer look at those files in both <a href="B16985_06_Final_SB_epub.xhtml#_idTextAnchor075"><em class="italic">Chapter 6</em></a>, <em class="italic">CSS and Built-In Styling Methods</em>, and <a href="B16985_07_Final_SB_epub.xhtml#_idTextAnchor081"><em class="italic">Chapter 7</em></a>, <em class="italic">Using UI Frameworks</em>.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Lib files</h2>
			<p>When talking<a id="_idIndexMarker166"/> about lib files, we refer to scripts that explicitly wrap third-party libraries as lib files. While the utility scripts are very generic and can be used by many different components and libraries, the lib files are specific for a certain library. To make the concept clearer, let's talk about GraphQL for a moment.</p>
			<p>As we're going to see in <em class="italic">Data fetching</em>, the last section of this chapter, we will need to initialize a GraphQL client, save some GraphQL queries and mutations locally, and so on. To make those scripts more modular, we will store them inside a new folder called <strong class="source-inline">graphql/</strong>, which lies inside a <strong class="source-inline">lib/</strong> directory, at the root of our project.</p>
			<p>If we try to visualize the folder structure for the preceding example, we will end up with the following schema:</p>
			<p class="source-code">next-js-app</p>
			<p class="source-code">  - lib/</p>
			<p class="source-code">    - graphql/</p>
			<p class="source-code">      - index.js</p>
			<p class="source-code">      - queries/</p>
			<p class="source-code">        - query1.js</p>
			<p class="source-code">        - query2.js</p>
			<p class="source-code">      - mutations/</p>
			<p class="source-code">        - mutation1.js</p>
			<p class="source-code">        - mutation2.js</p>
			<p>Other lib scripts can include all those files connecting and making queries to Redis, RabbitMQ, and so on, or functions specific to any external library.</p>
			<p>While an organized folder structure seems out of context when talking about the Next.js data flow, it can actually help us to manage the application state, as we will see in <a href="B16985_05_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Local and Global States in Next.js</em></p>
			<p>But talking about the application state, we want our components to be dynamic most of the time, meaning that they can render content and behave differently depending on the global <a id="_idIndexMarker167"/>application state or the data coming from external services. In fact, we need to call external APIs to retrieve our web app content dynamically in many cases. In the next section, we will see how to fetch data on the client and server sides, using both GraphQL and REST clients.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Data fetching</h1>
			<p>As seen in the <a id="_idIndexMarker168"/>previous chapters, Next.js allows us to fetch data on both the client and server sides. Server-side data fetching could happen in two different moments: at build time (using <strong class="source-inline">getStaticProps</strong> for static pages), and at runtime (using <strong class="source-inline">getServerSideProps</strong> for server-side rendered pages).</p>
			<p>Data can come from several resources: databases, search engines, external APIs, filesystems, and many other sources. Even if it's technically possible for Next.js to access a database and query for specific data, I'd personally discourage that approach as Next.js should only care about the frontend of our application.</p>
			<p>Let's take an example: we're building a blog, and we want to display an author page showing their name, job title, and biography. In that example, the data is stored in a MySQL database, and we could easily access it using any MySQL client for Node.js.</p>
			<p>Even though accessing that data from Next.js can be relatively easy, it would make our app less secure. A malicious user could potentially find a way to exploit our data using an unknown framework vulnerability, injecting malicious code, and using other techniques to steal our data.</p>
			<p>For that reason, I strongly suggest delegating database connections and queries to external systems (in other words, CMSes such as <em class="italic">WordPress</em>, <em class="italic">Strapi</em>, and <em class="italic">Contentful</em>) or backend frameworks (in other words, <em class="italic">Spring</em>, <em class="italic">Laravel</em>, and <em class="italic">Ruby on Rails</em>), which will make sure that the data is coming from a trusted source, will sanitize the user input detecting  potentially malicious code, and will establish a secure connection between your Next.js application and their APIs.</p>
			<p>In the following <a id="_idIndexMarker169"/>sections, we will see how to integrate <em class="italic">REST</em> and <em class="italic">GraphQL</em> APIs from both the client side and the server side.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Fetching data on the server side</h2>
			<p>As we've seen <a id="_idIndexMarker170"/>so far, Next.js allows us to fetch data on the server <a id="_idIndexMarker171"/>side by using its built-in <strong class="source-inline">getStaticProps</strong> and <strong class="source-inline">getServerSideProps</strong> functions.</p>
			<p>Given that Node.js doesn't support JavaScript <strong class="source-inline">fetch</strong> APIs like browsers do, we have two options for making HTTP requests on the server:</p>
			<ol>
				<li>Using the Node.js' built-in <strong class="source-inline">http</strong> library: We can use this module without installing any external dependency, but even if its APIs are really simple and well made, it would require a bit of extra work when compared to third-party HTTP clients.</li>
				<li>Using HTTP client libraries: There are several great HTTP clients for Next.js, making it really straightforward to make HTTP requests from the server. Popular libraries include <em class="italic">isomorphic-unfetch</em> (this renders the JavaScript <strong class="source-inline">fetch</strong> API available on Node.js), <em class="italic">Undici</em> (an official Node.js HTTP 1.1 client), and <em class="italic">Axios</em> (a very popular HTTP client that runs both on client and server with the same APIs).</li>
			</ol>
			<p>In the next section, we will be using <em class="italic">Axios</em> to make REST requests, as it is probably one of the most frequently used HTTP clients for both client and server (with ~17,000,000 downloads per <a id="_idIndexMarker172"/>week on npm), and there's a high chance that you will<a id="_idIndexMarker173"/> be using it sooner or later.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Consuming REST APIs on the server side</h2>
			<p>When discussing<a id="_idIndexMarker174"/> the integration of REST APIs, we <a id="_idIndexMarker175"/>need <a id="_idIndexMarker176"/>to divide them into <em class="italic">public</em> and <em class="italic">private</em> APIs. The public ones are accessible by anyone without any kind of authorization, and the private ones always need to be authorized to return some data.</p>
			<p>Also, the authorization method is not always the same (and different APIs might require different authorization methods), as it depends on who developed the APIs and the choices they made. For instance, if you want to consume any of the <em class="italic">Google</em> APIs, you would need to go into a process called <em class="italic">OAuth 2.0</em>, which is an industry standard for securing APIs under user authentication. You can read more about OAuth 2.0 in the official Google documentation: <a href="https://developers.google.com/identity/protocols/oauth2">https://developers.google.com/identity/protocols/oauth2</a>.</p>
			<p>Other APIs, such<a id="_idIndexMarker177"/> as the <em class="italic">Pexels</em> APIs (<a href="https://www.pexels.com/api/documentation">https://www.pexels.com/api/documentation</a>), allow you to consume their contents using an <em class="italic">API key</em>, which is basically an authorization token that you'll need to send within your request.</p>
			<p>There may be other ways in which to authorize your requests, but Oauth 2.0, JWT, and API Key are the most common ways that you'll likely encounter while developing your Next.js applications.</p>
			<p>If, after reading this section, you want to experiment with different APIs and authorization methods, here's an awesome GitHub repository containing a list of free REST APIs: https://github.com/public-apis/public-apis.</p>
			<p>For now, we will be using a custom API explicitly made for this book: <a href="https://api.realworldnextjs.com">https://api.realworldnextjs.com</a> (or, if you prefer: https://api.rwnjs.com). We can start by creating a new Next.js project:</p>
			<p class="source-code">npx create-next-app ssr-rest-api</p>
			<p>After running the Next.js initialization script, we can add <strong class="source-inline">axios</strong> as a dependency, as we'll use it as an HTTP client for making REST requests:</p>
			<p class="source-code">cd ssr-rest-api</p>
			<p class="source-code">yarn add axios</p>
			<p>At this point, we can easily edit the default Next.js index page. Here, we will list some users using a public API exposing just their usernames and personal IDs. After we click on one of the usernames, we will be redirected to a detail page to see more personal details for our users.</p>
			<p>Let's <a id="_idIndexMarker178"/>start <a id="_idIndexMarker179"/>by <a id="_idIndexMarker180"/>creating the <strong class="source-inline">pages/index.js</strong> page layout:</p>
			<p class="source-code">import { useEffect } from 'react';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">export async function getServerSideProps() {</p>
			<p class="source-code">  // Here we will make the REST request to our APIs</p>
			<p class="source-code">}</p>
			<p class="source-code">function HomePage({ users }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ul&gt;</p>
			<p class="source-code">      {</p>
			<p class="source-code">        users.map((user) =&gt;</p>
			<p class="source-code">          &lt;li key={user.id}&gt;</p>
			<p class="source-code">            &lt;Link</p>
			<p class="source-code">              href={`/users/${user.username}`}</p>
			<p class="source-code">              passHref</p>
			<p class="source-code">            &gt;</p>
			<p class="source-code">              &lt;a&gt; {user.username} &lt;/a&gt;</p>
			<p class="source-code">            &lt;/Link&gt;</p>
			<p class="source-code">          &lt;/li&gt;</p>
			<p class="source-code">        )</p>
			<p class="source-code">      }</p>
			<p class="source-code">    &lt;/ul&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default HomePage;</p>
			<p>If we try to run the preceding code, we will see an error, as we don't yet have our users' data. We need to call a REST API from the built-in <strong class="source-inline">getServerSideProps</strong> and pass the <a id="_idIndexMarker181"/>request<a id="_idIndexMarker182"/> result <a id="_idIndexMarker183"/>as a prop to the <strong class="source-inline">HomePage</strong> component:</p>
			<p class="source-code">import { useEffect } from 'react';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code"><strong class="bold">import axios from 'axios';</strong></p>
			<p class="source-code"><strong class="bold">export async function getServerSideProps() {</strong></p>
			<p class="source-code"><strong class="bold">  const usersReq =</strong></p>
			<p class="source-code"><strong class="bold">    await axios.get('https://api.rwnjs.com/04/users')</strong></p>
			<p class="source-code"><strong class="bold">  return {</strong></p>
			<p class="source-code"><strong class="bold">    props: {</strong></p>
			<p class="source-code"><strong class="bold">      users: usersReq.data</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p class="source-code">function HomePage({ users }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ul&gt;</p>
			<p class="source-code">      {</p>
			<p class="source-code">        users.map((user) =&gt;</p>
			<p class="source-code">          &lt;li key={user.id}&gt;</p>
			<p class="source-code">            &lt;Link</p>
			<p class="source-code">              href={`/users/${user.username}`}</p>
			<p class="source-code">              passHref</p>
			<p class="source-code">            &gt;</p>
			<p class="source-code">              &lt;a&gt; {user.username} &lt;/a&gt;</p>
			<p class="source-code">            &lt;/Link&gt;</p>
			<p class="source-code">          &lt;/li&gt;</p>
			<p class="source-code">        )</p>
			<p class="source-code">      }</p>
			<p class="source-code">    &lt;/ul&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default HomePage;</p>
			<p>Now, run <a id="_idIndexMarker184"/>the <a id="_idIndexMarker185"/>server <a id="_idIndexMarker186"/>and then go to <strong class="source-inline">http://localhost:3000</strong>. We should see the following list of users to appear on the browser:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_4.01_B16985.jpg" alt="Figure 4.1 – API result rendered on the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – API result rendered on the browser</p>
			<p>If we now try to click on one of the listed users, we will be redirected to a 404 page, as we haven't created a single page user yet.</p>
			<p>We can solve that problem by creating a new file, <strong class="source-inline">pages/users/[username].js</strong>, and calling another REST API to get the single user data.</p>
			<p>To get the single user data, we can call the following URL, https://api.rwnjs.com/04/users/[username], where <strong class="source-inline">[username]</strong> is a <a id="_idIndexMarker187"/>route <a id="_idIndexMarker188"/>variable representing<a id="_idIndexMarker189"/> the user we want to get the data of.</p>
			<p>Let's move to the <strong class="source-inline">pages/users/[username].js</strong> file and add the following content, starting with the <strong class="source-inline">getServerSideProps</strong> function:</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">import axios from 'axios';</p>
			<p class="source-code">export async function getServerSideProps(ctx) {</p>
			<p class="source-code">  const { username } = ctx.query;</p>
			<p class="source-code">  const userReq =</p>
			<p class="source-code">    await axios.get(</p>
			<p class="source-code">      `https://api.rwnjs.com/04/users/${username}`</p>
			<p class="source-code">    );</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      user: userReq.data</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p>Now, inside <a id="_idIndexMarker190"/>the<a id="_idIndexMarker191"/> same file, let's add a <strong class="source-inline">UserPage</strong> function, which will be the page template for<a id="_idIndexMarker192"/> our <strong class="source-inline">/users/[username]</strong> route:</p>
			<p class="source-code">function UserPage({ user }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href="/" passHref&gt;</p>
			<p class="source-code">          Back to home</p>
			<p class="source-code">        &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;hr /&gt;</p>
			<p class="source-code">      &lt;div style={{ display: 'flex' }}&gt;</p>
			<p class="source-code">        &lt;img</p>
			<p class="source-code">         src={user.profile_picture}</p>
			<p class="source-code">         alt={user.username}</p>
			<p class="source-code">         width={150}</p>
			<p class="source-code">         height={150}</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;b&gt;Username:&lt;/b&gt; {user.username}</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;b&gt;Full name:&lt;/b&gt;</p>
			<p class="source-code">              {user.first_name} {user.last_name}</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;b&gt;Email:&lt;/b&gt; {user.email}</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;b&gt;Company:&lt;/b&gt; {user.company}</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p class="source-code">          &lt;div&gt;</p>
			<p class="source-code">            &lt;b&gt;Job title:&lt;/b&gt; {user.job_title}</p>
			<p class="source-code">          &lt;/div&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default UserPage;</p>
			<p>But there's still a problem: if we try to render a single user page, we will get an error on the server side as we are not authorized to get the data from that API. Remember what we said at the beginning of this section? Not all APIs are public, which makes a lot of sense as there are times where we want to access very private information and companies and developers protect this information by restricting access to their APIs to authorized people only.</p>
			<p>In that case, we need to pass a valid token as an HTTP authorization header while making the API <a id="_idIndexMarker193"/>request, such that the server will <a id="_idIndexMarker194"/>know<a id="_idIndexMarker195"/> that we are authorized to access this information:</p>
			<p class="source-code">export async function getServerSideProps(ctx) {</p>
			<p class="source-code">  const { username } = ctx.query;</p>
			<p class="source-code">  const userReq = await axios.get(</p>
			<p class="source-code">    `https://api.rwnjs.com/04/users/${username}`,</p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">      headers: {</strong></p>
			<p class="source-code"><strong class="bold">        authorization: process.env.API_TOKEN</strong></p>
			<p class="source-code"><strong class="bold">      }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">  );</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      user: userReq.data</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p>As you can see, <strong class="source-inline">axios</strong> makes it really easy to add an HTTP header to the request, as we only need to pass an object as the second argument of its <strong class="source-inline">get</strong> method, containing a property called <strong class="source-inline">headers</strong>, which is an object including all the HTTP headers we want to send to the server within our request.</p>
			<p>You may be wondering what <strong class="source-inline">process.env.API_TOKEN</strong> stands for. While it is possible to pass a hardcoded string as a value for that header, it is bad practice for the following reasons:</p>
			<ol>
				<li value="1">When committing your code using Git or any other version control system, everyone having access to that repository will be able to read private information such as the authorization token (even outside collaborators). Consider this as a password that should be kept secret.</li>
				<li>Most of the time, API tokens change depending on the stage at which we're running our application: running our app locally, we may want to access APIs using a test token, and<a id="_idIndexMarker196"/> use a production one <a id="_idIndexMarker197"/>when deploying it. Using an environment<a id="_idIndexMarker198"/> variable will make it easier for us to use different tokens depending on the environment. The same is valid for API endpoints, but we will see that later on in this section.</li>
				<li>If an API token changes for any reason, you can easily edit it using a shared environment file for the whole app instead of changing the token value in every HTTP request.</li>
			</ol>
			<p>So, instead of manually writing sensitive data inside our files, we can create a new file called <strong class="source-inline">.env</strong> inside our project's root and add all the information we need for our application to run.</p>
			<p class="callout-heading">Never Commit Your .env File</p>
			<p class="callout">The <strong class="source-inline">.env</strong> file contains sensitive and private information and should never be committed using any version control software. Make sure to add <strong class="source-inline">.env</strong> to your <strong class="source-inline">.gitignore</strong>, <strong class="source-inline">.dockerignore</strong>, and other similar files before deploying or committing your code.</p>
			<p>Now, let's create and edit the <strong class="source-inline">.env</strong> file by adding the following content:</p>
			<p class="source-code"><strong class="bold">API_TOKEN=realworldnextjs</strong></p>
			<p class="source-code"><strong class="bold">API_ENDPOINT=https://api.rwnjs.com</strong></p>
			<p>Next.js has built-in support for <strong class="source-inline">.env</strong> and <strong class="source-inline">.env.local</strong> files, so you don't have to install external libraries to access those environment variables. </p>
			<p>After we've edited the file, we can restart the Next.js server and click on any user listed on the home page, thereby accessing the user detail page, which should look like this:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_4_02_B16985.jpg" alt="Figure 4.2 – The user detail page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The user detail page</p>
			<p>If we try<a id="_idIndexMarker199"/> to <a id="_idIndexMarker200"/>reach <a id="_idIndexMarker201"/>a page such as <strong class="source-inline">http://localhost:3000/users/mitch</strong>, we will get an error, as a user with <strong class="source-inline">mitch</strong> as their username does not exist, and the REST API will return a <strong class="source-inline">404</strong> status code. We can easily catch this error and return the Next.js default 404 page by just adding the following script to the <strong class="source-inline">getServerSideProps</strong> function:</p>
			<p class="source-code">export async function getServerSideProps(ctx) {</p>
			<p class="source-code">  const { username } = ctx.query;</p>
			<p class="source-code">  const userReq = await axios.get(</p>
			<p class="source-code">    `${process.env.API_ENDPOINT}/04/users/${username}`,</p>
			<p class="source-code">    {</p>
			<p class="source-code">      headers: {</p>
			<p class="source-code">        authorization: process.env.API_TOKEN</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  );</p>
			<p class="source-code"><strong class="bold">  if (userReq.status === 404) {</strong></p>
			<p class="source-code"><strong class="bold">    return {</strong></p>
			<p class="source-code"><strong class="bold">      notFound: true</strong></p>
			<p class="source-code"><strong class="bold">    };</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      user: userReq.data</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p>That way, Next.js<a id="_idIndexMarker202"/> will automatically redirect us <a id="_idIndexMarker203"/>to <a id="_idIndexMarker204"/>its default <strong class="source-inline">404</strong> page with no other configuration needed.</p>
			<p>So, we've seen how Next.js allows us to fetch data exclusively on the server side by using its built-in <strong class="source-inline">getServerSideProps</strong> function. We could have used the <strong class="source-inline">getStaticProps</strong> function instead, meaning that the page would have been statically rendered at<a id="_idIndexMarker205"/> build<a id="_idIndexMarker206"/> time, as<a id="_idIndexMarker207"/> seen in <a href="B16985_02_Final_SB_epub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring Different Rendering Strategies</em>.</p>
			<p>In the next section, we will see how to fetch data on the client side only.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Fetching data on the client side</h2>
			<p>Client-side data <a id="_idIndexMarker208"/>fetching is a crucial part of any dynamic web <a id="_idIndexMarker209"/>application. While server-side data fetching can be relatively secure (when done with caution), fetching data on the browser can add some extra complexities and vulnerabilities.</p>
			<p>Making HTTP requests on the server hides the API endpoint, parameters, HTTP headers, and possibly the authorization tokens from the users. However, doing so from the browser can reveal that private information, making it easy for malicious users to perform a plethora of possible attacks that exploit your data.</p>
			<p>When making HTTP requests on browsers, some specific rules are not optional:</p>
			<ol>
				<li value="1"><em class="italic">Make HTTP requests to trusted sources only</em>. You should always do some research about who is developing the APIs you're using and their security standards.</li>
				<li><em class="italic">Call HTTP APIs only when secured with an SSL certificate</em>. If a remote API is not secured under HTTPS, you're exposing yourself and your users to many attacks, such as man-in-the-middle, where a malicious user could sniff all the data passing from the client and the server using a simple proxy.</li>
				<li><em class="italic">Never connect to a remote database from the browser</em>. It may seem obvious, but it is technically possible for JavaScript to access remote databases. This exposes you and your users to high risk, as anyone could potentially exploit a vulnerability and gain access to your database.</li>
			</ol>
			<p>In the next section, we <a id="_idIndexMarker210"/>will take a closer look at consuming REST APIs<a id="_idIndexMarker211"/> on the client side.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Consuming REST APIs on the client side</h2>
			<p>Similar to the<a id="_idIndexMarker212"/> server side, fetching data on the client<a id="_idIndexMarker213"/> side<a id="_idIndexMarker214"/> is relatively easy, and if you already have experience in React or any other JavaScript framework or library, you can re-use your current knowledge for making REST requests from the browser without any complications.</p>
			<p>While the server-side data fetching phase in Next.js only occurs when declared inside its built-in <strong class="source-inline">getServerSideProps</strong> and <strong class="source-inline">getStaticProps</strong> functions, if we make a fetch request inside a given component, it will be executed on the client side by default.</p>
			<p>We usually want our client-side requests to run in two cases:</p>
			<ul>
				<li>Right after the component has mounted</li>
				<li>After a particular event occurs</li>
			</ul>
			<p>In both cases, Next.js doesn't force you to execute those requests differently than React, so you can basically make an HTTP request using the browser's built-in <strong class="source-inline">fetch</strong> API or an external library such as <strong class="source-inline">axios</strong>, just like we saw in the previous section. Let's try to recreate the same simple Next.js application from the previous section, but move all the API calls to the client side.</p>
			<p>Create a new <a id="_idIndexMarker215"/>Next.js project and edit the <strong class="source-inline">pages/index.js</strong> file as follows:</p>
			<p class="source-code">import { useEffect, useState } from 'react';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">function List({users}) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ul&gt;</p>
			<p class="source-code">      {</p>
			<p class="source-code">        users.map((user) =&gt;</p>
			<p class="source-code">          &lt;li key={user.id}&gt;</p>
			<p class="source-code">            &lt;Link</p>
			<p class="source-code">              href={`/users/${user.username}`}</p>
			<p class="source-code">              passHref</p>
			<p class="source-code">            &gt;</p>
			<p class="source-code">              &lt;a&gt; {user.username} &lt;/a&gt;</p>
			<p class="source-code">            &lt;/Link&gt;</p>
			<p class="source-code">          &lt;/li&gt;</p>
			<p class="source-code">        )</p>
			<p class="source-code">      }</p>
			<p class="source-code">    &lt;/ul&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">function Users() {</p>
			<p class="source-code">  const [loading, setLoading] = useState(true);</p>
			<p class="source-code">  const [data, setData] = useState(null);</p>
			<p class="source-code">  useEffect(async () =&gt; {</p>
			<p class="source-code">    const req =</p>
			<p class="source-code">      await fetch('https://api.rwnjs.com/04/users');</p>
			<p class="source-code">    const users = await req.json();</p>
			<p class="source-code">    setLoading(false);</p>
			<p class="source-code">    setData(users);</p>
			<p class="source-code">  }, []);</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      {loading &amp;&amp;&lt;div&gt;Loading users...&lt;/div&gt;}</p>
			<p class="source-code">      {data &amp;&amp;&lt;List users={data} /&gt;}</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Users;</p>
			<p>Can you <a id="_idIndexMarker216"/>spot <a id="_idIndexMarker217"/>the<a id="_idIndexMarker218"/> differences between this component and its SSR counterpart?</p>
			<ul>
				<li>The HTML generated on the server side contains the <strong class="source-inline">Loading users...</strong> text, as it is the initial state of our <strong class="source-inline">HomePage</strong> component.</li>
				<li>We will be able to see a list of users only after React hydration occurs. We will need to wait for the component to mount on the client side and the HTTP request to be spawned using the browser's <strong class="source-inline">fetch</strong> API.</li>
			</ul>
			<p>Now we need to implement the single user page as follows:</p>
			<ol>
				<li value="1">Let's create a new file, <strong class="source-inline">pages/users/[username].js</strong>, and start writing the <strong class="source-inline">getServerSideProps</strong> function, where we fetch the <strong class="source-inline">[username]</strong> variable from the route and the authorization token from the <strong class="source-inline">.env</strong> file:<p class="source-code">import { useEffect, useState } from 'react'</p><p class="source-code">import Link from 'next/link';</p><p class="source-code">export async function getServerSideProps({ query }) {</p><p class="source-code">  const { username } = query;</p><p class="source-code">  return {</p><p class="source-code">    props: {</p><p class="source-code">      username,</p><p class="source-code">      authorization: process.env.API_TOKEN</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now, inside the same file, let's create the <strong class="source-inline">UserPage</strong> component, where we'll execute <a id="_idIndexMarker219"/>the<a id="_idIndexMarker220"/> client-side data fetching <a id="_idIndexMarker221"/>function:<p class="source-code">function UserPage({ username, authorization }) {</p><p class="source-code">  const [loading, setLoading] = useState(true);</p><p class="source-code">  const [data, setData] = useState(null);</p><p class="source-code">  useEffect(async () =&gt; {</p><p class="source-code">    const req = await fetch(</p><p class="source-code">      `https://api.rwnjs.com/04/users/${username}`,</p><p class="source-code">      { headers: { authorization } }</p><p class="source-code">    );</p><p class="source-code">    const reqData = await req.json();</p><p class="source-code">    setLoading(false);</p><p class="source-code">    setData(reqData);</p><p class="source-code">  }, []);</p><p class="source-code">  return (</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;Link href="/" passHref&gt;</p><p class="source-code">          Back to home</p><p class="source-code">        &lt;/Link&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;hr /&gt;</p><p class="source-code">      {loading &amp;&amp; &lt;div&gt;Loading user data...&lt;/div&gt;}</p><p class="source-code">      {data &amp;&amp; &lt;UserData user={data} /&gt;}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default UserPage;</p><p>As you may <a id="_idIndexMarker222"/>have noticed, once we set the <a id="_idIndexMarker223"/>data<a id="_idIndexMarker224"/> using the <strong class="source-inline">setData</strong> hook function, we render a <strong class="source-inline">&lt;UserData /&gt;</strong> component. </p></li>
				<li>Create that last component, always inside the same <strong class="source-inline">pages/users/[username].js</strong> component:<p class="source-code">function UserData({ user }) {</p><p class="source-code">  return (</p><p class="source-code">    &lt;div style={{ display: 'flex' }}&gt;</p><p class="source-code">      &lt;img</p><p class="source-code">        src={user.profile_picture}</p><p class="source-code">        alt={user.username}</p><p class="source-code">        width={150}</p><p class="source-code">        height={150}</p><p class="source-code">      /&gt;</p><p class="source-code">      &lt;div&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;b&gt;Username:&lt;/b&gt; {user.username}</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;b&gt;Full name:&lt;/b&gt;</p><p class="source-code">            {user.first_name} {user.last_name}</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;b&gt;Email:&lt;/b&gt; {user.email}</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;b&gt;Company:&lt;/b&gt; {user.company}</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;b&gt;Job title:&lt;/b&gt; {user.job_title}</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p>As you can see, we're using the same approach as we did for the home page, making an HTTP request as soon as the component mounts on the client side. We're also passing the <strong class="source-inline">API_TOKEN</strong> from the server to the client using <strong class="source-inline">getServerSideProps</strong> so that we can use it for making an authorized request. However, if you try to run the preceding code, you will see at least two problems.</p><p>The first one is related to <strong class="bold">CORS</strong>.</p></li>
			</ol>
			<p><strong class="bold">CORS</strong> (which <a id="_idIndexMarker225"/>stands for <strong class="bold">Cross-Origin Resource Sharing</strong>) is a security mechanism implemented by browsers that aims to control the requests made from domains different from those of the API domain. In our <strong class="source-inline">HomePage</strong> component, we've been able to call the <strong class="source-inline">https://api.rwnjs.com/04/users</strong> API from a different domain (localhost, a<a id="_idIndexMarker226"/> replit.co <a id="_idIndexMarker227"/>domain, CodeSandbox domain, and so on) as the server allowed any domain to <a id="_idIndexMarker228"/>access its resources for that specific route.</p>
			<p>In that case, however, the browser makes some restrictions on the <strong class="source-inline">https://api.rwnjs.com/04/users/[username]</strong> endpoint, and we're not able to call this API directly from the client as we get blocked by CORS policy. CORS can be tricky sometimes, and I encourage you to read more about it on the Mozilla Developer Network page dedicated to this security policy: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a>.</p>
			<p>The second problem relates to exposing the authorization token to the client. In fact, if we open the Google Chrome developer tools and go to <strong class="bold">Network</strong>, we can select the HTTP request for the <a id="_idIndexMarker229"/>endpoint<a id="_idIndexMarker230"/> and see the authorization token in plain text in the <strong class="bold">Request Headers</strong> section:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_4_03_B16985.jpg" alt="Figure 4.3 – The HTTP Request Headers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – The HTTP Request Headers</p>
			<p>So, what's wrong with that?</p>
			<p>Imagine that you're paying for a service exposing live weather updates via an API and pretend that it costs $1 for every 100 requests.</p>
			<p>A malicious user who wants to use that same service without paying could easily find your private<a id="_idIndexMarker231"/> authorization token in the request header and use it to power their weather web app. That way, if the malicious user makes 1,000 requests, you'll be paying $10 without actually using their services.</p>
			<p>We can quickly solve both problems thanks to the Next.js API pages, which allows us to quickly create a REST API, making the HTTP request for use on the server side and returning the result to the client.</p>
			<p>Let's create a new folder inside <strong class="source-inline">pages/</strong> called <strong class="source-inline">api/</strong> and a new file, <strong class="source-inline">pages/api/singleUser.js</strong>:</p>
			<p class="source-code">import axios from 'axios';</p>
			<p class="source-code">export default async function handler(req, res) {</p>
			<p class="source-code">  const username = req.query.username;</p>
			<p class="source-code">  const API_ENDPOINT = process.env.API_ENDPOINT;</p>
			<p class="source-code">  const API_TOKEN = process.env.API_TOKEN;</p>
			<p class="source-code">  const userReq = await axios.get(</p>
			<p class="source-code">    `${API_ENDPOINT}/04/users/${username}`,</p>
			<p class="source-code">    { headers: { authorization: API_TOKEN } }</p>
			<p class="source-code">  );</p>
			<p class="source-code">  res</p>
			<p class="source-code">    .status(200)</p>
			<p class="source-code">    .json(userReq.data);</p>
			<p class="source-code">}</p>
			<p>As you<a id="_idIndexMarker232"/> can<a id="_idIndexMarker233"/> see, in<a id="_idIndexMarker234"/> this case, we're exposing a simple function taking two arguments:</p>
			<ul>
				<li><strong class="source-inline">req</strong>: An instance of Node.js' <strong class="source-inline">http.IncomingMessage</strong> (<a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage">https://nodejs.org/api/http.html#http_class_http_incomingmessage</a>) merged with some pre-built middlewares such as <strong class="source-inline">req.cookies</strong>, <strong class="source-inline">req.query</strong>, and <strong class="source-inline">req.body</strong>.</li>
				<li><strong class="source-inline">res</strong>: An instance of Node.js' <strong class="source-inline">http.serverResponse</strong> (<a href="https://nodejs.org/api/http.html#http_class_http_serverresponse">https://nodejs.org/api/http.html#http_class_http_serverresponse</a>), merged with some pre-built middleware such as <strong class="source-inline">res.status(code)</strong> for setting the HTTP status code, <strong class="source-inline">res.json(json)</strong> for returning a valid JSON, <strong class="source-inline">res.send(body)</strong> for sending an HTTP response containing a <strong class="source-inline">string</strong>, an <strong class="source-inline">object</strong>, or a <strong class="source-inline">Buffer</strong>, and <strong class="source-inline">res.redirect([status,] path)</strong> for redirecting to a specific page with a given (and optional) status code.</li>
			</ul>
			<p>Every file inside the <strong class="source-inline">pages/api/</strong> directory will be considered by Next.js as an API route.</p>
			<p>Now we can <a id="_idIndexMarker235"/>refactor our <strong class="source-inline">UserPage</strong> component by changing the API endpoint to the newly<a id="_idIndexMarker236"/> created <a id="_idIndexMarker237"/>one:</p>
			<p class="source-code">function UserPage({ username }) {</p>
			<p class="source-code">  const [loading, setLoading] = useState(true);</p>
			<p class="source-code">  const [data, setData] = useState(null);</p>
			<p class="source-code">  useEffect(async () =&gt; {</p>
			<p class="source-code">    const req = await fetch(</p>
			<p class="source-code"><strong class="bold">      </strong>`<strong class="bold">/api/singleUser?username=${username}</strong>`<strong class="bold">,</strong></p>
			<p class="source-code">    );</p>
			<p class="source-code">    const data = await req.json();</p>
			<p class="source-code">    setLoading(false);</p>
			<p class="source-code">    setData(data);</p>
			<p class="source-code">  }, []);</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href="/" passHref&gt;</p>
			<p class="source-code">          Back to home</p>
			<p class="source-code">        &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;hr /&gt;</p>
			<p class="source-code">      {loading &amp;&amp; &lt;div&gt;Loading user data...&lt;/div&gt;}</p>
			<p class="source-code">      {data &amp;&amp; &lt;UserData user={data} /&gt;}</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>If we now try to run our website, we will see that both our problems are solved!</p>
			<p>But there's still something we need to pay attention to. We've hidden the API token by writing a kind of <em class="italic">proxy</em> for the single user API, but a malicious user would still be able to use the <strong class="source-inline">/api/singleUser</strong> route to access private data with ease.</p>
			<p>To solve<a id="_idIndexMarker238"/> that <a id="_idIndexMarker239"/>specific<a id="_idIndexMarker240"/> problem, we can act in a variety of different ways:</p>
			<ul>
				<li>Render the component list exclusively on the server, just like in the previous section: That way, a malicious user won't call a private API or steal a secret API token. However, there are cases where you cannot run those kinds of API calls on the server only; if you need to make a REST request after the user clicks on a button, you're forced to make it on the client side.</li>
				<li>Use an authentication method to let authenticated users only access a specific API (JWT, API key, and so on).</li>
				<li>Use a backend framework such as <strong class="bold">Ruby on Rails</strong>, <strong class="bold">Spring,</strong> <strong class="bold">Laravel</strong>, <strong class="bold">Nest.js</strong>, and <strong class="bold">Strapi</strong>: They all provide different ways of securing your API calls from the client, making it way more comfortable for us to create secure Next.js applications.</li>
			</ul>
			<p>In <a href="B16985_13_Final_SB_epub.xhtml#_idTextAnchor131"><em class="italic">Chapter 13</em></a>, <em class="italic">Building an E-commerce Website with Next.js and GraphCMS</em>, we will see how to use Next.js as a frontend for different CMSes and e-commerce platforms, and we'll also cover user authentication and secure API calls. For now, in this chapter, we will only focus on how to make HTTP requests from both the server and client.</p>
			<p>In the next section, we <a id="_idIndexMarker241"/>will see how to adopt GraphQL as a REST <a id="_idIndexMarker242"/>alternative for fetching data in <a id="_idIndexMarker243"/>Next.js.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Consuming GraphQL APIs</h2>
			<p>GraphQL has<a id="_idIndexMarker244"/> been <a id="_idIndexMarker245"/>a game-changer in the API world, and it is increasing its popularity thanks to its ease of use, modularity, and flexibility.</p>
			<p>For those who are not very familiar with GraphQL, it is basically a query language for APIs first invented by <em class="italic">Facebook</em> back in 2012. It improves many key aspects of data fetching and manipulation compared to other web service architectures such as REST or SOAP. In fact, it allows you to avoid data over-fetching (you can simply query the data fields you need), get multiple resources within a single request, obtain a strongly and statically typed interface for your data, avoid API versioning, and so on.</p>
			<p>In this section, we<a id="_idIndexMarker246"/> will be using Apollo Client <span class="hidden">(</span><a href="https://www.apollographql.com/docs/react">https://www.apollographql.com/docs/react</a>), a very popular GraphQL client with built-in support for both React and Next.js for building a very simple online signbook.</p>
			<p>Let's start by creating a new project:</p>
			<p class="source-code">npx create-next-app signbook</p>
			<p>Now, let's add a couple of dependencies:</p>
			<p class="source-code">yarn add @apollo/client graphql isomorphic-unfetch</p>
			<p>We will need now to create an Apollo client for our Next.js application. We will do that by creating a new file<a id="_idIndexMarker247"/> inside <strong class="source-inline">lib/apollo/index.js</strong> and then writing the following function:</p>
			<p class="source-code">import { useMemo } from 'react';</p>
			<p class="source-code">import {</p>
			<p class="source-code">  ApolloClient,</p>
			<p class="source-code">  HttpLink,</p>
			<p class="source-code">  InMemoryCache</p>
			<p class="source-code">} from '@apollo/client';</p>
			<p class="source-code">let uri = 'https://rwnjssignbook.herokuapp.com/v1/graphql';</p>
			<p class="source-code">let apolloClient;</p>
			<p class="source-code">function createApolloClient() {</p>
			<p class="source-code">  return new ApolloClient({</p>
			<p class="source-code">    ssrMode: typeof window === 'undefined',</p>
			<p class="source-code">    link: new HttpLink({ uri }),</p>
			<p class="source-code">    cache: new InMemoryCache(),</p>
			<p class="source-code">  });</p>
			<p class="source-code">} </p>
			<p>As you can assume, by setting <strong class="source-inline">ssrMode: typeof window === "undefined"</strong>, we will use the same Apollo instance for both client and server. Also, <strong class="source-inline">ApolloClient</strong> uses the browser <strong class="source-inline">fetch</strong> API to make HTTP requests, so we'll need to import a polyfill to make it work on<a id="_idIndexMarker248"/> the server side; in that case, we'll be using <strong class="source-inline">isomorphic-unfetch</strong>.</p>
			<p>If you try to run <a href="https://api.realworldnextjs.com/04/signbook/graphql">https://api.realworldnextjs.com/04/signbook/graphql</a> on a browser, it will redirect you to a public <em class="italic">GraphCMS</em> GraphQL editor. In fact, we will be using that headless CMS as the data source for the application we're currently writing.</p>
			<p>Inside the <a id="_idIndexMarker249"/>same <strong class="source-inline">lib/apollo/index.js</strong> file, let's add a new function to initialize the Apollo client:</p>
			<p class="source-code">export function initApollo(initialState = null) {</p>
			<p class="source-code">  const client = apolloClient || createApolloClient();</p>
			<p class="source-code">  if (initialState) {</p>
			<p class="source-code">    client.cache.restore({</p>
			<p class="source-code">      ...client.extract(),</p>
			<p class="source-code">      ...initialState</p>
			<p class="source-code">    });</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if (typeof window === "undefined") {</p>
			<p class="source-code">    return client;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if (!apolloClient) {</p>
			<p class="source-code">    apolloClient = client;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return client;</p>
			<p class="source-code">}</p>
			<p>This function will<a id="_idIndexMarker250"/> allow us to avoid recreating a new Apollo client for <a id="_idIndexMarker251"/>each page. In fact, we will store a client instance on the server (inside the previously written <strong class="source-inline">apolloClient</strong> variable), where we can pass an initial state as an argument. If we pass that parameter to the <strong class="source-inline">initApollo</strong> function, it will be merged with the local cache to restore a full representation of the state once we move to another page.</p>
			<p>To achieve that, we will first need to add another <strong class="source-inline">import</strong> statement to the <strong class="source-inline">lib/apollo/index.js</strong> file. Given that re-initializing the Apollo client with a complex initial state can be an expensive task in terms of performance, we will use the React <strong class="source-inline">useMemo</strong> hook to speed up the process:</p>
			<p class="source-code">import { useMemo } from "react";</p>
			<p>And then, we will <strong class="source-inline">export</strong> one last function:</p>
			<p class="source-code">export function useApollo(initialState) {</p>
			<p class="source-code">  return useMemo(</p>
			<p class="source-code">    () =&gt; initApollo(initialState),</p>
			<p class="source-code">    [initialState]</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>Moving to our <strong class="source-inline">pages/</strong> directory, we can now create a new <strong class="source-inline">_app.js</strong> file, as seen in <em class="italic">Chapter 3</em>, <em class="italic">Next.js Basics and Built-In Components</em>. Here, we will wrap the whole app using the official <a id="_idIndexMarker252"/>Apollo context provider:</p>
			<p class="source-code">import { ApolloProvider } from "@apollo/client";</p>
			<p class="source-code">import { useApollo } from "../lib/apollo";</p>
			<p class="source-code">export default function App({ Component, pageProps }) {</p>
			<p class="source-code">  const apolloClient =</p>
			<p class="source-code">    useApollo(pageProps.initialApolloState);</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ApolloProvider client={apolloClient}&gt;</p>
			<p class="source-code">      &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">    &lt;/ApolloProvider&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>We can finally start to write our queries!</p>
			<p>We will organize our<a id="_idIndexMarker253"/> queries inside a new folder called <strong class="source-inline">lib/apollo/queries/</strong>.</p>
			<p>Let's start by creating a new file, <strong class="source-inline">lib/apollo/queries/getLatestSigns.js</strong>, exposing the following GraphQL query:</p>
			<p class="source-code">import { gql } from "@apollo/client";</p>
			<p class="source-code">const GET_LATEST_SIGNS = gql`</p>
			<p class="source-code">  query GetLatestSigns($limit: Int! = 10, $skip: Int! = 0){</p>
			<p class="source-code">    sign(</p>
			<p class="source-code">      offset: $skip,</p>
			<p class="source-code">      limit: $limit,</p>
			<p class="source-code">      order_by: { created_at: desc }</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">      uuid</p>
			<p class="source-code">      created_at</p>
			<p class="source-code">      content</p>
			<p class="source-code">      nickname</p>
			<p class="source-code">      country</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">`;</p>
			<p class="source-code">export default GET_LATEST_SIGNS;</p>
			<p>We can now <strong class="source-inline">import</strong> this <a id="_idIndexMarker254"/>query inside our <strong class="source-inline">pages/index.js</strong> file and <a id="_idIndexMarker255"/>try to make our first GraphQL request using Apollo and Next.js:</p>
			<p class="source-code">import { useQuery } from "@apollo/client";</p>
			<p class="source-code">import GET_LATEST_SIGNS from</p>
			<p class="source-code">  '../lib/apollo/queries/getLatestSigns'</p>
			<p class="source-code">function HomePage() {</p>
			<p class="source-code">  const { loading, data } = useQuery(GET_LATEST_SIGNS, {</p>
			<p class="source-code">    fetchPolicy: 'no-cache',</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return &lt;div&gt;&lt;/div&gt;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default HomePage</p>
			<p>As you can see, the Apollo client is incredibly easy to use. Thanks to the <strong class="source-inline">useQuery</strong> hook, we will have access to three different states:</p>
			<ul>
				<li><strong class="source-inline">loading</strong>: As the name suggests, it only returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> when a request is fulfilled or is still pending.</li>
				<li><strong class="source-inline">error</strong>: If the request fails for any reason, we will be able to catch the error and send a nice message to the user.</li>
				<li><strong class="source-inline">data</strong>: Contains the data we asked for with our query.</li>
			</ul>
			<p>Now, let's move back<a id="_idIndexMarker256"/> to our home page page for a moment. For simplicity, we <a id="_idIndexMarker257"/>will just add a remote <em class="italic">TailwindCSS</em> dependency for styling our demo app. In <a href="B16985_06_Final_SB_epub.xhtml#_idTextAnchor075"><em class="italic">Chapter 6</em></a>, <em class="italic">CSS and Built-In Styling Methods</em>, and <a href="B16985_07_Final_SB_epub.xhtml#_idTextAnchor081"><em class="italic">Chapter 7</em></a>, <em class="italic">Using UI Frameworks</em>, we will see how to optimize and integrate UI frameworks, but for now, we will keep things simple as we want to focus just on the data-fetching part of our application.</p>
			<p>Open the <strong class="source-inline">pages/index.js</strong> file and edit it as follows:</p>
			<p class="source-code"><strong class="bold">import Head from "next/head";</strong></p>
			<p class="source-code">import { ApolloProvider } from "@apollo/client";</p>
			<p class="source-code">import { useApollo } from "../lib/apollo";</p>
			<p class="source-code">export default function App({ Component, pageProps }) {</p>
			<p class="source-code">  const apolloClient =</p>
			<p class="source-code">    useApollo(pageProps.initialApolloState || {});</p>
			<p class="source-code">return (</p>
			<p class="source-code">  &lt;ApolloProvider client={apolloClient}&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;Head&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;link href="https://unpkg.com/tailwindcss@^2/dist/        tailwind.min.css"</strong></p>
			<p class="source-code"><strong class="bold">       rel="stylesheet"</strong></p>
			<p class="source-code"><strong class="bold">      /&gt;</strong></p>
			<p class="source-code"><strong class="bold">    &lt;/Head&gt;</strong></p>
			<p class="source-code">    &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">  &lt;/ApolloProvider&gt;</p>
			<p class="source-code"> );</p>
			<p class="source-code">}</p>
			<p>Now, we can <a id="_idIndexMarker258"/>create a new file, <strong class="source-inline">components/Loading.js</strong>. We will <a id="_idIndexMarker259"/>render it while we're fetching the signs from <strong class="source-inline">GraphCMS</strong>:</p>
			<p class="source-code">function Loading() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div</p>
			<p class="source-code">      className="min-h-screen w-screen flex justify-center</p>
			<p class="source-code">        items-center"&gt;</p>
			<p class="source-code">      Loading signs from Hasura...</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Loading;</p>
			<p>Once we have successfully fetched the desired data, we need to display it on the home page. To do that, we will create a new component inside the <strong class="source-inline">components/Sign.js</strong> file with the <a id="_idIndexMarker260"/>following content:</p>
			<p class="source-code">function Sign({ content, nickname, country }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div className="max-w-7xl rounded-md border-2 border-</p>
			<p class="source-code">      purple-800 shadow-xl bg-purple-50 p-7 mb-10"&gt;</p>
			<p class="source-code">      &lt;p className="text-gray-700"&gt; {content} &lt;/p&gt;</p>
			<p class="source-code">      &lt;hr className="mt-3 mb-3 border-t-0 border-b-2 </p>
			<p class="source-code">        border-purple-800" /&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;div className="text-purple-900"&gt;</p>
			<p class="source-code">          Written by &lt;b&gt;{nickname}&lt;/b&gt;</p>
			<p class="source-code">          {country &amp;&amp; &lt;span&gt; from {country}&lt;/span&gt;}</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Sign;</p>
			<p>Now, let's integrate <a id="_idIndexMarker261"/>those two new components inside our home page:</p>
			<p class="source-code">import { useQuery } from "@apollo/client";</p>
			<p class="source-code">import GET_LATEST_SIGNS from</p>
			<p class="source-code">  '../lib/apollo/queries/getLatestSigns'</p>
			<p class="source-code"><strong class="bold">import Sign from '../components/Sign'</strong></p>
			<p class="source-code"><strong class="bold">import Loading from '../components/Loading'</strong></p>
			<p class="source-code">function HomePage() {</p>
			<p class="source-code">  const { loading, error, data } =</p>
			<p class="source-code">    useQuery(GET_LATEST_SIGNS, {</p>
			<p class="source-code">      fetchPolicy: 'no-cache',</p>
			<p class="source-code">    });</p>
			<p class="source-code"><strong class="bold">  if (loading) {</strong></p>
			<p class="source-code"><strong class="bold">    return &lt;Loading /&gt;;</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code"><strong class="bold">  return (</strong></p>
			<p class="source-code"><strong class="bold">    &lt;div className="flex justify-center items-center flex-</strong></p>
			<p class="source-code"><strong class="bold">      col mt-20"&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;h1 className="text-3xl mb-5"&gt;Real-World Next.js </strong></p>
			<p class="source-code"><strong class="bold">        signbook&lt;/h1&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;Link href="/new-sign"&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;button className="mb-8 border-2 border-purple-800 </strong></p>
			<p class="source-code"><strong class="bold">          text-purple-900 p-2 rounded-lg text-gray-50</strong></p>
			<p class="source-code"><strong class="bold">            m-auto  mt-4"&gt;</strong></p>
			<p class="source-code"><strong class="bold">          Add new sign</strong></p>
			<p class="source-code"><strong class="bold">        &lt;/button&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/Link&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;div&gt;</strong></p>
			<p class="source-code"><strong class="bold">        {data.sign.map((sign) =&gt; (</strong></p>
			<p class="source-code"><strong class="bold">          &lt;Sign key={sign.uuid} {...sign} /&gt;</strong></p>
			<p class="source-code"><strong class="bold">        ))}</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/div&gt;</strong></p>
			<p class="source-code"><strong class="bold">    &lt;/div&gt;</strong></p>
			<p class="source-code"><strong class="bold">  );</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">export default HomePage</p>
			<p>If we now try to<a id="_idIndexMarker262"/> browse the home page, we will see a list of <a id="_idIndexMarker263"/>signs!</p>
			<p>We could also create a simple route for adding a new sign by creating a new page under <strong class="source-inline">pages/new-sign.js</strong>. Let's start by adding the required <strong class="source-inline">imports</strong> for that page:</p>
			<p class="source-code">import { useState } from "react";</p>
			<p class="source-code">import Link from "next/link";</p>
			<p class="source-code">import { useRouter } from "next/router";</p>
			<p class="source-code">import { useMutation } from "@apollo/client";</p>
			<p class="source-code">import ADD_SIGN from "../lib/apollo/queries/addSign";</p>
			<p>As you can see, we're importing a bunch of functions from different libraries. We will use the <strong class="source-inline">useState</strong> React hook to keep track of the changes in our form for submitting the sign, Next.js' <strong class="source-inline">useRouter</strong> hook for redirecting the user to the home page once they have created a new sign, and Apollo's <strong class="source-inline">useMutation</strong> hook for creating a new sign on GraphCMS. We also <strong class="source-inline">import</strong> a new GraphQL mutation called <strong class="source-inline">ADD_SIGN</strong>, and we will see this in detail after we have created this page.</p>
			<p>Moving on, we<a id="_idIndexMarker264"/> create the page structure:</p>
			<p class="source-code">function NewSign() {</p>
			<p class="source-code">  const router = useRouter();</p>
			<p class="source-code">  const [formState, setFormState] = useState({});</p>
			<p class="source-code">  const [addSign] = useMutation(ADD_SIGN, {</p>
			<p class="source-code">    onCompleted() {</p>
			<p class="source-code">      router.push("/");</p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p class="source-code">  const handleInput = ({ e, name }) =&gt; {</p>
			<p class="source-code">    setFormState({</p>
			<p class="source-code">      ...formState,</p>
			<p class="source-code">      [name]: e.target.value</p>
			<p class="source-code">    });</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p class="source-code">export default NewSign;</p>
			<p>Reading from top to bottom, we can see that we're using Apollo's <strong class="source-inline">useMutation</strong> hook to create a new sign. Once the sign has been created correctly, it will run the <strong class="source-inline">onCompleted</strong> callback, where we will redirect the user to the home page.</p>
			<p>Moving to the next function declared inside the component body, we can clearly see that we'll use the <strong class="source-inline">handleInput</strong> function to dynamically set the form state using the React <strong class="source-inline">useState</strong> hook as soon as the user types something in any form input.</p>
			<p>We now need to render the actual HTML containing a form with just three inputs: the user's <strong class="source-inline">nickname</strong>, a message<a id="_idIndexMarker265"/> to be written in the <strong class="source-inline">signbook</strong>, and (optionally) the <strong class="source-inline">country</strong> where the <a id="_idIndexMarker266"/>user is writing from:</p>
			<p class="source-code">return (</p>
			<p class="source-code">    &lt;div className="flex justify-center items-center flex-</p>
			<p class="source-code">      col mt-20"&gt;</p>
			<p class="source-code">      &lt;h1 className="text-3xl mb-10"&gt;Sign the Real-World </p>
			<p class="source-code">        Next.js signbook!&lt;/h1&gt;</p>
			<p class="source-code">      &lt;div className="max-w-7xl shadow-xl bg-purple-50 p-7 </p>
			<p class="source-code">        mb-10 grid grid-rows-1 gap-4 rounded-md border-2 </p>
			<p class="source-code">          border- purple-800"&gt;</p>
			<p class="source-code">     &lt;div&gt;</p>
			<p class="source-code">          &lt;label htmlFor="nickname" className="text-purple-</p>
			<p class="source-code">            900 mb-2"&gt;</p>
			<p class="source-code">            Nickname</p>
			<p class="source-code">          &lt;/label&gt;</p>
			<p class="source-code">          &lt;input</p>
			<p class="source-code">            id="nickname"</p>
			<p class="source-code">            type="text"</p>
			<p class="source-code">            onChange={(e) =&gt; handleInput({ e, name: </p>
			<p class="source-code">              'nickname' })}</p>
			<p class="source-code">            placeholder="Your name"</p>
			<p class="source-code">            className="p-2 rounded-lg w-full"</p>
			<p class="source-code">          /&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">          &lt;label htmlFor="content" className="text-purple-</p>
			<p class="source-code">            900 mb-2"&gt;</p>
			<p class="source-code">            Leave a message!</p>
			<p class="source-code">          &lt;/label&gt;</p>
			<p class="source-code">          &lt;textarea</p>
			<p class="source-code">            id="content"</p>
			<p class="source-code">            placeholder="Leave a message here!"</p>
			<p class="source-code">            onChange={(e) =&gt; handleInput({ e, name: </p>
			<p class="source-code">              'content' })}</p>
			<p class="source-code">            className="p-2 rounded-lg w-full"</p>
			<p class="source-code">          /&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">          &lt;label htmlFor="country" className="text-purple-</p>
			<p class="source-code">            900 mb-2"&gt;</p>
			<p class="source-code">            If you want, write your country name and its </p>
			<p class="source-code">              emoji flag</p>
			<p class="source-code">          &lt;/label&gt;</p>
			<p class="source-code">          &lt;input</p>
			<p class="source-code">            id="country"</p>
			<p class="source-code">            type="text"</p>
			<p class="source-code">            onChange={(e) =&gt; handleInput({ e, name: </p>
			<p class="source-code">              'country' })}</p>
			<p class="source-code">            placeholder="Country"</p>
			<p class="source-code">            className="p-2 rounded-lg w-full"</p>
			<p class="source-code">          /&gt;</p>
			<p class="source-code">          &lt;button</p>
			<p class="source-code">            className="bg-purple-600 p-4 rounded-lg text-</p>
			<p class="source-code">              gray-50 m-auto mt-4"</p>
			<p class="source-code">            onClick={() =&gt; addSign({ variables: formState })}&gt;</p>
			<p class="source-code">            Submit</p>
			<p class="source-code">          &lt;/button&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">      &lt;Link href="/" passHref&gt;</p>
			<p class="source-code">        &lt;a className="mt-5 underline"&gt; Back to the</p>
			<p class="source-code">          homepage&lt;/a&gt;</p>
			<p class="source-code">      &lt;/Link&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">)</p>
			<p>Let's take a closer <a id="_idIndexMarker267"/>look <a id="_idIndexMarker268"/>at how we create a mutation by clicking the submit button:</p>
			<p class="source-code">onClick={() =&gt; addSign({ variables: formState})}</p>
			<p>As you can see, we're taking the entire state stored inside the <strong class="source-inline">formState</strong> variable coming from the <strong class="source-inline">useState</strong> hook and passing it as a value for the <strong class="source-inline">variables</strong> property used by the <strong class="source-inline">addSign</strong> function:</p>
			<p class="source-code">  const [addSign] = useMutation(ADD_SIGN, {</p>
			<p class="source-code">    onCompleted() {</p>
			<p class="source-code">      router.push("/");</p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p>The <strong class="source-inline">addSign</strong> function represents the mutation that will add a new sign to GraphCMS, and we can add dynamic data by passing an object matching the mutation variables written<a id="_idIndexMarker269"/> inside the <strong class="source-inline">lib/apollo/queries/addSign.js</strong> file:</p>
			<p class="source-code">import { gql } from "@apollo/client";</p>
			<p class="source-code">const ADD_SIGN = gql`</p>
			<p class="source-code">  mutation InsertNewSign(</p>
			<p class="source-code">    $nickname: String!,</p>
			<p class="source-code">    $content: String!,</p>
			<p class="source-code">    $country: String</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">    insert_sign(objects: {</p>
			<p class="source-code">        nickname: $nickname,</p>
			<p class="source-code">        country: $country,</p>
			<p class="source-code">        content: $content</p>
			<p class="source-code">    }) {</p>
			<p class="source-code">      returning {</p>
			<p class="source-code">        uuid</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">`;</p>
			<p class="source-code">export default ADD_SIGN;</p>
			<p>The <strong class="source-inline">ADD_SIGN</strong> mutation, in fact, takes three argument variables: <strong class="source-inline">$nickname</strong>, <strong class="source-inline">$content</strong>, and <strong class="source-inline">$country</strong>. Using form field names that reflect the naming of the mutation variables, we can simply pass the whole form state as a value to our mutation.</p>
			<p>You can now try to<a id="_idIndexMarker270"/> create a new sign. After submitting the form, you will be automatically <a id="_idIndexMarker271"/>redirected to the home page and you will see your sign at the top of the page.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Summary</h1>
			<p>In this chapter, we've taken a look at two crucial topics when talking about Next.js: the project structure organization and the different ways of fetching data. Even if these two topics seem unrelated, being able to logically separate components and utilities, and fetching data in different ways, are essential skills that will allow you to better understand the next chapter, <a href="B16985_05_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a><em class="italic">, </em><em class="italic">Managing Local and Global States in Next.js</em>. As we've seen in this chapter, the complexity of any application can only grow over time as we add more features, bug fixes, and suchlike. Having a well-organized folder structure and a clear data flow can help us keep track of our application's state.</p>
			<p>We've also taken a look at how to fetch data using GraphQL. This is an exciting topic as, in the next chapter, we will see how to use Apollo Client as a state manager other than a GraphQL client.</p>
		</div>
	</body></html>