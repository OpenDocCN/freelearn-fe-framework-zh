- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Unit Testing with Jest and React Testing Library
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest 和 React Testing Library 进行单元测试
- en: In this chapter, we learn how to use Jest and React Testing Library, two popular
    automated testing tools that can be used together in React applications. We will
    create tests on the checklist component we created in [*Chapter 11*](B19051_11.xhtml#_idTextAnchor273),
    *Reusable Components*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Jest 和 React Testing Library，这两个流行的自动化测试工具可以在 React 应用程序中一起使用。我们将对我们在[*第
    11 章*](B19051_11.xhtml#_idTextAnchor273)“可复用组件”中创建的清单组件创建测试。
- en: We will start by focusing on Jest and using it to test simple functions, learning
    about Jest’s common **matcher** functions for writing expectations, and how to
    execute tests to check whether they pass.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先关注 Jest，并使用它来测试简单的函数，了解 Jest 的常见 **匹配器**函数用于编写期望，以及如何执行测试以检查它们是否通过。
- en: We will then move on to learning about component testing using React Testing
    Library. We’ll understand the different query types and variants and how they
    help us create robust tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将继续学习使用 React Testing Library 进行组件测试。我们将了解不同的查询类型和变体以及它们如何帮助我们创建健壮的测试。
- en: After that, we will learn the most accurate way to simulate user interactions
    using a React Testing Library companion package. We will use this to create tests
    for items being checked in the checklist component.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将学习使用 React Testing Library 伴侣包模拟用户交互的最准确方法。我们将使用它来为清单组件中正在检查的项目创建测试。
- en: At the end of the chapter, we will learn how to determine which code is covered
    by tests and, more importantly, which code is uncovered. We use Jest’s code coverage
    tool to do this and understand all the different coverage stats it gives us.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将学习如何确定哪些代码被测试覆盖，更重要的是，哪些代码未被覆盖。我们使用 Jest 的代码覆盖率工具来完成此操作，并理解它给出的所有不同覆盖率统计信息。
- en: 'So, in this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Testing pure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: Testing components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试组件
- en: Simulating user interactions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟用户交互
- en: Getting code coverage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取代码覆盖率
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use the following technologies in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下技术：
- en: '**Node.js** and **npm**: You can install them from [https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** 和 **npm**：您可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)安装它们。'
- en: '**Visual Studio Code**: You can install it from [https://code.visualstudio.com/](https://code.visualstudio.com/)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：您可以从[https://code.visualstudio.com/](https://code.visualstudio.com/)安装它。'
- en: We will start with a modified version of the code we finished in the last chapter.
    The modified code contains logic extracted into pure functions, which will be
    ideal to use in the first tests we write. This code can be found online at [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章结束的代码的修改版本开始。修改后的代码包含提取到纯函数中的逻辑，这将非常适合用于我们编写的第一个测试。此代码可在网上找到，地址为[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start)。
- en: 'Carry out the following steps to download this to your local computer:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将此下载到您的本地计算机：
- en: Go to [https://download-directory.github.io/](https://download-directory.github.io/)
    in a browser.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问[https://download-directory.github.io/](https://download-directory.github.io/)。
- en: 'In the textbox on the web page, enter the following URL: [https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页上的文本框中，输入以下 URL：[https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start](https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter12/start)。
- en: Press the *Enter* key. A ZIP file containing the `start` folder will now be
    downloaded.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Enter* 键。现在将下载包含 `start` 文件的 ZIP 文件。
- en: Extract the ZIP file to a folder of your choice and open that folder in Visual
    Studio Code.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ZIP 文件解压到您选择的文件夹中，并在 Visual Studio Code 中打开该文件夹。
- en: 'In Visual Studio Code’s terminal, execute the following command to install
    all the dependencies:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 的终端中，执行以下命令来安装所有依赖项：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You are now ready to start writing tests for the checklist component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以开始为清单组件编写测试了。
- en: Testing pure functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试纯函数
- en: In this section, we will start by understanding the fundamental parts of a Jest
    test. Then, we will put this into practice by implementing tests on a pure function
    in the checklist component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解 Jest 测试的基本组成部分。然后，我们将通过在清单组件中的纯函数上实现测试来将理论知识付诸实践。
- en: A pure function has a consistent output value for a given set of parameter values.
    These functions depend only on the function parameters and nothing outside the
    function, and also don’t change any argument values passed into them. So, pure
    functions are nice for learning how to write tests because there are no tricky
    side effects to deal with.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数对于给定的一组参数值具有一致的输出值。这些函数只依赖于函数参数，不依赖于函数外部的内容，并且也不改变传递给它们的任何参数值。因此，纯函数非常适合学习如何编写测试，因为它们没有需要处理的复杂副作用。
- en: In this section, we will also cover how to test exceptions, which is useful
    for testing type assertion functions. Finally, at the end of this section, we
    will learn how to run the tests in a test suite.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将介绍如何测试异常，这对于测试类型断言函数很有用。最后，在本节的最后，我们将学习如何在测试套件中运行测试。
- en: Understanding a Jest test
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Jest 测试
- en: Jest is preinstalled in a Create React App project and configured to look for
    tests in files with particular extensions. These file extensions are `.test.ts`
    for tests on pure functions and `.test.tsx` for tests on components. Alternatively,
    a `.spec.*` file extension could be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 在 Create React App 项目中预先安装并配置为在具有特定扩展名的文件中查找测试。这些文件扩展名是 `.test.ts` 用于纯函数的测试和
    `.test.tsx` 用于组件的测试。或者，可以使用 `.spec.*` 文件扩展名。
- en: 'A test is defined using Jest’s `test` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是通过 Jest 的 `test` 函数定义的：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `test` function has two parameters for the test name and implementation.
    It is common practice for the test implementation to be an anonymous function.
    The test implementation can be asynchronous by placing the `async` keyword in
    front of the anonymous function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 函数有两个参数，用于测试名称和实现。通常，测试实现是一个匿名函数。测试实现可以通过在匿名函数前放置 `async` 关键字来异步执行：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The test implementation will consist of calling the function with arguments
    being tested and checking the result is as we expect:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试实现将包括调用带有待测试参数的函数并检查结果是否符合我们的期望：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Jest’s `expect` function is used to define our expectations. The result of the
    function call is passed into `expect`, and it returns an object containing methods
    we can use to define specific expectations for the result. These methods are referred
    to as **matchers**. If the expectation fails, Jest will fail the test.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的 `expect` 函数用于定义我们的期望。函数调用的结果传递给 `expect`，并返回一个包含我们可以用来定义特定期望的方法的对象。这些方法被称为
    **匹配器**。如果期望失败，Jest 将使测试失败。
- en: 'The preceding test uses the `toBe` matcher. The `toBe` matcher checks that
    primitive values are equal, and the preceding test uses it to check that the `someResults`
    variable is equal to `"something"`. Other common matchers are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试使用了 `toBe` 匹配器。`toBe` 匹配器检查原始值是否相等，前面的测试使用它来检查 `someResults` 变量是否等于 `"something"`。其他常见的匹配器如下：
- en: '`toStrictEqual` for checking the values in an object or array. This recursively
    checks every property in the object or array. Here’s an example:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toStrictEqual` 用于检查对象或数组中的值。它递归地检查对象或数组中的每个属性。以下是一个示例：'
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`not` for checking the opposite of a matcher. Here’s an example:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not` 用于检查匹配器的相反面。以下是一个示例：'
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`toMatch` for checking strings against **regular expressions** (**regexes**).
    Here’s an example:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toMatch` 用于检查字符串与 **正则表达式**（**regexes**）的匹配。以下是一个示例：'
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`toContain` for checking if an element is in an array. Here’s an example:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toContain` 用于检查元素是否在数组中。以下是一个示例：'
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A complete list of all the standard matchers can be found in the Jest documentation
    at [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准匹配器的完整列表可以在 Jest 文档的 [https://jestjs.io/docs/expect](https://jestjs.io/docs/expect)
    找到。
- en: Now that we understand the basics of a Jest test, we will create our first Jest
    test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Jest 测试的基础知识，我们将创建我们的第一个 Jest 测试。
- en: Testing isChecked
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 `isChecked`
- en: 'The first function we will test is `isChecked`. This function has two parameters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的第一个函数是 `isChecked`。这个函数有两个参数：
- en: '`checkedIds`: This is an array of IDs that are currently checked'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkedIds`：这是一个当前被选中的 ID 数组'
- en: '`idValue`: This is the ID to determine whether it is checked'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idValue`：这是用于确定是否被选中的 ID'
- en: 'We will write a test for when the list item is checked and another for when
    it isn’t checked:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为列表项被选中时编写一个测试，以及当它没有被选中时编写另一个测试：
- en: Create a file called `isChecked.test.ts` in the `src/Checklist` folder that
    will contain the tests.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Checklist`文件夹中创建一个名为`isChecked.test.ts`的文件，该文件将包含测试。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is best practice to place test files adjacent to the source file being tested.
    This allows the developers to navigate to the test for a function quickly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试文件放置在要测试的源文件旁边是最佳实践。这允许开发者快速导航到函数的测试。
- en: 'Open `isChecked.test.ts` and import the `isChecked` function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`isChecked.test.ts`并导入`isChecked`函数：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Start to create the first test as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建第一个测试如下：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Jest puts the `test` function in the global scope, so there is no need to import
    it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Jest将`test`函数放在全局作用域中，因此不需要导入它。
- en: 'Add the test name as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试名称：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Forming a naming convention for test names is good practice so that they are
    consistent and easy to understand. Here, we have used the following naming structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为测试名称制定命名约定是良好的实践，以便它们保持一致且易于理解。在这里，我们使用了以下命名结构：
- en: '**should {expected output / behaviour} when {input /** **state condition}**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**当{输入/** **状态条件}时，应该{预期的输出/行为}**'
- en: 'Now, let’s start to implement the logic inside the test. The first step in
    the test is to call the function being tested with the arguments we want to test:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现测试内部的逻辑。测试的第一步是用我们想要测试的参数调用被测试的函数：
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second (and last) step in the test is to check that the result is what
    we expect, which is `true` for this test:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的第二步（也是最后一步）是检查结果是否是我们预期的，对于这个测试来说是`true`：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the result is a primitive value (a Boolean), we use the `toBe` matcher
    to verify the result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果是原始值（一个布尔值），我们使用`toBe`匹配器来验证结果。
- en: 'Add a second test to cover the case when the ID isn’t in the checked IDs:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个测试以覆盖ID不在已检查ID中的情况：
- en: '[PRE23]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That completes the tests on the `isChecked` function. Next, we will learn how
    to test exceptions that are raised. We will check that our tests work after that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对`isChecked`函数的测试。接下来，我们将学习如何测试抛出的异常。测试之后，我们将检查我们的测试是否正常工作。
- en: Testing exceptions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异常
- en: We are going to test the `assertValueCanBeRendered` type assertion function.
    This is a little different from the last function we tested because we want to
    test whether an exception is raised rather than the returned value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的是`assertValueCanBeRendered`类型断言函数。这与我们上次测试的函数略有不同，因为我们想测试是否抛出了异常，而不是返回值。
- en: 'Jest has a `toThrow` matcher that can be used to check whether an exception
    has been raised. For this to catch exceptions, the function being tested has to
    be executed inside the expectation, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Jest有一个`toThrow`匹配器，可以用来检查是否抛出了异常。为了捕获异常，被测试的函数必须在期望内部执行，如下所示：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use this approach to add three tests on the `assertValueCanBeRendered`
    type assertion function. Carry out the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种方法为`assertValueCanBeRendered`类型断言函数添加三个测试。执行以下步骤：
- en: 'Create a file called `assertValueCanBeRendered.test.ts` in the `src/Checklist`
    folder for the tests and import the `assertValueCanBeRendered` type assertion
    function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Checklist`文件夹中创建一个名为`assertValueCanBeRendered.test.ts`的文件用于测试，并导入`assertValueCanBeRendered`类型断言函数：
- en: '[PRE28]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first test we will add is to check whether an exception is raised when
    the value isn’t a string or number:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加的第一个测试是检查当值不是字符串或数字时是否会抛出异常：
- en: '[PRE29]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We pass the `true` Boolean value, which should cause an error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个`true`布尔值，这应该会导致错误。
- en: 'Next, we will test whether an exception isn’t raised when the value is a string:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将测试当值是一个字符串时是否不会抛出异常：
- en: '[PRE38]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We use the `not` matcher with `toThrow` to check that an exception is not raised.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`not`匹配器与`toThrow`一起检查没有抛出异常。
- en: 'The last test will test an exception isn’t raised when the value is a number:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的测试将检查当值是一个数字时不会抛出异常：
- en: '[PRE45]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That completes the tests for the `assertValueCanBeRendered` type assertion function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对`assertValueCanBeRendered`类型断言函数的测试。
- en: Now that we have implemented some tests, we will learn how to run them next.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一些测试，接下来我们将学习如何运行它们。
- en: Running tests
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: Create React App has an npm script called `test` that runs the tests. After
    the tests are run, a watcher will rerun the tests when the source code or test
    code changes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App有一个名为`test`的npm脚本，用于运行测试。测试运行后，当源代码或测试代码更改时，监视器将重新运行测试。
- en: 'Carry out the following steps to run all the tests and experiment with the
    test watcher options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以运行所有测试并实验测试监视器选项：
- en: 'Open the terminal and execute the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并执行以下命令：
- en: '[PRE52]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`test` is a very common npm script, so the `run` keyword can be omitted. In
    addition, `test` can be shortened to `t`. So, a shortened version of the previous
    command is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`是一个非常常见的npm脚本，因此可以省略`run`关键字。此外，`test`可以缩短为`t`。因此，上一个命令的简短版本如下：'
- en: '[PRE53]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The tests will be run, and the following summary will appear in the terminal:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将会运行，以下摘要将在终端中显示：
- en: '![Figure 12.1 – First test run](img/B19051_12_01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 第一次测试运行](img/B19051_12_01.jpg)'
- en: Figure 12.1 – First test run
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 第一次测试运行
- en: Notice that there is no Command Prompt in the terminal like there usually is
    after a command has finished executing. This is because the command hasn’t fully
    completed as the test watcher is running—this is called **watch mode**. The command
    won’t complete until watch mode is exited using the *q* key. Leave the terminal
    in watch mode and carry on to the next step.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，终端中没有像命令执行完毕后通常出现的命令提示符。这是因为命令还没有完全完成，因为测试监视器正在运行——这被称为**监视模式**。命令将不会完成，直到使用*c*键退出监视模式。在监视模式下留下终端，继续下一步。
- en: 'All the tests pass at the moment. Now, we will deliberately make a test fail
    so that we can see the information Jest provides us. So, open `assertValueCanBeRendered.ts`
    and change the expected error message on the first test as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前所有测试都通过了。现在，我们将故意使一个测试失败，以便我们可以看到Jest提供的信息。因此，打开`assertValueCanBeRendered.ts`并按如下方式更改第一个测试的预期错误信息：
- en: '[PRE54]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As soon as the test file is saved, the tests are rerun, and a failing test
    is reported as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试文件被保存，测试将重新运行，失败的测试将如下报告：
- en: '![Figure 12.2 – Failing test](img/B19051_12_02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 失败的测试](img/B19051_12_02.jpg)'
- en: Figure 12.2 – Failing test
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 失败的测试
- en: 'Jest provides valuable information about the failure that helps us quickly
    resolve test failures. It tells us this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Jest提供了关于失败的有价值的信息，帮助我们快速解决测试失败。它告诉我们以下内容：
- en: Which test failed
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个测试失败了
- en: What the expected result was, in comparison to the actual result
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期结果与实际结果的比较
- en: The line in our code where the failure occurred
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败发生的代码行
- en: 'Resolve the test failure by reverting the test to check for the correct error
    message. The test should be as follows now:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将测试回滚以检查正确的错误信息来解决测试失败。现在测试应该如下所示：
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will now start to explore some of the options on the test watcher. Press
    the *w* key in the terminal, where the test watcher is still running. The test
    watcher options will be listed as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将开始探索测试监视器上的一些选项。在终端中按*w*键，其中测试监视器仍在运行。测试监视器选项将如下列出：
- en: '![Figure 12.3 – Test watcher options](img/B19051_12_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 测试监视器选项](img/B19051_12_03.jpg)'
- en: Figure 12.3 – Test watcher options
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 测试监视器选项
- en: 'We can filter the test files that Jest executes by using the *p* watch option.
    Press the *p* key and enter `isChecked` when prompted for the pattern. The pattern
    can be any regex. Jest will search for test files that match the regex pattern
    and execute them. So, Jest runs the tests in `isChecked.test.ts` in our test suite:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用*p*监视选项来过滤Jest执行的测试文件。按*p*键，当提示输入模式时输入`isChecked`。模式可以是任何正则表达式。Jest将搜索与正则表达式模式匹配的测试文件并执行它们。因此，Jest在我们的测试套件中运行了`isChecked.test.ts`的测试：
- en: '![Figure 12.4 – Jest running a test file checking for a matching pattern](img/B19051_12_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – Jest运行检查匹配模式的测试文件](img/B19051_12_04.jpg)'
- en: Figure 12.4 – Jest running a test file checking for a matching pattern
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – Jest运行检查匹配模式的测试文件
- en: To clear the filename filter, press the *c* key.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清除文件名过滤器，请按*c*键。
- en: 'We can also filter the tests that Jest executes by the test name using the
    *t* watch option. Press *t* and enter `should return false when not in checkedIds`
    when prompted for the test name. Jest will search for test names that match the
    regex pattern and execute them. So, Jest runs the `should return false when not
    in checkedIds` test in our test suite:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用*t*监视选项通过测试名称过滤Jest执行的测试。按*t*键，当提示输入测试名称时输入`should return false when
    not in checkedIds`。Jest将搜索与正则表达式模式匹配的测试名称并执行它们。因此，Jest在我们的测试套件中运行了`should return
    false when not in checkedIds`测试：
- en: '![Figure 12.5 – Jest running test name matching a pattern](img/B19051_12_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – Jest运行匹配模式的测试名称](img/B19051_12_05.jpg)'
- en: Figure 12.5 – Jest running test name matching a pattern
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – Jest运行匹配模式的测试名称
- en: Press the *c* key to clear the test name filter and then press the *q* key to
    exit the test watcher.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*c*键清除测试名称过滤器，然后按*q*键退出测试监视器。
- en: 'That completes our exploration of running Jest tests and this section on testing
    pure functions. Here’s a quick recap of the key points:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对运行 Jest 测试的探索，以及本节对测试纯函数的讨论。以下是对关键点的快速回顾：
- en: Tests are defined using Jest’s `test` function.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用 Jest 的 `test` 函数定义。
- en: Expectations within the test are defined using Jest’s `expect` function in combination
    with one or more matchers.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试中的期望值使用 Jest 的 `expect` 函数结合一个或多个匹配器来定义。
- en: The `expect` function argument can be a function that executes the function
    being tested. This is useful for testing exceptions with the `toThrow` matcher.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect` 函数的参数可以是一个执行被测试函数的函数。这对于使用 `toThrow` 匹配器测试异常非常有用。'
- en: Jest’s test runner has a comprehensive set of options for running tests. The
    test watcher is particularly useful on large code bases because it only runs tests
    impacted by changes by default.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 的测试运行器有一套全面的选项用于运行测试。测试监视器在大型代码库中特别有用，因为它默认只运行受更改影响的测试。
- en: Next, we will learn how to test React components.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何测试 React 组件。
- en: Testing components
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: Testing components is important because this is what the user interacts with.
    Having automated tests on components gives us confidence that the app is working
    correctly and helps prevent regressions when we change code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试组件非常重要，因为这正是用户与之交互的部分。在组件上拥有自动化测试可以让我们对应用程序的正确运行充满信心，并在我们更改代码时帮助我们防止回归。
- en: In this section, we will learn how to test components with Jest and React Testing
    Library. Then, we will create some tests on the checklist component we developed
    in the last chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Jest 和 React 测试库来测试组件。然后，我们将对上一章中开发的清单组件创建一些测试。
- en: Understanding React Testing Library
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 React 测试库
- en: React Testing Library is a popular companion library for testing React components.
    It provides functions to render components and then select internal elements.
    Those internal elements can then be checked using special matchers provided by
    another companion library called `jest-dom`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: React 测试库是测试 React 组件的流行伴侣库。它提供了渲染组件并选择内部元素的功能。然后，可以使用另一个名为 `jest-dom` 的伴侣库提供的特殊匹配器来检查这些内部元素。
- en: A basic component test
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本组件测试
- en: 'Here’s an example of a component test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个组件测试的例子：
- en: '[PRE60]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s explain the test:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个测试：
- en: React Testing Library’s `render` function renders the component we want to test.
    We pass in all the appropriate attributes and content so that the component is
    in the required state for the checks. In this test, we have specified some text
    in the content.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 测试库的 `render` 函数渲染我们想要测试的组件。我们传入所有适当的属性和内容，以便组件处于检查所需的所需状态。在这个测试中，我们在内容中指定了一些文本。
- en: The next line selects an internal element of the component. There are lots of
    methods on React Testing Library’s `screen` object that allow the selection of
    elements. These methods are referred to as `getByText` selects an element by matching
    the text content specified. In this test, an element with `Some heading` text
    content will be selected and assigned to the `heading` variable.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行选择组件的内部元素。React 测试库的 `screen` 对象上有许多方法可以用来选择元素。这些方法被称为 `getByText`，通过匹配指定的文本内容来选择元素。在这个测试中，一个具有
    `Some heading` 文本内容的元素将被选择并分配给 `heading` 变量。
- en: The last line in the test is the expectation. The `toBeInTheDocument` matcher
    is a special matcher from `jest-dom` that checks whether the element in the expectation
    is in the DOM.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试中的最后一行是期望。`toBeInTheDocument` 匹配器是来自 `jest-dom` 的一个特殊匹配器，用于检查期望中的元素是否在 DOM
    中。
- en: Understanding queries
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解查询
- en: 'A React Testing Library query is a method that selects a DOM element within
    the component being rendered. There are many different queries that find the element
    in different ways:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: React 测试库的查询是一个选择渲染组件内部 DOM 元素的方法。有许多不同的查询以不同的方式找到元素：
- en: '`ByRole`: Queries elements by their role.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByRole`: 通过元素的角色进行查询。'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: DOM elements have a `role` attribute that allows assistive technologies such
    as screen readers to understand what they are. Many DOM elements have this attribute
    preset—for example, the `button` element automatically has the role of `'button'`.
    For more information on roles, see [https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DOM元素有一个`role`属性，允许辅助技术（如屏幕阅读器）理解它们是什么。许多DOM元素都有这个属性预设——例如，`button`元素自动具有`'button'`的角色。有关角色的更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)。
- en: '`ByLabelText`: Queries elements by their associated label. See this page in
    the React Testing Library documentation for the different ways elements can be
    associated with a label: [https://testing-library.com/docs/queries/bylabeltext](https://testing-library.com/docs/queries/bylabeltext).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByLabelText`: 通过关联的标签查询元素。有关元素如何与标签关联的不同方式的更多信息，请参阅React Testing Library文档中的此页面：[https://testing-library.com/docs/queries/bylabeltext](https://testing-library.com/docs/queries/bylabeltext)。'
- en: '`ByPlaceholderText`: Queries elements by their placeholder text.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByPlaceholderText`: 通过占位符文本查询元素。'
- en: '`ByText`: Queries elements by their text content.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByText`: 通过元素的文本内容查询元素。'
- en: '`ByDisplayValue`: Queries `input`, `textarea`, and `select` elements by their
    value.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByDisplayValue`: 通过`input`、`textarea`和`select`元素的值查询元素。'
- en: '`ByAltText`: Queries `img` elements by their `alt` attribute.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByAltText`: 通过`alt`属性查询`img`元素。'
- en: '`ByTitle`: Queries elements by their `title` attribute.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByTitle`: 通过`title`属性查询元素。'
- en: '`ByTestId`: Queries elements by their test ID (the `data-testid` attribute).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByTestId`: 通过测试ID（`data-testid`属性）查询元素。'
- en: 'There are also different types of queries that behave slightly differently
    on the found element. Each query type has a particular prefix on the query method
    name:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 还有不同类型的查询，它们在找到的元素上的行为略有不同。每个查询类型在查询方法名称上都有一个特定的前缀：
- en: '`getBy`: Throws an error if a single element is not found. This is ideal for
    synchronously getting a single element.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getBy`: 如果找不到单个元素，则抛出错误。这对于同步获取单个元素是理想的。'
- en: '`getAllBy`: Throws an error if at least one element is not found. This is ideal
    for synchronously getting multiple elements.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAllBy`: 如果至少找不到一个元素，则抛出错误。这对于同步获取多个元素是理想的。'
- en: '`findBy`: Throws an error if a single element is not found. The check for an
    element is repeated for a certain amount of time (1 second by default). So, this
    is ideal for asynchronously getting a single element that might not be immediately
    in the DOM.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findBy`: 如果找不到单个元素，则抛出错误。对于元素的检查会重复一定的时间（默认为1秒）。因此，这对于异步获取可能不在DOM中立即存在的单个元素是理想的。'
- en: '`findAllBy`: Throws an error if at least one element is not found within a
    certain time (1 second by default). This is ideal for asynchronously getting multiple
    elements that might not be immediately in the DOM.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findAllBy`: 如果在指定时间内（默认为1秒）至少找不到一个元素，则抛出错误。这对于异步获取可能不在DOM中立即存在的多个元素是理想的。'
- en: '`queryBy`: This returns `null` if an element is not found. This is ideal for
    checking that an element does *not* exist.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryBy`: 如果找不到元素，则返回`null`。这对于检查元素是否存在是理想的。'
- en: '`queryAllBy`: This is the same as `queryBy`, but returns an array of elements.
    This is ideal for checking multiple elements do *not* exist.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryAllBy`: 这与`queryBy`相同，但返回一个元素数组。这对于检查多个元素是否不存在是理想的。'
- en: So, the `getByText` query we used in the preceding test finds the element by
    the text content specified and raises an error if no elements are found.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在先前的测试中使用的`getByText`查询通过指定的文本内容查找元素，如果找不到元素则引发错误。
- en: 'For more information on queries, see the following page in the React Testing
    Library documentation: [https://testing-library.com/docs/queries/about/](https://testing-library.com/docs/queries/about/).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关查询的更多信息，请参阅React Testing Library文档中的以下页面：[https://testing-library.com/docs/queries/about/](https://testing-library.com/docs/queries/about/)。
- en: Notice that none of these queries references implementation details such as
    an element name, ID, or CSS class. If those implementation details change due
    to code refactoring, the tests shouldn’t break, which is precisely what we want.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些查询中没有任何一个引用实现细节，例如元素名称、ID或CSS类。如果由于代码重构导致这些实现细节发生变化，测试不应该中断，这正是我们想要的。
- en: Now that we understand React Testing Library, we will use it to write our first
    component test.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了React Testing Library，我们将使用它来编写我们的第一个组件测试。
- en: Implementing checklist component tests
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现清单组件测试
- en: The first component test we will write is to check that list items are rendered
    correctly. The second component test will check list items are rendered correctly
    when custom rendered.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个组件测试是检查列表项是否正确渲染。第二个组件测试将检查在自定义渲染时列表项是否正确渲染。
- en: 'React Testing Library and `jest-dom` are preinstalled in a Create React App
    project, which means we can get straight to writing the test. Carry out the following
    steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Create React App项目中预安装了React Testing Library和`jest-dom`，这意味着我们可以直接编写测试。执行以下步骤：
- en: 'Create a new file in the `src/Checklist` folder called `Checklist.test.tsx`
    and add the following import statements:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/Checklist`文件夹中创建一个名为`Checklist.test.tsx`的新文件，并添加以下导入语句：
- en: '[PRE61]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Start to create the test as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤开始创建测试：
- en: '[PRE63]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the test, render `Checklist` with some data:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试中，使用一些数据渲染`Checklist`：
- en: '[PRE65]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We’ve rendered a single list item that should have primary text `Lucy` and secondary
    text `Manager`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们渲染了一个单独的列表项，它应该有主要文本`Lucy`和次要文本`Manager`。
- en: 'Let’s check `Lucy` has been rendered:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查`Lucy`是否已经渲染：
- en: '[PRE75]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We have selected the element using the `getByText` query and fed that directly
    into the expectation. We use the `toBeInTheDocument` matcher to check that the
    found element is in the DOM.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getByText`查询选择了元素，并将其直接输入到预期中。我们使用`toBeInTheDocument`匹配器来检查找到的元素是否在DOM中。
- en: 'Complete the test by adding a similar expectation for checking for `Manager`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加一个类似的预期来检查`Manager`来完成测试：
- en: '[PRE86]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: That completes our first component test.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的第一个组件测试。
- en: 'We will add the second test in one go, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将一次性添加第二个测试，如下所示：
- en: '[PRE98]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We render a single list item with the same data as the previous test. However,
    this test custom renders the list items with a hyphen between the name and role.
    We use the same `getByText` query to check that the list item with the correct
    text is found in the DOM.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与之前测试相同的数据渲染了一个单独的列表项。然而，这个测试自定义渲染了列表项，在名称和角色之间有一个连字符。我们使用相同的`getByText`查询来检查是否在DOM中找到了具有正确文本的列表项。
- en: 'If the tests aren’t automatically running, run them by running `npm test` in
    the terminal. Use the *p* option to run these two new tests—they should both pass:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试没有自动运行，请在终端中运行`npm test`来运行它们。使用*p*选项运行这两个新测试——它们都应该通过：
- en: '![Figure 12.6 – Component tests passing](img/B19051_12_06.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 组件测试通过](img/B19051_12_06.jpg)'
- en: Figure 12.6 – Component tests passing
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 组件测试通过
- en: That completes our first two component tests. See how easy React Testing Library
    makes this!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的前两个组件测试。看看React Testing Library如何使这变得如此简单！
- en: Using test IDs
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试ID
- en: 'The next test we will implement is to check that a list item is checked when
    specified. This test will be slightly trickier and requires a test ID on the checkboxes.
    Carry out the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一个测试是检查当指定时列表项是否被选中。这个测试会稍微复杂一些，需要复选框上的测试ID。执行以下步骤：
- en: 'Start by opening `Checklist.tsx` and notice the following test ID on the `input`
    element:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`Checklist.tsx`并注意`input`元素上的以下测试ID：
- en: '[PRE116]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Test IDs are added to elements using a `data-testid` attribute. We can concatenate
    the list item ID so that the test ID is unique for each list item.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`data-testid`属性将测试ID添加到元素中。我们可以连接列表项ID，以便测试ID对每个列表项都是唯一的。
- en: 'Now, return to the `Checklist.test.tsx` file and begin to write the test:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到`Checklist.test.tsx`文件并开始编写测试：
- en: '[PRE120]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We have rendered the checklist with the same data as the previous tests. However,
    we have specified that the list item is checked using the `checkedIds` prop.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用与之前测试相同的数据渲染了清单。然而，我们已指定使用`checkedIds`属性来检查列表项。
- en: 'Now, on to the expectation for the test:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看测试的预期：
- en: '[PRE131]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: We select the checkbox by its test ID using the `getByTestId` query. We then
    use the `toBeChecked` matcher to verify the checkbox is checked. `toBeChecked`
    is another special matcher from the `jest-dom` package.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getByTestId`查询通过测试ID选择复选框。然后我们使用`toBeChecked`匹配器来验证复选框是否被选中。`toBeChecked`是来自`jest-dom`包的另一个特殊匹配器。
- en: 'This new test should pass, leaving us with three passing tests on `Checklist`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的测试应该通过，这样我们在`Checklist`上就有三个通过测试：
- en: '![Figure 12.7 – All three component tests passing](img/B19051_12_07.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 所有三个组件测试通过](img/B19051_12_07.jpg)'
- en: Figure 12.7 – All three component tests passing
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 所有三个组件测试通过
- en: Stop the test runner by pressing the *q* key.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*q*键停止测试运行器。
- en: 'That completes this section on testing components. Here’s a quick recap:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了本节关于组件测试的内容。这里是一个快速回顾：
- en: React Testing Library contains lots of useful queries for selecting DOM elements.
    Different query types will find single or many elements and will or won’t error
    if an element isn’t found. There is even a query type for repeatedly searching
    for elements rendered asynchronously.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Testing Library包含许多用于选择DOM元素的有用查询。不同的查询类型会找到单个或多个元素，如果找不到元素，则不会报错。甚至还有一个用于重复搜索异步渲染的元素的查询类型。
- en: '`jest-dom` contains lots of useful matchers for checking DOM elements. A common
    matcher is `toBeInTheDocument`, which verifies an element is in the DOM. However,
    `jest-dom` contains many other useful matchers, such as `toBeChecked` for checking
    whether an element is checked or not.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest-dom`包含许多用于检查DOM元素的有用匹配器。一个常见的匹配器是`toBeInTheDocument`，它验证一个元素是否在DOM中。然而，`jest-dom`还包含许多其他有用的匹配器，例如`toBeChecked`用于检查元素是否被勾选。'
- en: Next, we will learn how to simulate user interactions in tests.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在测试中模拟用户交互。
- en: Simulating user interactions
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟用户交互
- en: So far, our tests have simply rendered the checklist component with various
    props set. Users can interact with the checklist component by checking and unchecking
    items. In this section, we will first learn how to simulate user interactions
    in tests. We will then use this knowledge to test whether list items are checked
    when clicked and that `onCheckedIdsChange` is raised.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的测试只是简单地使用各种属性设置了清单组件。用户可以通过勾选和取消勾选项目与清单组件进行交互。在本节中，我们将首先学习如何在测试中模拟用户交互。然后，我们将利用这些知识来测试点击列表项时是否勾选，以及是否触发了`onCheckedIdsChange`。
- en: Understanding fireEvent and user-event
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`fireEvent`和`user-event`
- en: 'React Testing Library has a `fireEvent` function that can raise events on DOM
    elements. The following example raises a `click` event on a **Save** button:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: React Testing Library有一个`fireEvent`函数可以在DOM元素上触发事件。以下示例在**保存**按钮上触发了一个`click`事件：
- en: '[PRE145]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This is okay, but what if logic was implemented using a `mousedown` event rather
    than `click`? The test would then need to be as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但如果逻辑是使用`mousedown`事件而不是`click`事件实现的呢？那么测试将需要如下所示：
- en: '[PRE146]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Fortunately, there is an alternative approach to performing user interactions
    in tests. The alternative approach is to use the `user-event` package, which is
    a React Testing Library companion package that simulates user interactions rather
    than specific events. The same test using `user-event` looks like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在测试中执行用户交互有一个替代方法。这个替代方法是使用`user-event`包，这是一个React Testing Library的配套包，它模拟用户交互而不是特定的事件。使用`user-event`的相同测试看起来如下：
- en: '[PRE147]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The test would cover logic implemented using a `click` event or `mousedown`
    event. So, it is less coupled to implementation details, which is good. For this
    reason, we’ll use the `user-event` package to write interactive tests on our checklist
    component.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将涵盖使用`click`事件或`mousedown`事件实现的逻辑。因此，它与实现细节的耦合度较低，这是好的。因此，我们将使用`user-event`包来编写我们清单组件的交互式测试。
- en: 'The `user-event` package can simulate interactions other than clicks. See the
    documentation at the following link for more information: [https://testing-library.com/docs/user-event/intro](https://testing-library.com/docs/user-event/intro).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`user-event`包可以模拟除了点击之外的其他交互。有关更多信息，请参阅以下链接的文档：[https://testing-library.com/docs/user-event/intro](https://testing-library.com/docs/user-event/intro)。'
- en: Implementing checklist tests for checking items
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现检查项目的清单测试
- en: 'We will now write two interactive tests on the checklist component. The first
    test will check items are checked when clicked. The second test will check `onCheckedIdsChange`
    is called when items are clicked. Carry out the following steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为清单组件编写两个交互式测试。第一个测试将检查点击时项目是否被勾选。第二个测试将检查点击项目时是否调用了`onCheckedIdsChange`。执行以下步骤：
- en: 'Create React App does preinstall the `user-event` package, but it may be a
    version before version 14, which has a different API. Open `package.json`, and
    then find the `@testing-library/user-event` dependency and check the version.
    If the version isn’t 14 or above, then run the following command in the terminal
    to update it:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Create React App预先安装了`user-event`包，但它可能是在版本14之前的版本，这有一个不同的API。打开`package.json`，然后找到`@testing-library/user-event`依赖项并检查版本。如果版本不是14或更高，那么在终端中运行以下命令来更新它：
- en: '[PRE148]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'We will add the interactive tests in the same test file as the other component
    tests. So, open `Checklist.test.tsx` and add an import statement for `user-event`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在与其它组件测试相同的测试文件中添加交互式测试。因此，打开`Checklist.test.tsx`并添加对`user-event`的导入语句：
- en: '[PRE149]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The first test will test that items are checked when clicked. Start to implement
    this as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个测试将测试点击时项是否被选中。开始实现如下：
- en: '[PRE150]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We have marked the test as asynchronous because the simulated user interactions
    in `user-event` are asynchronous.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试标记为异步，因为`user-event`中的模拟用户交互是异步的。
- en: 'Next, initialize the user simulation as follows:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，初始化用户模拟如下：
- en: '[PRE152]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'We can now render a list item as we have done in previous tests. We will also
    get a reference to the checkbox in the rendered list item and check that it isn’t
    checked:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以渲染一个列表项，就像我们在之前的测试中所做的那样。我们还将获取渲染的列表项中的复选框引用，并检查它是否未被选中：
- en: '[PRE155]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Now, on to the user interaction. Simulate the user clicking the list item by
    calling the `click` method on the `user` object; the checkbox to be clicked needs
    to be passed into the `click` argument:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转向用户交互。通过在`user`对象上调用`click`方法来模拟用户点击列表项；需要将要点击的复选框传递给`click`参数：
- en: '[PRE170]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The last step in the test is to check that the checkbox is now checked:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试的最后一步是检查复选框现在是否被选中：
- en: '[PRE186]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The next test will test that the function assigned to the `onCheckedIdsChange`
    prop is called when a list item is clicked. Here is the test:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个测试将测试当列表项被点击时，分配给`onCheckedIdsChange`属性的函数是否被调用。以下是测试：
- en: '[PRE203]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: We set a `calledWith` variable to the value of the `onCheckedIdsChange` parameter.
    After the list item is clicked, we check the value of the `calledWith` variable
    using the `toStrictEqual` matcher. The `toStrictEqual` matcher is a standard Jest
    matcher that is ideal for checking arrays and objects.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`calledWith`变量设置为`onCheckedIdsChange`参数的值。在列表项被点击后，我们使用`toStrictEqual`匹配器检查`calledWith`变量的值。`toStrictEqual`匹配器是一个标准的Jest匹配器，非常适合检查数组和对象。
- en: 'The second test references the `IdValue` type, so add an import statement for
    this:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个测试引用了`IdValue`类型，因此添加一个导入语句：
- en: '[PRE220]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Run the tests by running `npm test` in the terminal. Press the *p* key to run
    all the tests in the `Checklist.test.tsx` file. We should now have five passing
    component tests:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行`npm test`来运行测试。按*p*键以运行`Checklist.test.tsx`文件中的所有测试。我们现在应该有五个通过组件测试：
- en: '![Figure 12.8 – Five passing component tests](img/B19051_12_08.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – 五个通过组件测试](img/B19051_12_08.jpg)'
- en: Figure 12.8 – Five passing component tests
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 五个通过组件测试
- en: Stop the test runner by pressing the *q* key.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*q*键停止测试运行器。
- en: That completes the tests for clicking items and this section on simulating user
    interactions. We learned that React Testing Library’s `fireAction` function raises
    a particular event that couples tests to implementation details. A better approach
    is to use the `user-event` package to simulate user interactions, potentially
    raising several events in the process.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了点击项的测试以及模拟用户交互本节的测试。我们了解到React Testing Library的`fireAction`函数引发了一个特定的事件，将测试与实现细节耦合。更好的方法是使用`user-event`包来模拟用户交互，在这个过程中可能会引发多个事件。
- en: Next, we will learn how to quickly determine any code that isn’t covered by
    tests.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何快速确定任何未由测试覆盖的代码。
- en: Getting code coverage
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码覆盖率
- en: Code coverage is how we refer to how much of our app code is covered by unit
    tests. As we write our unit tests, we’ll have a fair idea of what code is covered
    and not covered, but as the app grows and time passes, we’ll lose track of this.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是我们用来指代我们的应用程序代码中有多少被单元测试覆盖。当我们编写单元测试时，我们将对哪些代码被覆盖以及哪些代码未被覆盖有一个相当的了解，但随着应用程序的增长和时间的推移，我们将失去这种跟踪。
- en: In this section, we’ll learn how to use Jest’s code coverage option so that
    we don’t have to keep what is covered in our heads. We will use the code coverage
    option to determine the code coverage on the checklist component and understand
    all the different statistics in the report. We will use the code coverage report
    to find some uncovered code in our checklist component. We will then extend the
    tests on the checklist component to achieve full code coverage.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Jest的代码覆盖率选项，这样我们就不必在脑海中记住哪些代码被覆盖了。我们将使用代码覆盖率选项来确定清单组件的代码覆盖率，并理解报告中的所有不同统计数据。我们将使用代码覆盖率报告来找到清单组件中的某些未覆盖代码。然后我们将扩展清单组件的测试以实现完整的代码覆盖率。
- en: Running code coverage
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码覆盖率
- en: 'To get code coverage, we run the `test` command with a `--coverage` option.
    We also include a `--watchAll=false` option that tells Jest not to run in watch
    mode. So, run the following command in a terminal to determine code coverage on
    our app:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取代码覆盖率，我们使用带有`--coverage`选项的`test`命令。我们还包含一个`--watchAll=false`选项，告诉Jest不要在监视模式下运行。因此，在终端中运行以下命令以确定我们的应用程序的代码覆盖率：
- en: '[PRE221]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The tests take a little longer to run because of the code coverage calculations.
    When the tests have finished, a code coverage report is output in the terminal
    with the test results:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码覆盖率计算，测试运行会花费更长的时间。当测试完成后，终端会输出一个包含测试结果的代码覆盖率报告：
- en: '![Figure 12.9 – Terminal code coverage report](img/B19051_12_09.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 终端代码覆盖率报告](img/B19051_12_09.jpg)'
- en: Figure 12.9 – Terminal code coverage report
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 终端代码覆盖率报告
- en: Next, we will take some time to understand this code coverage report.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将花一些时间来理解这份代码覆盖率报告。
- en: Understanding the code coverage report
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解代码覆盖率报告
- en: The coverage report lists the coverage for each file and aggregates coverage
    in a folder for all the files in the project. So, the whole app has between 57.44%
    and 62.5% code coverage, depending on which statistic we take.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告列出了每个文件的覆盖率，并汇总了项目中所有文件的覆盖率。因此，整个应用程序的代码覆盖率在57.44%到62.5%之间，具体取决于我们采用哪个统计数据。
- en: 'Here’s an explanation of all the statistic columns:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对所有统计列的解释：
- en: '**% Stmts**: This is **statement coverage**, which is how many source code
    statements have been executed during test execution'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 语句**：这是**语句覆盖率**，指的是在测试执行过程中执行了多少源代码语句'
- en: '**% Branch**: This is **branch coverage**, which is how many of the branches
    of conditional logic have been executed during test execution'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 分支**：这是**分支覆盖率**，指的是在测试执行过程中有多少条件逻辑的分支被执行'
- en: '**% Funcs**: This is **function coverage**, which is how many functions have
    been called during test execution'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 函数**：这是**函数覆盖率**，指的是在测试执行过程中调用了多少函数'
- en: '**% Lines**: This is **line coverage**, which is how many lines of source code
    have been executed during test execution'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**% 行**：这是**行覆盖率**，指的是在测试执行过程中执行了多少行源代码'
- en: The rightmost column in the report is very useful. It gives the lines of source
    code that aren’t covered by tests. For example, the `getNewCheckedIds.ts` file
    in the checklist component has lines 9 and 10, which are uncovered.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 报告最右侧的列非常有用。它给出了测试未覆盖的源代码行。例如，清单组件中的`getNewCheckedIds.ts`文件的第9行和第10行未被覆盖。
- en: 'There is another version of the report that is generated in HTML format. This
    file is automatically generated every time a test is run with the `--coverage`
    option. So, this report has already been generated because we have just run the
    tests with the `--coverage` option. Carry out the following steps to explore the
    HTML report:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种以HTML格式生成的报告版本。每次运行带有`--coverage`选项的测试时，此文件都会自动生成。因此，由于我们刚刚运行了带有`--coverage`选项的测试，此报告已经生成。执行以下步骤以探索HTML报告：
- en: 'The report can be found in an `index.html` file in the `coverage\lcov-report`
    folder. Double-click on the file so that it opens in a browser:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告位于`coverage\lcov-report`文件夹中的`index.html`文件中。双击文件，使其在浏览器中打开：
- en: '![Figure 12.10 – HTML coverage report](img/B19051_12_10.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – HTML覆盖率报告](img/B19051_12_10.jpg)'
- en: Figure 12.10 – HTML coverage report
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – HTML覆盖率报告
- en: The report contains the same data as the terminal report, but this one is interactive.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 报告包含与终端报告相同的数据，但这个报告是交互式的。
- en: 'Click on the **src/Checklist** link in the second row of the report. The page
    now shows the coverage for the files in the checklist component:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在报告的第二行点击**src/Checklist**链接。现在页面显示了清单组件中文件的覆盖率：
- en: '![Figure 12.11 – Coverage report for checklist component files](img/B19051_12_11.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 清单组件文件覆盖率报告](img/B19051_12_11.jpg)'
- en: Figure 12.11 – Coverage report for checklist component files
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 清单组件文件覆盖率报告
- en: 'Click on the `getNewCheckedIds.ts` link to drill into the coverage for that
    file:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`getNewCheckedIds.ts`链接以深入查看该文件的覆盖率：
- en: '![Figure 12.12 – Coverage report for getNewCheckedIds.ts](img/B19051_12_12.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – getNewCheckedIds.ts覆盖率报告](img/B19051_12_12.jpg)'
- en: Figure 12.12 – Coverage report for getNewCheckedIds.ts
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – getNewCheckedIds.ts覆盖率报告
- en: We can see that the uncovered lines 9 and 10 are very clearly highlighted in
    the `getNewCheckedIds.ts` file.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，未覆盖的行9和10在`getNewCheckedIds.ts`文件中非常清晰地突出显示。
- en: So, the HTML coverage report is useful in a large code base because it starts
    with high-level coverage and allows you to drill into coverage on specific folders
    and files. When viewing a file in the report, we can quickly determine where the
    uncovered code is because it is clearly highlighted.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，HTML覆盖率报告在大型代码库中非常有用，因为它从高级覆盖率开始，并允许你深入查看特定文件夹和文件的覆盖率。在报告中查看文件时，我们可以快速确定未覆盖的代码位置，因为它被清晰地突出显示。
- en: Next, we will update our tests so that lines 9 and 10 in `getNewCheckedIds.ts`
    are covered.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新我们的测试，以便`getNewCheckedIds.ts`中的第9行和第10行被覆盖。
- en: Gaining full coverage on the checklist component
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现检查清单组件的全面覆盖率
- en: 'The logic not currently being checked by tests is the logic used when a list
    item is clicked but has already been checked. We will extend the `''should check
    items when clicked''` test to cover this logic. Carry out the following steps:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 目前未被测试检查的逻辑是当列表项被点击但已检查时的逻辑。我们将扩展`'should check items when clicked'`测试以覆盖此逻辑。执行以下步骤：
- en: 'Open `Checklist.test.tsx` and rename the `''should check items when clicked''`
    test as follows:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Checklist.test.tsx`并将`'should check items when clicked'`测试重命名为以下内容：
- en: '[PRE222]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Add the following highlighted lines at the end of the test to click the checkbox
    for a second time and check it is unchecked:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试末尾添加以下突出显示的行以再次点击复选框并检查它是否未选中：
- en: '[PRE225]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'In the terminal, rerun the tests with coverage:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，使用覆盖率重新运行测试：
- en: '[PRE244]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'All the tests still pass, and the coverage on the checklist component is now
    reported as 100% on all the statistics:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试仍然通过，检查清单组件的覆盖率现在在所有统计指标上报告为100%：
- en: '![Figure 12.13 – 100% coverage on the checklist component](img/B19051_12_13.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 检查清单组件的100%覆盖率](img/B19051_12_13.jpg)'
- en: Figure 12.13 – 100% coverage on the checklist component
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 检查清单组件的100%覆盖率
- en: The checklist component is now well covered. However, it is a little annoying
    that `index.ts` and `types.ts` appear in the report with zero coverage. We’ll
    resolve this next.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 检查清单组件现在得到了很好的覆盖。然而，`index.ts`和`types.ts`出现在报告中且覆盖率为零，这有点令人烦恼。我们将在下一部分解决这个问题。
- en: Ignoring files in the coverage report
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略覆盖率报告中的文件
- en: 'We will remove `index.ts` and `types.ts` from the coverage report because they
    don’t contain any logic and create unnecessary noise. Carry out the following
    steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从覆盖率报告中移除`index.ts`和`types.ts`，因为它们不包含任何逻辑，并产生不必要的噪音。执行以下步骤：
- en: 'Open the `package.json` file. We can configure Jest in the `package.json` file
    in a `jest` field, and there is a `coveragePathIgnorePatterns` configuration option
    for removing files from the coverage report. Add the following Jest configuration
    to `package.json` to ignore the `types.ts` and `index.ts` files:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`package.json`文件。我们可以在`package.json`文件中的`jest`字段中配置Jest，并且有一个`coveragePathIgnorePatterns`配置选项用于从覆盖率报告中移除文件。将以下Jest配置添加到`package.json`以忽略`types.ts`和`index.ts`文件：
- en: '[PRE245]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'In the terminal, rerun the tests with coverage:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，使用覆盖率重新运行测试：
- en: '[PRE254]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'The `types.ts` and `index.ts` files are removed from the coverage report:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`types.ts`和`index.ts`文件已从覆盖率报告中移除：'
- en: '![Figure 12.14 – types.ts and index.ts files removed from the coverage report](img/B19051_12_14.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 从覆盖率报告中移除了types.ts和index.ts文件](img/B19051_12_14.jpg)'
- en: Figure 12.14 – types.ts and index.ts files removed from the coverage report
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 从覆盖率报告中移除了types.ts和index.ts文件
- en: 'That completes this section on code coverage. Here’s a quick recap:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于代码覆盖率的讨论到此结束。以下是一个简要的回顾：
- en: The `--coverage` option outputs a code coverage report after the tests have
    run.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--coverage`选项在测试运行后输出代码覆盖率报告。'
- en: An interactive HTML code coverage report is generated in addition to the one
    in the terminal. This is useful on a large test suite to drill into uncovered
    code.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了终端中的覆盖率报告外，还生成一个交互式的HTML代码覆盖率报告。在大型测试套件中，这有助于深入分析未覆盖的代码。
- en: Both report formats highlight uncovered code, giving us valuable information
    to improve our test suite.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种报告格式都突出了未覆盖的代码，为我们提供了改进测试套件的有价值信息。
- en: Summary
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created tests on a checklist component using Jest and React
    Testing Library. In addition, we learned about common Jest matchers in Jest’s
    core package and useful matchers for component testing in a companion package
    called `jest-dom`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Jest和React Testing Library在检查清单组件上创建了测试。此外，我们还学习了Jest核心包中的常见匹配器和在名为`jest-dom`的配套包中用于组件测试的有用匹配器。
- en: We used Jest’s test runner and used options to run certain tests. This is particularly
    useful on large code bases.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Jest的测试运行器，并使用选项来运行某些测试。这对于大型代码库来说特别有用。
- en: We learned about the wide variety of queries available in React Testing Library
    to select elements in different ways. We used the `getByText` query extensively
    in the checklist tests. We also created a test ID on list item checkboxes so that
    the `getByTestId` query could be used to select them uniquely.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了React Testing Library中可用的广泛查询，用于以不同方式选择元素。我们在检查清单测试中广泛使用了`getByText`查询。我们还为列表项复选框创建了一个测试ID，以便可以使用`getByTestId`查询来唯一选择它们。
- en: We learned that the `user-event` package is an excellent way of simulating user
    interactions that are decoupled from the implementation. We used this to simulate
    a user clicking a list item checkbox.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到 `user-event` 包是模拟与实现解耦的用户交互的绝佳方式。我们使用它来模拟用户点击列表项复选框。
- en: We learned how to produce code coverage reports and understood all the statistics
    in the report. The report included information about uncovered code, which we
    used to gain 100% coverage on the checklist component.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何生成代码覆盖率报告，并理解了报告中的所有统计数据。报告包括了关于未覆盖代码的信息，我们使用这些信息在清单组件上实现了 100% 的覆盖率。
- en: So, we have reached the end of this book. You are now comfortable with both
    React and TypeScript and have excellent knowledge in areas outside React core,
    such as styling, client-side routing, forms, and web APIs. You will be able to
    develop components that are reusable across different pages and even different
    apps. On top of that, you will now be able to write a robust test suite so that
    you can ship new features with confidence.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经到达了这本书的结尾。你现在对 React 和 TypeScript 都很熟悉，并在 React 核心之外的区域，如样式、客户端路由、表单和
    Web API，拥有丰富的知识。你将能够开发跨不同页面甚至不同应用程序的可重用组件。除此之外，你现在将能够编写一个健壮的测试套件，这样你就可以自信地发布新功能。
- en: In summary, the knowledge from this book will allow you to efficiently build
    the frontend of large and complex apps with React and TypeScript. I hope you have
    enjoyed reading this book as much as I did writing it!
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这本书的知识将使你能够高效地使用 React 和 TypeScript 构建大型和复杂的应用程序的前端。我希望你阅读这本书的乐趣和我写作这本书的乐趣一样多！
- en: Questions
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to check what you have learned in this chapter:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以检查你在本章中学到的内容：
- en: We have written some tests for a `HomePage` component and placed them in a file
    called `HomePage.tests.tsx`. However, the tests aren’t run when the `npm test`
    command is executed—not even when the *a* key is pressed to run all the tests.
    What do you think the problem might be?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为 `HomePage` 组件编写了一些测试，并将它们放在名为 `HomePage.tests.tsx` 的文件中。然而，当执行 `npm test`
    命令时，测试并没有运行——甚至当按下 *a* 键来运行所有测试时也是如此。你认为可能的问题是什么？
- en: Why doesn’t the following expectation pass? How could this be resolved?
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下预期没有通过？如何解决这个问题？
- en: '[PRE255]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Which matcher can be used to check that a variable isn’t `null`?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个匹配器可以用来检查一个变量不是 `null`？
- en: 'Here’s an expectation that checks whether a **Save** button is disabled:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个检查**保存**按钮是否被禁用的预期：
- en: '[PRE256]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: The expectation passes as expected, but is there a different matcher that can
    be used to simplify this?
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果如预期通过，但是否有不同的匹配器可以用来简化这个操作？
- en: Write a test for the `getNewCheckedIds` function we used in this chapter. The
    test should check if an ID is removed from the array of checked IDs if it is already
    in the array.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们在这章中使用的 `getNewCheckedIds` 函数编写一个测试。测试应该检查如果 ID 已经在已检查的 ID 数组中，则从数组中移除该 ID。
- en: 'We have a `form` element containing a `findBy` query type so that the query
    retries until the data has been fetched:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个包含 `findBy` 查询类型的 `form` 元素，以便查询在数据被获取之前重试：
- en: '[PRE259]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: However, the expectation doesn’t work—can you spot the problem?
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，预期并没有工作——你能找到问题所在吗？
- en: 'The following expectation attempts to check that a **Save** button isn’t in
    the DOM:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下预期尝试检查一个**保存**按钮不在 DOM 中：
- en: '[PRE260]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: This doesn’t work as expected, though. Instead, an error is raised because the
    **Save** button can’t be found. How can this be resolved?
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并没有按预期工作。相反，由于找不到**保存**按钮，引发了一个错误。如何解决这个问题？
- en: Answers
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The problem is that the file extension is `tests.tsx` rather than `test.tsx`.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题在于文件扩展名是 `tests.tsx` 而不是 `test.tsx`。
- en: 'The `toBe` matcher should only be used for checking primitive values such as
    numbers and strings—this is an object. The `toStrictEqual` matcher should be used
    to check objects because it checks the values of all its properties instead of
    the object reference:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toBe` 匹配器应该仅用于检查原始值，如数字和字符串——这是一个对象。应该使用 `toStrictEqual` 匹配器来检查对象，因为它检查所有属性的值而不是对象引用：'
- en: '[PRE261]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'The `not` and `toBeNull` matchers can be combined to check a variable isn’t
    `null`:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`not` 和 `toBeNull` 匹配器可以组合起来检查一个变量不是 `null`：'
- en: '[PRE262]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'The `toBeDisabled` matcher can be used from `jest-dom`:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toBeDisabled` 匹配器可以从 `jest-dom` 中使用：'
- en: '[PRE263]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Here’s a test:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个测试示例：
- en: '[PRE264]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'The `findBy` query type requires awaiting because it is asynchronous:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`findBy` 查询类型需要等待，因为它异步执行：'
- en: '[PRE268]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'The `queryBy` query type can be used because it doesn’t throw an exception
    when an element isn’t found. In addition, the `not` and `toBeInTheDocument` matchers
    can be used to check that the element isn’t in the DOM:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`queryBy` 查询类型可以被使用，因为它在找不到元素时不会抛出异常。此外，可以使用 `not` 和 `toBeInTheDocument` 匹配器来检查元素不在
    DOM 中：'
- en: '[PRE269]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
