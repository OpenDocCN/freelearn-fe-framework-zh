<html><head></head><body>
<section class="section" epub:type="frontmatter chapter" id="_idContainer014" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">Introducing React Anti-Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This book dives deep into the realm of React anti-patterns. </span><span class="koboSpan" id="kobo.3.2">An anti-pattern is not necessarily a technical error – the code often functions properly at first – but although it may initially seem correct, as the code base expands, these anti-patterns can become problematic.</span></p>
<p><span class="koboSpan" id="kobo.4.1">As we navigate through the book, we’ll scrutinize code samples that might not embody best practices; some could be intricate to decipher, and others, tough to modify or extend. </span><span class="koboSpan" id="kobo.4.2">While certain pieces of code may suffice for smaller tasks, they falter when scaled up. </span><span class="koboSpan" id="kobo.4.3">Moreover, we’ll venture into time-tested patterns and principles from the expansive software world, seamlessly weaving them into our frontend discourse.</span></p>
<p><span class="koboSpan" id="kobo.5.1">I aim for practicality. </span><span class="koboSpan" id="kobo.5.2">The code illustrations originate either from past projects or commonplace domains such as a shopping cart and a user profile component, minimizing your need to decipher domain jargon. </span><span class="koboSpan" id="kobo.5.3">For a holistic view, the concluding chapters showcase detailed, end-to-end examples, furnishing a more organized and immersive experience.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Specifically, in this introductory chapter, we’ll address the intricacies of constructing advanced React applications, highlighting how state management and asynchronous operations can obfuscate code clarity. </span><span class="koboSpan" id="kobo.6.2">We’ll enumerate prevalent anti-patterns and offer a glimpse into the remedial strategies detailed later in the book.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.8.1">Understanding the difficulty of building UIs</span></li>
<li><span class="koboSpan" id="kobo.9.1">Understanding the state management</span></li>
<li><span class="koboSpan" id="kobo.10.1">Exploring “unhappy paths”</span></li>
<li><span class="koboSpan" id="kobo.11.1">Exploring common anti-patterns in React</span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">A GitHub repository has been created to host all the code we discuss in the book. </span><span class="koboSpan" id="kobo.13.2">For this chapter, you can find the code at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1"><span class="koboSpan" id="kobo.14.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1</span></a><span class="koboSpan" id="kobo.15.1">.</span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.16.1">Understanding the difficulty of building UIs</span></h1>
<p><span class="koboSpan" id="kobo.17.1">Unless you’re building a </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.18.1">straightforward, document-like web page — for example, a basic article without advanced UI elements such as search boxes or modals — the built-in languages offered by web browsers are generally insufficient. </span><em class="italic"><span class="koboSpan" id="kobo.19.1">Figure 1</span></em><em class="italic"><span class="koboSpan" id="kobo.20.1">.1</span></em><span class="koboSpan" id="kobo.21.1"> shows an example of a website</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.22.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">HTML</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.25.1">HyperText </span></strong><strong class="bold"><span class="koboSpan" id="kobo.26.1">Markup Language</span></strong><span class="koboSpan" id="kobo.27.1">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.28.1"><img alt="Figure 1.1: A simple HTML document website" src="image/B21103_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.29.1">Figure 1.1: A simple HTML document website</span></p>
<p><span class="koboSpan" id="kobo.30.1">However nowadays, most</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.31.1"> applications are more complicated and contain more elements than what this language was originally designed for.</span></p>
<p><span class="koboSpan" id="kobo.32.1">The disparity between the language of the web and the UI experiences that people encounter daily is substantial. </span><span class="koboSpan" id="kobo.32.2">Whether it’s a ticket booking platform, a project management tool, or an image gallery, modern web UIs are intricate and native web languages don’t readily support them. </span><span class="koboSpan" id="kobo.32.3">You can go the extra mile to “simulate” UI components such as accordions, toggle switches, or interactive cards, but fundamentally, you’re still working with what amounts to a document, not a genuine UI component.</span></p>
<p><span class="koboSpan" id="kobo.33.1">In an ideal world, building a UI would resemble working with a visual UI designer. </span><span class="koboSpan" id="kobo.33.2">Tools such as C++ Builder or Delphi, or more modern alternatives such as Figma, let you drag and drop components onto a canvas that then renders seamlessly on any screen. </span><span class="koboSpan" id="kobo.33.3">This isn’t the case with web development. </span><span class="koboSpan" id="kobo.33.4">For instance, to create a custom search input, you’ll need to wrap it in additional elements, fine-tune colors, adjust padding and fonts, and perhaps add an icon for user guidance. </span><span class="koboSpan" id="kobo.33.5">Creating an auto-suggestion list that appears right under the search box, matching its width exactly, is often far more labor-intensive than one might initially think.</span></p>
<p><span class="koboSpan" id="kobo.34.1">As shown in </span><em class="italic"><span class="koboSpan" id="kobo.35.1">Figure 1</span></em><em class="italic"><span class="koboSpan" id="kobo.36.1">.2</span></em><span class="koboSpan" id="kobo.37.1">, a web page can be super complicated and look nothing like a document on the surface, although the building blocks of the page are still pure HTML:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.38.1"><img alt="Figure 1.2: Jira issue view" src="image/B21103_01_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.39.1">Figure 1.2: Jira issue view</span></p>
<p><span class="koboSpan" id="kobo.40.1">This screenshot shows the </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.41.1">issue view of Jira, a popular web-based project management tool used to track, prioritize, and</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.42.1"> coordinate tasks and projects. </span><span class="koboSpan" id="kobo.42.2">An issue view contains many details such as the issue’s title, description, attachments, comments, and linked issues. </span><span class="koboSpan" id="kobo.42.3">It also contains many elements a user can interact with, such as an </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Assign to me</span></strong><span class="koboSpan" id="kobo.44.1"> button, the ability to change the priority of the issue, add a comment, and so on.</span></p>
<p><span class="koboSpan" id="kobo.45.1">For such a UI, you might expect there to be a navigator component, a drop-down list, an accordion, and so on. </span><span class="koboSpan" id="kobo.45.2">And seemingly, they are there, as labeled in </span><em class="italic"><span class="koboSpan" id="kobo.46.1">Figure 1</span></em><em class="italic"><span class="koboSpan" id="kobo.47.1">.2</span></em><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">But they are not actually components. </span><span class="koboSpan" id="kobo.48.3">Instead, developers have worked hard to </span><em class="italic"><span class="koboSpan" id="kobo.49.1">simulate</span></em><span class="koboSpan" id="kobo.50.1"> these with HTML, CSS, and JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.51.1">Now that we’ve glanced over the language mismatch issue in web UI development, it might be helpful to delve into what’s under the surface – the different states we need to manage in </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.52.1">frontend applications. </span><span class="koboSpan" id="kobo.52.2">This will provide a taste of the challenges that lie ahead and shed light on why introducing patterns is a key step toward addressing th</span><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.53.1">em.</span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.54.1">Understanding the state management</span></h1>
<p><span class="koboSpan" id="kobo.55.1">Managing the state in modern</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.56.1"> frontend development is a complex task. </span><span class="koboSpan" id="kobo.56.2">Nearly every application has to retrieve data from a remote server via a network – we can call this data </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">remote states</span></strong><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">Remote state originates from an external source, typically a backend </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.59.1">server or API. </span><span class="koboSpan" id="kobo.59.2">This is in contrast to local state, which is generated and managed entirely within the frontend application itself.</span></p>
<p><span class="koboSpan" id="kobo.60.1">There are many dark sides of remote states, making the frontend development difficult if you don’t pay close attention to them. </span><span class="koboSpan" id="kobo.60.2">Here, I’ll just list a</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.61.1"> few obvious considerations:</span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.62.1">Asynchronous nature</span></em><span class="koboSpan" id="kobo.63.1">: Fetching data from a remote source is usually an asynchronous operation. </span><span class="koboSpan" id="kobo.63.2">This adds complexity in terms of timing, especially when you have to synchronize multiple pieces of remote data.</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.64.1">Error handling</span></em><span class="koboSpan" id="kobo.65.1">: Connections to remote sources might fail or the server might return errors. </span><span class="koboSpan" id="kobo.65.2">Properly managing these scenarios for a smooth user experience can be challenging.</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.66.1">Loading states</span></em><span class="koboSpan" id="kobo.67.1">: While waiting for data to arrive from a remote source, the application needs to handle “loading” states effectively. </span><span class="koboSpan" id="kobo.67.2">This usually involves showing loading indicators or fallback UIs (when the requesting component isn’t available, we use a default one temporarily).</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.68.1">Consistency</span></em><span class="koboSpan" id="kobo.69.1">: Keeping the frontend state in sync with the backend can be difficult, especially in real-time applications or those that involve multiple users altering the same piece of data.</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.70.1">Caching</span></em><span class="koboSpan" id="kobo.71.1">: Storing some remote state locally can improve performance but bring its own challenges, such as invalidation and staleness. </span><span class="koboSpan" id="kobo.71.2">In other words, if the remote data is altered by others, we need a mechanism to receive updates or perform a refetch to update our local state, which introduces a lot of complexity.</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.72.1">Updates and optimistic UI</span></em><span class="koboSpan" id="kobo.73.1">: When a user makes a change, you can update the UI optimistically assuming the server call will succeed. </span><span class="koboSpan" id="kobo.73.2">But if it doesn’t, you’ll need a way to roll back those</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.74.1"> changes in your frontend state.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.75.1">And those are only some of the challenges of remote states.</span></p>
<p><span class="koboSpan" id="kobo.76.1">When the data is stored and accessible immediately in the frontend, you basically think in a linear way. </span><span class="koboSpan" id="kobo.76.2">This means you access and manipulate data in a straightforward sequence, one operation following another, leading to a clear and direct flow of logic. </span><span class="koboSpan" id="kobo.76.3">This way of thinking aligns well with the synchronous nature of the code, making the development process intuitive and easier to follow.</span></p>
<p><span class="koboSpan" id="kobo.77.1">Let’s compare how much more code we’ll need for rendering static data with remote data. </span><span class="koboSpan" id="kobo.77.2">Think about a famous quotes application that displays a list of quotes on the page.</span></p>
<p><span class="koboSpan" id="kobo.78.1">To render the passed-in </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.79.1">quotes list, you can map the data into JSX elements, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.80.1">
function Quotes(quotes: string[]) {
  return (
    &lt;ul&gt;
      {quotes.map((quote, index) =&gt; &lt;li key={index}&gt;{quote}&lt;/li&gt;)}
    &lt;/ul&gt;
  );
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.81.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.82.1">We’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">index</span></strong><span class="koboSpan" id="kobo.84.1"> as the key here, which is fine for static quotes. </span><span class="koboSpan" id="kobo.84.2">However, it’s generally best to avoid this practice. </span><span class="koboSpan" id="kobo.84.3">Using indices can lead to rendering issues in dynamic lists in real-world scenarios.</span></p>
<p><span class="koboSpan" id="kobo.85.1">If the quotes are from a remote server, the</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.86.1"> code will turn into something like the following:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
import React, { useState, useEffect } from 'react';
function Quotes() {
  const [quotes, setQuotes] = useState&lt;string[]&gt;([]);
  useEffect(() =&gt; {
    fetch('</span><a href="https://quote-service.com/quotes'"><span class="koboSpan" id="kobo.88.1">https://quote-service.com/quotes'</span></a><span class="koboSpan" id="kobo.89.1">)
      .then(response =&gt; response.json())
      .then(data =&gt; setQuotes(data));
  }, []);
  return (
    &lt;ul&gt;
      {quotes.map((quote, index) =&gt; &lt;li key={index}&gt;{quote}&lt;/li&gt;)}
    &lt;/ul&gt;
  );
}
export default Quotes;</span></pre> <p><span class="koboSpan" id="kobo.90.1">In this </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.91.1">React component, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">useState</span></strong><span class="koboSpan" id="kobo.93.1"> to create a quotes state variable, initially set as an empty array. </span><span class="koboSpan" id="kobo.93.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">useEffect</span></strong><span class="koboSpan" id="kobo.95.1"> Hook fetches quotes from a remote server when the component mounts. </span><span class="koboSpan" id="kobo.95.2">It then updates the quotes state with the fetched data. </span><span class="koboSpan" id="kobo.95.3">Finally, the component renders a list of quotes, iterating through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">quotes</span></strong><span class="koboSpan" id="kobo.97.1"> array.</span></p>
<p><span class="koboSpan" id="kobo.98.1">Don’t worry, there’s no need to sweat about the details for now; we’ll delve into them in the next chapter on React essentials.</span></p>
<p><span class="koboSpan" id="kobo.99.1">The previous code example shows the ideal scenario, but in reality, asynchronous calls come with their own challenges. </span><span class="koboSpan" id="kobo.99.2">We have to think about what to display while data is being fetched and how to handle various error scenarios, such as network issues or resource unavailability. </span><span class="koboSpan" id="kobo.99.3">These added complexities can make the code lengthier and more difficult to grasp.</span></p>
<p><span class="koboSpan" id="kobo.100.1">For instance, while fetching data, we temporarily transition into a loading state, and should anything go awry, we shift to an error state:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
function Quotes() {
  const [quotes, setQuotes] = useState&lt;string[]&gt;([]);
  const [isLoading, setIsLoading] = useState&lt;boolean&gt;(false);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  useEffect(() =&gt; {
    setIsLoading(true);
    fetch('</span><a href="https://quote-service.com/quotes'"><span class="koboSpan" id="kobo.102.1">https://quote-service.com/quotes'</span></a><span class="koboSpan" id="kobo.103.1">)
      .then(response =&gt; {
        if (!response.ok) {
          throw new Error('Failed to fetch quotes');
        }
        return response.json();
      })
      .then(data =&gt; {
        setQuotes(data);
      })
      .catch(err =&gt; {
        setError(err.message);
      })
      .finally(() =&gt; {
        setIsLoading(false);
      });
  }, []);
  return (
    &lt;div&gt;
      {isLoading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}
      {error &amp;&amp; &lt;p&gt;Error: {error}&lt;/p&gt;}
      &lt;ul&gt;
        {quotes.map((quote, index) =&gt; &lt;li key={index}&gt;{quote}&lt;/li&gt;)}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.104.1">The code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">useState</span></strong><span class="koboSpan" id="kobo.106.1"> to </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.107.1">manage three pieces of state: </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">quotes</span></strong><span class="koboSpan" id="kobo.109.1"> for storing the quotes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">isLoading</span></strong><span class="koboSpan" id="kobo.111.1"> for tracking the loading status, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">error</span></strong><span class="koboSpan" id="kobo.113.1"> for any fetch errors.</span></p>
<p><span class="koboSpan" id="kobo.114.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">useEffect</span></strong><span class="koboSpan" id="kobo.116.1"> Hook triggers the fetch operation. </span><span class="koboSpan" id="kobo.116.2">If the fetch is successful, the quotes are displayed and </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">isLoading</span></strong><span class="koboSpan" id="kobo.118.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">false</span></strong><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">If an error occurs, an error message is displayed and </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">isLoading</span></strong><span class="koboSpan" id="kobo.122.1"> is again set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">false</span></strong><span class="koboSpan" id="kobo.124.1">.</span></p>
<p><span class="koboSpan" id="kobo.125.1">As you can observe, the portion of the component dedicated to actual rendering is quite small (i.e., the JSX code inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">return</span></strong><span class="koboSpan" id="kobo.127.1">). </span><span class="koboSpan" id="kobo.127.2">In contrast, managing the state consumes nearly two-thirds of the function’s body.</span></p>
<p><span class="koboSpan" id="kobo.128.1">But that’s just one aspect of</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.129.1"> the state management. </span><span class="koboSpan" id="kobo.129.2">There’s also the matter of managing local state, which means the state only needs to be maintained inside a component. </span><span class="koboSpan" id="kobo.129.3">For example, as demonstrated in </span><em class="italic"><span class="koboSpan" id="kobo.130.1">Figure 1</span></em><em class="italic"><span class="koboSpan" id="kobo.131.1">.3</span></em><span class="koboSpan" id="kobo.132.1">, an accordion component needs to track whether it’s expanded or collapsed – when you click the triangle on the header, it toggles the list panel:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.133.1"><img alt="Figure 1.3: An expandable section" src="image/B21103_01_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.134.1">Figure 1.3: An expandable section</span></p>
<p><span class="koboSpan" id="kobo.135.1">Using a third-party state management library such as Redux or MobX can be beneficial when your application reaches a level of complexity that makes state tracking difficult. </span><span class="koboSpan" id="kobo.135.2">However, using a third-party state management library isn’t without its caveats (learning curve, best practices in a particular library, migration efforts, etc.) and should be considered carefully. </span><span class="koboSpan" id="kobo.135.3">That’s why many developers are leaning toward using React’s built-in </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.136.1">Context API for state management.</span></p>
<p><span class="koboSpan" id="kobo.137.1">Another significant complexity in modern frontend applications that often goes unnoticed by many developers, yet is akin to an iceberg that warrants closer attention, is “unhappy paths.” </span><span class="koboSpan" id="kobo.137.2">Let’s look at</span><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.138.1"> these next.</span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.139.1">Exploring “unhappy paths”</span></h1>
<p><span class="koboSpan" id="kobo.140.1">When it comes to UI development, our primary focus is often on the “happy path” – the optimal user journey where everything goes as planned. </span><span class="koboSpan" id="kobo.140.2">However, neglecting the “unhappy paths” can make your UI far more complicated than you might initially think. </span><span class="koboSpan" id="kobo.140.3">Here are some scenarios </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.141.1">that could lead to unhappy paths and consequently complicate your UI develop</span><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.142.1">ment efforts.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.143.1">Errors thrown from other components</span></h2>
<p><span class="koboSpan" id="kobo.144.1">Imagine that you’re using</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.145.1"> a third-party component or even another team’s component within your application. </span><span class="koboSpan" id="kobo.145.2">If that component throws an error, it could potentially break your UI or lead to unexpected behaviors that you have to account for. </span><span class="koboSpan" id="kobo.145.3">This can involve adding conditional logic or error boundaries to handle these errors gracefully, making your UI more complex than initially anticipated.</span></p>
<p><span class="koboSpan" id="kobo.146.1">For example, in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">MenuItem</span></strong><span class="koboSpan" id="kobo.148.1"> component that renders an item’s data, let’s see what happens when we try accessing something that doesn’t exist in the passed-in prop </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">item</span></strong><span class="koboSpan" id="kobo.150.1"> (in this case, we’re looking for the aptly named </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">item.something.doesnt.exist</span></strong><span class="koboSpan" id="kobo.152.1">):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
const MenuItem = ({
  item,
  onItemClick,
}: {
  item: MenuItemType;
  onItemClick: (item: MenuItemType) =&gt; void;
}) =&gt; {
  const information = item.something.doesnt.exist;
  return (
    &lt;li key={item.name}&gt;
      &lt;h3&gt;{item.name}&lt;/h3&gt;
      &lt;p&gt;{item.description}&lt;/p&gt;
      &lt;button onClick={() =&gt; onItemClick(item)}&gt;Add to Cart&lt;/button&gt;
    &lt;/li&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.154.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">MenuItem</span></strong><span class="koboSpan" id="kobo.156.1"> component </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.157.1">receives an </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">item</span></strong><span class="koboSpan" id="kobo.159.1"> object and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">onItemClick</span></strong><span class="koboSpan" id="kobo.161.1"> function as props. </span><span class="koboSpan" id="kobo.161.2">It displays the item’s name and description, as well as including an </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Add to Cart</span></strong><span class="koboSpan" id="kobo.163.1"> button. </span><span class="koboSpan" id="kobo.163.2">When the button is clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">onItemClick</span></strong><span class="koboSpan" id="kobo.165.1"> function is called with the item as an argument.</span></p>
<p><span class="koboSpan" id="kobo.166.1">This code attempts to access a non-existing property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">item.something.doesnt.exist</span></strong><span class="koboSpan" id="kobo.168.1">, which will cause a runtime error. </span><span class="koboSpan" id="kobo.168.2">As demonstrated in </span><em class="italic"><span class="koboSpan" id="kobo.169.1">Figure 1</span></em><em class="italic"><span class="koboSpan" id="kobo.170.1">.4</span></em><span class="koboSpan" id="kobo.171.1">, the application stopped working after the backend service returned some unexpected data:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.172.1"><img alt="Figure 1.4: A component-thrown exception during render" src="image/B21103_01_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.173.1">Figure 1.4: A component-thrown exception during render</span></p>
<p><span class="koboSpan" id="kobo.174.1">This can cause the </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.175.1">whole application to crash if we don’t isolate the error into an </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">error boundary</span></strong><span class="koboSpan" id="kobo.177.1">, as we can see in </span><em class="italic"><span class="koboSpan" id="kobo.178.1">Figure 1</span></em><em class="italic"><span class="koboSpan" id="kobo.179.1">.4</span></em><span class="koboSpan" id="kobo.180.1"> – the menus are not displayed, but the category and page titles remain functional; the area affected, which I’ve outlined with a red dotted line, is where the menus were supposed to appear. </span><span class="koboSpan" id="kobo.180.2">Error boundaries in </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.181.1">React are a feature that allows you to catch JavaScript errors that occur in child components, log those errors, and display a fallback UI instead of letting the whole app crash. </span><span class="koboSpan" id="kobo.181.2">Error boundaries catch errors during rendering, in life cycle methods, and in constructors of the whole tree below them.</span></p>
<p><span class="koboSpan" id="kobo.182.1">In real-w</span><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.183.1">orld projects, your UI might depend on various microservices or APIs for fetching data. </span><span class="koboSpan" id="kobo.183.2">If any of these downstream systems are down, your UI has to account for it. </span><span class="koboSpan" id="kobo.183.3">You’ll need to design fallbacks, loading indicators, or friendly error messages that guide the user on what to do next. </span><span class="koboSpan" id="kobo.183.4">Handling these scenarios effectively often involves both frontend and backend logic, thus adding another layer of complexity to your UI de</span><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.184.1">velopment tasks.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.185.1">Learning the unexpected user behavior</span></h2>
<p><span class="koboSpan" id="kobo.186.1">No matter</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.187.1"> how perfectly you design your UI, users will always find ways to use your system in manners you didn’t anticipate. </span><span class="koboSpan" id="kobo.187.2">Whether they input special characters in text fields, try to submit forms too quickly, or use browser extensions that interfere with your site, you have to design your UI to handle these edge cases. </span><span class="koboSpan" id="kobo.187.3">This means implementing additional validation, checks, and safeguards that can complicate your UI code base.</span></p>
<p><span class="koboSpan" id="kobo.188.1">Let’s examine a basic </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Form</span></strong><span class="koboSpan" id="kobo.190.1"> component to understand the considerations for user input. </span><span class="koboSpan" id="kobo.190.2">While this single-field form might require additional logic in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">handleChange</span></strong><span class="koboSpan" id="kobo.192.1"> method, it’s important to note that most forms typically consist of several fields (which means there will be more unexpected user behavior we need to consider):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
import React, { ChangeEvent, useState } from "react";
const Form = () =&gt; {
  const [value, setValue] = useState&lt;string&gt;("");
  const handleChange = (event: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const inputValue = event.target.value;
    const sanitizedValue = inputValue.replace(/[^\w\s]/gi, "");
    setValue(sanitizedValue);
  };
  return (
    &lt;div&gt;
      &lt;form&gt;
        &lt;label&gt;
          Input without special characters:
          &lt;input type="text" value={value} onChange={handleChange} /&gt;
        &lt;/label&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};
export default Form;</span></pre> <p><span class="koboSpan" id="kobo.194.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Form</span></strong><span class="koboSpan" id="kobo.196.1"> component </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.197.1">consists of a single text input field that restricts input to alphanumeric characters and spaces. </span><span class="koboSpan" id="kobo.197.2">It uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">value</span></strong><span class="koboSpan" id="kobo.199.1"> state variable to store the input field’s value. </span><span class="koboSpan" id="kobo.199.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">handleChange</span></strong><span class="koboSpan" id="kobo.201.1"> function, triggered on each input change, removes any non-alphanumeric characters from the user’s input before updating the state with the sanitized value.</span></p>
<p><span class="koboSpan" id="kobo.202.1">Understanding and effectively managing these unhappy paths are critical to creating a robust, resilient, and user-friendly interface. </span><span class="koboSpan" id="kobo.202.2">Not only do they make your application more reliable, but they also contribute to a more comprehensive and well-thought-o</span><a id="_idTextAnchor028"/><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.203.1">ut user experience.</span></p>
<p><span class="koboSpan" id="kobo.204.1">I believe you should now have a clearer insight into the challenges of building modern frontend applications in React. </span><span class="koboSpan" id="kobo.204.2">Tackling these hurdles isn’t straightforward, particularly since React doesn’t offer a definitive guide on which approach to adopt, how to structure your code base, manage states, or ensure code readability (and by extension, ease of maintenance in the long run), or how established patterns can be of aid, among other concerns. </span><span class="koboSpan" id="kobo.204.3">This lack of guidance often leads developers to create solutions that might work in the short term but could be riddled with anti-patterns.</span></p>
<h1 id="_idParaDest-23"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.205.1">Exploring common anti-patterns in React</span></h1>
<p><span class="koboSpan" id="kobo.206.1">Within the realm of software development, we often encounter practices and approaches that, at first glance, appear to offer a beneficial solution to a particular problem. </span><span class="koboSpan" id="kobo.206.2">These practices, labeled as </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">anti-patterns</span></strong><span class="koboSpan" id="kobo.208.1">, may provide immediate relief or a seemingly quick fix, but they often hide</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.209.1"> underlying issues. </span><span class="koboSpan" id="kobo.209.2">Over time, reliance on these anti-patterns can lead to greater complexities, inefficiencies, or even the very issues they were thought to resolve.</span></p>
<p><span class="koboSpan" id="kobo.210.1">Recognizing and understanding these anti-patterns is crucial for developers, as it enables them to anticipate potential pitfalls and steer clear of solutions that may be counterproductive in the long run. </span><span class="koboSpan" id="kobo.210.2">In the upcoming sections, we’ll highlight common anti-patterns accompanied by code examples. </span><span class="koboSpan" id="kobo.210.3">We’ll address each anti-pattern and outline potential solutions. </span><span class="koboSpan" id="kobo.210.4">However, we won’t delve deeply here since entire chapters are dedicated to discussing these topics in detail.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.211.1">Props drilling</span></h2>
<p><span class="koboSpan" id="kobo.212.1">In complex React </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.213.1">applications, managing state and ensuring that every component has access to the data it needs can become challenging. </span><span class="koboSpan" id="kobo.213.2">This is often observed in the form of </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">props drilling</span></strong><span class="koboSpan" id="kobo.215.1">, where</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.216.1"> props are passed from a parent component through multiple intermediary components before they reach the child component that actually needs them.</span></p>
<p><span class="koboSpan" id="kobo.217.1">For instance, consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">SearchableList</span></strong><span class="koboSpan" id="kobo.219.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">List</span></strong><span class="koboSpan" id="kobo.221.1">, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">ListItem</span></strong><span class="koboSpan" id="kobo.223.1"> hierarchy – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">SearchableList</span></strong><span class="koboSpan" id="kobo.225.1"> component contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">List</span></strong><span class="koboSpan" id="kobo.227.1"> component, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">List</span></strong><span class="koboSpan" id="kobo.229.1"> contains multiple instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">ListItem</span></strong><span class="koboSpan" id="kobo.231.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
function SearchableList({ items, onItemClick }) {
  return (
    &lt;div className="searchable-list"&gt;
      {/* Potentially some search functionality here */}
      &lt;List items={items} onItemClick={onItemClick} /&gt;
    &lt;/div&gt;
  );
}
function List({ items, onItemClick }) {
  return (
    &lt;ul className="list"&gt;
      {items.map(item =&gt; (
        &lt;ListItem key={item.id} data={item} onItemClick={onItemClick}
         /&gt;
      ))}
    &lt;/ul&gt;
  );
}
function ListItem({ data, onItemClick }) {
  return (
    &lt;li className="list-item" onClick={() =&gt; onItemClick(data.id)}&gt;
      {data.name}
    &lt;/li&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">In this setup, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">onItemClick</span></strong><span class="koboSpan" id="kobo.235.1"> prop is drilled from </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">SearchableList</span></strong><span class="koboSpan" id="kobo.237.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">List</span></strong><span class="koboSpan" id="kobo.239.1"> and finally to </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">ListItem</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">Though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">List</span></strong><span class="koboSpan" id="kobo.243.1"> component doesn’t use this prop, it has to pass it down to </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">ListItem</span></strong><span class="koboSpan" id="kobo.245.1">.</span></p>
<p><span class="koboSpan" id="kobo.246.1">This approach</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.247.1"> can lead to </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.248.1">increased complexity and reduced maintainability. </span><span class="koboSpan" id="kobo.248.2">When multiple props are passed down through various components, understanding the flow of data and debugging can become difficult.</span></p>
<p><span class="koboSpan" id="kobo.249.1">A potential solution to avoid props </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.250.1">drilling in React is by leveraging the Context API. </span><span class="koboSpan" id="kobo.250.2">It provides a way to share values (data and functions) between components without having to explicitly pass props through every level of the component tree.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.251.1">In-component data transformation</span></h2>
<p><span class="koboSpan" id="kobo.252.1">The component-centric approach in </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.253.1">React is all about breaking up tasks and concerns into manageable chunks, enhancing maintainability. </span><span class="koboSpan" id="kobo.253.2">One recurrent misstep, however, is when developers introduce complex data transformation logic directly</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.254.1"> within components.</span></p>
<p><span class="koboSpan" id="kobo.255.1">It’s common, especially when dealing with external APIs or backends, to receive data in a shape or format that isn’t ideal for the frontend. </span><span class="koboSpan" id="kobo.255.2">Instead of adjusting this data at a higher level, or in a utility function, the transformation is defined inside the component.</span></p>
<p><span class="koboSpan" id="kobo.256.1">Consider the following scenario:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  useEffect(() =&gt; {
    fetch(`/api/users/${userId}`)
      .then(response =&gt; response.json())
      .then(data =&gt; {
        // Transforming data right inside the component
        const transformedUser = {
          name: `${data.firstName} ${data.lastName}`,
          age: data.age,
          address: `${data.addressLine1}, ${data.city}, ${data.
</span><span class="koboSpan" id="kobo.257.2">           country}`
        };
        setUser(transformedUser);
      });
  }, [userId]);
  return (
    &lt;div&gt;
      {user &amp;&amp; (
        &lt;&gt;
          &lt;p&gt;Name: {user.name}&lt;/p&gt;
          &lt;p&gt;Age: {user.age}&lt;/p&gt;
          &lt;p&gt;Address: {user.address}&lt;/p&gt;
        &lt;/&gt;
      )}
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.258.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">UserProfile</span></strong><span class="koboSpan" id="kobo.260.1"> function component retrieves and displays a user’s profile based on the provided prop </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">userId</span></strong><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">Once the remote </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">data</span></strong><span class="koboSpan" id="kobo.264.1"> is fetched, it’s transformed within the </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.265.1">component itself to create a structured user</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.266.1"> profile. </span><span class="koboSpan" id="kobo.266.2">This transformed data consists of the user’s full name (a combination of first and last name), age, and a formatted address.</span></p>
<p><span class="koboSpan" id="kobo.267.1">By directly embedding the transformation, we encounter a few issues:</span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.268.1">Lack of clarity</span></em><span class="koboSpan" id="kobo.269.1">: Combining data fetching, transformation, and rendering tasks within a single component makes it harder to pinpoint the component’s exact purpose</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.270.1">Reduced reusability</span></em><span class="koboSpan" id="kobo.271.1">: Should another component require the same or a similar transformation, we’d be duplicating logic</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.272.1">Testing challenges</span></em><span class="koboSpan" id="kobo.273.1">: Testing this component now requires considering the transformation logic, making tests more convoluted</span></li>
</ul>
<p><span class="koboSpan" id="kobo.274.1">To combat this</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.275.1"> anti-pattern, it’s advised to separate data </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.276.1">transformation from the component. </span><span class="koboSpan" id="kobo.276.2">This can be achieved using utility functions or custom Hooks, thus ensuring a cleaner and more modular design. </span><span class="koboSpan" id="kobo.276.3">By externalizing these transformations, components remain focused on rendering and business logic stays centralized, making for a far more maintainable code base.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.277.1">Complicated logic in views</span></h2>
<p><span class="koboSpan" id="kobo.278.1">The beauty of modern frontend </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.279.1">frameworks, including React, is the distinct separation of concerns. </span><span class="koboSpan" id="kobo.279.2">By design, components should be oblivious </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.280.1">to the intricacies of business logic, focusing instead on presentation. </span><span class="koboSpan" id="kobo.280.2">However, a recurrent pitfall that developers encounter is the infusion of business logic within view components. </span><span class="koboSpan" id="kobo.280.3">This not only disrupts the clean separation but also bloats components and makes them harder to test and reuse.</span></p>
<p><span class="koboSpan" id="kobo.281.1">Consider a simple example. </span><span class="koboSpan" id="kobo.281.2">Imagine a component that is meant to display a list of items fetched from an API. </span><span class="koboSpan" id="kobo.281.3">Each item has a price, but we want to display items </span><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.282.1">above a certain threshold price:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
function PriceListView({ items }) {
  // Business logic within the view
  const filterExpensiveItems = (items) =&gt; {
    return items.filter(item =&gt; item.price &gt; 100);
  }
  const expensiveItems = filterExpensiveItems(items);
  return (
    &lt;div&gt;
      {expensiveItems.map(item =&gt; (
        &lt;div key={item.id}&gt;
          {item.name}: ${item.price}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.284.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">filterExpensiveItems</span></strong><span class="koboSpan" id="kobo.286.1"> function, a piece of business logic, resides directly within the view component. </span><span class="koboSpan" id="kobo.286.2">The component is now tasked with not just presenting data but also processing it.</span></p>
<p><span class="koboSpan" id="kobo.287.1">This approach can </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.288.1">become problematic:</span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.289.1">Reusability</span></em><span class="koboSpan" id="kobo.290.1">: If another component requires a similar filter, the logic would need to be duplicated</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.291.1">Testing</span></em><span class="koboSpan" id="kobo.292.1">: Unit testing becomes more complex as you’re not just testing the rendering, but also the business logic</span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.293.1">Maintenance</span></em><span class="koboSpan" id="kobo.294.1">: As the application grows and more logic is added, this component can become unwieldy and harder to maintain</span></li>
</ul>
<p><span class="koboSpan" id="kobo.295.1">To ensure our components remain reusable and easy to maintain, it’s wise to embrace the </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">separation of concerns</span></strong><span class="koboSpan" id="kobo.297.1"> principle. </span><span class="koboSpan" id="kobo.297.2">This </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.298.1">principle states that each module or</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.299.1"> function in software should have responsibility over a single part of the application’s functionality. </span><span class="koboSpan" id="kobo.299.2">By separating the business logic from the presentation layer and adopting a </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">layered architecture</span></strong><span class="koboSpan" id="kobo.301.1">, we </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.302.1">can ensure each part of our code handles its own specific responsibility, leading to a more</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.303.1"> modular and </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.304.1">maintainable code base.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.305.1">Lack of tests</span></h2>
<p><span class="koboSpan" id="kobo.306.1">Imagine building a </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.307.1">shopping cart component for an online store. </span><span class="koboSpan" id="kobo.307.2">The cart is crucial as it handles item additions, removals, and total price calculations. </span><span class="koboSpan" id="kobo.307.3">As straightforward as it may seem, it embodies various moving parts and logic interconnections. </span><span class="koboSpan" id="kobo.307.4">Without tests, you leave the door open for future problems, such as incorrect pricing, items not being added or removed correctly, or even security vulnerabilities.</span></p>
<p><span class="koboSpan" id="kobo.308.1">Consider this simplistic version of a shopping cart:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
function ShoppingCart() {
  const [items, setItems] = useState([]);
  const addItem = (item) =&gt; {
    setItems([...items, item]);
  };
  const removeItem = (itemId) =&gt; {
    setItems(items.filter(item =&gt; item.id !== itemId));
  };
  const calculateTotal = () =&gt; {
    return items.reduce((total, item) =&gt; total + item.price, 0);
  };
  return (
    &lt;div&gt;
      {/* Render items and controls for adding/removing */}
      &lt;p&gt;Total: ${calculateTotal()}&lt;/p&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.310.1">While this </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.311.1">shopping cart’s logic appears straightforward, potential pitfalls are lurking. </span><span class="koboSpan" id="kobo.311.2">What if an item gets added multiple times erroneously, or prices change dynamically, or discounts are applied? </span><span class="koboSpan" id="kobo.311.3">Without tests, these scenarios might not be evident until a user encounters them, which could be detrimental to the business.</span></p>
<p><span class="koboSpan" id="kobo.312.1">Enter </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">test-driven development</span></strong><span class="koboSpan" id="kobo.314.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.315.1">TDD</span></strong><span class="koboSpan" id="kobo.316.1">). </span><span class="koboSpan" id="kobo.316.2">TDD emphasizes writing tests before the actual component or logic. </span><span class="koboSpan" id="kobo.316.3">For our </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.318.1"> component, it means having tests verifying that items are correctly </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.319.1">added or removed, total calculations are adjusted appropriately, and edge cases, such as handling discounts, are managed. </span><span class="koboSpan" id="kobo.319.2">Only after these tests are in place should the actual component logic be implemented. </span><span class="koboSpan" id="kobo.319.3">TDD is more than just catching errors early; it champions well-structured, maintainable code.</span></p>
<p><span class="koboSpan" id="kobo.320.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">ShoppingCart</span></strong><span class="koboSpan" id="kobo.322.1"> component, adopting TDD would necessitate tests ensuring items get added or removed as expected, totals are correctly computed, and edge cases are tackled seamlessly. </span><span class="koboSpan" id="kobo.322.2">This way, as the application grows, the foundational TDD tests ensure each modification or addition maintains the application’s integrity and correctness.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.323.1">Duplicated code</span></h2>
<p><span class="koboSpan" id="kobo.324.1">It’s a familiar</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.325.1"> sight in many code bases – chunks of identical or very similar code scattered across different parts of the application. </span><span class="koboSpan" id="kobo.325.2">Duplicated code not only bloats the code base but also introduces potential points of failure. </span><span class="koboSpan" id="kobo.325.3">When a bug is detected or an enhancement is needed, every instance of the duplicated code may need to be altered, leading to an increased likelihood of introducing errors.</span></p>
<p><span class="koboSpan" id="kobo.326.1">Let’s consider two components in which the same filtering logic is repeated:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
function AdminList(props) {
  const filteredUsers = props.users.filter(user =&gt; user.isAdmin);
  return &lt;List items={filteredUsers} /&gt;;
}
function ActiveList(props) {
  const filteredUsers = props.users.filter(user =&gt; user.isActive);
  return &lt;List items={filteredUsers} /&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.328.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">DRY</span></strong><span class="koboSpan" id="kobo.330.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.331.1">don’t repeat yourself</span></strong><span class="koboSpan" id="kobo.332.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">principle</span></strong><span class="koboSpan" id="kobo.334.1"> comes to the rescue here. </span><span class="koboSpan" id="kobo.334.2">By centralizing common </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.335.1">logic into utility functions or </span><strong class="bold"><span class="koboSpan" id="kobo.336.1">higher-order components</span></strong><span class="koboSpan" id="kobo.337.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.338.1">HOCs</span></strong><span class="koboSpan" id="kobo.339.1">), the code becomes more maintainable and readable, and less</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.340.1"> prone to errors. </span><span class="koboSpan" id="kobo.340.2">For this example, we could abstract the filtering logic and reuse it, ensuring a </span><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.341.1">singular source of truth</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.342.1"> and easier updates.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.343.1">Long component with too much responsibility</span></h2>
<p><span class="koboSpan" id="kobo.344.1">React encourages the </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.345.1">creation of modular, reusable components. </span><span class="koboSpan" id="kobo.345.2">However, as features get added, a component can quickly grow in size and responsibility, turning into an unwieldy behemoth. </span><span class="koboSpan" id="kobo.345.3">A long component that manages various tasks becomes difficult to maintain, understand, and test.</span></p>
<p><span class="koboSpan" id="kobo.346.1">Imagine an </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">OrderContainer</span></strong><span class="koboSpan" id="kobo.348.1"> component that has a huge prop list that includes a lot of different aspects of the responsibilities:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
const OrderContainer = ({
  testID,
  orderData,
  basketError,
  addCoupon,
  voucherSelected,
  validationErrors,
  clearErrors,
  removeLine,
  editLine,
  hideOrderButton,
  hideEditButton,
  loading,
}: OrderContainerProps) =&gt; {
  //..
</span><span class="koboSpan" id="kobo.349.2">}</span></pre> <p><span class="koboSpan" id="kobo.350.1">Such a component violates the </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">single-responsibility principle</span></strong><span class="koboSpan" id="kobo.352.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.353.1">SRP</span></strong><span class="koboSpan" id="kobo.354.1">), which advocates that a component should </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.355.1">fulfill only one function. </span><span class="koboSpan" id="kobo.355.2">By taking on multiple roles, it becomes more complex and less maintainable. </span><span class="koboSpan" id="kobo.355.3">We need to analyze the core responsibility of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">OrderContainer</span></strong><span class="koboSpan" id="kobo.357.1"> component and separate the supporting logic into other smaller, focused</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.358.1"> components or utilize Hooks for logic separation.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.359.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.360.1">These listed anti-patterns have different variations, and we’ll discuss the solutions correspondingly in the following chapters. </span><span class="koboSpan" id="kobo.360.2">Apart from that, there are also some more generic design principles and design patterns we’ll discuss in the book, as well as some proven engineering practices, such as refactoring and TDD.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.361.1">Unveiling our approach to demolishing anti-patterns</span></h2>
<p><span class="koboSpan" id="kobo.362.1">When it comes to addressing prevalent anti-patterns, an arsenal of design patterns comes to the fore. </span><span class="koboSpan" id="kobo.362.2">Techniques such </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.363.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">render props</span></strong><span class="koboSpan" id="kobo.365.1">, HOCs, and </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">Hooks</span></strong><span class="koboSpan" id="kobo.367.1"> are </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.368.1">instrumental in augmenting component capabilities without deviating from their primary roles, while leveraging foundational patterns such as layered architecture and separation of concerns ensures a streamlined code base, demarcating logic, data, and presentation in a coherent manner. </span><span class="koboSpan" id="kobo.368.2">Such practices don’t just elevate the sustainability of React apps but also lay the groundwork for effective teamwork among developers.</span></p>
<p><span class="koboSpan" id="kobo.369.1">Meanwhile, </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">interface-oriented programming</span></strong><span class="koboSpan" id="kobo.371.1">, at its </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.372.1">core, zeroes in on tailoring software centered around the interactions occurring between software modules, predominantly via interfaces. </span><span class="koboSpan" id="kobo.372.2">Such a modus operandi fosters agility, rendering software modules not only more coherent but also amenable to </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.373.1">alterations. </span><span class="koboSpan" id="kobo.373.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">headless components</span></strong><span class="koboSpan" id="kobo.375.1"> paradigm, on the other hand, embodies components that, while devoid of direct rendering duties, are entrusted with the management of state or logic. </span><span class="koboSpan" id="kobo.375.2">These components pass the baton to their consuming counterparts for UI rendering, thus championing adaptability and reusability.</span></p>
<p><span class="koboSpan" id="kobo.376.1">By gaining a firm grasp on these design patterns and deploying them judiciously, we’re positioned to circumvent prevalent missteps, ther</span><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.377.1">eby uplifting the stature of our React applications.</span></p>
<p><span class="koboSpan" id="kobo.378.1">Plus, within the coding ecosystem, the twin pillars of TDD and consistent refactoring emerge as formidable tools to accentuate code quality. </span><span class="koboSpan" id="kobo.378.2">TDD, with its clarion call of test-before-code, furnishes an immediate feedback loop for potential discrepancies. </span><span class="koboSpan" id="kobo.378.3">Hand-in-hand with TDD, the</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.379.1"> ethos of persistent refactoring ensures that code is perpetually optimized and honed. </span><span class="koboSpan" id="kobo.379.2">Such methodologies not only set the benchmark for code excellence but also instill adaptability to forthcoming changes.</span></p>
<p><span class="koboSpan" id="kobo.380.1">As we navigate the realm of refactoring, it’s pivotal to delve into the essence of these techniques, discerning their intricacies and optimal application points. </span><span class="koboSpan" id="kobo.380.2">Harnessing these refactoring avenues promises to bolster your code’s clarity, sustainability, and overarching efficiency. </span><span class="koboSpan" id="kobo.380.3">This </span><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.381.1">is something that we’ll be doing throughout the book!</span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.382.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.383.1">In this chapter, we explored the challenges of UI development from its complexities to state management issues. </span><span class="koboSpan" id="kobo.383.2">We also discussed the common anti-patterns due to the nature of its complexity, and briefly introduced our approach that combines best practices and effective testing strategies. </span><span class="koboSpan" id="kobo.383.3">This sets the foundation for more efficient and robust frontend development.</span></p>
<p><span class="koboSpan" id="kobo.384.1">In the upcoming chapter, we’ll dive deep into React essentials, giving you the tools and knowledge you need to master this powerful library. </span><span class="koboSpan" id="kobo.384.2">Stay tuned!</span></p>
</section>
</body></html>