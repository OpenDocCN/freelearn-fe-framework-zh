<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer034">
<h1 class="chapter-number" id="_idParaDest-116"><a id="_idTextAnchor115"/>7</h1>
<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Implementing User Authentication and Global Notifications</h1>
<p>In the previous chapters, we configured the pages, created mocked APIs, and made the API calls from our application. However, the application still relies on test data when it comes to the authentication of the users in the <span class="No-Break">admin dashboard.</span></p>
<p>In this chapter, we will build the application’s authentication system, allowing users to authenticate and access protected resources in the admin dashboard. We will also be creating a toast notification system to provide feedback to users if an action happens that we want to notify <span class="No-Break">them about.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Implementing the <span class="No-Break">authentication system</span></li>
<li><span class="No-Break">Implementing notifications</span></li>
</ul>
<p>By the end of the chapter, we will have learned how to authenticate users in our application and also how to handle the global application state <span class="No-Break">with Zustand.</span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Technical requirements</h1>
<p>Before we get started, we need to set up the project. To be able to develop the project, you will need the following things installed on <span class="No-Break">your computer:</span></p>
<ul>
<li><strong class="bold">Node.js</strong> version 16 or above and <strong class="bold">npm</strong> version 8 <span class="No-Break">or above.</span></li>
</ul>
<p>There are multiple ways to install Node.js and npm. Here is a great article that goes into more <span class="No-Break">detail: </span><a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js"><span class="No-Break">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</span></a><span class="No-Break">.</span></p>
<ul>
<li><strong class="bold">VSCode</strong> (optional) is currently the most popular editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source, has great integration with TypeScript, and you can extend its features via extensions. It can be downloaded from <span class="No-Break">here: </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
</ul>
<p>The code files for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/React-Application-Architecture-for-Production"><span class="No-Break">https://github.com/PacktPublishing/React-Application-Architecture-for-Production</span></a><span class="No-Break">.</span></p>
<p>The repository can be cloned locally with the <span class="No-Break">following command:</span></p>
<pre class="console">
git clone https://github.com/PacktPublishing/React-Application-Architecture-for-Production.git</pre>
<p>Once the repository is cloned, we need to install the <span class="No-Break">application’s dependencies:</span></p>
<pre class="console">
npm install</pre>
<p>We can provide the environment variables using the <span class="No-Break">following command:</span></p>
<pre class="console">
cp .env.example .env</pre>
<p>Once the dependencies have been installed, we need to select the right stage of the code base that matches this chapter. We can do that by executing the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run stage:switch</pre>
<p>This command will prompt us with a list of stages for <span class="No-Break">each chapter:</span></p>
<pre class="console">
? What stage do you want to switch to? (Use arrow
 keys)
❯ chapter-02
  chapter-03
  chapter-03-start
  chapter-04
  chapter-04-start
  chapter-05
  chapter-05-start
(Move up and down to reveal more choices)</pre>
<p>This is the seventh chapter, so you can select <strong class="source-inline">chapter-07-start</strong> if you want to follow along, or <strong class="source-inline">chapter-07</strong> to see the final results of <span class="No-Break">the chapter.</span></p>
<p>Once the chapter has been selected, all files required to follow along with the chapter <span class="No-Break">will appear.</span></p>
<p>For more information about the setup details, check out the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Implementing the authentication system</h1>
<p>Authentication is the<a id="_idIndexMarker335"/> process of identifying who the user on a platform is. In our application, we need to identify users when they access the <span class="No-Break">admin dashboard.</span></p>
<p>Before implementing the system, we should look closely at how it <span class="No-Break">will work.</span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Authentication system overview</h2>
<p>We are going to authenticate<a id="_idIndexMarker336"/> the users with a token-based authentication system. That means the API will expect the user to send their authentication token with the request to access <span class="No-Break">protected resources.</span></p>
<p>Let’s take a look at the following diagram and the <span class="No-Break">subsequent steps:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 7.1 – Authentication system overview " height="706" src="image/B17297_07_01.jpg" width="1190"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Authentication system overview</p>
<p>The preceding diagram is <a id="_idIndexMarker337"/>explained <span class="No-Break">as follows:</span></p>
<ol>
<li>The user submits the login form with the credentials by creating a request to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">auth/login</strong></span><span class="No-Break"> endpoint.</span></li>
<li>If the user exists and the credentials are valid, a response with the user data returns. In addition to the response data, we are also attaching an <strong class="source-inline">httpOnly</strong> cookie, which will be used from this point onward for <span class="No-Break">authenticated requests.</span></li>
<li>Whenever the user authenticates, we will store the user object from the response in react-query’s cache and make it available to <span class="No-Break">the application.</span></li>
<li>Since the authentication is cookie-based with <strong class="source-inline">httpOnly</strong> cookies, we do not need to handle the authentication token on the frontend. Any subsequent requests will include the <span class="No-Break">token automatically.</span></li>
<li>Persisting user data on page refreshes will be handled by calling the <strong class="source-inline">/auth/me</strong> endpoint, which will fetch the user data and store it in the same <span class="No-Break">react-query cache.</span></li>
</ol>
<p>To implement this system, we <a id="_idIndexMarker338"/>need <span class="No-Break">the following:</span></p>
<ul>
<li>Auth features (login, logout, and accessing the <span class="No-Break">authenticated user)</span></li>
<li>Protect resources that require the user to <span class="No-Break">be authenticated</span></li>
</ul>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Building authentication features</h2>
<p>To build the authentication <a id="_idIndexMarker339"/>features, we already have the endpoints implemented.. We created them in <a href="B17297_05.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Mocking the API</em>. Now we need to consume them in <span class="No-Break">our application.</span></p>
<h3>Logging in</h3>
<p>To allow users to log in to the<a id="_idIndexMarker340"/> dashboard, we’ll require them to enter their email and password and submit <span class="No-Break">the form.</span></p>
<p>To implement the login feature, we will need to make an API call to the login endpoint on the server. Let’s create the <strong class="source-inline">src/features/auth/api/login.ts</strong> file and add <span class="No-Break">the following:</span></p>
<pre class="source-code">
import { useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { queryClient } from '@/lib/react-query';
import { AuthUser, LoginData } from '../types';
export const login = (
  data: LoginData
): Promise&lt;{
  user: AuthUser;
}&gt; =&gt; {
  return apiClient.post('/auth/login', data);
};
type UseLoginOptions = {
  onSuccess?: (user: AuthUser) =&gt; void;
};
export const useLogin = ({
  onSuccess,
}: UseLoginOptions = {}) =&gt; {
  const { mutate: submit, isLoading } = useMutation({
    mutationFn: login,
    onSuccess: ({ user }) =&gt; {
      queryClient.setQueryData(['auth-user'], user);
      onSuccess?.(user);
    },
  });
  return { submit, isLoading };
};</pre>
<p>We are defining the <a id="_idIndexMarker341"/>API request and the API mutation hook, allowing us to call the API from <span class="No-Break">our application.</span></p>
<p>Then, we can update the login form to make the API call. Let’s <span class="No-Break">modify </span><span class="No-Break"><strong class="source-inline">src/features/auth/components/login-form/login-form.tsx</strong></span><span class="No-Break">.</span></p>
<p>First, let’s import the <span class="No-Break"><strong class="source-inline">useLogin</strong></span><span class="No-Break"> hook:</span></p>
<pre class="source-code">
import { useLogin } from '../../api/login';</pre>
<p>Then, inside the <strong class="source-inline">LoginForm</strong> component body, we want to initialize the login mutation and submit it in the <span class="No-Break">submit</span><span class="No-Break"><a id="_idIndexMarker342"/></span><span class="No-Break"> handler:</span></p>
<pre class="source-code">
export const LoginForm = ({
  onSuccess,
}: LoginFormProps) =&gt; {
  const login = useLogin({ onSuccess });
  const { register, handleSubmit, formState } =
    useForm&lt;LoginData&gt;();
  const onSubmit = (data: LoginData) =&gt; {
    login.submit(data);
  };
     // rest of the component body
}</pre>
<p>We should also indicate that the action is being submitted by disabling the <span class="No-Break"><strong class="bold">Submit</strong></span><span class="No-Break"> button:</span></p>
<pre class="source-code">
&lt;Button
  isLoading={login.isLoading}
  isDisabled={login.isLoading}
  type="submit"
&gt;
  Log in
&lt;/Button&gt;</pre>
<p>When the form is submitted, it will<a id="_idIndexMarker343"/> call the login endpoint, which will authenticate the user if the credentials <span class="No-Break">are valid.</span></p>
<h3>Logging out</h3>
<p>To implement the logout <a id="_idIndexMarker344"/>feature, we need to call the logout endpoint, which will clear the auth cookie. Let’s create the <strong class="source-inline">src/features/auth/api/logout.ts</strong> file and add <span class="No-Break">the following:</span></p>
<pre class="source-code">
import { useMutation } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { queryClient } from '@/lib/react-query';
export const logout = () =&gt; {
  return apiClient.post('/auth/logout');
};
type UseLogoutOptions = {
  onSuccess?: () =&gt; void;
};
export const useLogout = ({
  onSuccess,
}: UseLogoutOptions = {}) =&gt; {
  const { mutate: submit, isLoading } = useMutation({
    mutationFn: logout,
    onSuccess: () =&gt; {
      queryClient.clear();
      onSuccess?.();
    },
  });
  return { submit, isLoading };
};</pre>
<p>We are defining the logout API <a id="_idIndexMarker345"/>request and the <span class="No-Break">logout mutation.</span></p>
<p>Then, we can expose that from the auth feature by re-exporting it from the <span class="No-Break"><strong class="source-inline">src/features/auth/index.ts</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
export * from './api/logout';</pre>
<p>We want to use it when the user clicks the <strong class="bold">Log Out</strong> button, which will be located in the dashboard navbar. Let’s go to the <strong class="source-inline">src/layouts/dashboard-layout.tsx</strong> file and import <span class="No-Break">additional dependencies:</span></p>
<pre class="source-code">
import { useRouter } from 'next/router';
import { useLogout } from '@/features/auth';</pre>
<p>Then, in the <strong class="source-inline">Navbar</strong> component, let’s use the <span class="No-Break"><strong class="source-inline">useLogout</strong></span><span class="No-Break"> hook:</span></p>
<pre class="source-code">
const Navbar = () =&gt; {
  const router = useRouter();
  const logout = useLogout({
    onSuccess: () =&gt; router.push('/auth/login'),
  });
  // the rest of the component
};</pre>
<p>Notice how we redirect the user to the login page when the logout <span class="No-Break">action succeeds.</span></p>
<p>Let’s finally wire the action to the <span class="No-Break">logout button:</span></p>
<pre class="source-code">
&lt;Button
  isDisabled={logout.isLoading}
  isLoading={logout.isLoading}
  variant="outline"
  onClick={() =&gt; logout.submit()}
&gt;
  Log Out
&lt;/Button&gt;</pre>
<p>Now, when the user clicks the <strong class="bold">Log Out</strong> button, the logout endpoint will be called, and then the user will be <a id="_idIndexMarker346"/>taken to the <span class="No-Break">login page.</span></p>
<h3>Getting an authenticated user</h3>
<p>To get started, let’s create the <strong class="source-inline">src/features/auth/api/get-auth-user.ts</strong> file and add <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker347"/></span><span class="No-Break"> following:</span></p>
<pre class="source-code">
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/api-client';
import { AuthUser } from '../types';
export const getAuthUser = (): Promise&lt;AuthUser&gt; =&gt; {
  return apiClient.get('/auth/me');
};
export const useUser = () =&gt; {
  const { data, isLoading } = useQuery({
    queryKey: ['auth-user'],
    queryFn: () =&gt; getAuthUser(),
  });
  return { data, isLoading };
};</pre>
<p>This endpoint will return<a id="_idIndexMarker348"/> information about the user currently <span class="No-Break">logged in.</span></p>
<p>Then, we want to export it from the <span class="No-Break"><strong class="source-inline">src/features/auth/index.ts</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
export * from './api/get-auth-user';</pre>
<p>Back to the <strong class="source-inline">src/layouts/dashboard-layout.tsx</strong> file, we need the user <span class="No-Break">data there.</span></p>
<p>Let’s replace the <strong class="source-inline">useUser</strong> hook from the test data with <span class="No-Break">the following:</span></p>
<pre class="source-code">
import { useLogout, useUser } from '@/features/auth';</pre>
<p>Another place where we need the user data is the dashboard jobs page. Let’s open <strong class="source-inline">src/pages/dashboard/jobs/index.tsx</strong> and import the <span class="No-Break"><strong class="source-inline">useUser</strong></span><span class="No-Break"> hook:</span></p>
<pre class="source-code">
import { useUser } from '@/features/auth';</pre>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Protecting resources that require the user to be authenticated</h2>
<p>What should happen if an unauthenticated user tries to view a protected resource? We want to ensure that any <a id="_idIndexMarker349"/>such attempt will redirect the user to the login page. To do that, we want to create a component that will wrap protected resources and let users view protected content only if they <span class="No-Break">are authenticated.</span></p>
<p>The <strong class="source-inline">Protected</strong> component will fetch the user from the <strong class="source-inline">/auth/me</strong> endpoint, and if the user exists, it will allow the content to be shown. Otherwise, it will redirect the user to the <span class="No-Break">login page.</span></p>
<p>The component has already been defined in the <strong class="source-inline">src/features/auth/components/protected/protected.tsx</strong> file, but it isn’t doing much right now. Let’s modify the file to <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker350"/></span><span class="No-Break"> following:</span></p>
<pre class="source-code">
import { Flex } from '@chakra-ui/react';
import { useRouter } from 'next/router';
import { ReactNode, useEffect } from 'react';
import { Loading } from '@/components/loading';
import { useUser } from '../../api/get-auth-user';
export type ProtectedProps = {
  children: ReactNode;
};
export const Protected = ({
  children,
}: ProtectedProps) =&gt; {
  const { replace, asPath } = useRouter();
  const user = useUser();
  useEffect(() =&gt; {
    if (!user.data &amp;&amp; !user.isLoading) {
      replace(
        `/auth/login?redirect=${asPath}`,
        undefined,
        { shallow: true }
      );
    }
  }, [user, asPath, replace]);
  if (user.isLoading) {
    return (
      &lt;Flex direction="column" justify="center" h="full"&gt;
        &lt;Loading /&gt;
      &lt;/Flex&gt;
    );
  }
  if (!user.data &amp;&amp; !user.isLoading) return null;
  return &lt;&gt;{children}&lt;/&gt;;
};</pre>
<p>The component accepts children as props, meaning it will wrap nested content and decide whether it should <span class="No-Break">be rendered.</span></p>
<p>We are accessing the<a id="_idIndexMarker351"/> user from the same <strong class="source-inline">useUser</strong> hook. Initially, while the data is being fetched, the component renders the <strong class="source-inline">Loading</strong> component. Once the data is fetched, we check in <strong class="source-inline">useEffect</strong> to see whether the user exists, and if it doesn’t, we will redirect to the login page. Otherwise, we can render children <span class="No-Break">as usual.</span></p>
<p>The <strong class="source-inline">Protected</strong> component is meant to be used in the dashboard. Since we already have a reusable layout for the dashboard, rather than wrapping every page with <strong class="source-inline">Protected</strong>, we can do that only <a id="_idIndexMarker352"/>once in the <span class="No-Break">dashboard layout.</span></p>
<p>Let’s open <strong class="source-inline">src/layouts/dashboard-layout.tsx</strong> and import the <span class="No-Break"><strong class="source-inline">Protected</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
import { Protected } from '@/features/auth';</pre>
<p>Then, in the JSX of the <strong class="source-inline">DashboardLayout</strong> component, let’s wrap everything with <strong class="source-inline">Protected</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
export const DashboardLayout = ({
  children,
}: DashboardLayoutProps) =&gt; {
  const user = useUser();
  return (
    &lt;Protected&gt;
      &lt;Box as="section" h="100vh" overflowY="auto"&gt;
        &lt;Navbar /&gt;
        &lt;Container as="main" maxW="container.lg" py="12"&gt;
          {children}
        &lt;/Container&gt;
        &lt;Box py="8" textAlign="center"&gt;
          &lt;Link
            href={`/organizations/${user.data?.
              organizationId}`}
          &gt;
            View Public Organization Page
          &lt;/Link&gt;
        &lt;/Box&gt;
      &lt;/Box&gt;
    &lt;/Protected&gt;
  );
};</pre>
<p>If you try to visit the <strong class="source-inline">http://localhost:3000/dashboard/jobs</strong> page, you will be redirected to the <span class="No-Break">login page.</span></p>
<p>Go ahead and try to log in<a id="_idIndexMarker353"/> with the existing credentials (email: user1@test.com; password: password). If everything is successful, you can access the dashboard with the data that belongs to the given <span class="No-Break">user organization.</span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Implementing notifications</h1>
<p>Whenever something happens<a id="_idIndexMarker354"/> in the application, such as a successful form submission or a failed API request, we want to notify our users <span class="No-Break">about it.</span></p>
<p>We will need to create a global store that will keep track of all notifications. We want it to be global because we want to show these notifications from anywhere in <span class="No-Break">the application.</span></p>
<p>For handling global states, we will be using Zustand, a state management library that is lightweight and very simple <span class="No-Break">to use.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Creating the store</h2>
<p>Let’s open the <strong class="source-inline">src/stores/notifications/notifications.ts</strong> file and import the dependencies<a id="_idIndexMarker355"/> we <span class="No-Break">will use:</span></p>
<pre class="source-code">
import { createStore, useStore } from 'zustand';
import { uid } from '@/utils/uid';</pre>
<p>Then, let’s declare the notification types for <span class="No-Break">the store:</span></p>
<pre class="source-code">
export type NotificationType =
  | 'info'
  | 'warning'
  | 'success'
  | 'error';
export type Notification = {
  id: string;
  type: NotificationType;
  title: string;
  duration?: number;
  message?: string;
};
export type NotificationsStore = {
  notifications: Notification[];
  showNotification: (
    notification: Omit&lt;Notification, 'id'&gt;
  ) =&gt; void;
  dismissNotification: (id: string) =&gt; void;
};</pre>
<p>The store will keep track of<a id="_idIndexMarker356"/> active notifications in an array. To show a notification, we need to call the <strong class="source-inline">showNotification</strong> method, and to dismiss it, we will <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">dismissNotification</strong></span><span class="No-Break">.</span></p>
<p>Let’s create <span class="No-Break">the store:</span></p>
<pre class="source-code">
export const notificationsStore =
  createStore&lt;NotificationsStore&gt;((set, get) =&gt; ({
    notifications: [],
    showNotification: (notification) =&gt; {
      const id = uid();
      set((state) =&gt; ({
        notifications: [
          ...state.notifications,
          { id, ...notification },
        ],
      }));
      if (notification.duration) {
        setTimeout(() =&gt; {
          get().dismissNotification(id);
        }, notification.duration);
      }
    },
    dismissNotification: (id) =&gt; {
      set((state) =&gt; ({
        notifications: state.notifications.filter(
          (notification) =&gt; notification.id !== id
        ),
      }));
    },
  }));</pre>
<p>To create the store, we use <strong class="source-inline">createStore</strong> from <strong class="source-inline">zustand/vanilla</strong> to make it more portable and testable. The function provides us with the <strong class="source-inline">set</strong> and <strong class="source-inline">get</strong> helpers, which allow us to modify and access the <span class="No-Break">store, respectively.</span></p>
<p>Since we created the store using the vanilla approach, we need to make it compatible with React. We do that<a id="_idIndexMarker357"/> by exposing the store with the <strong class="source-inline">useStore</strong> hook provided by Zustand <span class="No-Break">as follows:</span></p>
<pre class="source-code">
export const useNotifications = () =&gt;
  useStore(notificationsStore);</pre>
<p>And that’s the notification store. As you can see, it is very simple with <span class="No-Break">minimal boilerplate.</span></p>
<p>Any time we need to access the store inside React components or hooks, we can use the <strong class="source-inline">useNotifications</strong> hook. Alternatively, if we want to access the store from a plain JavaScript function outside React, we can use <span class="No-Break"><strong class="source-inline">notificationStore</strong></span><span class="No-Break"> directly.</span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Creating the UI</h2>
<p>Now that we have the notifications <a id="_idIndexMarker358"/>store, we need to build a UI to display those notifications <span class="No-Break">when active.</span></p>
<p>Let’s open the <strong class="source-inline">src/components/notifications/notifications.tsx</strong> file and import the <span class="No-Break">required dependencies:</span></p>
<pre class="source-code">
import {
  Flex,
  Box,
  CloseButton,
  Stack,
  Text,
} from '@chakra-ui/react';
import {
  Notification,
  NotificationType,
  useNotifications,
} from '@/stores/notifications';</pre>
<p>Then, let’s create <a id="_idIndexMarker359"/>the <strong class="source-inline">Notifications</strong> component, which will display <span class="No-Break">the notifications:</span></p>
<pre class="source-code">
export const Notifications = () =&gt; {
  const { notifications, dismissNotification } =
    useNotifications();
  if (notifications.length &lt; 1) return null;
  return (
    &lt;Box
      as="section"
      p="4"
      position="fixed"
      top="12"
      right="0"
      zIndex="1"
    &gt;
      &lt;Flex gap="4" direction="column-reverse"&gt;
        {notifications.map((notification) =&gt; (
          &lt;NotificationToast
            key={notification.id}
            notification={notification}
            onDismiss={dismissNotification}
          /&gt;
        ))}
      &lt;/Flex&gt;
    &lt;/Box&gt;
  );
};</pre>
<p>We are accessing the notifications via the <strong class="source-inline">useNotifications</strong> hook, which provides us with access to <span class="No-Break">the store.</span></p>
<p>As you can see, we are<a id="_idIndexMarker360"/> mapping through the active notifications. We render the <strong class="source-inline">NotificationToast</strong> component for each active notification and pass the notification object and the dismiss handler as props. Let’s implement it by describing the variants and <span class="No-Break">prop types:</span></p>
<pre class="source-code">
const notificationVariants: Record&lt;
  NotificationType,
  { color: string }
&gt; = {
  info: {
    color: 'primary',
  },
  success: {
    color: 'green',
  },
  warning: {
    color: 'orange',
  },
  error: {
    color: 'red',
  },
};
type NotificationToastProps = {
  notification: Omit&lt;Notification, 'duration'&gt;;
  onDismiss: (id: string) =&gt; void;
};</pre>
<p>Then, implement<a id="_idIndexMarker361"/> the <span class="No-Break"><strong class="source-inline">NotificationToast</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
const NotificationToast = ({
  notification,
  onDismiss,
}: NotificationToastProps) =&gt; {
  const { id, type, title, message } = notification;
  return (
    &lt;Box
      w={{ base: 'full', sm: 'md' }}
      boxShadow="md"
      bg="white"
      borderRadius="lg"
      {...notificationVariants[type]}
    &gt;
      &lt;Stack
        direction="row"
        p="4"
        spacing="3"
        justifyContent="space-between"
      &gt;
        &lt;Stack spacing="2.5"&gt;
          &lt;Stack spacing="1"&gt;
            &lt;Text fontSize="sm" fontWeight="medium"&gt;
              {title}
            &lt;/Text&gt;
            {notification.message &amp;&amp; (
              &lt;Text fontSize="sm" color="muted"&gt;
                {message}
              &lt;/Text&gt;
            )}
          &lt;/Stack&gt;
        &lt;/Stack&gt;
        &lt;CloseButton
          onClick={() =&gt; onDismiss(id)}
          transform="translateY(-6px)"
        /&gt;
      &lt;/Stack&gt;
    &lt;/Box&gt;
  );
};</pre>
<p>Now that we have the notifications store and the UI created, it is time to integrate them into <span class="No-Break">the application.</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Integrating and using notifications</h2>
<p>To integrate notifications into the <a id="_idIndexMarker362"/>application, let’s open the <strong class="source-inline">src/providers/app.tsx</strong> file and <a id="_idIndexMarker363"/>import the <span class="No-Break"><strong class="source-inline">Notifications</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
import { Notifications } from '@/components/notifications';</pre>
<p>Then, let’s render the component <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">AppProvider</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
export const AppProvider = ({
  children,
}: AppProviderProps) =&gt; {
  return (
    &lt;ChakraProvider theme={theme}&gt;
      &lt;GlobalStyle /&gt;
      &lt;Notifications /&gt;
      {/* rest of the code */}
    &lt;/ChakraProvider&gt;
  );
};</pre>
<p>Perfect! Now we are ready to start showing <span class="No-Break">some notifications.</span></p>
<p>As mentioned, we can use the store both in the React world and <span class="No-Break">outside it.</span></p>
<p>We will need to use it in a React component from the page for creating jobs. Any time we create a job successfully, we want to let the <span class="No-Break">user know.</span></p>
<p>Let’s open the <strong class="source-inline">src/pages/dashboard/jobs/create.tsx</strong> file and import the <span class="No-Break"><strong class="source-inline">useNotifications</strong></span><span class="No-Break"> hook:</span></p>
<pre class="source-code">
import { useNotifications } from '@/stores/notifications';</pre>
<p>Then, let’s initialize the<a id="_idIndexMarker364"/> hook inside the <strong class="source-inline">DashboardCreateJobPage</strong> <span class="No-Break">component body:</span></p>
<pre class="source-code">
const { showNotification } = useNotifications();</pre>
<p>Then, we can<a id="_idIndexMarker365"/> call <strong class="source-inline">showNotification</strong> in the <span class="No-Break"><strong class="source-inline">onSuccess</strong></span><span class="No-Break"> handler:</span></p>
<pre class="source-code">
const onSuccess = () =&gt; {
  showNotification({
    type: 'success',
    title: 'Success',
    duration: 5000,
    message: 'Job Created!',
  });
  router.push(`/dashboard/jobs`);
};</pre>
<p>We are showing a new success notification that will disappear after <span class="No-Break">5 seconds.</span></p>
<p>To see it in action, let’s open <a href="http://localhost:3000/dashboard/jobs/create">http://localhost:3000/dashboard/jobs/create</a> and submit the form. If the submission is successful, we should see something <span class="No-Break">like this:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 7.2 – Notifications in action " height="1647" src="image/B17297_07_02.jpg" width="1428"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Notifications in action</p>
<p>Perfect! Any time a job is created, the user will be notified <span class="No-Break">about it.</span></p>
<p>Another place that we can utilize notifications is in API error handling. Whenever an API error happens, we want to let the user know something <span class="No-Break">went wrong.</span></p>
<p>We can handle it on the API <a id="_idIndexMarker366"/>client level. Since Axios supports interceptors, and we already have them configured, we just need to modify the response <span class="No-Break">error interceptor.</span></p>
<p>Let’s open <strong class="source-inline">src/lib/api-client.ts</strong> and import <span class="No-Break">the store:</span></p>
<pre class="source-code">
import { notificationsStore } from '@/stores/notifications';</pre>
<p>Then, in the response<a id="_idIndexMarker367"/> error interceptor, let’s locate <span class="No-Break">the following:</span></p>
<pre class="source-code">
console.error(message);</pre>
<p>We’ll replace it with <span class="No-Break">the following:</span></p>
<pre class="source-code">
notificationsStore.getState().showNotification({
  type: 'error',
  title: 'Error',
  duration: 5000,
  message,
});</pre>
<p>To access values and methods on a vanilla Zustand store, we need to call the <span class="No-Break"><strong class="source-inline">getState</strong></span><span class="No-Break"> method.</span></p>
<p>Any time an error on the API happens, an error notification will be shown to <span class="No-Break">the user.</span></p>
<p>It’s worth mentioning that Chakra UI has its own toast notification system out of the box, which is very simple to use and would fit our needs, but we made our own to learn how to manage the global application state in a nice and <span class="No-Break">simple way.</span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Summary</h1>
<p>In this chapter, we learned how to handle authentication and manage the global state of <span class="No-Break">the application.</span></p>
<p>We started with an overview of the authentication system and how it works. Then, we implemented authentication features such as login, logout, and getting the authenticated user info. We also built the <strong class="source-inline">Protected</strong> component, which controls whether the user is allowed to see a page based on their <span class="No-Break">authentication status.</span></p>
<p>Then, we built a toast notification system where the user can trigger and display notifications from anywhere in the application. The main goal of building it was to introduce Zustand, a very simple and easy-to-use state management library for handling global <span class="No-Break">application state.</span></p>
<p>In the next chapter, we will learn how to approach testing the application with unit, integration, and <span class="No-Break">end-to-end tests.</span></p>
</div>
</div></body></html>