<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Component-Based Routing</h1>
                </header>
            
            <article>
                
<p>Routing is an integral part of today's frontend applications. In general, a router serves three main purposes:</p>
<ul>
<li>It makes your application navigable so that users can use their browser's back button and store and share links within the application</li>
<li>It offloads parts of the application composition so that the router takes responsibility for composing your application, based on routes and route parameters</li>
<li>It stores part of your application state within the URL of your browser</li>
</ul>
<p>The router that comes with Angular supports many different use-cases, and it comes with an easy-to-use API. It supports child routes that are similar to the Angular UI-Router nested states, Ember.js nested routes or child routers in the Durandal framework. Tied to the component tree, the router also makes use of its own tree structure to store states and to resolve requested URLs.</p>
<p>In this chapter, we will refactor our code to use the component-based router of Angular. We will look into the core elements of the router and how to use them to enable routing in our application.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Introducting to the Angular router</li>
<li>The router, container, and pure components</li>
<li>An overview of the refactoring needed to enable the router in our application</li>
<li>Creating a route configuration file and look into different route configuration possibilities</li>
<li>Using the<span> </span><kbd>RouterOutlet</kbd><span> </span>directive to create insertion points that are controlled by the router</li>
<li>Using the<span> </span><kbd>RouterLink</kbd><span> </span>directive and the router DSL to create navigation links</li>
<li>Using reactive router properties to obtain route parameters</li>
<li>Using both the <kbd>RouterActive</kbd> directive as well as the programmatic router API for reacting to activated route paths</li>
<li>Programmatically navigate using the router API</li>
<li>Creating a route guard for the project container</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to the Angular router</h1>
                </header>
            
            <article>
                
<p>The router in Angular is closely coupled to our component tree. The design of the Angular router is built on the assumption that a component tree is directly related to our URL structure. This is certainly true for most of the cases. If we have a component <strong>B</strong>, which is nested within a component <strong>A</strong>, the URL to represent our location would very likely be <kbd>/a/b</kbd>.</p>
<p>To specify the location in our template where we'd like to enable the router to instantiate components, we can use so-called <kbd>outlets</kbd>. Simply by including a <kbd>&lt;router-outlet&gt;</kbd> element, we can mark the location in our template, where the Angular router will instantiate components.</p>
<p>Based on some route configuration that we can provide in our main module, the router then decides which components need to be instantiated and placed into the corresponding router outlets. Routes can also be parameterized, and we can access these parameters within the instantiated components.</p>
<p>Using our component tree and the router configuration, we can build a hierarchical routing and decouple child routes from their parent routes. Such nested routes make it possible to compose our application layout on a meta level and reuse parent components for multiple child routes. By using the router we can add another layer of composition to our application. Take a look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7b7e177b-427c-4de1-b47c-ab9676a0e55f.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Router hierarchy established through a component tree and router outlet</div>
<p>Let's look at the elements of the router again in more detail:</p>
<ul>
<li><strong>Route configuration</strong>: The route configuration is done while importing the router into our application module. By configuring child routes, we can build decoupled nested routes easily.</li>
<li><strong>Router outlets</strong>: Outlets are the locations of components that will be managed by the router. Instantiated components that are based on the route configuration will be placed into these outlets.</li>
<li><strong>Router link</strong>: These are links built with a DSL style notation that enable the developer to build complex links through the routing tree.</li>
</ul>
<p>Within this chapter, we'll go through these different concepts of the Angular router and refactor our application to implement proper routing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composition using the router</h1>
                </header>
            
            <article>
                
<p>So far, we have achieved composition by including subcomponents in component templates directly. However, we'd now like to give the control to the router to compose our main application layout.</p>
<p>The following diagram provides an overview of the component architecture of our application, which we're going to enable for the router:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a4a7e86b-2a32-45c7-bf63-26d0fb34d6a3.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A component tree displaying routed container components (solid line) and components included via router outlets</div>
<p>After the changes that we're going to implement, the project container component is not directly included in our app component anymore. Instead, we use a router outlet in the template of our app component. This way, we can give control to the router and let it decide which component should be placed into the outlet. Currently, we only have the project component as a first-level route, but this will change in later chapters when we add more features to our application.</p>
<p>The project component will contain another router outlet, which enables us to do nested child routing. There, we'll be able to create child routings that enable us to switch between the different project detail views.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing with container components</h1>
                </header>
            
            <article>
                
<p>The composition that we've dealt with so far was purely based on instantiation via template inclusion. We used input and output properties to decouple and encapsulate components and followed nice reusable patterns.</p>
<p>Using the router, which instantiates components dynamically, we can't use template bindings on routed components anymore. While we previously relied on input and output properties to connect our components together, we're losing this possibility by using the router and we can't bind to inputs or outputs any longer.</p>
<p>Luckily, we already know about the concept of container components. Container components connect our state and data to our user interface components. They should not have any input or output properties and act as top-level components. They are by definition the perfect candidates for routed components:</p>
<ul>
<li>Since container components don't rely on input or output properties, they will work out-of-the-box when instantiated by the router</li>
<li>We can simply consider the router as a different source for state and pass down information from the URL state into our UI components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Router configuration</h1>
                </header>
            
            <article>
                
<p>Angular uses tree data structures to represent the router state. You can imagine that every navigation in your application activates a branch in this tree. Let's look at the following example.</p>
<p>We have an application that consists of four possible routes:</p>
<ul>
<li><kbd>/</kbd>: This is the root route of the application, which is handled in a component called <strong>A</strong>.</li>
<li><kbd>/b/:id</kbd>: This is the route where we can access the <kbd>b</kbd> detail view, which is handled in a component called <strong>B</strong>. In the URL, we can pass an <kbd>id</kbd> parameter (that is, <kbd>/b/100</kbd>).</li>
<li><kbd>/b/:id/c</kbd>: This is the route where the <kbd>b</kbd> detail view has another navigation possibility, which reveals more specific details that we call <kbd>c</kbd>. This is handled in a <strong>C</strong> component.</li>
<li><kbd>/b/:id/d</kbd>: This is the route where we can also navigate to a <kbd>d</kbd> view in the <kbd>b</kbd> detail view. This is handled by a component called <strong>D</strong>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/85ced9be-72d3-499c-988e-7493576774b9.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A route tree consisting of an active branch of route segments for the activated route /b/100/d</div>
<p class="mce-root">Let's assume that we activate a route in our example by navigating the URL, <kbd>/b/100/d</kbd>. In this case, we'd activate a route that reflects the state that is outlined in the preceding diagram. Note that the route segment <strong>B</strong> actually consists of two URL segments. The reason for this is that we've specified that our route <strong>B</strong> actually consists of the <kbd>b</kbd> identifier and an <kbd>:id</kbd> route parameter.</p>
<p>Using this tree data structure, we have a perfect abstraction to deal with navigation trees. We can compare trees, check whether certain segments exist in a tree, and extract parameters present on activated routes.</p>
<p>Within each routed component, we have the possibility to inject the activated route of that level. L<span>et's assume we'd want to access the <kbd>:id</kbd> parameter from the URL within component <strong>B</strong>. We can inject the</span> <kbd>ActivatedRoute</kbd> <span>into the constructor of our component and extract the route parameter from there by using the following code:</span></p>
<pre>@Component({<br/>  selector: 'mac-b',<br/>  templateUrl: './b.component.html'<br/>})<br/>export class BComponent {<br/>  <strong>constructor(route: ActivatedRoute) {</strong><br/><strong>    route.params.subscribe(params =&gt; console.log(params.id));</strong><br/><strong>  }</strong><br/>}</pre>
<p>The Angular router reuses component instances by default. This means that if the router is activating the same component again but with different parameters, Angular is not destroying the previous component instance. It re-uses the previous instance and provides the updated parameters to our component. That's the reason why the <kbd>params</kbd> property on the <kbd>ActivatedRoute</kbd> object is an observable stream. We can simply subscribe to this observable, which allows us to react on route parameter changes.</p>
<p>As you can see, the router API is quite flexible, and it allows us to inspect route activity on a very fine granularity. The tree structures that are used in the router make it possible to compare complex router states in our application without bothering about the underlying complexity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Back to the routes</h1>
                </header>
            
            <article>
                
<p>All right, now it's time to implement routing for our application! In the upcoming topics, we'll create the following routes for our application:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<thead>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Route path</strong></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>Description</strong></div>
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<p><kbd>/projects/:projectId</kbd></p>
</td>
<td>
<p>This route will activate the project container component in the outlet of our root application component. This consists of the <kbd>projects</kbd> URL segment as well as the <kbd>:projectId</kbd> URL segment to specify the project ID.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>/projects/:projectId/tasks</kbd></p>
</td>
<td>
<p>This route will activate the <kbd>TaskListContainer</kbd> component inside of our project component. While we're currently rendering the task list directly within the template of the project component, we will make use of an other router outlet instead.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>/projects/:projectId/comments</kbd></p>
</td>
<td>
<p><span>This route will activate the </span><kbd>ProjectCommentsContainer</kbd><span> component inside of our </span>project<span> component. The same router outlet within the project component is used to instantiate the project comments container component.</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">You can directly relate the preceding route configuration to the composition illustrated within the diagram of <span>the previous topic, </span><em>Composition using the router</em><span>.</span></p>
<p>To use the router of Angular, the first thing that we need to do is to create a route configuration. Let's create a new file on the path <kbd>src/app/routes.ts</kbd> and add our initial route configuration, using this code:</p>
<pre>import {Route} from '@angular/router';<br/>import {ProjectContainerComponent} from './container/project-container/project-container.component';<br/><br/>export const routes: Route[] = [{<br/>  path: 'projects/:projectId',<br/>  component: ProjectContainerComponent<br/>}, {<br/>  path: '',<br/>  pathMatch: 'full',<br/>  redirectTo: '/projects/1'<br/>}];</pre>
<p>For the moment we'll only configure the route for projects and add the child routes to project comments and tasks later.</p>
<p>The <kbd>path</kbd> property within our route configuration objects is used as a pattern to match against the URL in the browser. The router will observe URL changes in the browser and then try to match each path in our configuration against the new URL.</p>
<div class="packt_infobox">The Angular router will always match with a "first match wins" strategy. This means that you can have configuration scenarios where more than one configuration results in a match. However, only the first matching configuration within the list will be activated.</div>
<p>With the component property in our route configuration, we can tell Angular which component should be instantiated when a specific route is activated.</p>
<p>For our project route, we're also using a parameter segment to pass the ID of the project we want to display. </p>
<p>The second route in our configuration is a special route that will redirect users to the first project within our project list when they enter our app on the root URL (<kbd>http://localhost:4200/</kbd> in the case of our development server).</p>
<p>In redirect route configurations we can omit the <kbd>component</kbd> property but specify a <kbd>redirectTo</kbd> property to tell Angular that we'd like to redirect the user to a different URL. Within redirect routes, you always need to specify how you want to match the URL path. By default, Angular matches using a prefix match strategy. However, in many situations, you want to match the whole URL and not only a prefix. You can use the <kbd>pathMatch</kbd> property and set it to the value <kbd>'full'</kbd> for this purpose.</p>
<p>By specifying an empty path pattern, we can tell Angular to activate a route when there's an empty path segment within the browser's URL. However, when using the default prefix match strategy, this pattern will always result in a match. It's only when we set the <kbd>pathMatch</kbd> property to <kbd>'full'</kbd>, that we can cause a match when the user navigates to the root URL.</p>
<p>Okay, let's move on and include the router within our application. We can use the router configuration that we've just created to initialize the Angular router. Let's open up our main module located on the path <kbd>src/app/app.module.ts</kbd> and apply the following changes. Irrelevant code parts that did not change are hidden from the code excerpt and are marked with an ellipsis character. The effective changes within the code are marked in bold:</p>
<pre><span>…</span><br/><strong>import {RouterModule} from '@angular/router';</strong><br/><strong>import {routes} from './routes';</strong><br/><br/>@NgModule({<br/>  declarations: [<br/>    <span>…</span><br/>  ],<br/>  imports: [<br/>    BrowserModule,<br/>    HttpClientModule,<br/>    HttpClientInMemoryWebApiModule.forRoot(Database, {<br/>      delay: 0<br/>    })<strong>,</strong><br/>    <strong>RouterModule.forRoot(routes)</strong><br/>  ],<br/>  providers: [TaskService, UserService, ProjectService],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {<br/>}</pre>
<p>In the preceding code's changes to our main model, we're simply importing the routes configuration we've prepared and the Angular router module from <kbd>@angular/router</kbd>. By calling the module factory function <kbd>RouterModule.forRoot</kbd> we can pass our route configuration to the router and import the resulting router module into our application.</p>
<p>That was easy! You've successfully created your first route configuration and included the router in your application. When you preview your changes and reload your browser, you should already see the redirect configuration kicking in. Your browser URL should be relocated to <kbd>http://localhost:4200/projects/0</kbd>. However, we don't leverage the compositional features of the router yet and our project navigation needs to be changed too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composing projects using the router</h1>
                </header>
            
            <article>
                
<p>We've already prepared the route configuration for navigating our projects. The next step is to enable the router to handle the composition of projects correctly based on user navigation. Together, we'll execute the following three steps to achieve this:</p>
<ol>
<li>Using the <kbd>&lt;router-outlet&gt;</kbd> element within our root component to allow the router to place instantiated components.</li>
<li>Using the router link directives to make our project navigation work with the router.</li>
<li>Getting rid of the selected project state in our project service and instead rely on the URL state, which now includes the project ID of the navigated project. We can then refactor our project container component to make use of this route parameter.</li>
</ol>
<p>Let's start with the template of our root component. Currently, we're including the project container component within the template directly. Since we'd want to give control to the router to determine which component will be visible to the user, we need to change that and include a <kbd>&lt;router-outlet&gt;</kbd> in the template instead.</p>
<p>Let's open the template of our root component, which is located in <kbd>src/app/app.component.html</kbd>, and apply the following changes. Again, the ellipsis symbol indicates irrelevant code parts that remain the same:</p>
<pre><span>…</span><br/>&lt;main class="main"&gt;<br/>  <strong>&lt;router-outlet&gt;&lt;/router-outlet&gt;</strong><br/>&lt;/main&gt;</pre>
<p>We have removed the static inclusion of the project container component and added a router outlet element. This way the Angular router knows that it should instantiate activated components at this location within our template.</p>
<p>The next thing on our list is to use the router link directives in order to enable project navigation. Luckily we're already in the right place to perform this change. The project navigation is part of the root component template and we need to add the router link directives there. Within the template <kbd><span>src/app/app.component.html</span></kbd>, we perform the following changes:</p>
<pre>…<br/>&lt;mac-navigation-section title="Projects"&gt;<br/>  &lt;mac-navigation-item *ngFor="let project of projects | async"<br/>                       [navId]="project.id"<br/>                       [title]="project.title"<br/><strong>                       routerLinkActive="active"</strong><br/><strong>                       [routerLink]="['/projects', project.id]"</strong>&gt;<br/>  &lt;/mac-navigation-item&gt;<br/>&lt;/mac-navigation-section&gt;<br/>…</pre>
<p>The router link directive allows us to make any element act like a link, which activates a given route. By using the router DSL, we can specify a route as individual segment elements within an array. Since we're iterating over all projects to render navigation item components, we can use the project ID to construct links that activate our previously configured route path, <kbd>/projects/:projectId</kbd>.</p>
<p>The second change is to use the <kbd>routerLinkActive</kbd> directive on our navigation items. This directive is a simple helper that adds a CSS class to any element where a router link directive is present. If the configured router link URL matches the URL in the browser, then the CSS class will be added. You can specify the CSS class name within the <kbd>routerLinkActive</kbd> attribute value. This helps us to style the active navigation item so that the user always sees which project is currently navigated.</p>
<p>Great! You have successfully updated the navigation within our root component to use the Angular router directives. While previewing the changes, you can already see that the URL in your browser is updated when you're navigating between the different projects within the project navigation.</p>
<p>While so far we've been relying on our project service to tell us which project is currently selected, we're now leveraging the URL state of the router to store this information. Let's remove the <kbd>selectedProject</kbd> member and the call to the project service from our root component located in <kbd>src/app/app.component.ts</kbd>. We can also get rid of the <kbd>selectProject</kbd> method since the router is now in charge of selecting projects:</p>
<pre>…<br/>@Component({<br/>  selector: 'mac-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.css'],<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class AppComponent {<br/>  openTasksCount: Observable&lt;number&gt;;<br/>  user: Observable&lt;User&gt;;<br/>  projects: Observable&lt;Project[]&gt;;<br/><br/>  constructor(taskListService: TaskService,<br/>              userService: UserService,<br/>              private projectService: ProjectService) {<br/>    this.openTasksCount = taskListService.getTasks()<br/>      .pipe(<br/>        map((tasks: Task[]) =&gt; {<br/>          return tasks<br/>            .filter((task) =&gt; !task.done)<br/>            .length;<br/>        })<br/>      );<br/>    this.projects = projectService.getProjects();<br/>    this.user = userService.getCurrentUser();<br/>  }<br/>}<br/><br/></pre>
<p>There's still one step missing to complete the switch to the router for our project composition. If you have been previewing the changes we've performed so far, you've noticed that we're already changing the URL and that the project navigation items get activated correctly. However, we always see the first project title and description within the project component. <span>The project container component is currently still relying on the project service to obtain the selected project. We need to change that so that we use the state from the router.</span></p>
<p>Let's implement the changes in the container component <kbd>src/app/container/project-container/project-container.component.ts</kbd> in order to obtain the project ID parameter from the activated route and display the correct project after navigation:</p>
<pre>…<br/><strong>import {ActivatedRoute} from '@angular/router';</strong><br/><strong>import {combineLatest} from 'rxjs';</strong><br/><strong>import {map} from 'rxjs/operators';</strong><br/><br/>@Component({<br/>  selector: 'mac-project-container',<br/>  templateUrl: './project-container.component.html',<br/>  styleUrls: ['./project-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectContainerComponent {<br/>  …<br/><br/>  constructor(private projectService: ProjectService<strong>,</strong><br/><strong>              private route: ActivatedRoute</strong>) {<br/>    <strong>this.selectedProject = combineLatest(</strong><br/><strong>      projectService.getProjects(),</strong><br/><strong>      route.params</strong><br/><strong>    ).pipe(</strong><br/><strong>      map(([projects, routeParams]) =&gt;</strong><br/><strong>        projects.find((project) =&gt; project.id === +routeParams.projectId)</strong><br/><strong>      )</strong><br/><strong>    );</strong><br/>  }<br/><br/>  …<br/>}</pre>
<p>We're still using a member <kbd>selectedProject</kbd> which is of type <kbd>Observable&lt;Project&gt;</kbd> to represent the currently selected project. However, we're no longer obtaining this observable from the project service directly. Instead, we're using the <kbd>combineLatest</kbd> RxJS helper to combine two observable streams together in order to produce an output stream that emits the selected project.</p>
<p>We are combining the observable route parameters from the activated route with the project list from our project service. We can then use the <kbd>map</kbd> operator to find the right project within the project list using the ID obtained from the route parameters. The resulting observable stream will emit the selected project and re-emit whenever the route parameter or the project list changes.</p>
<p>Now, go ahead and preview the changes in your browser again. You should now see that the router navigation using the project navigation on the left should also cause an update on our project component. It should always display the correct project information depending on what project ID is present within the browser's URL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Child routes for project details</h1>
                </header>
            
            <article>
                
<p>Within this section, we're going to use the router for navigating the detail views on our projects. We currently have two detail views on our projects:</p>
<ul>
<li>Project tasks view using the task list container component</li>
<li>Project comments view using the project comments container component</li>
</ul>
<p>We also need to make sure that we're able to activate the sub-views using our tabbed interface on projects. Our current solution is to store the activated tab within the project container component. Based on that, we're deciding which detail view to show within the template of our project component. There, we're using a simple <kbd>ngIf</kbd> directive in order to determine which of the two child container components to show.</p>
<p>Let's start with our refactoring by including child route configurations for both our detail views. Open up the router configuration file on the path <kbd>src/app/routes.ts</kbd> and perform the following changes:</p>
<pre>import {Route} from '@angular/router';<br/>import {ProjectContainerComponent} from './container/project-container/project-container.component';<br/>import {TaskListContainerComponent} from './container/task-list-container/task-list-container.component';<br/>import {ProjectCommentsContainerComponent} from './container/project-comments-container/project-comments-container.component';<br/><br/>export const routes: Route[] = [{<br/>  path: 'projects/:projectId',<br/>  component: ProjectContainerComponent<strong>,</strong><br/><strong>  children: [{</strong><br/><strong>    path: 'tasks',</strong><br/><strong>    component: TaskListContainerComponent</strong><br/><strong>  }, {</strong><br/><strong>    path: 'comments',</strong><br/><strong>    component: ProjectCommentsContainerComponent</strong><br/><strong>  }, {</strong><br/><strong>    path: '**',</strong><br/><strong>    redirectTo: 'tasks'</strong><br/><strong>  }]</strong><br/>}, {<br/>  path: '',<br/>  pathMatch: 'full',<br/>  redirectTo: '/projects/1'<br/>}];</pre>
<p>Using the <kbd>children</kbd> property on route configurations, we can configure nested routes. It allows us to tell Angular that somewhere below the routed parent component, there will be another router outlet that can be used to instantiate components activated by child routes.</p>
<p>Let's say a user is navigating to the path <kbd>/projects/1/tasks</kbd> with our new configuration. This would activate a path in our route configuration. The project container component is activated and instantiated into the router outlet within our root component. Additionally, the route parameter <kbd>:projectId</kbd> is set to the value <kbd>1</kbd>. Since we've configured a matching child route with the path <kbd>tasks</kbd>, this child route will also be activated. The Angular router is now searching for a nested router outlet below the project container component so that it can instantiate the task list container component there.</p>
<p>Let's take a look at the diagram in the previous section, <em>Composition using the router</em> of this chapter again. This figure reflects our end goal in terms of composition using router outlets and instantiated components and illustrates where we need to add our nested router outlet element.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/38bed4ac-6ebe-4c1d-87a0-1c3e536ad730.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">A component tree displaying routed container components (solid line) and components included via router outlets</div>
<p>Let's now apply some changes to our project components in order to make our child routes work. There are three changes involved:</p>
<ol>
<li>Remove the static inclusion of the task view and the comments view within the project component and use a nested router outlet instead.</li>
<li>Update the project container component to obtain the active tab from the child route name. Again, we're using the router to store the state for which tab is currently active.</li>
<li>Update both the project comments container components as well as the task list container component to obtain the selected project from the router instead of the project service.</li>
</ol>
<p>Let's start with the first step, which is quite a simple one. Let's open up the file <kbd>src/app/project/project/project.component.ts</kbd> and replace the static inclusion of the detail views with a router outlet:</p>
<pre>&lt;header class="header"&gt;<br/>  &lt;h2 class="title"&gt;<br/>    &lt;mac-editor [content]="project.title"<br/>                [showControls]="true"<br/>                (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;<br/>  &lt;/h2&gt;<br/>  &lt;mac-editor [content]="project.description"<br/>              [showControls]="true"<br/>              (outSaveEdit)="updateDescription($event)"&gt;&lt;/mac-editor&gt;<br/>&lt;/header&gt;<br/>&lt;mac-tabs [tabs]="tabs"<br/>          [activeTab]="activeTab"<br/>          (outActivateTab)="activateTab($event)"&gt;<br/>&lt;/mac-tabs&gt;<br/><strong>&lt;router-outlet&gt;&lt;/router-outlet&gt;</strong></pre>
<p>Okay, now the router is in control of instantiating the right project details component within our nested router outlet.</p>
<p>The second change we're going to apply is concerning the tabbed interface component within our project component. Since our tabbed component is a pure component, it relies on the project container component to provide the active tab. Also, when we activate a tab, the project container component is implementing what should happen on an activation. Until now, the state for which of the tabs is currently active has been stored within the project container component directly. Now, we want to change this behaviour so that we use the router to store this state. An activation of a tab should then also trigger a route change. Let's open the file <kbd>src/app/container/project-container/project-container.component.ts</kbd> and implement the following changes:</p>
<pre>…<br/>import {ActivatedRoute<strong>, Router</strong>} from '@angular/router';<br/>import {combineLatest} from 'rxjs';<br/>import {map} from 'rxjs/operators';<br/><br/>@Component({<br/>  selector: 'mac-project-container',<br/>  templateUrl: './project-container.component.html',<br/>  styleUrls: ['./project-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectContainerComponent {<br/>  selectedProject: Observable&lt;Project&gt;;<br/>  tabs: Tab[] = [<br/>    {id: 'tasks', title: 'Tasks'},<br/>    {id: 'comments', title: 'Comments'},<br/>    {id: 'activities', title: 'Activities'}<br/>  ];<br/>  <strong>activeTab: Observable&lt;Tab&gt;;</strong><br/><br/>  constructor(private projectService: ProjectService,<br/>              private route: ActivatedRoute<strong>,</strong><br/><strong>              private router: Router</strong>) {<br/>    this.selectedProject = combineLatest(<br/>      projectService.getProjects(),<br/>      route.params<br/>    ).pipe(<br/>      map(([projects, routeParams]) =&gt;<br/>        projects.find((project) =&gt; project.id === +routeParams.projectId)<br/>      )<br/>    );<br/><br/><strong>    this.activeTab = combineLatest(</strong><br/><strong>      this.selectedProject,</strong><br/><strong>      route.url</strong><br/><strong>    ).pipe(</strong><br/><strong>      map(([project]) =&gt;</strong><br/><strong>        this.tabs.find((tab) =&gt;</strong><br/><strong>          router.isActive(</strong><br/><strong>            `/projects/${project.id}/${tab.id}`,</strong><br/><strong>            false</strong><br/><strong>          )</strong><br/><strong>        )</strong><br/><strong>      )</strong><br/><strong>    );</strong><br/>  }<br/><br/>  …<br/>}</pre>
<p>The tabs component is a pure component and this time we don't want to use the router link directives in order to make our project detail tabs navigable. Keeping things pure and not polluting your UI components with context-specific router link configurations can pay off when scaling your application. Instead, we want to use the router programmatically within our container component to cause navigation. We'd also like to have a way of telling which tab should be currently active according to the router state.</p>
<p>Within the preceding code changes, we're injecting the router instance within our component constructor. Additionally, we've changed the <kbd>activeTab</kbd> property to be of type <kbd>Observable&lt;Tab&gt;</kbd>. Now we need a way to react on router URL changes and figure out what of the tabs is active after the URL change. The observable behind <kbd>router.url</kbd> is exactly what we're looking for to start our reactive pipeline. On every navigation that causes the router to change the browser URL, this observable will emit an item. However, we're also going to need a reference to the currently selected project to figure out which tab is currently activated. For this purpose, we're combining the URL changes observables together with our <kbd>selectedProject</kbd> observable. Now, we have a stream that emits on URL changes and on changes of the selected project. Within a <kbd>map</kbd> operator, we're then using the <kbd>router.isActive</kbd> method in order to figure out which of the tabs is currently active. We can pass a URL string to the <kbd>isActive</kbd> method, and it tells us if that URL string is currently active within the router. We use the project ID of the selected project as well as the IDs of the individual tabs to construct this test URL string. At the end of our operator chain, the observable spits out the active tab object or null if none of the tabs is active.</p>
<p><span>Okay, we're almost there! The last change we need to apply to make our tabs work again is to refactor the</span><span> </span><kbd>activateTab</kbd><span> </span> <span>method within the project container component class. Instead of updating a local state to represent the active tab, we now need to trigger a router navigation programmatically by using this code:</span></p>
<pre>…<br/>import {map<strong>, take</strong>} from 'rxjs/operators';<br/><br/>@Component({<br/>  selector: 'mac-project-container',<br/>  templateUrl: './project-container.component.html',<br/>  styleUrls: ['./project-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectContainerComponent {<br/>  …<br/>  <br/>  activateTab(tab: Tab) {<br/>   <strong> this.selectedProject</strong><br/><strong>      .pipe(take(1))</strong><br/><strong>      .subscribe((project: Project) =&gt; {</strong><br/><strong>        this.router.navigate([</strong><br/><strong>          '/projects',</strong><br/><strong>          project.id,</strong><br/><strong>          tab.id</strong><br/><strong>        ]);</strong><br/><strong>      });</strong><br/>  }<br/><br/>  …<br/>}</pre>
<p>In order to navigate to a new URL programmatically, we can use the method <kbd>router.navigate</kbd> and use the router DSL to construct the URL segments of the desired route. Besides the ID of the activated tab, we also need the ID of the selected project to construct the target URL. Because the selected project is represented as an observable stream, we can transform using the take operator and subscribe to the output stream in order to get hold of the currently selected project object. Now, within the subscription, we have everything at hand to execute the programmatic navigation.</p>
<p>Since we're now using an observable to represent the active tab, we need to modify our template on the path <kbd>src/app/container/project-container/project-container.component.html</kbd> and use the async pipe to subscribe to the observable as follows:</p>
<pre>&lt;mac-project [project]="selectedProject | async"<br/>             [tabs]="tabs"<br/>             [activeTab]="<strong>activeTab | async</strong>"<br/>             (outActivateTab)="activateTab($event)"<br/>             (outUpdateProject)="updateProject($event)"&gt;<br/>&lt;/mac-project&gt;</pre>
<p>You've successfully refactored our tabs to work with the router and our configured child routes. If you preview your changes within the browser, you should be able to navigate between tabs again, and the browser URL should be updated while doing so. You can also try to reload your browser with a specific URL that directly navigates to a specific tab—the same scenario that would apply to a user using a bookmark to a specific tab on a project. Try, for example, to navigate to <kbd>http://localhost:4200/projects/2/comments</kbd> and see whether you're ending up where you'd expect to.</p>
<p>The last of the three steps to complete our child route refactoring is still outstanding. Currently, both of the detail views are still relying on the project service to determine the selected project. We need to change both of them to use the router instead and extract the selected project ID from the route, similarly as we do within the project container component already. Let's start with the task list container component within the file <kbd>src/app/container/task-list-container/task-list-container.component.ts</kbd>:</p>
<pre>…<br/><strong>import {combineLatest} from 'rxjs';<br/>import {ActivatedRoute} from '@angular/router';</strong><br/><br/>@Component({<br/>  selector: 'mac-task-list-container',<br/>  templateUrl: './task-list-container.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListContainerComponent {<br/>  …<br/><br/>  constructor(private taskService: TaskService,<br/>              private projectService: ProjectService<strong>,</strong><br/><strong>              private route: ActivatedRoute</strong>) {<br/>    <strong>this.selectedProject = combineLatest(</strong><br/><strong>      projectService.getProjects(),</strong><br/><strong>      route.parent.params</strong><br/><strong>    ).pipe(</strong><br/><strong>      map(([projects, routeParams]) =&gt;</strong><br/><strong>        projects.find((project) =&gt; project.id === +routeParams.projectId)</strong><br/><strong>      )</strong><br/><strong>    );</strong><br/><br/>    …<br/>  }<br/><br/> …<br/>}</pre>
<p style="font-size: 16px">Instead of obtaining the selected project observable from the project service, we're combining the project list observable, together with the route parameters, to find the selected project. This should look very familiar since we're using almost the same code as within the project container component. The only difference is that we need to access the parent route first. By calling <kbd>route.parent.params</kbd>, we can access the parent route and obtain the params from there. This is required since we're using nested routes and the task list container is a sub-view of the project container where the <kbd>:projectId</kbd> parameter is available.</p>
<p>Let's apply the same change to our project comments container component. Open up the file <kbd>src/app/container/project-comments-container/project-comments-container.component.ts</kbd> and update the code with the following changes:</p>
<pre>…<br/><strong>import {combineLatest} from 'rxjs';</strong><br/><strong>import {ActivatedRoute} from '@angular/router';</strong><br/><br/>@Component({<br/>  selector: 'mac-project-comments-container',<br/>  templateUrl: './project-comments-container.component.html',<br/>  styleUrls: ['./project-comments-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectCommentsContainerComponent {<br/>  …<br/><br/>  constructor(private projectService: ProjectService,<br/>              private userService: UserService<strong>,</strong><br/><strong>              private route: ActivatedRoute</strong>) {<br/>    this.user = userService.getCurrentUser();<br/>    <strong>this.selectedProject = combineLatest(</strong><br/><strong>      projectService.getProjects(),</strong><br/><strong>      route.parent.params</strong><br/><strong>    ).pipe(</strong><br/><strong>      map(([projects, routeParams]) =&gt;</strong><br/><strong>        projects.find((project) =&gt; project.id === +routeParams.projectId)</strong><br/><strong>      )</strong><br/><strong>    );</strong><br/>    this.projectComments = this.selectedProject<br/>      .pipe(<br/>        map((project) =&gt; project.comments)<br/>      );<br/>  }<br/>  …<br/><br/>}</pre>
<p><span>Congratulations! We've successfully implemented all changes necessary to provide a fully navigable project structure including child routes. We are no longer relying on the project service to store the selected project within our application. As the last step, we can remove the unnecessary code from the project service, since none of our components rely on it anymore. Let's open up the file <kbd>src/app/project/project.service.ts</kbd> and remove all code related to selecting projects:</span></p>
<pre>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {BehaviorSubject} from 'rxjs';<br/>import {Project} from '../model';<br/><br/>@Injectable()<br/>export class ProjectService {<br/>  private projects = new BehaviorSubject&lt;Project[]&gt;([]);<br/><br/>  constructor(private http: HttpClient) {<br/>    this.loadProjects();<br/>  }<br/><br/>  private loadProjects() {<br/>    this.http.get&lt;Project[]&gt;('/api/projects')<br/>      .subscribe((projects) =&gt; this.projects.next(projects));<br/>  }<br/><br/>  getProjects() {<br/>    return this.projects.asObservable();<br/>  }<br/><br/>  updateProject(project: Project) {<br/>    this.http.post(`/api/projects/${project.id}`, project)<br/>      .subscribe(() =&gt; this.loadProjects());<br/>  }<br/>}</pre>
<p>Nothing feels better than removing abandoned code, right? It's like a reward for our hard work refactoring and cleaning up our code. Let's preview our changes within the browser and test our newly added router features. You should now be able to use the application the same way as before our refactoring. However, we now store the selected project and the active project detail tab within the browser's URL. Navigate across the different views and also try to use the back and forward buttons within your browser. It just feels so much better to be able to navigate like this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Guarding our projects</h1>
                </header>
            
            <article>
                
<p>Sometimes, it's a good idea to prevent certain routes from being navigated, and to provide a fallback navigation for those scenarios. This is especially true when your routes include dynamic route parameters, which can change over time, meaning users may still have outdated bookmarks to those old URLs.</p>
<p>Guards are the perfect helper for preventing these navigation errors. While guards help you to prevent access to certain routes and redirect accordingly, you should never rely on them to provide any kind of security for your application. Security always needs to come from a server. Using guards, you can just provide the necessary usability of a user accessing an area where he would be confronted with errors, maybe because of missing permissions to call a backend web service, or simply because a navigated detail view by an item ID no longer exists.</p>
<p>Within this section, we're going to create a guard to prevent navigation to a non-existing project. We haven't used the Angular CLI for a while now. Let's give it a long deserved spin and use it to create the stub of our project container guard:</p>
<pre><strong>ng generate guard --spec=false --module=app guards/project-container</strong></pre>
<p>This will generate a stub guard and include it into our main app module in the provider section. Let's open up the guard file located at <kbd>src/app/guards/project-container.guard.ts</kbd> and change its content to the following:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {CanActivate, ActivatedRouteSnapshot, Router} from '@angular/router';<br/>import {ProjectService} from '../project/project.service';<br/>import {map} from 'rxjs/operators';<br/><br/>@Injectable()<br/>export class ProjectContainerGuard implements CanActivate {<br/>  constructor(private projectService: ProjectService,<br/>              private router: Router) {}<br/><br/>  canActivate(next: ActivatedRouteSnapshot) {<br/>    return this.projectService.getProjects()<br/>      .pipe(<br/>        map(projects =&gt; {<br/>          const projectExists = !!projects.find(project =&gt; project.id === +next.params.projectId);<br/>          if (!projectExists) {<br/>            this.router.navigate(['/projects', projects[0].id]);<br/>          }<br/>          return projectExists;<br/>        })<br/>      );<br/>  }<br/>}</pre>
<p>Within this simple project guard, we're implementing the <kbd>CanActivate</kbd> interface, which comes from the router module. By implementing this interface we can write a guard that allows us to control if a user can navigate a certain route. As the first argument of the <kbd>canActivate</kbd> method, we're receiving the activated route snapshot object of the target route. The method should return an observable of type <kbd>Observable&lt;boolean&gt;</kbd>. If we'd like to prevent the navigation, we can emit false through the observable stream that is returned.</p>
<p>In our case, we're using the project list observable obtained from the project service as an input observable. We then map the observable in order to determine if the project with the ID, extracted from the target route snapshot params, is existing. We're using the variable <kbd>projectExists</kbd> to store this information, which we return as the result of our mapping function. Additionally, if the project with the navigated ID does not exist, we're redirecting to the first project in the project list. We can do that by using the <kbd>router.navigate</kbd> method.</p>
<p>Now, the only thing left to activate our guard is to include it in our router configuration. Let's open the file <kbd>src/app/routes.ts</kbd> and add the following changes:</p>
<pre>…<br/><strong>import {ProjectContainerGuard} from './guards/project-container.guard';</strong><br/><br/>export const routes: Route[] = [{<br/>  path: 'projects/:projectId',<br/>  component: ProjectContainerComponent,<br/>  <strong>canActivate: [ProjectContainerGuard],</strong><br/>  children: [{<br/>    path: 'tasks',<br/>    component: TaskListContainerComponent<br/>  }, {<br/>    path: 'comments',<br/>    component: ProjectCommentsContainerComponent<br/>  }, {<br/>    path: '**',<br/>    redirectTo: 'tasks'<br/>  }]<br/>}, {<br/>  path: '',<br/>  pathMatch: 'full',<br/>  redirectTo: '/projects/1'<br/>}];</pre>
<p>Every route configuration supports a <kbd>canActivate</kbd> property, which can be set to a list of guards that implement the <kbd>CanActivate</kbd> interface. All we need to do is add our guard to the project route configuration.</p>
<p>That's it! We have guarded our project container component and it's no longer possible to cause errors because of navigations to projects that don't exist. You can preview your changes in the browser and try to navigate to a non-existing project. Just try to navigate to <kbd>http://localhost:4200/projects/100</kbd> for example. You should be redirected to the first project overview.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the basic concepts of the router in Angular. We looked at how we can use the existing component tree to configure child routes in nested-router scenarios. We have learned about the router outlet element and the basic router link directive.</p>
<p>We have refactored our existing navigation elements, such as the project navigation and the tabbed interface on the project view. We've used router links and programmatic navigation to fulfil different navigation scenarios.</p>
<p>We looked into some common route configuration specifics and the basics of the router link DSL. We've also learned about route matching patterns as well as parameter placeholders and how to access these parameters in activated routes.</p>
<p>Last but not least, we've created a simple guard which prevents our users from accessing project details with invalid project IDs.</p>
<p>In the next chapter, we will learn about SVG and how to use this web standard in order to draw graphics in our Angular applications. We will visualize an activity log of our application activities using SVG and see how Angular makes this technology even greater by enabling composability.</p>


            </article>

            
        </section>
    </body></html>