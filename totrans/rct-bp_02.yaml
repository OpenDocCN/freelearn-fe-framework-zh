- en: Chapter 2. Creating a Web Shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selling merchandise online has been a staple of the Web since it was commercialized
    in the 1990s. In this chapter, we will explore how we can leverage the power of
    ReactJS to create our very own web shop.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by creating a number of different components, such as a home page,
    a products page, a checkout and receipt page, and we'll fetch products from data
    stores via a concept called **Flux**.
  prefs: []
  type: TYPE_NORMAL
- en: When we're finished, you'll have a complete blueprint that you can expand upon
    and apply your own styling to.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating any kind of website, it's often beneficial to create a mock-up
    of how you want the page to look before proceeding to write any code. This makes
    it easier to visualize how you want your site to look and what components you
    need to create. You can use any kind of mockup tool to create this, even a sheet
    of paper will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at our website mock-up, we can see that we need to create the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: A layout component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A home page component for the front page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A menu component with a brand name and the most important links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A company information component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product list component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An item component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A checkout component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A receipt component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just the view components. In addition to these, we'll need to create
    data stores and actions and subcomponents for the main ones. For instance, for
    the product component on the front page, you will need a picture element, description,
    price, and a buy button, and any time you need a list or table, you need to make
    another subcomponent, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create these as we go along. Let''s take a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the components](img/B04943_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding mock-up shows the product list page as seen on a desktop and as
    viewed on a smart phone. It's worthwhile to sketch up mock-ups for all the platforms
    you intend to support. It's also a good idea to make sketches of all the different
    pages and states they can have.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be using the code from [Chapter 1](ch01.html "Chapter 1. Diving Headfirst
    into ReactJS"), *Diving Headfirst into ReactJS*, as the basis for this web shop.
    Make a duplicate of the code from the first chapter and make sure that it's running
    before you continue making changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Copy the code to another directory and run it by executing `node server.js`.
    It should start up a server and automatically open a browser window for you.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we need a basic layout for our webshop. There are many options
    available for you. For instance, you can choose any one of the many open source
    CSS frameworks, such as **Bootstrap** or **Foundation**, or you can strike your
    own path and build up a basic grid and bring in elements as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity's sake, we'll be going with Bootstrap for this webshop. It's
    a hugely popular framework that is easy to work with and has excellent support
    for React.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted, we''ll be using the scaffolding from [Chapter 1](ch01.html "Chapter 1. Diving
    Headfirst into ReactJS"), *Diving Headfirst into ReactJS*. In addition, we''re
    going to need a few more packages, most notably: `react-bootstrap`, `react-router`,
    `lodash`, `Reflux`, `superagent` and `react-router-bootstrap`. For simplicities
    sake, replace the dependencies section in your `package.json` with these values
    and run `npm install` in your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `--save-dev` option saves the dependencies in your `package.json` file under
    the `devDependencies` key as shown in the preceding code. On a production build,
    these dependencies will not be installed, and this makes the deployment go faster.
    We'll take a look at how to create a production build in [Chapter 8](ch08.html
    "Chapter 8. Deploying Your App to the Cloud"), *Deploying Your App to the Cloud*.
    If you rather want to put these packages in your regular dependencies section,
    use `--save` instead of `--save-dev` and in your `package.json` the preceding
    packages will reside in your `dependencies` section rather than in your `devDependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need the Bootstrap, and we''ll use a **Content Delivery Network** (**CDN**)
    to fetch it. Add the following code snippet to the `<head>` section of your `index.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether you want to support the older version of Internet Explorer is your
    choice, but if you do, you''re going to need to add this part to the `<head>`
    section of your `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This adds a **polyfill** to your code base. A polyfill adds support for HTML5
    features that older browsers don't support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to use the modern features of Internet Explorer, so let''s add
    the following `meta` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This setting tells the browser to render according to the most recent version
    of the standard. This tag was introduced in *IE8*, so this tag won't matter if
    your users are using *IE7* or lower. Additional settings are `IE=5` to `IE=11`
    and `IE=EmulateIE7` to `IE=EmulateIE11`. Using the emulate instructions informs
    Internet Explorer how to render in the standards and quirks mode. For instance,
    `EmulateIE9` renders the page as *IE9* in the standards mode and as *IE5* in the
    quirks mode.
  prefs: []
  type: TYPE_NORMAL
- en: Which settings you choose is dependent on your target platform, and unless you
    have a very specific IE version in mind, going with `IE=edge` is probably the
    safest option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the smart phones to show the page in proper scale, we need to
    add this `meta` tag as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This notifies the smart phone browser that you want to display the page in full
    width with a scale of 1\. You can play with the scale and width, but in most cases,
    this setting is what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your own CSS code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have a CSS file in the public folder. We''re going to use a very
    basic CSS layout and rely on Bootstrap for the most part. Edit `public/app.css`
    and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The padding is there simply to make sure that the content falls inside the menu
    (that we'll be creating in the upcoming section called *The menu and footer*).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a route handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open the `app.jsx` file, remove everything from the initial scaffold,
    and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In our imports section, we're now adding `react-router` and a new file called
    `routes.jsx`. You'll note that we're fetching `Route` from react-router by encapsulating
    it in braces. This is called **destructuring** and is identical to fetching it
    with `var Route = require("react-router").Route`, which is quite easy to type.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we do is let the **router** control our app by applying `Router.run`,
    provide it with the contents of our new `routes` file, then mount it on the `<div>`
    tag with the `id` container as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, to run this, you need to create a file called `router.jsx`. It should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty straightforward as you can see, since we're not creating any routes
    just yet. Again, we're importing `react`, `react-router`, and `route`, and also
    a new file called `layout.jsx`, which will be our primary route handler.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we're exporting the contents of the Routes as Routes. This is a
    necessary step because this is what allows you to import it later in your other
    scripts. You could simplify this by putting `module.exports =` instead of `const
    Routes =` in the module declaration and then skip the last line. It's your choice,
    but I think it's a good practice to structure your code by putting the imports
    first, the code in the middle, and then what the module exports last.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what should go into the `layout.jsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This page is completely empty. The only thing we've added for now is the route
    handler. This is where the contents of your route changes will go. Everything
    you put around it will not be changed when you switch to a new route, so this
    is where you place static elements, such as headers, footers, and asides.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have put all of this together, you''ve got all the pieces you need
    to start building your webshop. You have now implemented the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The scaffold from [Chapter 1](ch01.html "Chapter 1. Diving Headfirst into ReactJS"),
    *Diving Headfirst into ReactJS*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap for ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to handle route changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A polyfill for older browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't be discouraged when your web browser shows a blank web page when you run
    this code. This is the expected output at this point.
  prefs: []
  type: TYPE_NORMAL
- en: The menu and footer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time to start working on the visible menu components. Let's begin with
    the menu and the footer. Looking at our mock-up, we see that we want to build
    a full-width section with the brand name of the shop and the menu links, and at
    the bottom, we want a single centered line of text with a copyright notice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do this by adding the following import to our `import` section in the
    `layout.jsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `render` function with this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a directory called `components` and place a file called `menu.jsx`
    in there. Add the following code inside the `menu.jsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These imports pull in `Nav`, `NavItem`, `Navbar`, `Button`, and `LinkContainer`
    via destructuring, as mentioned in [Chapter 1](ch01.html "Chapter 1. Diving Headfirst
    into ReactJS"), *Diving Headfirst into ReactJS*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `Navbar` instance with a linked brandname. If you want an image
    instead of a text brand, you can insert a JSX node instead of a text string, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fixedTop` option creates a fixed `Navbar` instance that sticks to the
    top of your screen. Replace it with `staticTop` if you want a floating Navbar
    instance instead. You can also add `inverse` if you want a black Navbar instance
    instead of a grey one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We add three navigation items in our navigation bar, like in our mock-up. We
    also provide a **right** keyword so that the items in your Navbar instance are
    aligned to the right. These links redirect to those pages that we haven''t made
    yet, so we will have to make these next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for the menu. We also need to add the footer, so go ahead and add
    a file called `footer.jsx` in the `components` folder and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating the pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a subfolder called `pages` and add the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pages/products.jsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pages/company.jsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pages/checkout.jsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pages/receipt.jsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pages/item.jsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pages/home.jsx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add the links we just created in our routes. Open the `routes.jsx`
    file and add the following content to the imports section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `<Route handler={Layout} path="/"></Route>` code block with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've added the `receipt` page to our file structure and the routes, but it
    will not be visible in the menu bar because you should only be redirected to the
    `receipt` page after you've checked out an order.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app now, you'll see a menu bar on top of the screen, which you
    can click on. You'll note that when you click on any of the menu options, the
    app will route to the chosen page. You'll also note that the chosen route will
    be highlighted in the menu bar, which makes it easy to know where you are, without
    looking at the route in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: When you open the app in the responsive mode in your web browser or open the
    app on a smartphone, you'll note that the menu collapses and that a **Hamburger**
    button appears instead of the menu links. When you click on this button, the menu
    expands and presents the links in a drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database of products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your shops need products, so we're going to provide a small set of items for
    our web shop.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of data is usually stored in some kind of database. The database can
    be self provided either locally or remotely or you can use any of the many cloud-based
    database services. Traditionally, you would use a database based on **SQL** (**Structured
    Query Language**), but nowadays, it's common to go for the **NoSQL** document-based
    approach. This is what we'll do for our webshop, and we'll simply use a flat file
    for the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file and call it `products.json`, save it in the `public` folder,
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This file is equivalent to what you would find if you inserted a few products
    in a NoSQL database, such as **MongoDB**. The syntax is **JSON** (**JavaScript
    Object Notation**), an open format that transports data as attribute-value pairs.
    It's simple and language-independent, and just by looking at the preceding structure,
    you can easily understand its data structure and contents.
  prefs: []
  type: TYPE_NORMAL
- en: The fields should be self-explanatory, but let's walk through them. There are
    two groups of products, one for the main range and one for the sales range. The
    main range has only one item and the sales range has six. The products in each
    list have a title, an **SKU** (**store keeping unit**, for example, a product
    code), a price, a conveniently formatted savings text, a description, and an image
    URL. We've elected to insert a placeholder code for the pixel size of the image
    because we want to be able to dynamically alter the sizes when we present the
    pictures to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to access this file by going to `http://localhost:3000/products.json`,
    so we need to make an addition to `server.js`. Edit this file, and before the
    line with `app.listen`, add the following code and restart the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you access `http://localhost:3000/products.json`, you should be served
    our products.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data store to fetch the products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application architecture suggested for use with ReactJS is called **Flux**.
    It's not a framework though, but can be seen as more of a pattern to transmit
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flux consists of three major parts: the dispatchers, stores, and actions. The
    central idea behind Flux is a concept known as *unidirectional data flow*. The
    idea is that your app should have a store to hold your data and that your components
    should listen to it for updates. You interact with it using dispatchers, which
    you can think of as messengers that pass instructions to your actions. In your
    actions, you can fetch new data and pass it over to the store, which in turn emits
    data to your components.'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern avoids the common problem of having multiple places where you need
    to update the state of your application, which often leads to bugs that are hard
    to track down.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may be a bit much to digest, so let''s take a quick look at the individual
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dispatcher**: This is the central hub. It receives actions and sends payloads
    to all of its registered callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: These refer to helper methods that facilitate the passing of data
    to the dispatcher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stores**: These are logic containers that have callbacks registered on the
    dispatcher, which emits state changes to all registered callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views**: This refers to those React components that get a state from the
    stores and pass data to any of the descendants in their component tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a multitude of different Flux implementations. For this chapter, I've
    chosen Reflux as the Flux implementation, but we'll look at a different implementation
    called **Redux** in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced
    React*, and an alternate solution in [Chapter 7](ch07.html "Chapter 7. Reactagram"),
    *Reactagram*.
  prefs: []
  type: TYPE_NORMAL
- en: Reflux ditches the concept of a single central dispatcher, choosing to merge
    the concept of dispatcher and action. This lets us get away with less code and
    results in a code base that is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a **Reflux** implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We already installed *Reflux* and the HTTP request library called **Superagent**
    that we'll use to fetch our product's data when we bootstrapped our application
    at the beginning of the chapter, so we're ready to start with *Reflux* right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first store. Make two folders: `stores` and `actions`. Create
    two files, `stores/products.js` and `actions/products.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Stores` and `Actions` are regular JavaScript files, and unlike the ReactJS
    components, they don''t use `.jsx` file ending.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `actions/products.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we define a single key called **FetchProducts**. We then assign
    a Reflux action with the same name. It's possible to define a different name,
    but this will only lead to confusion later, so in order to keep the code base
    sane, it's advisable to duplicate the key name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `stores/products.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we import the action that we just created along with `superagent` and
    `reflux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init()` method will be executed once and is run immediately on import.
    This means that it starts executing everything that you''ve put in `init()` as
    soon as the page is processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we simply access `product.json`, and when it''s loaded, we emit the result
    to all those components that listen to updates from this store. Emits with Reflux
    is done using the `this.trigger()` built-in method and it emits the object that
    you pass within the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that this is taken care of, the next step is to listen to updates from
    this store in our code. Open `layout.jsx` and add the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code just above the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is exciting because we're finally starting to populate our app with content.
    Whenever the store emits data now, this component will pick it up and propagate
    it to its children components via the state object.
  prefs: []
  type: TYPE_NORMAL
- en: Building the product's listing and the item page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view we're going to build now will present users with a selection of your
    book titles. It will start with the main offering as a full-size column and then
    provide other offerings in three smaller columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open `pages/products.jsx` and write code that will display the product''s
    data. Replace everything in the file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect to receive a `data` property called products with two lists: a main
    offering and a sales offering. You''ll probably remember these from `products.json`,
    where we defined them. In our render code, we create a Bootstrap grid and create
    two nodes with a new component called **offerings**. We''re providing three properties
    to this component: a list of products, a type, and maximum amount of products
    that we want to display. In this context, `type` is a string and can be either
    `main` or `ribbon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the `map` function, we have assigned a new property called **key**. This
    is to help ReactJS uniquely identify the components. Any component with a key
    will be reordered and reused in the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re dealing with props, it''s usually a good idea to define a set
    of default properties for the data you want to work with. It''s also a way of
    documenting by writing easily understandable code. In this example, it''s very
    easy to infer just by looking at the property type and the default property that
    `maxProducts` defines the maximum number of products to be displayed. However,
    `type` is still hard to understand. As you know, it''s a string and can be `main`.
    Knowing that it also can be assigned as a *ribbon* is something that you need
    to read the rest of the source code to understand. In these cases, it may be helpful
    to provide the optional values in a docblock code. For instance, documenting this
    property can be done by adding a docblock like this: `@param {string} type "main"|"ribbon"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reducing the product data is done by applying a `filter` function to the list
    of products and returning the first matches by the `index` value. We then run
    a `map` function on the remaining data and return either a `MainOffering` component
    if `type` is `main` or a `RibbonOffering` component if `type` is `ribbon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MainOffering` component creates a full-sized column with a large product
    image to the left and it also creates a price, description, and a buy button to
    the right. The product image gets the 200 x 150 by way of replacing the `{size}`
    template with a `string` value. `Placehold.it` is a convient service that you
    can use to display a dummy image until you''ve got a real image to show. There
    are a number of such services online, ranging from the plain ones, such as `placehold.it`,
    to services showing dogs and cats to nature, technology, and architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth mentioning here that in the `render()` method, we either return
    a ReactJS node or `null` if `this.props.productData` has a title. The reason that
    we do this is because when we mount the component, `productData` will be unpopulated.
    If we try to use the property at this point, ReactJS will return an error. It
    will be populated as soon as the data has been fetched in the *store*, and that
    may take a few milliseconds or it may take a bit long depending on a number of
    things, but primarily, it depends on latency, which means it''s very unlikely
    that the data is available when you mount the component. In any case, you shouldn''t
    rely on that, so it''s better to return nothing until the data is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a number of components in this file, but note that we only export
    the main one, called products. The other components will not be available via
    destructuring because they have not been exported.
  prefs: []
  type: TYPE_NORMAL
- en: We've linked our items to the `item` page, so we need to flesh it out and retrieve
    the item data when the customer visits this page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `pages/item.jsx` and replace the content with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we take advantage of the fact that all of our products exist as a property
    to this page and that they simply return a filtered object list from the complete
    product list. The filter is based on `this.getParams().id`. This is a built-in
    *mixin* provided by `react-router`, which fetches the `id` key defined in `routes.jsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **mixin** is a piece of code that contains methods that can be included in
    other pieces of code without the use of inheritance. This is advantageous because
    it allows easy code injection and reuse. This has drawbacks as well because uncritical
    use of mixins can lead to confusion regarding the origin of the code you''re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This return declaration checks the new object list for its length and either
    provides the item information or an information block informing the customer that
    the product couldn''t be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The last piece of code prints out the product information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the final result should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the product''s listing and the item page](img/B04943_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final piece of the puzzle adds the action that puts the item in your cart.
    For that, we need to make another action file and a cart store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cart store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll need to add two more files to our project, `actions/cart.js` and `store/carts.js`.
    Create these files and add this code to the `actions` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We define three actions, one for adding items, one for removing them, and the
    third for clearing the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `store/carts.js` and add the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our `store` object. Initializing it outside `CartStore` itself makes
    it private and hidden, making it impossible to import `CartStore` and modify the
    `store` object directly. It''s customary, but not necessary, to prefix such objects
    with an underscore. It''s simply a way of indicating that we''re working with
    a `private` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the actions we''ll listen and respond to. Whenever any of the preceding
    actions are called in our code, the function that we connect to the action will
    be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `CartActions.AddToCart` with an item in our code, this code will
    add the item to our `cart` object. We then call `this.emit()`, which is our store
    emitter. We could just as easily call `this.trigger` directly (which is the native
    `Reflux` function for emitting data), but having a single function responsible
    for emitting data is beneficial if you need to perform any functions or execute
    any code before emitting the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This function removes an item from our `cart` object using the built-in `filter`
    function in JavaScript. The `filter` function returns a new array when called,
    excluding the item we want removed. We then simply emit the altered `cart` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This resets the cart and emits the empty `cart` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we emit the `cart` object. Any component that listens to
    this store will receive the object and render the new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to provide the user with some indication of the state of his/her
    cart, so open up `menu.jsx` and replace `NavItemLink` for the `Checkout` section
    with the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Before `render()`, add a `defaultProps` section with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'All state changes go through `layout.jsx`, so open this file and add the following
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `mixins` section, add a listener for the `cart` store and the function
    that is to be run when the cart emits data. The code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Menu` component needs to receive the new state, so provide it with this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add the action to the **Add to cart** buttons. Edit `pages/products.jsx`
    and replace the button code in `MainOffering` and `RibbonOffering` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line of code to the imports section as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You're set. When you click on the **Add to cart** button in the products page
    now, the cart will be updated and the menu count will also be updated immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a cart store](img/B04943_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checking out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What good is a webshop if your customers cannot check out? After all, that's
    what they're here for. Let's set up a check out screen and let the customer enter
    a delivery address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create some new files: `stores/customer.js`, `actions/customer.js`,
    and `components/customerdata.jsx`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `actions/customer.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This single action will be responsible for address management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open `stores/customer.js` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As in `cart.js`, here we define a `private` object to store the state of our
    store. As you can read from the object definition, we''ll store a customer list
    and a Boolean address validator. We will also import the customer action file
    that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You'll recognize the structure of this code from the `cart.js` file. We listen
    to the `SaveAddress` action and execute the connected function whenever the action
    is called. Finally, the emitter is called every time the state object is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we edit the last new file, let''s open `checkout.jsx` and set up the
    code we need there. Replace the current content with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We import two new functions from `React-Bootstrap` and two of the new files
    that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we initialize the component with two properties: a `cart`
    array and a `customer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We define a Boolean variable that controls whether the checkout button is visible
    or not. Our requirements are simply that we want at least one item in our cart
    and that the customer has entered a valid name address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then display a simple message to our customer inside a Bootstrap well. Next,
    we display the cart contents (which we''ll define in the following code snippet),
    and then, we present a series of input fields where the customer can add an address.
    Finally, we display a button that takes the user to the payment window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Cart is another React component that takes care of displaying a table with the
    contents of the customer's cart, including a total amount for the order. We initialize
    a variable for the total amount and set it to zero. We then use the built-in `forEach`
    function in JavaScript to loop and walkthrough the `cart` contents and create
    an order total. Since the prices come with a dollar symbol from the JSON file,
    we need to strip out this before adding the sums (or else JavaScript would simply
    concatenate the strings). We also use `parseFloat` to convert the string into
    a float.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this is not an ideal solution because you don't want to use `float`
    values when working with prices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try adding 0.1 and 0.2 with JavaScript to understand why (hint: it won''t equal
    0.3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best solution is to use integers and divide by 100 whenever you want to
    display fractional values. For that reason, `products.json` could be updated to
    include a price field like this: `"display_price": "$21.90","price": "2190"`.
    Then, we''d work with `price` in our code, but use `display_price` in our views.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we walk through our cart content again, but this time using JavaScript''s
    built-in `map` function. We return a new array populated with `CartElement` nodes.
    We then render a table and insert the new array that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `CartElement` component should look familiar to you with one exception,
    the `onClick` method has a bind. We do this because we want to pass along the
    product data when the customer clicks on the **Remove** button. The first element
    in the bind is the event and the second is the data. We don't need to pass along
    the event, so we simply set that to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking out](img/B04943_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to add the code for `customerdata.jsx` so let''s open this file
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This might look a bit complicated, but the idea here is that we'll set the customer
    name and address validation to the same as `this.props` if it exists, but if not,
    we use the default values of empty strings and set Boolean to `false` for address
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we do this is that we want to display whatever data the customer
    has entered if he/she chooses to add data to the checkout screen, but then decides
    to visit another part of the store before proceeding to the checkout screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is the first of four similar sections that deal with input validation.
    The validation is only based on string length, but it can be replaced with any
    desired validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: In `handleChangeName`, we clone the state in a local variable (making sure we
    don't accidentally mutate the state manually), and then, we set the new value
    for the name from the input field. The input value is fetched via `refs`, which
    is a ReactJS concept. A reference can be set to any element and accessed via `this.refs`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, on every change, we check all the validations that we've set up. If all
    are valid, we set the address validator to Boolean as `true`. Finally, we save
    the state and then run the action that will store the new address in the customer
    store. This change will be emitted to `layout.jsx`, which will then pass the data
    back to this component, and others which listens to the customer store.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns Boolean as `true` or `false` depending on all validation
    checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the Bootstrap `FormGroup` and `FormControl` functions and set
    the styling based on the validation check. We set the `ref` parameter here that
    we use to access the value when we save the name in our customer store. Every
    time the input field is changed, it''s sent to the `onChange` handler, `handleChangeName`.
    The rest of the input fields are identical, except that they call upon different
    change handlers and validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to propagate the changes in the new customer store from the layout
    to the children components, we need to make a change in `layout.jsx`. Open the
    file and add this import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the mixins, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Providing a receipt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next logical step is to take care of payment and provide a receipt for
    the customer. For payments, you need an account with a payment provider, such
    as **PayPal**, **Klarna**, **BitPay**, and so on. Integration is usually very
    straightforward, and it goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: You connect to a data API provided by the payment provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit your API key and the order data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the payment process is finished, the payment provider will redirect to
    your receipt page and let you know whether the payment was successful or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The connection to the payment API should be hooked up to the **Proceed to checkout**
    button. As the integration with a payment provider differs with every provider,
    we'll simply provide a receipt page without verifying the payment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `checkout.jsx` and add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace the checkout button with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `receipt.jsx` and replace the content with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, we tap into the `history` method and notify it to send the customer to
    the home page if there's no cart data. This is a simple validation to check whether
    the customer has entered the receipt page outside the predefined path.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution is not very robust. When you set it up with a payment provider,
    you will send an identifier to the provider. You need to store this identifier
    and use this instead to decide whether to show the receipt page and what to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re reusing code from the checkout page here to show the cart content and
    the order total. We''re also creating a new `OrderElement` component in order
    to display the list of items in the customer''s cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![Providing a receipt](img/B04943_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finished our first blueprint, the webshop. You now have a fully functioning
    shop built with ReactJS. Let's take a look at what we've built in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we started detailing the components that we needed to create and made
    a basic mock-up of how we wanted the site to look. We wanted the design to be
    responsive and the content visible on a range of devices, from the smallest smart
    phones to tablets and desktop computers screens.
  prefs: []
  type: TYPE_NORMAL
- en: We then worked on the layout and chose to use Bootstrap to help us with the
    responsive functionality. We took the scaffolding from [Chapter 1](ch01.html "Chapter 1. Diving
    Headfirst into ReactJS"), *Diving Headfirst into ReactJS*, and extended it by
    adding a small number of node modules from the `npm` registry, chiefly, `react-router`,
    `react-bootstrap`, and the promise-based request library, `superagent`.
  prefs: []
  type: TYPE_NORMAL
- en: We built the web shop based on the concept of unidirectional data flow, following
    the established Flux pattern where actions go back to the store and the store
    emits data to the components. Furthermore, we set it up so that all data is routed
    through the central app and propagated as properties to the child components.
    This is a powerful pattern because it leaves you with no uncertainty as to where
    your data originates from, and every part of your app has access to the same data
    with the same state.
  prefs: []
  type: TYPE_NORMAL
- en: While making the webshop, we resolved a number of technical hurdles, such as
    routing, form validation, and array filtering.
  prefs: []
  type: TYPE_NORMAL
- en: The final app is a basic working webshop that is ready to be developed and styled
    further.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at how to develop responsive apps with ReactJS!
  prefs: []
  type: TYPE_NORMAL
