<html><head></head><body>
<div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-196"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 id="_idParaDest-197"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.2.1">Deferring Loader Data</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Executing data loading on the server can speed up initial page load times and improve core web vitals </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.4.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Largest Contentful Paint</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">LCP</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">However, server-side data fetching can also become a bottleneck if a request is particularly slow. </span><span class="koboSpan" id="kobo.8.3">For such cases, Remix provides an alternative </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">data-fetching approach.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will work with Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">defer</span></strong><span class="koboSpan" id="kobo.12.1"> function and learn how to utilize HTTP and React streaming, React </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">Suspense</span></strong><span class="koboSpan" id="kobo.14.1">, and Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">Await</span></strong><span class="koboSpan" id="kobo.16.1"> component to defer slow loader data requests. </span><span class="koboSpan" id="kobo.16.2">This chapter is split into </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Streaming data to </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">the client</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Deferring </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">loader data</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">First, we will discuss the trade-offs of server-side data fetching and review the requirements for working with Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">defer</span></strong><span class="koboSpan" id="kobo.24.1"> function. </span><span class="koboSpan" id="kobo.24.2">Next, we will utilize Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">defer</span></strong><span class="koboSpan" id="kobo.26.1"> function in BeeRich and practice working with React </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">Suspense</span></strong><span class="koboSpan" id="kobo.28.1"> and Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">Await</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.30.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">After reading this chapter, you will know how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">defer</span></strong><span class="koboSpan" id="kobo.33.1"> to improve the performance of your Remix applications. </span><span class="koboSpan" id="kobo.33.2">You will have also learned the requirements for working with HTTP and React streaming. </span><span class="koboSpan" id="kobo.33.3">Finally, you will understand the trade-offs of deferring loader data and know when to utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">defer</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.35.1">in Remix.</span></span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.36.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.37.1">We need to update some code before we can get started with this chapter. </span><span class="koboSpan" id="kobo.37.2">Please follow the steps in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">README.md</span></strong><span class="koboSpan" id="kobo.39.1"> file in this chapter’s folder on GitHub before continuing. </span><span class="koboSpan" id="kobo.39.2">You can find the code for this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">here: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data"><span class="No-Break"><span class="koboSpan" id="kobo.41.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.42.1">.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.43.1">Streaming data to the client</span></h1>
<p><span class="koboSpan" id="kobo.44.1">There are </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.45.1">several different data-fetching strategies. </span><span class="koboSpan" id="kobo.45.2">We can initiate data fetching on the client using client-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">fetch</span></strong><span class="koboSpan" id="kobo.47.1"> requests or execute data fetching on the server to take advantage of server-side rendering. </span><span class="koboSpan" id="kobo.47.2">We can even fetch data during build time for static site generations. </span><span class="koboSpan" id="kobo.47.3">In this section, we will discuss the trade-offs of server-side data fetching and review the requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">HTTP streaming.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.49.1">Motivating server-side data fetching and streaming</span></h2>
<p><span class="koboSpan" id="kobo.50.1">Remix promotes fetching data on the server using </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">loader</span></strong><span class="koboSpan" id="kobo.52.1"> functions for each route, as opposed to fetching data at the component level. </span><span class="koboSpan" id="kobo.52.2">During the initial page load, </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.53.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">loader</span></strong><span class="koboSpan" id="kobo.55.1"> functions are called before React renders on the server. </span><span class="koboSpan" id="kobo.55.2">This guarantees that the loader data is available for the server-side rendering step, eliminating the need for client-side data-fetching logic and </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">loading states.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">When</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.58.1"> initiating data fetching on the client, we first need to load the HTML document and then wait for the JavaScript bundles to download and execute before executing the required fetch requests. </span><span class="koboSpan" id="kobo.58.2">This results in three client-server roundtrips before the LCP is finalized. </span><span class="koboSpan" id="kobo.58.3">In comparison, we can paint the LCP after one client-server roundtrip with server-side data fetching and rendering. </span><span class="koboSpan" id="kobo.58.4">Reducing the number of client-server roundtrips almost always results in faster response times and improved core </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">web vitals.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">Let’s run through an example to understand how server-side data fetching can improve the LCP of the initial page load. </span><span class="koboSpan" id="kobo.60.2">Assume we maintain an e-commerce web page for a product. </span><span class="koboSpan" id="kobo.60.3">The site shows an image of the product and some additional information about the product, such as the name of the product and </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">its price.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">First, let’s assume we operate a client-side-only SPA. </span><span class="koboSpan" id="kobo.62.2">What happens once a user visits our </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">web page?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.64.1"><img alt="Figure 13.1 – Client-side dat﻿a-fetching waterfall" src="image/Figure_13.1_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.65.1">Figure 13.1 – Client-side data-fetching waterfall</span></p>
<p><span class="koboSpan" id="kobo.66.1">As</span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.67.1"> visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.69.1">.1</span></em><span class="koboSpan" id="kobo.70.1">, the following</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.71.1"> requests are executed from </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">the browser:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.73.1">The browser requests the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">HTML document.</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">The browser requests scripts and other assets referenced in </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the document.</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">The React app is running and fetches the product information. </span><span class="koboSpan" id="kobo.77.2">The browser executes the </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">fetch requests.</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">The React app re-renders with the fetched data, and the browser requests assets linked in the HTML, such as the product images. </span><span class="koboSpan" id="kobo.79.2">The downloaded assets are used to paint </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the LCP.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.81.1">We </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.82.1">execute </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.83.1">four subsequent requests to display the product image and finalize the LCP, each request adding to the request waterfall and delaying </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the LCP.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">Now, let’s assume we use Remix to render the product page. </span><span class="koboSpan" id="kobo.85.2">How many client requests are necessary to finalize </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">the LCP?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.87.1"><img alt="Figure 13.2 – Server-side dat﻿a-fetching waterfall" src="image/Figure_13.2_B17399.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.88.1">Figure 13.2 – Server-side data-fetching waterfall</span></p>
<p><span class="koboSpan" id="kobo.89.1">As visible in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.90.1">Figure 13</span></em></span><em class="italic"><span class="koboSpan" id="kobo.91.1">.2</span></em><span class="koboSpan" id="kobo.92.1">, the following requests are executed from </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">the browser:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.94.1">The browser requests the HTML document. </span><span class="koboSpan" id="kobo.94.2">The received document already includes the product information and image </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">HTML element.</span></span></li>
<li><span class="koboSpan" id="kobo.96.1">The browser requests the product image together with the other linked assets. </span><span class="koboSpan" id="kobo.96.2">The downloaded assets are used to paint </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">the LCP.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.98.1">With </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.99.1">server-side data fetching, we only require two client-server roundtrips to render the product page. </span><span class="koboSpan" id="kobo.99.2">This is a </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">significant improvement.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">What changed? </span><span class="koboSpan" id="kobo.101.2">Remix flattens the request waterfall by moving the data fetching to the server. </span><span class="koboSpan" id="kobo.101.3">This way, images and other assets can load parallel to the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">JavaScript bundles.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">Unfortunately, this</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.104.1"> model may not work well when executing particularly slow requests in </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">loader</span></strong><span class="koboSpan" id="kobo.106.1"> functions. </span><span class="koboSpan" id="kobo.106.2">Since we wait for all </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">loader</span></strong><span class="koboSpan" id="kobo.108.1"> functions to finish before server-side rendering our React application, a slow request can become a bottleneck for our application and slow down initial page loads. </span><span class="koboSpan" id="kobo.108.2">In this case, we might want to look for </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">alternative approaches.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">One solution could be fetching the slow request from the client after the initial page has been downloaded from the server. </span><span class="koboSpan" id="kobo.110.2">However, this results in the request waterfall outlined earlier – further delaying the slow data response. </span><span class="koboSpan" id="kobo.110.3">Luckily, Remix provides a simple set of primitives to defer loading a promise and instead stream the response to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Streaming allows us to send bytes to the client, even if the full response has not been finalized. </span><span class="koboSpan" id="kobo.112.2">React provides utilities to stream server-side-rendered content to the client. </span><span class="koboSpan" id="kobo.112.3">React will start sending pieces of the rendered content to the client while still awaiting other pieces. </span><span class="koboSpan" id="kobo.112.4">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Suspense</span></strong><span class="koboSpan" id="kobo.114.1">, React can suspend component subtrees from rendering until a promise resolves. </span><span class="koboSpan" id="kobo.114.2">Remix builds on React </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Suspense</span></strong><span class="koboSpan" id="kobo.116.1"> to defer specific loader data requests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">defer</span></strong><span class="koboSpan" id="kobo.118.1"> function and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Await</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Remix </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">loader</span></strong><span class="koboSpan" id="kobo.123.1"> functions fetch data at the route level to avoid network waterfalls. </span><span class="koboSpan" id="kobo.123.2">If a request is particularly slow and in danger of becoming a bottleneck, we can pull another lever to defer that request. </span><span class="koboSpan" id="kobo.123.3">This is made possible by HTTP streaming and the web streaming API. </span><span class="koboSpan" id="kobo.123.4">In the next section, we will discuss the requirements to utilize HTTP streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">with Remix.</span></span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.125.1">Understanding HTTP streaming requirements</span></h2>
<p><span class="koboSpan" id="kobo.126.1">Since</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.127.1"> Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">defer</span></strong><span class="koboSpan" id="kobo.129.1"> function</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.130.1"> uses HTTP and React streaming, we can only utilize it on a server environment that supports HTTP streaming responses. </span><span class="koboSpan" id="kobo.130.2">In this section, we will discuss the requirements for HTTP streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">In </span><a href="B17399_03.xhtml#_idTextAnchor043"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.135.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.136.1">, </span><em class="italic"><span class="koboSpan" id="kobo.137.1">Deployment Targets, Adapters, and Stacks</span></em><span class="koboSpan" id="kobo.138.1">, we learned how Remix utilizes adapters to run on different JavaScript runtimes and server environments. </span><span class="koboSpan" id="kobo.138.2">Some environments, such as traditional serverless environments, may not support streaming responses. </span><span class="koboSpan" id="kobo.138.3">This is important to remember when evaluating hosting providers </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">and runtimes.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Fortunately, a growing number of environments do support HTTP streaming, and by default, Remix is set up with React streaming. </span><span class="koboSpan" id="kobo.140.2">This is great even without using </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">defer</span></strong><span class="koboSpan" id="kobo.142.1"> as it speeds up the initial document request. </span><span class="koboSpan" id="kobo.142.2">With HTTP streaming, the client can start receiving parts of the response without needing to wait for the full response to </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">be finalized.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">To find out whether your Remix project is set up with React streaming, you can check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">app/entry.server.tsx</span></strong><span class="koboSpan" id="kobo.146.1"> file in your Remix project. </span><span class="koboSpan" id="kobo.146.2">Search for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">renderToPipeableStream</span></strong><span class="koboSpan" id="kobo.148.1"> function. </span><span class="koboSpan" id="kobo.148.2">If it is in use, you can be certain that React streaming is set up. </span><span class="koboSpan" id="kobo.148.3">Otherwise, you can follow Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">defer</span></strong><span class="koboSpan" id="kobo.150.1"> guide to set up React streaming: </span><a href="https://remix.run/docs/en/2/guides/streaming"><span class="koboSpan" id="kobo.151.1">https://remix.run/docs/en/2/guides/streaming</span></a><span class="koboSpan" id="kobo.152.1"> (if your runtime and hosting environment </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">supports it).</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">If you can’t locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">app/entry.server.tsx</span></strong><span class="koboSpan" id="kobo.156.1"> file, it may be that you are using Remix's default implementation and that you need to reveal it by executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">npx remix reveal</span></strong><span class="koboSpan" id="kobo.158.1"> command. </span><span class="koboSpan" id="kobo.158.2">You can learn more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">entry.server.tsx</span></strong><span class="koboSpan" id="kobo.160.1"> file in </span><a href="B17399_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.161.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.162.1">, </span><em class="italic"><span class="koboSpan" id="kobo.163.1">Creating a New Remix Project</span></em><span class="koboSpan" id="kobo.164.1">, or in the Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">documentation: </span></span><a href="https://remix.run/docs/en/2/file-conventions/entry.server"><span class="No-Break"><span class="koboSpan" id="kobo.166.1">https://remix.run/docs/en/2/file-conventions/entry.server</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.167.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Now that you understand how Remix uses HTTP and React streaming, let’s try it out in BeeRich. </span><span class="koboSpan" id="kobo.168.2">In the next section, we will practice working with Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1"> function.</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.171.1">Deferring loader data</span></h1>
<p><span class="koboSpan" id="kobo.172.1">Not all </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.173.1">payloads are equally important to the user. </span><span class="koboSpan" id="kobo.173.2">Some data may only appear below the page’s fold and is not immediately visible to the user. </span><span class="koboSpan" id="kobo.173.3">Other information may not be of primary content of the page but slow down the initial page load. </span><span class="koboSpan" id="kobo.173.4">For example, we may want to prioritize displaying the product information for an e-commerce site as fast as possible. </span><span class="koboSpan" id="kobo.173.5">However, we might be okay deferring the loading of the comments section to</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.174.1"> speed up the initial page load time. </span><span class="koboSpan" id="kobo.174.2">For this, Remix provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">defer</span></strong><span class="koboSpan" id="kobo.176.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Await</span></strong><span class="koboSpan" id="kobo.178.1"> primitives. </span><span class="koboSpan" id="kobo.178.2">In this section, we will utilize Remix’s primitives with React </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Suspense</span></strong><span class="koboSpan" id="kobo.180.1"> in BeeRich to defer specific </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">loader data.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Please review the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">README.md</span></strong><span class="koboSpan" id="kobo.184.1"> file on GitHub for this chapter if you haven’t already: </span><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md"><span class="koboSpan" id="kobo.185.1">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md</span></a><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">This file will guide you through setting up the new expense and invoice changelog. </span><span class="koboSpan" id="kobo.186.3">Now, let’s allow users to see the </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.187.1">full history of all changes to their expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">and invoices:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.189.1">Let’s start by fetching the changelog data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">dashboard.expenses.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.191.1"> route module’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">load</span><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.193.1">er</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.195.1">
const userId = await requireUserId(request);const { id } = params;if (!id) throw Error('id route parameter must be defined');const expense = await db.expense.findUnique({ where: { id_userId: { id, userId } } });if (!expense) throw new Response('Not found', { status: 404 });</span><strong class="bold"><span class="koboSpan" id="kobo.196.1">const expenseLogs = await db.expenseLog.findMany({</span></strong><strong class="bold"><span class="koboSpan" id="kobo.197.1">  orderBy: { createdAt: 'desc' },</span></strong><strong class="bold"><span class="koboSpan" id="kobo.198.1">  where: { expenseId: id, userId },</span></strong><strong class="bold"><span class="koboSpan" id="kobo.199.1">});</span></strong><span class="koboSpan" id="kobo.200.1">return json(</span><strong class="bold"><span class="koboSpan" id="kobo.201.1">{ expense, expenseLogs }</span></strong><span class="koboSpan" id="kobo.202.1">);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.203.1">We now also return an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">expenseLogs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.205.1"> array.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.206.1">Note that the current implementation blocks the expense logs query until the expense has been fetched. </span><span class="koboSpan" id="kobo.206.2">This increases the initial page load time as we introduce a subsequent database query, something we will </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">fix later.</span></span></p></li> <li><span class="koboSpan" id="kobo.208.1">Next, create </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.209.1">an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">ExpenseLogs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1"> component:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.212.1">import type { ExpenseLog } from '@prisma/client';</span></strong><span class="koboSpan" id="kobo.213.1">import type { ActionFunctionArgs, LoaderFunctionArgs, </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">SerializeFrom</span></strong><span class="koboSpan" id="kobo.215.1"> } from '@remix-run/node';function ExpenseLogs({ expenseLogs }: { expenseLogs: </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">SerializeFrom&lt;ExpenseLog[]&gt;</span></strong><span class="koboSpan" id="kobo.217.1"> }) {  return (    &lt;ul className="space-y-2 max-h-[300px] lg:max-h-max overflow-y-scroll lg:overflow-hidden py-5"&gt;      {</span><strong class="bold"><span class="koboSpan" id="kobo.218.1">expenseLogs.map((expenseLog) =&gt;</span></strong><span class="koboSpan" id="kobo.219.1"> (        &lt;li key={expenseLog.id}&gt;          &lt;p&gt;            &lt;b&gt;              {`${expenseLog.title} - ${Intl.               </span><span class="koboSpan" id="kobo.219.2">NumberFormat('en-US', {                style: 'currency',                currency: expenseLog.currencyCode,              }).format(expenseLog.amount)}`}            &lt;/b&gt;          &lt;/p&gt;          {expenseLog.description &amp;&amp; (            &lt;p&gt;              &lt;i&gt;{expenseLog.description}&lt;/i&gt;            &lt;/p&gt;          )}          &lt;p className="text-sm text-gray-500"&gt;            {`${new Date(expenseLog.createdAt).             </span><span class="koboSpan" id="kobo.219.3">toLocaleDateString()} ${new Date(              expenseLog.createdAt,            ).toLocaleTimeString()}`}          &lt;/p&gt;        &lt;/li&gt;      ))}    &lt;/ul&gt;  );}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.220.1">We will render the component below the expense edit form to display </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the changelog.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.222.1">Note that we </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.223.1">use the generated </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">ExpenseLog</span></strong><span class="koboSpan" id="kobo.225.1"> type from Prisma for the component’s prop type. </span><span class="koboSpan" id="kobo.225.2">We wrap it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">SerializeFrom</span></strong><span class="koboSpan" id="kobo.227.1"> as loader data is fetched from the server and serialized as JSON while sent over </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">the network.</span></span></p></li> <li><span class="koboSpan" id="kobo.229.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.231.1"> call in the route module component to access the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">expenseLog</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> array:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.234.1">
const </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">{ expense, expenseLogs }</span></strong><span class="koboSpan" id="kobo.236.1"> = useLoaderData&lt;typeof loader&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.237.1">Import our reusable </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">H3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1"> component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.240.1">
import { H2, </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">H3</span></strong><span class="koboSpan" id="kobo.242.1"> } from '~/components/headings';</span></pre></li> <li><span class="koboSpan" id="kobo.243.1">Render the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">ExpenseLogs</span></strong><span class="koboSpan" id="kobo.245.1"> component below the edit </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">expense form:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
&lt;section className="my-5 w-full m-auto lg:max-w-3xl flex flex-col items-center justify-center gap-5"&gt;  &lt;H3&gt;Expense History&lt;/H3&gt;  </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">&lt;ExpenseLogs expenseLogs={expenseLogs} /&gt;</span></strong><span class="koboSpan" id="kobo.249.1">&lt;/section&gt;&lt;FloatingActionLink to="/dashboard/expenses/"&gt;Add expense&lt;/FloatingActionLink&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.250.1">Now, run </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.251.1">BeeRich on </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">localhost</span></strong><span class="koboSpan" id="kobo.253.1"> to test it out. </span><span class="koboSpan" id="kobo.253.2">Execute </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">npm run dev</span></strong><span class="koboSpan" id="kobo.255.1"> and open an expense details page in a </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">browser window.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.257.1">The new change history is great, but also not the most important aspect of the page. </span><span class="koboSpan" id="kobo.257.2">We render the history below the expense and invoice details on the nested detail routes. </span><span class="koboSpan" id="kobo.257.3">Most likely, the information will be rendered below the </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">page’s fold.</span></span></p></li>
<li><span class="koboSpan" id="kobo.259.1">To avoid delaying the initial page load, utilize Remix’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
import { </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">defer</span></strong><span class="koboSpan" id="kobo.264.1">, json, redirect, unstable_parseMultipartFormData } from '@remix-run/node';</span></pre></li> <li><span class="koboSpan" id="kobo.265.1">Replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">json</span></strong><span class="koboSpan" id="kobo.267.1"> helper in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">loader</span></strong><span class="koboSpan" id="kobo.269.1"> function with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> call:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.272.1">
return </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">defer</span></strong><span class="koboSpan" id="kobo.274.1">({ expense, expenseLogs });</span></pre></li> <li><span class="koboSpan" id="kobo.275.1">Refresh the page and note that nothing changed. </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">defer</span></strong><span class="koboSpan" id="kobo.277.1"> acts just as </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">json</span></strong><span class="koboSpan" id="kobo.279.1"> when called with resolved data. </span><span class="koboSpan" id="kobo.279.2">The magic only starts happening once we </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">defer</span></strong><span class="koboSpan" id="kobo.281.1"> an </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">unresolved </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">Promise</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.285.1">Remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">await</span></strong><span class="koboSpan" id="kobo.287.1"> keyword before the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">expenseLog.findMany</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1"> call:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
const expenseLogs = </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">db.expenseLog</span></strong><span class="koboSpan" id="kobo.292.1">  .findMany({    orderBy: { createdAt: 'desc' },    where: { expenseId: id, userId },  })  </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">.then((expense) =&gt; expense);</span></strong><span class="koboSpan" id="kobo.294.1">return </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">defer</span></strong><span class="koboSpan" id="kobo.296.1">({ expense, expenseLogs });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.297.1">Passing</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.298.1"> an unresolved </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Promise</span></strong><span class="koboSpan" id="kobo.300.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">defer</span></strong><span class="koboSpan" id="kobo.302.1"> changes the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">loader</span></strong><span class="koboSpan" id="kobo.304.1"> function. </span><span class="koboSpan" id="kobo.304.2">The function now returns without awaiting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">expenseLog</span></strong><span class="koboSpan" id="kobo.306.1"> query, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">defer</span></strong><span class="koboSpan" id="kobo.308.1"> will make sure to stream the data to the client </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">once resolved.</span></span></p></li> <li><span class="koboSpan" id="kobo.310.1">Note that we also chain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">then</span></strong><span class="koboSpan" id="kobo.312.1"> call at the end of the query. </span><span class="koboSpan" id="kobo.312.2">This is a trick to map </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">PrismaPromise</span></strong><span class="koboSpan" id="kobo.314.1">, which is returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">findMany</span></strong><span class="koboSpan" id="kobo.316.1">, to an actual </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">Promise</span></strong><span class="koboSpan" id="kobo.318.1"> object, as Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">defer</span></strong><span class="koboSpan" id="kobo.320.1"> function requires </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Promise</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1"> instances.</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">Snap! </span><span class="koboSpan" id="kobo.323.2">We broke the page as </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.325.1"> is now of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Promise</span></strong><span class="koboSpan" id="kobo.327.1"> type. </span><span class="koboSpan" id="kobo.327.2">We need to update our React code so that it can work with deferred loader data. </span><span class="koboSpan" id="kobo.327.3">First, import </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Suspense</span></strong><span class="koboSpan" id="kobo.329.1"> from React and </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Await</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.331.1">from Remix:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.332.1">
import {  </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Await</span></strong><span class="koboSpan" id="kobo.334.1">,  isRouteErrorResponse,  useActionData,  useLoaderData,  useNavigation,  useParams,  useRouteError,} from '@remix-run/react';import { </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">Suspense</span></strong><span class="koboSpan" id="kobo.336.1"> } from 'react';</span></pre></li> <li><span class="koboSpan" id="kobo.337.1">Wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">ExpenseLogs</span></strong><span class="koboSpan" id="kobo.339.1"> component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Suspense</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.341.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Await</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.345.1">Suspense</span></strong><span class="koboSpan" id="kobo.346.1"> fallback="Loading expense history..."&gt;  &lt;</span><strong class="bold"><span class="koboSpan" id="kobo.347.1">Await</span></strong><span class="koboSpan" id="kobo.348.1"> resolve={expenseLogs} errorElement="There was an error loading the expense history. </span><span class="koboSpan" id="kobo.348.2">Please try again."&gt;    </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">{(resolvedExpenseLogs) =&gt; &lt;ExpenseLogs expenseLogs={resolvedExpenseLogs} /&gt;}</span></strong><span class="koboSpan" id="kobo.350.1">  &lt;/</span><strong class="bold"><span class="koboSpan" id="kobo.351.1">Await</span></strong><span class="koboSpan" id="kobo.352.1">&gt;&lt;/</span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Suspense</span></strong><span class="koboSpan" id="kobo.354.1">&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.355.1">The new </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.356.1">suspense boundary renders the fallback content until Remix resolves the promise on the pending </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.358.1"> request. </span><span class="koboSpan" id="kobo.358.2">To inform Remix which promise we are awaiting, we must pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.360.1"> loader data to </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">Await</span></strong><span class="koboSpan" id="kobo.362.1">. </span><span class="koboSpan" id="kobo.362.2">We can also pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Await</span></strong><span class="koboSpan" id="kobo.364.1"> an </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">errorElement</span></strong><span class="koboSpan" id="kobo.366.1"> component in case the promise </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">is rejected.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.368.1">We pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Await</span></strong><span class="koboSpan" id="kobo.370.1"> a callback function as its child component. </span><span class="koboSpan" id="kobo.370.2">Once the promise is resolved, </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">Await</span></strong><span class="koboSpan" id="kobo.372.1"> will call the callback with the resolved data. </span><span class="koboSpan" id="kobo.372.2">This ensures that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">ExpenseLogs</span></strong><span class="koboSpan" id="kobo.374.1"> component has access to the resolved </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">expenseLogs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1"> data.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.377.1">Alternatively, we can access the resolved data by using Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">useDeferredValue</span></strong><span class="koboSpan" id="kobo.379.1"> hook within the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">child component.</span></span></p></li> <li><span class="koboSpan" id="kobo.381.1">Run BeeRich locally and notice how the initial page load does not include the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">expenseLogs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.383.1"> data.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.384.1">Note that you may need to delay the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.386.1"> query for better visibility. </span><span class="koboSpan" id="kobo.386.2">Otherwise, the deferred loading might be too fast on localhost </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">to capture.</span></span></p></li>
<li><span class="koboSpan" id="kobo.388.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">then</span></strong><span class="koboSpan" id="kobo.390.1"> statement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.392.1"> query in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.394.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
  const expenseLogs = db.expenseLog    .findMany({      orderBy: { createdAt: 'desc' },      where: { expenseId: id, userId },    })    .then((expense) =&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.396.1">new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(expense), 2000)));</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.397.1">Instead of resolving the results immediately, we add a two-second delay </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">setTimeout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.401.1">Now, inspect </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.402.1">the deferred data loading in the UI and the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.403.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1"> tab.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.405.1">The page first renders without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.407.1"> data. </span><span class="koboSpan" id="kobo.407.2">Instead, the suspense fallback string is rendered. </span><span class="koboSpan" id="kobo.407.3">Once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">expenseLogs</span></strong><span class="koboSpan" id="kobo.409.1"> promise resolves, the page re-renders with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">expenseLogs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1"> data.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.412.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">defer</span></strong><span class="koboSpan" id="kobo.414.1"> introduces a pending state in the UI. </span><span class="koboSpan" id="kobo.414.2">It is important to understand that this impacts the user experience. </span><span class="koboSpan" id="kobo.414.3">Introducing loading spinners should be considered a trade off for deferring loader data. </span><span class="koboSpan" id="kobo.414.4">We may introduce layout shifts once the data resolves that affect SEO as web crawlers may now parse the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">fallback UI.</span></span></p></li>
<li><span class="koboSpan" id="kobo.416.1">Next, optimize the call order in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">loader</span></strong><span class="koboSpan" id="kobo.418.1"> function. </span><span class="koboSpan" id="kobo.418.2">Move the expense logs query above the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">expense query:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
const userId = await requireUserId(request);const { id } = params;if (!id) throw Error('id route parameter must be defined');// Start expense logs query first before we await the expense query</span><strong class="bold"><span class="koboSpan" id="kobo.421.1">const expenseLogs =</span></strong><span class="koboSpan" id="kobo.422.1"> db.expenseLog  .findMany({    orderBy: { createdAt: 'desc' },    where: { expenseId: id, userId },  })  .then((expenseLogs) =&gt; expenseLogs);</span><strong class="bold"><span class="koboSpan" id="kobo.423.1">const expense = await</span></strong><span class="koboSpan" id="kobo.424.1"> db.expense.findUnique({ where: { id_userId: { id, userId } } });if (!expense) throw new Response('Not found', { status: 404 });return defer({ expense, expenseLogs });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.425.1">Since we </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.426.1">no longer await the expense logs query, we can start executing it before starting the expense query. </span><span class="koboSpan" id="kobo.426.2">This allows us to start the expense logs query as soon </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">as possible.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.428.1">Note that we also removed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">setTimeout</span></strong><span class="koboSpan" id="kobo.430.1"> call. </span><span class="koboSpan" id="kobo.430.2">Make sure you throttle the network and re-add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">setTimeout</span></strong><span class="koboSpan" id="kobo.432.1"> call if necessary to better investigate </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">the experience.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.434.1">From this, we can summarize that Remix provides us with a way to defer loader data per request. </span><span class="koboSpan" id="kobo.434.2">We can decide for each request whether we want to await or defer in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">loader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.436.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">Remember that we broke the page before adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Await</span></strong><span class="koboSpan" id="kobo.439.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Suspense</span></strong><span class="koboSpan" id="kobo.441.1">. </span><span class="koboSpan" id="kobo.441.2">It is good practice to first add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Await</span></strong><span class="koboSpan" id="kobo.443.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Suspense</span></strong><span class="koboSpan" id="kobo.445.1"> components to the page before returning promises with </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">defer</span></strong><span class="koboSpan" id="kobo.447.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">loader</span></strong><span class="koboSpan" id="kobo.449.1"> function. </span><span class="koboSpan" id="kobo.449.2">This will help you avoid errors while implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Await</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.451.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">Suspense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Practice using </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">defer</span></strong><span class="koboSpan" id="kobo.456.1"> by applying the same changes to the income routes. </span><span class="koboSpan" id="kobo.456.2">Copy-paste and adapt the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">ExpenseLogs</span></strong><span class="koboSpan" id="kobo.458.1"> component into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">dashboard.income.$id._index.tsx</span></strong><span class="koboSpan" id="kobo.460.1"> route module. </span><span class="koboSpan" id="kobo.460.2">Utilize the component and implement the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">defer</span></strong><span class="koboSpan" id="kobo.462.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Suspense</span></strong><span class="koboSpan" id="kobo.464.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Await</span></strong><span class="koboSpan" id="kobo.466.1"> flow as practiced in this chapter. </span><span class="koboSpan" id="kobo.466.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">setTimeout</span></strong><span class="koboSpan" id="kobo.468.1"> to test the </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">If you want more practice, add a </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Revert</span></strong><span class="koboSpan" id="kobo.472.1"> button to every expense and invoice log item to revert the expense object to that version. </span><span class="koboSpan" id="kobo.472.2">How could you make use of optimistic UI? </span><span class="koboSpan" id="kobo.472.3">How do deferring and optimistic UI play together? </span><span class="koboSpan" id="kobo.472.4">Review Remix’s documentation about </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">defer</span></strong><span class="koboSpan" id="kobo.474.1"> and optimistic UI if you need </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">more guidance.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.476.1">Remix provides levers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.477.1">Remix provides levers so that we can optimize the user experience based on our app’s requirements. </span><span class="koboSpan" id="kobo.477.2">When considering </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">defer</span></strong><span class="koboSpan" id="kobo.479.1">, it is important to remember that deferred data loading may also degrade the user experience by adding a pending UI and introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">loading spinners.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">In this section, you</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.482.1"> practiced working with Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">defer</span></strong><span class="koboSpan" id="kobo.484.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Await</span></strong><span class="koboSpan" id="kobo.486.1"> primitives. </span><span class="koboSpan" id="kobo.486.2">You now know how to use deferred response data streaming to optimize slow or secondary data requests but are aware that </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">defer</span></strong><span class="koboSpan" id="kobo.488.1"> is a lever that impacts the user experience by introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">pending UIs.</span></span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.490.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.491.1">In this chapter, you learned that Remix supports different data-fetching strategies. </span><span class="koboSpan" id="kobo.491.2">Deferring loader data can be utilized to resolve performance bottlenecks in your Remix apps when fetching from slow endpoints. </span><span class="koboSpan" id="kobo.491.3">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">defer</span></strong><span class="koboSpan" id="kobo.493.1"> function detects unresolved promises in the loader data and streams them to the client once resolved. </span><span class="koboSpan" id="kobo.493.2">React </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">Suspense</span></strong><span class="koboSpan" id="kobo.495.1"> and Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Await</span></strong><span class="koboSpan" id="kobo.497.1"> component are used to manage the deferred loader data </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">in React.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">You also learned that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">defer</span></strong><span class="koboSpan" id="kobo.501.1"> requires fallback UIs to communicate loading states. </span><span class="koboSpan" id="kobo.501.2">You now understand that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">defer</span></strong><span class="koboSpan" id="kobo.503.1"> comes with trade-offs that impact the user experience. </span><span class="koboSpan" id="kobo.503.2">On one hand, deferring loader data can speed up the initial document request. </span><span class="koboSpan" id="kobo.503.3">On the other hand, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">defer</span></strong><span class="koboSpan" id="kobo.505.1"> creates loading UIs, which results in a different </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">After reading this chapter, you know that Remix uses React streaming to speed up document requests. </span><span class="koboSpan" id="kobo.507.2">However, React and HTTP streaming are not supported on all server runtimes and environments. </span><span class="koboSpan" id="kobo.507.3">Conclusively, not all Remix adapters support React streaming. </span><span class="koboSpan" id="kobo.507.4">Since Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">defer</span></strong><span class="koboSpan" id="kobo.509.1"> function takes advantage of React </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">Suspense</span></strong><span class="koboSpan" id="kobo.511.1"> and React streaming, deferring loader data only works when React streaming is supported and </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">set up.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">Finally, you practiced deferring loader data by implementing an expense changelog </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">in BeeRich.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">In the next chapter, we will extend the changelog implementation and add real-time data responses with </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">Server-Sent </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.517.1">Events</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.518.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.519.1">SSE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">).</span></span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.521.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.522.1">You can read more about the Streams API via MDN Web </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">Docs: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API"><span class="No-Break"><span class="koboSpan" id="kobo.524.1">https://developer.mozilla.org/en-US/docs/Web/API/Streams_API</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.525.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">The Remix documentation includes a guide for streaming and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">defer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">: </span></span><a href="https://remix.run/docs/en/2/guides/streaming"><span class="No-Break"><span class="koboSpan" id="kobo.529.1">https://remix.run/docs/en/2/guides/streaming</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.530.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">defer</span></strong><span class="koboSpan" id="kobo.533.1"> function’s documentation can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">here: </span></span><a href="https://remix.run/docs/en/2/utils/defer"><span class="No-Break"><span class="koboSpan" id="kobo.535.1">https://remix.run/docs/en/2/utils/defer</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.536.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">In this chapter, we discussed core web vitals. </span><span class="koboSpan" id="kobo.537.2">You can read more about core web vitals, such as LCP, </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">here: </span></span><a href="https://web.dev/vitals/"><span class="No-Break"><span class="koboSpan" id="kobo.539.1">https://web.dev/vitals/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.540.1">.</span></span></p>
</div>
</body></html>