- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Role-Based Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Designing Authorization and Authentication*, we covered how
    designing an effective authentication and authorization system is challenging
    but crucial for user satisfaction. Users expect a high standard from web authentication
    systems, and any errors should be clearly communicated. As applications grow,
    their authentication backbone should be easily maintainable and extensible to
    ensure a seamless user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the challenges of creating a great auth UX
    and implementing a solid baseline experience. We will continue the router-first
    approach to designing SPAs by implementing the auth experience of LemonMart. In
    *Chapter 4*, *Creating a Router-First Line-of-Business App*, we defined user roles,
    finished our build-out of all major routing, and completed a rough walking-skeleton
    navigation experience of LemonMart. This means we are well prepared to implement
    a role-based conditional navigation experience that captures the nuances of a
    seamless auth experience. We will supplement this with an auth provider using
    the Google Firebase auth service, which you can leverage in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic UI components and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role-based routing using guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Firebase authentication recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a service using a factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *Chapter 6*:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm install` on the root folder to install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will continue building on `stage8` from the last chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The end state of the project is reflected at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `dist/stage8` folder at the root of the repository will contain
    the compiled result.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes to how Angular CLI generates new code, bug fixes, new versions
    of libraries, and side-by-side implementations of multiple techniques, there’s
    a lot of variation that is impossible to account for. If you find errors or have
    questions, please create an issue or submit a pull request on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: With the in-memory auth provider in place, let’s take advantage of all the supporting
    code we have written with dynamic UI components and a conditional navigation system
    for a role-based UX.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic UI components and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AuthService` provides asynchronous auth status and user information, including
    a user’s name and role. We can use all this information to create a friendly and
    personalized user experience. In this next section, we will implement the `LoginComponent`
    so that users can enter their username and password information and attempt a
    login.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the login component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LoginComponent` leverages the `AuthService` we created and implements validation
    errors using reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in `app.config.ts`, we provided `AuthService` using the class
    `InMemoryAuthService`. So, during runtime, when `AuthService` is injected into
    the `LoginComponent`, the in-memory service will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The `LoginComponent` should be designed to be rendered independently of any
    other component because, during a routing event, if we discover that the user
    is not properly authenticated or authorized, we will navigate them to this component.
    We can capture this origination URL as a `redirectUrl` so that once a user logs
    in successfully, we can navigate them back to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new component named `login` in the root of your application with inline
    styles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by implementing the routes to the `LoginComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the `'**'` path must be the last one defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using a similar `login` logic to the one we implemented in `HomeComponent`,
    implement the `LoginComponent` with some styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t forget to import the requisite dependent modules into your Angular application
    for the upcoming steps. This is intentionally left as an exercise for you to locate
    and import the missing modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using the `first` operator to manage the subscription. We ensure that
    we are logged out when `ngOnInit` is called. We build the reactive form in a standard
    manner. Finally, the `login` method calls `this.authService.login` to initiate
    the login process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We listen to the `authStatus$` and `currentUser$` data streams simultaneously
    using `combineLatest`. Every time there’s a change in each stream, our pipe gets
    executed. We filter out unsuccessful login attempts. As the result of a successful
    login attempt, we leverage the router to navigate an authenticated user to their
    profile. In the case of an error sent from the server via the service, we assign
    that error to `loginError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s an implementation for a login form to capture and validate a user’s
    `email` and `password` and, if there are any server errors, display them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t forget to import `ReactiveFormsModule` in `app.modules.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **Login** button is disabled until the email and password meet client site
    validation rules. Additionally, `<mat-form-field>` will only display one `mat-error`
    at a time, unless you create more space for more errors, so be sure to place your
    error conditions in the correct order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you’re done implementing the `LoginComponent`, you can update the home
    screen to conditionally display or hide the new component we created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `HomeComponent` to clean up the code we added previously so that
    we can display the `LoginComponent` when users land on the home page of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your application should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: LemonMart with login'
  prefs: []
  type: TYPE_NORMAL
- en: There’s still some work to be done in terms of implementing and showing/hiding
    the `sidenav` menu, profile, and logout icons, given the user’s authentication
    status.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional navigation is necessary to create a frustration-free UX. By selectively
    showing the elements the user has access to and hiding the ones they don’t, we
    allow the user to confidently navigate through the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by hiding the `LoginComponent` after a user logs into the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `HomeComponent`, inject the `AuthService` into the constructor as a
    `public` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the local variable `displayLogin` because we can directly tap into the
    auth status in the template using the `async` pipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a new template using the control flow syntax, along with the `async`
    pipe, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `async` pipe avoids errors like `Error: ExpressionChangedAfterItHasBeenCheckedError:
    Expression has changed after it was checked`. Whenever you see this error, stop
    using local variables and, instead, use the `async` pipe. It is the reactive thing
    to do!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the `AppComponent`, we will follow a similar pattern by injecting `AuthService`
    as a `public` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `mat-toolbar` in the template so that we monitor both `authStatus$`
    and `currentUser$` using the `async` pipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `@if` to hide all buttons meant for logged-in users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when a user is logged out, your toolbar should look clean, with no buttons,
    as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_06_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.2: The LemonMart toolbar before a user logs in'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also swap out the generic `account_circle` icon in the `profile` button
    if the user has a picture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the use of the `ngSrc` attribute within the `img` tag, which activates
    the `NgOptimizedImage` directive. This directive makes it easy to adopt performance
    best practices for loading images. It has rich features to prioritize or delay
    the loading of certain images to assist in fast **First Contentful Paint** (**FCP**)
    scenarios, allow the use of CDNs, and enforce the use of `width` and `height`
    attributes to prevent layout shifts that can occur when an image loads.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about `NgOptimizedImage` at [https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization).
  prefs: []
  type: TYPE_NORMAL
- en: We now have a highly functional toolbar that reacts to the auth status of the
    application and can also display information that belongs to the logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: Common validations for forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on, we need to refactor the validations for `LoginComponent`.
    As we implement more forms in *Chapter 8*, *Recipes – Reusability, Forms, and
    Caching*, you will realize that it gets tedious very quickly to repeatedly type
    out form validations in either template or reactive forms. Part of the allure
    of reactive forms is that they are driven by code, so we can easily extract the
    validations to a shared class and unit test and reuse them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `validations.ts` file under the `common` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the email and password validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on your password validation needs, you can use a `RegEx` pattern with
    the `Validations.pattern()` function to enforce password complexity rules or leverage
    the OWASP `npm` package, `owasp-password-strength-test`, to enable passphrases,
    as well as set more flexible password requirements. See the link to the OWASP
    authentication general guidelines in the *Further reading* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `LoginComponent` with the new validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s encapsulate some common UI behavior in an Angular service.
  prefs: []
  type: TYPE_NORMAL
- en: UI service using environment provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we start dealing with complicated workflows, such as the auth workflow, it
    is important to be able to programmatically display a toast notification for the
    user. In other cases, we may want to ask for confirmation before executing a destructive
    action with a more intrusive pop-up notification.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what component library you use, it gets tedious to recode the same
    boilerplate just to display a quick notification. A UI service can neatly encapsulate
    a default implementation that can be customized.
  prefs: []
  type: TYPE_NORMAL
- en: In the UI service, we will implement `showToast` and `showDialog` functions
    that can trigger notifications or prompt users for a decision, allowing us to
    use them within the code implementing the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new service named `ui` under `common`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a `showToast` function using `MatSnackBar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the documentation for `MatSnackBar` at [https://material.angular.io](https://material.angular.io).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since this service could be used by any service, component, or feature module,
    we can’t declare this service in a module context. Since our project is a standalone
    project, we instead need to implement an **environment provider** so that we can
    provide the service in the app context defined in `app.config.ts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a `showDialog` function using `MatDialog`, we must implement a basic `dialog`
    component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check out the documentation for `MatDialog` at [https://material.angular.io](https://material.angular.io).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new component named `simpleDialog` under the `common` folder with inline
    templates and styling, skip testing, and a flat folder structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SimpleDialogComponent` should not have an application selector like `selector:
    ''app-simple-dialog''`, since we only plan to use it with `UiService`. If auto-generated,
    remove this property from your component.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, implement a `showDialog` function using `MatDialog` to display the `SimpleDialogComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ShowDialog` returns an `Observable<boolean>`, so you can implement a follow-on
    action depending on what selection the user makes. Clicking on **OK** will return
    `true`, and **Cancel** will return `false`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `SimpleDialogComponent`, using `@Inject`, we can use all variables sent by
    `showDialog` to customize the content of the dialog.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a function named `provideUiService` as an environment provider at the bottom
    of `UiService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`makeEnvironmentProviders` allows us to wrap the dependencies of `Service`
    in an encapsulated object. This way, we don’t expose these dependencies to the
    component using the service. This helps us enforce a decoupled architecture.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `app.config.ts`, add `provideUiService()` to the `providers` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `login()` function on the `LoginComponent` to display a toast message
    after login:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, a toast message will appear after a user has logged in, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_06_03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.3: Material snackbar'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `snackBar` will either take up the full width of the screen or a portion,
    depending on the size of the browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Experiment with displaying a dialog instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you’ve verified that both `showToast` and `showDialog` work, which
    do you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: My rule of thumb between choosing a toast message or a dialog box is that unless
    the user is about to take an irreversible action, you should choose toast messages
    over dialogs so that you don’t interrupt the user’s workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s implement an application-wide side navigation experience as an alternative
    to the toolbar-based navigation we already have so that users can switch between
    modules with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Side navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enhance the user experience, it is essential to enable mobile-first workflows
    and offer an intuitive navigation mechanism that allows users to access their
    desired functionality quickly. A side navigation (`SideNav`) bar serves mobile
    and desktop users equally well. On mobile screens, it can be activated by a triple
    dash (hamburger) menu, and on a large screen, it can be locked open. To further
    optimize the experience, we should only show the links a user is authorized to
    view. We can do this by utilizing the `AuthenticationService` based on the user’s
    current role. We will implement the side navigation mock-up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Side navigation mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the code for the side navigation as a separate component so
    that it is easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: In the application’s root, create a `NavigationMenu` component with inline templates
    and styles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The side navigation isn’t technically required until after a user is logged
    in. However, to be able to launch the side navigation menu from the toolbar, we
    need to be able to trigger it from `AppComponent`. Since this component will be
    simple, we will eagerly load it. To do this lazily, Angular does have a Dynamic
    Component Loader pattern, which has a high implementation overhead that will only
    make sense if multi-hundred-KB savings are made.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SideNav` will be triggered from the toolbar, and it comes with a `<mat-sidenav-container>`
    parent container that hosts the `SideNav` itself and the application’s content.
    So we must render all application content by placing the `<router-outlet>` inside
    `<mat-sidenav-content>`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `AppComponent`, define some styles that will ensure that the web application
    will expand to fill the entire page and remain properly scrollable for desktop
    and mobile scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `MediaObserver` service from Angular Flex Layout in `AppComponent`.
    Also, implement `OnInit`, inject `DestroyRef`, and add a Boolean property named
    `opened`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To automatically determine the open/closed status of the side navigation, we
    need to monitor the media observer and the auth status. When the user logs in,
    we would like to show the side navigation and hide it when the user logs out.
    We can do this by assigning `opened` to the value of `authStatus$.isAuthenticated`.
    However, if we only consider `isAuthenticated`, and the user is on a mobile device,
    we will create a less-than-ideal UX. Watching for the media observer’s `mediaValue`,
    we can check whether the screen size is set to extra small or `xs`; if so, we
    can keep the side navigation closed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update `ngOnInit` to implement the dynamic side navigation open/closed logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By monitoring the media and `authStatus$` streams, we can consider unauthenticated
    scenarios where the side navigation should not be opened even if there’s enough
    screen space. We also use `takeUntilDestroyed` so that our resources can be cleaned
    up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the template with a responsive `SideNav` that will slide over the content
    in mobile or push the content aside in desktop scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding template leverages the media observer in `@ngbracket/ngx-layout`,
    a community clone of the deprecated Angular Flex Layout library. We injected `ngx-layout`
    earlier for a responsive implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the `// prettier-ignore` directive above your template to prevent
    Prettier from breaking up your template into too many lines, which can hurt readability
    in certain conditions like this one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will implement navigational links in `NavigationMenuComponent`. The number
    of links in our application will likely grow over time and be subject to various
    role-based business rules. Therefore, if we were to implement these links in `app.component.ts`,
    we would risk that file getting too large. In addition, we don’t want `app.component.ts`
    to change very often since changes made there can impact the entire application.
    It is a good practice to implement the links in a separate component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement navigational links in `NavigationMenuComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`<mat-nav-list>` is functionally equivalent to `<mat-list>`, so you can use
    the documentation of `MatList` for layout purposes. Observe the `subheaders` for
    **Manager**, **Inventory**, and **Clerk** here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_06_05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.5: The Manager dashboard showing Receipt Lookup on a desktop'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`routerLinkActive="active-link"` highlights the selected **Receipts** route,
    as shown in the preceding screenshot.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Angular Router keeps track of the state of navigation in the app. Based on which
    link is active, it automatically assigns the appropriate CSS so it can be highlighted
    as the active one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about the router at [https://angular.dev/guide/routing/router-reference](https://angular.dev/guide/routing/router-reference).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, you can see the difference in appearance and behavior on mobile
    devices as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B20960_06_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.6: The Manager dashboard showing Receipt Lookup on a mobile'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, let’s implement role-based routing.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based routing using guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most elemental and important part of your application. With lazy
    loading, we have ensured that only the bare minimum number of assets will be loaded
    to enable a user to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Once a user logs in, they should be routed to the appropriate landing screen
    as per their user role, so they’re not guessing how they need to use the application.
    For example, a cashier only needs access to the **point of sale (POS)** screen
    so that they can check out customers. In this case, cashiers can automatically
    be routed to that screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a mock-up of the POS screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: A POS screen mock-up'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s ensure users get routed to the appropriate page after logging in by updating
    the `LoginComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `login` logic to each route per role in the function named `homeRoutePerRole`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, clerks and managers are routed to their landing screens to access
    the features they need to accomplish their tasks, as shown earlier. Since we have
    implemented a default manager role, the corresponding landing experience will
    be launched automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about route guards, which help check for
    user authentication and can even load requisite data before a form is rendered.
    This is crucial in preventing unintentional access to routes that users should
    not have access to and deterring intentional attempts to breach these restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Route guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Route guards enable the further decoupling and reuse of logic and greater control
    over the component life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the four major guards you will most likely use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canActivate` and `canActivateChild`: Used for checking auth access to a route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canDeactivate`: Used to ask permission before navigating away from a route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resolve`: Allows the pre-fetching of data from route parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanLoad`: Allows custom logic to execute before loading feature module assets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the following sections to discover how to leverage `canActivate` and
    `canLoad`. The `Resolve` guard will be covered in *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*.
  prefs: []
  type: TYPE_NORMAL
- en: Auth guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auth guards enable a good UX by allowing or disallowing accidental navigation
    to a feature module or a component before the module has loaded, or before any
    improper data requests have been made to the server. For example, when a manager
    logs in, they’re automatically routed to the `/manager/home` path. The browser
    will cache this URL, and it would be completely plausible for a clerk to accidentally
    navigate to the same URL. Angular doesn’t know whether a particular route is accessible
    to a user. Without an `authGuard`, it will happily render the manager’s home page
    and trigger server requests that will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the robustness of your frontend implementation, every REST or
    GraphQL API you implement should also be properly secured with **Role-based Access
    Control** (**RBAC**) on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the router so that `ProfileComponent` can’t be activated without
    an authenticated user, and the `ManagerModule` won’t load unless a manager logs
    in using an `authGuard`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement a functional `AuthGuard`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that all dependencies are being injected inline, using the inject function,
    which allows dependency injection outside of just the constructor of an `@Injectable`
    class, in this case, a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `c``anLoad` guard to prevent the loading of a lazily loaded module,
    such as the `manager''s` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this instance, when the `ManagerModule` is loaded, `authGuard` will be called
    during the `canLoad` event, and the `checkLogin` function will verify the authentication
    status of the user. If the guard returns `false`, the module will not be loaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can go further and provide additional metadata in the route definition, like
    `expectedRole`, which will be passed into the `checkLogin` function by the `canActivate`
    event. If a user is authenticated, but their role doesn’t match `Role.Manager`,
    `authGuard` will again return `false,` and the module will not be loaded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `canActivate` guard to prevent the activation of individual components,
    such as the user’s `profile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of `user-routing.module.ts`, `authGuard` is called during the `canActivate`
    event, and the `checkLogin` function controls where this route can be navigated.
    Since the user is viewing their own profile, there’s no need to check the user’s
    role here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `canActivate` or `canActivateChild` with an `expectedRole` property to
    prevent the activation of components by other users, such as `ManagerHomeComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside `ManagerModule`, we can verify whether the user can access a particular
    route. We can once again define some metadata, like `expectedRole`, so if a role
    doesn’t match `Role.Manager`, `authGuard` will return `false,` and the navigation
    will be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will review some techniques to implement unit tests to isolate dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Auth service fake and common testing providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to provide mocked versions of services like `AuthService` or `UiService`
    using the `commonTestingProviders` function in `common.testing.ts`, using a pattern
    similar to `commonTestingModules`, which was mentioned in *Chapter 4*, *Creating
    a Router-First Line-of-Business App*. This way, we won’t have to mock the same
    objects repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the spy objects using the `autoSpyObj` function from `angular-unit-test-helper`
    and go over some less obvious changes we need to implement to get our tests passing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `commonTestingProviders` in `common.testing.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the test double provided for the `MediaObserver` in `app.component.spec.ts`
    and update it to use `commonTestingModules`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how we use the spread syntax, `...`, to expand the `commonTestingModules`
    within another array. This way, when you need to add more items to the array,
    it is convenient to do so by just adding a `common` and another element next to
    it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don’t confuse the spread syntax, `…`, with this book’s use of ellipses, also
    `…`, to represent the existence of surrounding code in the snippets shared.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `spec` file for `LoginComponent` to leverage `commonTestingModules`
    and `commonTestingProviders`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go ahead and apply this technique to all `spec` files that have a dependency
    on `AuthService` and `UiService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The notable exception is services, as in `auth.service.spec.ts`, where you
    do *not* want to use a test double. Since `AuthService` is the class under test,
    make sure it is configured as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update `ui.service.spec.ts` with similar considerations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember, don’t move on until all your tests pass!
  prefs: []
  type: TYPE_NORMAL
- en: A Firebase authentication recipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can leverage our current authentication setup and integrate it with a real
    authentication service. For this section, you need a free Google and Firebase
    account. Firebase is Google’s comprehensive mobile development platform: [https://firebase.google.com](https://firebase.google.com).
    You can create a free account to host your application and leverage the Firebase
    authentication system.'
  prefs: []
  type: TYPE_NORMAL
- en: The Firebase console, found at [https://console.firebase.google.com](https://console.firebase.google.com),
    allows you to manage users and send a password reset email without implementing
    a backend for your application. Later, you can leverage Firebase functions to
    implement APIs in a serverless manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding your project to Firebase using the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a blue screen  Description automatically generated](img/B20960_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The Firebase console'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide your project name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable Google Analytics for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It helps to create a Google Analytics account before attempting this, but it
    should still work. Once your project is created, you should see your project dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The Firebase project overview'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, marked with **1**, you can see a menu of tools and services
    that you can add to your project. At the top, marked with **2**, you can quickly
    jump between your projects. Before doing so, you need to add an application to
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Firebase application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your project can include multiple distributions of your application, like web,
    iOS, and Android versions. In this chapter, we’re only interested in adding a
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: On your project dashboard, click on the web application button to add an application,
    which is marked with **3** in *Figure 6.9*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an application nickname.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the option to set up **Firebase Hosting**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by hitting the **Register app** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip over the **Add Firebase SDK** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the Firebase CLI as instructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sign in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure your current directory is your project’s root folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the **Hosting** option. Don’t worry; you can add more features later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the project you created as the default, that is, **lemon-mart-007**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Say yes to “Detected an existing Angular codebase in the current directory,
    should we use this?”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will create two new files: `firebase.json` and `.firebaserc`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build your project for production:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can deploy your Angular application by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your website should be available on a URL similar to [https://lemon-mart-007.firebaseapp.com](https://lemon-mart-007.firebaseapp.com),
    as shown in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Add the `.firebase` folder to `.gitignore` so that you don’t check in your cache
    files. The other two files, `firebase.json` and `.firebaserc`, are safe to commit.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, connect a custom domain name that you own to the account using the
    Firebase console.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Firebase authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s configure authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the **Build** menu and select **Authentication** from the side navigation:![A
    screenshot of a login page  Description automatically generated](img/B20960_06_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.10: The Firebase Authentication page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a sign-in method; select **Email/Password** as the provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not enable the email link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now see the user management console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: The Firebase user management console'
  prefs: []
  type: TYPE_NORMAL
- en: It is straightforward and intuitive to operate, so I will leave the configuration
    of it as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Firebase auth provider to Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by adding Angular Fire, the official Firebase library for Angular,
    to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Follow Angular Fire’s quick start guide to finish setting up the library with
    your Angular project, which you can find linked from the `README` file on GitHub
    at [https://github.com/angular/angularfire](https://github.com/angular/angularfire).
  prefs: []
  type: TYPE_NORMAL
- en: Ensure Firebase modules are provided in `app.config.ts` as per the documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy your Firebase `config` object to all of your `environment.ts` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that any information provided in `environment.ts` is public information.
    So when you place your Firebase API key in this file, it will be publicly available.
    There’s a small chance that another developer could abuse your API key and run
    up your bill. To protect yourself from any such attack, check out this blog post
    by Paachu: *How to secure your Firebase project even when your API key is publicly
    available* at [https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843](https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `FirebaseAuthService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename the service file `auth.firebase.service.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Be sure to remove `{ providedIn: ''root'' }`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement Firebase auth by extending the abstract auth service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we only had to implement the delta between our already established
    authentication code and Firebase’s authentication methods. We didn’t have to duplicate
    any code, and we had to transform a Firebase `user` object into our application’s
    internal user object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that in `transformFirebaseUser`, we set `role: Role.None` because Firebase
    authentication doesn’t implement the concept of a user role by default. To make
    the Firebase integration fully functional, you’d have to implement Firebase functions
    and a Firestore database so that you can store rich user profiles and perform
    CRUD operations on it. In this case, after authentication, you’d make another
    call to retrieve the role information. In *Chapter 7*, *Working with REST and
    GraphQL APIs*, we cover how to implement this within your custom API.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use Firebase authentication instead of in-memory authentication, update
    the `AuthService` provider in `app.config.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you’ve completed the steps, add a new user from the Firebase authentication
    console, and you should be able to log in using real authentication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always make sure that you’re using HTTPS when transmitting any kind of **Personally
    Identifiable Information** (**PII**) or sensitive information (like passwords)
    over the internet. Otherwise, your information will be logged on to third-party
    servers or captured by bad actors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once again, be sure to update your unit tests before moving on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stop! Remove the `fake-jwt-sign` package from your project before deploying
    a real authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Your application is integrated with Firebase! Next, let’s cover
    service factories, which can help you to switch the providers of your abstract
    classes dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a service using a factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can dynamically choose providers during load time, so instead of changing
    code to switch between authentication methods, you can parametrize environment
    variables so that different kinds of builds can have different authentication
    methods. This is especially useful when writing automated UI tests against your
    application, where real authentication can be difficult, if not impossible, to
    deal with.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create an `enum` in `environment.ts` to help define our options,
    and then we will use that `enum` to choose an auth provider during our application’s
    bootstrap process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `enum` called `AuthMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `authMode` property in `environment.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `authFactory` function in a new file under `auth/auth.factory.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the factory must import any dependent service, as shown above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `AuthService` provider in `app.config.ts` to use the factory instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you can remove imports of `InMemoryAuthService` and `FirebaseAuthService`
    from `app.config.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: With this configuration in place, whenever you build your application in development
    configuration, you will use the in-memory auth service, and production (prod)
    builds will use the Firebase auth service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now be familiar with how to create high-quality auth experiences.
    In this chapter, we designed a great conditional navigation experience that you
    can use in your own applications, by copying the base elements to your project
    and implementing your own auth provider. We created a reusable UI service so that
    you can conveniently show alerts in the flow-control logic of your application.
  prefs: []
  type: TYPE_NORMAL
- en: We covered route guards to prevent users from stumbling onto screens they are
    not authorized to use, and we reaffirmed the point that the real security of your
    application should be implemented on the server side. You saw how you can use
    a factory to dynamically provide different auth providers for different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented a real auth provider with Firebase. In *Chapter 7*,
    *Working with REST and GraphQL APIs*, we will review LemonMart Server, a full-stack
    implementation using the minimal MEAN stack with REST and GraphQL APIs. We will
    complete our authentication journey by learning how to implement a custom auth
    provider and implement RBAC for both the REST and GraphQL endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Angular @if block*: [https://angular.dev/api/core/@if](https://angular.dev/api/core/@if)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular. *CanActivate*. Angular. Retrieved from [https://angular.io/api/router/CanActivate](https://angular.io/api/router/CanActivate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular. *CanLoad*. Angular. Retrieved from [https://angular.io/api/router/CanLoad](https://angular.io/api/router/CanLoad)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vasconcelos, V. (2019, October 10). *Angular Router Guards: A Complete Guide*.
    Angular University. Retrieved from [https://blog.angular-university.io/angular-router-guards/](https://blog.angular-university.io/angular-router-guards/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularFire. *Getting started with AngularFire authentication*. GitHub. Retrieved
    from [https://github.com/angular/angularfire/blob/master/docs/auth/getting-started.md](https://blog.angular-university.io/angular-router-guards/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Davis, J. (2021, April 12). *Role-Based Authorization in Angular with Firebase*.
    InDepth. Retrieved from [https://indepth.dev/posts/1305/role-based-firebase-authentication-with-angular-8](https://indepth.dev/posts/1305/role-based-firebase-authentication-with-angular-8
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between RxJS’s `combineLatest` and `merge` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between `canActivate` and `canLoad` in the context of
    Angular route guards.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does dynamic UI rendering improve the user experience in role-based navigation
    systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits and potential drawbacks of using a service like Firebase
    Authentication for user management in a web application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe a scenario where a service factory can be particularly useful in an
    Angular application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
