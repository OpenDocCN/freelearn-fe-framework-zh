<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer050">
<h1 class="chapter-number" id="_idParaDest-262"><a id="_idTextAnchor322"/>16</h1>
<h1 id="_idParaDest-263"><a id="_idTextAnchor323"/>Working with WebSockets</h1>
<p>In this chapter, we’ll look at how to test-drive the WebSocket API within our React app. We’ll use it to build a teaching mechanism whereby one person can share their screen and others can watch as they type out commands.</p>
<p>The WebSocket API isn’t straightforward. It uses a number of different callbacks and requires functions to be called in a certain order. To make things harder, we’ll do this all within a Redux saga: that means we’ll need to do some work to convert the callback API to one that can work with generator functions.</p>
<p>Because this is the last chapter covering unit testing techniques, it does things a little differently. It doesn’t follow a strict TDD process. The starting point for this chapter has a skeleton of our functions already completed. You’ll flesh out these functions, concentrating on learning test-driven techniques for WebSocket connections.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Designing a WebSocket interaction</li>
<li>Test-driving a WebSocket connection</li>
<li>Streaming events with redux-saga</li>
<li>Updating the app</li>
</ul>
<p>By the end of the chapter, you’ll have learned how the WebSocket API works along with its unit testing mechanisms.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor324"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter16">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter16</a></p>
<h1 id="_idParaDest-265"><a id="_idTextAnchor325"/>Designing a WebSocket interaction</h1>
<p>In this section, we’ll <a id="_idIndexMarker1427"/>start by describing the sharing workflow, then we’ll look at the new UI elements that support this workflow, and finally we’ll walk through the code changes you’ll make in this chapter.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor326"/>The sharing workflow</h2>
<p>A sharing <a id="_idIndexMarker1428"/>session is made up of one presenter and zero or more watchers. That means there are two modes that the app can be in: either <strong class="bold">presenting</strong> or <strong class="bold">watching</strong>.</p>
<p>When the app is in presenting mode, then everyone watching will get a copy of your Spec Logo instructions. All your instructions are sent to the server via a WebSocket.</p>
<p>When your app is in watching mode, a WebSocket receives instructions from the server and immediately outputs them onto your screen.</p>
<p>The messages sent to and from the server are simple JSON-formatted data structures.</p>
<p><em class="italic">Figure 16.1</em> shows how the interface looks when it’s in presenter mode.</p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 16.1 – Spec Logo in presenter mode " height="1215" src="image/Figure_16.01_B18423.jpg" width="1595"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – Spec Logo in presenter mode</p>
<p>So, how <a id="_idIndexMarker1429"/>does it work?</p>
<ol>
<li>The presenter clicks the <strong class="bold">Start sharing</strong> button. The server is sent the following message:<p class="source-code">{ type: "START_SHARING" }</p></li>
<li>The server then responds with the ID of the session:<p class="source-code">{ status: "STARTED", id: 123 }</p></li>
<li>This ID is used to construct a URL that opens the application in watching mode, for example:<p class="source-code">http://localhost:3000/index.xhtml?watching=123</p></li>
<li>The URL can be shared and opened anywhere. When the application is opened in this mode, the application immediately opens a WebSocket to the server and sends this message:<p class="source-code">{ type: "START_WATCHING", id: 123 }</p></li>
<li>There can be any number of watchers that connect. On an initial connection, any commands that the presenter has already sent to the server will be replayed. Those commands are sent from the presenter for any Redux action of type <strong class="source-inline">SUBMIT_EDIT_LINE</strong>, and they are sent via the WebSocket to the server like <a id="_idIndexMarker1430"/>this:<p class="source-code">{</p><p class="source-code">  type: "NEW_ACTION",</p><p class="source-code">  innerAction: {</p><p class="source-code">    type: "SUBMIT_EDIT_LINE",</p><p class="source-code">    text: "forward 10\n"</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>When the server receives actions on the presenter’s WebSocket, it immediately forwards the actions to every subscriber:<p class="source-code">{ type: "SUBMIT_EDIT_LINE", text: "forward 10\n" } }</p></li>
<li>The server also stores received actions in history, so the actions can be replayed by new joiners.</li>
<li>When the watcher is done, they simply need to close the browser window and their WebSocket will close.</li>
<li>When the presenter is done, they can either close the browser window or hit the <strong class="bold">Stop sharing</strong> button. This closes the connection and the server clears out its internal stat<a id="_idTextAnchor327"/>e.</li>
</ol>
<h2 id="_idParaDest-267"><a id="_idTextAnchor328"/>The new UI elements</h2>
<p>Here’s what <a id="_idIndexMarker1431"/>you’ll <a id="_idIndexMarker1432"/>find in the UI; all of this has already been built for you:</p>
<ul>
<li>A new menu button to toggle sharing on and off. It is named <strong class="bold">Start sharing</strong>, but once sharing has started, the name switches to <strong class="bold">Stop sharing</strong>.</li>
<li>There is a new message that appears as part of the menu buttons bar when Spec Logo is in sharing mode. It contains a message telling the user whether they are presenting or watching. If they are presenting, it also contains a URL that they can copy and share with others.</li>
<li>You can now launch the app in watching mode by adding the search parameter <strong class="source-inline">?watching=&lt;id&gt;</strong> to the end of the Spec Logo URL.</li>
</ul>
<p>Next, let’s have a look at the skeleton of the Redux saga that you’ll be fleshing <a id="_idTextAnchor329"/>out.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor330"/>Splitting apart the saga</h2>
<p>A new <a id="_idIndexMarker1433"/>piece <a id="_idIndexMarker1434"/>of Redux middleware exists in the file <strong class="source-inline">src/middleware/sharingSagas.js</strong>. This file has two parts to it. First, there’s a middleware function named <strong class="source-inline">duplicateForSharing</strong>. This is a filter that provides us with all the actions that we wish to broadcast:</p>
<pre class="source-code">
export const duplicateForSharing =
  store =&gt; next =&gt; action =&gt; {
    if (action.type === "SUBMIT_EDIT_LINE") {
      store.dispatch({
        type: "SHARE_NEW_ACTION",
        innerAction: action,
      });
    }
    return next(action);
  };</pre>
<p>Second, there’s the root saga itself. It’s split into four smaller functions, and these are the functions we’ll fill out in this chapter, using a test-driven approach:</p>
<pre class="source-code">
export function* sharingSaga() {
  yield takeLatest("TRY_START_WATCHING", startWatching);
  yield takeLatest("START_SHARING", startSharing);
  yield takeLatest("STOP_SHARING", stopSharing);
  yield takeLatest("SHARE_NEW_ACTION", shareNewActi<a id="_idTextAnchor331"/>on);
}</pre>
<p>With enough <a id="_idIndexMarker1435"/>of the design done, let’s get<a id="_idIndexMarker1436"/> cracking with the implementation.</p>
<h1 id="_idParaDest-269"><a id="_idTextAnchor332"/>Test-driving a WebSocket connection</h1>
<p>We start by filling out that <a id="_idIndexMarker1437"/>first function, <strong class="source-inline">startSharing</strong>. This function is invoked when the <strong class="source-inline">START_SHARING</strong> action is received. That action is triggered when the user clicks the <strong class="bold">Start sharing</strong> button:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/middleware/sharingSagas.test.js</strong> and add the following imports at the top:<p class="source-code">import { storeSpy, expectRedux } from "expect-redux";</p><p class="source-code">import { act } from "react-dom/test-utils";</p><p class="source-code">import { configureStore } from "../../src/store";</p></li>
<li>At the bottom of the file, add a new <strong class="source-inline">describe</strong> block and its setup. We’ll break this into a couple of steps: first, set up the Redux store and the WebSocket spy. Because <strong class="source-inline">window.WebSocket</strong> is a<a id="_idIndexMarker1438"/> constructor function, we use <strong class="source-inline">mockImplementation</strong> to stub it out: <p class="source-code">describe("sharingSaga", () =&gt; {</p><p class="source-code">  let store;</p><p class="source-code">  let socketSpyFactory;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    store = configureStore([storeSpy]);</p><p class="source-code">    socketSpyFactory = spyOn(window, "WebSocket");</p><p class="source-code">    socketSpyFactory.mockImplementation(() =&gt; {</p><p class="source-code">      return {};</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Understanding the WebSocket API</p>
<p class="callout">The WebSocket<a id="_idIndexMarker1439"/> constructor <a id="_idIndexMarker1440"/>returns an <a id="_idIndexMarker1441"/>object with <strong class="source-inline">send</strong> and <strong class="source-inline">close</strong> methods, plus <strong class="source-inline">onopen</strong>, <strong class="source-inline">onmessage</strong>, <strong class="source-inline">onclose</strong>, and <strong class="source-inline">onerror</strong> event handlers. We’ll implement most of these on our test double as we build out our test suite. If you’d like to learn more about the WebSocket API, check out the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<ol>
<li value="3">Next, because <a id="_idIndexMarker1442"/>we’re also concerned with the window location, we also need to stub out<a id="_idIndexMarker1443"/> the <strong class="source-inline">window.location</strong> object. Because this is a read-only object in the JSDOM environment, we need to use the <strong class="source-inline">Object.defineProperty</strong> function to override it. This is a little clunky, so you may prefer to extract that into its own function with a good name. Add the following into the same <strong class="source-inline">beforeEach</strong> block:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  Object.defineProperty(window, "location", {</p><p class="source-code">    writable: true,</p><p class="source-code">      value: {</p><p class="source-code">        protocol: "http:",</p><p class="source-code">        host: "test:1234",</p><p class="source-code">        pathname: "/index.xhtml",</p><p class="source-code">      },</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Add the first test in a nested <strong class="source-inline">describe</strong> block. This checks that we make the WebSocket<a id="_idIndexMarker1444"/> connection with the right URL:<p class="source-code">describe("START_SHARING", () =&gt; {</p><p class="source-code">  it("opens a websocket when starting to share", () =&gt; {</p><p class="source-code">    store.dispatch({ type: "START_SHARING" });</p><p class="source-code">    expect(socketSpyFactory).toBeCalledWith(</p><p class="source-code">      "ws://test:1234/share"</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by filling in the <strong class="source-inline">startSharing</strong> generator function in the file <strong class="source-inline">src/middleware/sharingSagas.js</strong> (remembering that the skeleton has already been created for you). This code constructs a new URL with the right host:<p class="source-code">function* startSharing() {</p><p class="source-code"><strong class="bold">  const { host } = window.location;</strong></p><p class="source-code"><strong class="bold">  new WebSocket(`ws://${host}/share`);</strong></p><p class="source-code">}</p></li>
<li>Back in the test suite, modify the WebSocket stub implementation to add an inner spy, <strong class="source-inline">sendSpy</strong>, which will be called when the user calls the <strong class="source-inline">send</strong> function on the WebSocket. We also need to store a reference to the <strong class="source-inline">socketSpy</strong> function that’s created, so we can call the callbacks that the user attaches to its event handlers (such as <strong class="source-inline">onopen</strong> and <strong class="source-inline">onmessage</strong>). This will make sense when we write <a id="_idIndexMarker1445"/>the next test:<p class="source-code"><strong class="bold">let sendSpy;</strong></p><p class="source-code"><strong class="bold">let socketSpy;</strong></p><p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  <strong class="bold">sendSpy = jest.fn();</strong></p><p class="source-code">  socketSpyFactory = spyOn(window, "WebSocket");</p><p class="source-code">  socketSpyFactory.mockImplementation(() =&gt; {</p><p class="source-code"><strong class="bold">    socketSpy = {</strong></p><p class="source-code"><strong class="bold">      send: sendSpy,</strong></p><p class="source-code"><strong class="bold">    };</strong></p><p class="source-code"><strong class="bold">    return socketSpy;</strong></p><p class="source-code">  });</p><p class="source-code">...</p><p class="source-code">}</p></li>
<li>When test-driving an API with callbacks, such as the WebSocket API, it’s important that we mimic the exact behavior of each callback. We will start with the <strong class="source-inline">onopen</strong> callback. The next test will trigger this as if it was a server sending a message. Because we expect a bunch of asynchronous actions to occur when <strong class="source-inline">onopen</strong> is received, we can use <strong class="source-inline">async act</strong> to wait for the actions to be completed. So, before the next test, define the following function, which triggers the <strong class="source-inline">onopen</strong> callback:<p class="source-code">const notifySocketOpened = async () =&gt; {</p><p class="source-code">  await act(async () =&gt; {</p><p class="source-code">    socketSpy.onopen();</p><p class="source-code">  });</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">Using act with non-React code</p>
<p class="callout">The <strong class="source-inline">async act</strong> function<a id="_idIndexMarker1446"/> helps us even when we’re not dealing with React components because it waits for promises to run before returning.</p>
<ol>
<li value="8">We can<a id="_idIndexMarker1447"/> then use the <strong class="source-inline">notifySocketOpened</strong> function in our next test, which checks that when the client receives a <strong class="source-inline">START_SHARING</strong> action, it immediately forwards it onto the server:<p class="source-code">it("dispatches a START_SHARING action to the socket", async () =&gt; {</p><p class="source-code">  store.dispatch({ type: "START_SHARING" });</p><p class="source-code">  await notifySocketOpened();</p><p class="source-code">  expect(sendSpy).toBeCalledWith(</p><p class="source-code">    JSON.stringify({ type: "START_SHARING" })</p><p class="source-code"> );</p><p class="source-code">});</p></li>
<li>To make that pass, start by extracting the existing code in the <strong class="source-inline">startSharing</strong> function into a new function named <strong class="source-inline">openWebsocket</strong>. Then, add in code that invokes a <strong class="source-inline">Promise</strong> object that resolves when the <strong class="source-inline">onopen</strong> message is received on the socket. This code is fairly difficult—we’re building a <strong class="source-inline">Promise</strong> object specifically to adapt the callback-based API into something that we can use with the generator <strong class="source-inline">yield</strong> keyword:<p class="source-code"><strong class="bold">const openWebSocket = () =&gt; {</strong></p><p class="source-code">  const { host } = window.location;</p><p class="source-code">  const socket = new WebSocket(`ws://${host}/share`);</p><p class="source-code"><strong class="bold">  return new Promise(resolve =&gt; {</strong></p><p class="source-code"><strong class="bold">    socket.onopen = () =&gt; {</strong></p><p class="source-code"><strong class="bold">      resolve(socket)</strong></p><p class="source-code"><strong class="bold">    };</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>You can now<a id="_idIndexMarker1448"/> make use of that <strong class="source-inline">openWebSocket</strong> function in <strong class="source-inline">startSharing</strong>. After this, your test should pass:<p class="source-code">function* startSharing() {</p><p class="source-code"><strong class="bold">  const presenterSocket = yield openWebSocket();</strong></p><p class="source-code"><strong class="bold">  presenterSocket.send(</strong></p><p class="source-code"><strong class="bold">    JSON.stringify({ type: "START_SHARING" })</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code">}</p></li>
<li>The next test will send a message over the socket from the server to the app. For this, we need a helper function to mimic sending a message and wait to empty the current task queue of tasks. Add this helper to <strong class="source-inline">test/middleware/sharingSagas.test.js</strong>, just below <strong class="source-inline">notifySocketOpened</strong>:<p class="source-code">const sendSocketMessage = async message =&gt; {</p><p class="source-code">  await act(async () =&gt; {</p><p class="source-code">    socketSpy.onmessage({</p><p class="source-code">     data: JSON.stringify(message)</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Add the<a id="_idIndexMarker1449"/> next test, using the function you’ve just defined:<p class="source-code">it("dispatches an action of STARTED_SHARING with a URL containing the id that is returned from the server",   async () =&gt; {</p><p class="source-code">  store.dispatch({ type: "START_SHARING" });</p><p class="source-code">  await notifySocketOpened();</p><p class="source-code">  await sendSocketMessage({</p><p class="source-code">    type: "UNKNOWN",</p><p class="source-code">    id: 123,</p><p class="source-code">  });</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({</p><p class="source-code">      type: "STARTED_SHARING",</p><p class="source-code">      url: "http://test:1234/index.xhtml?watching=123",</p><p class="source-code">    });</p><p class="source-code">});</p></li>
<li>To make this pass, we’ll read the message from the socket. Once that’s done, we can pass the retrieved information back to the Redux store. Start by adding the following new functions at the top of <strong class="source-inline">src/middleware/sharingSagas.js</strong>:<p class="source-code">const receiveMessage = (socket) =&gt;</p><p class="source-code">  new Promise(resolve =&gt; {</p><p class="source-code">    socket.onmessage = evt =&gt; {</p><p class="source-code">      resolve(evt.data)</p><p class="source-code">    };</p><p class="source-code">  });</p><p class="source-code">const buildUrl = (id) =&gt; {</p><p class="source-code">  const {</p><p class="source-code">    protocol, host, pathname</p><p class="source-code">  } = window.location;</p><p class="source-code">  return (</p><p class="source-code">    `${protocol}//${host}${pathname}?watching=${id}`</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Now you can<a id="_idIndexMarker1450"/> use those functions to finish the implementation of <strong class="source-inline">startSharing</strong>:<p class="source-code">function* startSharing() {</p><p class="source-code">  const presenterSocket = yield openWebSocket();</p><p class="source-code">  presenterSocket.send(</p><p class="source-code">    JSON.stringify({ type: "START_SHARING" })</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  const message = yield receiveMessage(</strong></p><p class="source-code"><strong class="bold">    presenterSocket</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">  const presenterSessionId = JSON.parse(message).id;</strong></p><p class="source-code"><strong class="bold">  yield put({</strong></p><p class="source-code"><strong class="bold">    type: "STARTED_SHARING",</strong></p><p class="source-code"><strong class="bold">    url: buildUrl(presenterSessionId),</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">}</p></li>
</ol>
<p>That’s it for the process of starting to share. Now let’s deal with what happens when the user clicks the <strong class="bold">Stop sharing</strong> button:</p>
<ol>
<li value="1">Create a helper <a id="_idIndexMarker1451"/>function inside the  <strong class="source-inline">describe</strong> block named <strong class="source-inline">sharingSaga</strong>, as shown. This function will change the system to a state of <strong class="source-inline">STARTED_SHARING</strong>:<p class="source-code">const startSharing = async () =&gt; {</p><p class="source-code">  store.dispatch({ type: "START_SHARING" });</p><p class="source-code">  await notifySocketOpened();</p><p class="source-code">  await sendSocketMessage({</p><p class="source-code">    type: "UNKNOWN",</p><p class="source-code">    id: 123,</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Update the spy to include a <strong class="source-inline">closeSpy</strong> variable, which we set up in the same way as <strong class="source-inline">sendSpy</strong>:<p class="source-code"><strong class="bold">let closeSpy;</strong></p><p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  sendSpy = jest.fn();</p><p class="source-code"><strong class="bold">  closeSpy = jest.fn();</strong></p><p class="source-code">  socketSpyFactory = spyOn(window, "WebSocket");</p><p class="source-code">  socketSpyFactory.mockImplementation(() =&gt; {</p><p class="source-code">    socketSpy = {</p><p class="source-code">      send: sendSpy,</p><p class="source-code"><strong class="bold">      close: closeSpy,</strong></p><p class="source-code">    };</p><p class="source-code">    return socketSpy;</p><p class="source-code">  });</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>Add the first test <a id="_idIndexMarker1452"/>in a new nested context. It begins by starting sharing and then dispatches the <strong class="source-inline">STOP_SHARING</strong> action:<p class="source-code">describe("STOP_SHARING", () =&gt; {</p><p class="source-code">  it("calls close on the open socket", async () =&gt; {</p><p class="source-code">    await startSharing();</p><p class="source-code">    store.dispatch({ type: "STOP_SHARING" });</p><p class="source-code">    expect(closeSpy).toBeCalled();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make this pass, we’ll fill out the <strong class="source-inline">stopSharing</strong> generator function. First, however, we need to get access to the socket that we created within the <strong class="source-inline">startSharing</strong> function. Extract that variable into the top-level namespace:<p class="source-code"><strong class="bold">let presenterSocket;</strong></p><p class="source-code">function* startSharing() {</p><p class="source-code"><strong class="bold">  presenterSocket =</strong> yield openWebSocket();</p><p class="source-code">  ...</p><p class="source-code">}</p></li>
<li>Then, add the following definition to the <strong class="source-inline">stopSharing</strong> function. You can then run your tests, and everything should pass; however, if you’re running your entire test suite (with <strong class="source-inline">npm test</strong>), you’ll see a couple of console errors appear. These are coming from one test in the <strong class="source-inline">MenuButtons</strong> test suite—we will fix this in<a id="_idIndexMarker1453"/> the <em class="italic">Updating the app</em> section later:<p class="source-code">function* stopSharing() {</p><p class="source-code">  <strong class="bold">presenterSocket.close();</strong></p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Running tests in just a single suite</p>
<p class="callout">To avoid seeing the console errors, remember you can opt to run tests for this test suite only using the command <strong class="source-inline">npm test test/middleware/sharingSagas.test.js</strong>.</p>
<ol>
<li value="6">Moving on to the next test, we want to update the Redux store with the new <strong class="source-inline">stopped</strong> status. This will allow us to remove the message that appeared to the user when they began sharing:<p class="source-code">it("dispatches an action of STOPPED_SHARING", async () =&gt; {</p><p class="source-code">  await startSharing();</p><p class="source-code">  store.dispatch({ type: "STOP_SHARING" });</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "STOPPED_SHARING" });</p><p class="source-code">});</p></li>
<li>That’s a simple one-liner to make pass:<p class="source-code">function* stopSharing() {</p><p class="source-code">  presenterSocket.close();</p><p class="source-code">  <strong class="bold">yield put({ type: "STOPPED_SHARING" });</strong></p><p class="source-code">}</p></li>
</ol>
<p>Next up is broadcasting actions from the presenter to the server:</p>
<ol>
<li value="1">Create a <a id="_idIndexMarker1454"/>new nested <strong class="source-inline">describe</strong> block with the following test:<p class="source-code">describe("SHARE_NEW_ACTION", () =&gt; {</p><p class="source-code">  it("forwards the same action on to the socket", async () =&gt; {</p><p class="source-code">    const innerAction = { a: 123 };</p><p class="source-code">    await startSharing(123);</p><p class="source-code">    store.dispatch({</p><p class="source-code">      type: "SHARE_NEW_ACTION",</p><p class="source-code">      innerAction,</p><p class="source-code">    });</p><p class="source-code">    expect(sendSpy).toHaveBeenLastCalledWith(</p><p class="source-code">      JSON.stringify({</p><p class="source-code">        type: "NEW_ACTION",</p><p class="source-code">        innerAction,</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make it pass by filling in the following content for the <strong class="source-inline">shareNewAction</strong> function:<p class="source-code">const shareNewAction = ({ innerAction }) =&gt; {</p><p class="source-code"><strong class="bold">  presenterSocket.send(</strong></p><p class="source-code"><strong class="bold">    JSON.stringify({</strong></p><p class="source-code"><strong class="bold">      type: "NEW_ACTION",</strong></p><p class="source-code"><strong class="bold">      innerAction,</strong></p><p class="source-code"><strong class="bold">    })</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code">}</p></li>
<li>Add the next test, which<a id="_idIndexMarker1455"/> checks that we do not send any actions if the user isn’t presenting:<p class="source-code">it("does not forward if the socket is not set yet", () =&gt; {</p><p class="source-code">  store.dispatch({ type: "SHARE_NEW_ACTION" });</p><p class="source-code">  expect(sendSpy).not.toBeCalled();</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Using not.toBeCalled in an asynchronous environment</p>
<p class="callout">This test has<a id="_idIndexMarker1456"/> a subtle issue. Although it will help you add to the design of your software, it’s slightly less useful as a regression test because it <em class="italic">could</em> potentially result in false positives. This test guarantees that something doesn’t happen between the start and the end of the test, but it makes no guarantees about what happens <em class="italic">after</em>. Such is the nature of the async environment.</p>
<ol>
<li value="4">Making this test pass is simply a matter of adding a conditional around the code we have:<p class="source-code">function* shareNewAction({ innerAction } ) {</p><p class="source-code">  <strong class="bold">if (presenterSocket) {</strong></p><p class="source-code">    presenterSocket.send(</p><p class="source-code">      JSON.stringify({</p><p class="source-code">        type: "NEW_ACTION",</p><p class="source-code">        innerAction,</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">  <strong class="bold">}</strong></p><p class="source-code">}</p></li>
<li>We also don’t want <a id="_idIndexMarker1457"/>to share the action if the user has stopped sharing—so let’s add that in:<p class="source-code">it("does not forward if the socket has been closed", async () =&gt; {</p><p class="source-code">  await startSharing();</p><p class="source-code">  socketSpy.readyState = WebSocket.CLOSED;</p><p class="source-code">  store.dispatch({ type: "SHARE_NEW_ACTION" });</p><p class="source-code">  expect(sendSpy.mock.calls).toHaveLength(1);</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">The WebSocket specification</p>
<p class="callout">The constant in the preceding test, <strong class="source-inline">WebSocket.CLOSED</strong>, and the constant in the following code, <strong class="source-inline">WebSocket.OPEN</strong>, are defined in the WebSocket specification.</p>
<ol>
<li value="6">Move to the top of the test file and define the following two constants, underneath your imports. These are needed because when we spy on the WebSocket constructor, we overwrite these values. So, we need to add them back in. Start by saving the real values:<p class="source-code">const WEB_SOCKET_OPEN = WebSocket.OPEN;</p><p class="source-code">const WEB_SOCKET_CLOSED = WebSocket.CLOSED;</p></li>
<li>Update your spy to set these constants once <strong class="source-inline">WebSocket</strong> has been stubbed. While we’re here, let’s also set the default <strong class="source-inline">readyState</strong> for a socket to be <strong class="source-inline">WebSocket.OPEN</strong>, which <a id="_idIndexMarker1458"/>means our other tests won’t break:<p class="source-code">socketSpyFactory = jest.spyOn(window, "WebSocket");</p><p class="source-code"><strong class="bold">Object.defineProperty(socketSpyFactory, "OPEN", {</strong></p><p class="source-code"><strong class="bold">  value: WEB_SOCKET_OPEN</strong></p><p class="source-code"><strong class="bold">});</strong></p><p class="source-code"><strong class="bold">Object.defineProperty(socketSpyFactory, "CLOSED", {</strong></p><p class="source-code"><strong class="bold">  value: WEB_SOCKET_CLOSED</strong></p><p class="source-code"><strong class="bold">});</strong></p><p class="source-code">socketSpyFactory.mockImplementation(() =&gt; {</p><p class="source-code">  socketSpy = {</p><p class="source-code">    send: sendSpy,</p><p class="source-code">    close: closeSpy,</p><p class="source-code"><strong class="bold">    readyState: WebSocket.OPEN,</strong></p><p class="source-code">  };</p><p class="source-code">  return socketSpy;</p><p class="source-code">});</p></li>
<li>Finally, back in the production code, make the test pass by checking if <strong class="source-inline">readyState</strong> is <strong class="source-inline">WebSocket.OPEN</strong>, which is not exactly what the test specified, but it’s good enough to make it pass:<p class="source-code">const shareNewAction = ({ innerAction }) =&gt; {</p><p class="source-code">  if (</p><p class="source-code">    presenterSocket<strong class="bold"> &amp;&amp;</strong></p><p class="source-code"><strong class="bold">    presenterSocket.readyState === WebSocket.OPEN</strong></p><p class="source-code">  ) {</p><p class="source-code">    presenterSocket.send(</p><p class="source-code">      JSON.stringify({</p><p class="source-code">        type: "NEW_ACTION",</p><p class="source-code">        innerAction,</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>That’s it for the presenter behavior: we <a id="_idIndexMarker1459"/>have<a id="_idIndexMarker1460"/> test-driven<a id="_idIndexMarker1461"/> the <strong class="source-inline">onopen</strong>, <strong class="source-inline">onclose</strong>, and <strong class="source-inline">onmessage</strong> callbacks. In <a id="_idIndexMarker1462"/>a real-world application, you would want to follow the same process for the <strong class="source-inline">onerror</strong> callback.</p>
<p>Now let<a id="_idTextAnchor333"/>’s look at the watcher’s behavior.</p>
<h1 id="_idParaDest-270"><a id="_idTextAnchor334"/>Streaming events with redux-saga</h1>
<p>We’ll repeat a<a id="_idIndexMarker1463"/> lot of the same techniques in this section. There are two new concepts: first, pulling out the <strong class="source-inline">search</strong> param for the watcher ID, and second, using <strong class="source-inline">eventChannel</strong> to subscribe to the <strong class="source-inline">onmessage</strong> callback. This is used to continually stream messages from the WebSocket into the Redux store.</p>
<p>Let’s being by specifying the new URL behavior:</p>
<ol>
<li value="1">Write a new <strong class="source-inline">describe</strong> block at the bottom of <strong class="source-inline">test/middleware/sharingSagas.test.js</strong>, but <a id="_idIndexMarker1464"/>still nested inside the main <strong class="source-inline">describe</strong> block:<p class="source-code">describe("watching", () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    Object.defineProperty(window, "location", {</p><p class="source-code">      writable: true,</p><p class="source-code">      value: {</p><p class="source-code">        host: "test:1234",</p><p class="source-code">        pathname: "/index.xhtml",</p><p class="source-code">        search: "?watching=234"</p><p class="source-code">      }</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">  it("opens a socket when the page loads", () =&gt; {</p><p class="source-code">    store.dispatch({ type: "TRY_START_WATCHING" });</p><p class="source-code">    expect(socketSpyFactory).toBeCalledWith(</p><p class="source-code">      "ws://test:1234/share"</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make it pass by filling out the <strong class="source-inline">startWatching</strong> function in your production code. You can make use of the existing <strong class="source-inline">openWebSocket</strong> function:<p class="source-code">function* startWatching() {</p><p class="source-code">  <strong class="bold">yield openWebSocket();</strong></p><p class="source-code">}</p></li>
<li>In the next test, we’ll begin to make use of the <strong class="source-inline">search</strong> param:<p class="source-code">it("does not open socket if the watching field is not set", () =&gt; {</p><p class="source-code">  window.location.search = "?";</p><p class="source-code">  store.dispatch({ type: "TRY_START_WATCHING" });</p><p class="source-code">  expect(socketSpyFactory).not.toBeCalled();</p><p class="source-code">});</p></li>
<li>Make it pass<a id="_idIndexMarker1465"/> by extracting the <strong class="source-inline">search</strong> param using the <strong class="source-inline">URLSearchParams</strong> object:<p class="source-code">function* startWatching() {</p><p class="source-code"><strong class="bold">  const sessionId = new URLSearchParams(</strong></p><p class="source-code"><strong class="bold">    window.location.search.substring(1)</strong></p><p class="source-code"><strong class="bold">  ).get("watching");</strong></p><p class="source-code"><strong class="bold">  if (sessionId) {</strong></p><p class="source-code">    yield openWebSocket();</p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}</p></li>
<li>Before we write the next test, add the following helper function, which mimics the action that will occur on the real WebSocket, ensuring that <strong class="source-inline">onopen</strong> is called:<p class="source-code">const startWatching = async () =&gt; {</p><p class="source-code">  await act(async () =&gt; {</p><p class="source-code">    store.dispatch({ type: "TRY_START_WATCHING" });</p><p class="source-code">    socketSpy.onopen();</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>When a new <a id="_idIndexMarker1466"/>watch session has started, we need to reset the user’s output so that it is blank:<p class="source-code">it("dispatches a RESET action", async () =&gt; {</p><p class="source-code">  await startWatching();</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "RESET" });</p><p class="source-code">});</p></li>
<li>Make it pass by adding in a <strong class="source-inline">put</strong> function call:<p class="source-code">function* startWatching() {</p><p class="source-code">  const sessionId = new URLSearchParams(</p><p class="source-code">    location.search.substring(1)</p><p class="source-code">  ).get("watching");</p><p class="source-code">  if (sessionId) {</p><p class="source-code">    yield openWebSocket();</p><p class="source-code">    <strong class="bold">yield put({ type: "RESET" });</strong></p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Next, we need to send a message to the server, including the ID of the session we wish to watch:<p class="source-code">it("sends the session id to the socket with an action type of START_WATCHING", async () =&gt; {</p><p class="source-code">  await startWatching();</p><p class="source-code">  expect(sendSpy).toBeCalledWith(</p><p class="source-code">    JSON.stringify({</p><p class="source-code">      type: "START_WATCHING",</p><p class="source-code">      id: "234",</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>We already <a id="_idIndexMarker1467"/>have our spy set up from the previous section, so this is a quick one to fix:<p class="source-code">function* startWatching() {</p><p class="source-code">  const sessionId = new URLSearchParams(</p><p class="source-code">    window.location.search.substring(1)</p><p class="source-code">  ).get("watching");</p><p class="source-code">  if (sessionId) {</p><p class="source-code">    <strong class="bold">const watcherSocket =</strong> yield openWebSocket();</p><p class="source-code">    yield put({ type: "RESET" });</p><p class="source-code">    watcherSocket.send(</p><p class="source-code">    <strong class="bold">  JSON.stringify({</strong></p><p class="source-code"><strong class="bold">        type: "START_WATCHING",</strong></p><p class="source-code"><strong class="bold">        id: sessionId,</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code"><strong class="bold">    </strong>);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>The next test tells the Redux store that we have started watching. This will then allow the React UI to display a message to the user telling them that they are connected:<p class="source-code">it("dispatches a STARTED_WATCHING action", async () =&gt; {</p><p class="source-code">  await startWatching();</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "STARTED_WATCHING" });</p><p class="source-code">});</p></li>
<li>Make that <a id="_idIndexMarker1468"/>pass by adding a new call to <strong class="source-inline">put</strong>, as shown:<p class="source-code">function* startWatching() {</p><p class="source-code">  ...</p><p class="source-code">  if (sessionId) {</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">yield put({ type: "STARTED_WATCHING" });</strong></p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Now the big one. We need to add in the behavior that allows us to receive multiple messages from the server and read them in:<p class="source-code">it("relays multiple actions from the websocket", async () =&gt; {</p><p class="source-code">  const message1 = { type: "ABC" };</p><p class="source-code">  const message2 = { type: "BCD" };</p><p class="source-code">  const message3 = { type: "CDE" };</p><p class="source-code">  await startWatching();</p><p class="source-code">  await sendSocketMessage(message1);</p><p class="source-code">  await sendSocketMessage(message2);</p><p class="source-code">  await sendSocketMessage(message3);</p><p class="source-code">  await expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching(message1);</p><p class="source-code">  await expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching(message2);</p><p class="source-code">  await expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching(message3);</p><p class="source-code">  socketSpy.onclose();</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Long tests</p>
<p class="callout">You may think it would help to have a smaller test that handles just one message. However, that won’t help us for multiple messages, as we need to use an entirely different implementation for multiple messages, as you’ll see in the next step.</p>
<ol>
<li value="13">We’ll use the <strong class="source-inline">eventChannel</strong> function to do this. Its usage is similar to the earlier <strong class="source-inline">Promise</strong> object usage when we converted a callback to an operation that could be awaited with <strong class="source-inline">yield</strong>. With the <strong class="source-inline">Promise</strong> object, we called <strong class="source-inline">resolve</strong> when the callback was received. With <strong class="source-inline">eventChannel</strong>, when the callback is received, we invoke <strong class="source-inline">emitter(END)</strong>. The significance of this will become <a id="_idIndexMarker1469"/>apparent in the next step:<p class="source-code">import { eventChannel, END } from "redux-saga";</p><p class="source-code">const webSocketListener = socket =&gt;</p><p class="source-code">  eventChannel(emitter =&gt; {</p><p class="source-code">    socket.onmessage = emitter;</p><p class="source-code">    socket.onclose = () =&gt; emitter(END);</p><p class="source-code">    return () =&gt; {</p><p class="source-code">      socket.onmessage = undefined;</p><p class="source-code">      socket.onclose = undefined;</p><p class="source-code">    };</p><p class="source-code">  });</p></li>
</ol>
<p class="callout-heading">Understanding the eventChannel function</p>
<p class="callout">The <strong class="source-inline">eventChannel</strong> functio<a id="_idIndexMarker1470"/>n from <strong class="source-inline">redux-saga</strong> is a mechanism for consuming event streams that occur outside of Redux. In the preceding example, the WebSocket provides the stream of events. When invoked, <strong class="source-inline">eventChannel</strong> calls the provided function to initialize the channel, then the provided <strong class="source-inline">emmitter</strong> function must be called each time an event is received. In our case, we pass the message directly to the <strong class="source-inline">emmitter</strong> function without modification. When the WebSocket is closed, we pass the special <strong class="source-inline">END</strong> event to signal to <strong class="source-inline">redux-saga</strong> that no more events will be received, allowing it to close the channel. </p>
<ol>
<li value="14">Now you can use the <strong class="source-inline">websocketListener</strong> function to create a channel that we can repeatedly take events from using a loop. This loop needs to be wrapped in a <strong class="source-inline">try</strong> construct. The <strong class="source-inline">finally</strong> block will be called when the <strong class="source-inline">emitter(END)</strong> instruction<a id="_idIndexMarker1471"/> is reached. Create a new generator function that does that, as shown:<p class="source-code">function* watchUntilStopRequest(chan) {</p><p class="source-code">  try {</p><p class="source-code">    while (true) {</p><p class="source-code">      let evt = yield take(chan);</p><p class="source-code">      yield put(JSON.parse(evt.data));</p><p class="source-code">    }</p><p class="source-code">  } finally {</p><p class="source-code">  }</p><p class="source-code">};</p></li>
<li>Link the <strong class="source-inline">webSocketListener</strong> function and the <strong class="source-inline">watchUntilStopRequest</strong> generator function by calling them both from within <strong class="source-inline">startWatching</strong>. After this step, your test should pass:<p class="source-code">function* startWatching() {</p><p class="source-code">  ...</p><p class="source-code">  if (sessionId) {</p><p class="source-code">    ...</p><p class="source-code">    yield put({ type: "STARTED_WATCHING" });</p><p class="source-code"><strong class="bold">    const channel = yield call(</strong></p><p class="source-code"><strong class="bold">      webSocketListener, watcherSocket</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code"><strong class="bold">    yield call(watchUntilStopRequest(channel);</strong></p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>The final test is to alert the Redux store that we’ve stopped watching so that it can then remove the message that appears in the React UI:<p class="source-code">it("dispatches a STOPPED_WATCHING action when the connection is closed", async () =&gt; {</p><p class="source-code">  await startWatching();</p><p class="source-code">  socketSpy.onclose();</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "STOPPED_WATCHING" });</p><p class="source-code">});</p></li>
<li>Make that pass <a id="_idIndexMarker1472"/>by adding this one-liner to the <strong class="source-inline">finally</strong> block in <strong class="source-inline">watchUntilStopRequest</strong>:<p class="source-code">try {</p><p class="source-code">  ...</p><p class="source-code">} finally {</p><p class="source-code"><a id="_idTextAnchor335"/>  <strong class="bold">yield put({ type: "STOPPED_WATCHING" });</strong></p><p class="source-code">}</p></li>
</ol>
<p>You’ve now completed the saga: your application is now receiving events, and you’ve seen how to use the <strong class="source-inline">eventChannel</strong> function to listen to a stream of messages.</p>
<p>All that’s left is to integrate this into our React component.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor336"/>Updating the app</h1>
<p>We’ve completed<a id="_idIndexMarker1473"/> the work on building the sagas, but we have just a couple of adjustments to make in the rest of the app.</p>
<p>The <strong class="source-inline">MenuButtons</strong> component is already functionally complete, but we need to update the tests to properly exercise the middleware, in two ways: first, we must stub out the WebSocket constructor, and second, we need to fire off a <strong class="source-inline">TRY_START_WATCHING</strong> action as soon as the app starts:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/MenuButtons.test.js</strong> and start by importing<a id="_idIndexMarker1474"/> the <strong class="source-inline">act</strong> function. We’ll need this to await our socket saga actions:<p class="source-code">import { act } from "react-dom/test-utils";</p></li>
<li>Next, find the <strong class="source-inline">describe</strong> block named <strong class="source-inline">sharing button</strong> and insert the following <strong class="source-inline">beforeEach</strong> block, which is similar to the same stubbed constructor you used in the saga tests:<p class="source-code">describe("sharing button", () =&gt; {</p><p class="source-code">  let socketSpyFactory;</p><p class="source-code">  let socketSpy;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    socketSpyFactory = jest.spyOn(</p><p class="source-code">      window,</p><p class="source-code">      "WebSocket"</p><p class="source-code">    );</p><p class="source-code">    socketSpyFactory.mockImplementation(() =&gt; {</p><p class="source-code">      socketSpy = {</p><p class="source-code">        close: () =&gt; {},</p><p class="source-code">        send: () =&gt; {},</p><p class="source-code">      };</p><p class="source-code">      return socketSpy;</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Next, in the same <strong class="source-inline">describe</strong> block, add the following <strong class="source-inline">notifySocketOpened</strong> implementation. This is different from the <strong class="source-inline">notifySocketOpened</strong> implementation in the saga tests, because it calls both <strong class="source-inline">onopen</strong> and then <strong class="source-inline">onmessage</strong>, with a sample message. All of this is necessary for the <strong class="source-inline">startSharing</strong> saga to run correctly: it mimics the WebSocket opening, then the server sending the first message, which should result in<a id="_idIndexMarker1475"/> the <strong class="source-inline">STARTED_SHARING</strong> message being sent:<p class="source-code">const notifySocketOpened = async () =&gt; {</p><p class="source-code">  const data = JSON.stringify({ id: 1 });</p><p class="source-code">  await act(async () =&gt; {</p><p class="source-code">    socketSpy.onopen();</p><p class="source-code">    socketSpy.onmessage({ data });</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>We can now use this to update the test that is causing console errors. The test is the one with the description <strong class="source-inline">dispatches an action of STOP_SHARING when stop sharing is clicked</strong>. To avoid the errors, we must adjust a couple of lines. First, we dispatch a <strong class="source-inline">START_SHARING</strong> message, rather than a <strong class="source-inline">STARTED_SHARING</strong> message. Then, we use <strong class="source-inline">notifySocketOpened</strong> to mimic the server response to opening the socket. This will trigger the saga to send a <strong class="source-inline">STARTED_SHARING</strong> event, which causes the <strong class="bold">Sharing</strong> button in <strong class="source-inline">MenuButtons</strong> to change to be named <strong class="bold">Stop sharing</strong>. The test clicks it and waits for the <strong class="source-inline">STOP_SHARING</strong> event to be sent: <p class="source-code">it("dispatches an action of STOP_SHARING when stop sharing is clicked", async () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code"><strong class="bold">  dispatchToStore({ type: "START_SHARING" });</strong></p><p class="source-code"><strong class="bold">  await notifySocketOpened();</strong></p><p class="source-code">  click(buttonWithLabel("Stop sharing"));</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "STOP_SHARING" });</p><p class="source-code">});</p></li>
<li>With the test<a id="_idIndexMarker1476"/> passing, update <strong class="source-inline">src/index.js</strong> to call the <strong class="source-inline">TRY_START_WATCHING</strong> action when the app first loads:<p class="source-code"><strong class="bold">const store = configureStoreWithLocalStorage();</strong></p><p class="source-code"><strong class="bold">store.dispatch({ type: "TRY_START_WATCHING" });</strong></p><p class="source-code">ReactDOM</p><p class="source-code">  .createRoot(document.getElementById("root"))</p><p class="source-code">  .render(</p><p class="source-code">    &lt;Provider store={<strong class="bold">store</strong>}&gt;</p><p class="source-code">      &lt;App /&gt;</p><p class="source-code">    &lt;/Provider);</p></li>
</ol>
<p>You can now run the app and try it out. Here’s a manual test you can try:</p>
<ol>
<li value="1">Open a session in a browser window and click <strong class="bold">Start sharing</strong>.</li>
<li>Right-click on the link that appears and choose to open it in a new window.</li>
<li>Move your two windows so that they are side by side.</li>
<li>In the original window, type some commands, such as <strong class="source-inline">forward 100</strong> and <strong class="source-inline">right 90</strong>. You should see the commands update.</li>
<li>Now, hit <strong class="bold">Stop sharing</strong> in the original window. You should see the sharing messages<a id="_idIndexMarker1477"/> disappear from b<a id="_idTextAnchor337"/>oth screens.</li>
</ol>
<p>That covers test-driving WebSockets.</p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor338"/>Summary</h1>
<p>In this chapter, we’ve covered how to test against the WebSocket API.</p>
<p>You’ve seen how to mock the WebSocket constructor function, and how to test-drive its <strong class="source-inline">onopen</strong>, <strong class="source-inline">onclose</strong>, and <strong class="source-inline">onmessage</strong> callbacks.</p>
<p>You’ve also seen how to use a <strong class="source-inline">Promise</strong> object to convert a callback into something that can be yielded in a generator function, and how you can use <strong class="source-inline">eventChannel</strong> to take a stream of events and send them into the Redux store.</p>
<p>In the next chapter, we’ll look at using Cucumber tests t<a id="_idTextAnchor339"/>o drive some improvements to the sharing feature.</p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor340"/>Exercises</h1>
<p>What tests could you add to <a id="_idTextAnchor341"/>ensure that socket errors are handled gracefully?</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor342"/>Further reading</h1>
<p>The WebSocket specification:</p>
<p><a href="https://www.w3.org/TR/websockets/">https://www.w3.org/TR/websockets/</a></p>
</div>
<div>
<div id="_idContainer051">
</div>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer052">
<h1 id="_idParaDest-275"><a id="_idTextAnchor343"/>Part 4 – Behavior-Driven Development with Cucumber</h1>
<p>This part is about <strong class="bold">behavior-driven development</strong> (<strong class="bold">BDD</strong>) using Cucumber tests. Whereas the first three parts were focused on building Jest unit tests at the component level, this part looks at writing tests at the <em class="italic">system</em> level—you might also think of these as end-to-end tests. The goal is to show how the TDD workflow applies beyond unit testing and can be used by the whole team, not just developers.</p>
<p>Finally, we end the book with a discussion of how TDD fits within the wider testing landscape and suggestions for how you can continue your TDD journey. </p>
<p>This part includes the following chapters:</p>
<ul>
<li><a href="B18423_17.xhtml#_idTextAnchor344"><em class="italic">Chapter 17</em></a>, <em class="italic">Writing Your First Cucumber Test</em></li>
<li><a href="B18423_18.xhtml#_idTextAnchor355"><em class="italic">Chapter 18</em></a>, <em class="italic">Adding Features Guided by Cucumber Tests</em></li>
<li><a href="B18423_19.xhtml#_idTextAnchor375"><em class="italic">Chapter 19</em></a>, <em class="italic">Understanding TDD in the Wider Testing Landscape</em></li>
</ul>
</div>
</div></body></html>