- en: Chapter 2. Angular Building Blocks - Part 1
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章 Angular 构建模块 - 第1部分
- en: This chapter gives you a detailed walk through the core building blocks of the
    Angular architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍Angular架构的核心构建模块。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Decorators and metadata
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器和元数据
- en: Templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Bindings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定
- en: Directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Dependency injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Modules (NgModules)
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块（NgModules）
- en: '* * *'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'A module is a single unit of implementation of distinct functionalities. Collections
    of such modules will be used to implement complex applications. Implementing module
    patterns helps you avoid global collisions of variables and methods. JavaScript
    encapsulates both private and public methods under a single object by implementing
    a modular pattern. The modular pattern achieves encapsulation using closure in
    JavaScript. JavaScript doesn''t support access modifiers; however, the same effectÂ can
    be achieved using function scopes. All Angular applications are modular in nature.
    We develop Angular applications by creating many modules. We develop modules to
    encapsulate functionalities that are independent and have one responsibility.
    A module exports the classes available in that module. Angular modules are called
    as `NgModules`. At least one Angular module will be present in any Angular application:
    a root module, which will represented as `AppModule`. `AppModule` is a class decorated
    with `@NgModule`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是实现不同功能的单个实现单元。通过多个模块的集合来实现复杂的应用程序。实现模块模式有助于避免变量和方法的全局冲突。JavaScript通过实现模块模式将私有方法和公共方法封装在单个对象中。模块模式在JavaScript中使用闭包来实现封装。JavaScript不支持访问修饰符；然而，使用函数作用域可以实现相同的效果。所有的Angular应用都是模块化的。我们通过创建许多模块来开发Angular应用。我们开发模块来封装独立且具有单一职责的功能。一个模块导出该模块中可用的类。Angular模块称为`NgModules`。在任何Angular应用程序中都会至少存在一个Angular模块：根模块，它被表示为`AppModule`。`AppModule`是一个被`@NgModule`装饰的类。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the precedingÂ code, anÂ `NgModule`Â imported from `@angular/core` is decorated
    to the `AppModule` class. Note that `NgModule` has some important properties,
    such as imports, exports, providers, declarations, and bootstrap.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，从`@angular/core`导入的`NgModule`被装饰为`AppModule`类。请注意，`NgModule`具有一些重要属性，如imports、exports、providers、declarations和bootstrap。
- en: The metadata declarations should be assigned with view classes such as components,
    directives, and pipes that belong to this module. The metadata exports will be
    assigned with the components, directives, or pipes that are usable in the component
    templates. The metadata imports should be assigned with the exported classes that
    are used by component templates. The metadata providers will be assigned with
    the services that are used or accessed in the entire application. It creates the
    instance of services assigned and adds to the global collection of services so
    that the services will be ready to be consumed across the Angular application.
    The metadata bootstrap is assigned with the root component that is responsible
    to render the main view of the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据声明应该分配给视图类，如组件、指令和管道，这些类属于该模块。元数据的exports将被分配给在组件模板中可用的组件、指令或管道。元数据的imports应该分配给组件模板中使用的导出类。元数据provider将分配给在整个应用程序中使用或访问的服务。它创建分配的服务的实例，并将其添加到服务的全局集合中，以便这些服务可以在整个Angular应用程序中被消耗。元数据bootstrap分配给负责渲染应用程序主视图的根组件。
- en: '![](img/image_02_001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001.png)'
- en: The Angular module
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块
- en: 'A sample `AppComponent` class is shown as follows. TheÂ export statement exposes
    the component, and the `AppComponent` class is accessible to other modules in
    the application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例`AppComponent`类如下所示。该`export`语句公开了组件，并且`AppComponent`类可被应用程序中的其他模块访问：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A class is a template that contains definitions ofÂ methods and variables of
    an object. An object is an instance of the class, so it can hold the real value
    of the variables, and the methods can perform actions against the actual values.
    Note that the current version of JavaScript doesn't support classes. It's a class-free
    language. In JavaScript, everything is an object, and functions are used to mimic
    classes. ECMAScript 6 introduces syntactic sugar over JavaScript prototype-based
    inheritance by introducing classes to JavaScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类是包含对象方法和变量定义的模板。对象是类的一个实例，因此它可以保存变量的真实值，并且方法可以针对实际值执行操作。注意，当前版本的JavaScript不支持类。它是一种无类语言。在JavaScript中，一切都是对象，并且函数被用来模拟类。ECMAScript
    6通过在JavaScript中引入类来引入对JavaScript基于原型的继承的一种语法糖。
- en: Here, we leverage the power of TypeScript as a superset of JavaScript. The export
    keyword in the statement says that we are exporting or exposing an `AppComponent`
    class to other modules of the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了TypeScript作为JavaScript的超集的能力。语句中的export关键字表示我们正在向应用程序的其他模块导出或公开一个`AppComponent`类。
- en: 'Let''s consider that we have saved this component in a file named `app.component.ts`.
    In order to access or reference the `AppComponent` class that is exposed, we need
    to import it in the file we willÂ access. The following statement does this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经把这个组件保存在一个名为`app.component.ts`的文件中。为了访问或引用被公开的`AppComponent`类，我们需要在我们将要访问的文件中导入它。下面的语句完成了这个操作：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the import keyword in the statement means that we are importing a class
    that is exposed:Â `AppComponent`. The `from` keyword represents or refers to the
    file or module where the importing component exists. For example, it is `app.component.ts`Â in
    our case. A module name is the filename of the component without the extension;
    so, here the module name is `app.component`. We start the module's filename with
    the relative file path (`./`), and it represents the same folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，语句中的import关键字表示我们正在导入一个被公开的类：`AppComponent`。from关键字表示或指向导入组件所在的文件或模块。例如，在我们的情况下，它是`app.component.ts`。一个模块名是组件的文件名去掉扩展名；所以，在这里，模块名是`app.component`。我们用相对文件路径(`./`)开头的模块文件名，并表示相同的文件夹。
- en: 'Modules can also have a collection of other modules and such modules are known
    as library modules. Angular itself has many library modules. Some library modules
    are core, common, router, and so on. We import `Component` from the `@angular/core`
    library module, which is the primary module that we use for most things:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以包含其他模块的集合，这样的模块被称为库模块。Angular本身有许多库模块。一些库模块是核心，公用，路由等。我们从`@angular/core`库模块中导入`Component`，这是我们大多数情况下使用的主要模块：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All Angular library modules will be mentioned without any relative file path
    in the from clause.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Angular库模块都将在from子句中以没有相对文件路径的方式提及。
- en: Components
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: '* * *'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: AngularJS has controllers, scopes, and directives to deal with views, bind data,
    and respond to events by updating changes to data. In Angular, Components replaced
    controllers, scopes, and directives from AngularJS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS具有控制器，作用域和指令来处理视图，绑定数据，并通过更新数据来响应事件。在Angular中，组件取代了AngularJS的控制器，作用域和指令。
- en: 'Angular, introduced components that support the object-oriented component model
    to write cleaner code. A component is a simple class that holds the logic of managing
    the associated template or view. A simple component class is given as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了支持面向对象组件模型的组件，以编写更干净的代码。一个组件是一个简单的类，它保持管理相关模板或视图的逻辑。一个简单的组件类如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In a component class, we will expose properties and methods to a template or
    view. Component properties can provide data for a template or view and allow the
    user to modify property values. Component methods can be called according to user
    actions over the view.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件类中，我们将属性和方法暴露给模板或视图。组件属性可以为模板或视图提供数据，并允许用户修改属性值。根据用户在视图上的操作，可以调用组件方法。
- en: '![](img/image_02_002.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002.png)'
- en: The Angular component FirstComponent
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件FirstComponent
- en: 'As you can see, the preceding code creates a simple JavaScript class named
    `**`FirstComponent`**`. You may be wondering how a JavaScript plain class can
    be treated as a component and how a template can be wired up to this class. In
    order to achieve this, Angular leverages the syntax of TypeScript to annotate
    the `**`FirstComponent`**` class as per ES6 specification 2015\. The following
    code shows the component class with an annotation that declares the class as a
    component and wires up the template with the markup identifier in the selector:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，上述代码创建了一个名为`**`FirstComponent`**`的简单JavaScript类。也许你想知道一个JavaScript普通类如何被视为组件，模板如何与这个类被连接起来。为了实现这一点，Angular利用了TypeScript语法来按照2015年的ES6规范对`**`FirstComponent`**`类进行注释，将其声明为组件并将模板与选择器的标识符进行连接。下面的代码展示了带有注释的组件类，声明类为组件并用模板将其与标记标识符连接起来：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might be surprised to see that we have not used `$scope` to expose the property
    and method of `FirstComponent`. Here, our component gets instantiated and is available
    in the template or view. So, we can access any property of that instance; also,
    we can call methods in the instance according to user actions or input in the
    view or template. The component instance provides the encapsulated data pertaining
    to that instance that is similar to the isolated scope in AngularJS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会惊讶地发现我们没有使用`$scope`来暴露`FirstComponent`的属性和方法。在这里，我们的组件实例化并可在模板或视图中使用。因此，我们可以访问该实例的任何属性；同时，我们可以根据用户在视图或模板中的操作或输入调用实例中的方法。组件实例提供了有关该实例的封装数据，类似于AngularJS中的隔离作用域。
- en: Inheritance of components can happen in Angular when the template of the root
    component has the special tags of another component's selector, and this also
    enables the child component to access its parents and siblings.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当根组件的模板具有另一个组件选择器的特殊标记时，Angular中的组件可以继承，并且这也使子组件能够访问其父级和同级组件。
- en: '![](img/image_02_003.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003.png)'
- en: The application's component hierarchy
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的组件层次结构
- en: The life cycle of a component
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件的生命周期
- en: 'Angular manages the life cycle of a component. Angular takes care of creating
    and rendering the components and their children and destroying them before removing
    them from the DOM. Angular keeps track of the value of the component property
    value. The following are the life cycle events of anÂ Angular component given
    in calling order:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular管理组件的生命周期。Angular负责创建和渲染组件及其子组件，并在从DOM中删除之前销毁它们。Angular跟踪组件属性值的变化。以下是Angular组件的生命周期事件按调用顺序给出：
- en: '**OnChanges**: This event is fired when a binding values changes. This method
    will have access to both the old value and the new value.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnChanges**: 当绑定值发生变化时会触发此事件。此方法将有权访问旧值和新值。'
- en: '**OnInit**: This event is fired after the execution of theÂ `OnChanges` event
    due to binding value changes.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnInit**: 这个事件在由于绑定值的更改而执行`OnChanges`事件之后触发。'
- en: '**DoCheck**: This event is fired for every change detected, and developers
    can write custom logic to check for the property changed.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DoCheck**: 这个事件会在检测到每次变化时被触发，开发人员可以编写自定义逻辑来检查属性的变化。'
- en: '**AfterContentInit**: This event will be fired when the directive''s content
    has been completely initialized.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AfterContentInit**: 当指令的内容完全初始化后将触发此事件。'
- en: '**AfterContentChecked**: This event will be fired after a directive''s content
    has been checked.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AfterContentChecked**: 这个事件将在指令内容被检查后触发。'
- en: '**AfterViewInit**: This event will be fired when the component''s template
    has been completely initialized.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AfterViewInit**: 当组件模板完全初始化后将触发此事件。'
- en: '**AfterViewChecked**: This event will be fired after the component''s template
    has been checked.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AfterViewChecked**: 这个事件将在组件模板被检查后触发。'
- en: '**OnDestroy**: This event will be fired before destroying the directive or
    component.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OnDestroy**: 这个事件将在销毁指令或组件之前触发。'
- en: You can either implement all of these events or only the specific events that
    are required for your component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实现所有这些事件，也可以只实现组件所需的特定事件。
- en: Decorators and metadata
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器和元数据
- en: '* * *'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: As you saw in the lastÂ section, we define JavaScript plain classes for a component,
    and we annotate it with some information to inform the Angular framework that
    this class is a component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一节中所看到的，我们为组件定义了JavaScript普通类，并对其进行了一些信息注释，以通知Angular框架该类是一个组件。
- en: 'We leverage the Typescript syntaxÂ and attach the classes with metadata using
    the decorator feature. To make a class as a component, we add the `@Component`
    decorator, as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了Typescript语法，并使用装饰符功能将类附加元数据。为了使一个类成为组件，我们添加`@Component`装饰符，如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s attach metadata to the `FirstComponent` class using the decorator
    syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用装饰符语法为`FirstComponent`类附加元数据：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have added metadata, such as a selector and `templateUrl`. The selector
    metadata configured in the component tells Angular to create the instance of a
    component when it encounters the `<first-controller>` markup:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经添加了诸如选择器和`templateUrl`之类的元数据。组件中配置的选择器元数据告诉Angular在遇到`<first-controller>`标记时创建该组件的实例：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `templateUrl` provides a URL of the template file for the component to render.
    When you run the application, the `<first-controller>` tag will be replaced by
    the content of the template that is referred to in `templateUrl`. This metadata
    is actually a parameter to the `@Component` decorator, and the decorator is a
    function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateUrl`提供了组件渲染的模板文件的URL。当您运行应用程序时，`<first-controller>`标记将被`templateUrl`中引用的模板内容替换。此元数据实际上是`@Component`装饰符的一个参数，而装饰符是一个函数。'
- en: By adding metadata via decorators, we are actually telling Angular what to do
    with the defined class. The component, template, and metadata together constitute
    a view.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过装饰符添加元数据，我们实际上告诉Angular如何处理定义的类。组件、模板和元数据一起构成一个视图。
- en: Templates
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: '* * *'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: You willÂ have noted that we have added inline markups for a view or template
    when annotating the component. We can also add a template URL isolating the view,
    or template markups in a separate HTML file, instead of having it as an inline
    view or template.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当对组件进行注解时，您可能已经注意到我们为视图或模板添加了内联标记。我们还可以添加一个模板URL，将视图或模板标记隔离在一个单独的HTML文件中，而不是将其作为内联视图或模板。
- en: 'A template comprises HTML tags that provide information to Angular on rendering
    the components. A simple template content is given in the following lines of code.
    It renders the name of the book and publisher:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模板由HTML标记组成，向Angular提供有关呈现组件的信息。以下代码行中给出了一个简单的模板内容。它呈现了书名和出版商：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inline templates
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联模板
- en: 'An inline template is used when there is a need to render very simple content,
    such as a one-liner, for example. In such cases, inline views or templates will
    be defined directly in the annotation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 内联模板在需要呈现非常简单内容（例如一行）时使用。在这种情况下，内联视图或模板将直接在注释中定义：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Isolated templates
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离模板
- en: 'Isolated templates are used mostly when the template contains more contents.
    In such cases, rather than assigning the larger content as an inline view, the
    content will be moved to a separate file and the HTML file URL will be assigned
    to `templateUrl`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离模板主要用于模板包含更多内容的情况。在这种情况下，内容将被移到一个单独的文件中，并将HTML文件的URL分配给`templateUrl`，如下所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The local template variable
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地模板变量
- en: 'Angular permitsÂ creating template-scoped variables to move data across the
    elements in a template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许创建模板作用域变量，在模板中移动数据：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding template markup, we have declared a local variable, todo, using
    the let keyword. Then, we iterate through the collection variable todos; each
    todo item gets assigned to todo and is available for use in `<todo-item>`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板标记中，我们使用let关键字声明了一个本地变量todo。然后，我们遍历todos集合变量；每个todo项目都被分配给todo，并且可以在`<todo-item>`中使用。
- en: 'A local template variable can also be used to hold the DOM element. The following
    code shows that the author will hold the input element itself, and the value of
    the element can be accessed using author.value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用本地模板变量来保存DOM元素。以下代码显示了作者将保存输入元素本身，并且可以使用author.value访问元素的值：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Binding
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: '* * *'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The binding technique will enable you to bind data to a template and will allow
    users to interact with the bound data. The Angular binding framework takes care
    of rendering the data to a view and updating itÂ as per user actions over the
    view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定技术将使您能够将数据绑定到模板，并允许用户与绑定的数据进行交互。Angular绑定框架负责将数据呈现到视图，并根据用户在视图上的操作进行更新。
- en: 'The following screenshot gives you a quick glimpseÂ of the various binding
    techniques in Angular. We will go through each binding technique in detail:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图让您快速了解了Angular中各种绑定技术。我们将逐个详细介绍每种绑定技术：
- en: '![](img/image_02_004.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_004.png)'
- en: Various binding syntaxes
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 各种绑定语法
- en: One-way binding
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向绑定
- en: 'Binding types such as `Interpolation`, `Property`, `Attribute`, `Class`, and
    `Style` support one-way data flow from the data source (exposed from the component)
    to a view or template. Template markups that let the data flow from a component
    property or method to a template are given in the following table (one-way binding):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`插值`、`属性`、`属性`、`类`和`样式`等绑定类型支持从数据源（从组件公开）到视图或模板的单向数据流。让数据从组件属性或方法流向模板的模板标记在下表中给出（单向绑定）：
- en: '| **Template code** | **Description** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **模板代码** | **描述** |'
- en: '| `{{expression}}` | This displays the expression built from the data source
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `{{表达式}}` | 这显示了从数据源构建的表达式 |'
- en: '| `[target]` = "expression" | This assigns the expression of a data source
    to the target property |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `[目标]` = "表达式" | 这将数据源的表达式分配给目标属性 |'
- en: '| `bind-target` = "expression" | This assigns the expression of a data source
    to the bind-target attribute |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `bind-target` = "表达式" | 这将数据源的表达式分配给绑定目标属性 |'
- en: 'Template markups that let data flow from a template to a component property
    or method are given in the following table (one-way binding):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让数据从模板流向组件属性或方法的模板标记在下表中给出（单向绑定）：
- en: '| **Template code** | **Description** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **模板代码** | **描述** |'
- en: '| `(target)` = "statement" | This assigns the expression of a data source to
    a target property |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `(目标)` = "语句" | 这将数据源的表达式分配给目标属性 |'
- en: '| `on-target` = "statement" | This assigns the expression of a data source
    to a bind-target attribute |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `on-target` = "语句" | 这将数据源的表达式分配给绑定目标属性 |'
- en: Interpolation binding
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内插绑定
- en: 'Interpolation is one of the main features ofÂ Angular. You can interpolate
    any property value or expression to the content of any HTML element, such as `div`Â andÂ `li`.
    You can achieve this with the help of double-curly braces, `{{and}}`, as shown
    in the following line of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内插是Â Angular的主要特性之一。您可以将任何属性值或表达式插值到任何HTML元素的内容中，例如`div`和`li`。您可以通过双大括号`{{和}}`来实现此目的，如下行代码所示：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we interpolate `authorName` to the content of the `div` tag. This is a
    one-way binding where the data flows from the component property or method to
    the template.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`authorName`插值到`div`标签的内容中。这是一种单向绑定，其中数据从组件属性或方法流向模板。
- en: Property binding
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性绑定
- en: 'Property binding is used to bind a component property to an HTML element property:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定用于将组件属性绑定到HTML元素属性：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Event binding
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件绑定
- en: 'HTML elements have various DOM events that will be fired when an event is triggered.
    For example, a button will fire a click event when itÂ is clicked on. We hook
    an event listener to get notified whenever an event is fired:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素具有各种DOM事件，当事件触发时将触发。例如，单击按钮时将触发点击事件。我们挂钩事件监听器以便在事件触发时得到通知：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding Angular code snippet that wraps the event name in brackets needs
    to hook the event listener so that it gets called when a click event is fired.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Angular代码片段将事件名称放在括号中，需要挂接事件监听器，以便在触发单击事件时调用它。
- en: Two-way binding
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向绑定
- en: Angular has removed a core feature from its framework, which was one main reason
    for the birth of AngularJS, that is, two-way binding. So, two way binding is not
    available by default. Now, let's see how to implement a two-way binding in Angular.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Angular已经从其框架中移除了一个核心功能，这是AngularJS诞生的一个主要原因，即双向绑定。因此，默认情况下不支持双向绑定。现在，让我们看看如何在Angular中实现双向绑定。
- en: 'Angular combined property and event binding for us to implement two-way binding,
    as shown in the following line of code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular结合属性和事件绑定，使我们能够实现双向绑定，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Template markup that helps data flow in both ways, from a template to a component
    and from a component to a template, is given in the following table (two-way binding):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以帮助数据双向流动的模板标记，从模板到组件，从组件到模板，如下表所示（双向绑定）：
- en: '| **Template code** | **Description** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **模板代码** | **描述** |'
- en: '| `[(target)]` = "expression" | This assigns the expression of a data source
    to a target property |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `[(目标)]` = "表达式" | 这将数据源的表达式分配给目标属性 |'
- en: '| `bindon-target` = "expression" | This assigns the expression of a data source
    to a bind-target attribute |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `bindon-target` = "表达式" | 这将数据源的表达式分配给绑定目标属性 |'
- en: Directives
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令
- en: '* * *'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We walked through the Angular component and the way it is decorated. The `@Component`
    itself is a directive with a template configured in the metadata. So, a directive
    is a component without a template, and `@directive` is used in Typescript to attach
    metadata to it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细介绍了Angular组件及其装饰方式。`@Component` 本身是一个带有在元数据中配置的模板的指令。因此，一个没有模板的指令是一个组件，而
    `@directive` 在Typescript中用于附加元数据。
- en: Structural directives
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构指令
- en: 'Structural directives deal with modifyingÂ elements in the DOM by adding new
    elements, removing existing elements, and replacing existing elements with new
    elements. The following markup shows two structural directives:Â `*ngFor` and
    `*ngIf`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令处理通过添加新元素、删除现有元素和用新元素替换现有元素来修改DOM中的元素。下面的标记显示了两个结构指令：`*ngFor` 和 `*ngIf`：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`*ngFor` iterates through each item in the todos collection and adds a `div`
    tag for each item. And `*ngIf` renders `<todo-item>` only if selectedTodo is available.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngFor` 遍历 todos 集合中的每个项目，并为每个项目添加一个 `div` 标签。而 `*ngIf` 仅在 selectedTodo 可用时呈现
    `<todo-item>`。'
- en: Attribute directives
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性指令
- en: 'AnÂ attribute directive will be added like an attribute to existing HTML elements,
    and this can alter or extend the behavior of HTML elements. For example, an ngModel
    directive, if added to an input element, will extend it by updating its value
    property and also by responding to change events:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令将像属性一样添加到现有的 HTML 元素中，并且可以修改或扩展 HTML 元素的行为。例如，如果将 ngModel 指令添加到输入元素中，它将通过更新其
    value 属性和响应更改事件来扩展它：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can also write our own directives apart from using existing ones, such as
    `ngSwitch`, `ngStyles`, and `ngClass`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用现有的指令，我们还可以编写自己的指令，比如 `ngSwitch`、`ngStyles` 和 `ngClass`。
- en: Dependency injection
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '* * *'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Dependency injection is a design pattern that handles dependencies and resolves
    them. An instance of the dependencies will be passed to the dependent in order
    to use it. If a client module or class is dependent on a service, it needs to
    create an instance of the service before using it. We can inject or pass the instance
    of the service to the client using a dependency injection pattern, rather than
    a client module building the service.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种处理依赖关系并解决它们的设计模式。依赖项的实例将传递给依赖项，以便使用它。如果客户端模块或类依赖于一个服务，它需要在使用之前创建该服务的一个实例。我们可以使用依赖注入模式注入或传递服务的实例给客户端，而不是客户端模块构建服务。
- en: Applying dependency injection enables us to create a client that does not have
    any knowledge of the service to be built and of the actual service it is consuming.
    The client will only have knowledge about the interface of the service as it needs
    to know how to use the service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应用依赖注入使我们能够创建一个不知道要构建的服务和实际消费的服务的客户端。客户端只会知道服务的接口，因为它需要知道如何使用服务。
- en: Why dependency injection?
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么依赖注入？
- en: Consider that we are creating a `Mobile` class, and it has dependency on a `camera`
    and `internet` connectivity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在创建一个 `Mobile` 类，并且它依赖于 `camera` 和 `internet` 连接。
- en: '![](img/image_02_005.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_005.png)'
- en: The code snippet of a Mobile class
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Mobile 类的代码片段
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Mobile` class is dependent on `Camera` and `Internet`, and this increases
    the difficulty in testing. We can only test Mobile with 2G Internet and 2 MP Camera
    because we cannot control the dependencies as the `Mobile` class takes care of
    the instance of dependency by itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mobile` 类依赖于 `Camera` 和 `Internet`，这增加了测试的难度。我们只能用 2G 互联网和 2 MP 相机来测试 Mobile，因为我们无法控制依赖，因为
    `Mobile` 类通过自身负责依赖的实例。'
- en: 'Now, let''s modify the constructor to receive the instance of `Camera` and
    `Internet` as parameters, as shown in the following line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改构造函数，接收 `Camera` 和 `Internet` 的实例作为参数，如下面的代码行所示：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now the `Mobile` class will not create an instance of `Camera` or `Internet`.
    It just consumes the instance of `Camera` or `Internet` that is received from
    the constructor parameters. This means that we moved the dependencies to the constructor.
    The client can create a `Mobile` class by passing the instance of `Camera` and
    `Internet` to the constructor, as shown in the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Mobile` 类将不再创建 `Camera` 或 `Internet` 的实例。它只消耗从构造函数参数中收到的 `Camera` 或 `Internet`
    的实例。这意味着我们将依赖项移到了构造函数中。客户端可以通过向构造函数传递 `Camera` 和 `Internet` 的实例来创建一个 `Mobile`
    类，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, the definitions of `Camera` and `Internet` have been decoupled
    from the `Mobile` class. We can pass any type of Camera with various megapixels
    and Internet with various bandwidths, such as 2G, 3G, and 4G, as long as both
    the `Camera` and `Internet` types passed by the client comply with the interface
    of `Camera` and `Internet`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`Camera`和`Internet`的定义已经与`Mobile`类解耦。只要客户端传递的`Camera`和`Internet`类型符合`Camera`和`Internet`的接口，我们就可以传递任何类型的具有不同百万像素的摄像头和不同带宽的互联网，比如2G，3G和4G。
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no change in the `Mobile` class to accommodate the 20 MP Camera and
    4G Internet dependencies. The `Mobile` class is much easier to test with various
    combinations of `Camera` and `Internet`, as we have complete control over the
    dependencies. We can also use a mocking technique in testing and pass mocks of
    `Camera` and `Internet` to constructor so that all the necessary operations will
    be done against the mocks of `Camera` and `Internet`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Mobile`类中没有改变，以适应20 MP摄像头和4G互联网的依赖性。`Mobile`类更容易通过各种组合的`Camera`和`Internet`进行测试，因为我们对依赖性有完全的控制。我们还可以在测试中使用模拟技术，并将`Camera`和`Internet`的模拟传递给构造函数，以便所有必要的操作都将针对`Camera`和`Internet`的模拟进行。
- en: The role of injectors
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入器的作用
- en: We just got to know what a dependency injection is and how it receives dependencies
    from an external client rather than creating themÂ itself. However, the client
    needs to update its code to pass an instance of 20 MP Camera and 4G Internet dependencies.
    Any client that wants to consume the `Mobile` class must create instances of `Camera`
    and `Internet` as the `Mobile` class depends on them. We eliminated the responsibility
    for creating the instances of dependencies from the `Mobile` class and moved them
    to clients that willÂ consume the `Mobile` class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了什么是依赖注入，以及它如何从外部客户端接收依赖性而不是自己创建它们。然而，客户端需要更新其代码，以传递20 MP摄像头和4G互联网依赖的实例。任何想要使用`Mobile`类的客户端都必须创建`Camera`和`Internet`的实例，因为`Mobile`类依赖于它们。我们从`Mobile`类中消除了创建依赖实例的责任，并将其移动到将使用`Mobile`类的客户端。
- en: 'Now, it has become the poor client''s problem to create the instances of `Camera`
    and `Internet`. So, to reduce the extra efforts of a client in creating the instances
    of dependencies, we need injectors that take care of assembling instances of the
    required `Camera` and `Internet` for the client. The dependency injection framework
    has something called an injector where we register our classes, such as `Mobile`.
    We can then request the injector to create the instance of `Mobile` for us. The
    injector will then take care of resolving the dependencies and creating `mobile`,
    as shown in the following line of code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，成为可怜的客户端的问题，要创建`Camera`和`Internet`的实例。因此，为了减少客户端创建依赖实例的额外工作，我们需要注入器来负责为客户端组装所需的`Camera`和`Internet`的实例。依赖注入框架有一个叫做注入器的东西，我们在其中注册我们的类，比如`Mobile`。然后我们可以请求注入器为我们创建`Mobile`的实例。注入器将负责解析依赖关系并创建`mobile`，如下面的代码行所示：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Handling dependency injection in Angular
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Angular中处理依赖注入
- en: Angular has its own dependency injection framework, and we will see, with an
    example, how it handles dependency injection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有自己的依赖注入框架，并且我们将通过一个示例看到它如何处理依赖注入。
- en: 'First, we will create a `Todo` class under `app/todos/todo.ts` with properties
    such as `id`, `description`, and `isCompleted`, as given in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`app/todos/todo.ts`下创建一个`Todo`类，该类具有诸如`id`，`description`和`isCompleted`等属性，如下截图所示：
- en: '![](img/image_02_006.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_006.png)'
- en: A code snippet of the Todo class
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Todo类的代码片段
- en: Then, create a `TodoListComponent` component and add the property to hold the
    collection of todo items retrieved from the injected `TodoService`. The service
    will be injected into constructor when `TodoListComponent` is instantiated by
    the dependency injection framework. You will learn more about services in r 3,
    *Angular Building Blocks - Part 2*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个`TodoListComponent`组件，并添加一个属性来保存从注入的`TodoService`检索到的待办事项集合。当依赖注入框架实例化`TodoListComponent`时，服务将被注入到构造函数中。您将在第3章*Angular构建块-第2部分*中了解更多关于服务的内容。
- en: '![](img/image_02_007.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_007.png)'
- en: A code snippet of the TodoListComponent class
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: TodoListComponent类的代码片段
- en: The code is written using Typescript, and when it compiles the code to JavaScript,
    it includes information about the class metadata, as the class was decorated with
    `@component`. This class metadata holds the information about associating the
    `todoService` parameter with the `TodoService` class. This enables the Angular
    injector to inject the instance of `TodoService` when it creates a new `TodoListComponent`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是使用 Typescript 编写的，当它将代码编译为 JavaScript 时，会包含有关类元数据的信息，因为类被装饰为 `@component`。这个类元数据包含了关联`todoService`参数和`TodoService`类的信息。这使得
    Angular 注入器在创建新的 `TodoListComponent` 时能够注入 `TodoService` 的实例。
- en: We don't explicitly call an injector to inject the service in our code. Instead,
    Angular's automated dependency injection takes care of it. The injector will be
    called implicitly while Angular instantiates components when it encounters the
    `<todo-list>` selector through HTML markups or when navigating to a component
    via a router.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们不需要显式调用注入器来注入服务。相反，Angular 的自动依赖注入会处理它。当 Angular 遇到通过 HTML 标记或通过路由导航到组件时遇到`<todo-list>`选择器时，注入器会在实例化组件的同时被隐式调用。
- en: Now, we will create `TodosComponent`, which registers `TodoService` using the
    providers parameter in the `@Component` directive. The instance of `TodoService`
    is readily available for the injection both in `TodosComponent` and in all its
    child s.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建 `TodosComponent`，在 `@Component` 指令的 providers 参数中注册 `TodoService`。`TodoService`
    的实例在`TodosComponent`中和它的所有子项中都可以被注入使用。
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's create the `TodoService` service that returns the collection of todo
    items.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建返回待办事项集合的 `TodoService` 服务。
- en: '![](img/image_02_008.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_008.png)'
- en: The code snippet of TodoService
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: TodoService 的代码片段
- en: In the production `TodoList` application, the `getTodos` method in `TodoService`
    will make an HTTP request to get the list of todos. For the basics, we are returning
    the collection of todos from the `mock-todos`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境的 `TodoList` 应用程序中，`TodoService` 中的 `getTodos` 方法将进行一个 HTTP 请求来获取待办事项列表。在基本情况下，我们从`mock-todos`中返回待办事项的集合。
- en: 'Finally, we need to create `mock-todos`, which holds the collection of todo
    items, as illustrated in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建 `mock-todos`，其中包含待办事项的集合，如下面的屏幕截图所示：
- en: '![](img/image_02_009.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_009.png)'
- en: A code snippet of mock-todos
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock-todos` 的代码片段'
- en: This file is used as an in-memory collection to hold the todo items, and it
    is made available to the components that import this file. This approach is good
    for the development phase, but this needs to be changed in the production phase
    to fetch todo items from the remote server.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件用作内存中的集合，以保存待办事项，并且可以在导入该文件的组件中使用。这种方法适用于开发阶段，但在生产阶段需要从远程服务器获取待办事项。
- en: 'Run the application by pressing *F5* in VS Code, and you will get the output
    of the Angular TodoList application, as shown in the following screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中按下*F5*运行应用程序，您将得到 Angular TodoList 应用程序的输出，如下面的屏幕截图所示：
- en: '![](img/todoapp.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/todoapp.png)'
- en: The TodoList application running in a browser
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的 TodoList 应用程序
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '* * *'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Wow! You must have learned a lot about Angular architecture's core building
    blocks by now.Â We started with e and discussed how it encapsulates the functionalities
    that are independent and have one responsibility.Â Then, you learned about the
    concepts of components and how they replaced controllers, scopes, and directives
    from AngularJS. You also learned about decorators and metadata that leverage the
    Typescript syntax to make a plain JavaScript class into an Angular component.
    Then, we discussed templates and the differences between inline templates and
    isolated templates. You also learned how to implement various binding techniques
    in a template. Later, we went through directives and how a directive is differentiated
    from a component. Finally, you learned about one of the most popular design patterns,
    dependency injection, and how it is handled by Angular.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！到现在为止，您一定已经学到了很多关于 Angular 架构的核心构建块。我们从 e 开始，讨论了它如何封装了独立且具有单一职责的功能。然后，您学习了组件的概念，以及它们如何取代了
    AngularJS 中的控制器、作用域和指令。您还了解了装饰器和元数据，它们利用了 Typescript 语法将普通的 JavaScript 类转换为 Angular
    组件。然后，我们讨论了模板以及内联模板和独立模板之间的区别。您还学习了如何在模板中实现各种绑定技术。稍后，我们通过指令讨论了指令以及指令与组件的区别。最后，您学习了一个最受欢迎的设计模式之一，依赖注入，以及它如何被
    Angular 处理。
- en: In the next chapter, we will discuss the remaining blocks in the Angular architecture.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Angular架构中剩下的部分。
