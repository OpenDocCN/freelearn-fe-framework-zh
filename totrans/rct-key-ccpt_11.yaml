- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Working with Complex State
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理复杂状态
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几点：
- en: Manage cross-component or even app-wide state (instead of just component-specific
    state)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理跨组件或甚至应用级别的状态（而不仅仅是组件特定的状态）
- en: Distribute data across multiple components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个组件间分配数据
- en: Handle complex state values and changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理复杂的状态值和变化
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: State is one of the core concepts you must understand (and work with) to use
    React effectively. Basically, every React app utilizes (many) state values across
    many components to present a dynamic, reactive user interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是您必须理解（并与之合作）以有效使用React的核心概念之一。基本上，每个React应用都会在许多组件间使用（许多）状态值来呈现动态、反应式的用户界面。
- en: From simple state values that contain a changing counter or values entered by
    users, all the way up to more complex state values such as the combination of
    multiple form inputs or user authentication information, state is everywhere.
    In React apps, it’s typically managed with the help of the `useState()` Hook.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含变化的计数器或用户输入的值的简单状态值，到更复杂的状态值，如多个表单输入的组合或用户身份验证信息，状态无处不在。在React应用中，它通常借助`useState()`钩子来管理。
- en: However, once you start building more complex React applications (e.g., online
    shops, admin dashboards, and similar sites), it is likely that you’ll face various
    challenges related to state. State values might be used in component A but changed
    in component B or be made up of multiple dynamic values that may change for a
    broad variety of reasons (e.g., a cart in an online shop, which is a combination
    of products, where every product has a quantity, a price, and possibly other traits
    that may be changed individually).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你开始构建更复杂的React应用（例如，在线商店、管理仪表板和类似网站），你可能会面临与状态相关的各种挑战。状态值可能在组件A中使用，但在组件B中更改，或者由多个可能因多种原因而变化的动态值组成（例如，在线商店中的购物车，它是由产品组合而成的，每个产品都有数量、价格，以及可能单独更改的其他属性）。
- en: You can handle all these problems with `useState()` , props, and the other concepts
    covered by this book thus far. But you will notice that solutions based on `useState()`
    alone gain a complexity that can be difficult to understand and maintain. That’s
    why React has more tools to offer—tools created for these kinds of problems, which
    this chapter will highlight and discuss.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`useState()`、props以及本书迄今为止涵盖的其他概念来处理所有这些问题。但你会注意到，仅基于`useState()`的解决方案会变得复杂，难以理解和维护。这就是为什么React提供了更多工具——为这类问题创建的工具，本章将突出和讨论这些工具。
- en: A Problem with Cross-Component State
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨组件状态的问题
- en: 'You don’t even need to build a highly sophisticated React app to encounter
    a common problem: state that spans multiple components.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要构建一个高度复杂的React应用，就可能会遇到一个常见问题：跨越多个组件的状态。
- en: 'For example, you might be building a news app where users can bookmark certain
    articles. A simple user interface could look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能正在构建一个新闻应用，用户可以标记某些文章。一个简单的用户界面可能看起来像这样：
- en: '![img](img/B31339_11_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_11_01.png)'
- en: 'Figure 11.1: An example user interface'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：一个示例用户界面
- en: As you can see in the preceding figure, the list of articles is on the left,
    and a summary of the bookmarked articles can be found in the sidebar on the right.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前图所示，文章列表在左侧，而已标记文章的摘要可以在右侧的侧边栏中找到。
- en: A common solution is to split this user interface into multiple components.
    The list of articles, specifically, would probably be in its own component—just
    like the bookmark summary sidebar.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的解决方案是将这个用户界面拆分成多个组件。具体来说，文章列表可能将作为一个独立的组件——就像书签摘要侧边栏一样。
- en: However, in that scenario, both components would need to access the same shared
    state—that is, the list of bookmarked articles. The article list component would
    require access in order to add (or remove) articles. The bookmark summary sidebar
    component would require it as it needs to display the bookmarked articles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，这两个组件都需要访问相同的共享状态——即已标记文章的列表。文章列表组件需要访问权限以便添加（或删除）文章。书签摘要侧边栏组件也需要它，因为它需要显示已标记的文章。
- en: 'The component tree and state usage for this kind of app could look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的应用的组件树和状态使用可能看起来像这样：
- en: '![img](img/B31339_11_02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_11_02.png)'
- en: 'Figure 11.2: Two sibling components share the same state'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：两个兄弟组件共享相同的状态
- en: In this figure, you can see that the state is shared across these two components.
    You also see that the two components have a shared parent component (the `News`
    component, in this example).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，你可以看到状态在这两个组件之间是共享的。你还可以看到这两个组件有一个共享的父组件（在这个例子中是 `News` 组件）。
- en: Since the state is used by two components, you would not manage it in either
    of those components. Instead, it’s *lifted up* , as described in *Chapter 4* ,
    *Working with Events and State* (in the *Lifting State Up* section). When lifting
    state up, the state values and pointers to the functions that manipulate the state
    values are passed down to the actual components that need access via props.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态被两个组件使用，你不会在任何一个组件中管理它。相反，它被*提升*，如*第4章*，*与事件和状态一起工作*（在*提升状态*部分）中所述。当提升状态时，状态值和指向操作状态值的函数的指针通过
    props 传递给实际需要访问的组件。
- en: This works and is a common pattern. You can (and should) keep on using it. But
    what if a component that needs access to some shared state is deeply nested in
    other components? What if the app component tree from the preceding example looked
    like this?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，并且是一个常见的模式。你可以（并且应该）继续使用它。但如果需要访问某些共享状态的组件深深嵌套在其他组件中怎么办？如果前一个例子中的应用组件树看起来像这样？
- en: '![img](img/B31339_11_03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_11_03.png)'
- en: 'Figure 11.3: A component tree with multiple layers of state-dependent components'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：具有多层状态相关组件的组件树
- en: 'In this figure, you can see that the `BookmarkSummary` component is a deeply
    nested component. Between it and the `News` component (which manages the shared
    state), you have two other components: the `InfoSidebar` component and the `BookmarkInformation`
    component. In more complex React apps, having multiple levels of component nesting,
    as in this example, is very common.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，你可以看到 `BookmarkSummary` 组件是一个深层嵌套的组件。在它和 `News` 组件（管理共享状态）之间，还有两个其他组件：`InfoSidebar`
    组件和 `BookmarkInformation` 组件。在更复杂的 React 应用中，像这个例子中这样有多个组件嵌套层级是非常常见的。
- en: 'Of course, even with those extra components, state values can still be passed
    down via props. You just need to add props to **all** components between the component
    that holds the state and the component that needs the state. For example, you
    must pass the `bookmarkedArticles` state value to the `InfoSidebar` component
    (via props) so that that component can forward it to `BookmarkInformation` :'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使有这些额外的组件，状态值仍然可以通过 props 传递。你只需要在持有状态的组件和需要状态的组件之间添加 props。例如，你必须通过 props
    将 `bookmarkedArticles` 状态值传递给 `InfoSidebar` 组件，这样该组件就可以将其转发给 `BookmarkInformation`：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The same procedure is repeated inside of the `BookmarkInformation` component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的过程在 `BookmarkInformation` 组件内部重复。
- en: '**Note**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the complete example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/01-cross-cmp-state](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/01-cross-cmp-state)
    .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完整的示例：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/01-cross-cmp-state](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/01-cross-cmp-state)。
- en: This kind of pattern is called **prop drilling** . Prop drilling means that
    a state value is passed through multiple components via props. And it’s passed
    through components that don’t need the state themselves at all—except for forwarding
    it to a child component (as the `InfoSidebar` and `BookmarkInformation` components
    are doing in the preceding example).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为**属性钻取**。属性钻取意味着状态值通过 props 在多个组件之间传递。并且它通过根本不需要状态的组件传递——除了将其转发给子组件（如前一个例子中的
    `InfoSidebar` 和 `BookmarkInformation` 组件所做的那样）。
- en: 'As a developer, you will typically want to avoid this pattern because prop
    drilling has a few weaknesses:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你通常会想避免这种模式，因为属性钻取有几个弱点：
- en: Components that are part of prop drilling (such as `InfoSidebar` or `BookmarkInformation`
    ) are not really reusable anymore because any component that wants to use them
    has to provide a value for the forwarded state prop.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于属性钻取的组件（例如 `InfoSidebar` 或 `BookmarkInformation`）实际上已经不能再重用了，因为任何想要使用它们的组件都必须为转发状态属性提供一个值。
- en: Prop drilling also leads to a lot of overhead code that has to be written (the
    code to accept props and forward props).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性钻取还会导致大量的开销代码需要编写（接受 props 和转发 props 的代码）。
- en: Refactoring components becomes more work because state props have to be added
    or removed.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构组件变得更加困难，因为必须添加或删除状态 props。
- en: For these reasons, prop drilling is only acceptable if all components involved
    are only used in this specific part of the overall React app, and the probability
    of reusing or refactoring them is low.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有当所有涉及的组件仅用于整个 React 应用的特定部分，并且重用或重构它们的可能性很低时，才接受属性钻探。
- en: 'Since prop drilling should be avoided (in most situations), React offers an
    alternative: the **context** API.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大多数情况下应避免使用开孔钻探，React 提供了一个替代方案：**上下文** API。
- en: Using Context to Handle Multi-Component State
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文处理多组件状态
- en: React’s context feature is one that allows you to create a value that can easily
    be shared across as many components as needed, without using props.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: React 的上下文功能允许你创建一个可以轻松地在所需组件之间共享的值，而无需使用属性。
- en: '![A diagram of a website  Description automatically generated](img/B31339_11_04.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![一个网站示意图  自动生成的描述](img/B31339_11_04.png)'
- en: 'Figure 11.4: React Context is attached to components to expose it to all child
    components—without prop drilling'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：React 上下文附加到组件上，以便将其暴露给所有子组件——无需属性钻探
- en: 'Using the context API is a multi-step process, the steps for which are described
    here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文 API 是一个多步骤的过程，其步骤在此处描述：
- en: You must create a context value that should be shared.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须创建一个应该共享的上下文值。
- en: The context must be provided in a parent component of the components that need
    access to the context object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问上下文对象的组件必须在父组件中提供上下文。
- en: Components that need access (for reading or writing) must subscribe to the context.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问（读取或写入）的组件必须订阅上下文。
- en: React manages the context value (and its changes) internally and automatically
    distributes it to all components that have subscribed to the context.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: React 内部管理和自动分发上下文值（及其更改）到所有已订阅上下文的组件。
- en: 'Before any component may subscribe, however, the first step is to create a
    context object. This is done via React’s `createContext()` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在任何一个组件可以订阅之前，第一步是创建一个上下文对象。这是通过 React 的 `createContext()` 函数完成的：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function takes an initial value that should be shared. It can be any kind
    of value (e.g., a string or a number), but typically, it’s an object. This is
    because most shared values are a combination of the actual values and functions
    that should manipulate those values. All these things are then grouped together
    into a single context object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个初始值，该值应该被共享。它可以任何类型的值（例如，字符串或数字），但通常是一个对象。这是因为大多数共享值都是实际值和应该操作这些值的函数的组合。所有这些都被组合成一个单独的上下文对象。
- en: Of course, the initial context value can also be an empty value (e.g., `null`
    , `undefined` , an empty `string` , etc.) if needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果需要，初始上下文值也可以是一个空值（例如，`null`、`undefined`、空字符串等）。
- en: '`createContext()` also returns a value: a context object that should be stored
    in a capitalized variable (or constant) because it’s actually a React component
    (and React components should start with capital characters).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContext()` 还返回一个值：一个上下文对象，应该存储在一个大写变量（或常量）中，因为它实际上是一个 React 组件（React
    组件应以大写字母开头）。'
- en: 'Here’s how the `createContext()` function can be called to create a context
    object for the example discussed earlier in this chapter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何调用 `createContext()` 函数来为本章前面讨论的示例创建上下文对象的方法：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the initial value is an object that contains the `bookmarkedArticles`
    property, which holds an (empty) array. You could also store just the array as
    an initial value (i.e., `createContext([])` ) but an object is better since more
    will be added to it later in the chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，初始值是一个包含 `bookmarkedArticles` 属性的对象，该属性包含一个（空的）数组。你也可以只将数组作为初始值存储（即，`createContext([])`），但对象更好，因为在本章的后面部分还会添加更多内容。
- en: This code is typically placed in a separate context code file (e.g., `bookmark-context.jsx`
    ) that’s often stored in a folder named `store` (because this context feature
    can be used as a central state store) or `context` . However, this is just a convention
    and is not technically required. You can put this code anywhere in your React
    app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通常放置在一个单独的上下文代码文件中（例如，`bookmark-context.jsx`），通常存储在名为 `store` 的文件夹中（因为上下文功能可以用作中央状态存储）或
    `context` 文件夹。然而，这只是一种约定，并不是技术上必需的。你可以在你的 React 应用程序的任何地方放置这段代码。
- en: If the file only contains the above code, it may use `.js` as a file extension
    since it doesn’t contain any JSX code. Later in this chapter, this will change—therefore
    you can already use `.jsx` as an extension.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件只包含上述代码，它可能使用 `.js` 作为文件扩展名，因为它不包含任何 JSX 代码。在本章的后面部分，这将会改变——因此你现在可以使用 `.jsx`
    作为扩展名。
- en: Of course, this initial value is not a replacement for state; it’s a static
    value that never changes. But this was just the first of three steps related to
    context. The next step is to provide the context.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个初始值不是状态的替代品；它是一个永远不会改变的静态值。但这只是与上下文相关的三个步骤中的第一个。下一步是提供上下文。
- en: Providing and Managing Context Values
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供和管理上下文值
- en: In order to use context values in other components, you must first provide the
    value. This is done using the value returned by `createContext()` .
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在其他组件中使用上下文值，你必须首先提供该值。这是通过使用`createContext()`返回的值来完成的。
- en: When using React 19 or higher, that function yields a React component that should
    be wrapped around all other components that need access to the context value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React 19或更高版本时，该函数返回一个React组件，该组件应包裹所有需要访问上下文值的其他组件。
- en: When using an older version of React (i.e., React 18 or older), the value returned
    by `createContext()` instead is an object that contains a nested `Provider` property.
    That property then holds a React component that should be wrapped around all other
    components that need access to the context value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用较旧的React版本（即React 18或更早版本）时，`createContext()`返回的值是一个包含嵌套`Provider`属性的对象。该属性然后包含一个React组件，该组件应包裹所有需要访问上下文值的其他组件。
- en: So, either way, it’s all about wrapping components with a context provider component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论是哪种方式，关键都是用上下文提供者组件包裹组件。
- en: 'In the preceding example, using React 19 or higher, the `BookmarkContext` component
    returned by `createContext()` could be used in the `News` component to wrap it
    around both the `Articles` and `InfoSidebar` components:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用React 19或更高版本时，`createContext()`返回的`BookmarkContext`组件可以在`News`组件中使用，将其包裹在`Articles`和`InfoSidebar`组件周围：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or, if using React 18 or lower:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果使用React 18或更低版本：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, this code does not work because one important thing is missing: the
    component expects a `value` prop, which should contain the current context value
    that should be distributed to interested components. While you do provide an initial
    context value (which could have been empty), you also need to inform React about
    the current context value because, very often, context values change (they are
    often used as a replacement for the cross-component state, after all).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码无法正常工作，因为缺少了一个重要的事项：组件期望一个`value`属性，该属性应包含要分发给感兴趣组件的当前上下文值。虽然你提供了初始上下文值（可能为空），但你还需要通知React关于当前上下文值的信息，因为上下文值经常发生变化（毕竟它们经常被用作跨组件状态的替代品）。
- en: 'Hence, the code could be altered like this when using React 19 or higher:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用React 19或更高版本时，代码可以修改如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, if using React 18 or lower:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果使用React 18或更低版本：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code, an object with a list of bookmarked articles is distributed
    to interested descendent components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，一个包含已标记文章列表的对象被分发给感兴趣的子组件。
- en: 'The list is still static, though. But that can be changed with a tool you already
    know about: the `useState()` Hook. Inside the `News` component, you can use the
    `useState()` Hook to manage the list of bookmarked articles, like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表仍然是静态的。但你可以使用你已知的工具来更改这一点：`useState()`钩子。在`News`组件内部，你可以使用`useState()`钩子来管理已标记文章的列表，如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this change, the context changes from static to dynamic. Whenever the `savedArticles`
    state changes, the context value will change.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，上下文从静态变为动态。每当`savedArticles`状态发生变化时，上下文值也会发生变化。
- en: Therefore, that’s the missing piece when it comes to providing the context.
    If the context should be dynamic (and changeable from inside some nested child
    component), the context value should also include a pointer to the function that
    triggers a state update.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是提供上下文时缺失的部分。如果上下文应该是动态的（并且可以从某个嵌套子组件内部更改），上下文值也应包括指向触发状态更新的函数的指针。
- en: 'For the preceding example, the code is therefore adjusted like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的示例，代码因此调整为如下所示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are two important things changed in this code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码片段中更改的两个重要事项：
- en: 'Two new functions were added: `addArticle` and `removeArticle` .'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了两个新函数：`addArticle`和`removeArticle`。
- en: 'Properties that point at these functions were added to `bookmarkCtxValue` :
    the `bookmarkArticle` and `unbookmarkArticle` methods.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指向这些函数的属性添加到了`bookmarkCtxValue`：`bookmarkArticle`和`unbookmarkArticle`方法。
- en: The `addArticle` function adds a new article (which should be bookmarked) to
    the `savedArticles` state. The function form of updating the state value is used
    since the new state value depends on the previous state value (the bookmarked
    article is added to the list of already bookmarked articles).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`addArticle` 函数将一篇新的文章（应该被书签）添加到 `savedArticles` 状态中。由于新的状态值依赖于前一个状态值（已书签的文章被添加到已书签文章的列表中），因此使用了更新状态值的函数形式。'
- en: Similarly, the `removeArticle` function removes an article from the `savedArticles`
    list by filtering the existing list such that all items, except for the one that
    has a matching `id` value, are kept.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`removeArticle` 函数通过过滤现有列表，保留所有除具有匹配 `id` 值之外的项目，从而从 `savedArticles` 列表中删除一篇文章。
- en: If the `News` component did not use the new context feature, it would be a component
    that uses state, just as you have seen many times before in this book. But now,
    by using React’s context API, those existing capabilities are combined with a
    new feature (the context) to create a dynamic, distributable value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `News` 组件没有使用新的上下文功能，它将是一个使用状态的组件，就像你在本书中多次看到的。但现在，通过使用 React 的上下文 API，这些现有功能与一个新特性（上下文）结合，创建了一个动态的、可分发的值。
- en: Any components nested in the `Articles` or `InfoSidebar` components (or their
    descendent components) will be able to access this dynamic context value, and
    the `bookmarkArticle` and `unbookmarkArticle` methods in the context object, without
    any prop drilling.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套在 `Articles` 或 `InfoSidebar` 组件（或其子组件）中的任何组件都将能够访问这个动态上下文值，以及上下文对象中的 `bookmarkArticle`
    和 `unbookmarkArticle` 方法，而无需任何属性传递。
- en: '**Note**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You don’t have to create dynamic context values. You could also distribute a
    static value to nested components. This is possible but a rare scenario, since
    most React apps typically need dynamic state values that can change across components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必创建动态上下文值。你也可以将静态值分发给嵌套组件。这种情况是可能的，但很少见，因为大多数 React 应用通常需要可以在组件间变化的动态状态值。
- en: Using Context in Nested Components
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在嵌套组件中使用 Context
- en: With the context created and provided, it’s ready to be used by components that
    need to access or change the context value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文创建并提供了之后，它就准备好被需要访问或更改上下文值的组件使用了。
- en: To make the context value accessible to components nested inside the context
    component ( `BookmarkContext` , in the preceding example), React offers a `use()`
    Hook that can be used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使上下文值对上下文组件内部的组件（例如，前一个示例中的 `BookmarkContext`）可用，React 提供了一个 `use()` 钩子，它可以被使用。
- en: This Hook, however, is only available when working with React 19 or higher.
    In projects that use older React versions, you would instead use the `useContext()`
    Hook for accessing some context value. That Hook is also still supported in React
    19, hence you can use either of the two Hooks for getting hold of a context value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个钩子仅在 React 19 或更高版本中可用。在使用较旧 React 版本的项目中，你将使用 `useContext()` 钩子来访问某些上下文值。该钩子也在
    React 19 中仍然得到支持，因此你可以使用这两个钩子中的任何一个来获取上下文值。
- en: The `use()` Hook is a bit more flexible than the `useContext()` Hook since,
    unlike any other Hooks, it may actually also be used from inside `if` statements
    or loops. In addition, the Hook can be used for more than getting access to context
    values—you’ll therefore see `use()` again in *Chapter 17* , *Understanding React
    Suspense & The use() Hook* .
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`use()` 钩子比 `useContext()` 钩子更灵活一些，因为与其他任何钩子不同，它实际上也可以在 `if` 语句或循环内部使用。此外，钩子不仅可以用来获取上下文值——因此你将在
    *第17章* 中再次看到 `use()`，即 *理解 React Suspense 与 use() 钩子*。'
- en: 'As mentioned, when working with React 19, if you’re trying to get access to
    a context value, both `use()` and `useContext()` can be used. Both `use()` and
    `useContext()` require one argument: the context object that was created via `createContext()`
    , i.e., the value returned by that function. As a result, you’ll then get the
    value passed to the context provider component (i.e., the value set for its `value`
    prop). When working with React 19 or higher, since `use()` is a bit more flexible
    and certainly a bit less to type, you can ignore `useContext()` and use the `use()`
    Hook for accessing context values.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当使用 React 19 时，如果你试图获取上下文值，可以使用 `use()` 和 `useContext()`。`use()` 和 `useContext()`
    都需要一个参数：通过 `createContext()` 创建的上下文对象，即该函数返回的值。因此，你将得到传递给上下文提供组件的值（即为其 `value`
    属性设置的值）。当使用 React 19 或更高版本时，由于 `use()` 更灵活，并且输入更少，你可以忽略 `useContext()` 并使用 `use()`
    钩子来访问上下文值。
- en: 'For the preceding example, the context value can be used in the `BookmarkSummary`
    component like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的例子，上下文值可以在`BookmarkSummary`组件中使用，如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code, `use()` receives the `BookmarkContext` value, which is imported
    from the `store/bookmark-context.jsx` file. It then returns the value stored in
    the context, which is the `bookmarkCtxValue` found in the previous code example.
    As you can see in that snippet, `bookmarkCtxValue` is an object with three properties:
    `bookmarkedArticles` , `bookmarkArticle` (a method), and `unbookmarkArticle` (also
    a method).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码中，`use()`接收从`store/bookmark-context.jsx`文件导入的`BookmarkContext`值。然后它返回上下文中存储的值，即在前面的代码示例中找到的`bookmarkCtxValue`。正如你可以在那个片段中看到的那样，`bookmarkCtxValue`是一个具有三个属性的对象：`bookmarkedArticles`、`bookmarkArticle`（一个方法）和`unbookmarkArticle`（也是一个方法）。
- en: This returned object is stored in a `bookmarkCtx` constant. Whenever the context
    value changes (because the `setSavedArticles` state-updating function in the `News`
    component is executed), this `BookmarkSummary` component will also be executed
    again by React, and thus `bookmarkCtx` will hold the latest state value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个返回的对象被存储在`bookmarkCtx`常量中。每当上下文值改变（因为`News`组件中的`setSavedArticles`状态更新函数被执行），React将再次执行这个`BookmarkSummary`组件，因此`bookmarkCtx`将持有最新的状态值。
- en: Finally, in the `BookmarkSummary` component, the `bookmarkedArticles` property
    is accessed on the `bookmarkCtx` object. This list of articles is then used to
    calculate the number of bookmarked articles, output a short summary, and display
    the list on the screen.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`BookmarkSummary`组件中，通过`bookmarkCtx`对象访问`bookmarkedArticles`属性。然后使用这篇文章列表来计算已标记文章的数量，输出简短摘要，并在屏幕上显示列表。
- en: 'Similarly, `BookmarkContext` can be used via `use()` in the `Articles` component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`BookmarkContext`可以通过`use()`在`Articles`组件中使用：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this component, the context is used to determine whether or not a given article
    is currently bookmarked (this information is required in order to change the icon
    and functionality of the button).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，上下文被用来确定给定的文章是否当前被书签标记（为了改变按钮的图标和功能，需要这个信息）。
- en: That’s how context values (whether static or dynamic) can be read in components.
    Of course, they can also be changed, as discussed in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是上下文值（无论是静态的还是动态的）如何在组件中被读取。当然，它们也可以像下一节讨论的那样被更改。
- en: Changing Context from Nested Components
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从嵌套组件更改上下文
- en: React’s context feature is often used to share data across multiple components
    without using props. It’s therefore also quite common that some components must
    manipulate that data. For example, the context value for a shopping cart must
    be adjustable from inside the component that displays product items (because those
    probably have an `"Add to cart"` button).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: React的上下文特性通常用于在多个组件之间共享数据，而不使用props。因此，一些组件必须操纵这些数据也是相当常见的。例如，购物车的上下文值必须可以从显示产品项的组件内部进行调整（因为这些可能有一个“添加到购物车”按钮）。
- en: 'However, to change context values from inside a nested component, you cannot
    simply overwrite the stored context value. The following code would not work as
    intended:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要从嵌套组件内部更改上下文值，你不能简单地覆盖存储的上下文值。以下代码不会按预期工作：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code does not work. Just as you should not try to update state by simply
    assigning a new value, you can’t update context values by assigning a new value.
    That’s why two methods ( `bookmarkArticle` and `unbookmarkArticle` ) were added
    to the context value in the *Providing and Managing Context Values* section. These
    two methods point at functions that trigger state updates (via the state-updating
    function provided by `useState()` ).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不起作用。正如你不应该尝试通过简单地分配一个新值来更新状态一样，你也不能通过分配新值来更新上下文值。这就是为什么在*提供和管理上下文值*部分添加了两个方法（`bookmarkArticle`和`unbookmarkArticle`）到上下文值中。这两个方法指向触发状态更新的函数（通过`useState()`提供的状态更新函数）。
- en: 'Therefore, in the `Articles` component, where articles can be bookmarked or
    unbookmarked via button clicks, these methods should be called:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可以通过按钮点击进行标记或取消标记文章的`Articles`组件中，应该调用这些方法：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `bookmarkArticle` and `unbookmarkArticle` methods are called inside of anonymous
    functions that are stored in a `buttonAction` variable. That variable is assigned
    to the `onClick` prop of the `<button>` (see the previous code snippet).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookmarkArticle`和`unbookmarkArticle`方法在存储在`buttonAction`变量中的匿名函数内部被调用。这个变量被分配给`<button>`的`onClick`属性（参见前面的代码片段）。'
- en: With this code, the context value can be changed successfully. Thanks to the
    steps taken in the previous section ( *Using Context in Nested Components* ),
    whenever the context value is updated, it is then also automatically reflected
    in the user interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，可以成功更改上下文值。多亏了上一节（*在嵌套组件中使用上下文*）中采取的步骤，每当上下文值更新时，它也会自动反映在用户界面上。
- en: '**Note**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The finished example code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/02-cross-cmp-state-with-context](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/02-cross-cmp-state-with-context)
    .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的示例代码可以在GitHub上找到，地址为[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/02-cross-cmp-state-with-context](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/02-cross-cmp-state-with-context)。
- en: Using the Context API Efficiently
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用上下文API
- en: Being able to create, provide, access, and change context is important—ultimately,
    it is these things that allow you to use React’s context API in your applications.
    But as your applications (and therefore probably also your context values) become
    more complex, it’s also important to set up and manage your context efficiently,
    for example, by getting proper IDE support.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建、提供、访问和更改上下文很重要——最终，正是这些事情允许您在应用程序中使用React的上下文API。但随着您的应用程序（以及因此可能也是您的上下文值）变得更加复杂，设置和管理您的上下文高效也很重要，例如，通过获得适当的IDE支持。
- en: Getting Better Code Completion
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获得更好的代码自动完成
- en: In the section *Using Context to Handle Multi-Component State* , a context object
    was created via `createContext()` . That function received an initial context
    value—an object that contains a `bookmarkedArticles` property, in the preceding
    example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用上下文处理多组件状态* 这一部分，通过`createContext()`创建了一个上下文对象。该函数接收一个初始上下文值——一个包含`bookmarkedArticles`属性的对象，在前面的例子中。
- en: In this example, the initial context value isn’t too important. It’s not often
    used because it’s overwritten with a new value inside the `News` component regardless.
    However, depending on which **Integrated Development Environment** **(IDE** )
    you’re using, you can get better code auto-completion when defining an initial
    context value that has the same shape and structure as the final context value
    that will be managed in other React components.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，初始上下文值并不重要。它不常使用，因为无论怎样，它都会在`News`组件内部被新的值覆盖。然而，根据您使用的**集成开发环境**（IDE），在定义具有与最终上下文值相同形状和结构的初始上下文值时，您可以得到更好的代码自动完成。
- en: 'Therefore, since two methods were added to the context value in the section
    *Providing and Managing Context Values* , those methods should also be added to
    the initial context value in `store/bookmark-context.jsx` :'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于在 *提供和管理上下文值* 这一部分中向上下文值添加了两种方法，因此这些方法也应添加到`store/bookmark-context.jsx`中的初始上下文值中：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The two methods are added as empty functions that do nothing because the actual
    logic is set in the `News` component. The methods are only added to this initial
    context value to provide better IDE auto-completion. This step is therefore optional.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法被添加为空函数，因为实际的逻辑是在`News`组件中设置的。这些方法仅添加到这个初始上下文值中，以提供更好的IDE自动完成。因此，这一步是可选的。
- en: Context or Lifting State Up?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文或提升状态？
- en: 'At this point, you now have two tools for managing cross-component state:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您现在有两个管理跨组件状态的工具：
- en: You can lift state up, as described earlier in the book (in *Chapter 4* , *Working
    with Events and State* , in the *Lifting State Up* section).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以提升状态，正如本书前面所描述的（在第4章 *与事件和状态一起工作* 的 *提升状态* 部分）。
- en: Alternatively, you can use React’s context API, as explained in this chapter.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以使用本章中解释的React的上下文API。
- en: Which of the two approaches should you use in each scenario?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，您应该使用哪种方法？
- en: 'Ultimately, it is up to you how you manage this, but there are some straightforward
    rules you can follow:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如何管理这取决于您，但有一些简单的规则您可以遵循：
- en: Lift the state up if you only need to share state across one or two levels of
    component nesting.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只需要在组件嵌套的一到两层之间共享状态，请提升状态。
- en: Use the context API if you have long chains of components (i.e., deep nesting
    of components) with shared state. Once you start to use a lot of prop drilling,
    it’s time to consider React’s context feature.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有长链组件（即组件的深层嵌套）并且有共享状态，请使用上下文API。一旦您开始使用大量的属性传递，就是考虑React的上下文功能的时候了。
- en: Also use the context API if you have a relatively flat component tree but want
    to reuse components (i.e., you don’t want to use props for passing state to components).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个相对扁平的组件树但想要重用组件（即，你不想使用props将状态传递给组件），也可以使用上下文API。
- en: Outsourcing Context Logic into Separate Components
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将上下文逻辑外包到单独的组件中
- en: With the previously explained steps, you have everything you need to manage
    cross-component state via context.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前解释的步骤，你已经拥有了通过上下文管理跨组件状态所需的一切。
- en: 'But there is one pattern you can consider for managing your dynamic context
    value and state: creating a separate component for providing (and managing) the
    context value.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以考虑一种模式来管理你的动态上下文值和状态：创建一个专门的组件来提供（和管理）上下文值。
- en: In the preceding example, the `News` component was used to provide the context
    and manage its (dynamic, state-based) value. While this works, your components
    can get unnecessarily complex if they have to deal with context management. Creating
    a separate, dedicated component for that can therefore lead to code that’s easier
    to understand and maintain.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`News` 组件被用来提供上下文并管理其（动态的、基于状态的）值。虽然这样做是可行的，但如果组件需要处理上下文管理，它们可能会变得不必要地复杂。因此，创建一个专门的组件来处理这一点可以导致代码更容易理解和维护。
- en: 'For the preceding example, that means that, inside of the `store/bookmark-context.jsx`
    file, you could create a `BookmarkContextProvider` component that looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的例子，这意味着在 `store/bookmark-context.jsx` 文件中，你可以创建一个看起来像这样的 `BookmarkContextProvider`
    组件：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This component contains all the logic related to managing a list of bookmarked
    articles via state. It creates the same context value as before (a value that
    contains the list of articles as well as two methods for updating that list).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件包含与通过状态管理一系列书签文章相关的所有逻辑。它创建了与之前相同的上下文值（包含文章列表以及更新该列表的两个方法）。
- en: The `BookmarkContextProvider` component does one additional thing though. It
    uses the special `children` prop (covered in *Chapter 3* , *Components and Props*
    , in the *The Special “children” Prop* section) to wrap whatever is passed between
    the `BookmarkContextProvider` 's component tags with `BookmarkContext` .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookmarkContextProvider` 组件做了一件事。它使用特殊的 `children` prop（在第3章的 *Components
    and Props* 部分的 *特殊的“children” prop* 小节中介绍）来包裹在 `BookmarkContextProvider` 组件标签之间传递的任何内容，用
    `BookmarkContext` 包裹。'
- en: 'This allows the use of the `BookmarkContextProvider` component in the `News`
    component, like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在 `News` 组件中使用 `BookmarkContextProvider` 组件，如下所示：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of managing the entire context value, the `News` component now simply
    imports the `BookmarkContextProvider` component and wraps that component around
    `Articles` and `InfoSidebar` . The `News` component, therefore, is leaner.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`News` 组件现在不再管理整个上下文值，而是简单地导入 `BookmarkContextProvider` 组件，并将该组件包裹在 `Articles`
    和 `InfoSidebar` 组件周围。因此，`News` 组件更加精简。'
- en: '**Note**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This pattern is entirely optional. It’s neither an official best practice nor
    does it yield any performance benefits. It’s just a pattern that can help with
    keeping your component functions lean and concise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式完全是可选的。它既不是官方的最佳实践，也不会带来任何性能上的好处。它仅仅是一个可以帮助你保持组件函数简洁和精炼的模式。
- en: It’s also worth mentioning that there is a related pattern for consuming context.
    That pattern, however, relies on building a custom React Hook—a concept that will
    be covered in the next chapter. Therefore, the mentioned context consumption pattern
    will be covered in the next chapter, too.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，还有一个相关的模式用于消费上下文。然而，该模式依赖于构建自定义的React Hook——这个概念将在下一章中介绍。因此，提到的上下文消费模式也将放在下一章中介绍。
- en: Combining Multiple Contexts
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合多个上下文
- en: Especially in bigger and more feature-rich React applications, it is possible
    (and quite probable), that you will need to work with multiple context values
    that are likely unrelated to each other. For example, an online shop could use
    one context for managing the shopping cart, another context for the user authentication
    status, and yet another context value for tracking page analytics.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在更大、功能更丰富的React应用程序中，你可能会需要处理多个可能彼此无关的上下文值。例如，一个在线商店可能会使用一个上下文来管理购物车，另一个上下文来管理用户认证状态，还有另一个上下文值来跟踪页面分析。
- en: React fully supports use cases like this. You can create, manage, provide, and
    use as many context values as needed. You can manage multiple (related or unrelated)
    values in a single context or use multiple contexts. You can provide multiple
    contexts in the same component or in different components. It is totally up to
    you and your app’s requirements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: React完全支持这种用例。你可以根据需要创建、管理、提供和使用尽可能多的上下文值。你可以在单个上下文中管理多个（相关或不相关的）值，或者使用多个上下文。你可以在同一个组件或不同组件中提供多个上下文。这完全取决于你和你应用程序的需求。
- en: You can also use multiple contexts in the same component (meaning that you can
    call `use()` or `useContext()` multiple times, with different context values).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在同一个组件中使用多个上下文（这意味着你可以多次调用`use()`或`useContext()`，并使用不同的上下文值）。
- en: Limitations of useState( )
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useState()`的局限性'
- en: Thus far in this chapter, the complexity of cross-component state has been explored.
    But state management can also get challenging in scenarios where some state is
    only used inside a single component.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经探讨了跨组件状态复杂性。但在某些情况下，一些状态仅在单个组件内部使用时，状态管理也可能具有挑战性。
- en: '`useState()` is a great tool for state management in most scenarios (of course,
    right now, it’s also the only tool that’s been covered). Therefore, `useState()`
    should be your default choice for managing state. But `useState()` can reach its
    limits if you need to derive a new state value that’s based on the value of another
    state variable, as in this example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下（当然，目前它也是唯一被介绍的工具），`useState()`是状态管理的一个很好的工具。因此，`useState()`应该是你管理状态的首选。但是，如果你需要根据另一个状态变量的值推导出新的状态值，例如在这个例子中，`useState()`可能会达到其极限：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This short snippet is taken from a component where an HTTP request is sent
    to fetch some blog posts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的片段是从一个组件中提取的，该组件向服务器发送HTTP请求以获取一些博客文章：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Note**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You’ll find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/04-complex-usestate](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/04-complex-usestate)
    .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的示例代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/04-complex-usestate](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/04-complex-usestate)。
- en: When initiating the request, an `isLoading` state value (responsible for showing
    a loading indicator on the screen) should be set to `true` only if no data was
    fetched before. If data was fetched before (i.e., `fetchedPosts` is not `null`
    ), that data should still be shown on the screen, instead of some loading indicator.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化请求时，只有在没有获取到数据之前，`isLoading`状态值（负责在屏幕上显示加载指示器）才应该设置为`true`。如果之前已经获取了数据（即`fetchedPosts`不是`null`），那么应该仍然在屏幕上显示这些数据，而不是某个加载指示器。
- en: 'At first sight, this code might not look problematic. But it actually violates
    an important rule related to `useState()` : you should not reference the current
    state to set a new state value. If you need to do so, you should instead use the
    function form of the state updating function (see the *Updating State Based on
    Previous State Correctly* section of *Chapter 4* , *Working with Events and State*
    ).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '初看之下，这段代码可能看似没有问题。但实际上，它违反了与`useState()`相关的一个重要规则：你不应该引用当前状态来设置新的状态值。如果你需要这样做，你应该使用状态更新函数的函数形式（参见第四章“基于前一个状态正确更新状态”部分）。 '
- en: However, in the preceding example, this solution won’t work. If you switch to
    the functional state-updating form, you only get access to the current value of
    the state you’re trying to update. You don’t get (safe) access to the current
    value of some other state. In the preceding example, another state ( `fetchedPosts`
    instead of `isLoading` ) is referenced. Therefore, you must violate the mentioned
    rule.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在前面的例子中，这个解决方案不起作用。如果你切换到函数状态更新形式，你只能访问你试图更新的状态的当前值。你不能（安全地）访问其他状态的当前值。在前面的例子中，另一个状态（`fetchedPosts`而不是`isLoading`）被引用。因此，你必须违反上述规则。
- en: 'This violation also has real consequences (in this example). The following
    code snippet is part of a function called `fetchPosts` , which is wrapped with
    `useCallback()` :'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种违规也有实际后果（在这个例子中）。以下代码片段是`fetchPosts`函数的一部分，该函数被`useCallback()`包装：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function sends an HTTP request and changes multiple state values based
    on the state of the request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数发送HTTP请求，并根据请求的状态更改多个状态值。
- en: '`useCallback()` is used to avoid an infinite loop related to `useEffect()`
    (see *Chapter 8* , *Handling Side Effects* , to learn more about `useEffect()`
    , infinite loops, and `useCallback()` as a remedy). Normally, `fetchedPosts` should
    be added as a dependency to the `dependencies` array passed as a second argument
    to the `useCallback()` function. However, in this example, this can’t be done
    because `fetchedPosts` is changed inside the function wrapped by `useCallback()`
    , and the state value is therefore not just a dependency but also actively changed.
    This causes an infinite loop.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback()` 用于避免与 `useEffect()` 相关的无限循环（参见 *第 8 章* ，*处理副作用* ，了解更多关于 `useEffect()`
    ，无限循环和 `useCallback()` 作为补救措施的信息）。通常，`fetchedPosts` 应该作为依赖项添加到传递给 `useCallback()`
    函数的第二个参数 `dependencies` 数组中。然而，在这个例子中，这不可能完成，因为 `fetchedPosts` 在 `useCallback()`
    包装的函数内部被更改，因此状态值不仅是一个依赖项，而且还被积极更改。这导致无限循环。'
- en: 'As a result, a warning is shown in the terminal and the intended behavior of
    not showing the loading indicator if data was fetched before is not achieved:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在终端中显示了一个警告，并且没有达到在数据之前获取数据时不显示加载指示器的预期行为：
- en: '![img](img/B31339_11_05.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_11_05.png)'
- en: 'Figure 11.5: A warning about the missing dependency is output in the terminal'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：在终端中输出关于缺少依赖项的警告
- en: Problems like the one just described are common if you have multiple related
    state values that depend on each other.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个人相关联的状态值相互依赖，那么像刚才描述的问题很常见。
- en: 'One possible solution would be to move from multiple, individual state slices
    ( `fetchedPosts` , `isLoading` , and `error` ) to a single, combined state value
    (i.e., to an object). That would ensure that all state values are grouped together
    and can thereby be accessed safely when using the functional state-updating form.
    The state-updating code could then look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是将多个单独的状态片段（`fetchedPosts`，`isLoading` 和 `error`）移动到一个单一的组合状态值（即一个对象）。这将确保所有状态值都组合在一起，并且因此在使用功能状态更新形式时可以安全地访问。状态更新代码可以如下所示：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This solution would work. However, ending up with ever more complex (and nested)
    state objects, managed via `useState()` , is not typically desirable as it can
    make state management a bit harder and bloat your component code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案将有效。然而，通过 `useState()` 管理的越来越复杂（且嵌套）的状态对象通常是不希望的，因为它可以使状态管理变得有点困难，并膨胀你的组件代码。
- en: 'That’s why React offers an alternative to `useState()` : the `useReducer()`
    Hook.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，React 提供了 `useState()` 的一个替代方案：`useReducer()` Hook。
- en: Managing State with useReducer( )
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 useReducer() 管理状态
- en: Just like `useState()` , `useReducer()` is a React Hook. And just like `useState()`
    , it is a Hook that can trigger component function re-evaluations. But, of course,
    it works slightly differently; otherwise, it would be a redundant Hook.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `useState()` 一样，`useReducer()` 也是一个 React Hook。并且就像 `useState()` 一样，它是一个可以触发组件函数重新评估的
    Hook。但是，当然，它的工作方式略有不同；否则，它将是一个多余的 Hook。
- en: '`useReducer()` is a Hook meant to be used for managing complex state objects.
    You will rarely (probably never) use it to manage simple string or number values.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer()` 是一个 Hook，旨在用于管理复杂的状态对象。你很少（可能永远）会使用它来管理简单的字符串或数字值。'
- en: 'This Hook takes two main arguments:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Hook 采取两个主要参数：
- en: A reducer function
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer 函数
- en: An initial state value
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始状态值
- en: 'This brings up an important question: what is a reducer function?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个重要问题：什么是 reducer 函数？
- en: Understanding Reducer Functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Reducer 函数
- en: 'In the context of `useReducer()` , a reducer function is a function that receives
    two parameters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `useReducer()` 的上下文中，reducer 函数是一个接收两个参数的函数：
- en: The current state value
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态值
- en: An action that was dispatched
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已分发的动作
- en: 'Besides receiving arguments, a reducer function must also return a value: the
    new state. It’s called a reducer function because it reduces the old state (combined
    with an action) to a new state.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接收参数外，reducer 函数还必须返回一个值：新的状态。它被称为 reducer 函数，因为它将旧状态（与一个动作结合）减少到新状态。
- en: 'To make this all a bit easier to grasp and reason through, the following code
    snippet shows how `useReducer()` is used in conjunction with such a reducer function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一切更容易理解并推理，以下代码片段展示了如何与这样的 reducer 函数结合使用 `useReducer()`：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At the bottom of this snippet, you can see that `useReducer()` is called inside
    of the `App` component function. Like all React Hooks, it must be called inside
    of component functions or other Hooks. You can also see the two arguments that
    were mentioned previously (the reducer function and the initial state value) being
    passed to `useReducer()` .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段的底部，你可以看到`useReducer()`是在`App`组件函数内部被调用的。像所有React Hooks一样，它必须在组件函数或其他Hooks内部调用。你还可以看到之前提到的两个参数（reducer函数和初始状态值）被传递给`useReducer()`。
- en: '`httpReducer` is the reducer function. The function takes two arguments ( `state`
    , which is the old state, and `action` , which is the dispatched action) and returns
    different state objects for different action types.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpReducer`是reducer函数。该函数接受两个参数（`state`，即旧状态，和`action`，即发送的动作）并为不同的动作类型返回不同的状态对象。'
- en: This reducer function takes care of all possible state updates. The entire state-updating
    logic is therefore outsourced from the component (note that `httpReducer` is defined
    outside of the component function).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个reducer函数负责处理所有可能的状态更新。因此，整个状态更新逻辑都是从组件中外包出去的（注意，`httpReducer`是在组件函数外部定义的）。
- en: But the component function must, of course, be able to trigger the defined state
    updates. That’s where actions become important.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但组件函数当然必须能够触发定义的状态更新。这就是动作变得重要的地方。
- en: '**Note**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In this example, the reducer function is created outside of the component function.
    You could also create it inside the component function, but that is not recommended.
    If you create the reducer function inside the component function, it will technically
    be recreated every time the component function is executed. This impacts performance
    unnecessarily since the reducer function does not need access to any component
    function values (state or props).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，reducer 函数是在组件函数外部创建的。你也可以在组件函数内部创建它，但这样做并不推荐。如果你在组件函数内部创建reducer函数，它将每次组件函数执行时都会被重新创建。这会不必要地影响性能，因为reducer函数不需要访问任何组件函数的值（状态或属性）。
- en: Dispatching Actions
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送动作
- en: The code shown previously is incomplete. When calling `useReducer()` in a component
    function, it does not just take two arguments. Instead, the Hook also returns
    a value—an array with exactly two elements (just like `useState()` , though the
    elements are different).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的代码是不完整的。在组件函数中调用`useReducer()`时，它不仅仅接受两个参数。相反，这个Hook还返回一个值——一个恰好有两个元素的数组（就像`useState()`一样，尽管元素是不同的）。
- en: '`useReducer()` should therefore be used like this (in the `App` component):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`useReducer()` 应该这样使用（在`App`组件中）：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this snippet, array destructuring is used to store the two elements (and
    it is always exactly two!) in two different constants: `httpState` and `dispatch`
    .'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，使用数组解构将两个元素（总是恰好两个！）存储在两个不同的常量中：`httpState`和`dispatch`。
- en: The first element in the returned array ( `httpState` , in this case) is the
    state value returned by the reducer function. It’s updated (meaning that the component
    function is called by React) whenever the reducer function is executed again.
    The element is called `httpState` in this example because it contains the state
    value, which is related to an HTTP request in this instance. That said, how you
    name the element in your case is up to you.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组中的第一个元素（在这个例子中是`httpState`）是reducer函数返回的状态值。每当reducer函数再次执行时，它就会被更新（这意味着React会调用组件函数）。在这个例子中，元素被称作`httpState`，因为它包含与HTTP请求相关的状态值。但说到底，你如何命名这个元素取决于你。
- en: 'The second element ( `dispatch` , in the example) is a function. It’s a function
    that can be called to trigger a state update (i.e., to execute the reducer function
    again). When executed, the `dispatch` function must receive one argument—that
    is, the action value that will be available inside of the reducer function (via
    the reducer function’s second argument). Here’s how `dispatch` can be used in
    a component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素（在这个例子中是`dispatch`）是一个函数。这是一个可以调用来触发状态更新（即再次执行reducer函数）的函数。当执行时，`dispatch`函数必须接收一个参数——即将在reducer函数内部（通过reducer函数的第二个参数）可用的动作值。以下是如何在组件中使用`dispatch`的示例：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The element is called `dispatch` in the example because it’s a function used
    for dispatching actions to the reducer function. Just as before, the name is up
    to you, but `dispatch` is a commonly chosen name.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，元素被称作`dispatch`，因为它是一个用于向reducer函数发送动作的函数。就像之前一样，名称由你决定，但`dispatch`是一个常用的名称。
- en: 'The shape and structure of that action value are also entirely up to you, but
    it’s often set to an object that contains a `type` property. The `type` property
    is used in the reducer function to perform different actions for different types
    of actions. `type` therefore acts as an action identifier. You can see the `type`
    property being used inside the `httpReducer` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那个动作值的形状和结构完全取决于你，但通常设置为一个包含`type`属性的对象。`type`属性在reducer函数中用于执行不同类型的动作。因此，`type`充当动作标识符。你可以在`httpReducer`函数内部看到`type`属性的使用：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can add as many properties to the action object as needed. In the preceding
    example, some state updates access `action.payload` to extract some extra data
    from the action object. Inside a component, you would pass data along with the
    action like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要向动作对象添加任意多的属性。在前面的例子中，一些状态更新通过访问`action.payload`从动作对象中提取一些额外数据。在一个组件内部，你会像这样传递数据与动作：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, the property name ( `payload` ) is up to you, but passing extra data
    along with the action allows you to perform state updates that rely on data generated
    by the component function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，属性名（`payload`）由你决定，但将额外数据与动作一起传递允许你执行依赖于组件函数生成数据的状态更新。
- en: 'Here’s the complete, final code for the entire `App` component function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个`App`组件函数的完整、最终代码：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this code snippet, you can see how different actions (with different `type`
    and sometimes `payload` properties) are dispatched. You can also see that the
    `httpState` value is used to show different user interface elements based on the
    state (e.g., `<p>Loading…</p>` is shown if `httpState.isLoading` is `true` ).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你可以看到如何派发不同的动作（具有不同的`type`和有时`payload`属性）。你还可以看到`httpState`值被用来根据状态显示不同的用户界面元素（例如，如果`httpState.isLoading`为`true`，则显示`<p>Loading…</p>`）。
- en: Summary and Key Takeaways
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: State management can have its challenges—especially when dealing with cross-component
    (or app-wide) state or complex state values.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理可能有其挑战——尤其是在处理跨组件（或全局）状态或复杂状态值时。
- en: Cross-component state can be managed by lifting state up or by using React’s
    context API.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨组件状态可以通过提升状态或使用React的上下文API来管理。
- en: The context API is typically preferable if you do a lot of prop drilling (forwarding
    state values via props across multiple component layers).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你进行大量的属性钻探（通过props在多个组件层之间传递状态值）时，上下文API通常是首选的。
- en: When using the context API, you use `createContext()` to create a new context
    object.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用上下文API时，你使用`createContext()`来创建一个新的上下文对象。
- en: The created context object is a component that must be wrapped around the part
    of the component tree that should get access to the context.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建的上下文对象是一个必须包裹在应该访问上下文的组件树部分的组件。
- en: When working with React 18 or older, the context object itself is not a component
    but an object that offers a nested `Provider` property that is a component.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用React 18或更早版本时，上下文对象本身不是一个组件，而是一个提供嵌套`Provider`属性的对象，该属性是一个组件。
- en: Components can access the context value via the `use()` (with React 19 or higher)
    or `useContext()` Hooks.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件可以通过`use()`（在React 19或更高版本中）或`useContext()`钩子访问上下文值。
- en: For managing complex state values, `useReducer()` can be a good alternative
    to `useState()` .
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于管理复杂状态值，`useReducer()`可以是一个比`useState()`更好的替代方案。
- en: '`useReducer()` utilizes a reducer function that converts the current state
    and a dispatched action to a new state value.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer()`利用一个将当前状态和已派发的动作转换为新的状态值的reducer函数。'
- en: '`useReducer()` returns an array with exactly two elements: the state value
    and a dispatch function, which is used for dispatching actions.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer()`返回一个包含恰好两个元素的数组：状态值和一个派发函数，用于派发动作。'
- en: What’s Next?
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Being able to manage both simple and complex state values efficiently is important.
    This chapter introduced two crucial tools that help with the task.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 能够有效地管理简单和复杂的状态值非常重要。本章介绍了两个帮助完成这项任务的关键工具。
- en: With the context API’s `use()` , `useContext()` , and `useReducer()` Hooks,
    three new React Hooks were introduced. Combined with all the other Hooks covered
    thus far in the book, these mark the last of the React Hooks you will need in
    your everyday work as a React developer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上下文API的`use()`、`useContext()`和`useReducer()`钩子，引入了三个新的React钩子。结合本书迄今为止涵盖的所有其他钩子，这些标志着作为React开发者日常工作中所需的最后一个React钩子。
- en: As a React developer, you’re not limited to the built-in Hooks, though. You
    can also build your own Hooks. The next chapter will finally explore how that
    works and why you might want to build custom Hooks in the first place.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管作为React开发者，你不仅限于内置的Hooks，你还可以构建自己的Hooks。下一章将最终探讨这是如何工作的，以及为什么你可能想要首先构建自定义Hooks。
- en: Test Your Knowledge!
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/11-complex-state/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/11-complex-state/exercises/questions-answers.md)
    :'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的理解。然后，你可以将你的答案与在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/11-complex-state/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/11-complex-state/exercises/questions-answers.md)中可以找到的示例进行比较：
- en: Which problem can be solved with React’s context API?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用React的上下文API可以解决哪些问题？
- en: Which three main steps have to be taken when using the context API?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上下文API时，必须采取哪三个主要步骤？
- en: When might `useReducer()` be preferred over `useState()` ?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下，`useReducer()`可能比`useState()`更可取？
- en: When working with `useReducer()` , what’s the role of actions?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`useReducer()`时，动作的作用是什么？
- en: Apply What You Learned
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: Apply your knowledge about the context API and the `useReducer()` Hook to some
    real problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将你对上下文API和`useReducer()` Hook的知识应用于一些实际问题。
- en: 'Activity 11.1: Migrating an App to the Context API'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动内容11.1：将应用迁移到上下文API
- en: In this activity, your task is to improve an existing React project. Currently,
    the app is built without the context API, and so cross-component state is managed
    by lifting the state up. In this project, prop drilling is the consequence in
    some components. Therefore, the goal is to adjust the app such that the context
    API is used for cross-component state management.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是改进现有的React项目。目前，该应用没有使用上下文API构建，因此跨组件状态是通过提升状态来管理的。在这个项目中，某些组件出现了prop
    drilling（属性钻取）的问题。因此，目标是调整应用，使其使用上下文API进行跨组件状态管理。
- en: '**Note**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    in this case) to use the right code snapshot.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1-start)找到此活动的起始代码。下载此代码时，您将始终下载整个存储库。请确保导航到包含起始代码的子文件夹（在本例中为`activities/practice-1-start`），以使用正确的代码快照。
- en: The provided project also uses many features covered in earlier chapters. Take
    your time to analyze it and understand the provided code. This is great practice
    and allows you to see many key concepts in action.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目还使用了之前章节中介绍的一些功能。花时间分析它并理解提供的代码。这是很好的实践，让你能够看到许多关键概念的实际应用。
- en: 'Once you have downloaded the code and run `npm install` in the project folder
    (to install all required dependencies), you can start the development server via
    `npm run dev` . As a result, upon visiting `localhost:5173` , you should see the
    following user interface:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并在项目文件夹中运行`npm install`（安装所有必需的依赖项）后，您可以通过`npm run dev`启动开发服务器。因此，访问`localhost:5173`时，您应该看到以下用户界面：
- en: '![img](img/B31339_11_06.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_11_06.png)'
- en: 'Figure 11.6: The running starting project'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：运行中的起始项目
- en: 'To complete the activity, the steps are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，步骤如下：
- en: Create a new context for the cart items.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为购物车项目创建一个新的上下文。
- en: Create a `Provider` component for the context and handle all context-related
    state changes there.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为上下文创建一个`Provider`组件，并在那里处理所有与上下文相关的状态变化。
- en: Provide the context (with the help of the `Provider` component) and make sure
    all components that need access to the context have access.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供上下文（借助`Provider`组件），并确保所有需要访问上下文的组件都能访问到。
- en: Remove the old logic (where state was lifted up).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除旧逻辑（状态提升的地方）。
- en: Use the context in all the components that need access to it.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有需要访问上下文的组件中使用上下文。
- en: The user interface should be the same as that shown in *Figure 11.6* once you
    have completed the activity. Make sure that the user interface works exactly as
    it did before you implemented React’s context features.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动后，用户界面应与*图11.6*中所示的用户界面相同。确保用户界面与实现React的上下文功能之前完全一样。
- en: '**Note**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All code files used for this activity, and the solution, can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1)
    .
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于此活动的代码文件和解决方案都可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1)找到。
- en: 'Activity 11.2: Replacing useState() with useReducer()'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.2：用useReducer()替换useState()
- en: In this activity, your task is to replace the `useState()` Hooks in the `Form`
    component with `useReducer()` . Use only one single reducer function (and thus
    only one `useReducer()` call) and merge all relevant state values into one state
    object.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是替换`Form`组件中的`useState()`钩子为`useReducer()`。只使用一个单独的reducer函数（因此只调用一次`useReducer()`），并将所有相关的状态值合并到一个状态对象中。
- en: '**Note**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-2-start`
    in this case) to use the right code snapshot.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2-start)找到这个活动的起始代码。在下载此代码时，你将始终下载整个仓库。请确保然后导航到包含起始代码的子文件夹（在这个例子中是`activities/practice-2-start`），以使用正确的代码快照。
- en: The provided project also uses many features covered in earlier chapters. Take
    your time to analyze it and understand the provided code. This is great practice
    and allows you to see many key concepts in action.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目还使用了前面章节中介绍的一些功能。花时间分析它并理解提供的代码。这是很好的练习，让你能够看到许多关键概念的实际应用。
- en: 'Once you have downloaded the code and run `npm install` in the project folder
    (to install all required dependencies), you can start the development server via
    `npm run dev` . As a result, upon visiting `localhost:5173` , you should see the
    following user interface:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码并在项目文件夹中运行`npm install`（安装所有必需的依赖项）后，你可以通过`npm run dev`启动开发服务器。结果，当你访问`localhost:5173`时，你应该看到以下用户界面：
- en: '![img](img/B31339_11_07.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_11_07.png)'
- en: 'Figure 11.7: The running starting project'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：运行中的起始项目
- en: 'In the provided starting project, users get one of three results upon clicking
    the `Submit` button:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的起始项目中，用户在点击`提交`按钮时会得到三个结果之一：
- en: If one or both input fields didn’t receive any input, an error message tells
    users to fill in the form.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个或两个输入字段没有接收任何输入，错误消息会告诉用户填写表单。
- en: If users entered values into both input fields, but at least one of the inputs
    holds an invalid value, a different error message is shown.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在两个输入字段中输入了值，但至少有一个输入包含无效值，则会显示不同的错误消息。
- en: If users entered valid values into both input fields, the entered values are
    printed in the developer tools JavaScript console.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在两个输入字段中输入了有效的值，则输入的值将在开发者工具的JavaScript控制台中打印出来。
- en: 'To complete the activity, the solution steps are as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，解决方案步骤如下：
- en: Remove (or comment out) the existing logic in the `Form` component that uses
    the `useState()` Hook for state management.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除（或注释掉）`Form`组件中使用`useState()`钩子进行状态管理的现有逻辑。
- en: Add a reducer function that handles two actions (email changed and password
    changed) and also returns a default value.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个处理两个动作（电子邮件更改和密码更改）的reducer函数，并返回一个默认值。
- en: Update the state object based on the dispatched action type (and payload, if
    needed).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据派发的动作类型（如果需要，还有负载）更新状态对象。
- en: Use the reducer function with the `useReducer()` Hook.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`useReducer()`钩子与reducer函数。
- en: Dispatch the appropriate actions (with the appropriate data) in the `Form` component.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Form`组件中派发适当的动作（带有适当的数据）。
- en: Use the state value where needed.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要的地方使用状态值。
- en: The user interface should be the same as that shown in *Figure 11.7* once you’ve
    finished the activity. Make sure that the user interface works exactly as it did
    before you implemented React’s context features.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动后，用户界面应与*图11.7*中显示的相同。确保用户界面与您实现React的上下文功能之前完全一致。
- en: '**Note**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All code files used for this activity, and the solution, can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2)
    .
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于此活动的代码文件和解决方案都可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2)找到。
