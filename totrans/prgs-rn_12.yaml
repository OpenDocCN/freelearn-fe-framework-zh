- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Automated Testing for React Native Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native应用程序的自动化测试
- en: Automating tests is one of the most important things you must do when your project
    grows. It can help ensure a certain level of quality of your application and can
    enable you to run faster release cycles without introducing bugs in every release.
    I recommend writing automated tests for your application as soon as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是当您的项目增长时必须做的最重要的事情之一。它可以帮助确保您应用程序的某个质量水平，并允许您在不引入每个版本中的错误的情况下运行更快的发布周期。我建议尽快为您的应用程序编写自动化测试。
- en: It is much easier to start writing tests right from the beginning because then,
    you are forced to structure your code in a way that works for automated testing.
    It can be hard to refactor an application to use automated testing when this wasn’t
    in focus at the beginning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就编写测试要容易得多，因为这样您被迫以适合自动化测试的方式组织代码。如果一开始没有关注这一点，那么重构应用程序以使用自动化测试可能会很困难。
- en: In this chapter, you will learn about automated testing in general and how to
    use automated testing in React Native apps. You will learn about the different
    tools and frameworks for different types of automated testing. These tools and
    frameworks are used in production by some of the most widely used apps in the
    world, so I recommend using them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解自动化测试的一般知识以及如何在React Native应用程序中使用自动化测试。您将了解不同类型的自动化测试的不同工具和框架。这些工具和框架被世界上一些最广泛使用的应用程序在生产中采用，因此我建议使用它们。
- en: 'To give you a good overview of all these topics, this chapter will cover the
    following topics. If you are already familiar with automated testing in general,
    you can skip the first section:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给您提供一个关于所有这些主题的良好概述，本章将涵盖以下主题。如果您已经熟悉自动化测试的一般知识，您可以跳过第一部分：
- en: Understanding automated testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解自动化测试
- en: Working with unit and integration tests in React Native
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React Native中使用单元和集成测试
- en: Working with component tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件测试
- en: Understanding end-to-end tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解端到端测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you must set up the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您必须设置以下内容：
- en: A working React Native environment ([bit.ly/prn-setup-rn](https://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的React Native环境（[bit.ly/prn-setup-rn](https://bit.ly/prn-setup-rn) – React
    Native CLI快速入门）。
- en: While most of this chapter should also work on Windows, I recommend working
    on a Mac. You need to work on a Mac to run Detox end-to-end tests on iOS simulators.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管本章的大部分内容也应该适用于Windows，但我建议在Mac上操作。您需要在Mac上操作才能在iOS模拟器上运行Detox端到端测试。
- en: An AWS account for accessing AWS Device Farm.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个AWS账户，用于访问AWS Device Farm。
- en: Understanding automated testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自动化测试
- en: 'There are different forms of automated testing. The following forms of automated
    testing are the most common ones and will be covered in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试有不同的形式。以下是一些最常见的自动化测试形式，并将在本章中进行介绍：
- en: '**Unit tests**: Unit tests cover the smallest parts of your business logic,
    such as single functions.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试覆盖业务逻辑的最小部分，例如单个函数。'
- en: '**Integration tests**: This form of testing works very similar to unit tests
    in React Native, but it covers multiple pieces of your business logic and tests
    whether the integration of these parts works as expected.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这种测试形式在React Native中与单元测试非常相似，但它覆盖了多个业务逻辑部分，并测试这些部分的集成是否按预期工作。'
- en: '**Component tests**: These tests cover your React Native UI components and
    check whether they do what they are expected to do. You can also check for (unexpected)
    changes in your components with this form of testing.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件测试**：这些测试覆盖您的React Native UI组件，并检查它们是否按预期执行。您还可以使用这种测试形式检查组件中的（意外）变化。'
- en: '**End-to-end tests**: This form of testing simulates end user behavior and
    checks whether your whole application behaves like it is expected to do.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：这种测试形式模拟最终用户的行为，并检查您的整个应用程序是否按预期运行。'
- en: To get the most out of automated testing, you should implement all four types
    of tests. All of them cover different areas of your application and can help you
    find different types of errors that the other types of testing can’t find.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用自动化测试，您应该实现所有四种类型的测试。所有这些测试都覆盖了应用程序的不同领域，并可以帮助您找到其他测试类型无法发现的错误。
- en: When working with automated testing, you should try to have high **code coverage**.
    Code coverage describes the percentage of your code that is covered by your automated
    tests. While it is a good metric to get an idea of whether automated tests are
    used in a project and that you didn’t forget any parts of your application, it
    has little significance on its own.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自动化测试时，你应该尽量提高 **代码覆盖率**。代码覆盖率描述了你的代码中由自动化测试覆盖的部分百分比。虽然这是一个很好的指标，可以了解自动化测试是否在项目中使用，以及你没有忘记应用程序的任何部分，但它本身意义不大。
- en: This is because it doesn’t help to write one test for every line of code you
    have. When working with automated tests, especially unit tests, integration tests,
    and component tests, you should always write multiple tests for the part you want
    to test, covering the most common use cases as well as important edge cases. This
    means you have to think a lot before writing your tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为为你的每一行代码编写一个测试并没有帮助。当使用自动化测试，尤其是单元测试、集成测试和组件测试时，你应该总是为你要测试的部分编写多个测试，覆盖最常见的用例以及重要的边缘情况。这意味着在编写测试之前，你必须深思熟虑。
- en: With unit tests, integration tests, and component tests, you typically test
    small parts of your application. This also means you have to create an environment
    where these small parts can work on their own. This can be achieved by mocking
    dependencies that are used in the tested part.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试、集成测试和组件测试时，你通常测试应用程序的小部分。这也意味着你必须创建一个环境，使这些小部分可以独立工作。这可以通过模拟在测试部分中使用的依赖项来实现。
- en: '**Mocking** means writing your own implementation of a dependency for the testing
    environment, to ensure it behaves as expected and to rule out that an error in
    the dependency leads to an error in the test.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocking** 指的是为测试环境编写依赖项的自己的实现，以确保它按预期行为，并排除依赖项中的错误导致测试错误的可能性。'
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s not always clear which parts of an application should be mocked in a test.
    I would recommend mocking more rather than less in unit tests because you want
    to test whether a very small part of your code behaves as it is expected to. In
    integration and component tests, I recommend mocking less rather than more because
    you want to test larger parts of your application and see whether the whole combination
    works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是清楚应用程序的哪些部分应该在测试中进行模拟。我建议在单元测试中模拟更多而不是更少，因为你想要测试代码的非常小部分是否按预期行为。在集成和组件测试中，我建议模拟更少而不是更多，因为你想要测试应用程序的更大部分，并查看整个组合是否工作。
- en: Because unit tests, integration tests, and component tests run in a test environment
    and use only parts of your application, they are very reliable. There aren’t many
    things that can interfere with these tests to distort the test results. This is
    different compared to working with end-to-end tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为单元测试、集成测试和组件测试在测试环境中运行，并且只使用你的应用程序的部分，所以它们非常可靠。没有多少事情可以干扰这些测试，从而扭曲测试结果。这与处理端到端测试不同。
- en: These tests run on your real application on a simulator or real device and depend
    on things such as network connectivity or other device behavior. This can lead
    to **test flakiness**. A flaky test is a test that passes and fails on different
    test runs without any code changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试在模拟器或真实设备上的真实应用程序上运行，并依赖于诸如网络连接或其他设备行为等因素。这可能导致 **测试不可靠**。不可靠的测试是指在没有任何代码更改的情况下，在不同测试运行中通过和失败测试。
- en: This is a real problem because it results in you having to manually check whether
    the test fails only because it is flaky or because it found a bug in your application.
    We’ll cover test flakiness in more detail in the *Understanding end-to-end tests*
    section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真正的问题，因为它导致你必须手动检查测试是否失败仅仅是因为它是不可靠的，还是因为它发现了你应用程序中的错误。我们将在 *理解端到端测试* 部分更详细地介绍测试不可靠性。
- en: But first, we’ll start by testing the business logic parts of our application
    automatically by using unit and integration tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将通过使用单元测试和集成测试自动测试我们应用程序的业务逻辑部分。
- en: Working with unit and integration tests in React Native
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React Native 中使用单元测试和集成测试
- en: When you start a new React Native project, it comes with a testing framework
    called **Jest** preconfigured. This is the recommended framework for unit tests,
    integration tests, and component tests. We’ll use it in the following sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始一个新的 React Native 项目时，它自带一个名为 **Jest** 的预配置测试框架。这是单元测试、集成测试和组件测试的推荐框架。我们将在以下部分中使用它。
- en: Let’s start with unit testing. We’ll use our example project again, but we will
    go back a few commits to use the local movie service implementation. You can have
    a look at the complete code by selecting the `chapter-12-unit-testing` branch
    in the example repository.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单元测试开始。我们将再次使用我们的示例项目，但我们将回滚几个提交，使用本地电影服务实现。你可以在示例仓库中选择 `chapter-12-unit-testing`
    分支来查看完整的代码。
- en: 'This local service implementation is very suitable as an example for unit testing
    because it has no dependencies. We know the data it is working on and can write
    tests very easily. In this example, we’ll test two API calls: `getMovies` and
    `getMovieById`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个本地服务实现非常适合作为单元测试的例子，因为它没有依赖项。我们知道它正在处理的数据，并且可以很容易地编写测试。在这个例子中，我们将测试两个 API
    调用：`getMovies` 和 `getMovieById`。
- en: 'The following code shows our first unit tests:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们的第一个单元测试：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code contains six tests grouped into two sections. The first section
    contains all tests regarding the `getMovies` API call. With the first test, we
    ensure that the `getMovies` call returns a value. The second test checks whether
    `getMovies` returns an array, while the last test validates that the returned
    array has the length we expect.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码包含六个测试，分为两个部分。第一部分包含所有关于 `getMovies` API 调用的测试。第一个测试确保 `getMovies` 调用返回了一个值。第二个测试检查
    `getMovies` 是否返回一个数组，而最后一个测试验证返回的数组长度是否符合我们预期的长度。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why we need three tests here when the last one fails
    as soon as one of the first two fails. This is because it gives us useful information
    so that we can see which tests fail. This makes debugging and searching for changes
    or bugs a lot easier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在这里需要三个测试，因为最后一个测试在第一个或第二个测试失败时就会失败。这是因为它为我们提供了有用的信息，使我们能够看到哪些测试失败了。这使得调试和搜索更改或错误变得容易得多。
- en: In the second section of the code example, we test the `getMoviesById` block.
    Again, we have three tests. The first one verifies that the API call returns a
    value for a movie ID we know exists. The second test checks that the correct movie
    is returned. The third test ensures that the `getMovieById` API call does not
    return anything for an ID we know doesn’t exist.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例的第二部分，我们测试了 `getMoviesById` 块。同样，我们有三个测试。第一个测试验证 API 调用返回了一个已知存在的电影 ID
    的值。第二个测试检查返回的是否是正确的电影。第三个测试确保 `getMovieById` API 调用对于我们知道不存在的 ID 不返回任何内容。
- en: 'As you can see, you shouldn’t only write one unit test when testing a function;
    you should try to cover at least the following areas:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在测试一个函数时，你不应该只写一个单元测试；你应该尝试至少覆盖以下区域：
- en: Check for existing and non-existing return values
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查现有和非现有返回值
- en: Check for expected data types
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查预期的数据类型
- en: Check whether the returned values match your expected data
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查返回的值是否与你的预期数据匹配
- en: If you work with ranges, write tests for the edge cases
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你处理范围，请为边缘情况编写测试
- en: If you experienced a bug, reproduce it with a unit test to ensure it will never
    be encountered again
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你遇到了一个错误，请使用单元测试来重现它，以确保它永远不会再次遇到
- en: 'Writing integration tests with Jest work pretty much the same as unit tests.
    The difference is that you test larger parts of your application. While the terminology
    is not always consistent, you can find a good definition in the React Native documentation
    ([https://bit.ly/prn-integration-tests](https://bit.ly/prn-integration-tests)).
    It counts as an integration test when at least one of the following four points
    is true:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jest 编写集成测试与单元测试非常相似。区别在于你测试的是应用程序的更大部分。虽然术语并不总是统一的，你可以在 React Native 文档中找到一个好的定义（[https://bit.ly/prn-integration-tests](https://bit.ly/prn-integration-tests)）。以下四个点中至少有一个为真时，它被视为集成测试：
- en: Combines several modules of your app
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合你的应用程序的几个模块
- en: Uses an external system
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部系统
- en: Makes a network call to other applications (such as the weather service API)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其他应用程序（如天气服务 API）发起网络调用
- en: Does any kind of file or database I/O
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行任何类型的文件或数据库 I/O 操作
- en: One thing that is quite important when working with integration tests is mocking.
    When running tests using Jest as your test runner, you don’t have any native parts
    of your application available; your tests run your JavaScript code in a JavaScript-only
    environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行集成测试时，有一件事非常重要，那就是模拟。当使用 Jest 作为测试运行器运行测试时，你没有任何应用程序的本地部分可用；你的测试在仅 JavaScript
    环境中运行你的 JavaScript 代码。
- en: 'This means you have to *mock* at least all native parts of your application.
    Jest comes with advanced support for mocking different parts of your code. You
    can check out the detailed documentation here: [https://bit.ly/prn-jest-mocking](https://bit.ly/prn-jest-mocking).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您至少需要模拟应用程序的所有原生部分。Jest提供了对模拟代码不同部分的高级支持。您可以在此处查看详细文档：[https://bit.ly/prn-jest-mocking](https://bit.ly/prn-jest-mocking)。
- en: While unit and integration testing work pretty much similar to tests on server
    applications or applications written in other languages, component tests are a
    frontend-only test type. This is what we’ll look at next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和集成测试的工作方式与服务器应用程序或用其他语言编写的应用程序的测试非常相似，但组件测试是一种仅针对前端测试的类型。这就是我们接下来要探讨的。
- en: Working with component tests
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与组件测试一起工作
- en: When working with component tests in React Native, the recommended solution
    is to use `react-native-testing-library`. This library is compatible with Jest,
    adds a rendering environment for your JavaScript application, and provides multiple
    useful selectors and other functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当在React Native中使用组件测试时，推荐的解决方案是使用`react-native-testing-library`。这个库与Jest兼容，为您的JavaScript应用程序添加了一个渲染环境，并提供多个有用的选择器和其它功能。
- en: The easiest type of component test is to check for (unexpected) changes. This
    is called **snapshot testing**. The component will be rendered and transformed
    into an XML or JSON representation, called a snapshot. This snapshot is stored
    with the tests. The next time the test runs, it is used to check for changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的组件测试类型是检查（意外的）变化。这被称为**快照测试**。组件将被渲染并转换为XML或JSON表示，称为快照。这个快照与测试一起存储。下次测试运行时，它将用于检查变化。
- en: 'The following code example shows a snapshot test for the `HomeView` component
    of our example application:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了我们示例应用程序中`HomeView`组件的快照测试：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code example shows how important it is to take testing into account when
    structuring your code. We can simply import the `HomeView` component from `Home.view`
    and pass properties to it when rendering it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例展示了在结构化代码时考虑测试的重要性。我们可以简单地从`Home.view`导入`HomeView`组件，并在渲染时传递属性。
- en: We don’t have to mock any stores or external dependencies. This makes it very
    easy to create the first snapshot test. We use the `render` function from `react-native-testing-library`
    to create a snapshot representation of the component. Then, we expect it to match
    our stored snapshot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要模拟任何存储或外部依赖。这使得创建第一个快照测试变得非常容易。我们使用`react-native-testing-library`中的`render`函数来创建组件的快照表示。然后，我们期望它与我们的存储快照相匹配。
- en: While snapshot testing can be very useful to realize unexpected changes, it
    only gives us information if anything has changed. To get more information about
    what changed and check whether everything works as expected, we have to create
    more advanced component tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然快照测试可以非常有用，以发现意外的变化，但它只在我们有变化时提供信息。为了获取更多关于变化的信息并检查一切是否按预期工作，我们必须创建更高级的组件测试。
- en: 'The following code example shows how we can check whether the component renders
    valid content:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了我们如何检查组件是否渲染了有效的内容：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this test, we pass all three genres we have in our `genres.json` file to
    the `HomeView` component. Again, we render it using the `render` function from
    `react-native-testing-library`. After rendering, we use another function from
    the testing library called `screen`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将我们的`genres.json`文件中的所有三个流派传递给`HomeView`组件。再次，我们使用`react-native-testing-library`中的`render`函数来渲染它。渲染后，我们使用测试库中的另一个函数`screen`。
- en: With this function, we can query values that are rendered to the simulated screen.
    This is how we try to find the titles of our three genres, which we expect to
    be there by checking for them with `toBeTruthy`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以查询渲染到模拟屏幕上的值。这就是我们尝试找到我们期望存在的三个流派标题的方式，我们通过使用`toBeTruthy`来检查它们。
- en: 'Next, we’ll go one step further and check whether we can click on the list
    items:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更进一步，检查我们是否可以点击列表项：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this test, we use the `fireEvent` function from `react-native-testing-library`
    to create a press event on every list item. To be able to check whether the press
    event triggers our `onGenrePress` function, we pass a Jest mock function, created
    with `jest.fn()`, to the component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用`react-native-testing-library`中的`fireEvent`函数在每一个列表项上创建一个点击事件。为了检查点击事件是否触发了我们的`onGenrePress`函数，我们向组件传递了一个使用`jest.fn()`创建的Jest模拟函数。
- en: This mock function collects a lot of information during the test, including
    how often it was called during the test. This is what we check for in this test.
    However, we can go one step further.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟函数在测试期间收集了大量信息，包括它在测试期间被调用的频率。这是我们在这个测试中要检查的内容。然而，我们可以更进一步。
- en: 'Not only can we check whether the mock function was called, but also whether
    it was called with the correct parameters:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅能够检查模拟函数是否被调用，还能检查它是否以正确的参数被调用：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example fires only on a press event but then checks whether the arguments
    that were passed to the function are correct. Since the `Action` genre is the
    first in the `genres` array, we expect the `onGenrePress` function to be called
    with it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只在按下事件发生时触发，然后检查传递给函数的参数是否正确。由于`Action`类型是`genres`数组中的第一个，我们期望`onGenrePress`函数与它一起被调用。
- en: Again, these types of tests are only that easy because we have a good code structure.
    If we hadn’t split our home page into a business logic and view, we would have
    to deal with our navigation library, as well as our global state management solution.
    While this is possible for most cases, it makes your component tests a lot more
    complex.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些类型的测试之所以如此简单，仅仅是因为我们有一个良好的代码结构。如果我们没有将主页拆分为业务逻辑和视图，我们就必须处理我们的导航库，以及我们的全局状态管理解决方案。虽然这在大多数情况下是可行的，但它使得你的组件测试变得更加复杂。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s a good idea to integrate unit tests, integration tests, and component tests
    into your CI development process. You should at least run these tests when opening
    pull requests. If your setup allows, you could also run them on every commit for
    a faster feedback loop.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将单元测试、集成测试和组件测试集成到你的持续集成（CI）开发流程中是个好主意。你至少应该在打开拉取请求时运行这些测试。如果你的设置允许，你还可以在每次提交时运行它们，以实现更快的反馈循环。
- en: I also recommend requiring a certain level of code coverage for the pipelines
    to pass, to ensure all developers write tests for their code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议要求达到一定程度的代码覆盖率，以确保所有开发者都为他们的代码编写测试。
- en: All the test types you have learned about so far only use and test parts of
    your application in a simulated environment. However, that changes when it comes
    to end-to-end tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止所了解的所有测试类型都只在你模拟的环境中测试和使用了应用程序的某些部分。然而，当涉及到端到端测试时，情况就改变了。
- en: Understanding end-to-end tests
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解端到端测试
- en: 'The idea of end-to-end tests is very simple: these tests try to simulate real-world
    user behavior and verify that the application behaves as expected. Normally, end-to-end
    tests work as black-box tests.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的想法非常简单：这些测试试图模拟现实世界的用户行为，并验证应用程序是否按预期运行。通常，端到端测试作为黑盒测试运行。
- en: This means that the testing framework does not know the inner functionality
    of the application that is being tested. It runs against the release build of
    the application, which will be shipped.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着测试框架并不知道正在被测试的应用程序的内部功能。它运行在应用程序的发布构建版本上，这个版本将被发布。
- en: Understanding the role of end-to-end testing
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端到端测试的作用
- en: At first sight, end-to-end tests seem to be a silver bullet for automated testing.
    Shouldn’t it be enough to simply test all scenarios of our application with end-to-end
    tests? Do we even need other test types, such as unit tests, integration tests,
    or component tests?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，端到端测试似乎是对自动化测试的万能药。难道仅仅通过端到端测试测试我们应用程序的所有场景就足够了吗？我们甚至还需要其他类型的测试，比如单元测试、集成测试或组件测试吗？
- en: The answers to these questions are very simple. End-to-end tests are powerful,
    but they also have some traits that make them only cover certain scenarios very
    well. First, end-to-end tests run for a long time, so testing all the functionality
    of a more complex application with end-to-end tests can take up to multiple hours.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案非常简单。端到端测试功能强大，但它们也有一些特性，使得它们只能很好地覆盖某些场景。首先，端到端测试运行时间较长，因此使用端到端测试测试更复杂应用程序的所有功能可能需要多达数小时。
- en: This means they can’t be run on every commit, which makes the feedback loop
    much longer. So, this scenario can’t be integrated into the CI development process,
    such as the one described in [*Chapter 11*](B16694_11.xhtml#_idTextAnchor376),
    *Creating and Automating Workflows*. Second, end-to-end tests are flaky by nature.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们不能在每次提交时运行，这使得反馈循环变得很长。因此，这种场景不能集成到CI开发流程中，例如在[*第11章*](B16694_11.xhtml#_idTextAnchor376)中描述的*创建和自动化工作流程*。其次，端到端测试本身具有不稳定性。
- en: This means that these tests can pass and fail on different test runs without
    any code changes. One reason for this is that applications can behave differently
    internally, on different test runs. For example, multiple network requests can
    be resolved in different orders on different test runs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这些测试可以在没有代码更改的情况下在不同测试运行中通过或失败。一个原因是应用程序可以在不同的测试运行中表现出不同的内部行为。例如，多个网络请求可以在不同的测试运行中以不同的顺序解决。
- en: This is no problem for end users, but it can be for automated end-to-end tests,
    where you try to run interactions as fast as possible. Another reason for test
    flakiness is the real-world conditions the tests are running in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这对最终用户来说没有问题，但对于尝试尽可能快地运行交互的自动化端到端测试来说，可能会出现问题。测试不稳定性的另一个原因是测试运行的实际情况。
- en: When the testing device has issues with network connectivity while the test
    runs, the test will fail, even if it should pass. Modern test frameworks try to
    reduce these problems as much as possible, but they haven’t been solved completely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试设备在测试运行期间遇到网络连接问题时，测试将失败，即使它应该通过。现代测试框架试图尽可能减少这些问题，但它们还没有完全解决。
- en: I recommend using end-to-end tests for the most used paths in your application.
    This can include account creation and login, as well as the core functionality
    of your product.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您为应用程序中最常用的路径使用端到端测试。这可以包括账户创建和登录，以及您产品的核心功能。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As a developer, you should always ensure there’s a balance between ensuring
    the quality of the product and keeping development speed. Too many end-to-end
    tests can increase the quality but significantly decrease the speed of your development
    or release process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，您应该始终确保在确保产品质量和保持开发速度之间保持平衡。过多的端到端测试可以提高质量，但会显著降低您的开发或发布流程的速度。
- en: Now that we’ve looked at end-to-end tests in general, let’s start writing our
    first tests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了端到端测试的一般情况，让我们开始编写我们的第一个测试。
- en: Writing end-to-end tests with Detox
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Detox 编写端到端测试
- en: Detox is an end-to-end testing framework that was initially developed for React
    Native applications. It isn’t a real black-box testing framework because it injects
    its own client into the application, which gets tested. This is done to reduce
    test flakiness, which works quite well but also can’t prevent flaky tests completely.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Detox 是一个最初为 React Native 应用程序开发的端到端测试框架。它不是一个真正的黑盒测试框架，因为它将自身的客户端注入到被测试的应用程序中。这样做是为了减少测试的不稳定性，这效果相当好，但也不能完全防止测试的不稳定性。
- en: This also means that you don’t ship the same binary that was tested. Normally,
    this should be no problem because you would simply build another binary with the
    same code and configuration except you would bundle it with the Detox client into
    your binary, but I wanted to mention it here anyway.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着您不会发送与测试相同的二进制文件。通常，这应该不会成问题，因为您只需使用相同的代码和配置构建另一个二进制文件，只是您会将 Detox 客户端捆绑到您的二进制文件中，但我想在这里提一下。
- en: 'The normal Detox testing process is shown in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的 Detox 测试流程如图所示：
- en: '![Figure 12.1 – Detox testing process'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – Detox 测试流程'
- en: '](img/B16694_12_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_12_01.jpg)'
- en: Figure 12.1 – Detox testing process
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – Detox 测试流程
- en: As you can see, you have to create a production bundle of your application before
    running your tests. Depending on the machine you create your builds on, as well
    as the size of your application, this can take some time. Next, you run your tests.
    After doing so, the testing environment will be torn down so that you can work
    with the test results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在运行测试之前，您必须创建应用程序的生产版本。根据您创建构建的机器以及应用程序的大小，这可能需要一些时间。接下来，您运行测试。完成之后，测试环境将被拆解，以便您可以处理测试结果。
- en: While this process works fine for running tests, it can be quite annoying while
    writing tests. Detox works best when using test IDs to identify elements you want
    to interact with. This means you have to touch your code and add test IDs to these
    elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过程在运行测试时效果很好，但在编写测试时可能会相当烦人。Detox 在使用测试 ID 来识别您想要与之交互的元素时效果最佳。这意味着您需要触摸您的代码，并给这些元素添加测试
    ID。
- en: 'This also means you have to create a new build every time you have to change
    anything regarding the test IDs in your code. Fortunately, there is another process
    you can use while writing your tests. You can also use Detox on development builds,
    which leads to the following process:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着每次你需要更改代码中关于测试 ID 的任何内容时，你都必须创建一个新的构建。幸运的是，在编写测试时，你可以使用另一个过程。你还可以在开发构建中使用
    Detox，这导致以下过程：
- en: '![Figure 12.2 – Detox process for writing tests'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 编写测试的 Detox 流程'
- en: '](img/B16694_12_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16694_12_02.jpg)'
- en: Figure 12.2 – Detox process for writing tests
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 编写测试的 Detox 流程
- en: When working with development builds, you only have to create your native development
    build once. As you already know, the JavaScript bundle will be fetched from the
    Metro server running on your computer during development.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当与开发构建一起工作时，你只需要创建一次本地的开发构建。正如你所知，JavaScript 包将在开发过程中从运行在你电脑上的 Metro 服务器获取。
- en: This means you can run your tests. If you realize you have to make changes to
    your test IDs, you can simply apply them and restart your tests. Then, the development
    build will fetch the new JavaScript bundle from the Metro server and run the tests.
    This can save a lot of time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以运行你的测试。如果你意识到你需要更改测试 ID，你可以简单地应用它们并重新启动测试。然后，开发构建将从 Metro 服务器获取新的 JavaScript
    包并运行测试。这可以节省很多时间。
- en: 'Now that you know Detox in general, let’s start working with it. This book
    does not include a detailed step-by-step guide for installing it since the installation
    steps changed quite frequently in the past. So, please look at the official installation
    guide in the Detox documentation here: [https://bit.ly/prn-detox-start](https://bit.ly/prn-detox-start).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了 Detox 的基本知识，让我们开始使用它。这本书没有包括安装它的详细步骤指南，因为过去的安装步骤变化相当频繁。所以，请查看 Detox
    文档中的官方安装指南：[https://bit.ly/prn-detox-start](https://bit.ly/prn-detox-start)。
- en: If you have trouble getting your Detox tests to work, you can have a look at
    the example project on GitHub at `chapter-12-detox-testing`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使你的 Detox 测试工作时有困难，你可以查看 GitHub 上的示例项目，项目地址为 `chapter-12-detox-testing`。
- en: Writing Detox tests is very similar to writing component tests because Detox
    uses Jest as its recommended test runner. However, with Detox, we run the test
    against the real application in a real-world scenario. This means we don’t have
    to work with mocking because everything we need is available. Before we start
    writing our test, we have to add test IDs to the components we want to interact
    with.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Detox 测试与编写组件测试非常相似，因为 Detox 使用 Jest 作为其推荐的测试运行器。然而，与 Detox 一起，我们在真实世界的场景中运行测试，针对真实的应用。这意味着我们不需要进行模拟，因为我们需要的所有东西都是可用的。在我们开始编写测试之前，我们必须向我们要与之交互的组件添加测试
    ID。
- en: 'The following example shows a snippet from `Home.view.tsx`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `Home.view.tsx` 的一个片段：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, you can see the `Pressable` component, which is used to display the genres.
    We added a `testID` property to this component, which makes it identifiable in
    our tests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到用于显示类别的 `Pressable` 组件。我们向这个组件添加了一个 `testID` 属性，这使得它在我们的测试中可以被识别。
- en: 'The following code example shows a simple Detox test for our application. You
    can also find it in the example project repository under `e2e/movie.e2e.js`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了我们应用的简单 Detox 测试。你还可以在示例项目仓库中的 `e2e/movie.e2e.js` 找到它：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we tell Detox to launch our app. Next, we wait for the genre with the
    `testAction` ID to be visible. Next, we tap the `Pressable` component. The same
    is done with the movies, except we don’t use the movie names as IDs but the list
    index. Finally, we verify that the overview text of the movie is shown.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉 Detox 启动我们的应用。然后，我们等待具有 `testAction` ID 的类别可见。接下来，我们点击 `Pressable` 组件。对于电影，我们做的是相同的，但我们不使用电影名称作为
    ID，而是使用列表索引。最后，我们验证电影概述文本是否显示。
- en: This example shows the advantages and disadvantages of end-to-end testing very
    well. On the one hand, we only needed a couple of lines of code to navigate to
    three different screens and verify the content. This means we can be quite confident
    that the application will not crash on these screens. On the other hand, it takes
    a lot of time to build the application, load it into a simulator, start it, and
    run the test.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好地展示了端到端测试的优点和缺点。一方面，我们只需要几行代码就能导航到三个不同的屏幕并验证内容。这意味着我们可以相当自信地认为应用在这些屏幕上不会崩溃。另一方面，构建应用、将其加载到模拟器中、启动它并运行测试需要花费很多时间。
- en: While Detox can run on real devices, it’s mostly used with simulators. These
    simulators can run in CI environments and therefore be integrated into an automated
    workflow easily.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Detox 可以在真实设备上运行，但它主要与模拟器一起使用。这些模拟器可以在CI环境中运行，因此可以轻松集成到自动化工作流程中。
- en: But you can even go one step further with end-to-end test integration in your
    automated workflow. While it is useful to run these tests on simulators, it’s
    even better to run them on real devices. Especially on Android, where you have
    thousands of different devices, you should at least test the most common ones.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但你甚至可以将你的自动化工作流程中的端到端测试集成更进一步。虽然在这些模拟器上运行这些测试是有用的，但将它们运行在实际设备上会更好。特别是在Android上，你拥有数千种不同的设备，你应该至少测试最常见的那些。
- en: It’s not unlikely that some errors will only occur on specific devices or OS
    versions. Since you don’t want to buy hundreds of devices for testing, you can
    use device farms such as AWS Device Farm. Unfortunately, Detox does not work in
    these environments, so you have to use Appium as the testing framework. This is
    what we’ll look at next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些特定设备或操作系统版本上出现一些错误并不罕见。由于你不想购买数百台设备进行测试，你可以使用AWS Device Farm等设备农场。不幸的是，Detox
    在这些环境中无法工作，所以你必须使用Appium作为测试框架。这就是我们将要探讨的内容。
- en: Understanding Appium and AWS Device Farm
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Appium和AWS Device Farm
- en: Unlike Detox, Appium is a real black-box testing framework. It works on your
    release binary and therefore tests the code you want to ship. It wasn’t primarily
    designed for React Native, but for native Android and iOS testing. Nevertheless,
    you can use it for React Native apps very well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与Detox不同，Appium是一个真正的黑盒测试框架。它作用于你的发布二进制文件，因此测试了你想要发布的代码。它最初并不是为React Native设计的，而是为原生Android和iOS测试设计的。尽管如此，你仍然可以很好地使用它来测试React
    Native应用程序。
- en: Appium is a very mature framework. At the time of writing, version 2 of Appium
    is still in progress and not ready to use, so the examples here refer to version
    1 of Appium.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Appium 是一个非常成熟的框架。在撰写本文时，Appium 的第2版仍在开发中，尚未准备好使用，因此这里提供的示例是关于Appium的第1版。
- en: 'The framework consists of multiple parts, which you have to understand when
    working with Appium. The following diagram shows these different parts:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架由多个部分组成，当你与Appium一起工作时，你必须理解这些不同的部分。以下图表显示了这些不同的部分：
- en: '![Figure 12.3 – Appium framework components'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – Appium框架组件'
- en: '](img/B16694_12_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_12_03.jpg)'
- en: Figure 12.3 – Appium framework components
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – Appium框架组件
- en: The core of Appium is a Node.js server, which takes test orders from an Appium
    client. This client is where you will write your tests. It can be written in different
    languages such as JavaScript, Java, C#, or Python.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Appium 的核心是一个Node.js服务器，它从Appium客户端接收测试命令。这个客户端就是你将编写测试的地方。它可以编写为不同的语言，如JavaScript、Java、C#或Python。
- en: Since you don’t want to introduce another language only for writing tests, I
    recommend going with the JavaScript implementation here. The server then uses
    an Appium driver to talk to the native testing frameworks, which are used to run
    the test on real Android and iOS devices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你不想仅为了编写测试而引入另一种语言，我建议在这里使用JavaScript实现。然后服务器使用Appium驱动程序与原生测试框架通信，这些框架用于在真实的Android和iOS设备上运行测试。
- en: Appium also provides a desktop application, which has a very useful inspector
    mode. You can use this mode to find identifiers to write your tests when you don’t
    work with test IDs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Appium 还提供了一个桌面应用程序，它有一个非常有用的检查器模式。当你不使用测试ID时，你可以使用此模式来查找标识符以编写你的测试。
- en: 'Since the Appium installation process will change significantly with Appium
    version 2, this book does not contain a detailed step-by-step guide for the installation.
    You can find these instructions in the official Appium documentation here: [https://bit.ly/prn-appium-installation](https://bit.ly/prn-appium-installation).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Appium的安装过程将随着Appium版本2的发布而显著变化，这本书没有包含安装的详细步骤指南。你可以在官方Appium文档中找到这些说明：[https://bit.ly/prn-appium-installation](https://bit.ly/prn-appium-installation)。
- en: In my opinion, using Appium with React Native is only interesting when it’s
    combined with a device farm to run your tests on multiple real devices. Otherwise,
    I would recommend sticking to Detox because it’s easier to install, configure,
    and maintain. But unfortunately, Detox has no support for running on device farms.
    So, again, you have to use Appium there.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，当与设备农场结合使用以在多个真实设备上运行测试时，使用Appium与React Native结合才真正有趣。否则，我建议坚持使用Detox，因为它更容易安装、配置和维护。但遗憾的是，Detox
    不支持在设备农场上运行。所以，再次，你不得不在那里使用Appium。
- en: One of these device farms is AWS Device Farm. It is an Amazon service that gives
    you access to hundreds of different real mobile device models. You can either
    upload and install your application and use the devices manually via your web
    browser or you can run automated tests on these devices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个设备农场是AWS设备农场。这是一个Amazon服务，它为您提供了访问数百种不同真实移动设备模型的机会。您可以通过网络浏览器手动上传和安装您的应用程序，或者在这些设备上运行自动化测试。
- en: 'This automated testing is exactly what we’ll do. The following diagram shows
    how the process of running Appium tests on AWS Device Farm integrates with your
    automated workflow:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化测试正是我们将要做的。以下图表显示了在AWS设备农场上运行Appium测试的过程如何与您的自动化工作流程集成：
- en: '![Figure 12.4 – Running automated tests on AWS Device Farm'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – 在AWS设备农场上运行自动化测试'
- en: '](img/B16694_12_04.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_12_04.jpg)'
- en: Figure 12.4 – Running automated tests on AWS Device Farm
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 在AWS设备农场上运行自动化测试
- en: AWS Device Farm can be accessed programmatically from your workflow automation
    or CI tool (such as Bitrise) or manually via your web browser. In both scenarios,
    you have to upload an Android APK or iOS IPA file, which should be tested, and
    a test bundle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过工作流程自动化或CI工具（如Bitrise）以编程方式访问AWS设备农场，或者通过您的网络浏览器手动访问。在两种情况下，您都必须上传一个待测试的Android
    APK或iOS IPA文件和一个测试包。
- en: This bundle is a `.zip` file, which contains the tests as well as some configurations
    for AWS Device Farm. You can also choose which **device pool** should be used
    for testing. A device pool is a collection of devices that you can create in the
    AWS Device Farm console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此包是一个`.zip`文件，其中包含测试以及一些AWS设备农场的配置。您还可以选择用于测试的**设备池**。设备池是在AWS设备农场控制台中可以创建的设备集合。
- en: AWS then runs your tests on every device that is part of your device pool and
    collects the test results. These results are displayed in the AWS Device Farm
    console and can also be passed back to your workflow automation or CI tool.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: AWS将在您的设备池中的每个设备上运行您的测试，并收集测试结果。这些结果将在AWS设备农场控制台中显示，也可以传递回您的工作流程自动化或CI工具。
- en: 'The following screenshot shows the overview of a test run in AWS Device Farm:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了AWS设备农场中测试运行的概览：
- en: '![Figure 12.5 – AWS Device Farm result screen'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – AWS设备农场结果屏幕'
- en: '](img/B16694_12_05_New.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_12_05_New.jpg)'
- en: Figure 12.5 – AWS Device Farm result screen
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – AWS设备农场结果屏幕
- en: This overview shows a test run that executed three tests on every device of
    the chosen device pool. All tests passed except two. This means there is either
    an error that makes two tests fail on one device type, or that two of the tests
    are flaky.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此概览显示了一个测试运行，在每个选择的设备池的每个设备上执行了三个测试。所有测试都通过了，除了两个。这意味着可能存在一个错误，导致两种测试在一个设备类型上失败，或者有两个测试是易变的。
- en: This is something you would have to investigate. Fortunately, AWS Device Farm
    provides logs, screenshots, and video recordings of every test run so that you
    can find out what is happening with ease.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要您进行调查。幸运的是，AWS设备农场提供了每个测试运行的日志、截图和视频记录，以便您可以轻松地找出发生了什么。
- en: 'Since the installation and configuration process for using Appium locally and
    on AWS Device Farm isn’t trivial, I created a demo repository that you can start
    from. It also contains a detailed setup and installation guide, as well as useful
    scripts for running Appium tests locally and creating bundles for running them
    on AWS Device Farm. You can find it here: [https://bit.ly/prn-appium-aws-repo](https://bit.ly/prn-appium-aws-repo).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本地和AWS设备农场使用Appium的安装和配置过程并不简单，我创建了一个演示仓库，您可以从这里开始。它还包含详细的设置和安装指南，以及用于在本地运行Appium测试和为AWS设备农场创建测试包的有用脚本。您可以在以下链接找到它：[https://bit.ly/prn-appium-aws-repo](https://bit.ly/prn-appium-aws-repo)。
- en: Now, let’s summarize this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结本章内容。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: First, you learned why automated testing is important and which types of tests
    exist for React Native apps. Then, you learned how to write unit and integration
    tests, as well as component tests, with Jest and `react-native-testing`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您学习了为什么自动化测试很重要，以及React Native应用程序存在哪些类型的测试。然后，您学习了如何使用Jest和`react-native-testing`编写单元测试、集成测试以及组件测试。
- en: 'Finally, you learned about end-to-end testing while covering two different
    frameworks: Detox and Appium. After completing this chapter, you should understand
    that automated testing is an essential part of large-scale projects and that every
    test type is important because it covers different areas.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你在涵盖两个不同框架：Detox 和 Appium 的过程中学习了端到端测试。完成这一章后，你应该明白自动化测试是大规模项目的一个关键部分，并且每种测试类型都很重要，因为它覆盖了不同的领域。
- en: Now that you have learned about the basics of writing large-scale applications
    with React Native, in the last chapter of this book, I will provide some tips
    from my experience as well as an outlook for the next few years regarding React
    Native.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了使用 React Native 编写大规模应用程序的基础知识，在这本书的最后一章，我将分享我的经验之谈，并对未来几年 React Native
    的发展趋势进行展望。
