<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Our First View via Component Building</h1>
                
            
            <article>
                
<p class="mce-root">We've been working hard at framing the base of our app in <a href="part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 2</a>, <em class="calibre21">Feature Modules,</em> and now it's time to finally get a glimpse of what we're working with. This is all about getting that first view from our sketch to the mobile device screen.</p>
<p class="mce-root">Building views with NativeScript for Angular is not much different than view building for the web. We will use Angular's Component decorator to build various components our UI needs to achieve the desired usability we're after. Instead of using the HTML markup, we will be using NativeScript XML, which is an extremely powerful, yet simple and concise, abstraction of all native view components on both iOS and Android.</p>
<p class="mce-root">We won't be covering all the benefits and types of components you have access to here; but to learn more, we recommend any of the following books: </p>
<ul class="calibre13">
<li class="calibre14"><a href="https://www.packtpub.com/web-development/getting-started-nativescript" class="calibre3">https://www.packtpub.com/web-development/getting-started-nativescript</a></li>
<li class="calibre14"><a href="https://www.manning.com/books/nativescript-in-action" class="calibre3">https://www.manning.com/books/nativescript-in-action</a></li>
</ul>
<p class="mce-root">In this chapter, we will be covering the following topics:</p>
<ul class="calibre13">
<li class="calibre14">Using Component decorator to compose our views</li>
<li class="calibre14">Creating reusable components</li>
<li class="calibre14">Creating a custom view filter using Pipe</li>
<li class="calibre14">Running the app on the iOS and Android simulators</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Our first view via component building</h1>
                
            
            <article>
                
<p class="mce-root">If we look at our sketch from <a href="part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 1</a>, <em class="calibre21">Get into Shape with @NgModule</em>, we can see a header at the top of the app, which will contain our app title with the record button to the right. We also see a listing of tracks with some player controls at the bottom. We can break these key elements of our UI design into essentially three primary components. One component is already provided by the NativeScript framework, the ActionBar, which we will use to represent the top header. </p>
<p class="mce-root">NativeScript provides many rich view components to build our UI. The markup is not HTML but rather XML with an <kbd class="calibre11">.html</kbd> extension, which may seem unusual. The reason the <kbd class="calibre11">.html</kbd> extension is used for XML view templates with NativeScript for Angular is that the custom renderer (<a href="https://github.com/NativeScript/nativescript-angular" class="calibre3">https://github.com/NativeScript/nativescript-angular</a>) uses a DOM adapter to parse the view template. Each NativeScript XML component represents true native view widgets on each respective platform.</p>
<p class="mce-root">For the other two primary components, we will use Angular's Component decorator. It's important at this phase of the app development cycle to think about encapsulated pieces of UI functionality. We will encapsulate our track listing as a component and the player controls as another component. In this exercise, we will use an outside-in approach to building our UI from an abstract viewpoint down to the implementation details of each component. </p>
<p class="mce-root">To begin, let's focus on the root component in our Angular app because it will define the basic layout of our first view. Open <kbd class="calibre11">app/app.component.html</kbd>, clear its contents, and replace with the following to rough out the initial UI concept from our sketch:</p>
<pre class="calibre22">&lt;ActionBar title="TNSStudio"&gt;<br class="title-page-name"/>&lt;/ActionBar&gt;<br class="title-page-name"/>&lt;GridLayout rows="*, 100" columns="*"&gt;<br class="title-page-name"/>  &lt;track-list row="0" col="0"&gt;&lt;/track-list&gt;<br class="title-page-name"/>  &lt;player-controls row="1" col="0"&gt;&lt;/player-controls&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">We are expressing our view with <kbd class="calibre11">ActionBar</kbd> and the primary layout container for the main view, <kbd class="calibre11">GridLayout</kbd>. With NativeScript, it's important that each view starts with a layout container as the root node (outside of any <kbd class="calibre11">ActionBar</kbd> or <kbd class="calibre11">ScrollView</kbd>), much like <kbd class="calibre11">div</kbd> tags that are used with HTML markup. At the time of this writing, there are six layout containers provided by NativeScript: <kbd class="calibre11">StackLayout</kbd>, <kbd class="calibre11">GridLayout</kbd>, <kbd class="calibre11">FlexboxLayout</kbd>, <kbd class="calibre11">AbsoluteLayout</kbd>, <kbd class="calibre11">DockLayout</kbd>, and <kbd class="calibre11">WrapLayout</kbd>. For our layout here, <kbd class="calibre11">GridLayout</kbd> will work well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">All about the GridLayout</h1>
                
            
            <article>
                
<p class="mce-root">The GridLayout is one of the three most used layouts you will use in your NativeScript application (the others are FlexboxLayout and StackLayout). This is the layout that allows you to build complex layouts easily.  To use the GridLayout is very much like the enhanced table in HTML.  You are basically going to want to take your screen area and divide your screen into the pieces you need. It will allow you to tell the columns (or rows) to be a percentage of the remaining width (and height) of the screen. The grid supports three types of values; <strong class="calibre1">absolute size</strong>, a percentage of <strong class="calibre1">remaining space</strong>, and <strong class="calibre1">used space</strong>. </p>
<p class="mce-root">For <strong class="calibre1">absolute size</strong>, you just type in the number. For example, <kbd class="calibre11">100</kbd> means it will use 100 dp of space. </p>
<div class="packt_infobox">Another name for <strong class="calibre27">dp</strong> is <strong class="calibre27">dip</strong>. They are the same. A device-independent pixel (also density-independent pixel, DIP, or DP) is a physical unit of measurement based on a coordinate system held by a computer and represents an abstraction of a pixel for use by an application that an underlying system then converts to physical pixels.</div>
<p class="mce-root">If you take the smallest iOS device supported, it has a screen width of 320dp. For other devices, such as tablets, some have a width of 1024 dp. So, 100 dp would be almost one third of an iOS phone, where it is one tenth of the screen on a tablet. So, this is something you need to think about when using fixed absolute values. It is typically better to use the used space over a fixed value, unless you are needing to constrain the column to a specific size.</p>
<p class="mce-root">To use <strong class="calibre1">remaining space-</strong>based values , that is, <kbd class="calibre11"><em class="calibre21">*</em></kbd>, the <kbd class="calibre11"><em class="calibre21">*</em></kbd> tells it to use the rest of the remaining space. If the columns (or rows) is set to <em class="calibre21"><kbd class="calibre11">*</kbd>, <kbd class="calibre11">*</kbd></em>, then space will be divided into two equal remainders of space. Likewise, <kbd class="calibre11">rows="*,*,*,*,*"</kbd> will specify five equal sized rows. You can also specify things, such as <kbd class="calibre11">columns="2*,3*,*",</kbd> and you will get three columns; the first column will be two sixth of the screen, the second column will be three sixth of the screen, and the final column will be one sixth of the screen (that is, 2+3+1 = 6).  This allows you great flexibility in how to use the remainder of the space.</p>
<p class="mce-root">The third type of sizing is <strong class="calibre1">space used</strong>. So what happens is the content inside the grid is measured and then the column is assigned the size that is the max used in that column (or row). This is very useful when you have a grid where you have data but you aren't sure of the size or you don't really care; you just want it to look good. So, this is the auto keyword. I might have <kbd class="calibre11">columns="auto,auto,*,auto"</kbd>. This means columns 1,2, and 4 will all be automatically sized based on the content inside those columns; and column 3 will use whatever space is left over. This is very useful for laying out the entire screen or parts of the screen where you are looking for a certain look.</p>
<p class="mce-root">The final reason why the GridLayout is one of the best layouts is that when you assign items to the GridLayout, you can actually assign multiple items to the same rows and/or columns and you can use row or column spans to allow items to use more than one row and/or column.</p>
<p class="mce-root">To assign an object, you just assign it via <kbd class="calibre11">row="0"</kbd> and/or <kbd class="calibre11">col="0"</kbd> (keep in mind these are index-based positions). You can also use <kbd class="calibre11">rowSpan</kbd> and <kbd class="calibre11">colSpan</kbd> to make an element span multiple rows and/or columns. Overall, the GridLayout is the most versatile layout and allows you to easily create almost any layout you will need in your app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back to our layout</h1>
                
            
            <article>
                
<p class="mce-root">Inside the grid, we have declared a <kbd class="calibre11">track-list</kbd> component to represent our track listing, which will flex vertically, taking up all the vertical space and leaving only a height of 100 for <kbd class="calibre11">player-controls</kbd>. We indicate <kbd class="calibre11">track-list</kbd> as <kbd class="calibre11">row="0" col="0"</kbd>, since rows and columns are index-based. The flexible (remainder) vertical height is defined via the GridLayout's <kbd class="calibre11">*</kbd> in the rows attribute. The bottom section of the grid (row 1) will represent the player controls, allowing users to play/pause the mix and shuttle the playback position.</p>
<p class="mce-root">Now that we have the app's primary view defined in a rather abstract way, let's dive into the two custom components we need to build, <kbd class="calibre11">track-list</kbd> and <kbd class="calibre11">player-controls</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building TrackList component</h1>
                
            
            <article>
                
<p class="mce-root">The track list should be a listing of all the recorded tracks. Each row in the list should provide a single record button to re-record in addition to a name label for displaying the title provided by the user. It should also provide a switch to allow the user to solo just that particular track.</p>
<p class="mce-root">We can inject <kbd class="calibre11">PlayerService</kbd> and declare it <kbd class="calibre11">public</kbd> to allow us to bind directly to the service's tracks collection.</p>
<p class="mce-root">We can also mock out some of our bindings to get things rolling like the <kbd class="calibre11">record</kbd> action. For now, let's just allow a track to be passed in and let's print out an inspection of that track via <kbd class="calibre11">LogService</kbd>.</p>
<p class="mce-root">Let's start by creating <kbd class="calibre11">app/modules/player/components/track-list/ track-list.component.ts</kbd><strong class="calibre1"> </strong>(with a matching <kbd class="calibre11">.html</kbd> template):</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack } from '../../../core/models';<br class="title-page-name"/>import { LogService } from '../../../core/services';<br class="title-page-name"/>import { PlayerService } from '../../services/player.service';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'track-list',<br class="title-page-name"/> templateUrl: 'track-list.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class TrackListComponent {<br class="title-page-name"/> <br class="title-page-name"/> constructor(<br class="title-page-name"/>   private logService: LogService,<br class="title-page-name"/>   public playerService: PlayerService<br class="title-page-name"/> ) { }<br class="title-page-name"/><br class="title-page-name"/> public record(track: ITrack) {<br class="title-page-name"/>   this.logService.inspect(track);<br class="title-page-name"/> }<br class="title-page-name"/>}</pre>
<p class="mce-root">For the view template <kbd class="calibre11">track-list.component.html</kbd>, we are going to employ the powerful <kbd class="calibre11">ListView</kbd> component. This widget represents the native UITableView (<a href="https://developer.apple.com/reference/uikit/uitableview" class="calibre3">https://developer.apple.com/reference/uikit/uitableview</a>) on iOS and the native ListView (<a href="https://developer.android.com/guide/topics/ui/layout/listview.html" class="calibre3">https://developer.android.com/guide/topics/ui/layout/listview.html</a>) on Android, offering 60 fps virtual scrolling with reused rows. Its performance is unparalleled on mobile devices:</p>
<pre class="calibre22">&lt;ListView [items]="playerService.tracks"&gt;<br class="title-page-name"/>  &lt;ng-template let-track="item"&gt;<br class="title-page-name"/>    &lt;GridLayout rows="auto" columns="75,*,100"&gt;<br class="title-page-name"/>      &lt;Button text="Record" (tap)="record(track)" <br class="title-page-name"/>          row="0" col="0"&gt;&lt;/Button&gt;<br class="title-page-name"/>      &lt;Label [text]="track.name" row="0" col="1"&gt;&lt;/Label&gt;<br class="title-page-name"/>      &lt;Switch [checked]="track.solo" row="0" col="2"&gt;<br class="title-page-name"/>      &lt;/Switch&gt;<br class="title-page-name"/>    &lt;/GridLayout&gt;<br class="title-page-name"/>  &lt;/ng-template&gt;<br class="title-page-name"/>&lt;/ListView&gt;</pre>
<p class="mce-root">There's a lot going on with this view template, so let's inspect it a bit.</p>
<p class="mce-root">Since we made <kbd class="calibre11">playerService</kbd> <kbd class="calibre11">public</kbd> upon injection into our Component's constructor, we can bind directly to its tracks via the <kbd class="calibre11">ListView</kbd> items' attribute using standard Angular binding syntax expressed as <kbd class="calibre11">[items]</kbd>. This will be the collection our list will iterate on.</p>
<p class="mce-root">The <kbd class="calibre11">template</kbd> node inside allows us to encapsulate how each row of our list will be laid out. It also allows us to declare a variable name (<kbd class="calibre11">let-track</kbd>) for use as our iterator reference. </p>
<p class="mce-root">We start with a GridLayout, since each row will contain a <span>Record</span> button (to allow a track to be re-recorded), to which we will assign a width of 75. This button will be bound to the <kbd class="calibre11">tap</kbd> event, which will activate a recording session if the user is authenticated.</p>
<p class="mce-root">Then, we will have a Label to display a user-provided name for the track, which we will assign <kbd class="calibre11">*</kbd> to ensure it expands to fill the horizontal space in between our left-hand and right-hand columns. We use the text attribute to bind to <kbd class="calibre11">track.name</kbd>.</p>
<p class="mce-root">Lastly, we will use <kbd class="calibre11">switch</kbd> to allow the user to toggle soloing the track in the mix. This provides the <kbd class="calibre11">checked</kbd> attribute to allow us to bind our <kbd class="calibre11">track.solo</kbd> property to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building a dialog wrapper service to prompt the user</h1>
                
            
            <article>
                
<p class="mce-root">If you recall from <a href="part0023.html#LTSU0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 1</a>, <em class="calibre21">Get Into Shape with @NgModule</em>, recording is a feature that should only be available to authenticated users. Therefore, we will want to prompt the user with a login dialog when they tap the <span>Record</span> button on each track. If they are already logged in, we will want to prompt them to confirm if they want to re-record the track for good usability.</p>
<p class="mce-root">We could handle this dialog directly in the Component by importing a NativeScript dialog service that provides a consistent API across both platforms. The <kbd class="calibre11">ui/dialogs</kbd> module from the NativeScript framework (<a href="https://docs.nativescript.org/ui/dialogs" class="calibre3">https://docs.nativescript.org/ui/dialogs</a>) is a very convenient service, allowing you to create native alerts, confirms, prompts, actions, and basic login dialogs. However, we may want to provide custom native dialog implementations on both iOS and Android down the road for an even nicer UX experience. There are several plugins that provide very elegant native dialogs, for example, <a href="https://github.com/NathanWalker/nativescript-fancyalert" class="calibre3">https://github.com/NathanWalker/nativescript-fancyalert</a>.</p>
<p class="mce-root">To prepare for this enriched user experience, let's build a quick Angular service that we can inject and use everywhere, which will allow us to easily implement these niceties down the road.</p>
<p class="mce-root">Since this should be considered a <kbd class="calibre11">core</kbd> service to our app, let's create <kbd class="calibre11">app/modules/core/services/dialog.service.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// nativescript<br class="title-page-name"/>import * as dialogs from 'ui/dialogs';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class DialogService {<br class="title-page-name"/> <br class="title-page-name"/>  public alert(msg: string) {<br class="title-page-name"/>    return dialogs.alert(msg);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public confirm(msg: string) {<br class="title-page-name"/>    return dialogs.confirm(msg);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public prompt(msg: string, defaultText?: string) {<br class="title-page-name"/>    return dialogs.prompt(msg, defaultText);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public login(msg: string, userName?: string, password?: string) {<br class="title-page-name"/>    return dialogs.login(msg, userName, password);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public action(msg: string, cancelButtonText?: string, <br class="title-page-name"/>    actions?: string[]) {<br class="title-page-name"/>    return dialogs.action(msg, cancelButtonText, actions);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">At first glance, this may appear incredibly wasteful! Why create a wrapper that provides the exact same API as a service that already exists from the NativeScript framework?</p>
<p class="mce-root">Yes, indeed, at this stage, it appears that way. However, we are preparing for greatness in flexibility and power with how we will handle these dialogs in the future. Stay tuned for a potential bonus chapter of material covering this fun and unique polish to the integration.</p>
<p class="mce-root">The last thing we need to do before we move on to use this service is to ensure it is added to our core service <kbd class="calibre11">PROVIDERS</kbd> collection. This will make sure Angular's DI system knows our new service is a valid token available for injection.</p>
<p class="mce-root">Open <kbd class="calibre11">app/modules/core/services/index.ts</kbd> and modify as follows:</p>
<pre class="calibre22">import { AuthService } from './auth.service';<br class="title-page-name"/>import { DatabaseService } from './database.service';<br class="title-page-name"/>import { DialogService } from './dialog.service';<br class="title-page-name"/>import { LogService } from './log.service';<br class="title-page-name"/><br class="title-page-name"/>export const PROVIDERS: any[] = [<br class="title-page-name"/> AuthService,<br class="title-page-name"/> DatabaseService,<br class="title-page-name"/> DialogService,<br class="title-page-name"/> LogService<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>export * from './auth.service';<br class="title-page-name"/>export * from './database.service';<br class="title-page-name"/>export * from './dialog.service';<br class="title-page-name"/>export * from './log.service';</pre>
<p class="mce-root">We are now ready to inject and use our new service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating DialogService into our component </h1>
                
            
            <article>
                
<p class="mce-root">Let's open up <kbd class="calibre11">track-list.component.ts</kbd> and inject <kbd class="calibre11">DialogService</kbd> for use in our record method. We will also need to determine if the user is logged in to conditionally display a login dialog or confirm prompt, so let's also inject <kbd class="calibre11">AuthService</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack } from '../../../core/models';<br class="title-page-name"/>import { AuthService, LogService, DialogService } from '../../../core/services';<br class="title-page-name"/>import { PlayerService } from '../../services/player.service';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'track-list',<br class="title-page-name"/>  templateUrl: 'track-list.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class TrackListComponent {<br class="title-page-name"/> <br class="title-page-name"/> constructor(<br class="title-page-name"/>   private authService: AuthService,<br class="title-page-name"/>   private logService: LogService,<br class="title-page-name"/>   private dialogService: DialogService,<br class="title-page-name"/>   public playerService: PlayerService<br class="title-page-name"/> ) { }<br class="title-page-name"/><br class="title-page-name"/> public record(track: ITrack, usernameAttempt?: string) {<br class="title-page-name"/>   if (AuthService.CURRENT_USER) {<br class="title-page-name"/>     this.dialogService.confirm(<br class="title-page-name"/>       'Are you sure you want to re-record this track?'<br class="title-page-name"/>     ).then((ok) =&gt; {<br class="title-page-name"/>       if (ok) this._navToRecord(track);<br class="title-page-name"/>     });<br class="title-page-name"/>   } else {<br class="title-page-name"/>     this.authService.promptLogin(<br class="title-page-name"/>       'Provide an email and password to record.',<br class="title-page-name"/>       usernameAttempt<br class="title-page-name"/>     ).then(<br class="title-page-name"/>       this._navToRecord.bind(this, track), <br class="title-page-name"/>       (usernameAttempt) =&gt; {<br class="title-page-name"/>         // initiate sequence again<br class="title-page-name"/>         this.record(track, usernameAttempt);<br class="title-page-name"/>       }<br class="title-page-name"/>     ); <br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _navToRecord(track: ITrack) {<br class="title-page-name"/>    // TODO: navigate to record screen<br class="title-page-name"/>    this.logService.debug('yes, re-record', track);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">The record method now first checks to see whether a user is authenticated via the static <kbd class="calibre11">AuthService.CURRENT_USER</kbd> reference, which is set when <kbd class="calibre11">AuthService</kbd> is first constructed via Angular's dependency injection upon app launch (see <a href="part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 2</a>, <em class="calibre21">Feature Modules</em>). </p>
<p class="mce-root">If a user is authenticated, we present a confirmation dialog to ensure the action was intentional.</p>
<p class="mce-root">If the user is not authenticated, we want to prompt the user to log in. To reduce the overload for this book, we will assume the user is already registered via a backend API, so we won't be asking the user to register. </p>
<p class="mce-root">We need to implement the <kbd class="calibre11">promptLogin</kbd> method in <kbd class="calibre11">AuthService</kbd> to persist the user's login credentials, so every time they return to the app, it will automatically log them in. The record method now provides an extra optional argument <kbd class="calibre11">usernameAttempt</kbd>, which will be useful to repopulate the username field of the login prompt when reinitiating the login sequence after a user input validation error. We won't do a thorough validation of user input here, but we can at least do a lightweight check for a valid email.</p>
<div class="packt_tip">In your own app, you should probably do more user input validation.</div>
<p class="mce-root">To maintain a clean separation of concerns, open <kbd class="calibre11">app/modules/core/services/auth.service.ts</kbd> to implement <kbd class="calibre11">promptLogin</kbd>. Here's the entire service with the modifications:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// lib<br class="title-page-name"/>import { BehaviorSubject } from 'rxjs/BehaviorSubject';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { DatabaseService } from './database.service';<br class="title-page-name"/>import { DialogService } from './dialog.service';<br class="title-page-name"/>import { LogService } from './log.service';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class AuthService {<br class="title-page-name"/><br class="title-page-name"/> // access our current user from anywhere<br class="title-page-name"/> public static CURRENT_USER: any;<br class="title-page-name"/> <br class="title-page-name"/> // subscribe to authenticated state changes<br class="title-page-name"/> public authenticated$: BehaviorSubject&lt;boolean&gt; = <br class="title-page-name"/>   new BehaviorSubject(false);<br class="title-page-name"/> <br class="title-page-name"/> constructor(<br class="title-page-name"/> private databaseService: DatabaseService,<br class="title-page-name"/> private dialogService: DialogService,<br class="title-page-name"/> private logService: LogService<br class="title-page-name"/> ) {<br class="title-page-name"/>   this._init();<br class="title-page-name"/> } <br class="title-page-name"/><br class="title-page-name"/> public promptLogin(msg: string, username: string = '')<br class="title-page-name"/>   : Promise&lt;any&gt; {<br class="title-page-name"/>   return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>     this.dialogService.login(msg, username, '')<br class="title-page-name"/>       .then((input) =&gt; {<br class="title-page-name"/>         if (input.result) { // result = false when canceled<br class="title-page-name"/>           if (input.userName &amp;&amp; <br class="title-page-name"/>               input.userName.indexOf('@') &gt; -1) {<br class="title-page-name"/>               if (input.password) {<br class="title-page-name"/>                 // persist user credentials<br class="title-page-name"/>                 this._saveUser(<br class="title-page-name"/>                   input.userName, input.password<br class="title-page-name"/>                 );<br class="title-page-name"/>                 resolve();<br class="title-page-name"/>               } else {<br class="title-page-name"/>                 this.dialogService.alert(<br class="title-page-name"/>                   'You must provide a password.'<br class="title-page-name"/>                 ).then(reject.bind(this, input.userName));<br class="title-page-name"/>               }<br class="title-page-name"/>           } else {<br class="title-page-name"/>             // reject, passing userName back<br class="title-page-name"/>             this.dialogService.alert(<br class="title-page-name"/>               'You must provide a valid email address.'<br class="title-page-name"/>             ).then(reject.bind(this, input.userName));<br class="title-page-name"/>           }<br class="title-page-name"/>         }<br class="title-page-name"/>       });<br class="title-page-name"/>     });<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> private _saveUser(username: string, password: string) {<br class="title-page-name"/>   AuthService.CURRENT_USER = { username, password };<br class="title-page-name"/>   this.databaseService.setItem(<br class="title-page-name"/>     DatabaseService.KEYS.currentUser,<br class="title-page-name"/>     AuthService.CURRENT_USER<br class="title-page-name"/>   );<br class="title-page-name"/>   this._notifyState(true);<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/>  private _init() {<br class="title-page-name"/>    AuthService.CURRENT_USER =<br class="title-page-name"/>      this.databaseService<br class="title-page-name"/>      .getItem(DatabaseService.KEYS.currentUser);<br class="title-page-name"/>    this.logService.debug(<br class="title-page-name"/>      `Current user: `, AuthService.CURRENT_USER<br class="title-page-name"/>    );<br class="title-page-name"/>    this._notifyState(!!AuthService.CURRENT_USER);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _notifyState(auth: boolean) {<br class="title-page-name"/>    this.authenticated$.next(auth);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We use the <kbd class="calibre11">dialogService.login</kbd> method to open a native login dialog, allowing the user to input a username and password. Once they choose ok, we do minimal validation of the input and, if successful, proceed to persist the username and password via <kbd class="calibre11">DatabaseService</kbd>. Otherwise, we simply alert the user of an error and reject our promise, passing along the username that was entered. This allows us to help the user out by redisplaying the login dialog with the failed username they entered, so they can more easily make corrections.</p>
<p class="mce-root">With these service level details complete, the <kbd class="calibre11">track-list</kbd> component is looking pretty good. However, there is one additional step we should take while we are working on this. If you recall, our TrackModel contains an order property that will help the user order the tracks in any way they'd like for convenience. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating an Angular Pipe - OrderBy </h1>
                
            
            <article>
                
<p class="mce-root">Angular provides the Pipe decorator for ease in creating view filters. Let's start by showing how we will use this in the view. You can see that it appears very similar to a command-line pipe used in Unix shell scripts; hence, it's named: <kbd class="calibre11">Pipe</kbd>:</p>
<pre class="calibre22">&lt;ListView [items]="playerService.tracks | orderBy: 'order'"&gt;</pre>
<p class="mce-root">This will take the <kbd class="calibre11">playerService.tracks</kbd> collection and ensure it is ordered via the <kbd class="calibre11">order</kbd> property of each <kbd class="calibre11">TrackModel</kbd> for the view display.</p>
<p class="mce-root">Since we may want to use this anywhere in our app views, let's add this pipe as part of <kbd class="calibre11">CoreModule</kbd>. Create <kbd class="calibre11">app/modules/core/pipes/order-by.pipe.ts</kbd> and here is how we will implement <kbd class="calibre11">OrderByPipe</kbd>:</p>
<pre class="calibre22">import { Pipe } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Pipe({<br class="title-page-name"/> name: 'orderBy'<br class="title-page-name"/>})<br class="title-page-name"/>export class OrderByPipe {<br class="title-page-name"/><br class="title-page-name"/> // Comparator method<br class="title-page-name"/> static comparator(a: any, b: any): number {<br class="title-page-name"/>   if (a === null || typeof a === 'undefined') a = 0;<br class="title-page-name"/>   if (b === null || typeof b === 'undefined') b = 0;<br class="title-page-name"/><br class="title-page-name"/>   if ((isNaN(parseFloat(a)) || !isFinite(a)) || <br class="title-page-name"/>       (isNaN(parseFloat(b)) || !isFinite(b))) {<br class="title-page-name"/>      // lowercase strings<br class="title-page-name"/>      if (a.toLowerCase() &lt; b.toLowerCase()) return -1;<br class="title-page-name"/>      if (a.toLowerCase() &gt; b.toLowerCase()) return 1;<br class="title-page-name"/>   } else {<br class="title-page-name"/>     // ensure number values<br class="title-page-name"/>     if (parseFloat(a) &lt; parseFloat(b)) return -1;<br class="title-page-name"/>     if (parseFloat(a) &gt; parseFloat(b)) return 1;<br class="title-page-name"/>   }<br class="title-page-name"/><br class="title-page-name"/>   return 0; // values are equal<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> // Actual value transformation<br class="title-page-name"/> transform(value: Array&lt;any&gt;, property: string): any {<br class="title-page-name"/>   return value.sort(function (a: any, b: any) {<br class="title-page-name"/>     let aValue = a[property];<br class="title-page-name"/>     let bValue = b[property];<br class="title-page-name"/>     let comparison = OrderByPipe<br class="title-page-name"/>                      .comparator(aValue, bValue);<br class="title-page-name"/>     return comparison;<br class="title-page-name"/>   });<br class="title-page-name"/> } <br class="title-page-name"/>}</pre>
<p class="mce-root">We won't go into too much detail with what is going on here, since this is pretty typical in JavaScript to order a collection. To finish this off, ensure <kbd class="calibre11">app/modules/core/pipes/index.ts</kbd> follows our standard convention:</p>
<pre class="calibre22">import { OrderByPipe } from './order-by.pipe';<br class="title-page-name"/><br class="title-page-name"/>export const PIPES: any[] = [<br class="title-page-name"/> OrderByPipe<br class="title-page-name"/>];</pre>
<p class="mce-root">Lastly, import the preceding collection for use with <kbd class="calibre11">app/modules/core/core.module.ts</kbd>. Here is the full file with all the modifications:</p>
<pre class="calibre22">// nativescript<br class="title-page-name"/>import { NativeScriptModule } from 'nativescript-angular/nativescript.module'; <br class="title-page-name"/><br class="title-page-name"/>// angular<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { PIPES } from './pipes';</strong><br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/> imports: [<br class="title-page-name"/>   NativeScriptModule<br class="title-page-name"/> ],<br class="title-page-name"/> <strong class="calibre1">declarations: [<br class="title-page-name"/>   ...PIPES<br class="title-page-name"/> ],</strong><br class="title-page-name"/> providers: [<br class="title-page-name"/>   ...PROVIDERS<br class="title-page-name"/> ],<br class="title-page-name"/> exports: [<br class="title-page-name"/>   NativeScriptModule,<br class="title-page-name"/>   <strong class="calibre1">...PIPES</strong><br class="title-page-name"/> ]<br class="title-page-name"/>})<br class="title-page-name"/>export class CoreModule { }</pre>
<p class="mce-root">Since pipes are view level implementations, we ensure they are added as part of the <kbd class="calibre11">exports</kbd> collection to allow other modules to use them.</p>
<p class="mce-root">Now, if we were to run our app at this point, you would notice that our <kbd class="calibre11">OrderBy</kbd> pipe used on our <kbd class="calibre11">track-list.component.html</kbd> view template would <em class="calibre21">NOT</em> work!</p>
<div class="packt_infobox">Angular modules compile in isolation of one another.</div>
<p class="mce-root">This is a critical point to understand: Angular compiles <kbd class="calibre11">PlayerModule</kbd> that declares <kbd class="calibre11">TrackListComponent</kbd><strong class="calibre1"> </strong>unto itself in an isolated sense. Since we declared <kbd class="calibre11">OrderByPipe</kbd> as part of <kbd class="calibre11">CoreModule</kbd> and <kbd class="calibre11">PlayerModule</kbd> has no dependency (at the moment) on <kbd class="calibre11">CoreModule</kbd>, the <kbd class="calibre11">TrackListComponent</kbd> gets compiled with no awareness of <kbd class="calibre11">OrderByPipe</kbd>! You would end up seeing this error generated in the console:</p>
<pre class="calibre22">CONSOLE ERROR file:///app/tns_modules/tns-core-modules/trace/trace.js:160:30: ns-renderer: ERROR BOOTSTRAPPING ANGULAR<br class="title-page-name"/>CONSOLE ERROR file:///app/tns_modules/tns-core-modules/trace/trace.js:160:30: ns-renderer: Template parse errors:<br class="title-page-name"/> The pipe 'orderBy' could not be found ("<br class="title-page-name"/> &lt;/ListView&gt;--&gt;<br class="title-page-name"/> <br class="title-page-name"/> &lt;ListView [ERROR -&gt;][items]="playerService.tracks | orderBy: 'order'"&gt;<br class="title-page-name"/>   &lt;ng-template let-track="item"&gt;<br class="title-page-name"/>     &lt;GridLayout rows"): TrackListComponent@10:10</pre>
<p class="mce-root">To remedy this, we want to make sure <kbd class="calibre11">PlayerModule</kbd> is aware of view-related declarations (such as pipes or other components) from <kbd class="calibre11">CoreModule</kbd> by ensuring <kbd class="calibre11">CoreModule</kbd> is added as part of the <kbd class="calibre11">imports</kbd> collection on <kbd class="calibre11">PlayerModule</kbd>. This also provides us with one additional convenience. If you notice, <kbd class="calibre11">CoreModule</kbd> specifies <kbd class="calibre11">NativeScriptModule</kbd> as an export, which means any module that imports <kbd class="calibre11">CoreModule</kbd> will inherently get <span><kbd class="calibre11">NativeScriptModule</kbd> along with it. Here are the final modifications to <kbd class="calibre11">PlayerModule</kbd> to allow everything to work together:</span></p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { NgModule } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/><strong class="calibre1">import { CoreModule } from '../core/core.module';</strong><br class="title-page-name"/>import { COMPONENTS } from './components';<br class="title-page-name"/>import { PROVIDERS } from './services';<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/> imports: [<br class="title-page-name"/>   <strong class="calibre1">CoreModule </strong><br class="title-page-name"/> ],<br class="title-page-name"/> providers: [...PROVIDERS],<br class="title-page-name"/> declarations: [...COMPONENTS],<br class="title-page-name"/> exports: [...COMPONENTS]<br class="title-page-name"/>})<br class="title-page-name"/>export class PlayerModule { }</pre>
<p class="mce-root">We can now move on to the <kbd class="calibre11">player-controls</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building PlayerControls component</h1>
                
            
            <article>
                
<p class="mce-root">Our player controls should contain a play/pause toggle button for the entire mix. It should also present a slider control to allow us to skip ahead and rewind our playback.</p>
<p class="mce-root">Let's create <kbd class="calibre11">app/modules/player/components/player-controls/player-controls.component.html</kbd><strong class="calibre1"> </strong>(with a matching <kbd class="calibre11">.ts</kbd>):</p>
<pre class="calibre22">&lt;GridLayout rows="100" columns="75,*" row="1" col="0"&gt;<br class="title-page-name"/>  &lt;Button [text]="playStatus" (tap)="togglePlay()" row="0" col="0"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;Slider minValue="0" [maxValue]="duration" <br class="title-page-name"/>          [value]="currentTime" row="0" col="1"&gt;&lt;/Slider&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">We start with a single row <kbd class="calibre11">GridLayout</kbd> with an explicit 100 height. Then, the first column will be constrained to 75 wide to accommodate our play/pause toggle button. Then, the second column will take up the rest of the horizontal space, indicated with <kbd class="calibre11">*</kbd> with the <kbd class="calibre11">Slider</kbd> component. This component is provided by the NativeScript framework and allows us to bind the <kbd class="calibre11">maxValue</kbd> attribute to the total duration of our mix as well as a value to <kbd class="calibre11">currentTime</kbd> of the playback.</p>
<p class="mce-root">Then, for <kbd class="calibre11">player-controls.component.ts</kbd>:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack } from '../../../core/models';<br class="title-page-name"/>import { LogService } from '../../../core/services';<br class="title-page-name"/>import { PlayerService } from '../../services';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/> moduleId: module.id,<br class="title-page-name"/> selector: 'player-controls',<br class="title-page-name"/> templateUrl: 'player-controls.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class PlayerControlsComponent {<br class="title-page-name"/><br class="title-page-name"/> public currentTime: number = 0; <br class="title-page-name"/> public duration: number = 0; <br class="title-page-name"/> public playStatus: string = 'Play';<br class="title-page-name"/><br class="title-page-name"/> constructor(<br class="title-page-name"/>   private logService: LogService,<br class="title-page-name"/>   private playerService: PlayerService<br class="title-page-name"/> ) { }<br class="title-page-name"/><br class="title-page-name"/> public togglePlay() {<br class="title-page-name"/>   let playing = !this.playerService.playing;<br class="title-page-name"/>   this.playerService.playing = playing;<br class="title-page-name"/>   this.playStatus = playing ? 'Stop' : 'Play';<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="mce-root">For now, we have placed <kbd class="calibre11">currentTime</kbd> and <kbd class="calibre11">duration</kbd> directly on the component, however, we will refactor those into  <kbd class="calibre11">PlayerService</kbd> later. Eventually, all of the state related to our player will come from <kbd class="calibre11">PlayerService</kbd> when we implement plugins to handle our audio in subsequent chapters. The <kbd class="calibre11">togglePlay</kbd> method also just stubs out some general behavior, toggling the text of our button to <span>Play</span> or <span>Stop</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Quick preview </h1>
                
            
            <article>
                
<p class="mce-root">At this point, we will take a quick look at what we have built so far. Currently, our player service returns an empty list of tracks. To see the results, we should add some dummy data to it. For example, in <kbd class="calibre11">PlayerService</kbd>, we could add:</p>
<pre class="calibre22">constructor() {<br class="title-page-name"/>  this.tracks = [<br class="title-page-name"/>    {name: "Guitar"},<br class="title-page-name"/>    {name: "Vocals"},<br class="title-page-name"/>  ];<br class="title-page-name"/>}</pre>
<p class="mce-root">Don't be surprised if it's not pretty; we'll cover that in the next chapter. We also won't cover all the runtime commands available to us yet; we'll cover that thoroughly in <a href="part0072.html#24L8G0-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 6</a>, <em class="calibre21">Running the app on iOS and Android</em>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preview  on iOS</h1>
                
            
            <article>
                
<p class="mce-root">You will have to be on a Mac with XCode installed to preview the iOS app:</p>
<pre class="calibre22"><strong class="calibre1">tns run ios --emulator</strong></pre>
<p class="mce-root">This should launch the iOS Simulator and you should see the following screenshot:</p>
<div class="mce-root1"><img class="image-border1" src="../images/00006.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preview on Android</h1>
                
            
            <article>
                
<p class="mce-root">You will have to have the AndroidSDKk and tools installed to preview on an Android emulator:</p>
<pre class="calibre22"><strong class="calibre1">tns run android --emulator</strong></pre>
<p class="mce-root"><span>This should launch an Android emulator and you should see the following screenshot:<br class="title-page-name"/></span></p>
<div class="mce-root1"><img class="image-border2" src="../images/00007.jpeg"/></div>
<p class="mce-root">Congratulations! We have our first view.  Well hey, no one said it would be pretty yet! </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">We have kicked off Part 2 with the component building, where we have laid out our root component <kbd class="calibre11">app.component.html</kbd> to house our primary view, where you learned about <kbd class="calibre11">GridLayout</kbd>, a very useful layout container.</p>
<p class="mce-root">Angular's Component decorator allowed us to easily build <kbd class="calibre11">TrackListComponent</kbd> as well as <kbd class="calibre11">PlayerControlsComponent</kbd>.<strong class="calibre1"> </strong>We also learned how to build an Angular <kbd class="calibre11">Pipe</kbd> to aid our view's ability to keep our track list in order. Angular's <kbd class="calibre11">NgModule</kbd> taught us we need to ensure any view-related declarations needed for any components are imported properly. This Angular design pattern helps maintain module isolation as standalone units of code that can be intermixed by importing modules into each other.</p>
<p class="mce-root">We also enhanced a fair share of our services to support some of the usability we desire with our components.</p>
<p class="mce-root">Finally, we were able to take a quick peek at what we were building. Even though it's not at all pretty at this point, we can see things coming together.</p>
<p class="mce-root">In <a href="part0059.html#1O8H60-289fe2426d594f99a90e4363b2c9c34d" class="calibre3">Chapter 4</a>, <em class="calibre21">A prettier view with CSS</em>, you will learn how to use CSS to bring out the pretty from our views.</p>


            </article>

            
        </section>
    </body></html>