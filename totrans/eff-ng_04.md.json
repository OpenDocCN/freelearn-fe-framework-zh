["```js\n<form>\n  <div class=»form-field\">\n    <label for=»description»>Description:</label>\n    <input type=»text» id=»description» name=»description»>\n  </div>\n  …………\n  <button type=»submit»>Submit</button>\n</form>\n```", "```js\nimports: [CommonModule, FormsModule, the page won’t be reloaded when you click your form’s submit button, which is precisely what we wanted.\nBut how can this be, since we didn’t change our form? The Angular `ngForm` directive prevents the default browser behavior when submitting the form, and because of that, the page isn’t reloading. But we didn’t add the directive to our form, so why isn’t the page reloading?\nThe answer lies in the selector of the `ngForm` directive. When we inspect the selector of the `ngForm` directive, we can see that the directive is automatically applied to all form tags, and because we’ve added `FormsModule`, the `ngForm` directive is applied to the form in our component. Even though the directive is automatically applied to HTML form tags, it’s advised to write declarative code and manually apply the directive to form tags. So, add the directive to your form tag like this:\n\n```", "```js\n\n On the left, we added a template variable called `#addExpenseForm`, while on the right, we assigned this template variable with an instance of the `ngForm` directive. By assigning the directive to a template variable, we can use the directive in all sibling and child elements of our HTML form tag.\nNow that we’ve added the forms module and the `ngForm` directive, we can start to configure the fields of our template-driven form.\nConfiguring template-driven form fields\nTo have a template-driven form, we need to connect the form’s input fields to an object in our component class and bind the fields to our `ngForm` instance to validate the entire form.\nLet’s start by creating an interface for the object we want to use in our form.\nIn the `add-expense` folder, create a new file, `add-expense.interface.ts`, and add the interface reflecting the fields in your form.\nFor our example, this is the interface definition:\n\n```", "```js\n\n Also, export the interface in the `index.ts` file of the library. Now, in `add-expense.component.ts`, define a property of the `AddExpense` type, as follows:\n\n```", "```js\n\n Here, we used an input with a default value. We used an input because the form will be a dumb component, and the parent component will input any default values other than empty values.\nNote that you don’t have to use an object in a template-driven form; you can also use separated properties or a combination of properties and objects. Once you’ve defined the object, you need to bind the properties of the `expenseToAdd` object to the fields of your form. We can do this using the `ngModel` directive.\nWhen you add the `ngModel` directive, behind the scenes, Angular registers `FormControl` in the `ngForm` instance. The `ngModel` directive allows for two-way data binding, meaning the values of the `expenseToAdd` object and our form will automatically be synchronized if we change the properties in our component class or if the user enters values inside the form inputs.\nYou connect the properties of the `expenseToAdd` object to the form inputs by adding the `ngModel` directive and the `name` attribute to each of the form inputs, like this:\n\n```", "```js\n[ngModel]=\"expenseToAdd.description\" (ngModelChange)=\"expenseToAdd.description = $event\"\n```", "```js\n{{ expenseToAdd | json }}\n```", "```js\n[ngModelOptions]=\"{name: 'description', updateOn: 'blur', standalone: false}\"\n```", "```js\n    <fieldset ngModelGroup=\"amount\"></fieldset>\n    ```", "```js\n<button type=\"submit\">Submit</button>\n```", "```js\n<form #addExpenseForm=\"ngForm\" ngSubmit on the form tag; on the right-hand side, you declare the ngSubmit event in round brackets; and on the left-hand side, you define a function that’s declared in the component class to handle the submission.\nFor our example, we will create an output event to output a clone of the form object and reset the form using the `ngForm` instance. To achieve this, we need a way to access the `ngForm` instance in our component class; we can do this using the `@``ViewChild` directive:\n\n```", "```js\n\n Next, we need to add the component’s output, which will allow us to send the submitted values to the parent component so that it can act upon it accordingly:\n\n```", "```js\n\n Lastly, we need to add the `onSubmit` method with our logic:\n\n```", "```js\n\n As you can see, we used the native `structuredClone` method to send a clone of the `expenseToAdd` object to the parent. We sent a clone because `expenseToAdd` is a reference object, meaning it will be cleared everywhere (also in the parent component) after we call `reset` on the form, and it will clear the object we bound to the `ngForm` instance.\nNow that we’ve added the submit logic, we’ll start exploring validation rules, control status, and how to display messages to the user based on the control statuses and validity of the form and its controls.\nUsing built-in validation rules for template-driven forms\nFor a good user experience, it’s important to provide good user feedback on our form. You want to indicate when your form fields are valid or still require some changes to be made by the user. You also want to prevent the user from submitting the form when not all the fields are valid and provide good error messages for incorrect or incomplete form fields.\nTo achieve these feats, you must add form validations to the form fields and use the control statuses to add or remove styling and error messages. Let’s start by exploring how to validate form fields in template-driven forms.\nValidating the form fields of template-driven forms can be done using directives. Most validations can be done using the built-in validation directives, but when needed, you can also create your own directives to validate template-driven form fields.\nYou can find all built-in validation directives on the official Angular website: [https://angular.io/api/forms/Validators](https://angular.io/api/forms/Validators).\nLet’s learn how to add validators to our example form. We will start by making our form fields required using the `required` directive. You can apply the `required` validator by adding this directive to your `input` fields:\n\n```", "```js\n[max]=\"100\"\n```", "```js\n[max]=\"null\" [disabled]=\"null\"\n```", "```js\n\"@global/styling\": \"file:libs/shared/global-styling\"\n```", "```js\nform.ng-touched {\n  .ng-valid:not(fieldset)  {\n    border-left: 5px solid #42A948; /* green */\n  }\n  .ng-invalid:not(form, fieldset) {\n    border-left: 5px solid #a94442; /* red */\n  }\n}\n```", "```js\n@import '@global/styling/form-control-status';\n```", "```js\n<input required [(ngModel)]=\"expenseToAdd.description\"\n       #description template variable and assigned it with ngModel. Now, you can access and control the form control instance created by the ngModel instance through the #decscription template variable.\nLet’s add a `span` element with an error message underneath the input element:\n\n```", "```js\n\n Next, we want to ensure this message is only shown when the form has been touched, and the input validator needs to be satisfied. We can do this by using `ngForm` and the form control instance, which we bound to the template variables. The form control instance exposes several properties that we can check to determine the status of the correlating input field.\nLike the control status CSS classes, the form and form control itself expose properties to assess the same statuses: `valid`, `invalid`, `pending`, `pristine`, `dirty`, `touched`, and `untouched`. The form control also exposes `disabled` and `enabled` as checks of the disabled status of the correlating input field.\nBesides these Boolean properties, the form control exposes multiple values and methods; you can find all the properties on the official Angular website: [https://angular.io/api/forms/FormControl](https://angular.io/api/forms/FormControl).\nNow, without further ado, let’s add a `*ngIf` statement to our span element so that it’s only displayed when the input form is touched and the required validator of the form control isn’t satisfied:\n\n```", "```js\n\n As you can see, we use the `hasError` method to check for the required validator. You can go ahead and add template variables for `ngModel` and error messages for the other fields in the form. For our VAT percentage field, we will add an additional message to check for the `max` validator:\n\n```", "```js\n<button ngForm instance and made the button invalid when the invalid property of the form returned true.\nNow that we’ve enhanced the user experience of our form by adding validation rules and supplying visual user feedback through styling and error messages, let’s move on and see how we can create custom validators for template-driven forms.\nCustom validators for template-driven forms\nTo finish this section, we will learn how to create custom validators for template-driven forms. The built-in validators will cover most scenarios, but in some cases, you need to create custom validators – for example, when you want to check values in your database or state when you need to perform cross-field validations or need to perform other validations that can’t be done with built-in validators.\nAll the built-in validators for template-driven forms are directives, so we also need to create a directive to build custom validators.\nLet’s start by creating a new library with our custom Nx generator. Name the library `form-validators`; then, select `max-word-count` and check the `template-driven-validators` folder and move the directive inside it. Now, add an export for the directive inside `index.ts`:\n\n```", "```js\n\n Now, let’s add some validation logic inside our directive. We’ll start by creating an input for our custom validator directive:\n\n```", "```js\n\n Next, we must implement the `Validator` interface:\n\n```", "```js\n\n The `Validator` interface requires you to implement a `validate` function:\n\n```", "```js\n\n As you can see, the `validate` function takes `AbstractControl` as input and returns either `null` or a `ValidationErrors` object. Inside the `validate` function, we will add our validation logic. When the validation passes, we will return `null`, and when the validation doesn’t pass, we will return a `ValidationErrors` object. To perform some validation logic, we need to access the form control of the HTML element on which our directive is declared.\nThe `AbstractControl` function parameter gives you access to a `FormControl` or `FormGroup` instance, depending on which HTML element you place the directive. When you place the directive on HTML elements that declare `ngModel`, you will receive a `FormControl` instance; if you put the directive on an HTML element with `ngModelGroup` declared, you will receive a `FormGroup` instance.\nIn our example, we will use the directive on elements with `ngModel` on it and receive a `FormControl` instance through the `function` parameter. We want to check the value of our form control and determine if more words are in the value than we defined in our `maxWords` input. When there are more words, our validation fails, and we return a `ValidationErrors` object; otherwise, we return `null`, which means our validation passes.\nFirst, we must check the number of words:\n\n```", "```js\n\n As you can see, we use `control.value` to get the value from the form control. If there is a value, we trim it and split it into spaces to get the number of words in the string. Next, we check if the number of words is bigger than the `maxWords` input; if that is the case, we return the error object; otherwise, we return `null`. The `error` object can have any format you like:\n\n```", "```js\n\n That is all the logic we need for our custom validator. But there is still one problem: when we declare the directive on our form, the form won’t know this directive is a custom validator; it will think it’s just a regular directive. Instead, we want our form to register the directive as a validator so that the form takes the directive into account when determining the form’s validity and its form groups and controls. We can achieve this by adding a provider to the directive decorator:\n\n```", "```js\n\n By adding the `NG_VALIDATORS` provider to our directive, the `ngForm` instance will register the directive as a validator and include the directive when determining if the form and its groups and controls are valid.\nTo use the directive, you need to add the directive class’ name to the imports of our `add-expense` component since both the directive and our component are standalone. After adding the directive to the imports array, you can use the directive in the HTML template:\n\n```", "```js\ndescription.hasError('btLibsUtilMaxWordCount')\n```", "```js\n{btLibsUtilMaxWordCount: { count: wordCount }}\n```", "```js\ndescription.getError('btLibsUtilMaxWordCount').count\n```", "```js\nconst password = control.get('password').value;\nconst confirm = control.get('password-confirm').value;\n```", "```js\n<input required [(ngModel)]=\"formObj.password\" null if the validation passes and a ValidationErrors object when the validation fails.\nAsync validations with custom validators\nLastly, you can create asynchronous validators. These asynchronous validators work similarly to regular custom validators; there are only two differences. First, the provider for the asynchronous validators is different. If you want to create an asynchronous validator, you must change the provider to the following values:\n\n```", "```js\n\n Secondly, you need to return `Promise` or `Observable` with either a `null` value or the `ValidationErrors` object. Here’s an example of such a function:\n\n```", "```js\n\n In this example, the `checkUsernameInDatabase` function is an API call that returns an observable, and we use RxJS’s pipe and map to map the result to `null` or the `ValidationErrors` object. You can use any asynchronous logic inside your validator, so long as you return `Promise` or `Observable` with `null` or the `ValidationErrors` object.\nIn this section, you learned how to create template-driven forms. You also learned how to create form controls using the `ngModel` directive, how to create form groups using `ngModelGroup`, and how to use built-in validators. Then, you learned about how to style a form and display error messages based on form control statuses. Lastly, you learned how to create custom validators for form controls, form groups, and asynchronous validation rules. Next, we will start learning how to build reactive forms.\nBuilding reactive forms\nIn this section, you will learn how to build reactive forms. We will rebuild the form we used in the previous section but reactively. You will learn how to create `FormGroup`, `FormArray`, and `FormControl` instances, how to validate reactive forms, and how to create custom validators for reactive forms. You will also learn how to dynamically create form fields and how to change the update behavior of reactive form fields.\nCreating a reactive form\nStart by removing or commenting out the HTML template and TypeScript code for our template-driven form. I will comment out the code so that it remains an example of the template-driven approach.\nNext, we’ll start with the same simple HTML form, including the description, amount excluding VAT, VAT percentage, and date fields. We will gradually transform the simple HTML form into a reactive form:\n\n```", "```js\n\n After creating the simple HTML form, we will start by importing `ReactiveFormsModule` inside our component. When building reactive forms, you import `ReactiveFormsModule` instead of the regular `FormsModule`. After adding `ReactiveFormsModule` to your component file, we can move on and start to create the form model using the `FormGroup` and `FormControl` classes.\nAt its core, an Angular form is a `FormGroup` class with `FormControl` elements inside `FormGroup`. When we created our template-driven form, Angular created a `FormGroup` class for our `ngForm` instance and added a `FormControl` element inside the `FormGroup` class for each `ngModel` directive we declared.\nTo construct our reactive form model, we need to do the same only manually:\n\n```", "```js\n\n As you can see, we’ve created a `FormGroup` instance and added a `FormControl` element inside for each form field. Inside the function brackets of the form control, we’ve added either an empty string or `null`; these are the default values for the form control instances.\nIf you want different default values, you can change the values inside the function brackets of the `FormControl` instances. Later in this section, we will create an input by which you can send default values from the parent, just like we did with the template-driven form.\nAfter creating the form model, you need to bind the form model to the form inside your HTML template. You can bind the form model to the template by using the `FormGroup` directive and assigning the directive with the form model, as follows:\n\n```", "```js\n<input formControlName directive with the key that was used to assign FormControl inside the FormGroup class you declared inside your TypeScript file. After adding the formControlName directive to all your form fields, the form model is bound to the HTML form.\nNow, when you change the values inside the input fields, `addExpenseForm` in your component class will be updated, and when you update the `FormControl` values inside your TypeScript file, the changes you made will be reflected inside the input fields in the browser. You can test this by adding a default value to one of the `FormControl` values inside your TypeScript file; when you do, the value should be reflected inside the HTML template.\nTo test if changing the input also changes the values of `addExpenseForm` in your component class, you can temporarily add the following code to your template so that you can see the changes to the `addExpenseForm` object in real time:\n\n```", "```js\n\n After creating the reactive form, you can remove the aforementioned line of code. Until then, it can be helpful to see if all values are synchronized.\nNow that we’ve defined and tested our form fields, let’s learn how we can group form fields into reactive forms.\nGrouping fields in reactive forms\nIn our template-driven form, we grouped the amount excluding VAT and VAT percentage fields using the `ngModelGroup` directive. By grouping fields, you can perform validation logic on the group instead of the individual fields, style the group, or just change the data structure to something better resembling your state or DTO objects.\nLet’s also group the amount excluding VAT and the VAT percentage fields in our reactive form. Start by changing the HTML template and wrap the two input fields inside a fieldset HTML template:\n\n```", "```js\n\n Next, change the form model so that it reflects the structure where the two fields are grouped inside a `FormGroup` class:\n\n```", "```js\n\n When you’ve updated the form model, you need to bind the form group inside the HTML form. You can bind the form group using the `formGroupName` directive and assign it with the key of your `FormGroup` class inside the form model. In our case, this is `amount`:\n\n```", "```js\n\n That is all you need to do. Now, when you log the form value, its structure will look like this:\n\n```", "```js\n\n Now that you know how to group fields using the `FormGroup` class, let’s explore how we can dynamically add fields and `FormControl` instances to our form and form model.\nDynamically adding fields and FormControl instances\nUnlike template-driven forms, when creating reactive forms, you can also group fields using the `FormArray` class. The `FormArray` class is useful when you don’t know how many values will be supplied, and the user can dynamically add and remove input fields in the form. An example of this might be tags or comments.\nTo demonstrate this, we will add another field to our reactive form so that we can add tags. Start by adding the `FormArray` class to your form model:\n\n```", "```js\n\n As you can see, `FormArray` takes an array instead of an object as a parameter. Inside this array, we declared a form control, which will be the first tag inside our form. Because `FormArray` takes an array, we can dynamically add (or remove) from controls, which, in turn, will add or remove input fields to/from our HTML form.\nNow that we’ve added the `FormArray` class inside our form model, let’s add some HTML so that the user can add multiple tags.\nStart by creating a `fieldset` value and declare the `formArrayName` directive on the HTML tag:\n\n```", "```js\n\n Inside `fieldset`, add the following HTML:\n\n```", "```js\n\n The aforementioned HTML will output a label and input for each `FormControl` inside `FormArray`. Now, we only need a way to add and remove `FormControl` instances.\nLet’s add two buttons to the HTML underneath the input tag:\n\n```", "```js\n\n Next, we need to add the logic for the click functions inside the component class:\n\n```", "```js\n\n With the aforementioned functions added to the component class, you can now add and remove `FormControl` instances inside the `FormArray` class, which will result in added or removed input fields.\nBut what if you have data in an object format instead of an array and you need to keep the form format, and just like our previous example, you don’t know how many or what fields you will have and what the keys for these fields will be?\nAn example could be when you receive a list of statuses that our expense has gone through, such as submitted, waiting for revision, checked, approved, and so on. For these scenarios, you can use the `FormRecord` class. We won’t add this to our form, but I will outline an example of how to handle a `FormRecord` class:\n\n```", "```js\n\n The `FormRecord` class receives an object with keys and `FormControl` or `FormGroup` instances. You can add the `FormControl` instances to the `FormRecord` class as follows:\n\n```", "```js\n\n As you can see, we utilize the `addControl` method, which is exposed on the `FormRecord` class. The `addControl` method is also available on `FormGroup`, but you should use `FormRecord` when you don’t know what fields will be added beforehand. You can use the `FormGroup` when you do know what the entire model will look like. You can strongly type `FormGroup` and `FormRecord`. To strongly type `FormGroup`, use the following syntax:\n\n```", "```js\n\n In this example, we added an interface for `FormGroup` between the arrow brackets. By adding the type, you strongly typed `FormGroup` and can’t add fields not defined in the `IAddress` interface. When strongly typing a `FormRecord` class, we tell the record what value our dynamic controls will have. For example, if we have a list of keys with a Boolean value, we can use this syntax:\n\n```", "```js\n\n Here, we tell `FormRecord` that each field that will be added should be a `FormContro` instance and that `FormControl` should have a Boolean value. If we have form controls with different values, we can change the Boolean value for string or any other type our controls will hold.\nNow that you know how to group fields using `FormGroup` or dynamically add fields using `FormArray`, `FormGroup`, or `FormRecord`, let’s explore how we can control the update behavior of our fields and how to declare standalone controls in a reactive form.\nConfiguring update behavior and declaring standalone controls\nWith template-driven forms, we have the option to configure the update behavior of form control instances using the `ngModelOptions` directive; in reactive forms, we control the update behavior inside the `FormGroup`, `FormArray`, or `FormControl` class. You can add a configuration object to set the `updateOn` property. You can set the `updateOn` property for `FormGroup`, `FormArray`, and `FormControl` elements alike.\nWhen you set the `updateOn` property for a `FormGroup` element of `FormArray`, it will be applied to all nested `FormControl` elements. If you define the `updateOn` property for a nested object inside the form model, that nested property will overrule the `updateOn` property of parent elements. Just like template-driven forms, you can set the update behavior to `change` (which is the default), `blur`, or `submit`:\n\n```", "```js\nsearchInput = new FormControl('');\n```", "```js\n<input [formControl]=\"searchInput\" type=\"text\">\n```", "```js\nthis.searchInput.value;\n```", "```js\nthis.searchInput.valueChanges.subscribe(() => { ……… });\n```", "```js\nexport interface AddExpenseReactive {\n  description?: string;\n  amount?: {\n    amountExclVat?: number;\n    vatPercentage?: number;\n  };\n  date?: string[];\n  tags?: string[];\n}\n```", "```js\n@Input()\npublic set expenseToAdd(value: AddExpenseReactive) {\n  this.addExpenseForm.patchValue(value);\n}\n```", "```js\n['2023-10-15']\n```", "```js\ndate: new FormControl(['']),\n```", "```js\nthis.addExpenseForm.controls.tags.clear();\nvalue.tags?.forEach(tag => {\n  this.addExpenseForm.controls.tags.push(new FormControl(tag)); });\n```", "```js\nthis.addExpenseForm.controls.description.setValue('New description');\n```", "```js\ndescription: new FormControl('', [ValidatorFn interface. We will create the same max word count validator, just like we did with the template-driven form, now only as a function instead of a directive.\nTo create the custom validator, start by creating a new folder, `reactive-validators`, inside the `form-validators` library. Inside this folder, create a new file named `max-word-count.function.ts`. We will use this new file to create our validator function:\n\n```", "```js\n\n Here, we create the `maxWordCountValidator` function, which will receive an input for the maximum word count we will allow. Inside this function, we return an implementation of the `ValidatorFn` interface. Here, `ValidatorFn` is the same as the `validate` method we declared inside the directive; we check the word count and return `null` if the word count is equal to or smaller than the allowed count and return a `ValidationErrors` object otherwise.\nNext, you can add this custom validator to your form controls:\n\n```", "```js\nthis.addExpenseForm.controls.description.addValidators(Validators.required);\nthis.addExpenseForm.controls.description.removeValidators(Validators.required);\n```", "```js\n<span *ngIf=\"addExpenseForm.touched && addExpenseForm.controls.description.hasError('required')\">This field is required</span>\n```", "```js\nexport interface DynamicControl {\n  controlKey: string;\n  formFieldType?: 'input' | 'select';\n  inputType?: string;\n  label?: string;\n  defaultValue?: any;\n  selectOptions?: string[];\n  updateOn: 'change' | 'blur' | 'submit';\n  validators?: ValidatorFn[];\n}\n```", "```js\n@Input() formModelConfig: DynamicControl[] = [];\nformModel = new FormGroup({});\n```", "```js\nngOnChanges(changes: SimpleChanges) {\n  if (changes[‹formModelConfig']) {\n    this.formModel = new FormGroup({});\n    this.formModelConfig.forEach((control) => {\n      this.formModel.addControl(\n        control.controlKey,\n        new FormControl(control.defaultValue, { updateOn: control.updateOn, validators: control.validators }));\n    }); }}\n```", "```js\n@Output() outputForm = new EventEmitter();\nonSubmit() {\n  this.outputForm.emit(structuredClone(this.formModel.value));\n  this.formModel.reset();\n}\n```", "```js\n<div class=\"form-container\">\n  <form [formGroup]=\"formModel\" (ngSubmit)=\"onSubmit()\">\n  </form>\n</div>\n```", "```js\n<div class=\"form-field\" *ngFor=\"let control of formModelConfig\">\n  <label for=»description»>{{control.label}}</label>\n  <ng-container [ngSwitch]=»control.formFieldType»>\n    <input *ngSwitchCase=»›input›»\n            formControlName=\"{{control.controlKey}}\"\n            type=\"{{control.inputType}}\">\n    <select *ngSwitchCase=»›select›»\n            formControlName=\"{{control.controlKey}}\">\n      <option\n         *ngFor=\"let option of control.selectOptions\"\n         value=\"{{option}}\">\n      </option>\n    </select>\n  </ng-container>\n</div>\n```", "```js\n<span *ngIf=\"formModel.touched && formModel.get(control.controlKey)?.hasError('required')\"> This field is required</span>\n```", "```js\n<bt-libs-ui-dynamic-form [formModelConfig]=\"formModelConfig\" (outputForm)=\"addExpense($event)\" />\n```", "```js\nformModelConfig: DynamicControl[] = [\n  {\n    controlKey: 'description', formFieldType: 'input',\n    inputType: 'text', label: 'Description',\n    defaultValue: '', updateOn: 'change',\n    validators: [Validators.required]\n  },\n  {\n    controlKey: 'amount', formFieldType: 'input',\n    inputType: 'number', label: 'Amount excl. VAT',\n    defaultValue: null, updateOn: 'change',\n    validators: [Validators.required]\n  }\n]\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```"]