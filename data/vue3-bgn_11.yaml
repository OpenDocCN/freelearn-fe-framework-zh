- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Managing Your Application’s State with Pinia
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pinia管理您的应用程序状态
- en: Building web applications is no simple task, not only because of the amount
    of knowledge required to write them but also because of the architectural complexity
    that a mature application can develop.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Web应用程序不是一项简单的任务，这不仅是因为编写它们所需的知识的数量，而且还因为成熟的应用程序可能发展的架构复杂性。
- en: When we first started this book, we introduced simple topics such as the ability
    to replace text with string interpolation or hide an element with the `v-if` directive.
    These features are at the core of the Vue.js framework and are needed to build
    an application with this framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初开始这本书时，我们介绍了简单的话题，比如使用字符串插值替换文本或使用`v-if`指令隐藏元素。这些功能是Vue.js框架的核心，并且是使用此框架构建应用程序所必需的。
- en: 'As we progressed in the book, we started to introduce topics that are not always
    required at the very start of your project development – and in some cases not
    needed at all. In the previous chapter, we covered Vue Router, which was the first
    additional package to join the Vue.js core framework. We are going to continue
    the trend by introducing another core maintained package that is part of the Vue
    ecosystem: Pinia.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们这本书的进展，我们开始介绍那些在项目开发初期并不总是必需的话题——在某些情况下甚至根本不需要。在前一章中，我们介绍了Vue Router，这是第一个加入Vue.js核心框架的附加包。我们将继续这一趋势，通过介绍Vue生态系统的一部分核心维护包：Pinia。
- en: Pinia is the official state management package for Vue.js. It is the descendant
    of the previous state management package, which was called Vuex.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Pinia是Vue.js的官方状态管理包。它是之前状态管理包的继承者，该包被称为Vuex。
- en: Why two different names?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有两个不同的名字？
- en: If both packages have been created and maintained by the same open source maintainer,
    why do they have different names? Pinia was supposed to be called Vuex 5, but
    during its development, they decided to give it a different name due to the two
    versions being majorly different from one another.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个包都是由同一个开源维护者创建和维护的，为什么它们有不同的名字？Pinia原本应该被称为Vuex 5，但在其开发过程中，他们决定给它一个不同的名字，因为这两个版本在主要方面彼此不同。
- en: As I have already mentioned, some features are not always expected in every
    application, and state management is one of them. In fact, introducing state management
    on a very small site would probably be a sign of over-architecture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，并非每个应用程序都需要所有功能，状态管理就是其中之一。实际上，在一个非常小的网站上引入状态管理可能是一个过度架构的迹象。
- en: 'In this chapter, we are going to explain what state management is and introduce
    Pinia as the official package of the Vue.js ecosystem. We will then discuss when
    an application is expected to include a state management system and cover the
    pros and cons of using one. We will then do some practice by including two stores
    within our application: one to handle the sidebar and one to handle our posts.
    While doing so, we will also add a couple of features to our app, such as the
    ability to toggle the sidebar from the header and the option to add new posts.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释什么是状态管理，并介绍Pinia作为Vue.js生态系统的官方包。然后，我们将讨论应用程序预期包含状态管理系统的情况，并讨论使用一个系统的优缺点。然后，我们将通过在我们的应用程序中包含两个存储来进行一些实践：一个用于处理侧边栏，另一个用于处理我们的帖子。在这样做的时候，我们还将向我们的应用程序添加一些功能，例如从标题栏切换侧边栏的能力以及添加新帖子的选项。
- en: 'The chapter has the following sections:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下部分：
- en: When to use state management
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用状态管理
- en: Learning about the structure of a Pinia store
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Pinia存储的结构
- en: Centralized sidebar state management with Pinia
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pinia进行集中式侧边栏状态管理
- en: By the end of the chapter, you should be familiar with the notion of state management
    and be able to define and use stores within your future applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该熟悉状态管理的概念，并且能够在你未来的应用程序中定义和使用存储。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch we will use is called `CH11`. To pull this branch,
    run the following command or use your GUI of choice to support you in this operation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用的分支被称为`CH11`。要拉取这个分支，请运行以下命令或使用您选择的GUI来支持您进行此操作：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: When to use state management
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用状态管理
- en: The first and most important part of this chapter is learning when it is appropriate
    to use Pinia in your application and when it is not.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的部分是学习何时在您的应用程序中使用Pinia，何时不使用。
- en: All extra packages and features that are added to an application come with an
    extra cost. This cost is in the time that it takes to learn these new skills,
    the extra time that a new feature may take to build, the extra complexity that
    the overall architecture may add to the project, and finally the extra size that
    another package adds to your JavaScript bundle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有添加到应用程序中的额外包和功能都会带来额外的成本。这种成本体现在学习这些新技能所需的时间、构建新功能可能需要额外的时间、整体架构可能给项目增加的额外复杂性，以及另一个包添加到您的JavaScript包中的额外大小。
- en: Adding a state manager to your application falls into this category of possible
    features that may not always be needed. Luckily for us, adding and utilizing Pinia
    is simple and does not add as much overhead to the project as other counterparts
    such as React Redux.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态管理器添加到您的应用程序属于这类可能不是总是需要的可选功能。幸运的是，添加和使用Pinia非常简单，并且不会像React Redux等其他类似工具那样给项目增加太多开销。
- en: The rule of thumb is that state management should only be added to a project
    if the project is complex enough and includes many layers of components, and if
    passing values across the application is complicated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 常规做法是，只有在项目足够复杂且包含许多组件层，并且跨应用程序传递值变得复杂时，才应该将状态管理添加到项目中。
- en: A good use case for Pinia is an application that is large, with properties being
    passed between many layers. Another use case would be a SPA that has very complex
    data that needs to be shared and manipulated by multiple parts of the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Pinia的一个良好用例是大型应用程序，属性在多个层之间传递。另一个用例是一个SPA，它具有非常复杂的数据，需要由应用程序的多个部分共享和操作。
- en: 'The main problem that state management solves is **prop drilling**. Therefore,
    the more complex and deep the application structure is, the better suited Pinia
    is for the project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理解决的主要问题是**属性钻取**。因此，应用程序的结构越复杂、越深入，Pinia就越适合该项目：
- en: '![Figure 11.1: Properties are passed down to multiple layers of components](img/B21130_11_01_BW.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：属性传递到多个组件层](img/B21130_11_01_BW.jpg)'
- en: 'Figure 11.1: Properties are passed down to multiple layers of components'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：属性传递到多个组件层
- en: What is prop drilling?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是属性钻取？
- en: The process of passing data from parents to children, especially multiple layers
    deep, is also referred to as prop drilling. It is a commonly used term when talking
    about state management and will also be used in the rest of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件传递数据到子组件的过程，尤其是多层深度的传递，也被称为属性钻取。当谈论状态管理时，这是一个常用的术语，也将在本章的其余部分中使用。
- en: 'Let’s analyze a few project examples and see whether we would need Pinia’s
    support to handle state management:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析几个项目示例，看看我们是否需要Pinia的支持来处理状态管理：
- en: '**Brochure site**: A simple site with a couple of static pages, perfect for
    local businesses. The site may have a contact form. There is no real data that
    needs to be managed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宣传册网站**：一个包含几个静态页面的简单网站，非常适合本地企业。该网站可能包含一个联系表单。没有真正需要管理的数据。'
- en: '*Store* *not needed*'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不需要存储*'
- en: '**A personal blog**: This site is a little more complex, with dynamic pages
    that render the blog pages as we learned about in the chapter on Vue Router. The
    data is passed to the pages, but it is not modified or needed in multiple parts
    of the application.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人博客**：这个网站稍微复杂一些，具有动态页面，可以渲染我们在Vue Router章节中学到的博客页面。数据被传递到页面，但在应用程序的多个部分中不需要修改或使用。'
- en: '*Store* *not needed*'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不需要存储*'
- en: '**An e-commerce site**: A commerce site used to sell products. This site will
    mostly be dynamic, with lots of interactivity offered throughout. Data needs to
    be passed and modified by many layers of the application, such as from the cart
    to the checkout.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子商务网站**：一个用于销售产品的商业网站。该网站将主要是动态的，提供大量的交互性。数据需要通过应用程序的多个层传递和修改，例如从购物车到结账。'
- en: '*Store needed*'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*需要存储*'
- en: '**A social media site**: A site that is used to create and share posts. The
    site will also have pages filtered by user, tags, category, and so on. The same
    data can be reused in many parts of the application, and using a store can ensure
    the data is only fetched once and then reused.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交媒体网站**：一个用于创建和分享帖子的网站。该网站还将有按用户、标签、类别等过滤的页面。相同的数据可以在应用程序的许多部分中重复使用，使用存储可以确保数据只被获取一次，然后重复使用。'
- en: '*Store needed*'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*需要存储*'
- en: Adding a state manager is not a must for all sites, but a requirement that is
    driven by the specific use case and needs of your SPA. It is true that as you
    progress in your career and get familiar with the tools and technology that the
    framework has to offer, you will find yourself over-architecting your application
    more often than not. However, at the very start of your career, it is important
    to stay lean and only choose the tools that you really need for your SPA.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有网站来说，添加状态管理器并不是必须的，但它是由您特定 SPA 的用例和需求驱动的需求。诚然，随着您职业生涯的进步，您将熟悉框架提供的工具和技术，您会发现您经常过度设计您的应用程序。然而，在您职业生涯的初期，保持简洁并只选择您真正需要的
    SPA 工具是非常重要的。
- en: Before moving on to the next section, we should say a few more words on the
    real benefits of using state management. We are going to do so by comparing two
    applications that have the same component structure but handle data differently.
    One uses prop drilling, while the other uses state management.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，我们应该对使用状态管理的真正好处说几句。我们将通过比较两个具有相同组件结构但处理数据方式不同的应用程序来实现这一点。一个使用属性钻取，而另一个使用状态管理。
- en: We will start with the example shown in *Figure 11**.1*. That example is similar
    to our Companion App, and it shows the way the `post` property flows from the
    `App.vue` component all the way down to the last component to render the post
    on the screen. At this stage, the application is still quite simple. Even if there
    is some multi-layer prop drilling happening, the complexity is still acceptable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 *图 11.1* 中所示的示例开始。这个示例类似于我们的伴侣应用，它展示了 `post` 属性从 `App.vue` 组件流向屏幕上渲染的最后组件的方式。在这个阶段，应用程序仍然相当简单。即使有一些多层属性钻取发生，复杂性仍然是可接受的。
- en: 'We are now going to add the possibility for a user to edit a post. Since properties
    can simply be modified in the component in which they are defined, we will have
    to emit an “edit” event all the way up the component tree:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加用户编辑帖子的可能性。由于属性可以在定义它们的组件中简单地修改，因此我们不得不在整个组件树中发出一个“编辑”事件：
- en: '![Figure 11.2: Props are passed down and events are passed up the component
    tree](img/B21130_11_02_BW.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：属性向下传递，事件向上传递到组件树](img/B21130_11_02_BW.jpg)'
- en: 'Figure 11.2: Props are passed down and events are passed up the component tree'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：属性向下传递，事件向上传递到组件树
- en: The situation here is starting to get more complicated. On top of prop drilling,
    we also have `Post` property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的情况开始变得更加复杂。除了属性钻取之外，我们还有 `Post` 属性。
- en: 'We are going to include a Pinia store and see what changes it brings to the
    table. Pinia is going to take ownership of the `post` property and provide it
    to the component that needs to read or modify it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包括一个 Pinia 存储，看看它会给桌面带来什么变化。Pinia 将接管 `post` 属性，并将其提供给需要读取或修改它的组件：
- en: '![Figure 11.3: A Pinia store managing the data](img/B21130_11_03_BW.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3：一个 Pinia 存储管理数据](img/B21130_11_03_BW.jpg)'
- en: 'Figure 11.3: A Pinia store managing the data'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：一个 Pinia 存储管理数据
- en: Adding a store has removed a lot of complexity in our application. When we edit
    posts, the only component that we re-render now will be **Post Body**. Furthermore,
    the store easily allows us to pass specific data down, such as **Recent post**
    in the sidebar. Doing so will also ensure that the sidebar will not be re-rendered
    unless the post that changed is included in it (this was also possible using props,
    but was not usually practiced).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加存储已经从我们的应用程序中移除了很多复杂性。当我们编辑帖子时，现在唯一需要重新渲染的组件将是 **帖子正文**。此外，存储使我们能够轻松地向下传递特定数据，例如侧边栏中的
    **最近帖子**。这样做也将确保除非更改的帖子包含在侧边栏中，否则侧边栏不会重新渲染（这也可能使用属性实现，但通常不这样做）。
- en: In this short section, we defined when state management is needed and when it
    should be omitted from your application. Then, we defined when a store is needed
    in your application by describing a few example applications. Finally, we introduced
    the notion of state management and covered the benefits that it brings to your
    application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的章节中，我们定义了何时需要状态管理以及何时应该从您的应用程序中省略它。然后，我们通过描述一些示例应用程序来定义在您的应用程序中何时需要存储。最后，我们介绍了状态管理的概念，并涵盖了它为您的应用程序带来的好处。
- en: In the next section, we are going to learn about the structure of Pinia and
    how we can use it within our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习 Pinia 的结构以及我们如何在应用程序中使用它。
- en: Learning about the structure of a Pinia store
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Pinia 存储的结构
- en: In this chapter, we are going to cover what makes up a Pinia store and how it
    can be used to support you in managing the data of your application. Pinia is
    built on the notion of multiple stores. Each individual store is going to manage
    a specific set of data or company logic that is not bound to a specific component.
    Your application could have a store for posts, a store for comments, and even
    a store to manage the state of the sidebar.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍构成 Pinia 存储的内容以及它是如何支持您管理应用程序数据的。Pinia 建立在多个存储的概念之上。每个单独的存储都将管理一组特定的数据或公司逻辑，这些数据或逻辑不绑定到特定的组件。您的应用程序可以有一个帖子存储、评论存储，甚至一个用于管理侧边栏状态的存储。
- en: Stores can talk with each other, but what matters the most is that you should
    be able to easily define what makes a single store. The stores’ data should be
    split well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 存储可以相互通信，但最重要的是您应该能够轻松定义单个存储的特点。存储的数据应该很好地分割。
- en: 'Each store is divided into three different sections: **state**, **getters**,
    and **actions**.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个存储被分为三个不同的部分：**state**、**getters** 和 **actions**。
- en: These three sets of options that are available within a Pinia store can actually
    compare to existing features that we have learned about regarding Vue Single-File
    Components.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这三组在 Pinia 存储中可用的选项实际上可以与我们关于 Vue 单文件组件所了解的现有功能进行比较。
- en: The **state** object defined in Pinia is comparable to Ref or Reactive used
    as private component data. The **getters** are comparable to computed properties,
    as they are used to create a modified version of the existing **state**. Lastly,
    we have **actions** that are like methods and are used to perform side effect
    on the store.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Pinia 中定义的 `state` 对象与用作私有组件数据的 Ref 或 Reactive 相当。`getters` 与计算属性相当，因为它们用于创建现有
    **state** 的修改版本。最后，我们有 **actions**，它们类似于方法，用于在存储上执行副作用。
- en: '![Figure 11.4: Comparison between Pinia’s options and a Vue component](img/B21130_11_04_BW.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：Pinia 选项与 Vue 组件之间的比较](img/B21130_11_04_BW.jpg)'
- en: 'Figure 11.4: Comparison between Pinia’s options and a Vue component'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：Pinia 选项与 Vue 组件之间的比较
- en: 'When we first initialized the application, we opted for the `CLI` command to
    create a store for us. For this reason, the Companion App includes a very simple
    store example here: [src/stores/counter.js](https://src/stores/counter.js). Let’s
    see what it includes to learn more about the actual structure of a Pinia store:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次初始化应用程序时，我们选择了 `CLI` 命令来为我们创建存储。因此，伴侣应用程序在这里提供了一个非常简单的存储示例：[src/stores/counter.js](https://src/stores/counter.js)。让我们看看它包含的内容，以了解更多关于
    Pinia 存储的实际结构：
- en: src/stores/sidebar.js
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: src/stores/sidebar.js
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first part of a store is its declaration. A store is declared using the
    `defineStore` method available within the `pinia` package. When creating a store,
    it is common for the exported method to follow the format of `counter` repository,
    we can expect the exported method to be named `useCounterStore`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 存储的第一部分是其声明。存储是通过 `pinia` 包内可用的 `defineStore` 方法声明的。在创建存储时，通常期望导出的方法遵循 `counter`
    存储库的格式，我们可以预期导出的方法被命名为 `useCounterStore`。
- en: Next, we have the `state` object. This is declared as a function that returns
    an object. The syntax may look familiar because it is the same as the syntax that
    we introduced in [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028) when we spoke
    about Vue components being declared using Options API. The `state` object includes
    the values of the store at their initial state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `state` 对象。它被声明为一个返回对象的函数。语法可能看起来很熟悉，因为它与我们介绍选项 API 时使用的语法相同，当时我们讨论了使用选项
    API 声明 Vue 组件。`state` 对象包括存储在初始状态下的值。
- en: Next, we have getters, which are the equivalent of the computed properties available
    within a Vue component. Getters are used to create a derivative value using `state`
    or other getters. For example, in a post store, we may have getters for `visiblePost`
    that just return the posts that have a `visible` flag. Getters receive the state,
    as the first argument has shown in the previous code snippets within the getters
    doubleCount.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有获取器（getters），它们是 Vue 组件内部可用的计算属性的等价物。获取器用于使用 `state` 或其他获取器创建派生值。例如，在一个帖子存储中，我们可能有
    `visiblePost` 获取器，它只返回具有 `visible` 标志的帖子。获取器接收状态，正如前一个获取器代码片段中显示的第一个参数所示。
- en: Last, we have actions. These are equivalent to methods and are used to trigger
    a side effect that can be used to modify one or more store entries. In our example,
    the action is called `increment`, and it is used to increase the value of the
    `count` state. Actions are asynchronous and can include external side effects
    such as calling an API or calling other store actions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有动作。这些相当于方法，用于触发一个副作用，可以用来修改一个或多个存储条目。在我们的例子中，动作被命名为 `increment`，它用于增加
    `count` 状态的值。动作是异步的，可以包括外部副作用，如调用 API 或调用其他存储动作。
- en: 'Now that we have learned how a store is structured, it is time to learn how
    to use a store within a component. To use a store within a component, we need
    to initialize it using the exported method generated using `definedStore`. In
    the instance of the counter store our initialization method would be `useCounterStore`
    that was defined in a previous code block:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了存储的结构，是时候学习如何在组件中使用存储了。要在组件中使用存储，我们需要使用由 `definedStore` 生成的导出方法来初始化它。在计数器存储的实例中，我们的初始化方法将是之前代码块中定义的
    `useCounterStore`：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then use it to access the state entries directly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用它直接访问状态条目：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same is then applied for the getters and actions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于获取器和动作：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this section, we introduced the basic structure of a Pinia store. We learned
    how to declare it using `defineStore`, then explained the three different parts
    of a store: state, getters, and actions. Finally, we learned how to access a store
    from the component by using the counter store to learn the syntax required to
    access its state, getters, and actions.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Pinia 存储的基本结构。我们学习了如何使用 `defineStore` 声明它，然后解释了存储的三个不同部分：状态、获取器和动作。最后，我们学习了如何通过使用计数器存储来学习访问其状态、获取器和动作所需的语法。
- en: In the next section, we will apply what we have learned so far by creating a
    few stores.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过创建一些存储来应用我们迄今为止所学的内容。
- en: Centralized sidebar state management with Pinia
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pinia 实现集中式侧边栏状态管理
- en: In the previous section, we introduced the basic structure and syntax of Pinia.
    To better learn and understand state management, we are going to modify our Companion
    App by refactoring some of the existing data into its own store. We are going
    to implement two different stores. The first is going to be a very simple store
    that will manage the state of the sidebar, while the second is going to handle
    posts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了 Pinia 的基本结构和语法。为了更好地学习和理解状态管理，我们将通过重构一些现有数据到其自己的存储中，来修改我们的伴侣应用。我们将实现两个不同的存储。第一个将是一个非常简单的存储，用于管理侧边栏的状态，而第二个将处理帖子。
- en: The store that handles the sidebar state is going to be quite small. It will
    be perfect for us to understand the basic syntax and usage of the store, while
    the one that handles posts is going to be a little more complex.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 处理侧边栏状态的存储将会相当小。这将非常适合我们理解存储的基本语法和用法，而处理帖子的存储将会稍微复杂一些。
- en: State management should not be used for all data, and its addition should be
    accompanied by a good reason that supports its use. So, is it right to add it
    on the sidebar?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理不应用于所有数据，其添加应伴随着支持其使用的好理由。那么，在侧边栏上添加它是正确的吗？
- en: Do your research
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 做好你的研究
- en: Go back to the code base and try to understand everything you can about the
    sidebar and how it functions. Exploratory knowledge is very useful in developing
    your tech skills.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码库，尝试理解关于侧边栏及其功能的一切。探索性知识在提升你的技术技能方面非常有用。
- en: 'The sidebar currently offers these features:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当前侧边栏提供以下功能：
- en: It can either be opened or closed
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以是打开的或关闭的
- en: It can be toggled with the use of a button
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过按钮切换
- en: It remembers its state using local storage
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用本地存储来记住其状态
- en: All the logic is included within the same component
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有逻辑都包含在同一个组件中
- en: 'Our simple `Sidebar.vue` component makes our sidebar nice and interactive.
    But from the preceding list, one line should catch our eye: “All the logic is
    included within the same component.”'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的 `Sidebar.vue` 组件使侧边栏变得既美观又交互。但从前面的列表中，有一行应该引起我们的注意：“所有逻辑都包含在同一个组件中。”
- en: If you jump back to the previous section, you may notice that we mentioned that
    the use of a store is usually associated with complex scenarios whereby data is
    passed between multiple components. However, in our case, all the data is stored
    in just one file and there is not much logic or computation. So why would we need
    to include a store? And is it a good idea to do so?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到上一节，你可能会注意到我们提到使用商店通常与复杂场景相关联，在这些场景中，数据在多个组件之间传递。然而，在我们的情况下，所有数据都存储在一个文件中，逻辑或计算并不多。那么我们为什么需要包含一个商店呢？这样做是个好主意吗？
- en: The short answer is no. In a scenario like this, a store is not actually needed.
    Even if I may handle sidebars with a store in my personal projects, I would not
    suggest that everyone should do so with all Vue projects.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是不。在这种场景下，实际上并不需要商店。即使我在个人项目中可能会用商店来处理侧边栏，我也不建议每个人都应该用所有Vue项目这样做。
- en: In its current state, the sidebar is too simple for it to be moved into a Pinia
    store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，侧边栏过于简单，以至于不能将其移动到Pinia商店中。
- en: Luckily for us, we have full control of the application, so we can simply add
    a requirement that would make the use of a store appropriate. In this situation,
    the new requirement is going to be to *add the ability to toggle the sidebar from
    the* *main header*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们对应用程序有完全的控制权，所以我们可以简单地添加一个要求，使使用商店变得合适。在这种情况下，新的要求是*从* *主标题* *添加切换侧边栏的能力*。
- en: Even if this requirement seems unreasonable, it is very common for the sidebar
    to be controlled by a different element. This scenario could become reality for
    your next project.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个要求看起来不合理，侧边栏通常由不同的元素控制是非常常见的。这种情况可能会成为你下一个项目的现实。
- en: To accomplish this new requirement, we would need to perform some prop drilling
    and event bubbling for it to work without a store. However, with the use of a
    simple store, the logic is going to be abstracted from the component and easily
    accessible by the whole application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个新要求，我们需要执行一些属性钻取和事件冒泡，以便在没有商店的情况下使其工作。然而，使用简单的商店，逻辑将被从组件中抽象出来，并且可以很容易地被整个应用程序访问。
- en: The creation of our first store is going to require two steps. First, we are
    going to refactor our application by moving the existing methods and data into
    the store. Second, we are going to update the components to use the newly created
    store.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的第一个商店需要两个步骤。首先，我们将通过将现有方法和数据移动到商店中来重构我们的应用程序。其次，我们将更新组件以使用新创建的商店。
- en: 'As we mentioned before, all of the logic that handles the sidebar switching
    is currently stored in the `Sidebar.vue` component. Within this component, we
    can find the following code linked to the sidebar toggling:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，处理侧边栏切换的所有逻辑目前都存储在`Sidebar.vue`组件中。在这个组件中，我们可以找到以下与侧边栏切换相关的代码：
- en: 'Declaration of the `closed` state:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closed`状态的声明：'
- en: '[PRE5]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Method to toggle the sidebar:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换侧边栏的方法：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Life cycle to initialize the sidebar state:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化侧边栏状态的生命周期：
- en: '[PRE10]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s go and create our first store.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去创建我们的第一个商店。
- en: Creating our first store
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个商店
- en: We are now going to take the preceding code and move it into a new store named
    `sidebar.js`. Just like we mentioned before, the `Ref` variable is going to change
    into `State` and the methods are going to become Pinia actions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将前面的代码移动到一个名为`sidebar.js`的新商店中。就像我们之前提到的，`Ref`变量将变成`State`，方法将变成Pinia动作。
- en: 'Let’s start by creating an empty structure for our store:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的商店创建一个空的结构：
- en: src/stores/sidebar.js
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: src/stores/sidebar.js
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our empty store includes the import of `defineStore` from the `pinia` package,
    the initialization of the store using the naming convention that we mentioned
    before (use + store name + Store) that creates `useSidebarStore`, and lastly three
    empty options for state, getters, and actions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的空商店包括从`pinia`包中导入`defineStore`，使用我们之前提到的命名约定（use + store name + Store）来初始化商店，从而创建`useSidebarStore`，最后是状态、获取器和动作的三个空选项。
- en: 'At this stage, the store is ready to be filled with information. Let’s populate
    it with the sidebar logic:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，商店已经准备好填充信息。让我们用侧边栏逻辑来填充它：
- en: src/stores/sidebar.js
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: src/stores/sidebar.js
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we declared a new value in the state object called `closed`.
    This has been set to `true` initially. We have left the `getters` untouched for
    now, as it is going to be used later in the section. Next, we declared two actions.
    One was to toggle the sidebar and the other was to load the sidebar from the local
    storage using existing code from our previous methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在状态对象中声明了一个新的值`closed`。它最初被设置为`true`。我们目前没有修改`getters`，因为它将在后面的部分中使用。接下来，我们声明了两个动作。一个是切换侧边栏，另一个是使用我们之前方法中的现有代码从本地存储中加载侧边栏。
- en: If we compare the code within the actions with methods that existed in the component,
    you will notice that they are very similar. The main difference is in the way
    in which we can access the state. In fact, when these methods were in the component,
    we had to use `closed.value` to access the value of the ref, while in Pinia, the
    value of individual state entities can be accessed using the `this.closed` keyword.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将动作中的代码与组件中存在的方法进行比较，你会注意到它们非常相似。主要区别在于我们可以访问状态的方式。实际上，当这些方法在组件中时，我们必须使用`closed.value`来访问引用的值，而在Pinia中，可以使用`this.closed`关键字来访问单个状态实体的值。
- en: Now that our store is complete, we just need to go back into the sidebar and
    replace the previous logic with the new store. Replacing the current logic with
    the store will require three steps. First, we need to load and initialize the
    store. Second, we need to replace the methods with Pinia actions, and finally,
    we need to modify the template to use the state from the store and not the ref.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了存储，我们只需要回到侧边栏并替换之前的逻辑为新存储。用存储替换当前逻辑需要三个步骤。首先，我们需要加载和初始化存储。其次，我们需要用Pinia动作替换方法，最后，我们需要修改模板以使用存储的状态而不是引用。
- en: 'Let’s start by removing the previous ref and initialize the store:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先移除之前的引用并初始化存储：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The store is initialized by importing and calling `useSidebarStore`. This is
    the exported method that we declared in the store. It is common to declare a constant
    called either just `store` or the name + `Store`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是通过导入并调用`useSidebarStore`来初始化的。这是我们声明的导出方法。通常声明一个名为`store`或名称+`Store`的常量是很常见的。
- en: Did you know?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: Using specific names for the store such as `sidebarStore` rather than just calling
    it `Store` can be very beneficial when trying to search for all the usages of
    a specific store. Since using state management allows you to use this logic anywhere
    in the app, it is nice to be able to search for it quickly, so having a consistent
    naming convention is helpful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定的存储名称，如`sidebarStore`而不是仅仅调用它为`Store`，在尝试搜索特定存储的所有用法时非常有用。由于使用状态管理允许你在应用的任何地方使用这种逻辑，所以能够快速搜索它是非常好的，因此有一个一致的命名约定是有帮助的。
- en: 'In the next step, we are going to work on the methods. We will remove existing
    methods and replace them with the store actions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将处理方法。我们将移除现有方法并用存储动作替换它们：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just like before, the preceding code includes two steps. It first removes the
    previous logic and then replaces it with the store implementation. We updated
    the content of the `onBeforeMount` life cycle by removing the logic that handles
    the retrieval of the sidebar from the state and replacing it with the `loadSidebarFromLocalStorage`
    action.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，前面的代码包括两个步骤。它首先移除之前的逻辑，然后用存储实现替换它。我们通过移除处理从状态中检索侧边栏的逻辑，并用`loadSidebarFromLocalStorage`动作替换它来更新了`onBeforeMount`生命周期内容。
- en: You may have noticed that we have not replaced the `toggleSidebar` method yet.
    This was not a mistake; in fact, we are going to be able to call the Pinia action
    directly from `<template>`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们还没有替换`toggleSidebar`方法。这不是一个错误；实际上，我们将能够直接从`<template>`调用Pinia动作。
- en: 'Let’s see which changes are needed in the HTML of our component to complete
    our refactoring into a Pinia store:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的组件HTML需要哪些更改来完成我们的重构到Pinia存储：
- en: src/components/organisms/sidebar.vue
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: src/components/organisms/sidebar.vue
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Updating the HTML is the easiest change of all. In fact, the only requirement
    here is to prepend all states and actions with the `sidebarStore` store constant.
    Just like actions, state values can also be accessed directly as shown by `sidebarStore.closed`.
    This was used to access the `closed` state value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 更新HTML是最容易的改变之一。实际上，这里唯一的必要条件是将所有状态和动作前缀为`sidebarStore`存储常量。就像动作一样，状态值也可以直接访问，就像`sidebarStore.closed`所示。这被用来访问`closed`状态值。
- en: At this stage, our refactoring of the sidebar is complete. All the logic that
    used to live within the component has been moved into a new store. The sidebar
    should work as expected, with the only difference being that its value and logic
    are stored in a store and not in the component itself.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们对侧边栏的重构已经完成。所有曾经存在于组件中的逻辑都已经移动到一个新的存储中。侧边栏应该按预期工作，唯一的区别是它的值和逻辑存储在存储中，而不是在组件本身中。
- en: To complete our task, we need to allow another part of the application to toggle
    the sidebar. This was the requirement that we added to justify our store creation
    and to learn about the store in more detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的任务，我们需要允许应用程序的另一部分切换侧边栏。这是我们添加以证明创建存储的必要性和深入了解存储的要求。
- en: Expanding the sidebar into the header
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将侧边栏扩展到头部
- en: In this section, we are going to work in the header to complete our task by
    adding the ability to toggle the sidebar visibility from a different part of the
    application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进入头部文件，通过添加从应用程序的不同部分切换侧边栏可见性的能力来完成我们的任务。
- en: We are going to do so by adding a simple button next to the settings icon in
    the header. Just like before, we are going to import and initialize the store
    and then use its actions directly. It is important to remember that this new button
    could have been placed anywhere within the application, since its action is owned
    and controlled by the store.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在头部旁边添加一个简单的按钮来实现这一点。就像之前一样，我们将导入并初始化存储，然后直接使用其动作。重要的是要记住，这个新按钮可以放置在应用程序的任何地方，因为它的动作由存储拥有和控制。
- en: 'Let’s go into `TheHeader.vue` and add the store:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入`TheHeader.vue`并添加存储：
- en: src/stores/TheHeader.vue
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: src/stores/TheHeader.vue
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no difference between the code we just wrote in the header and the
    one that we previously defined in the sidebar. In fact, when using a store, we
    are able to use it anywhere we want in the application without having to define
    anything else. All instances of the store will work as one, allowing us to use
    and modify states from different parts of the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在头部编写的代码与我们之前在侧边栏中定义的代码之间没有区别。事实上，当使用存储时，我们可以在应用程序的任何地方使用它，而无需定义任何其他内容。所有存储的实例将作为一个整体工作，允许我们从应用程序的不同部分使用和修改状态。
- en: At this stage, our Companion App will have an added feature that will allow
    us to toggle the sidebar either by using the sidebar itself or from the header.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的Companion App将增加一个新功能，允许我们通过使用侧边栏本身或从头部来切换侧边栏。
- en: Introducing the notion of getters
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍获取器（getters）的概念
- en: 'Before we move to the next section in this chapter, we should introduce another
    feature of the store that was mentioned but not yet used in our Companion App:
    getters.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本章的下一节之前，我们应该介绍存储的另一个特性，该特性已被提及但尚未在我们的Companion App中使用：获取器。
- en: Getters are comparable to computed properties. They allow you to create variables
    with the use of the store state. In our case, we are going to introduce a simple
    getter that will create a friendly `open` or `closed` label for our sidebar. Outside
    of this use case, getters can be used for translation purposes, to filter arrays,
    or to normalize data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器与计算属性类似。它们允许你使用存储状态来创建变量。在我们的例子中，我们将引入一个简单的获取器，为我们的侧边栏创建一个友好的`open`或`closed`标签。在除这个用例之外，获取器还可以用于翻译目的、过滤数组或规范化数据。
- en: 'Let’s go back to the `sidebar.js` file and add our `friendlyState` getter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`sidebar.js`文件并添加我们的`friendlyState`获取器：
- en: src/stores/sidebar.js
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: src/stores/sidebar.js
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating a getter is very simple. You must declare a method within the getters
    object and then add the logic to create the value that is going to be returned
    by the getters. Just like computed properties, this is going to be cached. More
    importantly, it is not supposed to produce any side effects (e.g., calling an
    API or logging data).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建获取器非常简单。你必须在获取器对象中声明一个方法，然后添加逻辑来创建获取器将要返回的值。就像计算属性一样，这将被缓存。更重要的是，它不应该产生任何副作用（例如，调用API或记录数据）。
- en: The main point to raise about getters is that they automatically receive the
    state object as the first argument. So, to access the closed state, we would write
    `state.closed`. Just like computed properties, thanks to the Vue reactivity system,
    if the state value changes, the `friendlyState` value will also update automatically.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于获取器需要提出的主要观点是它们自动接收状态对象作为第一个参数。因此，要访问关闭状态，我们将编写`state.closed`。就像计算属性一样，多亏了Vue的反应系统，如果状态值发生变化，`friendlyState`值也会自动更新。
- en: 'Now that our getter is in place, it is time to use it. We are going back to
    the headers and adding this string to be visible right below the user settings.
    We can reuse the store we previously imported to access the newly defined getter:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了getter，是时候使用它了。我们回到标题部分，将这个字符串添加到用户设置下方可见的位置。我们可以重用之前导入的存储来访问新定义的getter：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may have noticed from the previous code snippets that we did not require
    any extra initialization or code and that we were able to use the existing store
    to print the `friendlyState` getters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，从之前的代码片段中我们没有需要任何额外的初始化或代码，并且我们能够使用现有的存储来打印`friendlyState` getters。
- en: 'The header should now display our string:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在标题应该会显示我们的字符串：
- en: '![Figure 11.5: Companion App header with the sidebar state](img/B21130_11_05.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：带有侧边栏状态的伴侣应用程序标题](img/B21130_11_05.jpg)'
- en: 'Figure 11.5: Companion App header with the sidebar state'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：带有侧边栏状态的伴侣应用程序标题
- en: This was a simple example that helped us learn how to refactor existing code,
    as well as how to define a store with states, getters, and actions. Lastly, it
    helped us learn how to use the store from one or more components within the app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，帮助我们学习如何重构现有代码，以及如何定义具有状态、getter和actions的存储。最后，它帮助我们学习如何在应用程序中的一个或多个组件中使用存储。
- en: We are going to continue our journey to learning about Pinia by introducing
    another store in our Companion App. In the next section, we are going to create
    a store that will handle our posts. This is going to be a little bit more complex
    than the previous one and will allow us to introduce a few more features offered
    by the state manager.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在伴侣应用程序中引入另一个存储来继续我们的Pinia学习之旅。在下一节中，我们将创建一个将处理我们的帖子的存储。这将比之前的更复杂一些，并允许我们介绍状态管理器提供的更多功能。
- en: Creating a post store with Pinia
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pinia 创建帖子存储
- en: Adding state management in an application is a never-ending task, as it continues
    to evolve as the application grows. What we have done so far in our application
    – refactoring the application by moving logic out of the component and into the
    store – is a common practice. As we mentioned before, moving the sidebar logic
    into a store was a bit too much and not expected in a real app, because the logic
    was small enough to live within the component (even with the prop drilling).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中添加状态管理是一个永无止境的任务，因为随着应用程序的增长，它也在不断进化。到目前为止我们在应用程序中所做的工作——通过将逻辑从组件中移出并放入存储中来进行应用程序的重构——是一种常见的做法。正如我们之前提到的，将侧边栏逻辑移入存储中有点过于激进，在真实的应用程序中并不期望这样做，因为逻辑足够小，足以在组件内部运行（即使有属性钻取）。
- en: 'In this section, the situation is different. We are going to refactor a vital
    part of the application into the store: the posts. Handling the data fetching
    and management of the posts is a vital part of the application and will probably
    grow in complexity as your application grows. Because of these points, moving
    the posts into the store is going to improve the overall application structure.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，情况有所不同。我们将重构应用程序的一个关键部分到存储中：帖子。处理帖子的数据获取和管理是应用程序的一个关键部分，并且随着应用程序的增长可能会变得更加复杂。正因为如此，将帖子移入存储将改善应用程序的整体结构。
- en: Just like before, we are going to refactor the current code by first analyzing
    the code base to find all the code related to the post. We are then going to create
    a new store and move the code there. Finally, we are going to update the component
    to use the store.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们将通过首先分析代码库以找到所有与帖子相关的代码来重构当前代码。然后，我们将创建一个新的存储并将代码移到那里。最后，我们将更新组件以使用存储。
- en: Since this is the second time we are going through this exercise, I am going
    to jump past some steps and move directly into the creation of the store. Before
    you jump to the next section, I suggest you search for all the methods that are
    related to the post and compare them with the ones that we are going to write
    in our store. This exercise is going to be extremely valuable as it will provide
    you with insight into your current understanding of the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第二次进行这个练习，我将跳过一些步骤，直接进入存储的创建。在你跳到下一节之前，我建议你搜索所有与帖子相关的所有方法，并将它们与我们将在存储中编写的那些方法进行比较。这个练习将非常有价值，因为它将为你提供关于你对应用程序当前理解的洞察。
- en: Our new store is going to be called `posts.vue`. It will be saved in the `src/stores`
    folder just like our previous store.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新存储将被命名为`posts.vue`。它将保存在`src/stores`文件夹中，就像我们之前的存储一样。
- en: 'This store is going to include a state with `posts` and `page` properties,
    as well as two different actions: `fetchPosts` and `removePosts`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此存储将包含具有 `posts` 和 `page` 属性的状态，以及两个不同的操作：`fetchPosts` 和 `removePosts`：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We initialized the store by utilizing the naming convention that we introduced
    before. This produced a named export called `usePostsStore`. Then we declared
    our state with an empty array for the `posts` variable and a value of `0` for
    with `{ posts: [], page: 0 }`. Next, we copied our methods and turned them into
    Pinia’s action. The main difference between the previous methods that lived within
    the component and the copy that we have added to our store is the way in which
    we access variables such as `page` and `posts`. In a Pinia store, the state values
    can be accessed using the `page.value`, we would change this to `this.page`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过利用之前引入的命名约定初始化了存储。这产生了一个名为 `usePostsStore` 的命名导出。然后我们使用空数组为 `posts` 变量声明了状态，并使用
    `{ posts: [], page: 0 }` 的值为 `0`。接下来，我们复制了我们的方法并将它们转换为 Pinia 的操作。与前存在于组件中的方法以及我们添加到存储中的副本之间的主要区别是我们访问变量（如
    `page` 和 `posts`）的方式。在 Pinia 存储中，可以通过 `page.value` 访问状态值，我们将它改为 `this.page`。'
- en: This is the only change that we are going to make for the methods, as the rest
    of the logic stays the same and will not require any modification.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要为方法做出的唯一更改，因为其余的逻辑保持不变，并且不需要任何修改。
- en: Compared to the previous section, we have yet to introduce anything new, and
    the refactoring of the post store has followed a very similar flow as the sidebar
    store implementation. Refactoring logic into a store is usually going to be quite
    a simple exercise whereby we can lift and shift most of the logic like in our
    two examples.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节相比，我们还没有引入任何新内容，对帖子存储的重构流程与侧边栏存储实现非常相似。将逻辑重构到存储中通常是一个非常简单的练习，我们可以像在两个示例中那样提升和转移大部分逻辑。
- en: Now that the store is set, we will move our focus to the component to ensure
    it uses the store state and actions. While doing so, we are going to learn how
    to destructure a Pinia store to increase the readability of our component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存储已设置，我们将把注意力转向组件，确保它使用存储状态和操作。在这个过程中，我们将学习如何解构 Pinia 存储以增加组件的可读性。
- en: Destructing a store directly using syntax such as `const { test, test2 } = useTestStore()`
    is not possible, as it would break the reactivity of this state.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用如 `const { test, test2 } = useTestStore()` 这样的语法解构存储是不可能的，因为这会破坏此状态的响应性。
- en: Breaking the reactivity would mean that if the value changes within the store,
    the change will not propagate to the component anymore. To fix this limitation,
    Pinia exposes a `storeToRefs` method that will allow us to safely destructure
    the Pinia store.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 打破响应性意味着如果存储中的值发生变化，该变化将不再传播到组件中。为了解决这个问题，Pinia 提供了一个 `storeToRefs` 方法，它将允许我们安全地解构
    Pinia 存储。
- en: Store or ref is a personal preference
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 存储或 ref 是个人喜好
- en: Using the store directly like we did in our previous example or destructuring
    values to turn them into Refs is a completely personal preference. There is no
    right or wrong choice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储，就像我们在之前的示例中所做的那样，或者将值解构为 Refs 是一个完全个人的选择。没有对错之分。
- en: Using the store directly will clearly define what data is coming from the store,
    as it will prefix all data by the store name such as `myStore.firstName`. On the
    other hand, using Refs will generate a much cleaner component, as the state will
    not require the prefix, and accessing a state will just require the ref’s name
    such as `firstName`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用存储将明确定义来自存储的数据，因为它将使用存储名称作为所有数据的前缀，例如 `myStore.firstName`。另一方面，使用 Refs 将生成一个更干净的组件，因为状态不需要前缀，访问状态只需使用
    ref 的名称，例如 `firstName`。
- en: 'Let’s complete our store migration by changing the component to use the store
    and doing so using the `storeToRefs` method. Due to the file including many changes,
    we are going to break it down into multiple stages:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将组件更改为使用存储并使用 `storeToRefs` 方法来完成我们的存储迁移。由于文件包含许多更改，我们将将其分解为多个阶段：
- en: 'Initialize the store:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化存储：
- en: '[PRE23]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Replace the `private` state with the `store` state:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `private` 状态替换为 `store` 状态：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Replace methods with a store action:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法替换为存储操作：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Update the HTML.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 HTML。
- en: 'Due to the fact that we have chosen to turn the store state into Refs, no changes
    are required within the HTML, as the names of the old Refs and the new Refs now
    match. The only change that we need to make is in the `watch` method. In fact,
    because we turned the posts array from a reactive to a ref, we now need to append
    the `.value` for it to function properly:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们选择将存储状态转换为Refs，因此HTML内部不需要进行任何更改，因为旧Refs和新Refs的名称现在是一致的。我们唯一需要更改的是`watch`方法。实际上，因为我们已经将posts数组从响应式转换为ref，现在我们需要添加`.value`以便它能够正常工作：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Before we move on, I want to bring your attention to step 3\. In fact, if you
    were careful, you may have noticed that we extracted the actions of the store
    directly without using `storeToRefs`. This is possible because actions are stateless
    and do not have any reactivity.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想将您的注意力引到第3步。实际上，如果您足够细心，可能会注意到我们没有使用`storeToRefs`直接提取了存储的动作。这是可能的，因为动作是无状态的，并且没有任何响应性。
- en: 'The complete file will look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件将看起来像这样：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementing an Add Post action
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现添加帖子动作
- en: A few chapters ago, we introduced a component aimed at adding new posts to our
    state. This component was never fully implemented, as it is missing the main logic
    required to create a post. The reason why the component was left in this state
    was that adding the functionality without a store in place would have required
    a lot of prop drilling and event bubbling.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在几章之前，我们介绍了一个旨在向我们的状态添加新帖子的组件。这个组件从未完全实现，因为它缺少创建帖子所需的主要逻辑。组件被留下这种状态的原因是，在没有存储的情况下添加功能将需要大量的属性钻取和事件冒泡。
- en: Thanks to the post store, this is not the case anymore. In fact, we are going
    to be able to generate the logic required to add a new post using store actions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了帖子存储，这种情况不再存在。实际上，我们将能够使用存储动作生成添加新帖子所需的逻辑。
- en: The store is the sole owner of the posts, so we do not have to worry about where
    the posts are used. We can simply create an action that adds a post knowing that
    the store will handle the propagation and handling of the state within the rest
    of the application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是帖子的唯一所有者，所以我们不必担心帖子在哪里被使用。我们可以简单地创建一个添加帖子的动作，知道存储将处理应用程序其余部分的状态传播和处理。
- en: 'First, we are going to add an action in our `posts.js` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`posts.js`文件中添加一个动作：
- en: src/stores/post.js
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: src/stores/post.js
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `addPost` action is going to add a post by adding it at the start of the
    posts list. For the scope of our Companion App, adding a new post will just set
    the main body of the post, because other information such as ID and user information
    are going to be hardcoded and provided by a function called `generatePostStructure`..
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`addPost`动作将通过在帖子列表的开头添加帖子来添加帖子。对于我们的Companion App的范围，添加新帖子将只设置帖子的主要内容，因为其他信息，如ID和用户信息，将被硬编码并由名为`generatePostStructure`的函数提供。'
- en: 'Next, we are going to initialize the store and attach this action to the `createPostHandler`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化存储并将此动作附加到`createPostHandler`：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using the new action follows the same syntax used before. First, we import the
    store. Second, we initialize it. Third, we destructure the actions that we want
    to use, and lastly, we use the action as if it were a simple method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新动作遵循之前使用的相同语法。首先，我们导入存储。其次，我们初始化它。然后，我们解构我们想要使用的动作，最后，我们像使用简单方法一样使用动作。
- en: The preceding example uses the text area ref to get the `textarea` value. This
    is not the correct use of Vue.js and accessing values like this should be avoided.
    In fact, in the next chapter, we are going to refactor this file by introducing
    two-way binding with `v-model`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了文本区域ref来获取`textarea`的值。这不是Vue.js的正确用法，并且应该避免以这种方式访问值。实际上，在下一章中，我们将通过引入`v-model`的双向绑定对这个文件进行重构。
- en: Create your own store
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的存储
- en: Before moving on to the next chapter, you should try and create your own store.
    You can create a very similar store to the sidebar by creating a store that can
    handle the visibility of the `create post` component. You can use the button within
    the sidebar labeled `CreatePost.vue` visibility. You can see the full implementation
    in the `CH11-END` branch.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，您应该尝试创建自己的存储。您可以通过创建一个可以处理`create post`组件可见性的存储来创建一个与侧边栏非常相似的存储。您可以使用侧边栏中标记为`CreatePost.vue`可见性的按钮。您可以在`CH11-END`分支中看到完整的实现。
- en: In this section, we continued learning about the Pinia store by refactoring
    the post data. We created a new store by defining its state and actions. We then
    converted the existing code to work within the Pinia store. Next, we introduced
    the `storeToRefs` method and learned how to destructure state and actions from
    a store. Finally, we made use of the new store by adding the ability for users
    to add a new post by simply creating a new action. What you learned here is not
    a complete list of features offered by Pinia, but a quick introduction to a great
    state management package. As you practice more, you will then learn about other
    features such as `$patch` and `$reset`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们继续通过重构帖子数据来学习关于 Pinia 存储库的知识。我们通过定义其状态和动作创建了一个新的存储库。然后，我们将现有代码转换为在 Pinia
    存储库中工作。接下来，我们介绍了 `storeToRefs` 方法，并学习了如何从存储库中解构状态和动作。最后，我们通过添加用户通过创建新的动作添加新帖子的能力来利用新的存储库。您在这里学到的不是
    Pinia 提供的所有功能的完整列表，而是一个对优秀状态管理包的快速介绍。随着您练习的增多，您将了解其他功能，如 `$patch` 和 `$reset`。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Introducing state management into your application can really help you handle
    your data with ease. In the two examples that we shared in this chapter, we saw
    the benefit that state management can add to your application by avoiding prop
    drilling and event bubbling.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态管理引入您的应用程序可以真正帮助您轻松处理数据。在本章中我们分享的两个示例中，我们看到了状态管理如何通过避免属性钻取和事件冒泡来为您的应用程序增加好处。
- en: Before we conclude this chapter, I want to share one more benefit of using state
    management in your application. The refactor that we have accomplished in the
    previous two sections highlights the fact that using the Pinia store helped us
    remove lots of logic from the components to a single location within the store
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，我想分享使用状态管理在您的应用程序中的一个额外好处。在前两节中我们所完成的重构突出了使用 Pinia 存储库帮助我们从组件中移除大量逻辑到存储文件的单个位置这一事实。
- en: This abstraction is not only good for a development experience but can also
    be used to choose which parts of our application can be unit tested. You may remember
    from [*Chapter 8*](B21130_08.xhtml#_idTextAnchor103) that choosing what to test
    is quite complicated, as there is a very fine line between testing too much and
    testing too little. I personally use state management to delineate which parts
    of the application I will unit test. I achieve this by always making sure all
    stores are thoroughly tested.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象不仅对开发体验有益，还可以用来选择我们应用程序中哪些部分可以进行单元测试。您可能还记得从[*第8章*](B21130_08.xhtml#_idTextAnchor103)，选择要测试的内容相当复杂，因为测试过多和测试过少之间有一条非常细的界限。我个人使用状态管理来界定我将要单元测试的应用程序部分。我通过始终确保所有存储库都得到彻底测试来实现这一点。
- en: 'In this chapter, we first introduced the notion of state management and talked
    through the syntax and features that Pinia has to offer. We then started to put
    what we learned into practice by refactoring the sidebar into its own store. By
    doing so, we learned how to declare state, getters, and actions and how to use
    them within our components. Next, we continued our learning by refactoring one
    more piece of our application: the posts. We created a store and converted the
    methods into Pinia actions. Finally, we learned how to destructure state and the
    importance that state management can have in our application architecture.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了状态管理的概念，并讨论了 Pinia 提供的语法和功能。然后，我们开始将所学知识付诸实践，通过将侧边栏重构为其自己的存储库。通过这样做，我们学习了如何声明状态、获取器和动作，以及如何在组件中使用它们。接下来，我们继续学习，通过重构我们应用程序的另一部分：帖子。我们创建了一个存储库，并将方法转换为
    Pinia 动作。最后，我们学习了如何解构状态以及状态管理在我们应用程序架构中的重要性。
- en: In the next chapter, we are going to learn how to handle forms in our application
    by introducing two-way binding with `v-model` and client-side validation with
    **VeeValidate**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过引入 `v-model` 的双向绑定和客户端验证的 **VeeValidate** 来处理我们应用程序中的表单。
