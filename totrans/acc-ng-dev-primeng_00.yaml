- en: '*Chapter 4*: Exploring Angular Components Features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：探索 Angular 组件功能'
- en: In [*Chapter 3*](B16295_03_ePub_RK.xhtml#_idTextAnchor047), *Introducing CSS
    Custom Properties and New Provider Scopes,* we explored new platform and framework
    features in depth to prepare for *Part 2, Build a Real-World Application with
    the Angular Ivy Features You Learned*. Let's continue, but this time focus on
    brand new APIs introduced in the Angular component packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16295_03_ePub_RK.xhtml#_idTextAnchor047)，“介绍 CSS 自定义属性和新提供者作用域”，我们深入探讨了新的平台和框架功能，为*第2部分，使用你学到的
    Angular Ivy 功能构建真实世界应用程序*做准备。让我们继续，但这次将重点放在 Angular 组件包中引入的新 API 上。
- en: 'With Angular Ivy, the two first official Angular packages for Google products
    were introduced: YouTube Player and embedded Google Maps. We will explore both
    of these packages in this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Angular Ivy 的推出，推出了两个官方 Angular 包用于 Google 产品：YouTube Player 和嵌入式 Google
    Maps。在本章中，我们将探讨这两个包。
- en: 'Finally, we will cover two new APIs introduced by the Angular CDK: the Clipboard
    API and component testing harnesses. The Angular CDK clipboard directive, service,
    and domain object interact with the operating system''s native clipboard. A component
    harness is a testing API wrapping one or more Angular components using the test-as-a-user
    approach. It is usable in the context of unit tests and end-to-end tests.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍 Angular CDK 引入的两个新 API：剪贴板 API 和组件测试工具。Angular CDK 的剪贴板指令、服务和域对象与操作系统的原生剪贴板交互。组件工具是一个测试
    API，它使用测试即用户的方法包装一个或多个 Angular 组件。它可以在单元测试和端到端测试的上下文中使用。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Angular YouTube Player
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular YouTube Player
- en: Angular Google Maps components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Google Maps 组件
- en: The Clipboard API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板 API
- en: Testing as a user with component harnesses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件工具进行用户测试
- en: Learning about these topics will enable you to use these powerful features for
    our existing application in *Part 2, Build a Real-World Application with the Angular
    Ivy Features You Learned*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些主题将使您能够在*第2部分，使用你学到的 Angular Ivy 功能构建真实世界应用程序*中使用这些强大的功能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To proceed with this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续本章，您需要以下内容：
- en: Angular 9.0
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 9.0
- en: TypeScript 3.6
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 3.6
- en: You can find the complete code for the video and map examples in this book's
    companion GitHub repository at [https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的配套 GitHub 仓库中找到视频和映射示例的完整代码：[https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter4)。
- en: Angular YouTube Player
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular YouTube Player
- en: As part of Angular Ivy, the Angular team published official Angular components
    for Google products. One of them is the Angular YouTube Player. As the name suggests,
    it is used to embed a YouTube video player in your Angular application while getting
    the convenience of Angular data binding as well as programmatic access to the
    YouTube Player API through a component reference.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Angular Ivy 的一部分，Angular 团队发布了官方的 Angular 组件用于 Google 产品。其中之一是 Angular YouTube
    Player。正如其名称所示，它用于在您的 Angular 应用程序中嵌入 YouTube 视频播放器，同时获得 Angular 数据绑定的便利性以及通过组件引用以编程方式访问
    YouTube Player API。
- en: In this section, we will go through the setup needed to start using the Angular
    YouTube Player. We will then look at its entire API to get familiar with its capabilities
    and usage.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍开始使用 Angular YouTube Player 所需的设置。然后，我们将查看其整个 API，以便熟悉其功能和用法。
- en: Getting started
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'First, make sure to install the `@angular/youtube-player` package by using
    the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保使用以下命令安装`@angular/youtube-player`包：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now add `YouTubePlayerModule` to the module that declares the component that
    is going to use the YouTube Player component, as shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`YouTubePlayerModule`添加到声明将使用 YouTube Player 组件的组件的模块中，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before using the Angular YouTube Player component for the first time, we must
    load the YouTube IFrame API script. It is a 100 KB script, so depending on your
    priorities, there are several ways to load it. You could load it as part of the
    `scripts` option in your application project configuration in `angular.json`,
    but then the user would always pay the price upfront for loading, parsing, and
    executing this script.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次使用 Angular YouTube Player 组件之前，我们必须加载 YouTube IFrame API 脚本。这是一个 100 KB
    的脚本，因此根据您的优先级，有几种加载方式。您可以将它作为 `scripts` 选项的一部分加载到您的应用程序项目配置中的 `angular.json` 中，但这样用户就必须始终承担加载、解析和执行此脚本的前期费用。
- en: 'Instead, we can load it in when the component using it is activated, as we
    will see in the following tutorial:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以在使用它的组件激活时加载它，正如我们将在以下教程中看到的那样：
- en: 'First, we import the Angular core and common APIs we need and declare component
    metadata and the component name, in this case, `VideoComponent`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们需要的 Angular 核心和常用 API，并声明组件元数据和组件名称，在这种情况下为 `VideoComponent`：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we add a private property to keep a reference to the script we are going
    to dynamically load:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个私有属性以保持对将要动态加载的脚本的引用：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we inject the `Document` object of our platform, that is, the browser
    or the server:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们注入我们平台的 `Document` 对象，即浏览器或服务器：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We create an `async` script element that points to the https://www.youtube.com/iframe_api
    URL. This is a loader script for the initialization script, which sets up the
    YouTube API needed to embed YouTube videos. The Angular YouTube Player component
    is a convenient wrapper around this API:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个指向 https://www.youtube.com/iframe_api 的 `async` 脚本元素。这是一个初始化脚本的加载器脚本，它设置了嵌入
    YouTube 视频所需的 YouTube API。Angular YouTube Player 组件是这个 API 的便捷包装器：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When `VideoComponent` is initializing, add the YouTube IFrame API script element
    to the body element of the HTML document:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `VideoComponent` 初始化时，将 YouTube IFrame API 脚本元素添加到 HTML 文档的 body 元素中：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We remove the script element when `VideoComponent` is deactivated:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `VideoComponent` 停用时，我们移除脚本元素：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do not worry about loading the script multiple times. The browser will cache
    it and the YouTube IFrame API script will detect that it has already been loaded.
    For an even more robust setup solution, we can listen for the `loaded` event on
    the script element, set a loaded flag in our code, and add a condition not to
    load the script the next time this component is activated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心脚本多次加载。浏览器将缓存它，YouTube IFrame API 脚本将检测到它已经被加载。为了更健壮的设置解决方案，我们可以监听脚本元素的
    `loaded` 事件，在代码中设置一个已加载标志，并在下次此组件激活时添加一个条件以避免再次加载脚本。
- en: This is all the setup we need to use the Angular YouTube Player component. The
    full example is available in this book's companion GitHub repository, as mentioned
    in the introduction of this chapter. Now, let's move on to usage instructions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用 Angular YouTube Player 组件所需的所有设置。完整的示例可以在本书的配套 GitHub 仓库中找到，如本章引言中所述。现在，让我们继续到使用说明。
- en: Usage
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'The simplest example of using the Angular YouTube Player is to put the following
    code snippet in a component template:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular YouTube Player 的最简单示例是将以下代码片段放入组件模板中：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We pass a YouTube video ID to the `videoId` input property and the Angular YouTube
    Player will take care of everything else. Of course, it also allows for more customization.
    Let's start by looking at the `YouTubePlayer` component's data binding API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 YouTube 视频ID传递给 `videoId` 输入属性，Angular YouTube Player 将处理其他所有事情。当然，它也允许进行更多定制。让我们首先看看
    `YouTubePlayer` 组件的数据绑定 API。
- en: API reference
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 参考
- en: As of Angular version 12, the YouTube Player has no API reference. This is provided
    for you in this section so that you do not have to look up the source code and
    cross-reference it with the online YouTube JavaScript API reference to use it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Angular 版本 12，YouTube Player 没有API 参考。本节为您提供了这些信息，这样您就不必查找源代码并将其与在线 YouTube
    JavaScript API 参考进行交叉引用，以便使用它。
- en: The data binding API
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据绑定 API
- en: With the data binding API, we can declaratively configure the Angular YouTube
    Player component. The input properties are used to configure settings while the
    output properties emit events about user interactions and the video environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据绑定 API，我们可以声明式地配置 Angular YouTube Player 组件。输入属性用于配置设置，而输出属性则发出关于用户交互和视频环境的事件。
- en: First, we will look at the input properties.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看输入属性。
- en: Input properties
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入属性
- en: 'The input properties are used to configure the playback and visuals of the
    embedded player:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输入属性用于配置嵌入播放器的播放和视觉效果：
- en: '`@Input() endSeconds: number | undefined;`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() endSeconds: number | undefined;`'
- en: To set a playback ending point of the YouTube video, pass the offset in the
    number of seconds from the beginning of the video.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要设置YouTube视频的播放结束点，请传递从视频开始处的秒数偏移量。
- en: '`@Input() height: number | undefined;`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() height: number | undefined;`'
- en: The height of the YouTube Player is specified using the `height` input property,
    in the number of CSS pixels. It defaults to `390`.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: YouTube播放器的高度通过`height`输入属性指定，单位为CSS像素。默认值为`390`。
- en: '`@Input() playerVars: YT.PlayerVars | undefined;`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() playerVars: YT.PlayerVars | undefined;`'
- en: 'Many additional options can be passed to the `playerVars` input property, for
    example, we can pass `{ modestbranding: YT.ModestBranding.Modest }` to hide the
    YouTube logo. For a full reference, see [https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters](https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters).'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '可以通过`playerVars`输入属性传递许多其他选项，例如，我们可以传递`{ modestbranding: YT.ModestBranding.Modest
    }`来隐藏YouTube标志。有关完整参考，请参阅[https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters](https://developers.google.com/youtube/player_parameters.html?playerVersion=HTML5#Parameters)。'
- en: '`@Input() showBeforeIframeApiLoads: boolean | undefined;`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() showBeforeIframeApiLoads: boolean | undefined;`'
- en: The `showBeforeIframeApiLoads` input property defaults to `false` but can be
    set to `true` to make the YouTube Player component throw an error if it is loaded
    before the YouTube IFrame API is loaded.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`showBeforeIframeApiLoads`输入属性默认为`false`，但可以设置为`true`，以使YouTube播放器组件在YouTube
    IFrame API加载之前抛出错误。'
- en: '`@Input() startSeconds: number | undefined;`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() startSeconds: number | undefined;`'
- en: To set a playback starting point for the YouTube video, pass the offset in the
    number of seconds from the beginning of the video.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要设置YouTube视频的播放起始点，请传递从视频开始处的秒数偏移量。
- en: '`@Input() suggestedQuality: YT.SuggestedVideoQuality | undefined;`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() suggestedQuality: YT.SuggestedVideoQuality | undefined;`'
- en: 'The `suggestedQuality` input property accepts one of the following quality
    identifiers: `''default''`, `''small''`, `''medium''`, `''large''`, `''hd720''`,
    `''hd1080''`, `''highres''`.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`suggestedQuality`输入属性接受以下质量标识符之一：`''default''`、`''small''`、`''medium''`、`''large''`、`''hd720''`、`''hd1080''`、`''highres''`。'
- en: '`@Input() videoId: string | undefined;`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() videoId: string | undefined;`'
- en: The `videoId` input property accepts the YouTube video ID of the video to be
    played back.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`videoId`输入属性接受要播放的YouTube视频的ID。'
- en: '`@Input() width: number | undefined;`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Input() width: number | undefined;`'
- en: The width of the YouTube Player is specified using the `width` input property,
    in the number of CSS pixels. It defaults to `640`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: YouTube播放器的宽度通过`width`输入属性指定，单位为CSS像素。默认值为`640`。
- en: Next, we will look at the output properties, which emit events about the user
    interactions and video environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看输出属性，它们会发出有关用户交互和视频环境的事件。
- en: Output properties
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出属性
- en: 'The output properties expose the events that are emitted by the YouTube IFrame
    API. For a full reference of the events, see https://developers.google.com/youtube/iframe_api_reference#Events:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '输出属性暴露了由YouTube IFrame API发出的事件。有关事件的完整参考，请参阅https://developers.google.com/youtube/iframe_api_reference#Events:'
- en: '`@Output() apiChange: Observable<YT.PlayerEvent>;`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output() apiChange: Observable<YT.PlayerEvent>;`'
- en: When the closed captioning module is loaded or unloaded, an event is emitted
    by the `apiChange` output property.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当字幕模块加载或卸载时，`apiChange`输出属性会发出事件。
- en: '`@Output() error: Observable<YT.OnErrorEvent>;`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output() error: Observable<YT.OnErrorEvent>;`'
- en: 'The `error` output property emits an event when one of the following errors
    occurs, all of which are accessible through the `YT.PlayerError` enum: `EmbeddingNotAllowed`,
    `EmbeddingNotAllowed2`, `Html5Error`, `InvalidParam`, `VideoNotFound`.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当发生以下错误之一时，`error`输出属性会发出事件，所有这些错误都可以通过`YT.PlayerError`枚举访问：`EmbeddingNotAllowed`、`EmbeddingNotAllowed2`、`Html5Error`、`InvalidParam`、`VideoNotFound`。
- en: '`@Output() playbackQualityChange: Observable<YT.OnPlaybackQualityChangeEvent>;`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output() playbackQualityChange: Observable<YT.OnPlaybackQualityChangeEvent>;`'
- en: 'When the playback quality changes, one of the following quality identifiers
    is emitted through the `playbackQualityChange` output property: `''default''`,
    `''small''`, `''medium''`, `''large''`, `''hd720''`, `''hd1080''`, `''highres''`.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当播放质量改变时，以下质量标识符之一将通过`playbackQualityChange`输出属性发出：`'default'`、`'small'`、`'medium'`、`'large'`、`'hd720'`、`'hd1080'`、`'highres'`。
- en: '`@Output() playbackRateChange:Observable<YT.OnPlaybackRateChangeEvent>;`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output() playbackRateChange:Observable<YT.OnPlaybackRateChangeEvent>;`'
- en: When the video playback rate is changed, the `playbackRateChange` output property
    emits an event where its `data` property is a number such as `1.0` signifying
    the playback speed.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当视频播放速率改变时，`playbackRateChange`输出属性会触发一个事件，其中其`data`属性是一个数字，例如`1.0`，表示播放速度。
- en: '`@Output() ready: Observable<YT.PlayerEvent>;`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output() ready: Observable<YT.PlayerEvent>;`'
- en: This event is emitted when the YouTube Player is fully loaded and ready to be
    controlled.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当YouTube播放器完全加载并准备好被控制时，会触发此事件。
- en: '`@Output() stateChange: Observable<YT.OnStateChangeEvent>;`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Output() stateChange: Observable<YT.OnStateChangeEvent>;`'
- en: 'An event is output every time the YouTube Player state changes to one of the
    following, which are all accessible through the `YT.PlayerState` enum: `BUFFERING`,
    `CUED`, `ENDED`, `PAUSED`, `PLAYING`, `UNSTARTED`.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当YouTube播放器状态改变为以下之一时，都会输出一个事件，这些都可以通过`YT.PlayerState`枚举访问：`BUFFERING`、`CUED`、`ENDED`、`PAUSED`、`PLAYING`、`UNSTARTED`。
- en: Our components can send commands or read information from the YouTube Player
    using its components methods, which we will discuss next.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过其组件方法向YouTube播放器发送命令或读取信息，我们将在下一节讨论这些方法。
- en: Component methods
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件方法
- en: 'The `YouTubePlayer` component has several public methods that we can use to
    control the embedded video player:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`YouTubePlayer`组件有几个公共方法，我们可以使用这些方法来控制嵌入的视频播放器：'
- en: '`getAvailablePlaybackRates(): number[];`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAvailablePlaybackRates(): number[];`'
- en: Determines the supported playback rate for the current active or queued video.
    For a video supporting only normal playback speed, `[1.0]` is returned. Something
    like `[0.25, 0.5, 1.0, 1.5, 2.0]` might be returned.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定当前活动或队列视频支持的播放速率。对于仅支持正常播放速度的视频，返回`[1.0]`。可能返回类似`[0.25, 0.5, 1.0, 1.5, 2.0]`的数组。
- en: '`getCurrentTime(): number;`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCurrentTime(): number;`'
- en: Determines the number of seconds elapsed since the beginning of the video.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定视频开始以来的秒数。
- en: '`getDuration(): number;`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDuration(): number;`'
- en: Determines the duration in seconds of the current active video. If the video's
    metadata has not been loaded, it will return `0`.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定当前活动视频的持续时间（以秒为单位）。如果视频的元数据尚未加载，则返回`0`。
- en: For live streams, it will return the number of seconds since the stream started,
    was reset, or interrupted.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于直播流，它将返回自流开始、重置或中断以来的秒数。
- en: '`getPlaybackRate(): number;`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPlaybackRate(): number;`'
- en: Determines the playback rate of the current active or queued video where `1.0`
    is the normal playback speed.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定当前活动或队列视频的播放速率，其中`1.0`是正常播放速度。
- en: '`getPlayerState(): YT.PlayerState | undefined;`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPlayerState(): YT.PlayerState | undefined;`'
- en: 'Determines the current player state between one of the following, which are
    all accessible through the `YT.PlayerState` enum: `BUFFERING`, `CUED`, `ENDED`,
    `PAUSED` , `PLAYING`, `UNSTARTED`. Returns the latest value represented by an
    event emitted by the `stateChange` output property.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定当前播放器状态，可以是以下之一，这些都可以通过`YT.PlayerState`枚举访问：`BUFFERING`、`CUED`、`ENDED`、`PAUSED`、`PLAYING`、`UNSTARTED`。返回由`stateChange`输出属性触发的事件表示的最新值。
- en: '`getVideoEmbedCode(): string;`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getVideoEmbedCode(): string;`'
- en: 'Determines the HTML markup needed to embed the video in an HTML page, for example:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定嵌入HTML页面中视频所需的HTML标记，例如：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`getVideoLoadedFraction(): number;`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getVideoLoadedFraction(): number;`'
- en: Determines the percentage of the video that has been buffered by the player
    where `0.0` is 0% and `1.0` is 100%.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定播放器已缓冲的视频百分比，其中`0.0`是0%，`1.0`是100%。
- en: '`getVideoUrl(): string;`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getVideoUrl(): string;`'
- en: Determines the video's full URL on [youtube.com](http://youtube.com).
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定视频在[youtube.com](http://youtube.com)上的完整URL。
- en: '`getVolume(): number;`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getVolume(): number;`'
- en: Determines the volume level between `0` and `100`. Only returns integers. When
    muted, this method will return the level that was active when the audio was muted.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定音量级别在`0`到`100`之间。仅返回整数。当静音时，此方法将返回音频静音时的活动级别。
- en: '`isMuted(): boolean;`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isMuted(): boolean;`'
- en: Checks whether the audio is muted. `true` means muted, `false` means unmuted.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查音频是否静音。`true`表示静音，`false`表示未静音。
- en: '`mute(): void;`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mute(): void;`'
- en: Mutes the audio.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 静音音频。
- en: '`pauseVideo(): void;`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pauseVideo(): void;`'
- en: Pauses the video. An event is emitted through `stateChange`.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 暂停视频。通过`stateChange`触发一个事件。
- en: '`playVideo(): void;`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playVideo(): void;`'
- en: Starts playing the video. Does not count towards the video's view count on YouTube.
    An event is emitted through `stateChange`.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始播放视频。不计入YouTube视频的观看次数。通过`stateChange`触发一个事件。
- en: '`seekTo(seconds: number, allowSeekAhead: boolean): void;`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seekTo(seconds: number, allowSeekAhead: boolean): void;`'
- en: Goes to the specified timestamp. The video will keep being paused if paused
    before seeking. Setting `allowSeekAhead` to `false` keeps the player from downloading
    unbuffered content from the server. This can be used in combination with a progress
    bar.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳转到指定的标记时间戳。如果跳转前视频处于暂停状态，视频将继续暂停。将 `allowSeekAhead` 设置为 `false` 可以防止播放器从服务器下载未缓冲的内容。这可以与进度条一起使用。
- en: '`setPlaybackRate(playbackRate: number): void;`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setPlaybackRate(playbackRate: number): void;`'
- en: Adjusts the playback speed. Only affects the current active or queued video.
    Passing `1.0` to `playbackRate` sets the playback speed to normal.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调整播放速度。仅影响当前活动或排队的视频。将 `1.0` 传递给 `playbackRate` 将播放速度设置为正常。
- en: We should first call `getAvailablePlaybackRates` to check which playback rates
    are supported for the video. Listen to events emitted by the `playbackRateChange`
    output property to verify that the playback speed was successfully adjusted.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先应该调用 `getAvailablePlaybackRates` 来检查视频支持哪些播放速率。监听由 `playbackRateChange`
    输出属性发出的事件，以验证播放速度是否已成功调整。
- en: If the passed `playbackRate` does not exactly match supported playback speeds,
    the nearest rate will be matched, rounding to `1.0`.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果传递的 `playbackRate` 与支持的播放速率不完全匹配，则将匹配最近的速率，四舍五入到 `1.0`。
- en: '`setVolume(volume: number): void;`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setVolume(volume: number): void;`'
- en: Adjusts the volume to a level between `0` and `100`. Only accepts integers.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将音量调整到 `0` 到 `100` 之间的水平。仅接受整数。
- en: '`stopVideo(): void;`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopVideo(): void;`'
- en: Stops loading or playing the video. We can use this if we know that the user
    will not be watching additional videos in the YouTube Player. It's not necessary
    to call it before playing a different video. An event is emitted through `stateChange`,
    but the state could be any of `CUED`, `ENDED`, `PAUSED`, or `UNSTARTED`.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 停止加载或播放视频。如果我们知道用户不会在 YouTube 播放器中观看其他视频，我们可以使用这个方法。在播放不同视频之前不需要调用它。通过 `stateChange`
    发出事件，但状态可以是 `CUED`、`ENDED`、`PAUSED` 或 `UNSTARTED` 中的任何一个。
- en: '`unMute(): void;`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unMute(): void;`'
- en: Unmutes the audio.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 取消静音。
- en: With the knowledge of the full component API of the `YouTubePlayer` component,
    you can build your own controls on top of it, configure default settings across
    all YouTube Players in our application, control many YouTube Players at the same
    time or implement a YouTube video snippet widget using Angular.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解 `YouTubePlayer` 组件的完整组件 API 后，您可以在其之上构建自己的控件，配置应用程序中所有 YouTube Player 的默认设置，同时控制多个
    YouTube Player，或使用 Angular 实现一个 YouTube 视频片段小部件。
- en: We have discussed how to install and set up your application for the Angular
    YouTube Player. We have seen a simple example usage, listed its full API, and
    discussed its use cases. You are now ready to use the Angular YouTube Player in
    *Part 2, Build a Real-World Application with the Angular Ivy Features You Learned.*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何安装和设置您的应用程序以使用 Angular YouTube Player。我们看到了一个简单的示例用法，列出了其完整 API，并讨论了其用例。现在您可以使用
    Angular YouTube Player 在 *第 2 部分，使用您学到的 Angular Ivy 功能构建实际应用程序*。
- en: Next, we will look at the official Angular components for Google Maps.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看官方的 Angular Google Maps 组件。
- en: Angular Google Maps components
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular Google Maps 组件
- en: In this section, we will look at the official Google product component package
    called Angular Google Maps. The Google Maps API is large, so this package includes
    both a `GoogleMap` component and several other components used to configure and
    control its many features.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看名为 Angular Google Maps 的官方 Google 产品组件包。由于 Google Maps API 很大，因此此包包括
    `GoogleMap` 组件以及用于配置和控制其许多功能的几个其他组件。
- en: 'It consists of the following Angular components and directives:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它由以下 Angular 组件和指令组成：
- en: '`GoogleMap`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GoogleMap`'
- en: '`MapBicyclingLayer`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapBicyclingLayer`'
- en: '`MapCircle`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapCircle`'
- en: '`MapGroundOverlay`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapGroundOverlay`'
- en: '`MapInfoWindow`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapInfoWindow`'
- en: '`MapKmlLayer`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapKmlLayer`'
- en: '`MapMarker`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapMarker`'
- en: '`MapMarkerClusterer`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapMarkerClusterer`'
- en: '`MapPolygon`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapPolygon`'
- en: '`MapRectangle`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapRectangle`'
- en: '`MapTrafficLayer`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapTrafficLayer`'
- en: '`MapTransitLayer`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapTransitLayer`'
- en: We will explore the necessary component, `GoogleMap`, and the commonly used
    components `MapInfoWindow`, `MapMarker`, and `MapMarkerClusterer`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索必要的组件 `GoogleMap` 以及常用的组件 `MapInfoWindow`、`MapMarker` 和 `MapMarkerClusterer`。
- en: Getting started
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'To use the Angular Google Maps components, we first must load the Google Maps
    JavaScript API. This example wrapper component illustrates how to conditionally
    render the Google Maps component after the Google Maps JavaScript API has been
    initialized:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Angular Google Maps 组件，我们首先必须加载 Google Maps JavaScript API。此示例包装组件说明了在 Google
    Maps JavaScript API 初始化后如何有条件地渲染 Google Maps 组件：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our `MapComponent` has an observable UI property called `isGoogleMapsApiLoaded$`,
    which loads the Google Maps JavaScript API with a pre-configured API key. We use
    this to conditionally render the `GoogleMap` component in the component template,
    as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MapComponent` 有一个名为 `isGoogleMapsApiLoaded$` 的可观察 UI 属性，该属性使用预配置的 API 密钥加载
    Google Maps JavaScript API。我们使用此属性在组件模板中条件性地渲染 `GoogleMap` 组件，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Until the Google Maps JavaScript API is loaded, an Angular Material Spinner
    component is shown.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Maps JavaScript API 加载之前，会显示一个 Angular Material Spinner 组件。
- en: Notice that we created a view child query for `GoogleMap` and stored it in the
    `map` property. This can be used to programmatically control the map from the
    component model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为 `GoogleMap` 创建了一个视图子查询，并将其存储在 `map` 属性中。这可以用于从组件模型中编程控制地图。
- en: 'For reference, here is the Angular module that declares our example `MapComponent`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们声明的示例 `MapComponent` 的 Angular 模块：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have all the setup needed to work with the Angular Google Maps API,
    let's take a closer look at the most common components included in the `@angular/google-maps`
    package.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了使用 Angular Google Maps API 所需的所有设置，让我们更详细地看看 `@angular/google-maps`
    包中包含的最常见的组件。
- en: The GoogleMap component
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GoogleMap 组件
- en: The `GoogleMap` component is the primary entry point to the Angular Google Maps
    package. It is the top-level component that can contain other components from
    this package.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`GoogleMap` 组件是 Angular Google Maps 包的主要入口点。它是可以包含此包中其他组件的顶层组件。'
- en: This component is a declarative, Angular-specific wrapper for the `google.maps.Map`
    class from the Google Maps JavaScript API. Refer to the API reference for more
    details on the `Map` class (https://developers.google.com/maps/documentation/javascript/reference/map).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件是 Google Maps JavaScript API 中的 `google.maps.Map` 类的声明性、Angular 特定的包装器。请参阅
    API 参考以获取有关 `Map` 类的更多详细信息（https://developers.google.com/maps/documentation/javascript/reference/map）。
- en: The Google map component has the `center`, `height`, `mapTypeId`, `width`, and
    `zoom` input properties. It also accepts an `options` input of the `google.maps.MapOptions`
    type. It has 19 different output properties, all matching DOM events described
    in the Google Maps JavaScript API reference for the `Map` class. It also has a
    wide range of methods available for controlling the map.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Google 地图组件具有 `center`、`height`、`mapTypeId`、`width` 和 `zoom` 输入属性。它还接受一个 `options`
    输入，其类型为 `google.maps.MapOptions`。它有 19 个不同的输出属性，所有这些属性都与 Google Maps JavaScript
    API 参考中描述的 `Map` 类的 DOM 事件相匹配。它还提供了一系列可用于控制地图的方法。
- en: The MapMarker component
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapMarker 组件
- en: The `MapMarker` component's element, `<map-marker>`, is either nested inside
    the `<google-map>` element or a `<map-marker-clusterer>` element.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapMarker` 组件的元素 `<map-marker>` 要么嵌套在 `<google-map>` 元素内部，要么嵌套在 `<map-marker-clusterer>`
    元素内部。'
- en: This component represents a marker on a Google map. We can use a label, a marker
    icon, or a marker symbol to customize it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件代表 Google 地图上的一个标记。我们可以使用标签、标记图标或标记符号来自定义它。
- en: '`MapMarker` is an Angular-specific wrapper for the `google.maps.Marker` class.
    It has the `clickable`, `label`, `position`, and `title` input properties. It
    also accepts an `options` input of the `google.maps.MarkerOptions` type.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapMarker` 是 Angular 特定的 `google.maps.Marker` 类的包装器。它具有 `clickable`、`label`、`position`
    和 `title` 输入属性。它还接受一个 `options` 输入，其类型为 `google.maps.MarkerOptions`。'
- en: 'We can pass a custom icon through the marker options, for example, as follows
    where we use a beach flag icon:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过标记选项传递自定义图标，例如，如下所示，我们使用海滩旗帜图标：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Refer to the API reference for more details on the `Marker` class ([https://developers.google.com/maps/documentation/javascript/reference/marker](https://developers.google.com/maps/documentation/javascript/reference/marker)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 API 参考以获取有关 `Marker` 类的更多详细信息 ([https://developers.google.com/maps/documentation/javascript/reference/marker](https://developers.google.com/maps/documentation/javascript/reference/marker))。
- en: The MapMarkerClusterer component
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapMarkerClusterer 组件
- en: The `MapMarkerClusterer` component is an Angular-specific wrapper around the
    `MarkerClusterer` class from the `@googlemaps/markerclustererplus` package. Its
    element, `<map-marker-clusterer>`, is nested inside of `<google-map>` and contains
    multiple `<map-marker>` elements.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapMarkerClusterer` 组件是 Angular 特定的 `MarkerClusterer` 类的包装器，该类来自 `@googlemaps/markerclustererplus`
    包。其元素 `<map-marker-clusterer>` 嵌套在 `<google-map>` 元素内部，并包含多个 `<map-marker>` 元素。'
- en: This component is used to group many map markers into clusters when zoomed out
    on a map.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件用于在地图缩放时将许多地图标记分组到簇中。
- en: 'Before we can use it, we must load it into a global variable by inserting the
    following script tag at an appropriate place, for simplicity''s sake in the template
    of the component using it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用它之前，我们必须通过在适当的地点插入以下脚本标签将其加载到全局变量中，为了简单起见，在组件的模板中使用：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `MapMarkerClusterer` component has 18 different input properties, such as
    `minimumClusterSize`, `maxZoom`, and `zoomOnClick`. The `imagePath` input property
    can be used to specify custom map marker cluster images where this path is automatically
    suffixed with `[1-5].png` by default.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapMarkerClusterer` 组件有 18 个不同的输入属性，例如 `minimumClusterSize`、`maxZoom` 和 `zoomOnClick`。`imagePath`
    输入属性可以用来指定自定义地图标记聚类图像，其中此路径默认自动附加 `[1-5].png`。'
- en: 'Two output properties are available: `clusteringbegin` and `clusteringend`.
    They are emitted whenever markers first cluster and when they are split into individual
    markers, respectively.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个输出属性可用：`clusteringbegin` 和 `clusteringend`。它们在标记首次聚类和它们被拆分为单独标记时分别发出。
- en: Refer to the API reference for more details on the `MarkerClusterer` class (https://developers.google.com/maps/documentation/javascript/marker-clustering).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 API 参考以获取有关 `MarkerClusterer` 类的更多详细信息（https://developers.google.com/maps/documentation/javascript/marker-clustering）。
- en: The MapInfoWindow component
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MapInfoWindow 组件
- en: The `MapInfoWindow` component is an Angular-specific wrapper for the `google.maps.InfoWindow`
    class. Its element, `<map-info-window>`, is nested inside of `<google-map>`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapInfoWindow` 组件是 Angular 特定的 `google.maps.InfoWindow` 类的包装器。其元素 `<map-info-window>`
    嵌套在 `<google-map>` 中。'
- en: It is an overlay used to display notifications or metadata on top of a map,
    usually near a map marker.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个覆盖层，用于在地图上显示通知或元数据，通常在地图标记附近。
- en: Its `position` input property declares where on the map it appears. Additionally,
    it accepts an `options` input of type `google.maps.InfoWindowOptions`. It has
    five different output properties – `closeClick`, `contentChanged`, `domready`,
    `positionChanged`, and `zindexChanged` – all matching DOM events described in
    the Google Maps JavaScript API reference for the `InfoWindow` class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `position` 输入属性声明了它在地图上的位置。此外，它接受一个类型为 `google.maps.InfoWindowOptions` 的
    `options` 输入。它有五个不同的输出属性——`closeClick`、`contentChanged`、`domready`、`positionChanged`
    和 `zindexChanged`——所有这些都与 Google Maps JavaScript API 参考中 `InfoWindow` 类描述的 DOM
    事件相匹配。
- en: The `MapInfoWindow` component uses content projection, which means that the
    content we put inside of its custom element tags is rendered in its overlay when
    opened.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapInfoWindow` 组件使用内容投影，这意味着我们放入其自定义元素标签中的内容在打开时将在其覆盖层中渲染。'
- en: To display a `MapInfoWindow` component, call its `open` method, which optionally
    accepts `MapMarker` that the info window will be attached to. The `close` method
    hides the `MapInfoWindow` component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示 `MapInfoWindow` 组件，调用其 `open` 方法，该方法可选地接受 `MapMarker`，信息窗口将附加到该标记上。`close`
    方法隐藏 `MapInfoWindow` 组件。
- en: Refer to the API reference for more details on the `InfoWindow` class (https://developers.google.com/maps/documentation/javascript/reference/info-window).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 API 参考以获取有关 `InfoWindow` 类的更多详细信息（https://developers.google.com/maps/documentation/javascript/reference/info-window）。
- en: Now that you have an overview of the most used parts of the official Google
    Maps Angular components, you are prepared to use Google Maps in the Angular application
    in *Part 2, Build a Real-World Application with the Angular Ivy Features You Learned*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经了解了官方 Google Maps Angular 组件中最常用的部分，你准备好在 *Part 2, Build a Real-World
    Application with the Angular Ivy Features You Learned* 中使用 Google Maps。
- en: In the next section, we will learn about the Angular CDK's Clipboard API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解 Angular CDK 的 Clipboard API。
- en: The Clipboard API
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clipboard API
- en: The Angular CDK's Clipboard API offers a directive and a service to interact
    with the operating system's clipboard through the browser. The `CdkCopyToClipboard`
    directive can be used declaratively while the `Clipboard` service is used for
    use cases where a programmatic API is a better fit. The Clipboard API additionally
    takes care of long texts through the `PendingCopy` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK 的 Clipboard API 提供了一个指令和一个服务，通过浏览器与操作系统的剪贴板进行交互。`CdkCopyToClipboard`
    指令可以声明式地使用，而 `Clipboard` 服务用于更适合程序化 API 的用例。Clipboard API 还通过 `PendingCopy` 类处理长文本。
- en: In this section, you will learn how to use each of these classes from the Angular
    CDK package.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 Angular CDK 包中的每个这些类。
- en: The CdkCopyToClipboard directive
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CdkCopyToClipboard 指令
- en: The `CdkCopyToClipboard` directive is exported by `ClipboardModule`, which is
    in the `@angular/cdk/clipboard` sub-package. Its directive selector is `[cdkCopyToClipboard]`.
    The directive has an input property of the same name as the directive, which accepts
    the text that is copied when the element it is attached to is clicked.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`CdkCopyToClipboard` 指令由 `ClipboardModule` 导出，该模块位于 `@angular/cdk/clipboard`
    子包中。其指令选择器为 `[cdkCopyToClipboard]`。该指令有一个与指令同名的输入属性，它接受当附加到其上的元素被点击时复制的文本。'
- en: Because of browser security concerns, copying text to the clipboard must be
    done following a click event triggered by a user.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器安全考虑，复制文本到剪贴板必须在用户触发的点击事件之后进行。
- en: The copy to clipboard directive additionally has an input property named `cdkCopyToClipboardAttempts`.
    It accepts a number, which is the number of macrotask cycles the directive will
    attempt to copy the text for before giving up. This is relevant in the case of
    bigger text because of an implementation detail that ensures cross-browser compatibility
    until the upcoming Clipboard API is supported across all major browsers. We will
    discuss this caveat further when exploring the `PendingCopy` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 复制到剪贴板指令还有一个名为 `cdkCopyToClipboardAttempts` 的输入属性。它接受一个数字，这是指令在放弃之前尝试复制文本的宏任务周期数。这在处理更大的文本时是相关的，因为一个确保跨浏览器兼容性的实现细节，直到即将到来的
    Clipboard API 在所有主要浏览器中得到支持。我们将在探索 `PendingCopy` 类时进一步讨论这个注意事项。
- en: 'The copy to clipboard directive and its retry parameter is demonstrated in
    the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段演示了复制到剪贴板指令及其重试参数：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, the `CdkCopyToClipboard` directive has an output property named `cdkCopyToClipboardCopied`,
    which emits a Boolean value every time copying to the clipboard is attempted and
    indicates whether copying succeeded.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`CdkCopyToClipboard` 指令有一个名为 `cdkCopyToClipboardCopied` 的输出属性，每次尝试复制到剪贴板时都会发出一个布尔值，指示复制是否成功。
- en: The Clipboard service
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪贴板服务
- en: The `Clipboard` service is useful when we want to perform other operations before
    or after copying text to the clipboard, if the text is not easily accessible from
    a component template, or if we want more fine-grained control when copying big
    texts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在复制文本到剪贴板之前或之后执行其他操作，或者文本不易从组件模板中访问，或者我们希望在复制大文本时拥有更精细的控制时，`Clipboard` 服务非常有用。
- en: The clipboard service has two methods. The `Clipboard#copy` method accepts the
    text to copy to the clipboard and returns a Boolean value indicating whether the
    copy operation was successful.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 剪贴板服务有两种方法。`Clipboard#copy` 方法接受要复制到剪贴板的文本，并返回一个布尔值，指示复制操作是否成功。
- en: For some large texts, the `Clipboard#copy` method fails and we have to use the
    `Clipboard#beginCopy` method instead. This method also accepts the text that we
    want to copy to the clipboard but returns an instance of the `PendingCopy` class
    that we must interact further with to follow through on the copy to clipboard
    operation. This class is discussed next.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些大文本，`Clipboard#copy` 方法会失败，我们必须改用 `Clipboard#beginCopy` 方法。此方法也接受我们想要复制到剪贴板的文本，但返回一个
    `PendingCopy` 类的实例，我们必须进一步与之交互以完成复制到剪贴板的操作。这个类将在下一节中讨论。
- en: The PendingCopy class
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`PendingCopy` 类'
- en: An instance of the `PendingCopy` class is returned from the `Clipboard#beginCopy`
    method. As mentioned earlier in this section, this has to do with implementation
    details ensuring cross-browser compatibility for copying large texts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clipboard#beginCopy` 方法返回 `PendingCopy` 类的一个实例。如本节前面所述，这与确保复制大文本的跨浏览器兼容性的实现细节有关。'
- en: The first thing we must learn about the `PendingCopy` class is that we must
    tear down all instances by calling the `PendingCopy#destroy` method once we have
    finished using them or our application will leak resources.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须了解 `PendingCopy` 类的第一件事是，一旦我们完成使用它们，就必须通过调用 `PendingCopy#destroy` 方法来销毁所有实例，否则我们的应用程序将泄漏资源。
- en: The `PendingCopy#copy` method accepts no arguments and returns a Boolean value
    indicating whether the copy to clipboard operation succeeded. If `false` is returned,
    we should schedule another attempt for later.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`PendingCopy#copy` 方法不接受任何参数，并返回一个布尔值，指示复制到剪贴板的操作是否成功。如果返回 `false`，我们应该安排稍后再次尝试。'
- en: As described earlier in this section, the `CdkCopyToClipboard` directive supports
    a retry strategy for copying large texts by passing a maximum number of attempts
    to its `cdkCopyToClipboardAttempts` input property.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，`CdkCopyToClipboard` 指令通过传递最大尝试次数到其 `cdkCopyToClipboardAttempts` 输入属性，支持复制大文本的重试策略。
- en: Now that we have discussed all parts of the Angular CDK's Clipboard API, we
    are ready to implement a feature for the hands-on application in *Part 2, Build
    a Real-World Application with the Angular Ivy Features You Learned.*
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了 Angular CDK 的 Clipboard API 的所有部分，我们就准备好在 *第 2 部分，使用你学到的 Angular Ivy
    功能构建真实世界应用程序* 中实现一个实际应用的功能。
- en: In the next section, you will learn about component testing harnesses, an innovative
    API for testing components, and authoring testing APIs for components exposed
    in library packages.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解组件测试 Harness，这是一个用于测试组件的创新 API，以及为在库包中公开的组件编写测试 API。
- en: Testing as a user with component harnesses
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件 Harness 进行用户测试
- en: The Angular CDK's API for authoring and using component testing harnesses is
    a fresh approach with the test-as-a-user philosophy in mind. Each component or
    related set of components can have a component harness for tests. A component
    harness is a testing API for interacting with those components that can be used
    in unit, integration, and end-to-end tests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK 的用于编写和使用组件测试 Harness 的 API，是一种以“测试即用户”哲学为出发点的新方法。每个组件或相关组件集都可以有一个用于测试的组件
    Harness。组件 Harness 是一个用于与这些组件交互的测试 API，可用于单元测试、集成测试和端到端测试。
- en: Component testing harnesses internally rely only on a single selector for the
    component they wrap. Library authors can publish component harnesses for their
    Angular components. In this way, their consumers' tests, which depend on the library's
    components, will not have dependencies on the DOM structure except for that one
    selector, which the library authors are able to change if needed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试 Harness 内部仅依赖于它们所包装组件的单个选择器。库作者可以为他们的 Angular 组件发布组件 Harness。这样，他们的消费者测试（这些测试依赖于库的组件）除了那个选择器之外，不会对
    DOM 结构有依赖，而库作者如果需要可以更改该选择器。
- en: This is exactly what the Angular Components team do for Angular CDK and Angular
    Material. They release and maintain component harnesses for all their Angular
    components.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 Angular 组件团队为 Angular CDK 和 Angular Material 所做的事情。他们发布并维护所有 Angular 组件的组件
    Harness。
- en: Harness environments and harness loaders
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Harness 环境和 Harness 加载器
- en: A harness environment represents the context tests using component harnesses
    are run in. For unit and integration tests using test runners such as Karma, Jasmine,
    or Jest, we use `TestbedHarnessEnvironment`, which is bundled with the Angular
    CDK. For Protractor end-to-end tests, we use `ProtractorHarnessEnvironment`, which
    is also released as part of the Angular CDK.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Harness 环境代表使用组件 Harness 运行的测试上下文。对于使用 Karma、Jasmine 或 Jest 等测试运行器的单元和集成测试，我们使用
    `TestbedHarnessEnvironment`，它是 Angular CDK 的一部分。对于 Protractor 端到端测试，我们使用 `ProtractorHarnessEnvironment`，它也作为
    Angular CDK 的一部分发布。
- en: Important Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Protractor support is either deprecated or removed, depending on your Angular
    version.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Angular 版本的不同，Protractor 支持可能已被弃用或移除。
- en: If you want to use component harnesses with other end-to-end testing frameworks,
    you will have to extend the `HarnessEnvironment` base class and implement the
    `TestElement` interface to work in a different testing environment. Of course,
    first make sure to look for existing solutions in the Angular ecosystem.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要与其他端到端测试框架一起使用组件 Harness，你必须扩展 `HarnessEnvironment` 基类并实现 `TestElement`
    接口，以便在不同的测试环境中工作。当然，首先确保在 Angular 生态系统中寻找现有的解决方案。
- en: Only one harness environment can be active at any time. We use the harness environment
    to create a harness loader. A harness loader has the context of a certain DOM
    element and is used to query for and create component harnesses based on selectors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候只能有一个 Harness 环境处于活动状态。我们使用 Harness 环境来创建 Harness 加载器。一个 Harness 加载器具有特定
    DOM 元素的上下文，并用于根据选择器查询和创建组件 Harness。
- en: We will walk through simple code examples featuring harness environments and
    harness loaders after discussing the API of component harnesses that are distributed
    as part of Angular Material.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完作为 Angular Material 部分发布的组件 Harness 的 API 之后，我们将通过一些简单的代码示例来介绍 Harness 环境和
    Harness 加载器的使用。
- en: Component harnesses
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件 Harness
- en: A component harness can technically represent any DOM element and a set of user
    interactions and traits.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，组件 Harness 可以代表任何 DOM 元素以及一组用户交互和特性。
- en: To get the feel for a component harness, let's first look at the testing harness
    for the Angular Material Button component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受组件 Harness 的使用，让我们首先看看 Angular Material Button 组件的测试 Harness。
- en: 'The following is the API of `MatButtonHarness`, which is not inherited from
    the common component harness base classes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `MatButtonHarness` 的 API，它不是从公共组件 Harness 基类继承的：
- en: '`blur(): Promise<void>;`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur(): Promise<void>;`'
- en: '`click(relativeX: number, relativeY: number): Promise<void>;`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click(relativeX: number, relativeY: number): Promise<void>;`'
- en: '`click(''center''): Promise<void>;`'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`click(''center''): Promise<void>;`'
- en: '`click(): Promise<void>;`'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`click(): Promise<void>;`'
- en: '`focus(): Promise<void>;`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus(): Promise<void>;`'
- en: '`getText(): Promise<string>;`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getText(): Promise<string>;`'
- en: '`isDisabled(): Promise<boolean>;`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDisabled(): Promise<boolean>;`'
- en: '`isFocused(): Promise<boolean>;`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFocused(): Promise<boolean>;`'
- en: It has a few other methods that it inherits from an Angular CDK base class,
    but we will not discuss those for now.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它还继承自Angular CDK基类的一些其他方法，但我们现在不会讨论这些。
- en: I trust that you can guess what the methods do, based on their names, parameters,
    and return values. Notice that they are all asynchronous, that is, they all return
    a `Promise`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您可以根据它们的名字、参数和返回值猜出这些方法的功能。请注意，它们都是异步的，也就是说，它们都返回一个`Promise`。
- en: Every method except `getText` represents a user interaction. The `getText` method
    reads content from the DOM, which is displayed to the user, the text of the button
    to be precise.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`getText`方法之外，每个方法都代表用户交互。`getText`方法从DOM中读取内容，这是显示给用户的，即按钮的文本。
- en: Next, let's explore the API of the testing harness for the Angular Material
    Select component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索Angular Material Select组件测试 harness 的 API。
- en: 'The following is the API that is specific to `MatSelectHarness`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与`MatSelectHarness`特定的API：
- en: '`blur(): Promise<void>;`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur(): Promise<void>;`'
- en: '`clickOptions(filter?: OptionFilters): Promise<void>;`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clickOptions(filter?: OptionFilters): Promise<void>;`'
- en: Pick the drop-down option(s) matching the specified filter. For multi-option
    selects, multiple options can be picked. For single-option selects, the first
    matching option is picked.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择与指定过滤器匹配的下拉选项（复选）。对于多选项选择，可以选择多个选项。对于单选项选择，选择第一个匹配的选项。
- en: '`close(): Promise<void>;`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close(): Promise<void>;`'
- en: Closes the drop-down panel.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关闭下拉面板。
- en: '`focus(): Promise<void>;`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus(): Promise<void>;`'
- en: '`getOptionGroups(filter?: OptionGroupFilters): Promise<OptionGroup[]>;`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOptionGroups(filter?: OptionGroupFilters): Promise<OptionGroup[]>;`'
- en: Read drop-down option groups matching the specified filter.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 读取与指定过滤器匹配的下拉选项组。
- en: '`getOptions(filter?: OptionFilters): Promise<Option[]>;`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOptions(filter?: OptionFilters): Promise<Option[]>;`'
- en: Read drop-down options matching the specified filter.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 读取与指定过滤器匹配的下拉选项。
- en: '`getValueText(): Promise<string>;`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getValueText(): Promise<string>;`'
- en: Read the value of the chosen drop-down option.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 读取所选下拉选项的值。
- en: '`isDisabled(): Promise<boolean>;`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDisabled(): Promise<boolean>;`'
- en: '`isEmpty(): Promise<boolean>;`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty(): Promise<boolean>;`'
- en: Resolves `false` if no value has been picked. Resolves `true` if a value has
    been picked.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有选择任何值，则解析为`false`。如果已选择值，则解析为`true`。
- en: '`isFocused(): Promise<boolean>;`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFocused(): Promise<boolean>;`'
- en: '`isMultiple(): Promise<boolean>;`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isMultiple(): Promise<boolean>;`'
- en: Resolves `true` if the harness wraps a multi-option select component. Resolves
    `false` if it wraps a single-option select component.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 harness 包裹了一个多选项选择组件，则解析为`true`。如果它包裹了一个单选项选择组件，则解析为`false`。
- en: '`isOpen(): Promise<boolean>;`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isOpen(): Promise<boolean>;'
- en: '`isRequired(): Promise<boolean>;`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRequired(): Promise<boolean>;`'
- en: '`isValid(): Promise<boolean>;`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isValid(): Promise<boolean>;`'
- en: '`open(): Promise<void>;`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open(): Promise<void>;`'
- en: These methods correspond to our expectations about the behavior and information
    represented by a drop-down picker such as the Angular Material **Select** component.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法对应于我们对下拉选择器（如Angular Material **Select**组件）的行为和信息表示的预期。
- en: Now that we have discussed the most important concepts of a component harness
    and seen a few component harness APIs, it is time to look at a test case that
    combines these concepts.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了组件 harness 的最重要的概念并看到了一些组件 harness API，是时候看看一个结合这些概念的测试用例了。
- en: 'The following is an example of a test for an online clothing store. You will
    have to imagine the implementation of the `ShirtComponent` and collaborating services.
    In fact, this is what the test-as-a-user approach is all about. It is component-
    and implementation-agnostic:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在线服装店测试的示例。您将不得不想象`ShirtComponent`和协作服务的实现。事实上，这正是测试即用户方法的核心所在。它是组件和实现无关的：
- en: 'First, we import the necessary Angular packages:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入必要的Angular包：
- en: '[PRE16]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we import the `ShirtComponent` component, the collaborating `OrderService`,
    and the `OrderSpyService` class to replace it:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们导入`ShirtComponent`组件、协作的`OrderService`和`OrderSpyService`类来替换它：
- en: '[PRE17]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we can implement test cases, we configure the Angular testing module
    by setting up the necessary declarables and replacing `OrderService` with a spy
    service for testing purposes:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以实现测试用例之前，我们通过设置必要的声明式配置和将 `OrderService` 替换为用于测试的间谍服务来配置 Angular 测试模块：
- en: '[PRE18]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We use the component fixture from the previous step to create a harness loader
    for unit tests:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用前一步骤中的组件固定工具来创建单元测试的 harness loader：
- en: '[PRE19]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we store the order spy service in the shared `orderSpy` variable:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将订单间谍服务存储在共享的 `orderSpy` 变量中：
- en: '[PRE20]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we load the component harness for the shirt size picker, which is implemented
    using an Angular Material Select component as seen in this step:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们加载了 shirt size picker 的组件 harness，该 harness 是通过 Angular Material Select
    组件实现的，如本步骤所示：
- en: '[PRE21]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For this test case, we also have to load a component harness for the **purchase**
    button, which is implemented using the Angular Material Button component:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个测试用例，我们还需要加载一个 **购买** 按钮的组件 harness，该按钮是通过 Angular Material Button 组件实现的：
- en: '[PRE22]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we perform a sale as the user by picking a `Large` shirt and clicking
    the **purchase** button:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们作为用户执行一次销售，选择 `Large` 衣服尺寸并点击 **购买** 按钮：
- en: '[PRE23]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we assert that the order service spy has been called as expected:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们断言订单服务间谍已被按预期调用：
- en: '[PRE24]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We see that the test is relatively straightforward because of it using Angular
    Material's component harnesses. First, the *large* shirt size is picked, then
    the one-click **purchase** button is clicked, and we expect our order service
    spy to have been called with an order.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，由于使用了 Angular Material 的组件 harness，测试相对简单。首先，选择了 *大号* 衣服尺寸，然后点击了一键 **购买**
    按钮，我们期望我们的订单服务间谍已被调用并带有订单。
- en: Notice how we start out by configuring the Angular testing module as usual in
    a component test. After creating the component fixture, we use it to create a
    harness loader. The harness loader is then used to query for component harnesses
    for Angular Material Select and Button components. A filter is passed to make
    sure we interact with the correct button.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何在组件测试中像往常一样配置 Angular 测试模块的。在创建组件固定工具后，我们用它来创建一个 harness loader。然后，harness
    loader 被用来查询 Angular Material Select 和 Button 组件的组件 harness。传递一个过滤器以确保我们与正确的按钮进行交互。
- en: We use the component harnesses instead of interacting with component instances
    or passing selectors to DOM queries. Our test is decoupled from structural DOM
    changes and implementation details of Angular Material's components.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用组件 harness 而不是与组件实例交互或传递选择器到 DOM 查询。我们的测试与结构 DOM 变化和 Angular Material 组件的实现细节解耦。
- en: Now that we have explored the most important concepts of component harnesses,
    you are ready to implement your own and use them to test as a user in *Part 2,
    Build a Real-World Application with the Angular Ivy Features You Learned*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经探讨了组件 harness 的最重要的概念，你准备好实现自己的 harness 并使用它们在 *第 2 部分，使用你学到的 Angular
    Ivy 功能构建真实世界应用程序* 中作为用户进行测试了。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the APIs of the Angular YouTube Player, the
    Google Maps Angular components, the Angular CDK's Clipboard API, as well as the
    Angular CDK's component harnesses and how they are used by Angular Material, which
    we in turn can use in our applications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Angular YouTube Player 的 API、Google Maps Angular 组件、Angular CDK 的
    Clipboard API，以及 Angular CDK 的组件 harness 以及它们是如何被 Angular Material 使用的，反过来我们也可以在我们的应用程序中使用。
- en: The YouTube Player component is an Angular-specific wrapper around the embedded
    YouTube Player. We learned how to initialize it and explored its API in detail.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: YouTube Player 组件是围绕嵌入的 YouTube Player 的 Angular 特定包装器。我们学习了如何初始化它并详细探讨了其 API。
- en: Many official Angular component wrappers are available to create and interact
    with the rich API of Google Maps. We learned about the `GoogleMap`, `MapMarker`,
    `MapMarkerClusterer`, and `MapInfoWindow` components, which are used for common
    **Geographic Information System** (**GIS**) use cases.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 许多官方 Angular 组件包装器可用于创建和交互 Google Maps 的丰富 API。我们学习了 `GoogleMap`、`MapMarker`、`MapMarkerClusterer`
    和 `MapInfoWindow` 组件，它们用于常见的 **地理信息系统** (**GIS**) 用例。
- en: The Angular CDK's Clipboard API is a cross-browser and cross-platform compatible
    API for interacting with the native clipboard. We learned about the `CdkCopyToClipboard`
    directive, the `Clipboard` service, and the `PendingCopy` class.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK 的 Clipboard API 是一个跨浏览器和跨平台的 API，用于与原生剪贴板交互。我们学习了 `CdkCopyToClipboard`
    指令、`Clipboard` 服务和 `PendingCopy` 类。
- en: Finally, we discussed the main concepts of Angular component harnesses introduced
    by the Angular CDK. We saw examples of component harness APIs exposed by Angular
    Material and how we can use them to test our own components without relying on
    implementation details or DOM structures, which might change in a future version
    of the package.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了Angular CDK引入的Angular组件工具包的主要概念。我们看到了Angular Material暴露的组件工具包API的示例，以及我们如何使用它们来测试自己的组件，而无需依赖于实现细节或DOM结构，这些可能在包的未来版本中发生变化。
- en: With all these exciting new features and APIs fresh in our minds, let's move
    on to *Part 2, Build a Real-World Application with the Angular Ivy Features You
    Learned*, in which we add new functionality to an existing Angular application.
    Surely, this knowledge will come in handy.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记所有这些令人兴奋的新特性和API之后，让我们继续进入*第二部分，使用你学到的Angular Ivy特性构建一个真实世界的应用程序*，其中我们将向现有的Angular应用程序添加新功能。当然，这些知识将会非常有用。
- en: '[*Chapter 5*](B16295_05_ePub_RK.xhtml#_idTextAnchor075), *Using CSS Custom
    Properties,* starts off *Part 2, Build a Real-World Application with the Angular
    Ivy Features You Learned* by combining CSS Custom Properties and Angular to add
    a theme picker to the Angular Academy application.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第五章*](B16295_05_ePub_RK.xhtml#_idTextAnchor075)，*使用CSS自定义属性*，通过结合CSS自定义属性和Angular，在*第二部分，使用你学到的Angular
    Ivy特性构建一个真实世界的应用程序*中开始，为Angular Academy应用程序添加一个主题选择器。'
