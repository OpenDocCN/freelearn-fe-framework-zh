<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Selection - Make Selections from Choices</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, you'll learn about the following:</p>
<ul>
<li>Abstracting checkbox groups</li>
<li>Customizing checkbox items</li>
<li>Abstracting radio button groups</li>
<li>Using radio button types</li>
<li>Replacing checkboxes with switches</li>
<li>Controlling selects with state</li>
<li>Selecting multiple items</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>Any application that includes user interactions involves user making selections. This could range from a simple on/off switch to selection with several items that allow more than one item to be selected. Material-UI has different selection components that best fit a given user scenario. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstracting checkbox groups</h1>
                </header>
            
            <article>
                
<p>Checkboxes often provide the user with a group of related options that can be checked or unchecked. The Material-UI <kbd>Checkbox</kbd> component provides the base functionality, but you might want something a little more high level that can be reused throughout your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's create an abstraction for groups of checkbox options. Here's the code for a <kbd>CheckboxGroup</kbd> component:</p>
<pre>import React, { useState } from 'react';<br/><br/>import FormLabel from '@material-ui/core/FormLabel';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import FormGroup from '@material-ui/core/FormGroup';<br/>import FormControlLabel from '@material-ui/core/FormControlLabel';<br/>import FormHelperText from '@material-ui/core/FormHelperText';<br/>import Checkbox from '@material-ui/core/Checkbox';<br/><br/>const CheckboxGroup = ({ values, label, onChange }) =&gt; (<br/>  &lt;FormControl component="fieldset"&gt;<br/>    &lt;FormLabel component="legend"&gt;{label}&lt;/FormLabel&gt;<br/>    &lt;FormGroup&gt;<br/>      {values.map((value, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={<br/>            &lt;Checkbox<br/>              checked={value.checked}<br/>              onChange={onChange(index)}<br/>            /&gt;<br/>          }<br/>          label={value.label}<br/>        /&gt;<br/>      ))}<br/>    &lt;/FormGroup&gt;<br/>  &lt;/FormControl&gt;<br/>);<br/><br/>export default function AbstractingCheckboxGroups() {<br/>  const [values, setValues] = useState([<br/>    { label: 'First', checked: false },<br/>    { label: 'Second', checked: false },<br/>    { label: 'Third', checked: false }<br/>  ]);<br/><br/>  const onChange = index =&gt; ({ target: { checked } }) =&gt; {<br/>    const newValues = [...values];<br/>    const value = values[index];<br/><br/>    newValues[index] = { ...value, checked };<br/><br/>    setValues(newValues);<br/>  };<br/><br/>  return (<br/>    &lt;CheckboxGroup<br/>      label="Choices"<br/>      values={values}<br/>      onChange={onChange}<br/>    /&gt;<br/>  );<br/>}</pre>
<p>When you first load the screen, here's what you'll see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e019328e-fb1b-4907-b67e-b6c6b21d657f.png" style="width:8.25em;height:10.67em;"/></p>
<p>Here's what it looks like when you select the first two choices:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd3e84d4-3786-4698-aae3-f15afacd21b2.png" style="width:8.42em;height:11.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's take a closer look at the <kbd>CheckboxGroup</kbd> component:</p>
<pre>const CheckboxGroup = ({ values, label, onChange }) =&gt; (<br/>  &lt;FormControl component="fieldset"&gt;<br/>    &lt;FormLabel component="legend"&gt;{label}&lt;/FormLabel&gt;<br/>    &lt;FormGroup&gt;<br/>      {values.map((value, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={<br/>            &lt;Checkbox<br/>              checked={value.checked}<br/>              onChange={onChange(index)}<br/>            /&gt;<br/>          }<br/>          label={value.label}<br/>        /&gt;<br/>      ))}<br/>    &lt;/FormGroup&gt;<br/>  &lt;/FormControl&gt;<br/>);</pre>
<p>This is the abstraction that allows you to render groups of checkbox options on the various screens throughout your app. There are several Material-UI components involved with rendering a group of checkboxes—<kbd>CheckboxGroup</kbd> takes care of this for you so that you just need to worry about passing it an array of <kbd>values</kbd>, <kbd>label</kbd>, and an <kbd>onChange</kbd> handler.</p>
<p>Next, let's look at how <kbd>CheckboxGroup</kbd> is rendered by your application component:</p>
<pre>&lt;CheckboxGroup<br/>  label="Choices"<br/>  values={values}<br/>  onChange={onChange}<br/>/&gt;</pre>
<p>You only need to worry about structuring the values array and passing it to the <kbd>CheckboxGroup</kbd> component whenever your application needs to render a group of related checkbox options. Lastly, let's look at <kbd>state</kbd> and the <kbd>onChange()</kbd> handler used to toggle the checked state of the value:</p>
<pre>const [values, setValues] = useState([<br/>  { label: 'First', checked: false },<br/>  { label: 'Second', checked: false },<br/>  { label: 'Third', checked: false }<br/>]);<br/><br/>const onChange = index =&gt; ({ target: { checked } }) =&gt; {<br/>  const newValues = [...values];<br/>  const value = values[index];<br/><br/>  newValues[index] = { ...value, checked };<br/><br/>  setValues(newValues);<br/>};</pre>
<p class="mce-root"/>
<p>The <kbd>checked</kbd> property is changed based on the index argument and the <kbd>target.checked</kbd> value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Let's add a <kbd>List</kbd> component to this example so that you can better visualize the state changes that happen when checkboxes are checked/unchecked. Here's the additional Material-UI components that you'll need to import:</p>
<pre>import List from '@material-ui/core/List';<br/>import ListItem from '@material-ui/core/ListItem';<br/>import ListItemIcon from '@material-ui/core/ListItemIcon';<br/>import ListItemText from '@material-ui/core/ListItemText';<br/>import Typography from '@material-ui/core/Typography';</pre>
<p>The idea is to have this list render the labels of checked items. Let's render this list right below the <kbd>CheckboxGroup</kbd> component:</p>
<pre>&lt;Fragment&gt;<br/>  &lt;CheckboxGroup<br/>    label="Choices"<br/>    values={values}<br/>    onChange={onChange}<br/>  /&gt;<br/>  &lt;Typography variant="h6"&gt;Selection&lt;/Typography&gt;<br/>  &lt;List&gt;<br/>    {values<br/>      .filter(value =&gt; value.checked)<br/>      .map((value, index) =&gt; (<br/>        &lt;ListItem key={index}&gt;<br/>          &lt;ListItemText&gt;{value.label}&lt;/ListItemText&gt;<br/>        &lt;/ListItem&gt;<br/>      ))}<br/>  &lt;/List&gt;<br/>&lt;/Fragment&gt;</pre>
<p>The <kbd>filter()</kbd> call on <kbd>values</kbd> will only include values where the <kbd>checked</kbd> property is <kbd>true</kbd>. When the screen first loads, you'll see an empty list because nothing is checked by default:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c33f75d5-2efb-4776-862d-312cb6b183a8.png" style="width:8.42em;height:13.75em;"/></p>
<p>As you start making selections, you'll see the selection list change as a reflection of the application state changes:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/62fab76a-0a5a-4deb-8d8a-7a475bb8f7ed.png" style="width:7.92em;height:18.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Selection demos: <a href="https://material-ui.com/demos/selection-controls/">https://material-ui.com/demos/selection-controls/</a></li>
<li><kbd>Checkbox</kbd> API documentation: <a href="https://material-ui.com/api/checkbox/">https://material-ui.com/api/checkbox/</a></li>
<li><kbd>FormHelperText</kbd> API documentation: <a href="https://material-ui.com/api/form-helper-text/">https://material-ui.com/api/form-helper-text/</a></li>
<li><kbd>FormControlLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-control-label/">https://material-ui.com/api/form-control-label/</a></li>
<li><kbd>FormGroup</kbd> API documentation: <a href="https://material-ui.com/api/form-group/">https://material-ui.com/api/form-group/</a></li>
<li><kbd>FormControl</kbd> API documentation: <a href="https://material-ui.com/api/form-control/">https://material-ui.com/api/form-control/</a></li>
<li><kbd>FormLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-label/">https://material-ui.com/api/form-label/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing checkbox items</h1>
                </header>
            
            <article>
                
<p>The default appearance of Material-UI <kbd>Checkbox</kbd> components tries to resemble the native browser checkbox input element. You can change the icon that's used for both the checked and the unchecked state of the component. Even after you change the icons used by <kbd>Checkbox</kbd>, any color changes are still honored.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here's some code that imports several Material-UI icons and uses them to configure the icons used by the <kbd>Checkbox</kbd> components:</p>
<pre>import React, { useState, useEffect } from 'react';<br/><br/>import FormGroup from '@material-ui/core/FormGroup';<br/>import FormControlLabel from '@material-ui/core/FormControlLabel';<br/>import Checkbox from '@material-ui/core/Checkbox';<br/><br/>import AccountBalance from '@material-ui/icons/AccountBalance';<br/>import AccountBalanceOutlined from '@material-ui/icons/AccountBalanceOutlined';<br/>import Backup from '@material-ui/icons/Backup';<br/>import BackupOutlined from '@material-ui/icons/BackupOutlined';<br/>import Build from '@material-ui/icons/Build';<br/>import BuildOutlined from '@material-ui/icons/BuildOutlined';<br/><br/>const initialItems = [<br/>  {<br/>    name: 'AccountBalance',<br/>    Icon: AccountBalanceOutlined,<br/>    CheckedIcon: AccountBalance<br/>  },<br/>  {<br/>    name: 'Backup',<br/>    Icon: BackupOutlined,<br/>    CheckedIcon: Backup<br/>  },<br/>  {<br/>    name: 'Build',<br/>    Icon: BuildOutlined,<br/>    CheckedIcon: Build<br/>  }<br/>];<br/><br/>export default function CustomizingCheckboxItems() {<br/>  const [items, setItems] = useState({});<br/><br/>  useEffect(() =&gt; {<br/>    setItems(<br/>      initialItems.reduce(<br/>        (state, item) =&gt; ({ ...state, [item.name]: false }),<br/>        {}<br/>      )<br/>    );<br/>  }, []);<br/><br/>  const onChange = e =&gt; {<br/>    setItems({ [e.target.name]: e.target.checked });<br/>  };<br/><br/>  return (<br/>    &lt;FormGroup&gt;<br/>      {initialItems.map(({ name, Icon, CheckedIcon }, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={<br/>            &lt;Checkbox<br/>              checked={items[name]}<br/>              onChange={onChange}<br/>              inputProps={{ name }}<br/>              icon={&lt;Icon fontSize="small" /&gt;}<br/>              checkedIcon={&lt;CheckedIcon fontSize="small" /&gt;}<br/>            /&gt;<br/>          }<br/>          label={name}<br/>        /&gt;<br/>      ))}<br/>    &lt;/FormGroup&gt;<br/>  );<br/>}</pre>
<p class="mce-root"/>
<p>Here's what the checkboxes look like when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4694fa3e-cc13-405c-bf70-25c90b627ee9.png" style="width:11.00em;height:9.42em;"/></p>
<p>These checkboxes are unchecked. Here's what they look like when they're checked:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/30e1f3be-b683-45e2-8d41-b566ea64ba0e.png" style="width:11.33em;height:9.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's walk through what's happening here. The <kbd>initialItems</kbd> array is the starting point for the construction of the checkboxes:</p>
<pre>const initialItems = [<br/>  {<br/>    name: 'AccountBalance',<br/>    Icon: AccountBalanceOutlined,<br/>    CheckedIcon: AccountBalance<br/>  },<br/>  {<br/>    name: 'Backup',<br/>    Icon: BackupOutlined,<br/>    CheckedIcon: Backup<br/>  },<br/>  {<br/>    name: 'Build',<br/>    Icon: BuildOutlined,<br/>    CheckedIcon: Build<br/>  }<br/>];</pre>
<p class="mce-root"/>
<p>Each item has a <kbd>name</kbd> component to identify the checkbox, as well as checked/unchecked <kbd>Icon</kbd> components. Next, let's take a look at how the state of the <kbd>CustomizingCheckboxItems</kbd> component is initialized:</p>
<pre>const [items, setItems] = useState({});<br/><br/>useEffect(() =&gt; {<br/>  setItems(<br/>    initialItems.reduce(<br/>      (state, item) =&gt; ({ ...state, [item.name]: false }),<br/>      {}<br/>    )<br/>  );<br/>}, []);</pre>
<p>The state is initialized to an object by reducing the <kbd>initialItems</kbd> array. For each item in the array, the state of this component will have a property that's initialized to false. The name of the property is based on the <kbd>name</kbd> property of the item. So, for example, the component state will look something like this after it's reduced:</p>
<pre>{<br/>  AccountBalance: false,<br/>  Backup: false,<br/>  Build: false<br/>}</pre>
<p>These properties are used to store the checked state of each checkbox. Next, let's look at how each <kbd>Checkbox</kbd> component is rendered based on the <kbd>initialItems</kbd> array:</p>
<pre>&lt;FormGroup&gt;<br/>  {initialItems.map(({ name, Icon, CheckedIcon }, index) =&gt; (<br/>    &lt;FormControlLabel<br/>      key={index}<br/>      control={<br/>        &lt;Checkbox<br/>          checked={items[name]}<br/>          onChange={onChange}<br/>          inputProps={{ name }}<br/>          icon={&lt;Icon fontSize="small" /&gt;}<br/>          checkedIcon={&lt;CheckedIcon fontSize="small" /&gt;}<br/>        /&gt;<br/>      }<br/>      label={name}<br/>    /&gt;<br/>  ))}<br/>&lt;/FormGroup&gt;</pre>
<p class="mce-root"/>
<p>The key properties that customize each of the checkboxes are <kbd>icon</kbd> and <kbd>checkedIcon</kbd>. These properties use the <kbd>Icon</kbd> and <kbd>CheckIcon</kbd> properties from the items array, respectively.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Because the icons that you're using to customize the <kbd>Checkbox</kbd> component are Material-UI components, you can change the color of the checkbox and have it work the same as would without custom icons. For example, you could set the color of the checkboxes in this example to default:</p>
<pre>&lt;Checkbox<br/>  color="default"<br/>  checked={items[name]}<br/>  onChange={onChange}<br/>  inputProps={{ name }}<br/>  icon={&lt;Icon fontSize="small" /&gt;}<br/>  checkedIcon={&lt;CheckedIcon fontSize="small" /&gt;}<br/>/&gt;</pre>
<p>Here's how this would look with every checkbox checked:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e7f52c0f-6241-434d-bd06-d7abab6bcc94.png" style="width:12.08em;height:9.83em;"/></p>
<p>With the color set to the default, the color doesn't change when a checkbox goes from unchecked to checked. This doesn't matter much, though, because the icons go from an outline theme to a filled theme. Just the shape change is enough to indicate that the item is checked.</p>
<p>Let's try it out with <kbd>primary</kbd>, just for fun:</p>
<pre>&lt;Checkbox<br/>  color="primary"<br/>  checked={items[name]}<br/>  onChange={onChange}<br/>  inputProps={{ name }}<br/>  icon={&lt;Icon fontSize="small" /&gt;}<br/>  checkedIcon={&lt;CheckedIcon fontSize="small" /&gt;}<br/>/&gt;</pre>
<p>Here's how this looks with everything checked:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6fd53663-430e-45c2-9998-adb43440ee40.png" style="width:11.92em;height:9.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Selection</kbd> demos: <a href="https://material-ui.com/demos/selection-controls/">https://material-ui.com/demos/selection-controls/</a></li>
<li><kbd>Checkbox</kbd> API documentation: <a href="https://material-ui.com/api/checkbox/">https://material-ui.com/api/checkbox/</a></li>
<li><kbd>FormControlLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-control-label/">https://material-ui.com/api/form-control-label/</a></li>
<li><kbd>FormGroup</kbd> API documentation: <a href="https://material-ui.com/api/form-group/">https://material-ui.com/api/form-group/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstracting radio button groups</h1>
                </header>
            
            <article>
                
<p><strong>Radio button groups</strong> are similar to checkbox groups. The key difference is that radios are used when only one value should be selected. Also, like checkbox groups, radio button groups require several Material-UI components that can be encapsulated and reused throughout an application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Here's some code that captures all of the pieces required to put together a radio button group into a single component:</p>
<pre>import React, { useState } from 'react';<br/><br/>import Radio from '@material-ui/core/Radio';<br/>import { default as MaterialRadioGroup } from '@material-ui/core/RadioGroup';<br/>import FormControlLabel from '@material-ui/core/FormControlLabel';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import FormLabel from '@material-ui/core/FormLabel';<br/><br/>const options = [<br/>  { label: 'First', value: 'first' },<br/>  { label: 'Second', value: 'second' },<br/>  { label: 'Third', value: 'third' }<br/>];<br/><br/>const RadioGroup = ({ value, options, name, label, onChange }) =&gt; (<br/>  &lt;FormControl component="fieldset"&gt;<br/>    &lt;FormLabel component="legend"&gt;{label}&lt;/FormLabel&gt;<br/>    &lt;MaterialRadioGroup<br/>      name={name}<br/>      value={value}<br/>      onChange={onChange}<br/>      disabled<br/>    &gt;<br/>      {options.map((option, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={&lt;Radio /&gt;}<br/>          value={option.value}<br/>          label={option.label}<br/>        /&gt;<br/>      ))}<br/>    &lt;/MaterialRadioGroup&gt;<br/>  &lt;/FormControl&gt;<br/>);<br/><br/>export default function AbstractingRadioButtonGroups() {<br/>  const [value, setValue] = useState('first');<br/><br/>  const onChange = e =&gt; {<br/>    setValue(e.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;RadioGroup<br/>      value={value}<br/>      options={options}<br/>      name="radio1"<br/>      label="Pick One"<br/>      onChange={onChange}<br/>    /&gt;<br/>  );<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's what you'll see when you first load the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6eb97438-c896-4b6e-ad43-554dfcebf63a.png" style="width:7.33em;height:9.50em;"/></p>
<p>Here's what the component looks like if you were to click on the third option:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/694b1a38-364d-473c-9c8c-c78806312760.png" style="width:7.42em;height:10.33em;"/></p>
<p>Because these options all belong to the same radio group, only one option can be checked at a time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's take a closer look at the <kbd>RadioGroup</kbd> component in this example:</p>
<pre>const RadioGroup = ({ value, options, name, label, onChange }) =&gt; (<br/>  &lt;FormControl component="fieldset"&gt;<br/>    &lt;FormLabel component="legend"&gt;{label}&lt;/FormLabel&gt;<br/>    &lt;MaterialRadioGroup name={name} value={value} onChange={onChange}&gt;<br/>      {options.map((option, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={&lt;Radio /&gt;}<br/>          value={option.value}<br/>          label={option.label}<br/>        /&gt;<br/>      ))}<br/>    &lt;/MaterialRadioGroup&gt;<br/>  &lt;/FormControl&gt;<br/>);</pre>
<p>The <kbd>options</kbd> property should have an array value, which is then mapped to the <kbd>FormControlLabel</kbd> components. The <kbd>control</kbd> property uses the <kbd>Radio</kbd> component to render each radio control. Unlike checkbox groups, the <kbd>onChange</kbd> property is on the <kbd>MaterialRadioGroup</kbd> component instead of on each individual <kbd>Radio</kbd>. This is because there's only ever a single active value, which is managed by <kbd>MaterialRadioGroup</kbd>.</p>
<div class="packt_infobox">The Material-UI <kbd>RadioGroup</kbd> component is imported with the <kbd>MaterialRadioGroup</kbd> alias because we're creating a component of the same name. This is fine, as long as you're clear about which packages own which components.</div>
<p>Next, let's see how the <kbd>RadioGroup</kbd> component is rendered:</p>
<pre>&lt;RadioGroup<br/>  value={value}<br/>  options={options}<br/>  name="radio1"<br/>  label="Pick One"<br/>  onChange={onChange}<br/>/&gt;</pre>
<p>The <kbd>name</kbd> property is what ties everything together. It's important that radio buttons that are part of the same group have the same name. This abstraction takes care of this for you by only requiring the name in one place. Here's what the <kbd>options</kbd> array looks like:</p>
<pre>const options = [<br/>  { label: 'First', value: 'first' },<br/>  { label: 'Second', value: 'second' },<br/>  { label: 'Third', value: 'third' }<br/>];</pre>
<p>The idea with radio groups is that they only ever have one value. The value properties in the <kbd>options</kbd> array are the allowed values—but only one is active. The last thing worth looking at with this example is the <kbd>onChange</kbd> handler and the state structure of the application component:</p>
<pre>const [value, setValue] = useState('first');<br/><br/>const onChange = e =&gt; {<br/>  setValue(e.target.value);<br/>};</pre>
<p>This is how the initial radio selection is set. When it changes, the value state is updated to the value of the selected radio.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can disable the entire radio button group by setting the <kbd>disabled</kbd> property on the <kbd>FormControl</kbd> component:</p>
<pre>&lt;FormControl component="fieldset" disabled&gt;<br/>  ...<br/>&lt;/FormControl&gt;</pre>
<p>When you disable the control, you can't interact with it at all. Here's what this looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ac2f3af5-43ae-434f-83c5-da027a70bba0.png" style="width:8.50em;height:11.00em;"/></p>
<p>In other scenarios, you will only want to disable one of the options. You can support this in the <kbd>RadioGroup</kbd> component by checking for a <kbd>disabled</kbd> property in the <kbd>options</kbd> array:</p>
<pre>&lt;FormControlLabel<br/>  key={index}<br/>  control={&lt;Radio disabled={option.disabled} /&gt;}<br/>  value={option.value}<br/>  label={option.label}<br/>/&gt;</pre>
<p>Here is how you would disable an option in the <kbd>options</kbd> array:</p>
<pre>const options = [<br/>  { label: 'First', value: 'first' },<br/>  { label: 'Second', value: 'second', disabled: true },<br/>  { label: 'Third', value: 'third' }<br/>];</pre>
<p class="mce-root"/>
<p>Here's how the radio group looks with the <span class="packt_screen">Second</span> option disabled:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/905790cf-1e91-4f7f-bd38-11fc9ad4165e.png" style="width:7.83em;height:9.92em;"/></p>
<p>While the <span class="packt_screen">Second</span> option is disabled, there's no way to activate it because the user cannot interact with it.</p>
<div class="packt_tip">Be careful about disabling the option that's active by default. There's no way for this to not cause confusion for the user. You can activate another option in the group, but then you can't activate the option that was active to begin with.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Selection</kbd> demos: <a href="https://material-ui.com/demos/selection-controls/">https://material-ui.com/demos/selection-controls/</a></li>
<li><kbd>Radio</kbd> API documentation: <a href="https://material-ui.com/api/radio/">https://material-ui.com/api/radio/</a></li>
<li><kbd>RadioGroup</kbd> API documentation: <a href="https://material-ui.com/api/radio-group/">https://material-ui.com/api/radio-group/</a></li>
<li><kbd>FormControlLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-control-label/">https://material-ui.com/api/form-control-label/</a></li>
<li><kbd>FormControl</kbd> API documentation: <a href="https://material-ui.com/api/form-control/">https://material-ui.com/api/form-control/</a></li>
<li><kbd>FormLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-label/">https://material-ui.com/api/form-label/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Radio button types</h1>
                </header>
            
            <article>
                
<p>There are a number of radio button aspects that you can customize to create your own type of radio button group. While the underlying principle of selecting a single value from several options doesn't change, you can make the radio button group design fit any application.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that, based on the layout of your screen, and in order to stay consistent with other screens in your app, you need to create a radio group with the following design traits:</p>
<ul>
<li>A single row is used to present options</li>
<li>There are icons and text for each option</li>
<li>The primary theme color is used for selected options</li>
</ul>
<p>Here's some code that does this:</p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import Radio from '@material-ui/core/Radio';<br/>import RadioGroup from '@material-ui/core/RadioGroup';<br/>import FormControlLabel from '@material-ui/core/FormControlLabel';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import FormLabel from '@material-ui/core/FormLabel';<br/><br/>import Car from '@material-ui/icons/DirectionsCar';<br/>import CarOutlined from '@material-ui/icons/DirectionsCarOutlined';<br/>import Bus from '@material-ui/icons/DirectionsBus';<br/>import BusOutlined from '@material-ui/icons/DirectionsBusOutlined';<br/>import Train from '@material-ui/icons/Train';<br/>import TrainOutlined from '@material-ui/icons/TrainOutlined';<br/><br/>export default function RadioButtonTypes() {<br/>  const [value, setValue] = useState('train');<br/><br/>  const onChange = e =&gt; {<br/>    setValue(e.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;FormControl component="fieldset"&gt;<br/>      &lt;FormLabel component="legend"&gt;Travel Mode&lt;/FormLabel&gt;<br/>      &lt;RadioGroup name="travel" value={value} onChange={onChange} row&gt;<br/>        &lt;FormControlLabel<br/>          value="car"<br/>          control={<br/>            &lt;Radio<br/>              color="primary"<br/>              icon={&lt;CarOutlined /&gt;}<br/>              checkedIcon={&lt;Car /&gt;}<br/>            /&gt;<br/>          }<br/>          label="Car"<br/>          labelPlacement="bottom"<br/>        /&gt;<br/>        &lt;FormControlLabel<br/>          value="bus"<br/>          control={<br/>            &lt;Radio<br/>              color="primary"<br/>              icon={&lt;BusOutlined /&gt;}<br/>              checkedIcon={&lt;Bus /&gt;}<br/>            /&gt;<br/>          }<br/>          label="Bus"<br/>          labelPlacement="bottom"<br/>        /&gt;<br/>        &lt;FormControlLabel<br/>          value="train"<br/>          control={<br/>            &lt;Radio<br/>              color="primary"<br/>              icon={&lt;TrainOutlined /&gt;}<br/>              checkedIcon={&lt;Train /&gt;}<br/>            /&gt;<br/>          }<br/>          label="Train"<br/>          labelPlacement="bottom"<br/>        /&gt;<br/>      &lt;/RadioGroup&gt;<br/>    &lt;/FormControl&gt;<br/>  );<br/>}</pre>
<p>Here's what the radio group looks like when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1952a618-c8f4-4ecb-8c2e-efa2c162d6f7.png" style="width:18.33em;height:7.75em;"/></p>
<p>You can change the default selection by clicking on any of the other icons or labels. The icon state is updated to reflect the change:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9ab9c12-7df6-49e1-8ed0-8405add19cbb.png" style="width:17.67em;height:7.33em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>It seems that we were able to meet the criteria set forth for the radio button group. Let's walk through the code to see how each requirement was met. First, the group is rendered horizontally with each radio button on the same row. This is done by passing the <kbd>row</kbd> property to the <kbd>RadioGroup</kbd> component:</p>
<pre>&lt;RadioGroup<br/>  name="travel"<br/>  value={value}<br/>  onChange={onChange}<br/>  row<br/>&gt;</pre>
<p>The label of each radio is displayed underneath each radio button because this works better with the row layout of the group. This is done by setting the <kbd>labelPlacement</kbd> property value of <kbd>FormControlLabel</kbd>. The radio color uses the primary color from the Material-UI theme when selected. It's also using custom icons for checked and unchecked states:</p>
<pre>&lt;Radio<br/>  color="primary"<br/>  icon={&lt;BusOutlined /&gt;}<br/>  checkedIcon={&lt;Bus /&gt;}<br/>/&gt;</pre>
<p>Both of these enhancements are handled by the <kbd>Radio</kbd> component.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Selection</kbd> demos:<a href="https://material-ui.com/demos/selection-controls/"> https://material-ui.com/demos/selection-controls/</a></li>
<li><kbd>Radio</kbd> API documentation: <a href="https://material-ui.com/api/radio/">https://material-ui.com/api/radio/</a></li>
<li><kbd>RadioGroup</kbd> API documentation: <a href="https://material-ui.com/api/radio-group/">https://material-ui.com/api/radio-group/</a></li>
<li><kbd>FormControlLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-control-label/">https://material-ui.com/api/form-control-label/</a></li>
<li><kbd>FormControl</kbd> API documentation: <a href="https://material-ui.com/api/form-control/">https://material-ui.com/api/form-control/</a></li>
<li><kbd>FormLabel</kbd> API documentation: <a href="https://material-ui.com/api/form-label/">https://material-ui.com/api/form-label/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replacing checkboxes with switches</h1>
                </header>
            
            <article>
                
<p>Material-UI has a control which is very similar to a checkbox, called a switch. The main visual distinction between the two components is that a switch has more emphasis on the toggling on/off action. In a mobile environment, users might feel more accustomed to the <kbd>Switch</kbd> component. In any other environment, you're probably best sticking with regular <kbd>Checkbox</kbd> components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that, instead of creating a component that abstracts a group of <kbd>Checkbox</kbd> components, you you want want to do the same thing with the <kbd>Switch</kbd> components. Here's the code:</p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import FormLabel from '@material-ui/core/FormLabel';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import FormGroup from '@material-ui/core/FormGroup';<br/>import FormControlLabel from '@material-ui/core/FormControlLabel';<br/>import FormHelperText from '@material-ui/core/FormHelperText';<br/>import Switch from '@material-ui/core/Switch';<br/><br/>const SwitchGroup = ({ values, label, onChange }) =&gt; (<br/>  &lt;FormControl component="fieldset"&gt;<br/>    &lt;FormLabel component="legend"&gt;{label}&lt;/FormLabel&gt;<br/>    &lt;FormGroup&gt;<br/>      {values.map((value, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={<br/>            &lt;Switch<br/>              checked={value.checked}<br/>              onChange={onChange(index)}<br/>            /&gt;<br/>          }<br/>          label={value.label}<br/>        /&gt;<br/>      ))}<br/>    &lt;/FormGroup&gt;<br/>  &lt;/FormControl&gt;<br/>);<br/><br/>export default function ReplacingCheckboxesWithSwitches() {<br/>  const [values, setValues] = useState([<br/>    { label: 'First', checked: false },<br/>    { label: 'Second', checked: false },<br/>    { label: 'Third', checked: false }<br/>  ]);<br/><br/>  const onChange = index =&gt; ({ target: { checked } }) =&gt; {<br/>    const newValues = [...values];<br/>    const value = values[index];<br/><br/>    newValues[index] = { ...value, checked };<br/>    setValues(newValues);<br/>  };<br/><br/>  return (<br/>    &lt;SwitchGroup<br/>      label="Choices"<br/>      values={values}<br/>      onChange={onChange}<br/>    /&gt;<br/>  );<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's what the switch group looks like when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8a9987eb-9c23-4ed2-944f-1c247d253394.png" style="width:6.92em;height:9.50em;"/></p>
<p>Here's what the switch group looks like with every switch turned on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f5ce315-7af3-4094-b189-e3fc546c6491.png" style="width:7.42em;height:9.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Anywhere that you can use a <kbd>Checkbox</kbd> component, you can also use a <kbd>Switch</kbd> component. This code was taken from the <em>Abstracting checkbox groups</em> section from earlier in this chapter. The <kbd>Checkbox</kbd> components were replaced with <kbd>Switch</kbd> components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Rather than having divergent code paths for handling <kbd>Checkbox</kbd> versus <kbd>Switch</kbd> components, you could enhance the <kbd>SwitchGroup</kbd> component to accept a <kbd>checkbox</kbd> Boolean property that, when <kbd>true</kbd>, uses <kbd>Checkbox</kbd> as the control instead of <kbd>Switch</kbd>. Here's what the new <kbd>SwitchGroup</kbd> looks like:</p>
<pre>const SwitchGroup = ({ values, label, onChange }) =&gt; (<br/>  &lt;FormControl component="fieldset"&gt;<br/>    &lt;FormLabel component="legend"&gt;{label}&lt;/FormLabel&gt;<br/>    &lt;FormGroup&gt;<br/>      {values.map((value, index) =&gt; (<br/>        &lt;FormControlLabel<br/>          key={index}<br/>          control={<br/>            &lt;Switch<br/>              checked={value.checked}<br/>              onChange={onChange(index)}<br/>            /&gt;<br/>          }<br/>          label={value.label}<br/>        /&gt;<br/>      ))}<br/>    &lt;/FormGroup&gt;<br/>  &lt;/FormControl&gt;<br/>);</pre>
<p>And here's an example that shows both versions of the control being rendered side by side:</p>
<pre>&lt;Fragment&gt;<br/>  &lt;SwitchGroup<br/>    label="Switch Choices"<br/>    values={values}<br/>    onChange={this.onChange}<br/>  /&gt;<br/>  &lt;SwitchGroup<br/>    label="Switch Choices"<br/>    values={values}<br/>    onChange={onChange}<br/>    checkbox<br/>  /&gt;<br/>&lt;/Fragment&gt;</pre>
<p>The second <kbd>SwitchGroup</kbd> component uses the <kbd>checkbox</kbd> property to render the <kbd>Checkbox</kbd> components instead of the <kbd>Switch</kbd> components. Here's what the result looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5928fd7-6726-4739-98b0-0cc282996c08.png" style="width:15.83em;height:13.08em;"/></p>
<p class="mce-root"/>
<p>Here's what you'll see if you select the first option in either the switch choices or the checkbox choices group:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f8f7080-57a8-4d2e-9fd6-d77c7fd52e7a.png" style="width:16.75em;height:13.67em;"/></p>
<p>They are both updated because both fields share the same application state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Selection</kbd> demos: <a href="https://material-ui.com/demos/selection-controls/">https://material-ui.com/demos/selection-controls/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling selects with state</h1>
                </header>
            
            <article>
                
<p>Some forms involve making selections from a list of values. This is kind of like choosing a radio button option from a radio button group. With the Material-UI <kbd>Select</kbd> component, you get something that looks more like a traditional HTML select element. Often, web application forms have several selects that depend on one another. In React/Material-UI applications, these selects are controlled through <span>the <kbd>state</kbd> component</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that your screen has two selects—a category select and a product select. Initially, only the category select is populated and enabled. The product select depends on the category select—once a category is selected, the product select is enabled and populated with the appropriate products. Here's the code to do this:</p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import InputLabel from '@material-ui/core/InputLabel';<br/>import MenuItem from '@material-ui/core/MenuItem';<br/>import FormHelperText from '@material-ui/core/FormHelperText';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import Select from '@material-ui/core/Select';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  control: { margin: theme.spacing(2), minWidth: 200 }<br/>}));<br/><br/>export default function ControllingSelectsWithState() {<br/>  const classes = useStyles();<br/><br/>  const [categories, setCategories] = useState([<br/>    { label: 'Category 1', id: 1 },<br/>    { label: 'Category 2', id: 2 },<br/>    { label: 'Category 3', id: 3 }<br/>  ]);<br/><br/>  const [products, setProducts] = useState([<br/>    { label: 'Product 1', id: 1, category: 1 },<br/>    { label: 'Product 2', id: 2, category: 1 },<br/>    { label: 'Product 3', id: 3, category: 1 },<br/>    { label: 'Product 4', id: 4, category: 2 },<br/>    { label: 'Product 5', id: 5, category: 2 },<br/>    { label: 'Product 6', id: 6, category: 2 },<br/>    { label: 'Product 7', id: 7, category: 3 },<br/>    { label: 'Product 8', id: 8, category: 3 },<br/>    { label: 'Product 9', id: 9, category: 3 }<br/>  ]);<br/><br/>  const setters = {<br/>    categories: setCategories,<br/>    products: setProducts<br/>  };<br/>  const collections = { categories, products };<br/><br/>  const onChange = e =&gt; {<br/>    const setCollection = setters[e.target.name];<br/>    const collection = collections[e.target.name].map(item =&gt; ({<br/>      ...item,<br/>      selected: false<br/>    }));<br/>    const index = collection.findIndex(<br/>      item =&gt; item.id === e.target.value<br/>    );<br/><br/>    collection[index] = { ...collection[index], selected: true };<br/>    setCollection(collection);<br/>  };<br/><br/>  const category = categories.find(category =&gt; category.selected) || {<br/>    id: ''<br/>  };<br/>  const product = products.find(product =&gt; product.selected) || {<br/>    id: ''<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;FormControl className={classes.control}&gt;<br/>        &lt;InputLabel htmlFor="categories"&gt;Category&lt;/InputLabel&gt;<br/>        &lt;Select<br/>          value={category.id}<br/>          onChange={onChange}<br/>          inputProps={{<br/>            name: 'categories',<br/>            id: 'categories'<br/>          }}<br/>        &gt;<br/>          &lt;MenuItem value=""&gt;<br/>            &lt;em&gt;None&lt;/em&gt;<br/>          &lt;/MenuItem&gt;<br/>          {categories.map(category =&gt; (<br/>            &lt;MenuItem key={category.id} value={category.id}&gt;<br/>              {category.label}<br/>            &lt;/MenuItem&gt;<br/>          ))}<br/>        &lt;/Select&gt;<br/>      &lt;/FormControl&gt;<br/>      &lt;FormControl<br/>        className={classes.control}<br/>        disabled={category.id === ''}<br/>      &gt;<br/>        &lt;InputLabel htmlFor="Products"&gt;Product&lt;/InputLabel&gt;<br/>        &lt;Select<br/>          value={product.id}<br/>          onChange={onChange}<br/>          inputProps={{<br/>            name: 'products',<br/>            id: 'values'<br/>          }}<br/>        &gt;<br/>          &lt;MenuItem value=""&gt;<br/>            &lt;em&gt;None&lt;/em&gt;<br/>          &lt;/MenuItem&gt;<br/>          {products<br/>            .filter(product =&gt; product.category === category.id)<br/>            .map(product =&gt; (<br/>              &lt;MenuItem key={product.id} value={product.id}&gt;<br/>                {product.label}<br/>              &lt;/MenuItem&gt;<br/>            ))}<br/>        &lt;/Select&gt;<br/>      &lt;/FormControl&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>Here's what you'll see when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea78f539-5991-4e16-9bea-952b7e22f1b3.png" style="width:13.42em;height:7.92em;"/></p>
<p>The category select is populated with options for you to choose from. The product select is disabled because no category has been selected. Here's what the category select looks like when it's open:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4243d9dd-76be-4508-8d75-aa6fa4fcfec4.png" style="width:12.25em;height:11.50em;"/></p>
<p>Once you select a category, you should be able to open the product select and make a product selection:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/42c98998-0e50-4d1c-8c4f-345571ea0834.png" style="width:11.42em;height:16.17em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The two <kbd>Select</kbd> components in this example have state dependencies. That is, the state of the product select depends on the state of the category select. This is because the options displayed in the product select are filtered based on the chosen category. Let's take a closer look at the state:</p>
<pre>const [categories, setCategories] = useState([<br/>  { label: 'Category 1', id: 1 },<br/>  { label: 'Category 2', id: 2 },<br/>  { label: 'Category 3', id: 3 }<br/>]);<br/><br/>const [products, setProducts] = useState([<br/>  { label: 'Product 1', id: 1, category: 1 },<br/>  { label: 'Product 2', id: 2, category: 1 },<br/>  { label: 'Product 3', id: 3, category: 1 },<br/>  { label: 'Product 4', id: 4, category: 2 },<br/>  { label: 'Product 5', id: 5, category: 2 },<br/>  { label: 'Product 6', id: 6, category: 2 },<br/>  { label: 'Product 7', id: 7, category: 3 },<br/>  { label: 'Product 8', id: 8, category: 3 },<br/>  { label: 'Product 9', id: 9, category: 3 }<br/>]);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>categories</kbd> and <kbd>products</kbd> arrays represent the options of the two selects on the screen. The selected option is marked with a <kbd>selected</kbd> Boolean property value of <kbd>true</kbd>. No options are selected by default. Both selects use the same <kbd>onChange()</kbd> handler:</p>
<pre>const setters = {<br/>  categories: setCategories,<br/>  products: setProducts<br/>};<br/>const collections = { categories, products };<br/><br/>const onChange = e =&gt; {<br/>  const setCollection = setters[e.target.name];<br/>  const collection = collections[e.target.name].map(item =&gt; ({<br/>    ...item,<br/>    selected: false<br/>  }));<br/>  const index = collection.findIndex(<br/>    item =&gt; item.id === e.target.value<br/>  );<br/><br/>  collection[index] = { ...collection[index], selected: true };<br/>  setCollection(collection);<br/>};</pre>
<p>The array to use depends on the value of <kbd>e.target.name</kbd>—which will be either categories or products. Once the collection value is initialized with the appropriate array, the <kbd>selected</kbd> property is set to <kbd>false</kbd> for every value. Then, the selected value is looked up based on <kbd>e.target.value</kbd>, and the <kbd>selected</kbd> property is set to <kbd>true</kbd> for this value.</p>
<p>Next, let's break down what's happening in the rest of the <kbd>ControllingSelectsWithState</kbd> component. First, the <kbd>category</kbd> and <kbd>product</kbd> selections are looked up from the component state:</p>
<pre>const category = categories.find(category =&gt; category.selected) || {<br/>  id: ''<br/>};<br/>const product = products.find(product =&gt; product.selected) || {<br/>  id: ''<br/>};</pre>
<p class="mce-root"/>
<p>You have to make sure that an object with an <kbd>id</kbd> property is always assigned to these constants, because this is expected later on. The empty string will match the empty value option, so that it is selected by default. Next, let's see how the category options are rendered:</p>
<pre>{categories.map(category =&gt; (<br/>  &lt;MenuItem key={category.id} value={category.id}&gt;<br/>    {category.label}<br/>  &lt;/MenuItem&gt;<br/>))}</pre>
<p>This is a straightforward mapping of values in the <kbd>categories</kbd> array to the <kbd>MenuItem</kbd> components. The options in the <span>select <kbd>category</kbd></span> never change; in other words, the product options change based on the selected category—let's see how this is done:</p>
<pre>{products<br/>  .filter(product =&gt; product.category === category.id)<br/>  .map(product =&gt; (<br/>    &lt;MenuItem key={product.id} value={product.id}&gt;<br/>      {product.label}<br/>    &lt;/MenuItem&gt;<br/>  ))}</pre>
<p>Before each product is mapped to a <kbd>MenuItem</kbd> component, the <kbd>products</kbd> array is filtered based on the selected category using <kbd>filter()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See Also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Selection</kbd> demos: <a href="https://material-ui.com/demos/selects/">https://material-ui.com/demos/selects/</a></li>
<li><kbd>InputLabel</kbd> API documentation: <a href="https://material-ui.com/api/input-label/">https://material-ui.com/api/input-label/</a></li>
<li><kbd>MenuItem</kbd> API documentation:  <a href="https://material-ui.com/api/menu-item/">https://material-ui.com/api/menu-item/</a></li>
<li><kbd>FormHelperText</kbd> API documentation: <a href="https://material-ui.com/api/form-helper-text/">https://material-ui.com/api/form-helper-text/</a></li>
<li><kbd>FormControl</kbd> API documentation: <a href="https://material-ui.com/api/form-control/">https://material-ui.com/api/form-control/</a></li>
<li><kbd>Select</kbd> API documentation: <a href="https://material-ui.com/api/select/">https://material-ui.com/api/select/</a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting multiple items</h1>
                </header>
            
            <article>
                
<p>Users can select multiple values from the <kbd>Select</kbd> components. This involves using an array as the selected value state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here's some code that renders <kbd>Select</kbd> with several values. You can select as many values as you like:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Select from '@material-ui/core/Select';<br/>import Input from '@material-ui/core/Input';<br/>import InputLabel from '@material-ui/core/InputLabel';<br/>import MenuItem from '@material-ui/core/MenuItem';<br/>import FormControl from '@material-ui/core/FormControl';<br/><br/>const options = [<br/>  { id: 1, label: 'First' },<br/>  { id: 2, label: 'Second' },<br/>  { id: 3, label: 'Third' },<br/>  { id: 4, label: 'Fourth' },<br/>  { id: 5, label: 'Fifth' }<br/>];<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  formControl: {<br/>    margin: theme.spacing(1),<br/>    minWidth: 100,<br/>    maxWidth: 280<br/>  }<br/>}));<br/><br/>export default function SelectingMultipleItems() {<br/>  const classes = useStyles();<br/>  const [selected, setSelected] = useState([]);<br/><br/>  const onChange = e =&gt; {<br/>    setSelected(e.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;FormControl className={classes.formControl}&gt;<br/>      &lt;InputLabel htmlFor="multi"&gt;Value&lt;/InputLabel&gt;<br/>      &lt;Select<br/>        multiple<br/>        value={selected}<br/>        onChange={onChange}<br/>        input={&lt;Input id="multi" /&gt;}<br/>      &gt;<br/>        {options.map(option =&gt; (<br/>          &lt;MenuItem key={option.id} value={option.id}&gt;<br/>            {option.label}<br/>          &lt;/MenuItem&gt;<br/>        ))}<br/>      &lt;/Select&gt;<br/>    &lt;/FormControl&gt;<br/>  );<br/>}</pre>
<p>Here's what the <span>selection</span> looks like when it's first opened:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/af8ee671-a857-4834-8ce9-3136f50ea6c8.png" style="width:6.50em;height:13.83em;"/></p>
<p>Here's what the select looks like with the first, third, and fifth options selected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef081767-4f01-4a97-96d1-b8a05f81d9ca.png" style="width:6.17em;height:13.50em;"/></p>
<p class="mce-root"/>
<p>Now that you've made your selections, you can click somewhere on the screen outside the menu to close it, or you can hit the <em>E</em><em>sc</em> key. You'll be able to see your selections in the text input:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c6683a7c-20e3-4b6d-b18e-ab4900bfc80f.png" style="width:12.75em;height:4.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by taking a look at how the <kbd>Select</kbd> component is rendered:</p>
<pre>&lt;Select<br/>  multiple<br/>  value={selected}<br/>  onChange={onChange}<br/>  input={&lt;Input id="multi" /&gt;}<br/>&gt;<br/>  {options.map(option =&gt; (<br/>    &lt;MenuItem key={option.id} value={option.id}&gt;<br/>      {option.label}<br/>    &lt;/MenuItem&gt;<br/>  ))}<br/>&lt;/Select&gt;</pre>
<p>The <kbd>options</kbd> array values are mapped to <kbd>MenuItem</kbd> components, just like any other <kbd>Select</kbd>. The <kbd>multiple</kbd> property tells the component to allow the user to make multiple selections. The <kbd>selected</kbd> state of the <kbd>SelectingMultipleItems</kbd> component is an array, which holds the selected values. This array is populated by the <kbd>onChange</kbd> handler:</p>
<pre>const onChange = e =&gt; {<br/>  setSelected(e.target.value);<br/>};</pre>
<p>Because the <kbd>multiple</kbd> property was used, <kbd>e.target.value</kbd> is an array of selected values—you can just update the selected state using this value as is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Rather than having the selected items show up as a comma-separated list of <kbd>test</kbd>, you can make the items stand out by mapping the selected values to <kbd>Chip</kbd> components. Let's make a component that will handle this:</p>
<pre>function Selected({ selected }) {<br/>  const classes = useStyles();<br/><br/>  return selected.map(value =&gt; (<br/>    &lt;Chip<br/>      key={value}<br/>      label={options.find(option =&gt; option.id === value).label}<br/>      className={classes.chip}<br/>    /&gt;<br/>  ));<br/>}</pre>
<p>This code block shows how you can use this component in the <kbd>renderValue</kbd> property of the <kbd>Select</kbd> component:</p>
<pre>&lt;Select<br/>  multiple<br/>  value={selected}<br/>  onChange={onChange}<br/>  input={&lt;Input id="multi" /&gt;}<br/>  renderValue={selected =&gt; &lt;Selected selected={selected} /&gt;}<br/>&gt;<br/>  {options.map(option =&gt; (<br/>    &lt;MenuItem key={option.id} value={option.id}&gt;<br/>      {option.label}<br/>    &lt;/MenuItem&gt;<br/>  ))}<br/>&lt;/Select&gt;</pre>
<p>Now, when you make multiple selections, they'll render as <kbd>Chip</kbd> components:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ba85cb59-fb07-40ee-802c-5a4aae6215fb.png" style="width:15.50em;height:6.25em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Selection</kbd> demos: <a href="https://material-ui.com/demos/selects/">https://material-ui.com/demos/selects/</a></li>
<li><kbd>Select</kbd> API documentation: <a href="https://material-ui.com/api/select/">https://material-ui.com/api/select/</a></li>
<li><kbd>Input</kbd> API documentation: <a href="https://material-ui.com/api/input/">https://material-ui.com/api/input/</a></li>
<li><kbd>InputLabel</kbd> API documentation: <a href="https://material-ui.com/api/input-label/">https://material-ui.com/api/input-label/</a></li>
<li><kbd>MenuItem</kbd> API documentation: <a href="https://material-ui.com/api/menu-item/">https://material-ui.com/api/menu-item/</a></li>
<li><kbd>FormControl</kbd> API documentation: <a href="https://material-ui.com/api/form-control/">https://material-ui.com/api/form-control/</a></li>
<li><kbd>Chip</kbd> API documentation: <a href="https://material-ui.com/api/chip/">https://material-ui.com/api/chip/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>