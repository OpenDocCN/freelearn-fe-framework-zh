- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating through Applications with Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we did a great job of separating concerns and adding different
    layers of abstraction to increase the maintainability of an Angular application.
    However, we have barely focused on the application’s UX.
  prefs: []
  type: TYPE_NORMAL
- en: Our user interface is bloated, with components scattered across a single screen.
    We must provide a better navigational experience for users and a logical way to
    change the application’s view intuitively. Now is the right time to incorporate
    routing and split the different areas of interest into pages, connected by a grid
    of links and URLs.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we deploy a navigation scheme between components of an Angular application?
    We use the Angular router and create custom links for our components to react
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Angular router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the main routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing application routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters to routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing navigation with advanced features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through routing in the
    Angular framework. You can find the related source code in the `ch09` folder of
    the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Angular router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In traditional web applications, when we wanted to change from one view to
    another, we needed to request a new page from the server. The browser would create
    a URL for the view and send it to the server. The browser would then reload the
    page as soon as the client received a response. It was a process that resulted
    in round trip time delays and a bad user experience for our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, γραμμή, στιγμιότυπο οθόνης, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Routing in traditional web applications'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern web applications using JavaScript frameworks such as Angular follow
    a different approach. They handle changes between views or components on the client
    side without bothering the server. They contact the server once during bootstrapping
    to get the main HTML file. The router on the client intercepts and handles any
    subsequent URL changes. These applications are called **Single-Page Applications
    (SPAs)** because they do not cause a full reload of a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, παράλληλα, διάγραμμα, γραμμή  Περιγραφή που
    δημιουργήθηκε αυτόματα](img/B21418_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: SPA architecture'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular framework provides the `@angular/router` npm package, which we can
    use to navigate between different components in an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding routing in an Angular application involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the base path for the Angular application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an appropriate directive or service from the `@angular/router` npm package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring different routes for the Angular application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deciding where to render components upon navigation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following sections, we will learn the basics of Angular routing before
    diving deeper into hands-on examples.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a base path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen, modern and traditional web applications react differently
    when a URL changes inside the application. The architecture of each browser plays
    an essential part in this behavior. Older browsers initiate a new request to the
    server when the URL changes. Modern browsers, also known as **evergreen** browsers,
    can change the URL and the browser history when navigating in different views
    without sending a request to the server, using a technique called **pushState**
    .
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 pushState allows in-app navigation without causing a full reload of a
    page and is supported by all modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular application must set the `<base>` HTML tag in the `index.html` file
    to enable pushState routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `href` attribute informs the browser of the path it should follow when loading
    application resources. The Angular CLI automatically adds the tag when creating
    a new application and sets the `href` value to the application root, `/` . If
    your application resides in a different folder from the root, you should name
    it after that folder.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling routing in Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular router is enabled by default in new Angular applications, as indicated
    by the `provideRouter` method in the `app.config.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In applications built with older versions of the Angular framework, the router
    is enabled by importing the `RouterModule` class in the main application module
    and using its `forRoot` method to define the routing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `provideRouter` method enables us to use a set of Angular artifacts related
    to routing:'
  prefs: []
  type: TYPE_NORMAL
- en: Services to perform common routing tasks such as navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives that we can use in our components to enrich them with navigation
    logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It accepts a single parameter, which is the routing configuration of the application,
    and is defined by default in the `app.routes.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `app.routes.ts` file contains a list of `Routes` objects that specify which
    routes exist in the application and which components should respond to a specific
    route. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In applications built with older versions of the Angular framework, you may
    notice that the route configuration is defined in a dedicated `app-routing.module.ts`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Each route definition object contains a `path` property, which is the URL path
    of the route, and a `component` property that defines which component will be
    loaded when the application navigates to that path.
  prefs: []
  type: TYPE_NORMAL
- en: The value of a `path` property should not contain a leading `/` .
  prefs: []
  type: TYPE_NORMAL
- en: Navigation in an Angular application can occur manually by changing the browser
    URL or navigating using in-app links. The browser will cause the application to
    reload in the first scenario, while the second will instruct the router to navigate
    at runtime. In our case, when the browser URL contains the `products` path, the
    router renders the product list component on the page. On the contrary, when the
    application navigates to `products` by code, the router follows the same procedure
    and updates the browser URL.
  prefs: []
  type: TYPE_NORMAL
- en: If the user tries to navigate to a URL that does not match any route, Angular
    activates a custom type of route called **wildcard** or **fallback** . The wildcard
    route has a `path` property with two asterisks and matches any URL. The component
    property for this is usually an application-specific `PageNotFoundComponent` or
    the main component of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The template of the main application component contains the `<router-outlet>`
    element, which is one of the main directives of the Angular router. It resides
    inside the `app.component.html` file and is used as a placeholder for components
    activated with routing. These components are rendered as a sibling element of
    the `<router-outlet>` element.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the basics and provided a minimal router setup. In the next
    section, we will look at a more realistic example and expand our knowledge of
    routing.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the main routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we start designing the architecture of an Angular application with routing,
    it is easiest to think about its main features, such as menu links that users
    can click to access. Products and shopping carts are basic features of the e-shop
    application we are currently building. Adding links and configuring them to activate
    certain features of an Angular application is part of the route configuration
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the source code of the Angular application we created in *Chapter
    8* , *Communicating with Data Services over HTTP* , to follow along with the rest
    of the chapter. After you get the code, we suggest you take the following actions
    for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `auth.interceptor.ts` and its unit test file. Actual calls in the
    Fake Store API do not need authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `app.config.ts` file so that the `provideHttpClient` method does
    not use the interceptor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set up the route configuration of our application, we need to follow the
    steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new Angular component for the shopping
    cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.routes.ts` file and add the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two route definition objects in the `routes` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, the `products` route will activate the `ProductListComponent`
    , and the `cart` route will activate the `CartComponent` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.html` file and modify the `<header>` HTML element as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding template, we apply the `routerLink` directive to anchor HTML
    elements and assign the route path we want to navigate. Notice that the path should
    start with `/` as opposed to the `path` property in the route definition object.
  prefs: []
  type: TYPE_NORMAL
- en: How the path starts depends on whether we want to use absolute or relative routing
    in our application, as we will learn later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the `<router-outlet>` HTML element inside the `<div>` element with the
    `content` class selector and remove the `<app-product-list>` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.ts` file, remove any references to the `ProductListComponent`
    class, and import the `RouterLink` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.css` file and replace every CSS style related to the
    `.social-links` selector with the following styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the global `styles.css` file and add the following CSS styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to preview our Angular application:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ng serve` command and navigate to `http://localhost:4200` . Initially,
    the application page displays the application header and the copyright information
    only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Products** link. The application should display the product list
    and update the browser URL to match the `/products` path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now navigate to the root path at `http://localhost:4200` and append the `/cart`
    path at the end of the browser URL. The application should replace the product
    list view with the cart component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**cart works!**'
  prefs: []
  type: TYPE_NORMAL
- en: Routing in Angular works bi-directionally. It enables us to navigate to an Angular
    component using the in-app links or the browser address bar.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Your Angular application now supports in-app navigation.
  prefs: []
  type: TYPE_NORMAL
- en: We have barely scratched the surface of Angular routing. There are many features
    for us to investigate in the following sections. For now, let’s try to break our
    components into more routes so that we can manage them easily.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing application routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application displays the product list along with the product details and
    the product create components. We need to organize the routing configuration so
    that different routes activate each component.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will add a new route for the product create component. Later,
    in the *Passing parameters to routes* section, we will add a separate route for
    the product details component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with the product create component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following route definition object in the `routes` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `product-list.component.ts` file and remove any references to the `ProductCreateComponent`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `product-list.component.html` file and remove the `<app-product-create>`
    element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `ng serve` command to start the application, click on the **Products**
    link, and verify that the product create form is not displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Currently, the product create component is only accessible using the browser
    URL, and we cannot reach it using the application UI. In the following section,
    we will learn how to accomplish that task and imperatively navigate to a route.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating imperatively to a route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The product create component can only be activated by entering the address
    `http://localhost:4200/products/new` in the browser address bar. Let’s add a button
    in the product list that will navigate us from the UI also:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.html` file and modify the second `@if` block
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `<path>` element below might be tricky to type out manually. Alternatively,
    you can find the code in the `ch09` folder in the book’s GitHub repository and
    copy it from there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we added an anchor element that will navigate us to
    the product create component, as indicated by the value of the `routerLink` directive.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `routerLink` directive is `new` and not `/products/new` as
    someone would expect. The preceding behavior is because the button resides in
    the product list component, which is already activated by the `products` part
    of the route.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router can synthesize the destination route by all activated routes,
    but if you don’t want to start from the root, you can add a `/` before the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.css` file and add the following CSS styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-list.component.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `RouterLink` class in the `imports` array of the `@Component` decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-create.component.css` file and add the following CSS style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding style, the `:host` selector targets the host element of the
    product create component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `ng serve` command to start the application and navigate to `http://localhost:4200/products`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Product list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the button with the plus sign. The application redirects you to the /
    `products/new` route and activates the product create component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Product create form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the product create component remains functional, our change introduced
    a flaw in the application’s UX. The user does not have a visual indication when
    a new product is created because the product list belongs to a different route.
    We must modify the logic of the **Create** button so that it redirects the user
    to the product list upon successful creation of a product:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-create.component.ts` file and add the following `import`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `Router` service in the `constructor` of the `ProductCreateComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `createProduct` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, we call the `navigate` method of the `Router` service
    to navigate into the `/products` route of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `/` character because we are using absolute routing by default.
  prefs: []
  type: TYPE_NORMAL
- en: It accepts a **link parameters array** containing the destination route path
    we want to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and modify the `getProducts` method so
    that it uses the Fake Store API when there is no local product data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we do not make the preceding change, the product list component will always
    return data from the Fake Store API.
  prefs: []
  type: TYPE_NORMAL
- en: Our application now redirects users to the product list whenever they create
    a new product so that they can see it on the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have configured the application routing to activate components according
    to a given path. However, our application does not show any components in the
    following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: When we navigate to the root path of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we try to navigate to a non-existing route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will learn how to use the built-in route paths
    that Angular router provides and improve the application UX.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in route paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to define a component that will be loaded when we navigate to the
    root path, we create a route definition object and set the `path` property to
    an empty string. A route with an empty string `path` is called the **default**
    route of the Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we want the default route to display the product list component.
    Open the `app.routes.ts` file and add the following route at the end of the `routes`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we tell the router to redirect to the `products` path
    when the application navigates to the default route. The `pathMatch` property
    tells the router how to match the URL to the root path property. In this case,
    the router redirects to the `products` path only when the URL matches the root
    path, which is the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the application, we will notice that when the browser URL points to
    the root path of our application, we are redirected to the `products` path, and
    the product list is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We added the default route after all other routes because the order of the routes
    is important. The router selects routes with a first-match-wins strategy. More
    specific routes should be defined before less specific ones.
  prefs: []
  type: TYPE_NORMAL
- en: We have encountered the concept of unknown routes in the *Introducing the Angular
    router* section. We saw briefly how to set up a **wildcard** route to display
    a `PageNotFoundComponent` when our application tries to navigate to a route that
    does not exist. In real-world applications, it is common to create such a component,
    especially if you want to display additional information to the user, such as
    what next steps they can follow. In our case, which is simpler, we will redirect
    to the `products` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following route at the end of the
    `routes` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The wildcard route must be the last entry in the route list because the application
    should only reach it if there are no matching routes.
  prefs: []
  type: TYPE_NORMAL
- en: If we run our application using the `ng serve` command and navigate to an unknown
    path, our application will display the product list.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have relied on the address bar of the browser to indicate which
    route is active at any given time. As we will learn in the following section,
    we could improve the user experience using CSS styling.
  prefs: []
  type: TYPE_NORMAL
- en: Styling router links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application header contains the **Products** and the **My Cart** links.
    When we navigate to each one, it is not clear which route has been activated.
    The Angular router exports the `routerLinkActive` directive, which we can use
    to change the style of a link when the corresponding route is active. It works
    similarly to the class binding we learned about in *Chapter 3* , *Structuring
    User Interfaces with Components* . It accepts a list of class names or a class
    that is added when the link is active and removed when it becomes inactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to use it in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.css` file and add the following CSS style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.ts` file and import the `RouterLinkActive` class from
    the `@angular/router` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `RouterLinkActive` class in the `imports` array of the `@Component`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.html` file and add the `routerLinkActive` directive
    to both links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when we click on an application link in the header, its color changes to
    denote the link is active.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use routing and activate components that do not need
    any parameters. However, the product details component accepts the product ID
    as a parameter. In the next section, we will learn how to activate the component
    using dynamic route parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common scenario in enterprise web applications is to have a list of items,
    and when you click on one of them, the page changes the current view and displays
    details of the selected item. The previous approach resembles a master-detail
    browsing functionality, where each generated URL on the master page contains the
    identifiers required to load each item on the detail page.
  prefs: []
  type: TYPE_NORMAL
- en: We can represent the previous scenario with two routes navigating to different
    components. One component is the list of items, and the other is the item details.
    So, we need to find a way to create and pass dynamic item-specific data from one
    route to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are tackling double trouble here: creating URLs with dynamic parameters
    at runtime and parsing the value of these parameters. No problem: the Angular
    router has our back, and we will see how with a real example.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a detail page using route parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The product list in our application currently displays a list of products. When
    we click on a product, the product details appear below the list. We need to refactor
    the previous workflow so that the component responsible for displaying product
    details is rendered on a different page from the list. We will use the Angular
    router to redirect the user to the new page upon clicking on a product from the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The product list component currently passes the selected product ID via input
    binding. We will use the Angular router to pass the product ID as a route parameter
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following route definition in the `routes` variable after the `products/new`
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The colon character denotes `id` as a route parameter in the new route definition
    object. If a route has multiple parameters, we separate them with `/` . As we
    will learn later, the parameter name is important when we want to consume its
    value in our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.html` file and add an anchor element for the
    product title so that it uses the new route definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, the `routerLink` directive uses property binding to
    set its value in a link parameters array. We pass the `id` of the product template
    reference variable as a parameter in the array.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to prefix the value of the link parameters array with `/products`
    because that route already activates the product list.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `<app-product-detail>` component and the `click` event binding from
    the `<li>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can refactor the `product-list.component.ts` file and remove any code that
    uses the `selectedProduct` property and the `ProductDetailComponent` class. The
    product list does not need to keep the selected product in its local state because
    we are navigating away from the list upon choosing a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed by modifying the product detail component so that it works
    with routing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-detail.component.css` file and add a CSS style to set the
    width of the host element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-detail.component.ts` file and modify the `import` statements
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Angular router exports the `ActivatedRoute` service, which we can use to
    retrieve information about the currently activated route, including any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the component `constructor` to inject the `ActivatedRoute` and `Router`
    services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the list of implemented interfaces of the `ProductDetailComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following `ngOnInit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ActivatedRoute` service contains the `paramMap` observable, which we can
    use to subscribe and get route parameter values. The `switchMap` RxJS operator
    is used when we want to get a value from an observable, complete it, and pass
    the value down to another observable. We use it, in this case, to pipe the `id`
    parameter from the `paramMap` observable to the `getProduct` method of the `ProductsService`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `changePrice` and `remove` methods so that the application will
    redirect to the product list upon completion of each action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `ngOnChanges` method because the component and its bindings are initialized
    every time the route is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the output event emitters because the product list component is not a
    parent component anymore. Leave the `id` input property as is because we will
    use it later in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the `addToCart` method empty for now. We will use it later in *Chapter
    10* , *Collecting User Data with Forms* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is also worth noting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `paramMap` observable returns an object of the `ParamMap` type. We can use
    the `get` method of the `ParamMap` object to pass the parameter name we defined
    in the route configuration and access its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We convert the value of the `id` parameter to a number because route parameter
    values are always strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the application using the `ng serve` command and click on a product
    from the list, the application navigates us to the product details component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, σχεδίαση  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Product Details page'
  prefs: []
  type: TYPE_NORMAL
- en: If you refresh the browser, the application will not display the product because
    the `getProduct` method of the `ProductsService` class works only with the cached
    version of product data. You must go to the product list again and select a product
    because the local cache has been reset. Note that this behavior is based on the
    current implementation of the e-shop application and is not tied to the Angular
    router architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we used the `paramMap` property to get route parameters
    as an observable. So, ideally, our component could be notified of new values during
    its lifetime. But the component is destroyed each time we want to select a different
    product from the list, and so is the subscription to the `paramMap` observable.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can avoid using observables by reusing the instance of a component
    as soon as it remains rendered on the screen during consecutive navigations. We
    can achieve this behavior using child routes, as we will learn in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing components using child routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Child routes are a perfect solution when we want a landing page component that
    will provide routing to other components. The component should contain a `<router-outlet>`
    element in which child routes will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we want to define the layout of our Angular application like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shape  Description automatically generated with medium confidence](img/B21418_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Master-detail layout'
  prefs: []
  type: TYPE_NORMAL
- en: The scenario in the previous diagram requires the product list component to
    contain a `<router-outlet>` element to render the product details component when
    the related route is activated.
  prefs: []
  type: TYPE_NORMAL
- en: The product details component will be rendered in the `<router-outlet>` of the
    product list component and not in the `<router-outlet>` of the main application
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The product details component is not destroyed when we navigate from one product
    to another. Instead, it remains in the DOM tree, and its `ngOnInit` method is
    called once, the first time we select a product. When we choose a new product
    from the list, the `paramMap` observable emits the `id` of the new product. The
    new product is fetched using the `ProductsService` class, and the component template
    is refreshed to reflect the new changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route configuration of the application, in this case, would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we use the `children` property of the route definition
    object to define child routes containing a list of route definition objects.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that we removed the word `products` from the `path` property of
    the children routes because the parent route will append it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A parent route can also provide services to its children by using the `providers`
    property of the route definition object. Providing services in a route is very
    helpful when we want to limit access to a subset of the routing configuration.
    If we wanted to restrict the `ProductsService` class only to the product-related
    components, we should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Angular creates a separate injector when providing services in route definition
    objects, which is an immediate child of the root injector. Suppose the service
    is also provided in the root injector, and suppose the cart component uses that.
    In that case, the instance created by one of the product-related components will
    differ from that of the cart component.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use the `paramMap` observable in Angular routing. In
    the following section, we will discuss an alternative approach using snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a snapshot of route parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we select a product from the list, the product list component is removed
    from the DOM tree, and the product details component is added. To choose a different
    product, we need to click on either the **Products** link or the back button of
    our browser. Consequently, the product details component is replaced by the product
    list component in the DOM. So, we are in a situation where only one component
    is displayed on the screen at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the product details component is destroyed, so is its `ngOnInit` method
    and the subscription to the `paramMap` observable. So, we do not benefit from
    using observables at this point. Alternatively, we could use the `snapshot` property
    of the `ActivatedRoute` service to get values for route parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `snapshot` property represents the current value of a route parameter, which
    also happens to be the initial value. It contains the `params` property, an object
    of route parameter key-value pairs we can access.
  prefs: []
  type: TYPE_NORMAL
- en: If you are sure your component will not be reused, use the snapshot approach.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have dealt with routing parameters in the form of `products/:id`
    . We use these parameters to navigate to a component that requires the parameter.
    In our case, the product details component requires the `id` parameter to get
    specific product details. However, there is another type of route parameter when
    we need it to be optional, as we will learn in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering data using query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 8* , *Communicating with Data Services over HTTP* , we learned how
    to pass query parameters to a request using the `HttpParams` class. The Angular
    router also supports passing query parameters through the application’s URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getProducts` method in the `products.service.ts` file uses HTTP query
    parameters to limit product results returned from the Fake Store API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses a hardcoded value for setting the `limit` query parameter. We will
    modify the application so that the product list component passes the `limit` value
    dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `products.service.ts` file and modify the `getProducts` method so
    that the `limit` is passed as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding method, if the `limit` value is **falsy** , we pass a default
    value of `10` to the query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: A falsy value evaluates to `False` in a Boolean context and can be `null` ,
    `undefined` , `0` , or `False` . You can read more at [https://developer.mozilla.org/docs/Glossary/Falsy](https://developer.mozilla.org/docs/Glossary/Falsy)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and import the `ActivatedRoute` service
    and the `switchMap` RxJS operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `ActivatedRoute` service in the `constructor` of the `ProductListComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ActivatedRoute` service contains a `queryParamMap` observable that we
    can subscribe to get query parameter values. It returns a `ParamMap` object, similar
    to the `paramMap` observable we saw earlier, which we can query to get parameter
    values. Modify the `getProducts` method to use the `queryParamMap` observable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `switchMap` RxJS operator to pipe the `limit`
    parameter from the `queryParamMap` observable to the `getProducts` method of the
    `ProductsService` class as a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `ng` `serve` command to start the application and navigate to `http://localhost:4200?limit=5`
    . You should see a list of 5 products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Filtered product list'
  prefs: []
  type: TYPE_NORMAL
- en: Try to experiment with different values for the limit parameter and observe
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters in routing are powerful and can be used for various use cases,
    such as filtering and sorting data. They can also be used when working with snapshot-based
    routing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explore a new innovative way to pass route
    parameters using component input properties.
  prefs: []
  type: TYPE_NORMAL
- en: Binding input properties to routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already learned, in *Chapter 3* , *Structuring User Interfaces with
    Components* , that we use input and output bindings to inter-communicate between
    components. An input binding can also pass route parameters while navigating to
    a component. We will see an example using the product detail component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input binding with route parameters is not enabled by default in the Angular
    router. We must activate it from the application configuration file. Open the
    `app.config.ts` file and import the `withComponentInputBinding` function from
    the `@angular/router` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass the preceding function as the second parameter in the `provideRouter`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `product-detail.component.ts` file and change the type of the
    `id` component property to a `string` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must change the property type because routing parameters are passed as strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `ngOnInit` method to use the `id` parameter to fetch a product:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the `ng serve` command and verify that the product details are displayed
    upon selecting a product from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Binding route parameters to component input properties has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript component class is simpler because we do not have asynchronous
    calls with observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can access existing components that work with input and output bindings using
    a route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input binding works with components that are activated via routing. If we want
    to access any route parameter from another component, we must use the `ActivatedRoute`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned all the different ways to pass parameters during navigation,
    we have covered all the essential information we need to start building Angular
    applications with routing. In the following sections, we will focus on advanced
    practices that enhance the user experience when using in-app navigation in Angular
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing navigation with advanced features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered basic routing with route and query parameters. The
    Angular router is quite capable, though, and able to do much more, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access to a route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing navigation away from a route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefetching data to improve application UX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy-loading routes to speed up response time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will learn about all these techniques in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling route access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we want to control access to a particular route, we use a **guard** .
    To create a guard, we use the `ng generate` command of the Angular CLI, passing
    the word `guard` and its name as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the previous command, the Angular CLI asks what type of guard
    we would like to create. There are multiple types of guards that we can create
    according to the functionality that they provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanActivate` : Controls whether a route can be activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanActivateChild` : Controls whether children routes can be activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CanDeactivate` : Controls whether a route can be deactivated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deactivation happens when we navigate away from a route.
  prefs: []
  type: TYPE_NORMAL
- en: '`CanMatch` : Controls whether a route can be accessed at all'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select `CanActivate` and press *Enter* . The Angular CLI creates the following
    `auth.guard.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The guard that we created is a function of type `CanActivateFn` , which accepts
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`route` : Indicates the route that will be activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` : Contains the state of the router upon successful navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CanActivateFn` function can return a boolean value, either synchronously
    or asynchronously. In the latter case, the router will wait for the observable
    or the promise to resolve before continuing. If the asynchronous event does not
    complete, the navigation will not continue. It can also return a `UrlTree` object,
    which will cause new navigation to a defined route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our guard returns `true` immediately, allowing free access to the route. Let’s
    add custom logic to control access based on whether the user is logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `import` statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the body of the arrow function with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `inject` method to inject the `AuthService`
    and `Router` services into the function. We then check the value of the `isLoggedIn`
    signal. If it is `true` , we allow the application to navigate to the requested
    route. Otherwise, we use the `parseUrl` method of the `Router` service to navigate
    to the root path of the Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: The `parseUrl` method returns a `UrlTree` object, which effectively cancels
    the previous navigation and redirects the user to the URL passed in the parameter.
    It is advised to use it over the `navigate` method, which may introduce unexpected
    behavior and can lead to complex navigation issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `authGuard` function in the `canActivate` array of the `cart` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `canActivate` property is an array because multiple guards can control route
    activation. The order of guards in the array is important. If one of the guards
    fails to pass, Angular will prevent access to the route.
  prefs: []
  type: TYPE_NORMAL
- en: Only authenticated users can now access the shopping cart. If you run the application
    using the `ng serve` command and click the **My Cart** link, you will notice that
    nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: When you try to access the shopping cart from the product list, you always remain
    on the same page. This is because the redirection that happens due to the authentication
    guard does not have any effect when you are already in the redirected route.
  prefs: []
  type: TYPE_NORMAL
- en: Another guard type related to the activation of a route is the `CanDeactivate`
    guard. In the following section, we will learn how to use it to prevent a user
    leaving a route.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing navigation away from a route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A guard that controls if a route can be deactivated is a function of the `CanDeactivateFn`
    type. We will learn how to use it by implementing a guard that notifies the user
    of pending products in the cart when they navigate away from the cart component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate a new guard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the `CanDeactivate` type from the list and press *Enter* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `checkout.guard.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the generic of the `CanDeactivateFn` to `CartComponent` and remove the
    parameters of the arrow function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a real-world scenario, we will probably need to add more components in the
    generics to create a generic guard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the body of the arrow function with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we use the `confirm` method of the global `window`
    object to display a confirmation dialog before navigating away from the cart component.
    The application execution will wait until the confirmation dialog is dismissed
    as a user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A route definition object contains a `canDeactivate` array similar to `canActivate`
    . Add the `checkoutGuard` function to the `canDeactivate` array of the `cart`
    route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `canDeactivate` property is an array because multiple guards can control
    route deactivation. The order of guards in the array is important. If one of the
    guards fails to pass, Angular will prevent a user leaving the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such a simple scenario, we could have written the logic of the `checkoutGuard`
    function inline to avoid the creation of the `checkout.guard.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application using the `ng serve` command and click the **My Cart**
    link after you have logged in. If you then click on the **Products** link or press
    the back button of the browser, you should see a dialog with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You have pending items in your cart. Do you want to continue?**'
  prefs: []
  type: TYPE_NORMAL
- en: If you click the **Cancel** button, the navigation is canceled, and the application
    remains in its current state. If you click the **OK** button, you will be redirected
    to the product list.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching route data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that when you navigate to the root path of the application
    for the first time, there is a delay in displaying the product list. It is reasonable
    since we are making an HTTP request to the backend API. However, the product list
    component was already initialized at that time.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding behavior may lead to unwanted effects if the component contains
    logic that interacts with data during initialization. To solve this problem, we
    can use a **resolver** to prefetch the product list and load the component when
    data are available.
  prefs: []
  type: TYPE_NORMAL
- en: A resolver can be handy when handling possible errors before activating a route.
    It would be more appropriate to navigate to an error page if the request to the
    API does not succeed instead of displaying a blank page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a resolver, we use the `ng generate` command of the Angular CLI,
    passing the word `resolver` and its name as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates the following `products.resolver.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The resolver that we created is a function of type `ResolveFn` , which accepts
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`route` : Indicates the route that will be activated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` : Contains the state of the activated route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ResolveFn` function can return an observable or promise. The router will
    wait for the observable or the promise to resolve before continuing. If the asynchronous
    event does not complete, the navigation will not continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our resolver returns a boolean value. Let’s add custom logic so
    that it returns an array of products:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `productsResolver` function so that it returns a product array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `inject` method to inject `ProductsService` in the function body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `queryParamMap` property to get the `limit` parameter value from the
    current route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `return` statement with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting function should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have created the resolver, we can connect it with the product list
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `resolve` property to the `products` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `resolve` property is an object that contains a unique name as a key and
    the resolver function as a value. The key name is important because we will use
    it in our components to access the resolved data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and import the `of` operator from
    the `rxjs` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `getProducts` method so that it subscribes to the `data` property
    of the `ActivatedRoute` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, the `data` observable emits an object whose value
    exists in the `products` key. Notice that we use the `switchMap` operator to return
    products in a new observable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can also remove any references to the `ProductsService` class
    because it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ng serve` command to start the application and verify that the product
    list is displayed when navigating to `http://localhost:4200` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular resolvers improve application performance when complex initialization
    logic exists in routed components. Another way to improve the application performance
    is to load components or child routes on demand, as we will learn in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy-loading parts of the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application may grow at some point, and the amount of data we put into it
    may also increase. The application may take a long time to start initially, or
    certain parts can take a long time to load. To overcome these problems, we can
    use a technique called **lazy loading** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy loading means we don’t initially load certain application parts, such
    as Angular components or routes. There are many advantages of lazy loading in
    an Angular application:'
  prefs: []
  type: TYPE_NORMAL
- en: Components and routes can be loaded upon request from the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users who visit certain areas of your application can significantly benefit
    from this technique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add more features in a lazy-loaded area without affecting the overall
    application bundle size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand how lazy loading in Angular works, we will create a new component
    that displays the current user profile.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice is to lazy-load parts of the application that are not used frequently,
    such as the profile of the currently logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create an Angular component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `user.routes.ts` in the `src\app` folder and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we set the `path` property to an empty string to activate
    the route by default. We also use the `default` keyword to benefit from the default
    export feature in lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.routes.ts` file and add the following route definition in the
    `routes` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `loadChildren` property of a route definition object is used to lazy-load
    Angular routes. It returns an arrow function that uses a dynamic `import` statement
    to lazy-load the routes file. The `import` function accepts the relative path
    of the routes file we want to import.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new anchor element to the `<header>` element of the `app.component.html`
    file that links to the newly created route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the command `ng serve` and observe the output in the console window. It
    should look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding output, we can see that the Angular CLI has created a lazy
    chunk file named **user-routes** in addition to the initial chunk files of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate with your browser to `http://localhost:4200` and open the developer
    tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **My Profile** link and inspect the **Network** requests tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Lazy-loaded route'
  prefs: []
  type: TYPE_NORMAL
- en: The application initiates a new request to the chunk file, which is the bundle
    of the user route. The Angular framework creates a new bundle for each lazy-loaded
    artifact and does not include it in the main application bundle.
  prefs: []
  type: TYPE_NORMAL
- en: If you navigate away and click the **My Profile** link again, you will notice
    that the application does not make a new request to load the bundle file. As soon
    as a lazy-loaded route is requested, it is kept in memory and can be used for
    subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lazy loading works not only with routes but also with components. We could
    have lazy-loaded the user component instead of the whole route by modifying the
    `user` route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we use the `loadComponent` property to import the
    `user.component.ts` file dynamically. The `import` function returns a promise
    that we chain with the `then` method to load the `UserComponent` class.
  prefs: []
  type: TYPE_NORMAL
- en: The user route is currently accessible for all users, even if not authenticated.
    In the following section, we will learn how to protect them using guards.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting a lazy-loaded route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can control unauthorized access to a lazy-loaded route similarly to how we
    can on normal routes. However, our guards need to support a function type named
    `CanMatchFn` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We will extend our authentication guard for use with lazy-loaded routes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `auth.guard.ts` file and import the `CanMatchFn` type from the `@angular/router`
    npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the signature of the `authGuard` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.routes.ts` file and add the `authGuard` function in the `canMatch`
    array of the `user` route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `canMatch` property is an array because multiple guards can control route
    matching. The order of guards in the array is important. If one of the guards
    fails to match with a route, Angular will prevent access to the route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we now run the application and click the **My Profile** link, we will notice
    that we cannot navigate to the respective component unless we are authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading is a technique preferred when the application performance is critical.
    Angular has also introduced a more performant feature to delay loading parts of
    an Angular application called **deferrable views** . Deferrable views give developers
    more fine-grained control over the conditions under which a part of the application
    will be loaded. We will explore deferrable views in *Chapter 15* , *Optimizing
    Application Performance* .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now uncovered the power of the Angular router, and we hope you have
    enjoyed this journey into the intricacies of this library. One of the things that
    shines in the Angular router is the vast number of options and scenarios we can
    cover with such a simple but powerful implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the basics of setting up routing and handling different types
    of parameters. We have also learned about more advanced features, such as child
    routing. Furthermore, we have learned how to protect our routes from unauthorized
    access. Finally, we have shown the full power of routing and how you can improve
    response time with lazy loading and prefetching.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will beef up our application components to showcase
    the mechanisms underlying web forms in Angular and the best strategies to grab
    user input with form controls.
  prefs: []
  type: TYPE_NORMAL
