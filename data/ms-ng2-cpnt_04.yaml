- en: Chapter 4. No Comments, Please!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。请不要评论！
- en: During the course of this chapter, we will create reusable components to enable
    commenting not only on projects, but also on any other entity within our application.
    We'll build our commenting system in a way that it will allow us to place it anywhere
    we'd like for our users to put comments. In order to provide our users with a
    feature to edit existing comments and also a seamless authoring experience, we'll
    create an editor UI component that could be used to make arbitrary content within
    our application editable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将创建可重用组件，以使评论不仅限于项目，还可以用于我们应用程序中的任何其他实体。我们将以这种方式构建我们的评论系统，以便我们可以将其放置在我们希望用户放置评论的任何位置。为了为用户提供编辑现有评论的功能以及无缝的创作体验，我们将创建一个编辑器UI组件，可以用于使应用程序中的任意内容可编辑。
- en: Discussing security and proper user management in this chapter is still out
    of scope, but we're going to create a dummy user service that will help us simulate
    a logged-in user. This service will be used by the commenting system, and we'll
    refactor our existing component to make use of it too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章讨论安全和适当用户管理还不在范围之内，但我们将创建一个模拟用户服务，这将帮助我们模拟已登录用户。此服务将由评论系统使用，并且我们将重构现有组件以利用它。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using `contenteditable` to create an in-place editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`contenteditable`创建就地编辑器
- en: Using `@HostBinding` and `@HostListener` to bind component members to host element
    properties and events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@HostBinding`和`@HostListener`将组件成员绑定到宿主元素属性和事件
- en: Communicating directly with view children using the `@ViewChild` annotation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@ViewChild`注解直接与视图子元素通信
- en: Performing DOM operations by injecting and using `ElementRef`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注入和使用`ElementRef`执行DOM操作
- en: Creating a dummy user service and using the `@Injectable` annotation to serve
    it as a dependency injection provider
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模拟用户服务并使用`@Injectable`注解作为依赖注入提供者
- en: Applying custom actions on component input changes, using the `OnChanges` life
    cycle hook
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件输入更改上应用自定义操作，使用`OnChanges`生命周期钩子
- en: Creating a simple pipe to format relative time intervals using the `Moment.js`
    library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的管道，使用`Moment.js`库格式化相对时间间隔
- en: One editor to rule them all
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个编辑器统治一切
- en: Since we will be processing a lot of user input within our application, it's
    crucial to provide a nice authoring experience to our users. Within the commenting
    system we're about to create in this chapter, we need a way through which users
    could edit existing comments, as well as add new comments. We could use regular
    text area input and work with dialog boxes to edit comments, but this seems too
    old-fashioned for a modern user interface, which we're going to build, and does
    not really provide a great user experience. What we're looking for is a way to
    edit stuff in place. The commenting system will not only benefit from such an
    in-place editor, but it will also help us create the editor component in such
    a way that we can use it for any content within our application that we'd like
    to make editable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在应用程序中处理大量用户输入，因此为用户提供良好的创作体验至关重要。在本章即将创建的评论系统中，我们需要一种方式，让用户能够编辑现有评论，以及添加新评论。我们可以使用常规文本区域输入并使用对话框来编辑评论，但这对于我们要构建的现代用户界面来说似乎过于过时，并且并不真正提供良好的用户体验。我们所寻找的是一种就地编辑内容的方法。评论系统不仅将从这种就地编辑器中受益，而且它还将帮助我们以这种方式创建编辑器组件，以便我们可以将其用于我们希望使其可编辑的应用程序中的任何内容。
- en: In order to build our in-place editor, we're going to use the `contenteditable`
    API that will enable a user to modify the content within the HTML elements directly
    in the site document.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的就地编辑器，我们将使用`contenteditable` API，这将使用户能够直接在站点文档中的HTML元素内修改内容。
- en: 'The following example illustrates how we can use the `contenteditable` attribute
    to make HTML elements editable:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了我们如何使用`contenteditable`属性使HTML元素可编辑：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the preceding example on a blank HTML page and click on the `h1` text. You
    will see that the element has become editable and you can type to modify its content.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在空白HTML页面上运行前面的示例，并点击`h1`文本。你会看到该元素已变为可编辑状态，你可以键入以修改其内容。
- en: 'Getting notified about changes within editable elements is fairly easy. There''s
    an input event emitted on every DOM element that is editable, and this will allow
    us to react to a change easily:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通知关于可编辑元素内的更改相对容易。每个可编辑的DOM元素都会发出输入事件，这将使我们能够轻松地做出反应：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this example, we have already created a naive implementation of an in-place
    editor where we're able to monitor changes applied by the user. Within this topic,
    we'll use this standard technology to build a reusable component that we can use
    wherever we want to make things editable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，我们已经创建了一个简单的原地编辑器实现，我们可以监控用户应用的变化。在这个主题中，我们将使用这项标准技术来构建一个可重用的组件，我们可以在任何需要使内容可编辑的地方使用它。
- en: Creating an editor component
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建编辑器组件
- en: 'First, let''s create a new folder named `editor` within our `ui` folder. In
    this folder, we''re going to create a new component file named `editor.js`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的 `ui` 文件夹中创建一个名为 `editor` 的新文件夹。在这个文件夹中，我们将创建一个名为 `editor.js` 的新组件文件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, that's quite a lot of new code. Let's dissect the different parts of the
    `Editor` component and go through each part step by step.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这有很多新的代码。让我们逐步分析 `Editor` 组件的不同部分。
- en: 'Within our `Editor` component, we''ll need to interact with the native DOM
    element, which is editable. The easiest and also the safest method to do this
    is to use the `@ViewChild` decorator in order to retrieve an element with a local
    view reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Editor` 组件中，我们需要与可编辑的原生 DOM 元素进行交互。最简单也是最安全的方法是使用 `@ViewChild` 装饰器来检索具有本地视图引用的元素：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous chapter, we learned about the `@ContentChildren` annotation,
    which helps us obtain a list of all the child components within content projection
    points. If we would like to do the same with regular view children, we need to
    use the equivalent `@ViewChildren` annotation. While `@ContentChildren` searches
    for components within content projection points, `@ViewChildren` hunts for the
    regular sub-tree of a component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 `@ContentChildren` 注解，它帮助我们获取内容投影点内所有子组件的列表。如果我们想要对常规视图子组件做同样的事情，我们需要使用等效的
    `@ViewChildren` 注解。虽然 `@ContentChildren` 在内容投影点内搜索组件，但 `@ViewChildren` 在组件的常规子树中寻找。
- en: If we want to search the component sub-tree for one single component, we can
    use the `@ViewChild` annotation (please note that `@ViewChild` and `@ViewChidren`
    are different).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在组件子树中搜索单个组件，我们可以使用 `@ViewChild` 注解（请注意，`@ViewChild` 和 `@ViewChildren`
    是不同的）。
- en: '| Query annotation | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 查询注解 | 描述 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@ViewChildren`(selector) | Will query the current component''s view for
    either directives or components and return an object of the type `QueryList`.
    If the view is dynamically updated, this list will be updated as well. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `@ViewChildren`(selector) | 将查询当前组件的视图中的指令或组件，并返回一个类型为 `QueryList` 的对象。如果视图是动态更新的，此列表也将相应更新。
    |'
- en: '| `@ViewChild`(selector) | Will query for only the first matching component
    or directive and return an instance of it. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `@ViewChild`(selector) | 将仅查询第一个匹配的组件或指令，并返回其实例。 |'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A selector can be either a directive or component type, or a string that contains
    the name of a local view variable. If a local view variable name is provided,
    Angular will search for the element containing the view variable reference.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可以是指令或组件类型，或者是一个包含本地视图变量名称的字符串。如果提供了本地视图变量名称，Angular 将会搜索包含视图变量引用的元素。
- en: If you need to communicate with view child components directly, using `@ViewChild`
    and `@ViewChildren` annotations should be your preferred way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要直接与视图子组件通信，使用 `@ViewChild` 和 `@ViewChildren` 注解应该是你的首选方式。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Sometimes you need to run the initialization code on view children after your
    component is initialized. In such cases, you can use the `AfterViewInit` life
    cycle hook. While the view child properties of your component class will still
    be undefined within the constructor of your component, they will be populated
    and initialized after the `AfterViewInit` life cycle callback.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要在组件初始化后对视图子组件运行初始化代码。在这种情况下，你可以使用 `AfterViewInit` 生命周期钩子。虽然你的组件类中的视图子属性在你的组件构造函数中仍然是未定义的，但它们将在
    `AfterViewInit` 生命周期回调之后填充和初始化。
- en: The `@ViewChild` and `@ViewChildren` decorators are great tools to interact
    with in your view directly. It doesn't really matter whether you'd like to interact
    with a DOM element or a component instance. Both use cases are nicely covered
    using this declarative API.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild` 和 `@ViewChildren` 装饰器是直接与你的视图交互的出色工具。你想要与之交互的是 DOM 元素还是组件实例，这并不重要。这两个用例都得到了很好的覆盖，使用了这个声明式
    API。'
- en: 'Let''s move back to our `Editor` component code. The next thing we''re going
    to look into are the component''s input functions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Editor`组件代码。接下来我们要查看的是组件的输入函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `content` input property is the main interface for interacting with the
    component from outside. Using property bindings, we can have any preexisting text
    content set up in the editor component.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`content`输入属性是外部与组件交互的主要接口。使用属性绑定，我们可以在编辑器组件中设置任何现有的文本内容。'
- en: The `editMode` property is a Boolean value that controls whether the editor
    is in edit or display mode. Our editor component will depend on this flag to know
    whether content should be edited or not. This allows us to switch from read-only
    mode to edit mode and back interactively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`editMode`属性是一个布尔值，用于控制编辑器是否处于编辑或显示模式。我们的编辑器组件将依赖于这个标志来知道内容是否应该被编辑。这允许我们从只读模式切换到编辑模式，然后再切换回来，实现交互式操作。'
- en: Though an input property, this flag can be controlled from outside the component.
    At the same time, it can also be used to create property binding of a host element.
    Specifically, we can use the flag to create a class attribute binding to add or
    remove the modifier class, `editor--edit-mode`. This class is used to control
    some differences in the visual appearance of the editor while in edit mode.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个输入属性，但这个标志可以从组件外部进行控制。同时，它也可以用来为主元素创建属性绑定。具体来说，我们可以使用这个标志来创建一个类属性绑定，以添加或删除修饰类`editor--edit-mode`。这个类用于在编辑模式下控制编辑器视觉外观的一些差异。
- en: 'The last of the three input properties in our editor component, `showControls`,
    controls whether the editor should show the control functions. There are three
    controls that will be shown when this property evaluates to a true value:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编辑器组件中的三个输入属性中的最后一个，`showControls`，控制编辑器是否应该显示控制功能。当这个属性评估为真值时，将显示以下三个控制：
- en: '**Edit button**: This will be shown when the component is in display mode,
    and it will switch the component to edit mode using the `editMode` flag.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑按钮**：当组件处于显示模式时将显示，它将使用`editMode`标志将组件切换到编辑模式。'
- en: '**Save button**: This will be shown only if the component is in edit mode.
    This control will save the changes applied within the current edit mode and switch
    the component back to display mode.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存按钮**：只有在组件处于编辑模式时才会显示。这个控件将保存当前编辑模式中应用的所有更改，并将组件切换回显示模式。'
- en: '**Cancel button**: This is the same as the save button, and this control is
    shown only when the component is in edit mode. If activated, the component will
    switch back to display mode, reverting any changes that you may have made.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消按钮**：这与保存按钮相同，并且仅在组件处于编辑模式时显示。如果激活，组件将切换回显示模式，撤销您可能做出的任何更改。'
- en: 'Besides our input properties, we also need some output properties to notify
    the outer world about the changes within our editor. The following piece of code
    helps us do this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的输入属性之外，我们还需要一些输出属性来通知外部世界我们编辑器中的更改。以下代码片段帮助我们做到这一点：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `editSaved` event will be emitted once the edited content is saved using
    the save button control. Also, it'll be better if an event is emitted upon every
    input change within our editable content element. For this, we used the `editableInput`
    output property.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用保存按钮控件保存编辑内容时，将触发`editSaved`事件。此外，如果在我们可编辑内容元素中的每次输入更改时都发出事件，那就更好了。为此，我们使用了`editableInput`输出属性。
- en: Our editor component works in a simple way. If the component is in edit mode,
    it shows an element that can be edited. However, once the editor switches back
    to display mode, we see a different element that cannot be edited. The visibility
    is controlled with the modifier class set by the host element property binding
    to the `editMode` flag.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编辑器组件以简单的方式工作。如果组件处于编辑模式，它会显示一个可编辑的元素。然而，一旦编辑器切换回显示模式，我们会看到一个不同的元素，这个元素不能被编辑。可见性是通过主机元素属性绑定到`editMode`标志的修饰类来控制的。
- en: 'Angular has no control over the content within our editable element. We control
    this content manually by using native DOM operations. Let''s look at how we did
    this. First of all, we needed to use delegates to access the element, since we''re
    most likely going to change how we will read and write to and from the editable
    element. We used the following to do this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Angular无法控制我们可编辑元素中的内容。我们通过使用原生DOM操作手动控制这个内容。让我们看看我们是如何做到这一点的。首先，我们需要使用代理来访问元素，因为我们很可能会改变我们如何读取和写入可编辑元素。我们使用了以下方法来实现这一点：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we used the `nativeElement` property on our `editableContentElement`
    field, previously set by the `@ViewChild` decorator.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`editableContentElement`字段上使用了`nativeElement`属性，该属性之前由`@ViewChild`装饰器设置。
- en: Angular does not directly provide us with a DOM element reference but a wrapper
    object of the type `ElementRef`. It's basically a wrapper around the native DOM
    element, holding additional information that is relevant to Angular.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Angular并没有直接提供DOM元素引用，而是提供了一个类型为`ElementRef`的包装对象。它基本上是原生DOM元素的包装，包含与Angular相关的额外信息。
- en: Using the `nativeElement` accessor, we can obtain a reference to the underlying
    DOM element.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nativeElement`访问器，我们可以获取底层DOM元素的引用。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ElementRef` wrapper plays an important part in Angular's platform-agnostic
    architecture. It allows you to run Angular in different environments (for example,
    native mobile, web workers, or others). It's part of an abstraction layer between
    the components and their views.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElementRef`包装器在Angular的平台无关架构中扮演着重要的角色。它允许你在不同的环境中运行Angular（例如，原生移动设备、web
    workers或其它）。它是组件及其视图之间的抽象层的一部分。'
- en: 'We also needed a way to set the content of the editable element based on the
    input that we would receive from the content input property. We could use the
    life cycle hook `OnInit`, which will be called only after the input properties
    are checked upon component initialization. However, this life cycle hook fires
    only once after the initialization, and we needed a way that would have helped
    us react to subsequent input changes of the `content` property. Have a look at
    the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来根据我们从内容输入属性接收到的输入来设置可编辑元素的内容。我们可以使用生命周期钩子`OnInit`，它将在组件初始化后检查输入属性之后被调用。然而，这个生命周期钩子只在初始化后触发一次，我们需要一种方法来帮助我们响应`content`属性的后续输入更改。请看以下代码片段：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `OnChanges` life cycle hook is exactly what we needed here. With this, once
    a change in the content input property is detected (this also includes the first
    change after the initialization), we can reflect the changed content onto our
    editable element.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnChanges`生命周期钩子正是我们所需要的。有了它，一旦检测到内容输入属性的变化（这包括初始化后的第一次变化），我们就可以将更改的内容反映到我们的可编辑元素上。'
- en: 'Now we have already implemented the reflection of the component content input
    property onto the editable field. But what about the opposite direction? We need
    to find a way to reflect the changes in our editable element onto our component
    `content` property. That''s also closely related to the actions performed on the
    component using the available controls within edit mode, which are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了组件内容输入属性到可编辑字段的反射。但反过来怎么办？我们需要找到一种方法来将可编辑元素中的更改反映到我们的组件`content`属性上。这也与在编辑模式中使用可用控件对组件执行的操作密切相关，这些操作如下：
- en: '**In the save operation**: Here, we reflect the edited content from the editable
    element back to the component''s `content` property.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在保存操作中**：在这里，我们将可编辑元素中的编辑内容反映回组件的`content`属性。'
- en: '**In the cancel operation**: Here, we ignore what has been edited by the user
    within the editable element and set its content back to the value in the component''s
    `content` property:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在取消操作中**：在这里，我们忽略用户在可编辑元素中进行的编辑，并将其内容设置回组件`content`属性中的值：'
- en: 'Let''s look at the code for those two operations:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两个操作的代码：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In addition to the highlighted code, which shows the reflection between the
    component's `content` property and the editable element, we emitted certain events
    that would help us notify the outside world about the changes. In both the operations,
    we set the `editMode` flag to `false` after completion. This ensures that our
    editor will switch to display mode after any one of the operations is completed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示组件`content`属性和可编辑元素之间反射的代码之外，我们还发出了一些事件，这些事件将帮助我们通知外部世界关于这些变化。在这两个操作中，我们在完成后将`editMode`标志设置为`false`。这确保了在任一操作完成后，我们的编辑器将切换到显示模式。
- en: 'The `edit` method will be called from the edit control button when the component
    is in display mode. The only thing it does is that it switches the component back
    to edit mode:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件处于显示模式时，`edit` 方法将从编辑控制按钮被调用。它所做的一切只是将组件切换回编辑模式：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Whatever we''ve discussed thus far in relation to the code is good enough for
    us to set up a fully functional component. However, the last part of the code,
    which we haven''t discussed yet, relates to ensuring better accessibility of our
    editor. Since our editor component is a bit larger than the editable element,
    we also want to make sure that a click anywhere inside the editor component will
    cause the editable element to be focused. The following code makes this happen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们关于代码的讨论已经足够我们设置一个完全功能性的组件。然而，代码的最后部分，我们还没有讨论，它关系到确保我们的编辑器有更好的可访问性。由于我们的编辑器组件比可编辑元素大一些，我们还想确保在编辑器组件内的任何地方点击都会使可编辑元素获得焦点。以下代码实现了这一点：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the `@HostListener` decorator, we registered an event binding on our component
    element that called the `focusEditableContent` method. Inside this method, we
    used the reference to the editable DOM element and triggered a focus.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@HostListener` 装饰器，我们在组件元素上注册了一个事件绑定，该绑定调用 `focusEditableContent` 方法。在这个方法内部，我们使用了可编辑
    DOM 元素的引用并触发了焦点。
- en: 'Let''s look at the template of our component that is located within the `editor.html`
    file in order to see how we could interact with the logic within our component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位于 `editor.html` 文件中的组件模板，以便了解我们如何与组件内的逻辑交互：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The logic within the editor component template is quite straightforward. If
    you've been following the component code, you'll now be able to identify the different
    elements that compose this component's view.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器组件模板中的逻辑非常简单。如果您一直在关注组件代码，现在您将能够识别组成此组件视图的不同元素。
- en: The first element with the `editor__editable-content` class is our editable
    element that has the `contenteditable` attribute. The user will be able to type
    into this element when the editor is in edit mode. It's important to note that
    we've annotated it with a local view variable reference, `#editableContentElement`,
    which we're using in our view child queries.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `editor__editable-content` 类的第一个元素是我们具有 `contenteditable` 属性的可编辑元素。当编辑器处于编辑模式时，用户将能够在此元素中键入。重要的是要注意，我们已使用局部视图变量引用对其进行注释，`#editableContentElement`，我们在视图子查询中使用它。
- en: The second element with the `editor__output` class is only to display the editor
    content and is only visible when the editor is in display mode. The visibility
    of both the elements is controlled using CSS, based on the `editor--edit-mode`
    modifier class, which, if you recall from the component class code, is set through
    host property binding based on the `editMode` property.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `editor__output` 类的第二元素仅用于显示编辑器内容，并且仅在编辑器处于显示模式时可见。这两个元素的可见性都使用 CSS 控制，基于
    `editor--edit-mode` 修饰类，如果您还记得组件类代码，它是通过主机属性绑定根据 `editMode` 属性设置的。
- en: 'The three control buttons are shown using the `NgIf` directive conditionally.
    The `showControls` input property needs to be `true`, and depending on the `editMode`
    flag, the screen will either show the edit button or the save and the cancel button:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 三个控制按钮是通过 `NgIf` 指令条件性地显示的。`showControls` 输入属性需要设置为 `true`，并且根据 `editMode` 标志，屏幕将显示编辑按钮或保存和取消按钮：
- en: '![Creating an editor component](img/image00316.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![创建编辑器组件](img/image00316.jpeg)'
- en: Screenshot of our editor component in action
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编辑器组件在行动中的截图
- en: Recap
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Within this building block, we have created an in-place editor widget, which
    we can use to grab user input for any content within our application. It allows
    us to provide the user with contextual editing capabilities, which will result
    in a great user experience.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构建块中，我们创建了一个原地编辑器小部件，我们可以使用它来获取应用程序中任何内容的用户输入。它允许我们向用户提供上下文编辑功能，这将带来极佳的用户体验。
- en: 'We have also learned about the following topics:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了以下主题：
- en: Using `contenteditable` HTML5 attribute to enable in-place editing.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `contenteditable` HTML5 属性来启用原地编辑。
- en: Using `@ViewChild` and `@ViewChildren` to query view child elements.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@ViewChild` 和 `@ViewChildren` 来查询视图子元素。
- en: Using the `ElementRef` dependency to perform native DOM operations.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ElementRef` 依赖项执行原生 DOM 操作。
- en: Implementing the logic, using the `OnChange` life cycle hook, to reflect data
    between Angular and the content that is not in immediate control of Angular.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `OnChange` 生命周期钩子实现逻辑，以反映 Angular 和不在 Angular 直接控制下的内容之间的数据。
- en: Building a commenting system
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建评论系统
- en: 'In the previous topic, we created an editor component that will support users
    in editing content within our application. Here, we''re going to create a commenting
    system that will enable users to write comments in various areas of our application.
    The commenting system will use our editor component to make comments editable,
    and thereby help users create new comments:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一主题中，我们创建了一个编辑器组件，该组件将支持用户在我们的应用程序中编辑内容。在这里，我们将创建一个评论系统，该系统将使用户能够在应用程序的各个区域撰写评论。评论系统将使用我们的编辑器组件使评论可编辑，从而帮助用户创建新的评论：
- en: '![Building a commenting system](img/image00317.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![构建评论系统](img/image00317.jpeg)'
- en: An illustration of the component sub-tree of a commenting system
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 评论系统组件子树的示意图
- en: The preceding diagram illustrates the architecture of the component tree within
    the commenting system that we are about to create.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了我们即将创建的评论系统中的组件树架构。
- en: The `Comments` component will be responsible for listing all the existing comments,
    as well as creating new comments.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comments` 组件将负责列出所有现有评论，以及创建新的评论。'
- en: Each comment itself is encapsulated into a `Comment` component. `Comment` components
    themselves use an editor that enables users to edit comments once they are created.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每条评论本身都被封装在一个 `Comment` 组件中。`Comment` 组件本身使用一个编辑器，允许用户在创建评论后编辑评论。
- en: The `Editor` component, which we built in the previous topic, is used by the
    `Comment` component directly, to provide an input control for adding new comments.
    This allows us to reuse the functionality of our editor component to capture user
    input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一主题中构建的 `Editor` 组件被 `Comment` 组件直接使用，以提供添加新评论的输入控制。这允许我们重用我们的编辑器组件的功能来捕获用户输入。
- en: The `Editor` component emits an `editSaved` event once editable content is saved
    using the control buttons of the editor. In the `Comment` component, we will capture
    these events and propagate a new event upward to our `Comments` component. There,
    we will do the necessary updates but then again emit a new event to notify our
    parent about the change. In a composition of components, each component will react
    on change and delegate to the parent component if necessary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用编辑器的控制按钮保存可编辑内容时，`Editor` 组件会发出 `editSaved` 事件。在 `Comment` 组件中，我们将捕获这些事件并将新事件向上传播到
    `Comments` 组件。在那里，我们将进行必要的更新，然后再发出一个新事件来通知我们的父组件。在组件组合中，每个组件都会对更改做出反应，并在必要时委托给父组件。
- en: Building the comment component
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建评论组件
- en: Let's start building our commenting system by fleshing out the `Comment` component
    first. In addition to the comment itself, we'd like to display the user's profile
    who commented, and of course, the time of the comment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过首先完善 `Comment` 组件来开始构建我们的评论系统。除了评论本身，我们还想显示评论用户的个人资料，当然，还有评论的时间。
- en: To display the time, we will make use of relative time formatting, as this will
    give our users a better feel of time. Relative time formatting displays timestamps
    in the format "5 minutes ago" or "1 month ago", in contrast to absolute timestamps,
    such as "25.12.2015 18:00". Using the `Moment.js` library, we'll create a pipe
    that we can use within component templates to convert timestamps and dates into
    relative time intervals.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示时间，我们将使用相对时间格式，因为这会给我们的用户更好的时间感。相对时间格式以“5分钟前”或“1个月前”的格式显示时间戳，而不是像“25.12.2015
    18:00”这样的绝对时间戳。我们将使用 `Moment.js` 库创建一个管道，我们可以在组件模板中使用它将时间戳和日期转换为相对时间间隔。
- en: 'Let''s create a new pipe within a new folder named `pipes`. The pipe needs
    to be created within a file named `from-now.js`, which is created under the `pipes`
    folder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为 `pipes` 的新文件夹内创建一个新的管道。该管道需要创建在 `pipes` 文件夹下的名为 `from-now.js` 的文件中：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This pipe can now be used within the templates of components to format timestamps
    and dates into relative time intervals.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个管道可以在组件的模板中使用，以将时间戳和日期格式化为相对时间间隔。
- en: 'Let''s use this pipe and the `Editor` component we created in the previous
    topic to create our `Comment` component. Within a file named `comment.html`, which
    is located within a new `comment` folder in the `comments` folder, we''ll create
    the template for our `Comment` component:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个管道和我们在上一主题中创建的 `Editor` 组件来创建我们的 `Comment` 组件。在名为 `comment.html` 的文件中，该文件位于
    `comments` 文件夹下的新 `comment` 文件夹内，我们将创建 `Comment` 组件的模板：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From the user object, we will get the user's profile image as well as the username.
    To display the time of the comment in a relative format, we'll use the `fromNow`
    pipe that we created earlier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户对象中，我们将获取用户的个人资料图片以及用户名。为了以相对格式显示评论的时间，我们将使用我们之前创建的 `fromNow` 管道。
- en: Finally, we will make use of the in-place editor component to display the content
    of the comment and make it editable at the same time. We will bind the comment
    content property to the content input property of the editor. At the same time,
    we will listen for the `editSaved` event of the editor and call the `onContentSaved`
    method on our comment component class. If you look at our component code again,
    you'll notice that we are re-emitting the event within the method so that the
    outside world is also notified about the change in the comment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用内联编辑器组件来显示评论的内容，并使其可编辑。我们将评论内容属性绑定到编辑器的内容输入属性。同时，我们将监听编辑器的 `editSaved`
    事件，并在我们的评论组件类上调用 `onContentSaved` 方法。如果你再次查看我们的组件代码，你会注意到我们在方法中重新发出事件，这样外界也会被通知评论的变化。
- en: 'Let''s take a look at the component class that we will create in a file named
    `comment.js`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们将在名为 `comment.js` 的文件中创建的组件类：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The component code is pretty straightforward. The only noticeable difference
    to other components we've created so far is the `pipes` property within the component's
    annotation. Here, we specify that we'd like to use the `FromNowPipe` class that
    we've just created. Pipes always need to be declared within the component; otherwise,
    they can't be used within the component's template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 组件代码相当简单。与其他我们迄今为止创建的组件相比，唯一明显的区别是组件注释中的 `pipes` 属性。在这里，我们指定我们想要使用我们刚刚创建的 `FromNowPipe`
    类。管道始终需要在组件中声明；否则，它们不能在组件的模板中使用。
- en: As input, we expect a user object that is passed along with the `user` input
    property. The `content` input property should be filled with the actual comment
    as a string, while the `time` input property should be set to a timestamp that
    reflects the actual time of the comment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入，我们期望一个用户对象，它通过 `user` 输入属性传递。`content` 输入属性应填充实际的评论作为字符串，而 `time` 输入属性应设置为反映评论实际时间的戳记。
- en: We also have an output property called `commentEdited`, which we will use to
    notify the changes on the comment. The `onEditSaved` method will be called by
    the event binding on our `Editor` component, which will then emit an event using
    the `commentEdited` output property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `commentEdited` 的输出属性，我们将使用它来通知评论的变化。`onEditSaved` 方法将由我们的 `Editor`
    组件上的事件绑定调用，然后它将使用 `commentEdited` 输出属性发出一个事件。
- en: Building the comments component
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 `Comments` 组件
- en: We now have all the components ready in order to finish building our commenting
    system. The last missing piece of the puzzle is the `Comments` component, which
    will list all the comments and provide an editor to create new comments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有组件，以便完成构建我们的评论系统。最后缺失的拼图是 `Comments` 组件，它将列出所有评论并提供一个编辑器来创建新的评论。
- en: 'First, let''s take a look at the template of our `Comments` component that
    we will create in a file named `comments.html` within a folder named `comments`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下我们将在名为 `comments` 的文件夹中创建的名为 `comments.html` 的文件中的 `Comments` 组件模板：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see the direct usage of an `Editor` component within the component's
    template. We are using this in-place editor to provide an input component to create
    new comments. We could also use a text area here, but we've decided to reuse our
    `Editor` component. We will set the `editMode` property to true so it will be
    initialized in edit mode. We will also set the `showControls` input to `false`
    because we don't want the editor to become autonomous. We will only use its in-place
    editing capabilities, but control it from our `Comments` component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在组件的模板中看到 `Editor` 组件的直接使用。我们使用这个内联编辑器来提供一个输入组件以创建新的评论。我们也可以在这里使用文本区域，但我们决定重用我们的
    `Editor` 组件。我们将 `editMode` 属性设置为 true，以便它在编辑模式下初始化。我们还将 `showControls` 输入设置为 `false`，因为我们不希望编辑器变得自主。我们只会使用它的内联编辑功能，但将从我们的
    `Comments` 组件中控制它。
- en: To add a new comment, we will use a button that has a click event binding, which
    calls the `addNewComment` method on our component class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一条新评论，我们将使用一个具有点击事件绑定的按钮，该按钮调用我们的组件类上的 `addNewComment` 方法。
- en: Below the section where users can add new comments, we will create another section
    that will list all the existing comments. If no comments exist, we simply don't
    render the section. With the help of the `NgFor` directive, we could display all
    the existing comments and create a `Comment` component for each repetition. We
    will bind all the comment data properties to our `Comment` component and also
    add an event binding to handle updated comments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户可以添加新评论的部分下方，我们将创建另一个部分，用于列出所有现有的评论。如果没有评论存在，我们简单地不渲染该部分。借助`NgFor`指令，我们可以显示所有现有的评论，并为每个重复创建一个`Comment`组件。我们将所有评论数据属性绑定到我们的`Comment`组件，并添加一个事件绑定来处理更新的评论。
- en: 'Let''s create the component class within a new file named `comments.js` in
    the `comments` folder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`comments`文件夹中创建一个新的名为`comments.js`的文件，以创建组件类：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s go through individual code parts again and discuss what each of them
    does. First, we declared an input property named `comments` in our component class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次逐个分析代码部分，并讨论每个部分的作用。首先，我们在组件类中声明了一个名为`comments`的输入属性：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `comments` input property is a list of comment objects that contains all
    of the data associated with the comments. This includes the user who authored
    the comment and the timestamp, as well as the content of the comment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`comments`输入属性是一个包含所有与评论相关数据的评论对象列表。这包括撰写评论的用户、时间戳以及评论的内容。'
- en: 'We also need to be able to emit an event once a comment is added or an existing
    comment is modified. For this purpose, we used an output property named `commentsUpdates`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够在添加评论或修改现有评论后发出一个事件。为此，我们使用了一个名为`commentsUpdates`的输出属性：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once a new comment is added or an existing one is modified, we will emit an
    event from this output property with the updated list of comments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了新的评论或修改了现有的评论，我们将从这个输出属性发出一个事件，并附带更新后的评论列表。
- en: The `Editor` component we're going to use to add new comments will not have
    its own control buttons. We will use the `showControls` input property to disable
    them. Instead, we will control the editor from our `Comments` component directly.
    Therefore, we need a way to communicate with the `Editor` component within our
    component class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的`Editor`组件将没有自己的控制按钮。我们将使用`showControls`输入属性来禁用它们。相反，我们将直接从我们的`Comments`组件控制编辑器。因此，我们需要一种与组件类内部的`Editor`组件进行通信的方法。
- en: 'We used the `@ViewChild` decorator for this purpose again. However, this time,
    we did not reference a DOM element, which contains a local view variable reference.
    We directly passed our component type class to the decorator. Angular will search
    for any `Editor` components within the comments view and provide us with a reference
    to the instance of the editor. This is shown in the following line of code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了`@ViewChild`装饰器来达到这个目的。然而，这次我们没有引用一个包含本地视图变量引用的DOM元素，而是直接将我们的组件类型类传递给装饰器。Angular将在评论视图中搜索任何`Editor`组件，并为我们提供对编辑器实例的引用。这在上面的代码行中有所体现：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the `Comments` component only hosts one editor directly within the component
    template, we can use the `@ViewChild` annotation to obtain a reference to it.
    Using this reference, we can directly interact with the child component. This
    will allow us to control the editor directly from our `Comments` component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Comments`组件直接在组件模板中托管一个编辑器，我们可以使用`@ViewChild`注解来获取对其的引用。使用这个引用，我们可以直接与子组件交互。这将允许我们从`Comments`组件直接控制编辑器。
- en: 'Let''s move on to the next part of the code, which is the `Comments` component
    constructor. The only thing we''ve done here is inject a user service that will
    provide us with a way to obtain information of the currently logged-in user. As
    of now, this functionality is only mocked, and we will receive information of
    a dummy user. We need this information in the `Comments` component, since we need
    to know which user has actually entered a new comment:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到代码的下一部分，即`Comments`组件构造函数。我们在这里所做的唯一一件事是注入一个用户服务，该服务将为我们提供一种获取当前登录用户信息的方式。目前，这个功能只是模拟的，我们将收到一个虚拟用户的信息。我们需要在`Comments`组件中获取这些信息，因为我们需要知道哪个用户实际上输入了新的评论：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the next part of the code, we controlled how we should react to the changes
    of the `comments` input property. Actually, we would never want the list of comments
    to remain undefined. It should be an empty list in case there are no comments,
    but the input property comments should never be undefined. We controlled this
    by using the `OnChange` life cycle hook and overriding our `comments` property
    if it was set to `undefined` from outside:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分，我们控制了如何响应`comments`输入属性的变化。实际上，我们绝对不希望评论列表保持未定义状态。如果没有评论，它应该是一个空列表，但输入属性`comments`绝不能是未定义的。我们通过使用`OnChange`生命周期钩子并覆盖我们的`comments`属性来控制这一点，如果它从外部被设置为`undefined`：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This small change makes the internal handling of our comment data much cleaner.
    We don't need additional checks when working for array transformation functions,
    and we can always treat the `comments` property as an array.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的改动使得我们内部处理评论数据的方式变得更加清晰。在处理数组转换函数时，我们不需要额外的检查，并且我们可以始终将`comments`属性视为一个数组。
- en: 'Since the `Comments` component is also responsible for handling the logic that
    deals with the process of adding new comments, we needed a method that could implement
    this requirement. In relation to this, we used some immutable practices we learned
    about in the previous chapter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Comments`组件还负责处理与添加新评论过程相关的逻辑，我们需要一个方法来实现这一要求。与此相关，我们使用了我们在上一章中学到的一些不可变实践：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are a few key aspects in this part of the code. This method will be called
    from our component view when the `Add comment` button is clicked. This is when
    the user will have already entered some text into the editor and a new comment
    will have been created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有几个关键方面。当点击“添加评论”按钮时，这个方法将从我们的组件视图中被调用。这时，用户已经将一些文本输入到编辑器中，并且已经创建了一个新的评论。
- en: First, we will use the user service that we injected within the constructor
    to obtain information related to the currently logged-in user. The content of
    the newly created comment will be obtained directly from the `Editor` component
    we set up using the `@ViewChild` annotation. And, the `getEditableContent` method
    will allow us to receive the content of the editable element within the in-place
    editor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用在构造函数中注入的用户服务来获取与当前登录用户相关的信息。新创建的评论内容将直接从我们使用`@ViewChild`注解设置的`Editor`组件中获取。此外，`getEditableContent`方法将允许我们接收内联编辑器中可编辑元素的内容。
- en: The next thing we wanted to do was to communicate an update of the comment list
    with the outside world. We used the `commentsUpdated` output property to emit
    an event with the updated comment list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来想要做的是将评论列表的更新信息传达给外界。我们使用了`commentsUpdated`输出属性来发射一个包含更新后评论列表的事件。
- en: Finally, we wanted to clear the editor used to add new comments. As the in-place
    editor in the view of the `Comments` component is only used to add new comments,
    we can always clear it after a comment is added. This will give the user the impression
    that his comment has been moved from the editor into the list of comments. Then,
    once again, we can access the `Editor` component directly using our `newCommentEditor`
    property and call the `setEditableContent` method with an empty string to clear
    the editor. And this is what we've done here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要清除用于添加新评论的编辑器。由于`Comments`组件视图中的内联编辑器仅用于添加新评论，因此每次添加评论后我们都可以清除它。这将给用户一种他的评论已经从编辑器移动到评论列表中的印象。然后，我们再次可以直接使用我们的`newCommentEditor`属性访问`Editor`组件，并通过调用`setEditableContent`方法使用空字符串来清除编辑器。这正是我们在这里所做的事情。
- en: 'Our `Comments` component will hold the list of all the comments, and its view
    will create a `Comment` component for each comment in that list. Each `Comment`
    component will use an `Editor` component to provide in-place editing of its content.
    These editors work autonomously using their own controls, and they emit an event
    if the content is changed or altered in any way. To take care of this, we need
    to re-emit this event with the name `commentEdited` from the `Comment` component.
    Now we only need to catch this event within our `Comments` component in order
    to update the list of comments with the changes. This is illustrated in the following
    part of the code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Comments`组件将持有所有评论的列表，其视图将为列表中的每个评论创建一个`Comment`组件。每个`Comment`组件将使用`Editor`组件来提供其内容的就地编辑。这些编辑器独立工作，使用它们自己的控件，如果内容被更改或以任何方式修改，它们会发出事件。为了处理这一点，我们需要从`Comment`组件重新发出名为`commentEdited`的事件。现在我们只需要在我们的`Comments`组件中捕获此事件，以便用更改更新评论列表。这在下述代码部分中得到了说明：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method will be called for each individual `Comment` component that is repeated
    using the `NgFor` directive. From the view, we pass a reference to the comment
    object concerned, as well as the edited content we would receive from the `Comment`
    component event.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将为使用`NgFor`指令重复的每个单独的`Comment`组件调用。从视图中，我们传递一个对相关评论对象的引用，以及我们从`Comment`组件事件接收到的编辑内容。
- en: The comment object will only be used to determine the position of the updated
    comment within the comment list. If the new comment content is empty, we will
    remove the comment from the list. Otherwise, we will just create a copy of the
    previous comment object, change the content with the new edited content, and replace
    the old comment object in the list with the copy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 评论对象将仅用于确定更新评论在评论列表中的位置。如果新的评论内容为空，我们将从列表中删除该评论。否则，我们只需创建前一个评论对象的副本，用新的编辑内容更改内容，并用副本替换列表中的旧评论对象。
- en: Finally, since we wanted to communicate the change in the comment list, we emitted
    an event using the `commentUpdated` output property.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们想要传达评论列表的变化，我们使用`commentUpdated`输出属性发出了一个事件。
- en: With this, we have completed our commenting system, and now it's time to make
    use of it. We already have an empty tab prepared for our project comments, and
    this is going to be the spot where we will add commenting capabilities using our
    commenting system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了评论系统，现在是时候利用它了。我们已经有了一个空白的标签页用于我们的项目评论，这将是我们将使用评论系统添加评论功能的地方。
- en: 'First, let''s amend our `Project` component template, `project/project.html`,
    to include the commenting system:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改我们的`Project`组件模板，`project/project.html`，以包含评论系统：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is as easy as it gets. Since we are paying attention to a clean component
    architecture, the inclusion of our commenting system really works like a breeze.
    The only thing we now need to ensure is that we provide a property on our project
    with a list of comments. We also need a way to react to changes if comments are
    updated within our `Comments` component. For this purpose, we will create an `updateComments`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单不过的事情了。由于我们关注的是干净的组件架构，因此我们的评论系统的加入就像微风一样顺畅。我们现在唯一需要确保的是，在我们的项目中提供一个包含评论列表的属性。我们还需要一种方式来响应评论在`Comments`组件内更新时的变化。为此，我们将创建一个`updateComments`方法。
- en: 'Let''s look at the component class changes within the `project/project.js`
    file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`project/project.js`文件中的组件类更改：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we are already dealing with project updates in a general way and our
    `Project` component is emitting directly to our `App` component, where projects
    data will be persisted, the only thing we need to implement is an additional input
    property, as well as a method to handle comment updates:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在一般方式上处理项目更新，并且我们的`Project`组件直接向我们的`App`组件发出，其中项目数据将被持久化，我们唯一需要实现的是额外的输入属性，以及处理评论更新的方法：
- en: '![Building the comments component](img/image00318.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![构建评论组件](img/image00318.jpeg)'
- en: Screenshot of the commenting system integrated within our project component
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 项目组件内集成的评论系统截图
- en: Recap
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Within this topic, we have successfully created a full-fledged commenting system
    that can be placed in various areas of our application to enable commenting. Users
    can interact with in-place editors to edit the content in comments, which gives
    them a great user experience.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们成功创建了一个完整的评论系统，可以放置在我们应用程序的各个区域以启用评论功能。用户可以通过与就地编辑器交互来编辑评论中的内容，这为他们提供了很好的用户体验。
- en: 'While writing the code for our commenting system, we learned about the following
    topics:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的评论系统代码时，我们学习了以下主题：
- en: Implementing a simple pipe using the `@Pipe` annotation and the `Moment.js`
    library to provide relative time formatting
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@Pipe` 注解和 `Moment.js` 库实现一个简单的管道，以提供相对时间格式化
- en: Using the `OnChanges` life cycle hook to prevent unwanted or invalid values
    within input properties
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `OnChanges` 生命周期钩子来防止输入属性中的不希望或不正确的值
- en: Using `@ViewChild` to obtain a reference to the components within the component
    sub-tree in order to establish direct communication
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `@ViewChild` 获取组件子树中组件的引用以建立直接通信
- en: Reusing the `Editor` component as an input field replacement and as an autonomous
    in-place editor within the `Comment` component
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Comment` 组件中将 `Editor` 组件作为输入字段替代品以及作为独立的就地编辑器进行重用
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a simple in-place editor that we can use for making
    content editable within our application. Going forward, we can use the `Editor`
    component wherever we want to make content editable for our users. They will not
    have to jump into nasty dialogs or separate configuration pages, but will be in
    a position to edit directly, as per their current context. This is a great tool
    for enhancing the user experience for our users.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个简单的就地编辑器，我们可以用它来在我们的应用程序中使内容可编辑。从现在开始，我们可以在任何需要为用户使内容可编辑的地方使用 `Editor`
    组件。他们不需要跳入讨厌的对话框或单独的配置页面，而是可以直接编辑，根据他们当前的环境。这对提升我们用户的用户体验是一个很好的工具。
- en: Besides our shiny new `Editor` component, we created a whole commenting system
    that can be easily included in areas of our application where we'd like to provide
    commenting capabilities. We have now included the commenting system within our
    `Project` component, and users can now comment on projects by navigating to the
    **Comments** tab on the project details.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们闪亮的新 `Editor` 组件外，我们还创建了一个可以轻松包含在我们希望提供评论功能的应用程序区域的完整评论系统。现在，我们已经将评论系统包含在我们的
    `Project` 组件中，用户现在可以通过导航到项目详情的 **评论** 选项卡来对项目进行评论。
- en: In the next chapter, we'll use the component-based router of Angular to make
    our application navigable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Angular 的基于组件的路由器来使我们的应用程序可导航。
