- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Complex Tasks with Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached a point in our journey where we can successfully develop more
    complex applications by nesting components within other components in a sort of
    component tree. However, bundling all our business logic into a single component
    is not the way to go. Our application might become unmaintainable very soon as
    it develops.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll investigate the advantages that Angular’s dependency
    management mechanism can bring to the table to overcome such problems. We will
    learn how to use the **Angular Dependency Injection** ( **DI** ) mechanism to
    declare and consume our dependencies across the application with minimum effort
    and optimal results. By the end of this chapter, you will be able to create an
    Angular application that is correctly structured to enforce the **Separation of
    Concerns** ( **SoC** ) pattern using services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following concepts relating to Angular services:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Angular DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first Angular service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing dependencies across the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting services in the component tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding providers in the injector hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter contains various code samples to walk you through the concept of
    Angular services. You can find the related source code in the `ch05` folder of
    the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Angular DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is an application design pattern we also come across in other languages,
    such as C# and Java. As our applications grow and evolve, each code entity will
    internally require instances of other objects, better known as **dependencies**
    . Passing such dependencies to the consumer code entity is known as an **injection**
    , and it also entails the participation of another code entity called an **injector**
    . An injector is responsible for instantiating and bootstrapping the required
    dependencies to be ready for use when injected into a consumer. The consumer knows
    nothing about how to instantiate its dependencies and is only aware of the interface
    they implement to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Angular includes a top-notch DI mechanism to expose required dependencies to
    any Angular artifact of an Angular application. Before delving deeper into this
    subject, let’s look at the problem that DI in Angular is trying to address.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 3* , *Structuring User Interfaces with Components* , we learned
    how to display a list of objects using the `@for` block. We used a static list
    of `Product` objects that were declared in the `product-list.component.ts` file,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This previous approach has two main drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: In real-world applications, we rarely work with static data. It usually comes
    from a backend API or some other external source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product list is tightly coupled with the component. Angular components are
    responsible for the presentation logic and should not be concerned with how to
    get data. They only need to display it in the HTML template. Thus, they should
    delegate business logic to services to handle such tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we’ll learn how to avoid these obstacles using Angular
    services.
  prefs: []
  type: TYPE_NORMAL
- en: You will need the source code of the Angular application we created in *Chapter
    4* , *Enriching Applications Using Pipes and Directives* , to follow along with
    the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an Angular service that will return the product list. Thus,
    we will effectively delegate business logic tasks away from the component. Remember:
    *the component should only be concerned with presentation logic* .'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first Angular service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new Angular service, we use the `ng generate` command of the Angular
    CLI while passing the name of the service as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding command will create the `products` service, which consists
    of the `products.service.ts` file and its accompanying unit test file, `products.service.spec.ts`
    .
  prefs: []
  type: TYPE_NORMAL
- en: We usually name a service after the functionality that it represents. Every
    service has a business context or domain within which it operates. When it starts
    to cross boundaries between different contexts, this is an indication that you
    should break it into different services. A products service should be concerned
    with products. Similarly, orders should be managed by a separate orders service.
  prefs: []
  type: TYPE_NORMAL
- en: An Angular service is a TypeScript class marked with the `@Injectable` decorator.
    The decorator identifies the class as an Angular service that can be injected
    into other Angular artifacts such as components, directives, or even other services.
    It accepts an object as a parameter with a single property named `providedIn`
    , which defines which injector provides the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular service, by default, is registered with an injector – the `root`
    injector of the Angular application, as defined in the `products.service.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our service does not contain any implementation. Let’s add some logic so that
    our component can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following statement to import the `Product` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following method in the `ProductsService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the following sections, we will learn how to use the service in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting services in the constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to use a service in an Angular component is through its
    `constructor` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and modify the `products` property
    so that it is initialized to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following statement to import the `ProductsService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a component property called `productService` and give it a type of `ProductsService`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the property using the `new` keyword in the component’s `constructor`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `OnInit` interface from the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `OnInit` interface to the list of implemented interfaces of the `ProductListComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `ngOnInit` method that calls the `getProducts` method of
    the `productService` property and assigns the returned value to the `products`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the `ng serve` command to verify that the list of
    products is still shown correctly on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, σχεδίαση  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Product list'
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We have successfully wired up our component with the service, and our
    application looks great. Well, this seems to be the case, but it’s actually not.
    There are some problems with the actual implementation. If the `ProductsService`
    class must change, maybe to accommodate another dependency, `ProductListComponent`
    should also change the implementation of its `constructor` . Thus, it is evident
    that the product list component is tightly coupled to the implementation of `ProductsService`
    . It prevents us from altering, overriding, or neatly testing the service if required.
    It also entails that a new `ProductsService` object is created every time we render
    a product list component, which might not be desired in specific scenarios, such
    as when we expect to use an actual singleton service.
  prefs: []
  type: TYPE_NORMAL
- en: 'DI systems try to solve these issues by proposing several patterns, and the
    **constructor injection** pattern is the one enforced by Angular. We could remove
    the `productService` component property and inject the service directly into the
    `constructor` . The resulting `ProductListComponent` class would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider declaring injected services as `readonly` to provide more stable code
    and prevent re-assignment of the service. In the preceding snippet, the `constructor`
    could be re-written as `constructor(private readonly productService: ProductsService)
    {}` .'
  prefs: []
  type: TYPE_NORMAL
- en: The component does not need to know how to instantiate the service. On the other
    hand, it expects such a dependency to be available before it is instantiated so
    that it can be injected through its `constructor` . This approach is easier to
    test as it allows us to override it or mock it up.
  prefs: []
  type: TYPE_NORMAL
- en: However, using a `constructor` is not the only way to inject services in an
    Angular application, as we will learn in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The inject keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular framework contains a built-in `inject` method that we can use to
    inject services without using the `constructor` . There are some cases where we
    would like to use the `inject` method:'
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` contains many injected services, making our code unreadable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors cannot be used when working with pure functions in the Angular
    router or the HTTP client, as we will learn in the following chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see how we could refactor the product list component to use the `inject`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-list.component.ts` file and import the `inject` method from
    the `@angular/core` npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the following property in the `ProductListComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the `constructor` from the `ProductListComponent` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application should still work as expected if we run the `ng serve` command.
    The product list should be displayed as in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore additional use cases for the `inject` method in *Chapter 8*
    , *Communicating with Data Services over HTTP* , and *Chapter 9* , *Navigating
    through Applications with Routing* .
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the `constructor` approach, the `inject` method provides more accurate
    types, enforcing strongly typed Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular CLI provides a schematic that we can run to migrate to the new `inject`
    method. You can find more detail on how to run the schematic at [https://angular.dev/reference/migrations/inject-function](https://angular.dev/reference/migrations/inject-function)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we use both the inject method and constructor approach, according
    to the execution context of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, when we create a new Angular service, the Angular CLI registers
    this service with the root injector of the application by default. In the following
    section, we’ll learn about the internals of the DI mechanism and how the root
    injector works.
  prefs: []
  type: TYPE_NORMAL
- en: Providing dependencies across the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular framework offers a DI mechanism to provide dependencies in Angular
    artifacts such as components, directives, pipes, and services. The Angular DI
    is based on an injector hierarchy where at the top there is the root injector
    of an Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Injectors in Angular can examine the dependencies in the `constructor` of an
    Angular artifact and return an instance of the type represented by each dependency,
    so that we can use it straight away in the implementation of our Angular class.
    The injector maintains a list of all dependencies that an Angular application
    needs. When a component or other artifact wants to use a dependency, the injector
    first checks to see if it has already created an instance of this dependency.
    If not, it creates a new one, returns it to the component, and keeps a copy for
    further use. The next time the same dependency is requested, it returns the copy
    previously created. But how does the injector know which dependencies an Angular
    application needs?
  prefs: []
  type: TYPE_NORMAL
- en: When we create an Angular service, we use the `providedIn` property of the `@Injectable`
    decorator to define how it is provided to the application. That is, we create
    a **provider** for this service. A provider is a *recipe* containing guidelines
    on creating a specific service. During application startup, the framework is responsible
    for configuring the injector with providers of services so that it knows how to
    create one upon request. An Angular service is configured with the root injector
    by default when created with the CLI. The root injector creates singleton services
    that are globally available through the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 1* , *Building Your First Angular Application* , we learned that
    the application configuration object defined in the `app.config.ts` file has a
    `providers` property where we can register application services. We could remove
    the `providedIn` property from the `@Injectable` decorator of the `products.service.ts`
    file and add it in that array directly. Registering a service in this way is the
    same as configuring the service with `providedIn: ''root''` . The main difference
    between them is that the `providedIn` syntax is **tree shakable** .'
  prefs: []
  type: TYPE_NORMAL
- en: Tree shaking is the process of finding dependencies that are not used in an
    application and removing them from the final bundle. In the context of Angular,
    the Angular compiler can detect and delete Angular services that are not used,
    resulting in a smaller bundle.
  prefs: []
  type: TYPE_NORMAL
- en: When you provide a service through the application configuration object, the
    Angular compiler cannot say if the service is used somewhere in the application.
    So, it includes the service in the final bundle *a priori* . Thus, using the `@Injectable`
    decorator over the `providers` array of the application configuration is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: You should always register singleton services with the root injector.
  prefs: []
  type: TYPE_NORMAL
- en: The root injector is not the only injector in an Angular application. Components
    have their injectors, too. Angular injectors are also hierarchical. Whenever an
    Angular component defines a token in its `constructor` , the injector searches
    for a type that matches that token in the pool of registered providers. If no
    match is found, it delegates the search to the parent component’s provider and
    keeps bubbling the component injector tree until it reaches the root injector.
    If no match is found, Angular throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore the injector hierarchy of the product list component using Angular
    DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the application using the `ng serve` command and preview it at `http://localhost:4200`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start Angular DevTools and select the **Components** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **app-product-list** component from the component tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, αριθμός  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Components tab'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, the **Injected Services** section contains the services
    injected in the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the down arrow next to the **ProductsService** label, and you will
    see the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμμή, γραμματοσειρά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Product list injector hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: The injector hierarchy diagram in Angular DevTools is in horizontal orientation.
    Here, we show it vertically for readability..
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram depicts the injector hierarchy of the product list component.
    It contains two main injector hierarchy types common to an Angular application:
    **environment** and **element** injectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Environment injectors are configured using the `providedIn` property and the
    `providers` array in the application configuration object. In our case, we see
    the **Root** and **Standalone[_AppComponent]** injectors because the products
    service is provided from the root injector using the `providedIn` property.
  prefs: []
  type: TYPE_NORMAL
- en: Angular creates an element injector for each component which can be configured
    from the `providers` array of the `@Component` decorator, as we will see in the
    following section. In our case, we see the **AppComponent** and **ProductListComponent**
    injectors because these components are related directly to the product list.
  prefs: []
  type: TYPE_NORMAL
- en: You can select the **Injector Tree** tab of Angular DevTools for a more detailed
    analysis of the application injector hierarchy per type. You can also learn more
    about the different kinds of injectors at [https://angular.dev/guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies](https://angular.dev/guide/di/hierarchical-dependency-injection#types-of-injector-hierarchies)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Components create injectors, so they are immediately available to their child
    components. We’ll learn about this in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting services in the component tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned in the preceding section, Angular uses an element injector to
    provide services in components through the `providers` property of the `@Component`
    decorator. A service that registers with the element injector can serve two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be shared with its child components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can create multiple copies of the service every time the component that provides
    the service is rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we’ll learn how to apply each approach.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing dependencies through components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A service provided through a component can be shared among the child components
    of the parent component, and it is immediately available for injection into their
    constructors. Child components reuse the same instance of the service as the parent
    component. Let’s walk our way through an example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Angular component named `favorites` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `favorites.component.ts` file and modify the `import` statements accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `FavoritesComponent` class to use the `ProductsService` class and
    get the product list in a `products` component property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `favorites.component.html` file and replace its content with the following
    HTML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we iterate over the `products` array and use the `slice`
    pipe to display only two products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `favorites.component.ts` file so that it imports the `CommonModule`
    class that is needed for the `slice` pipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `favorites.component.css` file to add some CSS styles to our favorite
    products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-list.component.ts` file, import the `FavoritesComponent`
    class, and add the `ProductsService` class to the `providers` array of the `@Component`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `products.service.ts` file and remove the `providedIn` property from
    the `@Injectable` decorator since the element injector of the product list component
    will provide it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, open the `product-list.component.html` file and add the following
    HTML snippet to display the contents of the favorites component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the application using `ng serve` , you should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, σχεδίαση  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Product list with favorites'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain what we did in the previous example in more detail. We injected
    `ProductsService` in `FavoritesComponent` but we did not provide it through its
    injector. So, how was the component aware of how to create an instance of the
    `ProductsService` class and use it? It wasn’t. When we added the favorites component
    to the `ProductListComponent` template, we made it a direct child of this component,
    thus giving it access to all its provided services. In a nutshell, `FavoritesComponent`
    can use `ProductsService` out of the box because it is already provided through
    the element injector of its parent component, `ProductListComponent` .
  prefs: []
  type: TYPE_NORMAL
- en: So, even if `ProductsService` was initially registered with the environment
    root injector, we could also register it with the element injector of `ProductListComponent`
    . In the next section, we’ll investigate how it is possible to achieve such behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Root and component injectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already learned that when we create an Angular service using the Angular
    CLI, the service is provided in the application’s root injector by default. How
    does this differ when providing a service through the element injector of a component?
  prefs: []
  type: TYPE_NORMAL
- en: 'Services provided with the application root injector are available throughout
    the whole application. When a component wants to use such a service, it only needs
    to inject it, nothing more. Now, if the component provides the same service through
    its injector, it will get an instance of the service entirely different from the
    one from the root injector. This technique is called **service scope limiting**
    because we limit the scope of the service to a specific part of the component
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B21418_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Service scope limiting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous diagram shows that `ProductsService` can be provided through two
    injectors: the application root injector and the element injector of the product
    list component. The `FavoritesComponent` class injects `ProductsService` to use
    it. As we have already seen, `FavoritesComponent` is a child component of `ProductListComponent`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: According to the injector hierarchy, it will first ask the injector of its parent
    component, `ProductListComponent` , about providing the service. The `ProductListComponent`
    class indeed provides `ProductsService` , so it creates a new instance of the
    service and returns it to `FavoritesComponent` .
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider that another component in our application, `CmpA` , wants to use
    `ProductsService` . Since it is not a child component of `ProductListComponent`
    and does not contain any parent component that provides the required service,
    it will finally reach the application root injector. The root injector that provides
    `ProductsService` checks if it has already created an instance for that service.
    If not, it creates a new one, called `productService` , and returns it to `CmpA`
    . It also keeps `productService` in the local pool of services for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose another component, `CmpB` , wants to use `ProductsService` and asks
    the application root injector. The root injector knows it has already created
    the `productService` instance when `CmpA` requested it and returns it immediately
    to the `CmpB` component.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxing components with multiple instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we provide a service through the element injector and inject it into the
    component’s `constructor` , a new instance is created every time the component
    is rendered on the page. It can come in handy in cases such as when we want to
    have a local cache service for each component. We will explore this scenario by
    transforming our Angular application so that the product list displays a quick
    view of each product using an Angular service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new Angular component for the product
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-view.component.ts` file and declare an input property named
    `id` so we can pass a unique identifier of the product we want to display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following Angular CLI command inside the `product-view` folder to create
    an Angular service that will be dedicated to the product view component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `product-view.service.ts` file and remove the `providedIn` property
    from the `@Injectable` decorator because we will provide it later in the product
    view component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject `ProductsService` into the `constructor` of the `ProductViewService`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding technique is called **service-in-a-service** because we inject
    one Angular service into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a method named `getProduct` that takes an `id` property as a parameter.
    The method will call the `getProducts` method of the `ProductsService` class and
    search through the product list based on the `id` . If it finds the product, it
    will keep it in a local variable named `product` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have already created the essential Angular artifacts for working with the
    product view component. All we need to do now is connect them and wire them up
    to the product list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject `ProductViewService` in the `constructor` of the `ProductViewComponent`
    and implement the `ngOnInit` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a component property to keep the product that we will fetch from the
    `ProductViewService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `ngOnInit` method so that it calls the `getProduct` method of the
    `ProductViewService` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we pass the `id` component property to the `getProduct`
    method as a parameter and assign the returned value to the `product` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `product-view.component.html` file and replace its content with the
    following HTML template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `product-list.component.ts` file and import the `ProductViewComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, open the `product-list.component.html` file and modify the `@for`
    block to use the product view component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run our application with the `ng serve` command, we will see that the
    product list is still displayed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Each rendered product view component creates a dedicated sandboxed `ProductViewService`
    instance for its purpose. Any other component cannot share the instance or be
    changed except by the component that provides it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to provide `ProductViewService` in `ProductListComponent` instead of `ProductViewComponent`
    ; you will see that only one product is rendered multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, λογότυπο  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Product list'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, only one service instance is shared among the child components.
    Why is that? Recall the business logic of the `getProduct` method from the `ProductViewService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, the `product` property is set initially when we provide
    the service inside `ProductListComponent` . Since we have only one instance of
    the service, the value of the property will remain the same while we render the
    product view component multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how dependencies are injected into the component hierarchy and
    how provider lookup is performed by bubbling the request upward in the component
    tree. However, what if we want to constrain such injection or lookup actions?
    We’ll see how to do so in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting provider lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can only constrain dependency lookup to the next upper level. To do so,
    we need to apply the `@Host` decorator to those dependency parameters whose provider
    lookup we want to restrict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the element injector of `FavoritesComponent` will
    look for the `ProductsService` class in its providers. If it does not provide
    the service, it will not bubble up the injector hierarchy; instead, it will stop
    and throw an exception in the console window of the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Error: NG0201: No provider for _ProductsService found in NodeInjector.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the injector so that it does not throw an error if we decorate
    the service with the `@Optional` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, using the `@Optional` decorator does not solve the actual problem.
    The preceding snippet will still throw an error, different than the previous one,
    because we still use the `@Host` decorator that limits searching the `ProductsService`
    class in the injector hierarchy. We need to refactor the `ngOnInit` lifecycle
    hook event so that it takes care of not finding the service instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Host` and `@Optional` decorators define the level at which the injector
    searches for dependencies. There are two other decorators, called `@Self` and
    `@SkipSelf` . When using the `@Self` decorator, the injector looks for dependencies
    in the injector of the current component. On the contrary, the `@SkipSelf` decorator
    instructs the injector to skip the local injector and search further up in the
    injector hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Host` and `@Self` decorators work similarly. For more information about
    when to use each, have a look at [https://angular.dev/guide/di/hierarchical-dependency-injection#self](https://angular.dev/guide/di/hierarchical-dependency-injection#self)
    and [https://angular.dev/guide/di/hierarchical-dependency-injection#host](https://angular.dev/guide/di/hierarchical-dependency-injection#host)
    .
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how the Angular DI framework uses classes as dependency
    tokens to work out the type required and return it from any providers available
    in the injector hierarchy. However, there are cases where we might need to override
    the instance of a class or provide types that are not actual classes, such as
    primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding providers in the injector hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already learned how to use the `providers` array of the `@Component` decorator
    in the *Sharing dependencies through components* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax is called **class provider** syntax and is shorthand for
    the **provide object literal** syntax shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax uses an object with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`provide` : This is the token used to configure the injector. It is the actual
    class that consumers of the dependency inject into their constructors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useClass` : This is the actual implementation the injector will provide to
    the consumers. The property name will differ according to the implementation type
    provided. The type can be a class, a value, or a factory function. In this case,
    we use `useClass` because we are providing a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at some examples to get an overview of how to use the provide object
    literal syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding service implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already learned that a component could share its dependencies with
    its child components. Consider the `FavoritesComponent` , where we used the `slice`
    pipe to display a list of favorite products in its template. What if it needs
    to get data through a trimmed version of `ProductsService` and not directly from
    the service instance of `ProductListComponent` ? We could create a new service
    extending the `ProductsService` class and filtering out data using the native
    **Array.slice** method. Let’s create the new service and learn how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `favorites.service.ts` file and add the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `extends` keyword in the class definition to indicate that `ProductsService`
    is the base class of `FavoritesService` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `constructor` to call the `super` method and execute any business
    logic inside the base class `constructor` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following service method that uses the `slice` method to return
    only the first two products from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method is marked with the `override` keyword to indicate that
    the implementation of the method replaces the corresponding method of the base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `favorites.component.ts` file and add the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `FavoritesService` class in the `providers` array of the `@Component`
    decorator as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, we removed `CommonModule` from the `imports` array
    because we no longer need the `slice` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, open the `favorites.component.html` file and remove the `slice` pipe
    from the `@for` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the application using the `ng serve` command, we will see that the
    **Favorites** section is still displayed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, λογότυπο, γραφικά  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Favorite products list'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output assumes that you have already imported and added the favorites
    component in the product list component.
  prefs: []
  type: TYPE_NORMAL
- en: The `useClass` property essentially overwrote the initial implementation of
    the `ProductsService` class for the favorites component. Alternatively, we can
    go the extra mile and use a function to return a specific object instance that
    we need, as we will learn in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Providing services conditionally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example in the previous section, we used the `useClass` syntax to replace
    the implementation of the injected `ProductsService` class. Alternatively, we
    could create a **factory function** that decides whether it will return an instance
    of the `FavoritesService` or `ProductsService` class according to a condition.
    The function would reside in a simple TypeScript file named `favorites.ts` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then modify the `providers` array in the `favorites.component.ts`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that if one of the services also injected other dependencies,
    the previous syntax would not suffice. For example, if the `FavoritesService`
    class was dependent on the `ProductViewService` class, we would add it to the
    `deps` property of the provide object literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then use it in the factory function of the `favorites.ts` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We have already learned how to provide an alternate class implementation for
    an Angular service. What if the dependency we want to provide is not a class but
    a string or an object? We can use the `useValue` syntax to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming objects in Angular services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is common to keep application settings in a constant object in real-world
    applications. How could we use the `useValue` syntax to provide these settings
    in our components? We will learn more by creating settings for our application,
    such as the version number and the title:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `app.settings.ts` file in the `src\app` folder of the Angular CLI
    workspace and add the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may think we could provide these settings as `{ provide: AppSettings, useValue:
    appSettings }` , but this would throw an error because `AppSettings` is an interface,
    not a class. Interfaces are syntactic sugar in TypeScript that are thrown away
    during compilation. Instead, we should provide an `InjectionToken` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following statement to import the `InjectionToken` class from the `@angular/core`
    npm package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the following constant variable that uses the `InjectionToken` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.ts` file and modify the `import` statements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the application settings token in the `providers` array of the `@Component`
    decorator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `useValue` syntax is particularly useful when testing Angular applications.
    We will use it extensively when we learn about unit testing in *Chapter 13* ,
    *Unit Testing Angular Applications* .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following property in the `AppComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `app.component.html` file and modify the `<footer>` tag to include
    the application version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the `ng serve` command and observe the footer in
    the application output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copyright ©2024 All Rights Reserved - v1.0**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that although the `AppSettings` interface did not play a significant role
    in the injection process, we need it to provide typing on the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: Angular DI is a powerful and robust mechanism that allows us to manage the dependencies
    of our applications efficiently. The Angular team has put much effort into making
    it simple to use and removed the burden from the developer’s side. As we have
    seen, the combinations are plentiful, and how we will use them depends on the
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular DI implementation is the backbone of the Angular framework. Angular
    components delegate complex tasks to Angular services, based on the Angular DI.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned what Angular DI is and how to leverage it by creating
    Angular services. We explored different ways of injecting Angular services into
    components. We saw how to share services between components, isolate services
    in components, and define dependency access through the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we investigated how to override Angular services by replacing the service
    implementation or transforming existing objects into services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn what reactive programming is and how we can
    use observables in the context of Angular applications.
  prefs: []
  type: TYPE_NORMAL
