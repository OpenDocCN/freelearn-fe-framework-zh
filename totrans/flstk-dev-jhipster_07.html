<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Going into Production</h1>
                </header>
            
            <article>
                
<p>Our application is almost ready and it's time to go into production. Since this is the age of cloud computing, we will be deploying our application to a cloud provider—Heroku, to be specific. Before we go on and deploy intended for Linux, but it is possible to use it with Mac and Windows using tools such as our application into production, we need to make sure our application is production ready in our local environment. It would also be beneficial to make ourselves familiar with technologies and tools that will be useful at this stage.</p>
<p>In this chapter, we will learn about the following:</p>
<ul>
<li class="mce-root"><span>An introduction to Docker</span></li>
<li class="mce-root">Starting the production database with Docker</li>
<li class="mce-root">An introduction to Spring profiles</li>
<li class="mce-root">Packaging the application for local deployment</li>
<li class="mce-root">Upgrading to the newest version of JHipster</li>
<li class="mce-root">An introduction to the deployment options supported by JHipster</li>
<li class="mce-root">Production deployment to Heroku cloud</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An Introduction to Docker</h1>
                </header>
            
            <article>
                
<p>Docker is one of the most disruptive technologies to have taken center stage in the world of DevOps in recent times. Docker is a technology that enables operating-system-level virtualization or containerization, and is also open source and free to use. Docker is intended for Linux, but it is possible to use it with Mac and Windows using tools such as Docker for Mac and Docker for Windows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker containers</h1>
                </header>
            
            <article>
                
<p>When we talk about containers in the Docker world, we are technically talking about Linux containers. As stated by Red Hat on their website (<a href="https://www.redhat.com/en/topics/containers/whats-a-linux-container">https://www.redhat.com/en/topics/containers/whats-a-linux-container</a>):</p>
<div class="packt_quote">A Linux container is a set of processes that are isolated from the rest of the system, running from a distinct image that provides all files necessary to support the processes. By providing an image that contains all of an application’s dependencies, it is portable and consistent as it moves from development to testing, and finally to production.</div>
<p><span>Though the concept is not new, Docker makes it possible to create containers that are easy to build, deploy, version, and share. A Docker container only contains dependencies that are required for the application to run on the host OS; it shares the OS and other dependencies for the host system hardware. This makes a Docker container lighter than a <strong>virtual machine</strong> (<strong>VM</strong>) in terms of size and resource usage as it doesn't have to ship an entire OS and emulate virtual hardware. Hence, </span><span>Docker made virtual machines obsolete in many of the traditional use cases that were handled using VM technologies. This also means that, with Docker, we will be able to run more applications on the same hardware compared to running with VMs. Docker containers are instances of a docker image, which is a set of layers which describes the application that is being containerized. They contain the code, runtime, libraries, environment variables, and configuration files needed to run the application. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Dockerfile</h1>
                </header>
            
            <article>
                
<p>A Dockerfile is a set of instructions that tells Docker how to build a Docker image. By running the <kbd>docker build</kbd> command on a specific Dockerfile, we will produce a docker image that can be used to create Docker containers. Existing docker images can be used as a base for new Dockerfiles, hence letting you reuse and extend existing images.</p>
<p>The following code is from the Dockerfile of our application:</p>
<pre>FROM openjdk:8-jre-alpine<br/><br/>ENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \<br/>    JHIPSTER_SLEEP=0 \<br/>    JAVA_OPTS=""<br/><br/>CMD echo "The application will start in ${JHIPSTER_SLEEP}s..." &amp;&amp; \<br/>    sleep ${JHIPSTER_SLEEP} &amp;&amp; \<br/>    java ${JAVA_OPTS} -Djava.security.egd=file:/dev/./urandom -jar /app.war<br/><br/>EXPOSE 8080 5701/udp<br/><br/>ADD *.war /app.war</pre>
<p>The <kbd>FROM</kbd> instruction specifies the base image to use while initializing the build. Here, we specify open JDK 8 as our Java runtime.</p>
<p>The <kbd>ENV</kbd> instruction is used to set environment variables, and the <kbd>CMD</kbd> instruction is used to specify commands to be executed.</p>
<p>The <kbd>EXPOSE</kbd> instruction is used to specify the port that the container listens to during runtime.</p>
<p>Visit <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a> for a complete reference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Docker Hub</h1>
                </header>
            
            <article>
                
<p>Docker Hub (<a href="https://hub.docker.com/">https://hub.docker.com/</a>) is the online registry provided by Docker. It can be used to publish public and private docker images. This makes sharing and reusing docker images extremely easy.</p>
<p>To get a docker image from the registry, we just need to run <kbd>docker pull &lt;image-name&gt;</kbd>.</p>
<p>This makes it easy to use third-party tools without having to install them locally by just pulling and running the container from the registry.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Docker compose</h1>
                </header>
            
            <article>
                
<p>Docker compose is a tool in the Docker platform that is used to define and run multi-container applications. It lets us define how a container will behave when it is run in production, and also lets us define other services that it depends on and how services work with each other. Each application is a service as it defines the behavior of the container, for example, what port it runs on, what environment variables it uses, and so on. A YAML file is used for this. A single <kbd>docker.compose.yml</kbd> file can define all the services that are required for a multi-container application and can then be started with a single command. We will see more about Docker and docker -compose in <a href="9362521a-199a-4dda-ae0d-e55d9ed76957.xhtml" target="_blank">Chapter 11</a>, <em>Deploying with Docker Compose</em>.</p>
<div class="packt_infobox">Visit <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a> to learn more about Docker.</div>
<p>The following table is a list of useful commands for Docker and Docker compose:</p>
<table>
<tbody>
<tr>
<td><kbd>docker build -t myapp:1.0.</kbd></td>
<td>Build an image from the Dockerfile in the current directory and tag the image</td>
</tr>
<tr>
<td><kbd><span>docker images</span></kbd></td>
<td><span>List all images that are locally stored with the Docker </span><span>engine</span></td>
</tr>
<tr>
<td>
<div><kbd>docker pull alpine:3.4</kbd></div>
</td>
<td><span>Pull an image from a registry</span></td>
</tr>
<tr>
<td><kbd><span>docker push myrepo/myalpine:3.4</span></kbd></td>
<td><span>Push an image to a registry</span></td>
</tr>
<tr>
<td><kbd><span>docker login</span></kbd></td>
<td>Log<span> </span>in to<span> a registry (the Docker Hub, by default)</span></td>
</tr>
<tr>
<td><kbd>docker run --rm -it -p 5000:80 -v /dev/code alpine:3.4 /bin/sh</kbd></td>
<td>Run a docker container
<p class="mce-root"><strong>--rm</strong>: Remove container automatically after it exits<br/>
<strong>-it</strong>: Connect the container to the Terminal<br/>
<strong>-p</strong>: Expose port <kbd>5000</kbd> externally and map to port <kbd>80</kbd><br/>
<strong>-v</strong>: Create a host mapped volume inside the container<br/>
<strong>alpine:3.4</strong>: The image from which the container is instantiated<br/>
<strong>/bin/sh</strong>: The command to run inside the container</p>
</td>
</tr>
<tr>
<td><kbd>docker stop myApp</kbd></td>
<td>Stop a running container</td>
</tr>
<tr>
<td><kbd>docker ps</kbd></td>
<td>List the running containers</td>
</tr>
<tr>
<td><kbd>docker rm -f $(docker ps -aq)</kbd></td>
<td>Delete all running and stopped containers</td>
</tr>
<tr>
<td><kbd>docker exec -it web bash</kbd></td>
<td>Create a new bash process inside the container and connect it to the Terminal</td>
</tr>
<tr>
<td><kbd>docker logs --tail 100 web</kbd></td>
<td>Print the last 100 lines of a container's logs</td>
</tr>
<tr>
<td><kbd>docker-compose up</kbd></td>
<td>Start the services defined in the <kbd>docker-compose.yml</kbd> file in the current folder</td>
</tr>
<tr>
<td><kbd><span>docker-compose down</span></kbd></td>
<td>
<p><span>Stop the services defined in the <kbd>docker-compose.yml</kbd> file in the </span><span>current</span><span> folder</span></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting the production database with Docker</h1>
                </header>
            
            <article>
                
<p>JHipster creates a Dockerfile for the application and provides <kbd>docker-compose</kbd> files for all the technologies we choose, such as the database, search engine, Jenkins, and so on, under <kbd>src/main/docker</kbd>:</p>
<pre>├── <strong>app.yml</strong> - Main compose file for the application<br/>├── <strong>Dockerfile</strong> - The Dockerfile for the application<br/>├── <strong>hazelcast-management-center.yml</strong> - Compose file hazelcast management center<br/>├── <strong>jenkins.yml</strong> - Compose file for Jenkins<br/>├── <strong>mysql.yml</strong> - Compose file for the database that we choose.<br/>└── <strong>sonar.yml</strong> - COmpose file for SonarQube.</pre>
<p>Let's see how we can start our production database using Docker from the compose file provided under <kbd>src/main/docker/mysql.yml</kbd>. You will need to use a Terminal for the following instructions:</p>
<ol>
<li>Run <kbd>docker --version</kbd> and <kbd>docker-compose --version</kbd> to ensure these are installed.</li>
<li>Run <kbd>docker ps</kbd> to list the running containers. If you are not already running any containers, you should see an empty list.</li>
<li>Let's start the DB by running <kbd>docker-compose -f src/main/docker/mysql.yml up</kbd>.</li>
</ol>
<p class="mce-root">You will see the following console output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0a0b7920-48c2-4abd-a248-20fb92ab1dfc.png"/></div>
<div class="packt_tip">If you want to run the service in the background, pass the <kbd>-d</kbd> flag to the command. <kbd>docker-compose -f src/main/docker/mysql.yml up -d</kbd> will let you continue to use the same Terminal without having to switch to another.</div>
<p>Now if you run <kbd>docker ps</kbd> again, it should list the database service that we started:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/163a93cf-8eb3-4041-ac9e-c9000aa34411.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to Spring profiles</h1>
                </header>
            
            <article>
                
<p>Before we prepare our application for production, let's talk a little bit about Spring profiles. </p>
<p>Spring profiles (<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java</a>) let you change the way your application behaves based on environments. This is achieved using the <kbd>@Profile</kbd> annotations and profile-specific configuration files, which can be activated by specifying the <kbd>spring.profiles.active</kbd> property. Based on the profile that we set here, Spring will choose the appropriate <kbd>application.properties/application.yml</kbd> files and will include/exclude components that are included/excluded for the specific profile using the <kbd>@Profile</kbd> annotation in the Java source code. For example, if we set <kbd>spring.profiles.active=prod</kbd>, all the Spring components that have <kbd>@Profile("prod")</kbd> will be instantiated and any component that has <kbd>@Profile("!prod")</kbd> will be excluded. Similarly, Spring will load and use the <kbd>application-prod.yml</kbd> or <kbd>application-prod.properties</kbd> file if it is available on the classpath.</p>
<p>JHipster configures a <kbd>dev</kbd> and <kbd>prod</kbd> profile by default and includes an <kbd>application-dev.yml</kbd> and <kbd>application-prod.yml</kbd> in the <kbd>src/main/resources/config</kbd> folder, along with the base <kbd>application.yml</kbd> file. JHipster goes a step further and provides a <kbd>dev</kbd> and <kbd>prod</kbd> profile for the Gradle build as well (Available for Maven as well) so that we can build/run the application for a particular profile, which is very handy. Here are the profile and database configurations defined in the <kbd>application-dev.yml</kbd> file:</p>
<pre>...<br/><br/><strong>spring</strong>:<br/>    <strong>profiles</strong>:<br/>        <strong>active</strong>: <strong>dev</strong><br/>        <strong>include</strong>: <strong>swagger</strong><br/>    ...<br/>    datasource:<br/>        type: com.zaxxer.hikari.HikariDataSource<br/>        url: jdbc:h2:file:./build/h2db/db/store;DB_CLOSE_DELAY=-1<br/>        username: store<br/>        password:<br/>    ...</pre>
<p>The following profiles are available in a J<span>Hipster application:</span></p>
<table>
<tbody>
<tr>
<td>
<p><kbd>dev</kbd></p>
</td>
<td>
<p>Tuned for development and productivity, it enables Spring dev tools, in-memory databases, and so on</p>
</td>
</tr>
<tr>
<td>
<p><kbd>prod</kbd></p>
</td>
<td>
<p>Tuned for production, it focuses on performance and stability</p>
</td>
</tr>
<tr>
<td>
<p><kbd>swagger</kbd></p>
</td>
<td>
<p>Enables Swagger documentation for the API</p>
</td>
</tr>
<tr>
<td>
<p><kbd>no-liquibase</kbd></p>
</td>
<td>
<p>Disables Liquibase, and is useful in production environments where you don't want Liquibase to run</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packaging the application for local deployment</h1>
                </header>
            
            <article>
                
<p>Now let's build our application and deploy it locally. This can be done in two ways, either using Docker or by building and executing a WAR file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and deploying using Docker</h1>
                </header>
            
            <article>
                
<p>Let's use a Gradle task to build our docker image.</p>
<div class="packt_tip">Use the <kbd>./gradlew tasks</kbd> command to list all available tasks.</div>
<ol>
<li>In your Terminal, go to the project root folder and execute; <kbd>./gradlew bootRepackage -Pprod buildDocker</kbd>:
<ul>
<li><span><strong>bootRepackage</strong>: Builds an executable archive (WAR) file for the application</span></li>
<li><strong>-Pprod</strong>: Specifies the profile to use</li>
<li><span><strong>buildDocker</strong>: Builds a docker image based on the Dockerfile present in the </span><kbd>src/main/docker</kbd> <span><span>folder</span></span></li>
</ul>
</li>
</ol>
<div class="packt_tip"><span>If you are using JHipster Version 5 or above, use</span> <kbd>bootWar</kbd> <span>instead of the</span> <kbd>bootRepackage</kbd> <span>command in Gradle.</span></div>
<p style="padding-left: 60px">2. Once the task is completed successfully, we can deploy our app by running:</p>
<pre style="padding-left: 60px"><strong>&gt; docker-compose -f src/main/docker/app.yml up</strong></pre>
<p>This will also start the MySQL DB if you haven't started it already. If you already have it running from the previous step, then <kbd>docker-compose</kbd> will just skip it.</p>
<p>Our application will be ready once we see the following output in the console. As you can see, it's running with the <kbd>prod</kbd> and <kbd>swagger</kbd> profiles:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8b7871d3-eb48-463f-9b18-466c3f0fb218.png"/></div>
<p>Visit <kbd>http://localhost:8080</kbd> in your favorite browser to see the application in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and deploying an executable archive</h1>
                </header>
            
            <article>
                
<p>If you prefer not to use Docker, then we could deploy the app with a production profile locally by completing the following steps:</p>
<ol>
<li><span>First, make sure that MySQL DB is running from the previous step; otherwise, start it using </span><kbd>docker-compose -f src/main/docker/mysql.yml up -d</kbd>.</li>
<li>Now let's create an executable archive for the prod profile by running <kbd>./gradlew bootRepackage -Pprod</kbd>.</li>
<li>Once the build is successful, there will be two archives (WAR) created under <kbd>build/libs</kbd>. The <kbd>store-0.0.1-SNAPSHOT.war</kbd> file is an executable archive which can be run directly on a JVM, and the <kbd>store-0.0.1-SNAPSHOT.war.original</kbd> is a normal WAR file that can be deployed to a server such as JBoss or Tomcat.</li>
<li>Let's use the executable archive. Just run <kbd>./build/libs/store-0.0.1-SNAPSHOT.war</kbd> to start the application. If you are on Windows, run <kbd>java -jar build/libs/store-0.0.1-SNAPSHOT.war</kbd>.</li>
</ol>
<p>Once the application starts up, you will see the URL printed on the console. V<span>isit </span><kbd>http://localhost:8080</kbd> <span>in your favorite browser to see the application in action.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Upgrading to the newest version of JHipster</h1>
                </header>
            
            <article>
                
<p>JHipster provides an<span> </span>upgrade sub-generator (<a href="http://www.jhipster.tech/upgrading-an-application/">http://www.jhipster.tech/upgrading-an-application/</a>)<span> </span>to help you upgrade an application with a new JHipster version of it. It is quite useful as it automates a lot of manual steps for you, and the only thing you need to do is resolve merge conflicts if there are any after the upgrade is complete. Let's upgrade<span> </span>our<span> </span>application, shall we?</p>
<ol>
<li>In your Terminal, execute the <kbd>jhipster upgrade</kbd> command. The upgrade process will start if there is a new version of JHipster available; otherwise the process will exit.</li>
</ol>
<p>Once the process starts, you will see a detailed console log of what is going on. As you can see, this sub-generator uses the global JHipster version instead of the local one, unlike other sub-generators:</p>
<pre><strong>Using JHipster version installed globally</strong><br/>Executing jhipster:upgrade<br/>Options: <br/>Welcome to the JHipster Upgrade Sub-Generator<br/>This will upgrade your current application codebase to the latest JHipster version<br/>Looking for latest generator-jhipster version...<br/>yarn info v1.5.1<br/>4.14.1<br/>Done in 0.16s.<br/> <strong>New generator-jhipster version found: 4.14.1</strong><br/>     info git rev-parse -q --is-inside-work-tree<br/> Git repository detected<br/>     info git status --porcelain<br/>     info git rev-parse -q --abbrev-ref HEAD<br/>     info git rev-parse -q --verify jhipster_upgrade<br/>     info git checkout --orphan jhipster_upgrade<br/> <strong>Created branch jhipster_upgrade</strong><br/>     info Removing .angular-cli.json<br/>     ...<br/> Cleaned up project directory<br/>Installing JHipster 4.13.3 locally<br/>     info yarn add generator-jhipster@4.13.3 --dev --no-lockfile --ignore-scripts<br/>yarn add v1.5.1<br/>...<br/>Done in 6.16s.<br/> <strong>Installed generator-jhipster@4.13.3</strong><br/><strong>Regenerating application with JHipster 4.13.3...</strong><br/>warning package.json: No license field<br/>/home/deepu/Documents/jhipster-book/online-store/node_modules/.bin<br/>     info "/home/deepu/Documents/jhipster-book/online-store/node_modules/.bin/jhipster" --with-entities --force --skip-install<br/>Using JHipster version installed globally<br/>Running default command<br/>Executing jhipster:app<br/>Options: withEntities: true, force: true, skipInstall: true, with-entities: true, skip-install: true<br/>...<br/>Server application generated successfully.<br/>...<br/>Client application generated successfully.<br/>...<br/>Entity generation completed<br/>...<br/>Congratulations, JHipster execution is complete!<br/> <strong>Successfully regenerated application with JHipster 4.13.3</strong><br/>     info Removing src/main/resources/keystore.jks<br/>     info git add -A<br/>     info git commit -q -m "Generated with JHipster 4.13.3" -a --allow-empty<br/> Committed with message "Generated with JHipster 4.13.3"<br/>     info git checkout -q master<br/> Checked out branch "master"<br/>     info git --version<br/>     info git merge --strategy=ours -q --no-edit --allow-unrelated-histories jhipster_upgrade<br/> Current code has been generated with version 4.13.3<br/>     info git checkout -q jhipster_upgrade<br/> Checked out branch "jhipster_upgrade"<br/><strong>Updating generator-jhipster to 4.14.1 . This might take some time...</strong><br/>     info yarn add generator-jhipster@4.14.1 --dev --no-lockfile --ignore-scripts<br/>...<br/>Done in 30.40s.<br/> <strong>Updated generator-jhipster to version 4.14.1</strong><br/>     info Removing .angular-cli.json<br/>     ...<br/> Cleaned up project directory<br/><strong>Regenerating application with JHipster 4.14.1...</strong><br/>/home/deepu/Documents/jhipster-book/online-store/node_modules/.bin<br/>     info "/home/deepu/Documents/jhipster-book/online-store/node_modules/.bin/jhipster" --with-entities --force --skip-install<br/>Using JHipster version installed globally<br/>Running default command<br/>Executing jhipster:app<br/>Options: withEntities: true, force: true, skipInstall: true, with-entities: true, skip-install: true<br/>...<br/>Entity generation completed<br/>Congratulations, JHipster execution is complete!<br/> <strong>Successfully regenerated application with JHipster 4.14.1</strong><br/>     info Removing src/main/resources/keystore.jks<br/>     info git add -A<br/>     info git commit -q -m "Generated with JHipster 4.14.1" -a --allow-empty<br/> <strong>Committed with message "Generated with JHipster 4.14.1"</strong><br/>     info git checkout -q master<br/> Checked out branch "master"<br/><strong>Merging changes back to master...</strong><br/>     info git merge -q jhipster_upgrade<br/> Merge done!<br/>     info git diff --name-only --diff-filter=U package.json<br/><strong>WARNING! There are conflicts in package.json, please fix them and then run yarn</strong><br/> Start your Webpack development server with:<br/>yarn start<br/><br/>     info git diff --name-only --diff-filter=U<br/> Upgraded successfully.<br/><strong>WARNING! Please fix conflicts listed below and commit!</strong><br/><strong>gradle/wrapper/gradle-wrapper.properties</strong><br/><strong>package.json</strong><br/><strong>src/test/java/com/mycompany/store/web/rest/CustomerResourceIntTest.java</strong><br/><br/>Congratulations, JHipster execution is complete!</pre>
<p style="padding-left: 30px">The sub-generator does the following in order:</p>
<ol>
<li>Checks whether there is a new version of JHipster available (not applicable if you are using <kbd>--force</kbd>).</li>
<li>Checks whether the application is already initialized as a GIT repository; otherwise, JHipster will initialize one for you and commit the current codebase to the master branch.</li>
<li>Checks to ensure that there are no uncommitted local changes in the repository. The process will exit if it finds any uncommitted changes.</li>
<li>Checks whether a <kbd>jhipster_upgrade</kbd> branch exists. If not, a branch is created.</li>
</ol>
<p> </p>
<ol start="5">
<li>Checks out the <kbd>jhipster_upgrade</kbd> branch.</li>
<li>Upgrades JHipster to the latest available version globally.</li>
<li>Cleans the current project directory.</li>
<li>Regenerates the application using the <kbd>jhipster --force --with-entities</kbd> command.</li>
<li>Commits the generated code to the <kbd>jhipster_upgrade</kbd> branch.</li>
<li>Merges the <kbd>jhipster_upgrade</kbd> branch back to the original branch from where the <kbd>jhipster upgrade</kbd> command was launched.</li>
</ol>
<p style="padding-left: 60px">Let's see what has changed after the upgrade before we resolve the merge conflicts. See the changes staged. Carefully check the changes to make sure everything is in order, especially in the files where we made customizations earlier. My changelog looks like this; note that I truncated the bottom as there were 147 updated files:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/385098d9-1701-4287-bbdc-1b12e53d1500.png" style="font-size: 1em"/></div>
<p>Thankfully, we have only three conflicts and hence they should be easy to resolve. The conflict in <kbd>package.json</kbd> arises from the change we made to integrate Bootswatch. Carefully resolve the conflict stage in the file and move on to next file.</p>
<p>Once all the conflicts are resolved, stage the files and commit them:</p>
<pre><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "update to latest JHipster version"</strong></pre>
<p>Ensure that everything works. Run the server-side and client-side tests using <kbd>./gradlew test &amp;&amp; yarn &amp;&amp; yarn test</kbd>, and start the application to verify this by running the <kbd>./gradlew clean webpackBuildDev bootRun</kbd> command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to deployment options supported by JHipster</h1>
                </header>
            
            <article>
                
<p>Now that we have verified our production builds by deploying it locally, let's see how we can take it to actual production by using a cloud service. JHipster supports most of the cloud platforms out of the box, and provides special sub-generator commands for the popular ones such as Heroku, Cloudfoundry, and AWS.</p>
<p>JHipster also supports platforms such as Openshift, Google Cloud (using Kubernetes), and Rancher, but let's see them in upcoming chapters as they are more geared towards microservices. In theory, though, you could use them for Monolith deployments as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Heroku</h1>
                </header>
            
            <article>
                
<p>Heroku (<a href="https://www.heroku.com/">https://www.heroku.com/</a>) is the cloud platform from Salesforce. It lets you deploy, manage, and monitor your applications on the cloud. Heroku has a focus on Applications rather than on containers and supports languages ranging from NodeJS to Java to Go. JHipster provides the Heroku sub-generator, which was built and is maintained by Heroku, making it easy to deploy JHipster apps to Heroku cloud. It makes use of the Heroku CLI, and you need a Heroku account to use it. The sub-generator can be used to deploy and update your application to Heroku.</p>
<p>Visit <a href="http://www.jhipster.tech/heroku/">http://www.jhipster.tech/heroku/</a> for more info.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cloud Foundry</h1>
                </header>
            
            <article>
                
<p class="mce-root">Cloud Foundry is a multi-cloud computing platform governed by Cloud Foundry Foundation. It was originally created by VMWare, and is now under Pivotal, the company behind Spring Framework. It offers a multi-cloud solution which is currently supported by <strong>Pivotal Cloud Foundry</strong> (<strong>PCF</strong>), <strong>Pivotal Web Services</strong> (<strong>PWS</strong>), Atos Canary, SAP cloud platform, and IBM Bluemix among others. The platform is open source and hence can be used to set up your own private instance. JHipster provides a sub-generator to deploy JHipster applications to any Cloud Foundry provider easily. It makes use of the Cloud Foundry command line tool.</p>
<p class="mce-root">Visit <a href="http://www.jhipster.tech/cloudfoundry/">http://www.jhipster.tech/cloudfoundry/</a> for more info.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Amazon Web Services</h1>
                </header>
            
            <article>
                
<p><strong>Amazon Web Services</strong> (<strong>AWS</strong>) is the leading cloud computing platform that offers platform, software, and infrastructure as a service. AWS offers Elastic Beanstalk as a simple platform to deploy and manage your applications on the cloud. JHipster provides a sub-generator to deploy JHipster applications to AWS or Boxfuse (<a href="http://www.jhipster.tech/boxfuse">http://www.jhipster.tech/boxfuse</a>/), an alternative service. </p>
<p><span>Visit <a href="http://www.jhipster.tech/aws/">http://www.jhipster.tech/aws/</a> for more info.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Production deployment to Heroku cloud</h1>
                </header>
            
            <article>
                
<p>We need to choose a cloud provider. For this demo, let's choose Heroku.</p>
<div class="packt_infobox">Though the Heroku account is free and you get free credits, you will have to provide your credit card information to use MySQL and other add-ons. You will only be charged if you exceed the free quota.</div>
<p>Let's deploy our application to Heroku by completing the following steps:</p>
<ol>
<li>First, you need to create an account in Heroku (<a href="https://signup.heroku.com/">https://signup.heroku.com/</a>). It is free and you get free credits as well.  </li>
<li>Install the Heroku CLI tool by following  <a href="https://devcenter.heroku.com/articles/heroku-cli">https://devcenter.heroku.com/articles/heroku-cli</a>.</li>
<li>Verify that the Heroku CLI is installed fine by running <kbd>heroku --version</kbd>.</li>
</ol>
<p> </p>
<ol start="4">
<li>Login to Heroku by running <kbd>heroku login</kbd>. When prompted, enter your Heroku email and password.</li>
<li>Now run the <kbd>jhipster heroku</kbd> command. You will start seeing questions.</li>
<li>Choose a name you like when asked <span class="packt_screen">Name to deploy as: (store)</span>. By, default it will use the application name. Try to choose a unique name since the Heroku namespace is shared.</li>
<li>Next, you will be asked to choose a region<span>—</span><span class="packt_screen">On which region do you want to deploy?</span> Choose between US and EU, and proceed.</li>
<li>The generator will create the required files and accept changes suggested by the Gradle build files.</li>
</ol>
<p>The console output will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c22002f-f3e7-4535-bbd4-2c805f16922f.png"/></div>
<p>The generated <kbd>.yml</kbd> files add Heroku-specific configurations for the application. The <kbd>Procfile</kbd> contains the specific command that will be executed on Heroku for the application. The Gradle build is also modified to include dependencies required by Heroku.</p>
<p>After generating the files, it will build the application and will start uploading artifacts. This may take several minutes based on your network latency. Once this has been successfully completed, you should see the following screen:</p>
<div class="CDPAlignCenter CDPAlign"><img height="458" src="assets/eb2b31e1-4456-4b8d-83e1-4873bfc9d5ae.png" width="464"/></div>
<p>Now run the <kbd>heroku open</kbd> command to open the deployed application in a browser. That's it, you have successfully deployed your application to Heroku with a few commands.</p>
<p>When you update the application further, you can rebuild the package using <kbd>./gradlew -Pprod bootRepackage</kbd> and then redeploy it using the <kbd>heroku deploy:jar --jar build/libs/*war</kbd> command.</p>
<p>Don't forget to commit the changes made to <kbd>git</kbd> by executing the following command:</p>
<pre><strong>&gt; git add --all</strong><br/><strong>&gt; git commit -am "add heroku configuration"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Deployment to production is one of the most important phases of application development, and is the most crucial one as well. With the help of JHipster, we deployed our application to a cloud provider with ease. We also learned about Docker and the various other deployment options available. We also made use of the upgrade sub-generator to keep our application up-to-date with JHipster.</p>
<p><span>So far, we've seen how we can develop and deploy a monolithic e-commerce application using JHipster. We started with a monolith and, in the upcoming chapters, we will see how we can scale our application into a microservice architecture with the help of JHipster.  In the next chapter, we will learn about different microservice technologies and tools. So, stay tuned!</span></p>


            </article>

            
        </section>
    </body></html>