- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Writing Unit Tests in Angular with Jest
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest在Angular中编写单元测试
- en: '*“It works on my machine”* is a phrase that won’t lose its beauty with time.
    It is a shield for many engineers and a nightmare for the quality assurance professionals.
    But honestly, what’s a better way for your application’s robustness than writing
    tests? And when it comes to writing unit tests, my personal favorite is **Jest**.
    That is because it is super-fast, lightweight, and has an easy API to write tests.
    More importantly, it is faster than the Karma and Jasmine setup that comes out
    of the box with Angular. In this chapter, you’ll learn how to configure Jest with
    Angular to run these tests in parallel. You’ll learn how to test components, services,
    and pipes with Jest. You’ll also learn how to mock dependencies for these tests.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*“在我的机器上它运行正常”*这句话随着时间的推移仍不失其美感。它是许多工程师的盾牌，但对于质量保证专业人员来说却是一场噩梦。但说实话，还有什么比编写测试更好的方法来提高应用程序的健壮性呢？当谈到编写单元测试时，我个人最喜欢的工具是**Jest**。这是因为它超级快，轻量级，并且有易于使用的API来编写测试。更重要的是，它的速度比Angular自带的开箱即用的Karma和Jasmine设置要快。在本章中，您将学习如何配置Jest与Angular一起并行运行这些测试。您将学习如何使用Jest测试组件、服务和管道。您还将学习如何为这些测试模拟依赖项。'
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up unit tests in Angular with Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中使用Jest设置单元测试
- en: Providing global mocks for Jest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Jest提供全局模拟
- en: Mocking Angular services using stubs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根模拟Angular服务
- en: Using spies on an injected service in a unit test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中监视注入的服务
- en: Mocking child components and directives using the `ng-mocks` package
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ng-mocks`包模拟子组件和指令
- en: Writing even easier tests with Angular CDK component harnesses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CDK组件工具包编写更简单的测试
- en: Unit-testing components with observables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可观察对象进行单元测试组件
- en: Unit-testing Angular pipes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试Angular管道
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保您的设置已按照“Angular-Cookbook-2E”GitHub仓库中的“技术要求”完成。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter10)。
- en: Setting up unit tests in Angular with Jest
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest在Angular中设置单元测试
- en: By default, a new Angular project comes bundled with a lot of goodness, including
    the configuration and tooling in which to run unit tests with Karma and Jasmine.
    While working with Karma is relatively convenient, many developers find that in
    large-scale projects, the whole testing process becomes much slower if there are
    a lot of tests involved. This is mainly because you can’t run tests in parallel.
    In this recipe, we’ll set up Jest for unit testing in an Angular app. Additionally,
    we’ll migrate existing tests from the Karma syntax to the Jest syntax.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一个新的Angular项目包含了许多优点，包括配置和用于运行单元测试的工具，例如Karma和Jasmine。虽然使用Karma相对方便，但许多开发者在大型项目中发现，如果涉及大量测试，整个测试过程会变得非常缓慢。这主要是因为您不能并行运行测试。在本食谱中，我们将为Angular应用程序设置Jest进行单元测试。此外，我们将现有测试从Karma语法迁移到Jest语法。
- en: Starting with v16, Angular comes with a developer preview for Jest, and the
    process has become much easier. This recipe targets apps up to Angular v15 and
    covers what we can do in v16 at the end of the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从v16版本开始，Angular为Jest提供了开发者预览，这个过程变得更加简单。本食谱针对Angular v15及以下版本的应用程序，并在本章末尾介绍v16版本可以做什么。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-jest-setup`
    inside the cloned repository:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用程序位于克隆的仓库中的`start/apps/chapter10/ng-jest-setup`：
- en: Open the code repository in your code editor.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command in *step 2* is different from the rest of the recipes’ commands
    in this book. This is because the project for this recipe is *not* part of the
    NX workspace we have. It is a standalone Angular app itself; hence, it has different
    commands.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*步骤 2* 中的命令与本书中其他食谱的命令不同。这是因为本食谱的项目 *不是* 我们拥有的 NX 工作空间的一部分；它本身就是一个独立的 Angular
    应用；因此，它有不同的命令。'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_10_01.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_10_01.png)'
- en: 'Figure 10.1: The ng-jest-setup app running on http://localhost:4200'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.1：在 http://localhost:4200 上运行的 ng-jest-setup 应用
- en: 'Next, try to run the test and monitor how much time it takes for the entire
    process to run. Run the command `npm run test:ng-jest-setup` from the workspace
    `root`; within a few seconds, a new Chrome window should open, as follows:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，尝试运行测试并监控整个过程运行所需的时间。从工作区 `root` 运行命令 `npm run test:ng-jest-setup`；几秒钟内，应该会打开一个新的
    Chrome 窗口，如下所示：
- en: '![](img/B18469_10_02.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_10_02.png)'
- en: 'Figure 10.2: The tests’ results with Karma and Jasmine'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.2：使用 Karma 和 Jasmine 的测试结果
- en: Looking at the preceding screenshot, you might say *“Pfffttt, Ahsan, it says
    ‘finished in 0.033s (or something close to it)!’ What else do you want?”* Well,
    that time only covers how long it took Karma to run the tests *in the browser
    after the Chrome window was created*. It doesn’t count the time it took to start
    the process, start the Chrome window, and then load the tests. This could be improved
    by running the Chrome Headless browser for Karma, which requires some configuration.
    However, it is still slower compared to the alternative (Jest). Also, at the time
    of writing this recipe, I’m running this on a Macbook Pro with the M2 Chip, *which
    is fast*. That’s why we’re going to replace it with Jest. Now that you understand
    the issue, in the next section, let’s take a look at the steps of the recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看到前面的截图，你可能会说 *“Pfffttt，Ahsan，它说‘完成于 0.033s（或接近这个时间）！’你还需要什么？” 好吧，这个时间只涵盖了 Karma
    在创建 Chrome 窗口后运行测试所需的时间。它不包括启动过程、启动 Chrome 窗口以及加载测试所需的时间。这可以通过为 Karma 运行无头 Chrome
    浏览器来改进，这需要一些配置。然而，与替代方案（Jest）相比，它仍然较慢。此外，在编写此食谱时，我在 Macbook Pro 上运行此操作，*它很快*。这就是我们要用
    Jest 替换它的原因。现在，你已经了解了问题，在下一节中，让我们看看食谱的步骤。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we have an Angular app with a simple `Counter` component. It shows the
    value of the counter and has three action buttons: one of the buttons is to increase
    the value of the counter, one of them is to decrease the value, and another is
    to reset the value. Additionally, there are some tests written with Karma and
    Jasmine, and all of the tests will pass if you run the tests. We’ll start by setting
    up Jest instead. Perform the following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的 `Counter` 组件的 Angular 应用。它显示计数器的值，并有三个操作按钮：其中一个按钮用于增加计数器的值，另一个用于减少，另一个用于重置值。此外，还有一些使用
    Karma 和 Jasmine 编写的测试，如果你运行测试，所有测试都将通过。我们将首先设置 Jest。执行以下步骤：
- en: 'First, open a new Terminal window/tab, and make sure you’re inside the `start/apps/chapter10/ng-jest-setup`
    folder. Once inside, run the following command to install the packages that are
    required to test with Jest:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端窗口/标签页，确保你位于 `start/apps/chapter10/ng-jest-setup` 文件夹内。一旦进入，运行以下命令来安装测试
    Jest 所需的包：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now uninstall Karma and the unwanted dependencies. Now, run the following
    command in your Terminal:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以卸载 Karma 和不需要的依赖项。现在，在你的终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, update the test configuration in the `angular.json` file, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `angular.json` 文件中的测试配置，如下所示：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will now create a file to configure Jest for our project. Create a file
    named `jestSetup.ts` inside the project’s folder, and paste the following content
    inside:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个文件来配置 Jest 以用于我们的项目。在项目文件夹内创建一个名为 `jestSetup.ts` 的文件，并将以下内容粘贴进去：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s modify `tsconfig.spec.json` to use Jest instead of Jasmine. After
    the modification, your entire file should appear as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `tsconfig.spec.json` 文件，使用 Jest 而不是 Jasmine。修改后，你的整个文件应该如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll now modify `package.json` to add the `npm` scripts that’ll run the Jest
    tests:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将修改 `package.json` 文件，添加运行 Jest 测试的 `npm` 脚本：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let’s wrap up the entire configuration for our Jest tests by adding
    the Jest configuration in the `package.json` file, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过在 `package.json` 文件中添加 Jest 配置来完成我们 Jest 测试的整个配置，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have set everything up, simply run the `test` command from within
    the `ng-jest-setup` folder, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，只需在 `ng-jest-setup` 文件夹内运行 `test` 命令，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the tests are finished, you should be able to see the following output:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦测试完成，你应该能看到以下输出：
- en: '![](img/B18469_10_03.png)'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_03.png)'
- en: 'Figure 10.3: The results of the tests with Jest'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.3：使用 Jest 的测试结果
- en: Kaboom! You will notice that the entire process of running the tests with Jest
    takes about 6 seconds. It might take longer when you run it for the first time,
    but the subsequent runs should be faster. Now that you know how to configure an
    Angular app to use Jest for unit tests, please refer to the next section for resources
    in which to learn more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kaboom！你会注意到使用 Jest 运行测试的整个过程大约需要 6 秒。第一次运行时可能会更长，但后续的运行应该会更快。现在你已经知道如何配置 Angular
    应用程序以使用 Jest 进行单元测试，请参阅下一节以获取更多学习资源。
- en: 'Bonus: Migrating to Jest in Angular v16'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奖励：将 Angular v16 迁移到 Jest
- en: 'Starting from Angular v16, all you need to do to migrate to Jest (considering
    your project currently uses Karma) is to update the `angular.json` file in the
    project with the following configuration object property hierarchy `your-app >
    architect > test` settings:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular v16 开始，要将项目迁移到 Jest（假设你的项目目前使用 Karma），你只需要更新项目中的 `angular.json` 文件，并使用以下配置对象属性层次结构
    `your-app > architect > test` 设置：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Testing Web Frameworks with Jest: [https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 测试 Web 框架：[https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks)
- en: 'Getting Started with Jest: [https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 入门：[https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)
- en: 'Moving Angular CLI to Jest: [https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca](https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Angular CLI 迁移到 Jest：[https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca](https://blog.angular.io/moving-angular-cli-to-jest-and-web-test-runner-ef85ef69ceca)
- en: Providing global mocks for Jest
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Jest 提供全局模拟
- en: In the previous recipe, we learned how to set up Jest for Angular unit tests.
    There might be some scenarios in which you’d want to use a browser API that might
    not be part of your actual Angular code – for instance, using `LocalStorage` or
    `alert`. In such cases, we need to provide some global mocks for the functions
    that we want to return mock values from. This is so that we can perform tests
    involving them as well. In this recipe, you’ll learn how to provide global mocks
    to Jest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们学习了如何为 Angular 单元测试设置 Jest。可能会有一些场景，你想要使用浏览器 API，而这些 API 可能不是你的实际
    Angular 代码的一部分——例如，使用 `LocalStorage` 或 `alert`。在这种情况下，我们需要为那些我们想要返回模拟值的函数提供一些全局模拟。这样我们就可以测试涉及它们的测试了。在这个菜谱中，你将学习如何为
    Jest 提供全局模拟。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-jest-global-mocks`
    inside the cloned repository:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter10/ng-jest-global-mocks`：
- en: Open the code repository in your code editor.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该能看到以下内容：
- en: '![](img/B18469_10_04.png)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_04.png)'
- en: 'Figure 10.4: The ng-jest-global-mocks app running on http://localhost:4200'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.4：在 http://localhost:4200 上运行的 ng-jest-global-mocks 应用程序
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，在下一节中，让我们来回顾一下菜谱的步骤。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The app we’re using for this recipe uses two global APIs: `window.localStorage`
    and `window.alert`. Note that when the app starts, we get the counter value from
    `LocalStorage`, and then upon increment, decrement, and reset, we store it in
    `LocalStorage`. When the counter value becomes greater than the `MAX_VALUE` or
    lower than the `MIN_VALUE`, we show the alert using the `alert` method. Let’s
    begin the recipe by writing some cool unit tests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个菜谱中使用的应用程序使用了两个全局 API：`window.localStorage` 和 `window.alert`。请注意，当应用程序启动时，我们从
    `LocalStorage` 获取计数器值，然后在增加、减少和重置时，我们将其存储在 `LocalStorage` 中。当计数器值大于 `MAX_VALUE`
    或小于 `MIN_VALUE` 时，我们使用 `alert` 方法显示警告。让我们通过编写一些酷炫的单元测试来开始这个菜谱：
- en: 'First, we’ll write our test cases to show the alert when the counter value
    goes beyond `MAX_VALUE` and `MIN_VALUE`. Modify the `counter.component.spec.ts`
    file as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写测试用例以显示当计数器的值超过 `MAX_VALUE` 和 `MIN_VALUE` 时会弹出警告。修改 `counter.component.spec.ts`
    文件，如下所示：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you can see that the tests pass but with a bunch of console errors. And
    what if we wanted to check whether the value from `LocalStorage` is being saved
    and retrieved properly?
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到测试通过了，但伴随着大量的控制台错误。那么，如果我们想检查从 `LocalStorage` 保存和检索的值是否正确呢？
- en: 'We’ll create a new test to make sure the `localStorage.getItem` method is called
    to retrieve the last saved value from the `LocalStorageAPI`. Add the test to the
    `counter.component.spec.ts` file, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的测试来确保 `localStorage.getItem` 方法被调用以从 `LocalStorageAPI` 获取最后保存的值。将测试添加到
    `counter.component.spec.ts` 文件中，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that we’re using `it.only` for this test case. This is to ensure that
    we’re only running this test (for now). If you run the tests, you should be able
    to see something like the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到我们在这个测试用例中使用了 `it.only`。这是为了确保我们现在只运行这个测试。如果你运行测试，你应该能看到以下截图中的内容：
- en: '![](img/B18469_10_05.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B18469_10_05.png](img/B18469_10_05.png)'
- en: 'Figure 10.5: The test that covers the LocalStorageAPI has failed'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.5：覆盖 LocalStorageAPI 的测试失败了
- en: 'Notice the **Matcher error: received value must be a mock or a spy function**
    message. This is what we’re going to do next, that is, provide a mock.'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到 **匹配器错误：接收到的值必须是一个模拟或间谍函数** 的消息。这就是我们接下来要做的，也就是提供一个模拟。
- en: 'Create a file inside the project’s `src` folder, and name the file `jest-global-mocks.ts`.
    Then, add the following code to mock the `LocalStorageAPI`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的 `src` 文件夹内创建一个文件，并将其命名为 `jest-global-mocks.ts`。然后，添加以下代码来模拟 `LocalStorageAPI`：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, import this file into the `src/test-setup.ts` file, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此文件导入到 `src/test-setup.ts` 文件中，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if you rerun the tests, they should pass.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你重新运行测试，它们应该会通过。
- en: 'Let’s add another test to ensure we retrieve the last saved value from `LocalStorage`
    in the component initiation. Modify the `counter.component.spec.ts` file, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试以确保在组件初始化时从 `LocalStorage` 中检索最后保存的值。修改 `counter.component.spec.ts`
    文件，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let’s make sure that we save the counter value to `LocalStorage` whenever
    we trigger the `increment`, `decrement`, or `reset` methods. Update the `counter.component.spec.ts`
    as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们确保在触发 `increment`、`decrement` 或 `reset` 方法时，将计数器的值保存到 `LocalStorage` 中。更新
    `counter.component.spec.ts` 文件，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Awesomesauce! You’ve just learned how to provide global mocks to Jest for testing.
    Please refer to the next section to understand how this works.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经学会了如何为 Jest 测试提供全局模拟。请参考下一节了解这是如何工作的。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Jest provides a way to define global mocks for tests. It comes with a lot of
    built-in functions to define test suites and test cases, along with assertion
    functions. Here is an example of a simple Jest test suite for a `sum` function
    that adds two numbers:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 提供了一种为测试定义全局模拟的方法。它自带了许多内置函数来定义测试套件和测试用例，以及断言函数。以下是一个简单的 Jest 测试套件示例，用于测试一个
    `sum` 函数，该函数用于将两个数字相加：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Jest also has a way to use a particular file to set up Jest in projects. When
    working with different frameworks, the file (or the filename) can be different,
    but the purpose would still be the same, that is, to define global configuration
    via this Jest setup file. In our NX workspace, we already have the Jest files
    in each project under the `src` folder, and the filename is usually `test-setup.ts`.
    One of the common approaches to define global mocks is to create a new file containing
    the mocks and then import it into the `test-setup.ts` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 还有一种方法可以在项目中使用特定的文件来设置 Jest。当与不同的框架一起工作时，文件（或文件名）可能不同，但目的仍然是相同的，即通过这个 Jest
    设置文件定义全局配置。在我们的 NX 工作区中，我们已经在每个项目的 `src` 文件夹下创建了 Jest 文件，文件名通常是 `test-setup.ts`。定义全局模拟的一种常见方法是为模拟创建一个新的文件，然后将其导入到
    `test-setup.ts` 文件中。
- en: Notice that we use the `Object.defineProperty` method in the `window` object
    to provide a mock implementation for the `LocalStorage` object, and we do similar
    for the `window.alert` mock. This is actually the same for any API that is not
    implemented in the **JSDOM**(**JavaScript Document Object Model**). Similarly,
    you can provide a global mock for each API that you use in your tests. Notice
    that in the `value` property, we create a new instance of the `LocalStorageMock`
    class using the `new` keyword. Essentially, this is one way to define mocks. We
    create the `LocalStorageMock` class, and in that, we have a private property named
    `storage` that mimics the `localStorage` object. We have also defined the `getItem`
    and `setItem` methods in there so that we can set values to this storage and get
    values from it. Notice that we do not have the implementations of the `removeItem`
    and `clear` methods that we have in the actual `localStorage` API. We don’t have
    to have them because we’re not using these methods in our actual code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Object.defineProperty`方法在`window`对象中为`LocalStorage`对象提供模拟实现，并且我们对`window.alert`模拟也做了类似处理。这实际上适用于任何未在**JSDOM**（**JavaScript
    Document Object Model**）中实现的自定义API。同样，你可以为你在测试中使用的每个API提供一个全局模拟。注意，在`value`属性中，我们使用`new`关键字创建`LocalStorageMock`类的新实例。本质上，这是定义模拟的一种方法。我们创建了`LocalStorageMock`类，在其中有一个名为`storage`的私有属性，它模拟了`localStorage`对象。我们还在其中定义了`getItem`和`setItem`方法，以便我们可以向此存储设置值并从中获取值。注意，我们没有实现`removeItem`和`clear`方法，这些方法在实际的`localStorage`
    API中是有的。我们不需要它们，因为我们实际上没有使用这些方法。
- en: In the `should call the localStorage.getItem method on component init` test,
    we simply spy on the `localStorage` object’s `getItem` method, call the `ngOnInit`
    method ourselves, and then expect it to have been called. *Easy peasy!*
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`should call the localStorage.getItem method on component init`测试中，我们简单地监视`localStorage`对象的`getItem`方法，自己调用`ngOnInit`方法，然后期望它已经被调用。*简单易行!*
- en: In the `should retrieve the last saved value from localStorage on component
    init` test, we save a value in the `localStorage` object for the counter value
    as `12`, using the `setItem` method. Essentially, calling the `setItem` method
    calls our mock implementation method and not the actual `localStorage` API’s `setItem`
    method. Notice that, here, we *do not* spy on the `getItem` method; this is because,
    later on, we want the value of the component’s `counter` property to be `12`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`should retrieve the last saved value from localStorage on component init`测试中，我们使用`setItem`方法在`localStorage`对象中为计数器的值保存`12`。本质上，调用`setItem`方法调用的是我们的模拟实现方法，而不是实际的`localStorage`
    API的`setItem`方法。注意，在这里，我们没有对`getItem`方法进行监视；这是因为，稍后我们希望组件的`counter`属性的值为`12`。
- en: IMPORTANT NOTE
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Whenever we spy on a method, remember that any statements in the actual function
    will no longer be executed. This is why we do not spy on the `getItem` method
    in the preceding test. If we do so, the `getItem` method from the mock implementation
    will not return anything. Therefore, our expected value for the counter property
    will not be `12`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们监视一个方法时，请记住，实际函数中的任何语句将不再执行。这就是为什么我们不会在先前的测试中监视`getItem`方法。如果我们这样做，模拟实现中的`getItem`方法将不会返回任何内容。因此，我们对计数器属性的预期值将不会是`12`。
- en: Put simply, if you have to rely on the outcome of a function’s implementation,
    or the statements executed within a function, do not spy on that function and
    replace such a function with `jest.fn().mockReturnValue(123);`. This ensures we
    can check if the function is called but also with a return value that can be used
    by the actual code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你必须依赖于函数实现的输出，或者函数内部执行的语句，不要监视该函数，并用`jest.fn().mockReturnValue(123);`替换该函数。这确保了我们不仅可以检查函数是否被调用，还可以使用实际的代码使用返回值。
- en: 'PS: I always end up learning this the hard way after debugging and bashing
    my head for a while.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PS：我总是在调试和敲打了一段时间的头之后，才艰难地学到这一点。
- en: The final test is an easy one. In the `should save the new counterValue to localStorage
    on increment, decrement and reset` test, we spy on the `setItem` method. Then,
    we manually set the value of the counter property each time before we run the
    `increment`, `decrement`, and `reset` methods respectively. Additionally, we expect
    the `setItem` method to have been called with the right arguments to save the
    value to the store. Note that we do not check the store’s value after saving it.
    As I mentioned earlier, since we have spied on the `setItem` method, its internal
    statement won’t trigger and the value won’t be saved; therefore, we can’t retrieve
    the saved value afterward.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的测试非常简单。在 `should save the new counterValue to localStorage on increment,
    decrement and reset` 测试中，我们监视 `setItem` 方法。然后，在分别运行 `increment`、`decrement` 和
    `reset` 方法之前，我们手动设置计数器属性的值。此外，我们期望 `setItem` 方法使用正确的参数被调用以保存值到存储中。注意，我们在保存后不检查存储的值。如我之前提到的，因为我们监视了
    `setItem` 方法，其内部语句不会触发，因此值不会被保存；因此，我们之后无法检索保存的值。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The Jest documentation for `setupFiles`: [https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setupFiles` 的 Jest 文档：[https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array)'
- en: 'Manual Mocks with Jest: [https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 进行手动模拟：[https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks)
- en: Mocking Angular services using stubs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根模拟 Angular 服务
- en: There’s rarely an Angular app that doesn’t have a **Service** created inside
    it. And where overall business logic is concerned, services hold a great deal,
    particularly when it comes to interacting with APIs. In this recipe, you’ll learn
    how to mock services using stubs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有 Angular 应用程序在其内部没有创建一个 **服务**。在整体业务逻辑方面，服务承载了大量的内容，尤其是在与 API 交互时。在这个食谱中，你将学习如何使用存根模拟服务。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-services-stubs`
    inside the cloned repository:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用程序位于克隆的仓库 `start/apps/chapter10/ng-test-services-stubs` 内：
- en: Open the code repository in your code editor.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_10_06.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_06.png)'
- en: 'Figure 10.6: The ng-test-services-stubs app running on http://localhost:4200'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.6：ng-test-services-stubs 应用在 http://localhost:4200 上运行
- en: Now that we have the app running locally, in the next section, let’s take a
    look at the steps of the recipe.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用程序，在下一节中，让我们看看食谱的步骤。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have the same application as the previous recipe; however, we’ve moved the
    logic of saving and retrieving data from `localStorage` to the `CounterService`
    we’ve created. Now, all the tests are passing. However, what if we wanted to hide/encapsulate
    the logic of where the counter value is stored? Perhaps we want to send a backend
    API call for it. To do this, it makes more sense to test that our `CounterService`''s
    methods are being called instead of checking `localStorage` methods. Let’s follow
    the recipe to provide a mock stub for our service:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有与之前食谱相同的应用程序；然而，我们将保存和检索数据的逻辑从 `localStorage` 移动到了我们创建的 `CounterService`。现在，所有测试都通过了。但是，如果我们想隐藏/封装计数器值存储的逻辑呢？也许我们想为此发送后端
    API 调用。为此，测试我们的 `CounterService` 的方法是否被调用比检查 `localStorage` 方法更有意义。让我们按照食谱为我们的服务提供一个模拟存根：
- en: 'First, let’s create a folder inside the `src` folder, named `__mocks__`. Inside
    it, create another folder named `services`. Then, again inside this folder, create
    the `counter.service.mock.ts` file with the following content:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `src` 文件夹内创建一个名为 `__mocks__` 的文件夹。在其内部，创建一个名为 `services` 的文件夹。然后，再次在这个文件夹内部，创建一个名为
    `counter.service.mock.ts` 的文件，并包含以下内容：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, provide the mock service instead of the actual service in the `counter.component.spec.ts`,
    as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `counter.component.spec.ts` 中，用模拟服务代替实际服务，如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the preceding change, you should see the following error that says the
    `localStorage.getItem` hasn’t been called. This is because we’re now spying on
    the methods on our mock stub for the service:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着前面的更改，你应该会看到以下错误，表明 `localStorage.getItem` 没有被调用。这是因为我们现在正在监视我们服务模拟存根上的方法：
- en: '![](img/B18469_10_07.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_07.png)'
- en: 'Figure 10.7: localStorage.getItem is not called because of the methods being
    spied on'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.7：由于监视的方法，`localStorage.getItem`没有被调用
- en: 'Now, instead of expecting the `localStorage` object’s methods to be called,
    let’s expect our service’s methods to be called in our tests. Update the `counter.component.spec.ts`
    file using the snippet at [https://ng-cookbook.com/s/services-stub-tests](https://ng-cookbook.com/s/services-stub-tests)
    to replace all the tests below the following comment:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，不要期望在测试中调用`localStorage`对象的`methods`，而是期望调用我们服务的`methods`。使用以下代码片段更新`counter.component.spec.ts`文件，以替换以下注释下面的所有测试：[https://ng-cookbook.com/s/services-stub-tests](https://ng-cookbook.com/s/services-stub-tests)
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Great! You now know how to mock services to test components with service dependencies.
    Please refer to the next section to understand how it all works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在知道如何模拟服务来测试具有服务依赖的组件。请参阅下一节了解这一切是如何工作的。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Providing stubs for Angular services is already a breeze. This is thanks to
    Angular’s out-of-the-box methods and tooling from the `@angular/core` package,
    especially `@angular/core/testing`. First, we create the stub for our `CounterService`
    and use `jest.fn` for every method within `CounterService`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为Angular服务提供存根已经变得非常简单。这要归功于Angular的内置方法和来自`@angular/core`包的工具，特别是`@angular/core/testing`。首先，我们为我们的`CounterService`创建存根，并在`CounterService`中的每个方法中使用`jest.fn`。
- en: 'Calling `jest.fn` returns a new, unused mock function that Jest automatically
    spies upon as well. Optionally, we can also pass a mock implementation method
    as a parameter for `jest.fn`. View the following example from the official documentation
    for `jest.fn`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`jest.fn`返回一个新的、未使用的模拟函数，Jest会自动监视它。可选地，我们还可以将模拟实现方法作为参数传递给`jest.fn`。查看以下来自官方文档的`jest.fn`示例：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we create the stub, we pass it to the `TestBed` configuration in the provider’s
    array against the `CounterService` – but with the `useValue` property set to the
    `counterServiceMock`. This tells Angular to use our stub as it is for `CounterService`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了存根，我们就将其传递给`TestBed`配置中的提供者数组中的`CounterService` - 但将`useValue`属性设置为`counterServiceMock`。这告诉Angular使用我们的存根作为`CounterService`。
- en: 'Then, in the test where we expect `CounterService.getFromStorage` method to
    be called when the component initiates, we use the following statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在期望组件初始化时调用`CounterService.getFromStorage`方法的测试中，我们使用以下语句：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that in the preceding code, we are able to directly use `expect` on `counterServiceMock.getFromStorage`.
    While this isn’t possible in Karma and Jasmine, it is possible with Jest, since
    we’re using `jest.fn` for each underlying method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的代码中，我们能够直接在`counterServiceMock.getFromStorage`上使用`expect`。虽然这在Karma和Jasmine中是不可能的，但使用Jest时是可能的，因为我们为每个底层方法使用了`jest.fn`。
- en: 'Then, for a test in which we want to check whether the `getFromStorage` method
    is called and returns a saved value, we first use the `counterServiceMock.getFromStorage.mockReturnValue(12);`
    statement. This ensures that when the `getFromStorage` method is called, it returns
    the value of `12`. Then, we just run the `ngOnInit` method in the test and expect
    that our component’s counter property has now been set to `12`. This means that
    the following things happen:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于想要检查`getFromStorage`方法是否被调用并返回保存值的测试，我们首先使用`counterServiceMock.getFromStorage.mockReturnValue(12);`语句。这确保了当调用`getFromStorage`方法时，它返回`12`的值。然后，我们只需在测试中运行`ngOnInit`方法，并期望组件的计数器属性现在已设置为`12`。这意味着以下事情发生了：
- en: '`ngOnInit` calls the `getFromStorage` method.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ngOnInit`调用`getFromStorage`方法。'
- en: '`getFromStorage` returns the previously saved value (in our case, that’s `12`,
    but in reality, it’ll be fetched from `localStorage`).'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getFromStorage`返回之前保存的值（在我们的例子中，这是`12`，但在现实中，它将从`localStorage`中获取）。'
- en: The component’s counter property is set to the retrieved value, which, in our
    case, is `12`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件的计数器属性被设置为检索到的值，在我们的例子中是`12`。
- en: 'Now, for the final test, we just expect that the `saveToStorage` method of
    our `CounterService` is called in each necessary case. For this, we use the following
    types of `expect` statements:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于最后的测试，我们只需期望在每种必要情况下调用`CounterService`的`saveToStorage`方法。为此，我们使用以下类型的`expect`语句：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s pretty much about it. Unit tests are fun, aren’t they? Now that you’ve
    understood how it all works, please refer to the next section for some helpful
    resources that you can use for further reading.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是全部内容。单元测试很有趣，不是吗？现在你已经了解了这一切是如何工作的，请参阅下一节，了解一些有用的资源，你可以用来进一步阅读。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The official documentation for `jest.fn`: [https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.fn`的官方文档：[https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)'
- en: 'Angular’s *Component testing scenarios*: [https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的*组件测试场景*：[https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)
- en: Using spies on an injected service in a unit test
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单元测试中监视注入的服务
- en: While you can provide stubs for your services in the unit tests with Jest, sometimes,
    it might feel like an overhead creating a mock for every new service. Let’s suppose
    that if the service’s usage is limited to one test file, it might make more sense
    to just use spies on the actual injected service. In this recipe, that’s exactly
    what we’re going to do.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在单元测试中使用Jest为你的服务提供存根，但有时，为每个新的服务创建存根可能会感觉像是一种负担。让我们假设，如果服务的使用仅限于一个测试文件，那么在注入的实际服务上使用间谍可能更有意义。在这个配方中，我们正是要这么做。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-services`
    inside the cloned repository:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用位于克隆的仓库中的`start/apps/chapter10/ng-test-services`：
- en: Open the code repository in your code editor.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE25]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_10_08.png)'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_08.png)'
- en: 'Figure 10.8: ng-test-services app running on http://localhost:4200'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.8：ng-test-services应用在http://localhost:4200上运行
- en: Now that we have the app running, in the next section, let’s go through the
    steps of the recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了运行中的应用，在下一节中，让我们通过配方的步骤。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We have an application that has a `Counter` component. We can increment, decrement,
    and reset the counter, and the value for the counter changes. The value is also
    stored in the `localStorage`. We have the logic of saving and retrieving data
    from `localStorage` to the `CounterService`. Now, all the tests are passing, but
    we are checking the values in our tests directly from the `localStorage`. What
    if we decided to change the logic of where the counter value is stored? Perhaps
    we want to send a backend API call for it. To do this, it makes more sense to
    test that our `CounterService`''s methods are being called instead of checking
    `localStorage` methods. However, unlike the previous recipe, where we provided
    stubs for our services, we’re going to inject the service directly and will create
    jest spies for the functions from the Angular Service that we want to ensure are
    being called. Let’s follow the recipe to do that:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含`Counter`组件的应用。我们可以增加、减少和重置计数器，计数器的值也会改变。这个值也存储在`localStorage`中。我们有从`localStorage`到`CounterService`保存和检索数据的逻辑。现在，所有的测试都通过了，但我们直接从`localStorage`检查测试中的值。如果我们决定改变计数器值存储的逻辑呢？也许我们想要为它发送后端API调用。为此，测试我们的`CounterService`的方法是否被调用比检查`localStorage`方法更有意义。然而，与之前提供的为我们的服务提供存根的配方不同，我们将直接注入服务，并为我们要确保被调用的Angular服务中的函数创建jest间谍。让我们按照配方来做：
- en: 'Open the `counter.component.spec.ts` file. You’ll see a comment that says `//
    replace the tests below`. Let’s replace the first test `should call the localStorage.getItem
    method on component init` below that comment with the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`counter.component.spec.ts`文件。你将看到一个注释说`// 替换下面的测试`。让我们在那个注释下面替换第一个测试`should
    call the localStorage.getItem method on component init`，替换为以下内容：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you run `npm run test` again, you should still see all the tests passing.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你再次运行`npm run test`，你应该仍然看到所有测试都通过了。
- en: 'Now, let’s replace the test that says `should retrieve the last saved value
    from localStorage on component init` with the following test:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将测试替换为“在组件初始化时从localStorage检索最后保存的值”的测试，替换为以下测试：
- en: '[PRE27]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, replace the last test that says `should save the new counterValue
    to localStorage on increment, decrement and reset` with the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将最后一个测试“在增加、减少和重置时将新的counterValue保存到localStorage”替换为以下代码：
- en: '[PRE28]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Awesome! With this change, you should see all eight tests passing. Let’s take
    a look at the next section to understand how it works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过这个更改，你应该看到所有八个测试都通过了。让我们看看下一节，了解它是如何工作的。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe contained a lot of knowledge from the previous recipes of this chapter.
    However, the key highlight is the fact that the `CounterService` class that is
    injected in the component can only be directly mocked using the `jest.spyOn` method.
    This method removes the need to mock every single service separately. In the first
    (replaced) test, we spy on the `getFromStorage` method of the `component.counterService`
    property. This makes it a Jest spy that we can provide to the `expect` block and
    that can run the `expect(component.counterService.getFromStorage).toHaveBeenCalled();`
    statement. In the second test, notice that we not only spy on the `getFromStorage`
    method but also return a mock value, `12`, so that when the `component.ngOnInit`
    method is called, the value returned from the `CounterService` is this mocked
    value, `12`. Hence, the `counter` property is set to 12 and the test passes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱包含了本章之前食谱中的很多知识。然而，关键亮点是注入到组件中的`CounterService`类只能通过`jest.spyOn`方法直接模拟。这种方法消除了需要单独模拟每个服务的需求。在第一个（已替换）测试中，我们监视`component.counterService`属性的`getFromStorage`方法。这使得它成为一个Jest监视器，我们可以将其提供给`expect`块，并运行`expect(component.counterService.getFromStorage).toHaveBeenCalled();`语句。在第二个测试中，请注意，我们不仅监视了`getFromStorage`方法，还返回了一个模拟值`12`，这样当`component.ngOnInit`方法被调用时，从`CounterService`返回的值就是这个模拟值`12`。因此，`counter`属性被设置为12，测试通过。
- en: Finally, in the last test, we spy on the `saveToStorage` method. Then, every
    time we click `Increment`, `Decrement`, or `Reset`, we expect the spied function
    to be called with the correct value. *Easy peasy!*
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后一个测试中，我们监视`saveToStorage`方法。然后，每次我们点击`Increment`、`Decrement`或`Reset`时，我们期望被监视的函数以正确的值被调用。*简单易行！*
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Testing Angular Services: [https://angular.io/guide/testing-services](https://angular.io/guide/testing-services)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Angular服务：[https://angular.io/guide/testing-services](https://angular.io/guide/testing-services)
- en: Mocking child components and directives using the ng-mocks package
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ng-mocks包模拟子组件和指令
- en: Unit tests mostly revolve around testing components, directives, pipes, or services
    in isolation. However, what if your component depends completely on another component
    or directive to work properly, especially in a non-standalone application/component?
    In such cases, you usually provide a mock implementation for the component, but
    that is a lot of work. However, with the `ng-mocks` package, it is super-easy.
    In this recipe, we’ll learn an advanced example of how to use `ng-mocks` for a
    parent component that depends on a child component to work properly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试主要围绕测试组件、指令、管道或服务进行。然而，如果你的组件完全依赖于另一个组件或指令才能正常工作，尤其是在一个非独立应用程序/组件中，会怎样呢？在这种情况下，你通常会提供一个模拟实现来模拟组件，但这需要大量的工作。然而，使用`ng-mocks`包，这变得非常简单。在这个食谱中，我们将学习如何使用`ng-mocks`来模拟一个依赖于子组件才能正常工作的父组件的高级示例。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-ng-mocks`
    inside the cloned repository:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要工作的应用程序位于克隆的仓库中的`start/apps/chapter10/ng-test-ng-mocks`目录下：
- en: Open the code repository in your code editor.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来启动项目：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_10_09.png)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_09.png)'
- en: 'Figure 10.9: ng-test-ng-mocks app running on http://localhost:4200'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.9：ng-test-ng-mocks应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用程序，在下一节中，让我们来了解一下食谱的步骤。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'If you run the command `npm run test ng-test-ng-mocks` from the workspace root,
    you’ll see that not all of our tests pass. Additionally, there are a bunch of
    errors on the console, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从工作区根目录运行命令`npm run test ng-test-ng-mocks`，你会看到并非所有我们的测试都通过。此外，控制台还有一大堆错误，如下所示：
- en: '![](img/B18469_10_10.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_10_10.png)'
- en: 'Figure 10.10: Error during unit tests mentioning app-version-control component'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：单元测试中提到app-version-control组件时的错误
- en: 'Note that we are using an app with `NgModule`, i.e., *not a standalone app*.
    This is to demonstrate how to work in such situations. Let’s go through the recipe
    to mock the respective components using the `ng-mocks` package:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用一个带有`NgModule`的应用程序，即**不是一个独立的应用程序**。这是为了演示如何在这样的情况下工作。让我们通过食谱来模拟相应的组件，使用`ng-mocks`包：
- en: 'First, let’s install the `ng-mocks` package within our project. To do this,
    run the following command from your project root in the Terminal:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的项目中安装`ng-mocks`包。为此，从终端中运行以下命令，从项目根目录开始：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we’ll try to fix the tests for the `App` component. To only run specific
    tests based on a string regex, we can use the -`t` parameter with the test command.
    Run the following command, and after it runs, press the -`t` key to provide the
    regex `"``App"`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试修复`App`组件的测试。要基于字符串正则表达式仅运行特定测试，我们可以使用测试命令的-`t`参数。运行以下命令，运行后按-`t`键提供正则表达式`"``App"`：
- en: '[PRE31]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you can see that we only run the tests for `AppComponent`, and they fail
    as follows:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你可以看到我们只运行了`AppComponent`的测试，并且它们失败了如下：
- en: '![](img/B18469_10_11.png)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_10_11.png)'
- en: 'Figure 10.11: Only running specific tests'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.11：仅运行特定测试
- en: 'To fix the error shown in *Figure 10.10*, we’ll import `VersionControlComponent`
    into the `TestBed` definition inside the `app.component.spec.ts` file. This is
    so that our test environment also knows the missing `<app-version-control>` component.
    To do this, modify the file as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修复*图10.10*中显示的错误，我们需要将`VersionControlComponent`导入到`app.component.spec.ts`文件中的`TestBed`定义内部。这样做是为了让我们的测试环境也知道缺失的`<app-version-control>`组件。为此，按照以下方式修改文件：
- en: '[PRE32]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you rerun the tests for `AppComponent`, you’ll see some fresher and newer
    errors. Progress! But since we have the `Version Control` component dependent
    on another component, the tests don’t pass. We’ll discuss why this is in more
    detail in the *How it works...* section. However, to fix this, let’s follow the
    next steps.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你重新运行`AppComponent`的测试，你会看到一些更新鲜、更新的错误。进展！但是，由于`Version Control`组件依赖于另一个组件，测试没有通过。我们将在*如何工作...*部分更详细地讨论这是为什么。然而，为了修复这个问题，让我们按照以下步骤进行。
- en: 'Instead of providing the `VersionControlComponent` directly, we need to mock
    it, since we don’t really care about it for the tests for `AppComponent`. One
    way would be to use `CUSTOM_ELEMENT_SCHEMA` in the `TestBed`''s configuration
    to tell the test bed that we don’t really care about the `VersionControlComponent`
    inside the tests for `AppComponent`. However, we’re going to use a `MockComponent`
    from `ng-mocks` to mock the component, achieving the same outcome. To do this,
    update the `app.component.spec.ts` file as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们并不关心`AppComponent`测试中的`VersionControlComponent`，所以我们需要对其进行模拟。一种方法是在`TestBed`的配置中使用`CUSTOM_ELEMENT_SCHEMA`来告诉测试床我们并不关心`AppComponent`测试中的`VersionControlComponent`。然而，我们将使用`ng-mocks`中的`MockComponent`来模拟组件，以达到相同的效果。为此，按照以下方式更新`app.component.spec.ts`文件：
- en: '[PRE33]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Boom! Problem solved. Run the tests again, just for the `AppComponent`, and
    you should see them all pass as follows:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嘣！问题解决。再次运行测试，仅针对`AppComponent`，你应该会看到它们都通过如下：
- en: '![](img/B18469_10_12.png)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_10_12.png)'
- en: 'Figure 10.12: Passing all of the tests for App component'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B18469_10_12.png)'
- en: Press the *a* key in the terminal to run all tests again.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中按*a*键再次运行所有测试。
- en: 'Now, let’s talk about the tests for the `Version Control` component. This depends
    on the `VC Logs` component. Let’s mock the `VCLogsComponent` class like a pro
    this time, using the `MockBuilder` and `MockRender` methods, so we can get rid
    of the errors during the tests. After the update, the `version-control.component.spec.ts`
    file should appear as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈`Version Control`组件的测试。这依赖于`VC Logs`组件。这次，让我们像专业人士一样模拟`VCLogsComponent`类，使用`MockBuilder`和`MockRender`方法，这样我们就可以在测试期间消除错误。更新后，`version-control.component.spec.ts`文件应该如下所示：
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you run `npm run test` now, you should see all of the tests passing. Let’s
    write another test in the next step.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在运行`npm run test`，你应该会看到所有的测试都通过了。接下来，让我们在下一步写另一个测试。
- en: '`VersionControlComponent` uses `VCLogsComponent` as a child component in the
    template. Additionally, it provides the `vName` property as `@Input()` to `VCLogsComponent`,
    via the `[vName]` attribute. We can check whether the input’s value is set correctly.
    To do so, update the `version-control.component.spec.ts` file, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VersionControlComponent`在模板中将`VCLogsComponent`用作子组件。此外，它通过`[vName]`属性将`vName`属性作为`@Input()`提供给`VCLogsComponent`。我们可以检查输入值是否设置正确。为此，按照以下方式更新`version-control.component.spec.ts`文件：'
- en: '[PRE35]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are now going to modify the `vc-logs.component.spec.ts` file to make sure
    that when the `vName` changes inside the `VCLogsComponent`, we have a new log
    created inside the `logs` array. To do so, modify the file as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改`vc-logs.component.spec.ts`文件，以确保当`VCLogsComponent`中的`vName`发生变化时，在`logs`数组中创建一个新的日志。为此，按照以下方式修改文件：
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Boom! We have implemented some interesting tests by using the `ng-mocks` package.
    I absolutely love it every time I use it (mostly with components that are part
    of an `NgModule`, as `standalone` components don’t have this issue). Now that
    we’ve finished the recipe, in the next section, let’s take a look at how it all
    works.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 嘣！我们已经通过使用`ng-mocks`包实现了一些有趣的测试。每次我使用它时，我都非常喜欢（通常与`NgModule`中的组件一起使用，因为`standalone`组件没有这个问题）。现在我们已经完成了配方，在下一节中，让我们看看这一切是如何工作的。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a couple of interesting things that we have covered in this recipe.
    First, to avoid any errors on the console complaining about unknown components,
    we use the `MockComponent` method from the `ng-mocks` package, declaring the components
    we’re dependent on as mocks. Notice that when a component is mocked, it loses
    its functionality, as all the methods become `spy` functions. That is absolutely
    the simplest thing we can achieve with the `ng-mocks` package. However, we will
    move on to an advanced situation, which I will admit is sort of an unconventional
    approach, that is, testing the `@Input` properties and `@Output` emitters of the
    child components in the parent component in order to test an entire flow. This
    is what we do for the tests of `VersionControlComponent` by checking the value
    of an `@Input` property `vName`. Again, this is mostly useful for non-standalone
    components.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们涵盖了一些有趣的事情。首先，为了避免控制台上的任何错误，抱怨未知组件，我们使用来自`ng-mocks`包的`MockComponent`方法，将我们依赖的组件声明为模拟。请注意，当一个组件被模拟时，它会失去其功能，因为所有的方法都变成了`spy`函数。这正是我们可以用`ng-mocks`包实现的简单事情。然而，我们将继续到一个更高级的情况，我必须承认这是一种相当不寻常的方法，即测试父组件中子组件的`@Input`属性和`@Output`发射器，以便测试整个流程。这就是我们通过检查`@Input`属性`vName`的值来测试`VersionControlComponent`的方式。再次强调，这主要适用于非独立组件。
- en: Notice that we removed the usage of the `@angular/core/testing` package completely
    from the `version-control.component.spec.ts` file. This is because we’re no longer
    using `TestBed` to create the test environment. Instead, we use the `MockBuilder`
    method from the `ng-mocks` package to build the test environment for our `VersionControlComponent`.
    The `MockBuilder` method has several overloads, the one we used to take the target
    component as the first argument, and the `NgModule` this component is a part of
    as the second argument. The module and everything inside it are mocked. This makes
    it so much easier to test the component in isolation. You also have methods like
    `exclude` that you can chain, like `MockBuilder(MyComponent, MyModule).exclude(OtherComponent)`,
    to not mock specific components. However, we didn’t need to do that in this recipe.
    We also wrote an interesting test for the `VersionControlComponent`, that is,
    getting a child component (`VCLogsComponent`) using the `ngMocks.find` method
    and checking if the child component’s `@Input()` is set appropriately when the
    respective property in the parent changes. I call this interesting because now
    we’re getting away from the entire notion of “testing components in isolation,”
    as we are now checking a property of another component than the component we’re
    actually testing. In general, you would want to mock the child components or any
    dependency that a component has. With that said, the approach in your team might
    be different. If you have a strong case for not mocking the child component and
    then checking its properties as shown in the recipe, now you know how. Please
    refer to the next section for further resources to read.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经完全从`version-control.component.spec.ts`文件中移除了对`@angular/core/testing`包的使用。这是因为我们不再使用`TestBed`来创建测试环境。相反，我们使用`ng-mocks`包中的`MockBuilder`方法为我们的`VersionControlComponent`构建测试环境。`MockBuilder`方法有几个重载，我们使用的是将目标组件作为第一个参数，以及该组件所属的`NgModule`作为第二个参数。模块及其内部的所有内容都被模拟。这使得单独测试组件变得容易得多。您还可以使用像`exclude`这样的方法进行链式调用，例如`MockBuilder(MyComponent,
    MyModule).exclude(OtherComponent)`，以不模拟特定的组件。然而，在这个配方中我们不需要这样做。我们还为`VersionControlComponent`编写了一个有趣的测试，即使用`ngMocks.find`方法获取子组件（`VCLogsComponent`），并检查当父组件中的相应属性发生变化时，子组件的`@Input()`是否设置得当。我认为这很有趣，因为我们现在正在检查另一个组件的属性，而不仅仅是我们要测试的组件。一般来说，您会想要模拟子组件或组件拥有的任何依赖项。话虽如此，您团队的方法可能不同。如果您有充分的理由不模拟子组件，并像配方中那样检查其属性，现在您知道了如何做。请参阅下一节以获取更多阅读资源。
- en: IMPORTANT NOTE
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that we don’t use a spy on the `VersionControlComponent.addNewReleaseLog`
    method. This is because if we do so, that function will become a Jest spy function.
    Therefore, it’ll lose its internal functionality. In return, it’ll never add the
    new log to the `releaseLogs` array, and none of our tests will pass. You can try
    it out for fun.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不会在`VersionControlComponent.addNewReleaseLog`方法上使用间谍。这是因为如果我们这样做，该函数将变成Jest间谍函数。因此，它将失去其内部功能。作为交换，它将永远不会将新日志添加到`releaseLogs`数组中，并且我们的所有测试都不会通过。你可以尝试一下，看看效果如何。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The `ng-mocks` package’s `mock` method: [https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-mocks`包的`mock`方法：[https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock)'
- en: 'The `ng-mocks` official documentation: [https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-mocks`官方文档：[https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu)'
- en: Writing even easier tests with Angular CDK component harnesses
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular CDK组件工具包编写更简单的测试
- en: When writing tests for components, there might be scenarios where you’d want
    to interact with the DOM elements. Now, this can already be achieved by using
    the `fixture.debugElement.query` method to find the element, using a selector
    and then triggering events on it. However, that means maintaining the DOM queries
    for different platforms, knowing the identifiers of all the selectors, and then
    exposing all of that in the tests. And this is even worse if we’re talking about
    an Angular library. It certainly isn’t necessary for each developer who interacts
    with my library to know all the element selectors in order to write tests. Only
    the author of the library should know that much to respect encapsulation. Luckily,
    we have the component harnesses from the Angular CDK team, which were released
    with Angular 9 along with the IVY compiler. And they’ve led by example, by providing
    component harnesses for the Angular material components as well. In this recipe,
    you’ll learn how to create your own component harnesses.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写组件测试时，可能会有一些场景，你想要与DOM元素交互。现在，这已经可以通过使用`fixture.debugElement.query`方法来查找元素，使用选择器然后触发它的事件来实现。然而，这意味着需要维护不同平台的DOM查询，了解所有选择器的标识符，然后在测试中公开所有这些。如果我们谈论Angular库，那就更糟了。当然，没有必要让每个与我库交互的开发者都知道所有元素选择器才能编写测试。只有库的作者应该知道这么多，以尊重封装。幸运的是，我们有Angular
    CDK团队提供的组件工具包，它们与Angular 9和IVY编译器一起发布。他们以身作则，为Angular材料组件提供了组件工具包。在这个菜谱中，你将学习如何创建自己的组件工具包。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-cdk-harness`
    inside the cloned repository:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用位于克隆的仓库中的`start/apps/chapter10/ng-test-cdk-harness`：
- en: Open the code repository in your code editor.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE37]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该会看到以下内容：
- en: '![](img/B18469_10_13.png)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_13.png)'
- en: 'Figure 10.13: The ng-test-cdk-harness app running on http://localhost:4200'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.13：运行在http://localhost:4200的ng-test-cdk-harness应用
- en: Now that you have the app running, let’s move on to the next section to follow
    the recipe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启动了应用，让我们继续到下一个部分，按照菜谱进行。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have our favorite Angular version control app that allows us to create release
    logs. Also, we have tests written already, including tests that interact with
    the DOM element to validate a few use cases. Let’s follow the recipe to use component
    harnesses instead, discovering how easy it becomes to use in the actual tests:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个我们最喜欢的Angular版本控制应用，它允许我们创建发布日志。此外，我们已经有了一些测试，包括与DOM元素交互以验证一些用例的测试。让我们遵循菜谱使用组件工具包，看看在实际测试中变得多么容易：
- en: 'First, run the following command to run the tests:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行以下命令以运行测试：
- en: '[PRE38]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we’ll create a `component harness` for the `VersionControlComponent`.
    Let’s create a new file inside the `version-control` folder, and name it `version-control.component.harness.ts`.
    Then, add the following code inside it:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为`VersionControlComponent`创建一个`component harness`。让我们在`version-control`文件夹内创建一个新文件，并将其命名为`version-control.component.harness.ts`。然后，在它里面添加以下代码：
- en: '[PRE39]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to set up the harness environment for our tests for `VersionControlComponent`.
    For this, we’ll use `TestbedHarnessEnvironment` from the Angular CDK. Update the
    `version-control.component.spec.ts` file as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的`VersionControlComponent`测试设置 Harness 环境。为此，我们将使用 Angular CDK 中的`TestbedHarnessEnvironment`。按照以下方式更新`version-control.component.spec.ts`文件：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let’s write some methods in our `VersionControlComponentHarness` class
    to get the relevant information. We’ll use these methods in the later steps. Update
    the `version-control.component.harness.ts` file as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`VersionControlComponentHarness`类中编写一些方法来获取相关信息。我们将在后续步骤中使用这些方法。按照以下方式更新`version-control.component.harness.ts`文件：
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we’ll work on our first test, named `should show error on wrong version
    number input`, with the component harness. Update the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用组件 Harness 来完成我们的第一个测试，命名为`should show error on wrong version number
    input`。按照以下方式更新`version-control.component.spec.ts`文件：
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, if you run `npm run test`, you should see all of the tests passing, which
    means our first test with the component harness works. Woo-hoo!
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你运行`npm run test`，你应该会看到所有的测试都通过了，这意味着我们使用组件 Harness 的第一个测试是有效的。哇哦！
- en: 'For the final test, we also need a component harness for `VCLogsComponent`.
    Let’s quickly create it. Add a new file inside the `vc-logs` folder, named `vc-logs.component.harness.ts`,
    and add the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最终测试，我们还需要为`VCLogsComponent`创建一个组件 Harness。让我们快速创建它。在`vc-logs`文件夹内添加一个新文件，命名为`vc-logs.component.harness.ts`，并添加以下代码：
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, let’s modify our final tests in the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们修改`version-control.component.spec.ts`文件中的最终测试，如下所示：
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Voilà! That’s some amazing testing right there using the Angular CDK component
    harnesses. If you run the tests now, you should see them all passing. Now that
    you’ve finished the recipe, please refer to the next section to learn how this
    works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！这就是使用 Angular CDK 组件 Harness 进行的一些令人惊叹的测试。如果你现在运行测试，你应该会看到它们全部通过。现在你已经完成了这个食谱，请参考下一节了解它是如何工作的。
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All right! That was a cool recipe, and I enjoyed writing it too. The key factor
    of this recipe is the `@angular/cdk/testing` package. If you have worked with
    `e2e` tests using Protractor before, this is a similar concept to the **Pages**
    or **Page Objects** (**POs**) in Protractor. The first thing we do is to create
    a component harness for both the `VCLogsComponent` and the `VersionControlComponent`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！这是一个很棒的食谱，我也很享受写它。这个食谱的关键因素是`@angular/cdk/testing`包。如果你之前使用 Protractor 进行过`e2e`测试，那么这个概念与
    Protractor 中的**页面**或**页面对象**（**POs**）类似。我们首先做的事情是为`VCLogsComponent`和`VersionControlComponent`创建组件
    Harness。
- en: Notice that we import the `ComponentHarness` class from `@angular/cdk/testing`
    for both component harnesses. Then, we extend our custom classes, called `VersionControlComponentHarness`
    and `VCLogsComponentHarness`, from the `ComponentHarness` class. Essentially,
    this is the correct way to author component harnesses. Did you notice the static
    property called `hostSelector`? We need this property for every component harness
    class that we create, and the value is always the selector of the target element/component.
    This ensures that when we load this harness into the test environment, the environment
    can find the host element in the DOM – for which we’re creating the component
    harness. In our component harness class, we use the `this.locatorFor` method to
    find elements within the host component. The `locateFor` method takes a single
    argument as the **CSS selector** of the element to be found, returning an `AsyncFactoryFn`.
    This means the returned value is a function that we can use later to get the required
    elements.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为两个组件 Harness 从`@angular/cdk/testing`中导入`ComponentHarness`类。然后，我们扩展我们的自定义类，称为`VersionControlComponentHarness`和`VCLogsComponentHarness`，从`ComponentHarness`类继承。本质上，这是编写组件
    Harness 的正确方式。你注意到名为`hostSelector`的静态属性了吗？我们需要为每个我们创建的组件 Harness 类都设置这个属性，其值总是目标元素/组件的选择器。这确保了当我们把这个
    Harness 加载到测试环境中时，环境可以在 DOM 中找到主机元素——这就是我们创建组件 Harness 的原因。在我们的组件 Harness 类中，我们使用`this.locatorFor`方法在主机组件中查找元素。`locateFor`方法接受一个参数，即要查找的元素的**CSS
    选择器**，返回一个`AsyncFactoryFn`。这意味着返回的值是一个我们可以稍后用来获取所需元素的函数。
- en: In the `VersionControlComponentHarness` class, we find the submit button and
    the version number input using the *protected* methods `getSubmitButton` and `getAppVersionInput`,
    respectively. All of these are of the `AsyncFactoryFn` type, as mentioned earlier.
    We have these methods set as *protected* because we don’t want the developers
    who write the unit tests to access or care about the information of the DOM elements.
    This makes it much easier for everyone to write tests without worrying about the
    internal implementation of accessing the DOM.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VersionControlComponentHarness`类中，我们分别使用受保护的`getSubmitButton`和`getAppVersionInput`方法找到提交按钮和版本号输入。所有这些方法都是前面提到的`AsyncFactoryFn`类型。我们将这些方法设置为受保护的，因为我们不希望编写单元测试的开发者访问或关心DOM元素的信息。这使得每个人都能更容易地编写测试，而无需担心访问DOM的内部实现。
- en: One important thing to mention here is that when we call the `locatorFor` method
    or the `locatorForAll` method, we get back a `Promise` with the `TestElement`
    item or a `Promise` with a list of `TestElement` items, respectively. Each `TestElement`
    item has a bunch of handy methods, such as `click`, `sendKeys`, `focus`, `blur`,
    `getProperty`, `text`, and more. These methods are what we’re interested in, since
    we use them behind the scenes to interact with the DOM elements.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要提到的一个重要事项是，当我们调用`locatorFor`方法或`locatorForAll`方法时，我们分别得到一个包含`TestElement`项的`Promise`和一个包含`TestElement`项列表的`Promise`。每个`TestElement`项都有一系列方便的方法，例如`click`、`sendKeys`、`focus`、`blur`、`getProperty`、`text`等。这些方法正是我们所感兴趣的，因为我们在幕后使用它们与DOM元素进行交互。
- en: Now, let’s talk about configuring the test environment. In the `version-control.component.spec.ts`
    file, we set up the environment to use component harnesses for both `VCLogsComponent`
    and `VersionControlComponent`. The `TestbedHarnessEnvironment` element is the
    key element here. We use the `TestbedHarnessEnvironment.harnessForFixture` method
    first. This is because we are writing tests for the `VersionControlComponent`,
    and we also want the harness of the same component as root. Therefore, the `harnessForFixture`
    method makes sense here. This method takes the `fixture` as the first argument
    and the `harness` class as the second. Then, we also use the `loader` method of
    the `TestbedHarnessEnvironment` class to get an instance of the `HarnessLoader`.
    This loader can then get the harness of the `VCLogsComponent`, i.e., get the instance
    of the `VCLogsComponentHarness` class. Note that the fixture is what we get in
    the test environment using the `TestBed.createComponent(VersionControlComponent)`
    statement.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈配置测试环境。在`version-control.component.spec.ts`文件中，我们设置环境以使用组件工具包对`VCLogsComponent`和`VersionControlComponent`进行测试。`TestbedHarnessEnvironment`元素是这里的关键元素。我们首先使用`TestbedHarnessEnvironment.harnessForFixture`方法。这是因为我们正在为`VersionControlComponent`编写测试，并且我们还想将同一组件的工具包作为根。因此，`harnessForFixture`方法在这里是合理的。该方法将`fixture`作为第一个参数，将`harness`类作为第二个参数。然后，我们还使用`TestbedHarnessEnvironment`类的`loader`方法来获取`HarnessLoader`的实例。这个加载器可以获取`VCLogsComponent`的工具包，即获取`VCLogsComponentHarness`类的实例。请注意，`fixture`是我们使用`TestBed.createComponent(VersionControlComponent)`语句在测试环境中获得的。
- en: Notice that in the tests, we use the `harnessLoader.getHarness` method by providing
    the harness class as an argument. This enables the test environment to find the
    DOM element associated with the `hostSelector` property of the harness class.
    Additionally, we get back the instance of the component harness that we can use
    further in the test.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在测试中，我们通过提供工具包类作为参数来使用`harnessLoader.getHarness`方法。这使测试环境能够找到与工具包类`hostSelector`属性关联的DOM元素。此外，我们还得到了可以进一步在测试中使用的组件工具包实例。
- en: See also
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Finding components in the DOM with component harnesses: [https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom](https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件工具包在DOM中查找组件：[https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom](https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom)
- en: 'API for component harness authors: [https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors](https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件工具包作者的API：[https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors](https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors)
- en: Unit-testing responses from HTTP calls
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试HTTP调用响应
- en: If you’re building an Angular application, it is very likely that you’ll work
    with HTTP calls inside the app at some point. For instance, you could be fetching
    data from a third-party API or just making APIs to your own server. In either
    case, it becomes slightly difficult to test applications that have HTTP calls
    in action. In this recipe, we’re going to learn how to create unit-tests with
    HTTP calls.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个Angular应用程序，你很可能在某个时候会在应用程序内部处理HTTP调用。例如，你可能从第三方API获取数据，或者只是向自己的服务器发送API调用。在两种情况下，测试具有HTTP调用的应用程序都会变得稍微困难一些。在这个食谱中，我们将学习如何创建带有HTTP调用的单元测试。
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-http-resp`
    inside the cloned repository:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用程序位于克隆的仓库中的`start/apps/chapter10/ng-test-http-resp`目录内：
- en: Open the code repository in your code editor.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE45]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_10_14.png)'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_14.png)'
- en: 'Figure 10.14: The ng-test-http-resp app running on http://localhost:4200'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.14：ng-test-http-resp应用程序在http://localhost:4200上运行
- en: 'Let’s also run the tests. Right now, the test for the `UserService`, which
    fetches the `HTTP` response, doesn’t pass. You should see an output similar to
    *Figure 10.15*:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们也运行一下测试。目前，对`UserService`的测试，它获取HTTP响应，没有通过。你应该看到类似于*图10.15*的输出：
- en: '![](img/B18469_10_15.png)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_15.png)'
- en: 'Figure 10.15: Test failing for the UserService'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.15：UserService测试失败
- en: Now that we have the app and tests running locally, in the next section, let’s
    take a look at the steps of the recipe.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将应用程序和测试在本地上运行起来，在下一节中，让我们看看食谱的步骤。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll write one single test that checks if the service’s `getUser` method returns
    the correct data. If you open the `UserService`, you’ll notice that the service
    fetches the users using an HTTP call and then modifies the data to add the `fullAddress`
    property. Our test should expect the same to happen. Let’s get started:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个单独的测试来检查服务器的`getUser`方法是否返回正确的数据。如果你打开`UserService`，你会注意到该服务使用HTTP调用获取用户，然后修改数据以添加`fullAddress`属性。我们的测试应该期望发生相同的事情。让我们开始：
- en: 'First and foremost, we’ll fix the failing test. We’ll add the `HttpClientModule`
    class to the test in the `imports` array. Update the `user.service.spec.ts` as
    follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将修复失败的测试。我们将把`HttpClientModule`类添加到测试的`imports`数组中。按照以下方式更新`user.service.spec.ts`：
- en: '[PRE46]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, as soon as you run the `npm run test` command, you’ll see that the tests
    pass now as follows:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当你运行`npm run test`命令时，你会看到测试现在通过了，如下所示：
- en: '![](img/B18469_10_16.png)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_16.png)'
- en: 'Figure 10.16: Tests passing for the UserService as well'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.16：UserService的测试也通过
- en: 'Now, we’ll import the `HttpClientTestingModule` in the `user.service.spec.ts`
    file to be able to use it to intercept HTTP calls. Modify the file as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`user.service.spec.ts`文件中导入`HttpClientTestingModule`，以便能够使用它来拦截HTTP调用。按照以下方式修改文件：
- en: '[PRE47]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s create a controller using the `HttpTestingController` class from the
    same `@angular/common/http/testing` package. We’ll use this controller later to
    expect and intercept the HTTP calls. Update the `user.service.spec.ts` file as
    follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用来自同一`@angular/common/http/testing`包的`HttpTestingController`类创建一个控制器。我们稍后会使用这个控制器来期望和拦截HTTP调用。按照以下方式更新`user.service.spec.ts`文件：
- en: '[PRE48]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we’ll write a test (finally). We’ll intercept the HTTP call to `/assets/users.json`
    using the `httpTestingController`, and then we will compare the result with our
    expected data. Update the `user.service.ts` file by adding a test, as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个测试（终于）。我们将使用`httpTestingController`拦截对`/assets/users.json`的HTTP调用，然后我们将比较结果与我们的预期数据。通过添加以下测试来更新`user.service.ts`文件：
- en: '[PRE49]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We’ll add an `afterEach` hook in the tests to verify that there are no pending
    requests after our test. Let’s add it to the `user.service.spec.ts` file as follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在测试中添加一个`afterEach`钩子来验证测试后没有挂起的请求。让我们将其添加到`user.service.spec.ts`文件中，如下所示：
- en: '[PRE50]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, let’s populate the mock data (the `mockUsers` array) with two users. Since
    we’re using `req.flush(mockUsers)`, the HTTP call will be intercepted, and this
    data (`mockUsers` array) will be returned from it as a response. Replace the test
    `it('should return expected user data (HttpClient called once)'` in the file `user.service.spec.ts`
    with the snippet from [https://ng-cookbook.com/s/ng-test-http-mock-users](https://ng-cookbook.com/s/ng-test-http-mock-users).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用两个用户填充模拟数据（`mockUsers`数组）。由于我们使用了`req.flush(mockUsers)`，HTTP调用将被拦截，并且这些数据（`mockUsers`数组）将作为响应从其中返回。将文件`user.service.spec.ts`中的测试`it('should
    return expected user data (HttpClient called once)'`替换为[https://ng-cookbook.com/s/ng-test-http-mock-users](https://ng-cookbook.com/s/ng-test-http-mock-users)中的代码片段。
- en: 'Finally, update the test further to make the http call, using the `getUsers`
    method, and see if we can expect the transformed data. Update the `user.service.spec.ts`
    file, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，进一步更新测试，使用`getUsers`方法进行HTTP调用，并查看我们是否可以期望转换后的数据。更新`user.service.spec.ts`文件，如下所示：
- en: '[PRE51]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you run the tests, you should see them all pass as follows:'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行测试，你应该看到它们都通过，如下所示：
- en: '![](img/B18469_10_17.png)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_17.png)'
- en: 'Figure 10.17: All of the tests pass'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.17：所有测试通过
- en: Great! You now know how to work with `HttpTestingController` to test services
    that have methods, using HTTP calls. Although there’s still a lot to learn about
    testing HTTP calls and Observables in Angular, the purpose of this recipe was
    to keep everything simple and sweet.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你现在知道如何使用`HttpTestingController`来测试具有方法的服务的HTTP调用。尽管关于在Angular中测试HTTP调用和Observables还有很多东西要学习，但这个菜谱的目的是保持一切简单而甜蜜。
- en: Now that you have finished the recipe, please refer to the next section to understand
    how it works.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了这个菜谱，请参考下一节了解它是如何工作的。
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The hero of this recipe is the `HttpClientTestingModule`, which allows us to
    use an instance of `HttpTestingController`. The `HttpTestingController` makes
    it easy to intercept the HTTP calls in our code and allows us to return a specific
    response. This makes it easier for us to not have our Angular services tested
    with real HTTP calls, which can be expensive. Another benefit of this approach
    to mocking the response is always having the same response object to work with.
    In our case, our `getUsers` method not only made an HTTP call but also transformed
    data, using the `map` operator from `RxJs`. Therefore, we used an array of mocked
    users and expected the result from the `getUsers` method to have the transformed
    data, i.e., including the `fullAddress` property containing the right data. You
    can see in the test that we use the `HttpTestingController.expectOne` method,
    telling our test that there should be only one request when we run the test. We
    expect the method of that request to be `GET`. Then, we expect that the returned
    value from the `getUsers` method has an array of users containing the `fullAddress`
    property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的英雄是`HttpClientTestingModule`，它允许我们使用`HttpTestingController`的一个实例。`HttpTestingController`使得拦截我们代码中的HTTP调用变得容易，并允许我们返回一个特定的响应。这使得我们更容易不对Angular服务进行真实的HTTP调用测试，这可能会很昂贵。这种模拟响应方法的另一个好处是始终有一个相同的响应对象可以与之工作。在我们的例子中，我们的`getUsers`方法不仅进行了HTTP调用，还使用`RxJs`的`map`运算符转换了数据。因此，我们使用了一个模拟用户数组，并期望`getUsers`方法的结果包含转换后的数据，即包含正确的`fullAddress`属性。你可以在测试中看到，我们使用了`HttpTestingController.expectOne`方法，告诉我们的测试在运行测试时应该只有一个请求。我们期望那个请求的方法是`GET`。然后，我们期望`getUsers`方法返回的值有一个包含`fullAddress`属性的用户的数组。
- en: See also
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular testing component scenarios: [https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular测试组件场景：[https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios)
- en: '`HttpTestingController` docs: [https://angular.io/api/common/http/testing/HttpTestingController](https://angular.io/api/common/http/testing/HttpTestingController)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpTestingController`文档：[https://angular.io/api/common/http/testing/HttpTestingController](https://angular.io/api/common/http/testing/HttpTestingController)'
- en: Unit-testing Angular pipes
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试Angular管道
- en: In my opinion, pipes are the easiest thing to test in an Angular application.
    Why? Well, this is because they’re (supposed to be) pure functions that return
    the same result based on the same set of inputs. In this recipe, we’ll write some
    tests for a simple pipe in an Angular application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，管道是Angular应用程序中最容易测试的东西。为什么？因为它们（应该是）纯函数，根据相同的输入集返回相同的结果。在这个菜谱中，我们将为Angular应用程序中的一个简单管道编写一些测试。
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with now resides in `start/apps/chapter10/ng-test-pipes`
    inside the cloned repository:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将要工作的应用位于克隆的仓库中的`start/apps/chapter10/ng-test-pipes`：
- en: Open the code repository in your code editor.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来运行项目：
- en: '[PRE52]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_10_18.png)'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_10_18.png)'
- en: 'Figure 10.18: The ng-test-pipes app running on http://localhost:4200'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.18：运行在http://localhost:4200的ng-test-pipes应用
- en: Now that we have the app running locally, in the next section, let’s go through
    the steps of the recipe.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用，在下一节中，让我们通过食谱的步骤。
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we have a simple recipe that takes two inputs – the digit and the max
    factor value. Based on these inputs, we show a multiplication table. We already
    have the `MultTablePipe` that is working fine according to our business logic.
    We’ll now write some unit tests to validate our inputs and expected outputs, as
    follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的食谱，它接受两个输入——数字和最大因子值。基于这些输入，我们显示一个乘法表。我们已经有了一个工作正常的`MultTablePipe`，根据我们的业务逻辑。现在我们将编写一些单元测试来验证我们的输入和预期输出，如下所示：
- en: 'Let’s write our first custom test for `MultTablePipe`. We’ll make sure it returns
    an empty array when we have an invalid value for the `digit` input. Replace the
    whole `mult-table.pipe.spec.ts` file with the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`MultTablePipe`编写第一个自定义测试。我们将确保当`digit`输入无效时，它返回一个空数组。用以下代码替换整个`mult-table.pipe.spec.ts`文件：
- en: '[PRE53]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s write another test to validate the `limit` input so that we also return
    an empty array if it is invalid:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写另一个测试来验证`limit`输入，以便在它无效时也返回一个空数组：
- en: '[PRE54]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we’ll write a test to validate the output of the pipe’s `transform` method
    when both the `digit` and `limit` inputs are valid. In this scenario, we should
    get back the array containing the multiplication table. Write another test as
    follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个测试来验证当`digit`和`limit`输入都有效时，管道的`transform`方法的输出。在这种情况下，我们应该得到包含乘法表的数组。按照以下方式编写另一个测试：
- en: '[PRE55]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Right now, within the app, we have the possibility to provide decimal digits
    for the `limit` input. For instance, we can write `2.5` as the max factor in the
    input. To handle this, we use a `Math.floor` in `MultTablePipe` to round it down
    to the lower number. Let’s write a test to make sure this works:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，在应用内部，我们有提供`limit`输入的十进制数字的可能性。例如，我们可以将`2.5`作为输入中的最大因子。为了处理这种情况，我们在`MultTablePipe`中使用`Math.floor`将其向下舍入到较小的数字。让我们编写一个测试来确保这一点：
- en: '[PRE56]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Easy peasy!* Writing tests for Angular pipes is so straightforward that I
    love it. We could call this the power of pure functions. Now that you’ve finished
    the recipe, please refer to the next section for more informative links.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单易行!* 编写 Angular 管道的测试非常直接，我非常喜欢它。我们可以称之为纯函数的力量。现在你已经完成了食谱，请参阅下一节以获取更多信息链接。'
- en: See also
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Testing Angular pipes official documentation: [https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 Angular 管道官方文档：[https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes)
- en: 'Test Angular Pipes With Services: [https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务测试 Angular 管道：[https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576)
- en: Learn more on Discord
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里你可以分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_10.xhtml)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_10.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1388317275422265.png)'
