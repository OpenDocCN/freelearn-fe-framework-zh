- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Type-Checking and Validation with TypeScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TypeScript 进行类型检查和验证
- en: In this chapter, we’ll explore the importance of **property validation** in
    React components for creating robust, bug-free applications. We’ll introduce **TypeScript**,
    which is a powerful tool for static type-checking in JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在 React 组件中属性验证的重要性，以创建健壮、无错误的程序。我们将介绍 **TypeScript**，这是一种在 JavaScript
    中进行静态类型检查的强大工具。
- en: We’ll guide you through setting up TypeScript in the project and cover its basic
    and advanced concepts. We’ll also provide examples of how to use TypeScript for
    type-checking in React components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指导您在项目中设置 TypeScript 并介绍其基本和高级概念。我们还将提供如何使用 TypeScript 在 React 组件中进行类型检查的示例。
- en: By the end of this chapter, you’ll have a solid foundation in property validation
    and type-checking, and be ready to create more predictable, reliable components
    using TypeScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将在属性验证和类型检查方面打下坚实的基础，并准备好使用 TypeScript 创建更可预测、更可靠的组件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Knowing what to expect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解预期内容
- en: An introduction to TypeScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 简介
- en: Using TypeScript in React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中使用 TypeScript
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter05)。
- en: Knowing what to expect
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解预期内容
- en: In any application, predictability is key. A predictable application behaves
    in expected ways, reducing bugs, improving user experience, and simplifying maintenance.
    When we talk about predictability in the context of React, we often refer to how
    components behave based on the props they receive. Props is short for properties
    and serves as the inputs to React components, determining their behavior and rendering.
    This is where the concept of **props validation** comes into play.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，可预测性都是关键。一个可预测的应用程序会以预期的行为运行，减少错误，提高用户体验，并简化维护。当我们谈论 React 中的可预测性时，我们通常指的是组件根据其接收的属性如何行为。Props
    是属性的简称，作为 React 组件的输入，决定了其行为和渲染。这就是 **属性验证** 概念发挥作用的地方。
- en: The importance of props validation
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性验证的重要性
- en: Props validation is a way to ensure that components receive the right type of
    data. It’s like a contract between components. When a component specifies the
    types of props it expects to receive, it makes a promise that it will behave in
    a certain way if it receives props of those types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 属性验证是一种确保组件接收正确类型数据的方法。它就像组件之间的合同。当组件指定它期望接收的属性类型时，它承诺如果接收了这些类型的属性，它将以某种方式行为。
- en: 'Props validation is crucial for a few reasons, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 属性验证对于以下几个原因至关重要：
- en: '**It helps catch errors early in the development process**: If a component
    receives a prop of an unexpected type, it might not behave as expected, leading
    to bugs that can be hard to track down. By validating props, we can catch these
    errors before they cause problems.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它有助于在开发过程中早期捕获错误**：如果组件接收到了一个意外的属性类型，它可能不会按预期行为，导致难以追踪的错误。通过验证属性，我们可以在它们造成问题之前捕获这些错误。'
- en: '**Props validation improves code readability**: By looking at a component’s
    prop types, you can quickly understand what data the component expects to receive.
    This makes it easier to use and reuse components throughout your application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性验证提高了代码可读性**：通过查看组件的属性类型，您可以快速了解组件期望接收哪些数据。这使得在整个应用程序中使用和重用组件变得更加容易。'
- en: '**Props validation makes components more predictable**: When a component clearly
    specifies the types of props it expects to receive, it’s easier to understand
    how the component will behave based on its props.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性验证使组件更具可预测性**：当组件明确指定它期望接收的属性类型时，更容易理解组件将如何根据其属性行为。'
- en: Potential issues without props validation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有属性验证的潜在问题
- en: 'Without adequate props validation, components can become unpredictable and
    prone to bugs. Let’s take a look at a component:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的属性验证，组件可能会变得不可预测，并容易产生错误。让我们看看一个组件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, a component expects to receive a **list prop**, which should
    be an array of objects with name and email properties. If this component receives
    a list prop that is a string, a number, or even an array, but without objects,
    it might try to access `user.name` or `user.email`, which would result in an error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个组件期望接收一个**list prop**，它应该是一个包含名称和电子邮件属性的数组对象。如果这个组件接收到的list prop是一个字符串、一个数字，甚至是一个数组，但没有对象，它可能会尝试访问`user.name`或`user.email`，这会导致错误。
- en: These types of errors can be hard to debug, especially in larger applications
    with many components. It also might be difficult to understand what exactly we
    should provide to the component without reading every single line of code of this
    component. Errors can also lead to crashes or unexpected behavior in your application.
    But what if we can add a props validation to our components that can help us catch
    these errors early and ensure that your components behave as expected? Let’s explore
    it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误可能很难调试，尤其是在具有许多组件的大型应用程序中。也可能很难理解我们应该向组件提供什么，而不必阅读这个组件的每一行代码。错误也可能导致应用程序崩溃或出现意外的行为。但如果我们能向我们的组件添加props验证，这可以帮助我们提前捕获这些错误并确保组件按预期行为？让我们来探索一下。
- en: Options for props validation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: props验证的选项
- en: There are several tools you can use for props validation in React and React
    Native. One of these is `PropTypes`, a library that allows you to specify the
    types of props a component should receive. Another option is TypeScript, a statically
    typed superset of JavaScript that provides powerful tools for type-checking.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用几种工具在React和React Native中进行props验证。其中之一是`PropTypes`，这是一个库，允许你指定组件应接收的属性类型。另一个选项是TypeScript，它是JavaScript的一个静态类型超集，提供了强大的类型检查工具。
- en: 'Now, I would like to show you examples of the `MyList` component with `PropTypes`.
    Take a look at this component:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想向您展示带有`PropTypes`的`MyList`组件的示例。请看这个组件：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we’re using `PropTypes` to specify that the `list` prop should
    be an array of objects, and each object should have a `name` and an `email` property,
    both of which should be strings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`PropTypes`来指定`list` prop应该是一个对象数组，并且每个对象都应该有一个`name`和`email`属性，这两个属性都应该是字符串。
- en: 'Next, let’s take a look at the TypeScript example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看TypeScript的示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this TypeScript example, we’re defining a `User` type and a `MyListProps`
    type. The `User` type is an object with a `name` and an `email` property, both
    of which are strings. The `MyListProps` type is an object with a `list` property,
    which is an array of `User` objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个TypeScript示例中，我们定义了一个`User`类型和一个`MyListProps`类型。`User`类型是一个具有`name`和`email`属性的对象，这两个属性都是字符串。`MyListProps`类型是一个具有`list`属性的对象，该属性是一个`User`对象的数组。
- en: While both PropTypes and TypeScript offer valuable tools for props validation,
    we’ll be focusing on TypeScript for the remainder of this book. TypeScript provides
    a more comprehensive and powerful approach to type-checking, and it’s becoming
    increasingly popular in the React and React Native communities.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PropTypes和TypeScript都提供了用于props验证的有价值工具，但我们将在这本书的剩余部分专注于TypeScript。TypeScript提供了一种更全面、更强大的类型检查方法，并且在React和React
    Native社区中越来越受欢迎。
- en: In the following chapters, all examples will use TypeScript. By the end of this
    book, you’ll have a solid understanding of TypeScript and how to use it in your
    own React and React Native projects. So, let’s dive in and start exploring the
    world of TypeScript!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，所有示例都将使用TypeScript。到这本书结束时，你将有一个扎实的TypeScript理解，并知道如何在你的React和React
    Native项目中使用它。所以，让我们深入探索TypeScript的世界吧！
- en: Introduction to TypeScript
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript简介
- en: As we embark on this journey to learn about type-checking and validation, let’s
    momentarily step away from React and React Native and turn our attention to TypeScript.
    You might be wondering, “What exactly is TypeScript?”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习类型检查和验证的旅程时，让我们暂时从React和React Native中抽身，将注意力转向TypeScript。你可能想知道，“TypeScript究竟是什么？”
- en: '**TypeScript** is a statically typed superset of **JavaScript**, developed
    and maintained by Microsoft. This means that it adds additional features to JavaScript,
    one of the most significant being static typing. While JavaScript is dynamically
    typed, TypeScript introduces a type system that allows you to explicitly define
    the type of data that variables, function parameters, and function return values
    can have.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeScript** 是由微软开发和维护的 **JavaScript** 的静态类型超集。这意味着它为JavaScript添加了额外的功能，其中最显著的是静态类型。虽然JavaScript是动态类型的，但TypeScript引入了一个类型系统，允许你明确地定义变量、函数参数和函数返回值可以具有的数据类型。'
- en: But don’t worry, TypeScript is completely compatible with JavaScript. In fact,
    any valid JavaScript code is also valid TypeScript code. TypeScript uses a transpiler
    (a type of compiler) to convert TypeScript code, which browsers can’t understand
    directly, into JavaScript code, which can run in any environment where JavaScript
    runs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但不用担心，TypeScript与JavaScript完全兼容。事实上，任何有效的JavaScript代码也是有效的TypeScript代码。TypeScript使用一个转译器（一种编译器类型）将TypeScript代码转换为浏览器无法直接理解的JavaScript代码，这样就可以在任何JavaScript可以运行的环境中运行。
- en: 'Consider the following JavaScript function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下JavaScript函数：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function works as expected when you pass a string as an argument. But if
    you pass a number, it doesn’t throw an error, even though it doesn’t make much
    sense to greet a number.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递一个字符串作为参数时，这个函数按预期工作。但是，如果你传递一个数字，它不会抛出错误，尽管问候一个数字在逻辑上并不合理。
- en: 'Now, let’s see how we could write this function in TypeScript:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何用TypeScript编写这个函数：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the TypeScript version, we’ve added a type annotation to the `name` parameter.
    This tells TypeScript that `name` should always be a string. If we try to call
    `greet` with a number, TypeScript will give us an error. This helps us catch the
    mistake before we even run the code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript版本中，我们为`name`参数添加了类型注解。这告诉TypeScript`name`始终应该是字符串类型。如果我们尝试用数字调用`greet`，TypeScript会给出错误。这有助于我们在运行代码之前就捕获到错误。
- en: 'This is a simple example, but it illustrates one of the key benefits of TypeScript:
    it can help us catch errors early before they lead to bugs in our code. It’s like
    having a helpful co-pilot who points out potential issues before they become problematic.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但它说明了TypeScript的一个关键好处：它可以帮助我们在错误导致代码中的bug之前尽早捕获错误。这就像有一个有用的副驾驶，在问题变得严重之前指出潜在的问题。
- en: Why use TypeScript?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用TypeScript？
- en: 'Now that we’ve introduced what TypeScript is, let’s delve into why you might
    want to learn and use it in your projects:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了TypeScript是什么，让我们深入探讨为什么你可能想在项目中学习和使用它：
- en: '**Catch errors early**: We’ve already discussed it, but it’s worth putting
    it in the first place on the list. One of the biggest advantages of TypeScript
    is its ability to catch errors at compile time, before even running the code.
    This can help prevent many common errors that might not be caught until runtime
    in regular JavaScript.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽早捕获错误**：我们之前已经讨论过这一点，但将其放在列表的第一位仍然很有价值。TypeScript最大的优点之一就是能够在编译时捕获错误，甚至在代码运行之前。这有助于防止许多在常规JavaScript中可能直到运行时才被捕获的常见错误。'
- en: '**Improve code readability**: TypeScript’s **type annotations** make it clear
    what kind of values a function expects as arguments or what type of value a function
    returns. This can make the code easier to read and understand, especially for
    other developers who might be working on the same code base.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码可读性**：TypeScript的类型注解使得函数期望的参数类型或函数返回的类型值一目了然。这使得代码更容易阅读和理解，尤其是对于可能正在同一代码库上工作的其他开发者来说。'
- en: '**Easier refactoring**: TypeScript’s static typing also makes it easier to
    refactor code. If you change the type of a variable or the signature of a function,
    TypeScript can help you find all the places in your code where you need to make
    corresponding changes.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易重构**：TypeScript的静态类型还使得代码重构变得更加容易。如果你更改变量的类型或函数的签名，TypeScript可以帮助你找到代码中需要做出相应更改的所有位置。'
- en: '**Community and tooling support**: TypeScript has gained significant popularity
    in the JavaScript community and is used by many large companies like Microsoft,
    Google, and Airbnb. This implies that there’s a large community of developers
    who can provide support and a wealth of resources for learning TypeScript. Additionally,
    many code editors have excellent support for TypeScript, providing features like
    **autocompletion**, **type inference**, and **error highlighting**.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区和工具支持**：TypeScript 在 JavaScript 社区中获得了显著的流行度，并被微软、谷歌和 Airbnb 等许多大型公司使用。这意味着有一个庞大的开发者社区可以提供支持，并提供丰富的学习
    TypeScript 的资源。此外，许多代码编辑器对 TypeScript 提供了出色的支持，提供如 **自动完成**、**类型推断**和**错误突出显示**等功能。'
- en: '**Integration with modern frameworks and libraries**: TypeScript integrates
    well with modern JavaScript frameworks like React and React Native, which have
    built-in TypeScript definitions, making it easier to build strongly typed applications.
    Moreover, a vast majority of popular JavaScript libraries have TypeScript definitions
    available. These definitions, often contributed by the community, provide type
    information about the library’s functions and objects, making it easier and safer
    to use these libraries in your TypeScript projects.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与现代框架和库的集成**：TypeScript 与现代 JavaScript 框架如 React 和 React Native 集成良好，这些框架内置了
    TypeScript 定义，使得构建强类型应用变得更加容易。此外，大多数流行的 JavaScript 库都提供了 TypeScript 定义。这些定义通常由社区贡献，提供了关于库函数和对象类型信息，使得在
    TypeScript 项目中使用这些库更加容易和安全。'
- en: This widespread adoption of TypeScript in the JavaScript ecosystem ensures that
    you can leverage the benefits of TypeScript almost anywhere in your code base.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种在 JavaScript 生态系统中对 TypeScript 的广泛应用确保了你可以几乎在代码库的任何地方利用 TypeScript 的益处。
- en: '**Increasing job market demand**: The popularity of TypeScript extends beyond
    just development practices: it’s also increasingly sought after in the job market.
    Many companies, from start-ups to large corporations, are adopting TypeScript
    for their projects, and as a result, there’s a growing demand for developers who
    are proficient in TypeScript. This is particularly true for roles involving React
    and React Native, where TypeScript is often used for its benefits in scaling and
    maintaining large code bases. By learning TypeScript, you’re not only gaining
    a valuable skill for your projects but also making yourself more marketable as
    a developer.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加就业市场需求**：TypeScript 的流行不仅限于开发实践：它在就业市场上也越来越受欢迎。许多公司，从小型初创公司到大型企业，都在其项目中采用
    TypeScript，因此对熟练掌握 TypeScript 的开发者的需求不断增长。这对于涉及 React 和 React Native 的职位尤其如此，在这些职位中，TypeScript
    通常用于其在大规模代码库扩展和维护方面的优势。通过学习 TypeScript，你不仅为你的项目获得了一项宝贵的技能，而且作为开发者，也使自己在市场上更具竞争力。'
- en: In summary, TypeScript offers a range of benefits that can help you write more
    robust, maintainable code. It’s a valuable tool in any JavaScript developer’s
    toolkit, and its growing popularity in the job market makes it a worthwhile investment
    for your career development.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，TypeScript 提供了一系列可以帮助你编写更健壮、可维护代码的益处。它是任何 JavaScript 开发者工具箱中的宝贵工具，其在就业市场上的日益流行使其成为你职业发展的值得投资。
- en: But understanding the benefits of TypeScript is just the first step. To truly
    harness its power, you need to know how to use it in your projects. In the next
    section, we’ll guide you through the process of setting up TypeScript in a React
    project. We’ll cover everything from installing TypeScript to configuring your
    project to use it. So, let’s dive in and start exploring the practical side of
    TypeScript!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但理解 TypeScript 的好处只是第一步。要真正发挥其威力，你需要知道如何在项目中使用它。在下一节中，我们将指导你通过在 React 项目中设置
    TypeScript 的过程。我们将从安装 TypeScript 到配置项目使用 TypeScript 的所有内容进行讲解。那么，让我们深入探索 TypeScript
    的实际应用吧！
- en: Setting up TypeScript in a project
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在项目中设置 TypeScript
- en: In the first chapter, we walked through the process of creating a new React
    project using **Vite**. Now, let’s see how we can create a TypeScript project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了使用 **Vite** 创建新 React 项目的流程。现在，让我们看看如何创建一个 TypeScript 项目。
- en: '**Vite** provides a template for creating a new React and TypeScript project.
    You can create a new project with the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vite** 为创建新的 React 和 TypeScript 项目提供了一个模板。你可以使用以下命令创建一个新项目：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command creates a new Vite project with the `react-ts` template, which
    includes TypeScript. The project based on this template will include the `tsconfig.json`
    file in the root of your project. This file is used to configure TypeScript for
    your project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用 `react-ts` 模板创建一个新的 Vite 项目，该模板包含 TypeScript。基于此模板的项目将在您的项目根目录中包含 `tsconfig.json`
    文件。此文件用于为您的项目配置 TypeScript。
- en: 'Here’s what the `tsconfig.json` file might look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `tsconfig.json` 文件可能的样子：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These settings tell TypeScript to compile your code to the latest version of
    JavaScript (`"target": "esnext"`), to use the latest module system (`"module":
    "esnext"`), and to use the new JSX transform introduced in *React 17* (`"jsx":
    "react-jsx"`). The `"strict": true` option enables a wide range of type-checking
    behavior to catch more issues.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '这些设置告诉 TypeScript 将您的代码编译为最新版本的 JavaScript (`"target": "esnext"`), 使用最新的模块系统
    (`"module": "esnext"`), 并使用 *React 17* 中引入的新 JSX 转换 (`"jsx": "react-jsx"`). `"strict":
    true` 选项启用了一组广泛的类型检查行为，以捕获更多问题。'
- en: 'With TypeScript set up, let’s write some code. However, TypeScript uses different
    file extensions than JavaScript: `*.ts` for files without JSX, and `*.tsx` for
    files with JSX. So, let’s create our first React component using TypeScript:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 TypeScript 之后，让我们编写一些代码。然而，TypeScript 使用与 JavaScript 不同的文件扩展名：没有 JSX 的文件使用
    `*.ts` 扩展名，而带有 JSX 的文件使用 `*.tsx` 扩展名。因此，让我们使用 TypeScript 创建我们的第一个 React 组件：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we’re defining an `AppProps` type for the props of the `App`
    component. This tells TypeScript that the message prop should be a string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在为 `App` 组件的 props 定义一个 `AppProps` 类型。这告诉 TypeScript，`message` prop
    应该是一个字符串。
- en: 'Now, let’s take a look at the figure of how `main.tsx` looks like right now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `main.tsx` 现在的样子：
- en: '![Picture 2](img/B19636_06_01.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](img/B19636_06_01.png)'
- en: 'Figure 6.1: App component in the main.tsx file with the error from TypeScript'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：main.tsx 文件中的 App 组件及其 TypeScript 错误
- en: 'This is how TypeScript checks and validates props usage in components. Here,
    we should pass the `message` prop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 TypeScript 如何检查和验证组件中 props 的使用。在这里，我们应该传递 `message` prop：
- en: '![Picture 3](img/B19636_06_02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3](img/B19636_06_02.png)'
- en: 'Figure 6.2: App component in the main.tsx file without errors'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：main.tsx 文件中没有错误的 App 组件
- en: 'Finally, you can run your project with the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用以下命令运行您的项目：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command starts the **Vite development server**. If there are any **type
    errors** in your code, TypeScript will show them in the console as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动 **Vite 开发服务器**。如果您的代码中存在任何 **类型错误**，TypeScript 也会在控制台中显示它们。
- en: Basic types in TypeScript
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 中的基本类型
- en: One of the key features of TypeScript is its rich type system. TypeScript introduces
    several basic types that you can use to describe the shape of your data. To specify
    the type of a variable, you use a colon after the variable name, followed by the
    type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的一个关键特性是其丰富的类型系统。TypeScript 引入了几种基本类型，您可以使用它们来描述您数据的结构。要指定变量的类型，您在变量名后使用冒号，然后跟类型。
- en: 'Let’s explore these basic types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些基本类型：
- en: '**Boolean**: The most basic datatype is the simple `true`/`false` value, which
    JavaScript and TypeScript call a Boolean:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布尔值**: 最基本的类型是简单的 `true`/`false` 值，JavaScript 和 TypeScript 称其为 Boolean：'
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Number**: As in JavaScript, all numbers in TypeScript are floating point
    values. These floating point numbers get the type number:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**: 与 JavaScript 一样，TypeScript 中的所有数字都是浮点值。这些浮点数获得 `number` 类型：'
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**String**: Another fundamental part of creating programs in JavaScript for
    web pages and servers alike is working with **textual data**. As in other languages,
    we use the type string to refer to these textual datatypes:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**: 在 JavaScript 中创建用于网页和服务器程序的基本部分之一是处理 **文本数据**。与其他语言一样，我们使用 `string`
    类型来引用这些文本数据类型：'
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Array**: TypeScript, like JavaScript, allows you to work with arrays of values.
    Array types can be written in one of two ways. In the first, you use the type
    of the elements followed by `[]` to denote an array of that element type:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**: TypeScript，就像 JavaScript 一样，允许您使用值数组。数组类型可以用两种方式之一来编写。在第一种方式中，您使用元素的类型，然后跟上一个
    `[]` 来表示该元素类型的数组：'
- en: '[PRE12]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second way uses a generic array type, `Array<elemType>`:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二种方式使用泛型数组类型，`Array<elemType>`：
- en: '[PRE13]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Tuple**: Tuple types allow you to express an array where the type of a fixed
    number of elements is known but does not need to be the same. For example, you
    may want to represent a value as a pair of a `string` and a `number`:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**: 元组类型允许您表达一个数组，其中已知固定数量元素的类型，但不需要它们相同。例如，您可能希望将一个值表示为一个 `string` 和一个
    `number` 的对：'
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Enum**: A helpful addition to the standard set of datatypes from JavaScript
    is the `enum`. As in languages like C#, an `enum` is a way of giving more friendly
    names to sets of numeric values:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**枚举**：JavaScript 标准数据类型集的一个有用补充是 `enum`。类似于 C# 等语言，`enum` 是为数值集合提供更友好名称的一种方式：'
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Any**: We may need to describe the type of variables that we do not know
    when we are writing an application. These values may come from dynamic content,
    for example, from the user or a third-party library. In these cases, we want to
    opt out of type-checking and let the values pass through compile-time checks.
    To do so, we label these with the `any` type:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Any**：当我们编写应用程序时，我们可能需要描述我们不知道的变量的类型。这些值可能来自动态内容，例如用户或第三方库。在这些情况下，我们希望退出类型检查并让值通过编译时检查。为此，我们用
    `any` 类型标记这些值：'
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Unknown**: The `unknown` type is a type-safe counterpart of `any`. Anything
    is assignable to `unknown`, but `unknown` isn’t assignable to anything but itself
    and `any` without a type assertion or a control flow-based narrowing. Likewise,
    no operations are permitted on an `unknown` without first asserting or narrowing
    to a more specific type:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unknown**：`unknown` 类型是 `any` 的类型安全对应物。任何东西都可以赋值给 `unknown`，但 `unknown` 只能赋值给自己和
    `any`（在没有类型断言或基于控制流的缩窄的情况下）。同样，在没有首先断言或缩窄到更具体的类型之前，不允许对 `unknown` 执行任何操作：'
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we can’t assign `notSure` to `surelyNotAString` without a type-check,
    because `notSure` is of the `unknown` type. This helps prevent errors because
    we can’t inadvertently perform operations on variables of the `unknown` type without
    first checking their types.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，如果没有类型检查，我们不能将 `notSure` 赋值给 `surelyNotAString`，因为 `notSure` 是 `unknown`
    类型。这有助于防止错误，因为我们不能在不首先检查其类型的情况下意外地对 `unknown` 类型的变量执行操作。
- en: 'A common use case for `unknown` is in a `catch` clause, where the type of the
    `error` object is not known:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`unknown` 的一个常见用例是在 `catch` 子句中，其中 `error` 对象的类型是未知的：'
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we don’t know what the `error` type might be, so we give it
    the `unknown` type. This forces us to check its type before we can interact with
    it.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不知道 `error` 类型可能是什么，所以我们给它赋予 `unknown` 类型。这迫使我们在与它交互之前检查其类型。
- en: '**Void**: `void` is a little like the opposite of `any`: the absence of having
    any type at all. You may commonly see this as the return type of functions that
    do not return a value:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Void**：`void` 类似于 `any` 的对立面：完全没有类型。你可能会常见到它是没有返回值的函数的返回类型：'
- en: '[PRE19]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Null and undefined**: In TypeScript, both `undefined` and `null` actually
    have their own types named `undefined` and `null` respectively. Much like `void`,
    they’re not extremely useful on their own:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Null 和 undefined**：在 TypeScript 中，`undefined` 和 `null` 实际上分别有自己的类型，分别命名为
    `undefined` 和 `null`。与 `void` 类似，它们本身并不非常有用：'
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, `undefined` plays a crucial role in optional types. In TypeScript,
    you can make a type optional by adding `?` after the type name. This means the
    value can be of the specified type or `undefined`. For example:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，`undefined` 在可选类型中起着至关重要的作用。在 TypeScript 中，你可以在类型名称后添加 `?` 来使一个类型可选。这意味着值可以是指定的类型或
    `undefined`。例如：
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Never:** The `never` type in TypeScript represents a type of value that never
    occurs. It’s used in situations where a function never returns a value or reaches
    the end of its execution path. For example, a function that throws an error or
    one that has an infinite loop can be annotated with the `never` type:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永不**：在 TypeScript 中，`never` 类型代表一种永远不会发生值的类型。它在函数永远不会返回值或达到其执行路径的末尾时使用。例如，抛出错误的函数或具有无限循环的函数可以用
    `never` 类型进行注解：'
- en: '[PRE22]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Understanding these basic types is a crucial first step in working with TypeScript.
    As you start to use TypeScript in your projects, you’ll find that these types
    are powerful tools for writing robust, maintainable code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些基本类型是在 TypeScript 中工作的关键第一步。当你开始在项目中使用 TypeScript 时，你会发现这些类型是编写健壮、可维护代码的强大工具。
- en: In the next section, we’ll delve deeper into TypeScript’s type system and explore
    interfaces and type aliases, which provide a way to define complex types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨 TypeScript 的类型系统，并探索接口和类型别名，它们提供了一种定义复杂类型的方法。
- en: Interfaces and type aliases
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和类型别名
- en: While the basic types are useful for simple data types, when dealing with more
    complex data structures, we need more powerful tools. This is where interfaces
    and type aliases come in. They allow us to define complex types and give them
    a name.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本类型对于简单数据类型很有用，但在处理更复杂的数据结构时，我们需要更强大的工具。这就是接口和类型别名发挥作用的地方。它们允许我们定义复杂类型并给它们命名。
- en: Interfaces
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口
- en: 'An interface in TypeScript is a way of defining a contract for complex types.
    It describes the shape an object should have. Here’s an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，接口是一种定义复杂类型合同的方式。它描述了一个对象应该具有的形状。以下是一个示例：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we’ve defined a `User` interface with two properties: `name`
    and `email`, both of which are strings. We can use this interface to type-check
    objects:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个具有两个属性`name`和`email`的`User`接口，这两个属性都是字符串类型。我们可以使用这个接口来进行对象类型检查：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we try to assign an object that doesn’t match the `User` interface to the
    user variable, TypeScript will give us an error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将一个不符合`User`接口的对象赋值给用户变量，TypeScript将会给我们一个错误。
- en: Type aliases
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'Type aliases are very similar to interfaces, but can be used for other types
    as well, not just objects. Here’s an example of a `type` alias:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名与接口非常相似，但也可以用于其他类型，而不仅仅是对象。以下是一个`type`别名的示例：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we’ve defined a `Point` type that represents a point in a
    two-dimensional space and `ID` that can be a string or number. We can use these
    `type` aliases in the same way we use interfaces:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个`Point`类型，它代表二维空间中的一个点，以及一个可以是字符串或数字的`ID`。我们可以像使用接口一样使用这些`type`别名：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Interfaces vs type aliases
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口与类型别名
- en: So, when should you use an interface, and when should you use a type alias?
    In many cases, the two are interchangeable, and it’s mostly a matter of personal
    preference.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时应该使用接口，何时应该使用类型别名？在许多情况下，两者可以互换，这主要是个人的偏好问题。
- en: However, there are some differences. Interfaces are more extensible because
    they can be declared multiple times, and they will be merged together. Typealiases
    can’t be re-opened to add new properties. On the other hand, type aliases can
    represent other types like union types, intersection types, tuples, and any other
    types that aren’t currently available in an interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些不同之处。接口更具有可扩展性，因为它们可以被多次声明，并且会合并在一起。类型别名不能重新打开以添加新属性。另一方面，类型别名可以表示其他类型，如联合类型、交叉类型、元组以及其他在接口中目前不可用的类型。
- en: In general, if you’re defining the shape of an object, either an interface or
    a type alias would work. If you’re defining a type that could be something other
    than an object, you’ll need to use a type alias.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你正在定义对象的形状，无论是接口还是类型别名都可以。如果你正在定义一个可能不是对象的类型，你需要使用类型别名。
- en: In this section, we’ve taken our first steps into the world of TypeScript. We’ve
    learned about its setup in a **Vite** project, its basic types, and how to define
    complex types using interfaces and type aliases.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们迈出了TypeScript世界的第一步。我们学习了在**Vite**项目中设置TypeScript、其基本类型以及如何使用接口和类型别名定义复杂类型。
- en: Now let’s explore how we can use TypeScript with React components, state, event
    handlers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何将TypeScript与React组件、状态、事件处理程序一起使用。
- en: Using TypeScript in React
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中使用TypeScript
- en: Alright, we’ve made it this far! We’ve learned about the basics of TypeScript
    and talked about its benefits. Now, it’s time to roll up our sleeves and get our
    hands dirty with some practical TypeScript in React.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经走到这一步了！我们已经学习了TypeScript的基础知识，并讨论了它的好处。现在，是时候卷起袖子，用一些实际的TypeScript在React中动手实践了。
- en: 'In this section, we’re going to explore how to use TypeScript to type-check
    all the different parts of a React application. We’ll look at components, props,
    state, event handlers, context, and even refs. Don’t worry: I’ll walk you through
    plenty of examples to help illustrate these concepts.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用TypeScript来检查React应用程序的所有不同部分。我们将查看组件、props、状态、事件处理程序、上下文，甚至是refs。不用担心：我会通过大量的示例来帮助你理解这些概念。
- en: Type-checking props in React components
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React组件中检查props
- en: 'In a React application, one of the primary areas where we can leverage TypeScript
    is in our components, specifically with props. Let’s see the example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个React应用程序中，我们可以利用TypeScript的主要领域之一是在我们的组件中，特别是与props相关。让我们看看示例：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we’re defining a `GreetingProps` type that specifies the shape
    of the props that `Greeting` should receive. We’re then using this type to type-check
    the `name` prop in the `Greeting` component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个`GreetingProps`类型，它指定了`Greeting`应该接收的props的形状。然后我们使用这个类型来检查`Greeting`组件中的`name`
    prop。
- en: 'This is a simple example with just one prop, but the same approach can be used
    for components with more complex props. For example, if a component receives an
    object or an array as a prop, we can define a type that describes the shape of
    that object or array. Here’s an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只有一个props的简单例子，但同样的方法也可以用于具有更复杂props的组件。例如，如果一个组件接收一个对象或数组作为props，我们可以定义一个类型来描述该对象或数组的形状。以下是一个例子：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, the `UserCard` component receives a user prop that is an object
    with name and email properties. We define a `UserProps` type that describes the
    shape of this object and use it to type-check the user prop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`UserCard`组件接收一个包含`name`和`email`属性的对象类型的`user`属性。我们定义一个`UserProps`类型来描述这个对象的形状，并使用它来检查`user`属性的类型。
- en: 'Let’s consider another common scenario in React: **optional props**. Sometimes,
    a component has props that aren’t always required. In these cases, we can provide
    a default value for the prop, and mark it as optional in our type definition.
    Here’s an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑React中另一个常见的场景：**可选props**。有时，一个组件的props不是总是必需的。在这些情况下，我们可以为prop提供一个默认值，并在我们的类型定义中将其标记为可选。以下是一个例子：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `ButtonProps` type, we’re using `React.ReactNode` for the children prop.
    This is a special type provided by React that can accept any kind of renderable
    content. This includes strings, numbers, JSX elements, arrays of these types,
    or even functions that return these types. By using `React.ReactNode`, we’re saying
    that the `children` prop can be any kind of content that React can render. Also,
    we’re using the `disabled` prop, which is optional. We indicate that `disabled`
    is optional by adding a `?` after the prop name in the `ButtonProps` type. We
    also provide a default value of false for disabled in the component function parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ButtonProps`类型中，我们使用`React.ReactNode`作为`children` prop的类型。这是React提供的一个特殊类型，可以接受任何可渲染的内容。这包括字符串、数字、JSX元素、这些类型的数组，甚至是返回这些类型的函数。通过使用`React.ReactNode`，我们表示`children`
    prop可以是React可以渲染的任何类型的内容。此外，我们还使用了可选的`disabled` prop。我们通过在`ButtonProps`类型中将`disabled`
    prop名称后面添加一个`?`来表示`disabled`是可选的。我们还在组件函数参数中为`disabled`提供了默认值false。
- en: 'This way, we can use the `Button` component with or without the `disabled`
    prop, and TypeScript will still type-check it correctly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以在有或没有`disabled` prop的情况下使用`Button`组件，TypeScript仍然会正确地进行类型检查：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Typing state
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化状态
- en: Just as we type-checked our props, we can also use TypeScript to type-check
    the state in our components. This ensures that we’re always using the correct
    types of state values, providing another layer of safety to our code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对props进行了类型检查一样，我们也可以使用TypeScript来检查组件中的状态。这确保了我们始终使用正确的状态值类型，为我们的代码提供了另一层安全保障。
- en: 'Let’s look at an example of how we can apply TypeScript to state in a functional
    component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将TypeScript应用于函数组件中的状态的例子：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this `Counter` component, we’re using `React.useState<number>(0)` to declare
    a state variable `count` with an initial value of `0`. By providing `<number>`
    as a type argument to `useState`, we’re telling TypeScript that `count` should
    always be a number. By the way: we can omit passing `<number>` because TypeScript
    is smart enough to infer that `count` should be a number based on the initial
    value type.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Counter`组件中，我们使用`React.useState<number>(0)`来声明一个初始值为`0`的状态变量`count`。通过将`<number>`作为`useState`的类型参数，我们告诉TypeScript
    `count`始终应该是数字类型。顺便说一句：我们可以省略传递`<number>`，因为TypeScript足够智能，可以根据初始值的类型推断出`count`应该是数字类型。
- en: This also means that the `setCount` function will only accept numbers. If we
    try to call `setCount` with a non-number argument, TypeScript will give us an
    error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着`setCount`函数只会接受数字。如果我们尝试用非数字参数调用`setCount`，TypeScript会给我们一个错误。
- en: Typing event handlers
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化事件处理器
- en: Another area where TypeScript can be very useful in a React application is in
    **event handlers**. By type-checking our event handlers, we can ensure that we’re
    using the correct event types and accessing the right properties on the event
    objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个TypeScript在React应用程序中非常有用的领域是在**事件处理器**。通过类型检查我们的事件处理器，我们可以确保我们使用正确的事件类型，并访问事件对象上的正确属性。
- en: 'Let’s look at an example of a functional component with an input field and
    a typed event handler:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具有输入字段和类型化事件处理器的函数组件的例子：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this `InputField` component, we’re defining a `handleChange` function that
    will be called whenever the input field’s value changes. We’re using the `React.ChangeEvent<HTMLInputElement>`
    type for the event parameter to specify that this function should receive a change
    event from an input field.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`InputField`组件中，我们定义了一个`handleChange`函数，该函数将在输入字段值变化时被调用。我们使用`React.ChangeEvent<HTMLInputElement>`类型作为事件参数，以指定这个函数应该接收来自输入字段的更改事件。
- en: This type includes all the properties we would expect from a change event on
    an input field, such as `event.target.value`. If we try to access a property that
    doesn’t exist on this type of event, TypeScript will give us an error.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型包括我们从输入字段更改事件中期望的所有属性，例如`event.target.value`。如果我们尝试访问这个类型上不存在的属性，TypeScript会给我们一个错误。
- en: Typing context
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化上下文
- en: 'When using TypeScript with React, we can also type-check our context to ensure
    that we’re always using the correct types of values. Let’s look at an example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用TypeScript与React时，我们还可以对上下文进行类型检查，以确保我们始终使用正确的值类型。让我们看看一个例子：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we’re creating a `ThemeContext` with `React.createContext`.
    We’re providing a `ThemeContextType` as a type argument to `createContext` to
    specify the shape of the context value. This type includes a theme string and
    a `setTheme` function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`React.createContext`创建了一个`ThemeContext`。我们向`createContext`提供一个`ThemeContextType`作为类型参数，以指定上下文值的形状。这个类型包括一个主题字符串和一个`setTheme`函数。
- en: We’re then creating a `ThemeProvider` component that provides the theme and
    `setTheme` values to the context. Inside the `useTheme` hook, we’re using `React.useContext`
    to consume the `ThemeContext`. If the context is `null`, we throw an error.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`ThemeProvider`组件，它将主题和`setTheme`值提供给上下文。在`useTheme`钩子内部，我们使用`React.useContext`来消费`ThemeContext`。如果上下文是`null`，我们抛出一个错误。
- en: This is a common pattern to ensure that the context is used within a provider.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的模式，以确保在提供者内部使用上下文。
- en: With this example, I want to highlight an important TypeScript feature. In the
    `useTheme` hook, we don’t specify the type. It returns the context value, which
    TypeScript knows is of the `ThemeContextType` type and not `null`, thanks to the
    error check. This means that when we use `useTheme`, TypeScript will automatically
    provide the correct, non-null context type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我想强调TypeScript的一个重要特性。在`useTheme`钩子中，我们不需要指定类型。它返回上下文值，TypeScript知道它是`ThemeContextType`类型而不是`null`，这要归功于错误检查。这意味着当我们使用`useTheme`时，TypeScript会自动提供正确的非空上下文类型。
- en: Typing refs
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入引用
- en: 'Now, let’s turn our attention to another powerful feature in React: refs. As
    you already know from *Chapter 3*, *Understanding React Components and Hooks*,
    refs give us a way to access **DOM nodes** or **React elements** directly within
    our components. But how do we ensure we’re using refs correctly? TypeScript coming
    to the rescue.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向React中的另一个强大特性：refs。正如你从*第3章*，*理解React组件和Hooks*中已经知道的，refs给我们提供了一个在组件内部直接访问**DOM节点**或**React元素**的方法。但我们是怎样确保正确使用refs的呢？TypeScript来帮忙。
- en: 'Consider this example where we apply TypeScript to refs:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子，我们将TypeScript应用到refs上：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this `InputField` component, we’re creating a ref with `React.useRef`. We’re
    providing `HTMLInputElement` as a type argument to `useRef` to specify the type
    of the ref. `HTMLInputElement` is a type provided by TypeScript’s built-in DOM
    typings, and it represents an input element in the DOM. This type corresponds
    to the type of the DOM element that the ref is attached to.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`InputField`组件中，我们使用`React.useRef`创建了一个引用。我们向`useRef`提供一个`HTMLInputElement`作为类型参数，以指定引用的类型。`HTMLInputElement`是TypeScript内置DOM类型提供的一个类型，它代表DOM中的一个输入元素。这个类型对应于引用附加到的DOM元素的类型。
- en: This means that `inputRef.current` will be of the `HTMLInputElement | null`
    type, and TypeScript will know that it has a `focus` method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`inputRef.current`将是`HTMLInputElement | null`类型，TypeScript会知道它有一个`focus`方法。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the world of type-checking and validation in
    React. We started with the importance of props validation, then introduced TypeScript
    and its benefits for robust type-checking.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了React中的类型检查和验证的世界。我们从属性验证的重要性开始，然后介绍了TypeScript及其在健壮类型检查方面的好处。
- en: We then applied TypeScript to React, demonstrating its use in type-checking
    various aspects of React components, from props and state to event handlers, context,
    and refs. All of it allows you to create applications that are not only more dependable
    but also easier to maintain, allowing for early detection of errors and significantly
    improving both the quality of your code and your efficiency as a developer.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将 TypeScript 应用于 React，展示了它在检查 React 组件各个方面（从 props 和 state 到事件处理器、上下文和
    refs）中的使用。所有这些功能都允许你创建不仅更可靠而且更容易维护的应用程序，能够早期发现错误，显著提高你的代码质量和作为开发者的效率。
- en: As we move to the next chapter, *Handling Navigation with Routes*, we’ll shift
    our focus to navigation in React applications. We’ll learn how to set up and use
    routes to navigate between different parts of our application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入下一章，*使用路由处理导航*，我们将把我们的重点转向 React 应用程序中的导航。我们将学习如何设置和使用路由在应用程序的不同部分之间进行导航。
