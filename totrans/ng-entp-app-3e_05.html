<html><head></head><body>
  <div id="_idContainer254" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-165" class="chapterTitle">Designing Authentication and Authorization</h1>
    <p class="normal">Designing a high-quality <strong class="keyWord">authentication</strong> and <strong class="keyWord">authorization</strong> system without frustrating the end user is a difficult<a id="_idIndexMarker449"/> problem<a id="_idIndexMarker450"/> to solve. Authentication is the act of verifying the identity of a user, and authorization specifies the privileges that a user must have to access a resource. Both processes, <strong class="keyWord">auth</strong> for short, must seamlessly work in tandem to address users’ needs with varying roles, needs, and job functions.</p>
    <p class="normal">On today’s web, users have a high baseline level of expectations from any auth system they encounter through the browser, so this is an important part of your application to get right the first time. The user should always know what they can and can’t do in your application. If there are errors, failures, or mistakes, the user should be informed about why they occurred. As your application grows, it will be easy to miss how an error condition could be triggered. Your implementation should be easy to extend or maintain. Otherwise, this basic backbone of your application will require a lot of maintenance. In this chapter, we will walk through the challenges of creating a great auth UX and implementing a solid baseline experience.</p>
    <p class="normal">In this chapter, we will implement a token-based auth scheme around the user entity defined in the last chapter. For a robust and maintainable implementation, we will deep dive into <strong class="keyWord">Object-Oriented Programming</strong> (<strong class="keyWord">OOP</strong>) with abstraction, inheritance, and factories, along with implementing a cache <a id="_idIndexMarker451"/>service, a UI service, and an in-memory fake auth service for testing and educational purposes.</p>
    <p class="normal">In this chapter, we’re going to cover the following topics:</p>
    <ul>
      <li class="bulletList">Designing an auth workflow</li>
      <li class="bulletList">TypeScript operators for safe data handling</li>
      <li class="bulletList">Implementing data entities</li>
      <li class="bulletList">Reusable services leveraging OOP concepts</li>
      <li class="bulletList">Creating an auth service</li>
      <li class="bulletList">A cache service using localStorage</li>
      <li class="bulletList">An in-memory auth service</li>
      <li class="bulletList">Logout</li>
      <li class="bulletList">An HTTP interceptor</li>
    </ul>
    <h1 id="_idParaDest-166" class="heading-1">Technical requirements </h1>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the following linked repository. The repository contains the final and completed state of the code. You can verify your progress at the end of this chapter by looking for the end-of-chapter snapshot of code under the <code class="inlineCode">projects</code> folder.</p>
    <p class="normal">For <em class="italic">Chapter 5</em>:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Clone the repository <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</li>
      <li class="numberedList">Execute <code class="inlineCode">npm install</code> on the root folder to install dependencies.</li>
      <li class="numberedList">The beginning state of the project is reflected at:
        <pre class="programlisting con"><code class="hljs-con">projects/stage7
</code></pre>
      </li>
      <li class="numberedList">The end state of the project is reflected at:
        <pre class="programlisting con"><code class="hljs-con">projects/stage8
</code></pre>
      </li>
      <li class="numberedList">Add the stage name to any <code class="inlineCode">ng</code> command to act only on that stage:
        <pre class="programlisting con"><code class="hljs-con">npx ng build stage8
</code></pre>
        <div class="packt_tip">
          <p class="normal">Note that the <code class="inlineCode">dist/stage8</code> folder at the root of the repository will contain the compiled result.</p>
        </div>
      </li>
    </ol>
    <div class="note">
      <p class="normal">Beware that the source code provided in the book and the version on GitHub are likely to be different. The ecosystem around these projects is ever-evolving. Between changes to how Angular CLI generates new code, bug fixes, new versions of libraries, and side-by-side implementations of multiple techniques, there’s a lot of variation that’s impossible to account for. If you find errors or have questions, please create an issue or submit a pull request on GitHub.</p>
    </div>
    <p class="normal">Let’s start by going over how a token-based auth workflow functions.</p>
    <h1 id="_idParaDest-167" class="heading-1">Designing an auth workflow</h1>
    <p class="normal">A <a id="_idIndexMarker452"/>well-designed authentication workflow is stateless so that there’s no concept of an expiring session. Users can interact with your stateless REST APIs from as many devices and tabs as they wish, simultaneously or over time. A <strong class="keyWord">JSON Web Token</strong> (<strong class="keyWord">JWT</strong>) implements<a id="_idIndexMarker453"/> distributed claims-based authentication that can be digitally signed or information-protected and/or encrypted, using <a id="_idIndexMarker454"/>a <strong class="keyWord">Message Authentication Code</strong> (<strong class="keyWord">MAC</strong>). This means that once a user’s identity is authenticated (that is, a password challenge on a login form), they receive an encoded claim ticket or a token, which can then be used to make future requests to the system without having to reauthenticate the identity of the user.</p>
    <p class="normal">The server can independently verify the validity of this claim and process the requests without requiring prior knowledge of having interacted with this user. Thus, we don’t have to store session information regarding a user, making our solution stateless and easy to scale. Each token will expire after a predefined period, and due to their distributed nature, they can’t be remotely or individually revoked; however, we can bolster real-time security by interjecting custom account and user role status checks to ensure that the authenticated user is authorized to access server-side resources.</p>
    <div class="packt_tip">
      <p class="normal">JWTs <a id="_idIndexMarker455"/>implement the <strong class="keyWord">Internet Engineering Task Force</strong> (<strong class="keyWord">IETF</strong>) industry standard <a id="_idIndexMarker456"/>RFC 7519, found at <a href="https://tools.ietf.org/html/rfc7519"><span class="url">https://tools.ietf.org/html/rfc7519</span></a>.</p>
    </div>
    <p class="normal">A good authorization workflow enables conditional navigation based on a user’s role, so users are automatically taken to the optimal landing screen; routes and UI elements that are not suitable for their roles should not be displayed, and if, by mistake, they try to access a restricted path, they should be prevented from doing so. You must remember that any client-side role-based navigation is merely a convenience and is not meant for security. </p>
    <p class="normal">This means that every call made to the server should contain the necessary header information, with the secure token, so that the user can be reauthenticated by the server and their role independently verified. Only then will they be allowed to retrieve secured data. By its nature, client-side authentication can’t be trusted. All auth logic must be implemented server-side. Implementing password reset screens securely can be especially challenging, since they can be triggered within your web app or via a link embedded into an email/notification. When the modality of interaction increases, the attack surface grows with it. For this reason, I recommend building reset screens with server-side rendering so that both the user and the server can verify that the intended user is interacting with the system. If you’re implementing this client-side, you must ensure the server generates a time-limited, one-time-use-only token to <a id="_idIndexMarker457"/>pass alongside the new password so that you can be reasonably sure the request is legitimate. Next, let’s dive into how you can generate secure tokens.</p>
    <h2 id="_idParaDest-168" class="heading-2">JWT life cycle</h2>
    <p class="normal">JWTs complement a stateless <a id="_idIndexMarker458"/>REST API architecture with an encrypted token mechanism that allows convenient, distributed, and high-performance authentication and authorization of client requests. There are three main components of a token-based authentication scheme:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Client-side</strong>: Captures<a id="_idIndexMarker459"/> login information and hides disallowed actions for a good UX.</li>
      <li class="bulletList"><strong class="keyWord">Server-side</strong>: Validates<a id="_idIndexMarker460"/> that every request is authenticated and has the proper authorization.</li>
      <li class="bulletList"><strong class="keyWord">Auth service</strong>: Generates <a id="_idIndexMarker461"/>and validates encrypted tokens and independently verifies the auth status of user requests from a data store.</li>
    </ul>
    <p class="normal">A secure system presumes that data sent/received between clients (applications and browsers), systems (servers and services), and databases are encrypted using <strong class="keyWord">Transport Layer Security</strong> (<strong class="keyWord">TLS</strong>), which<a id="_idIndexMarker462"/> is essentially a newer version of the <strong class="keyWord">Secure Sockets Layer</strong> (<strong class="keyWord">SSL</strong>). Your REST API must be hosted with a properly configured SSL <a id="_idIndexMarker463"/>certificate, serving all API calls over HTTPS so that user credentials are never exposed between the client and the server. Similarly, any database or third-party service call should happen over TLS. This ensures the security of the data in transit.</p>
    <p class="normal">At <a id="_idIndexMarker464"/>rest (when data is in a database), passwords should be stored using a secure one-way hashing algorithm with good salting practices.</p>
    <div class="packt_tip">
      <p class="normal">Did all the talk of hashing and salting make you think of breakfast? Unfortunately, they’re cryptography-related terms. If you want to learn more, check out this article: <a href="https://crackstation.net/hashing-security.htm"><span class="url">https://crackstation.net/hashing-security.htm</span></a>.</p>
    </div>
    <p class="normal">Sensitive user information, such <a id="_idIndexMarker465"/>as <strong class="keyWord">Personally Identifiable Information</strong> (<strong class="keyWord">PII</strong>), should be encrypted at rest with a secure two-way encryption algorithm, unlike passwords. Passwords are hashed, so we verify that the user is providing the same password without the system knowing what the password is. With PII, we must be able to decrypt data to display it to the user. However, since the data is encrypted at rest, if the database is compromised, then the hacked data is worthless.</p>
    <p class="normal">Following a layered approach to security is critical, as attackers will need to accomplish the unlikely feat of compromising all layers of your security simultaneously to cause meaningful harm to your business.</p>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">Fun fact</strong>: When you hear about massive data breaches from major corporations, the root cause is a lack of proper implementation of in-transit or at-rest security. Sometimes, this is because it is too computationally expensive to continually encrypt/decrypt data, so engineers rely on being behind firewalls. In that case, once the outer perimeter is breached, as they say, the fox has access to the hen house.</p>
    </div>
    <p class="normal">Consider the following sequence diagram, which highlights the life cycle of JWT-based authentication:</p>
    <figure class="mediaobject"><img src="../Images/B20960_05_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.1: The life cycle of JWT-based authentication</p>
    <p class="normal">Initially, a <a id="_idIndexMarker466"/>user logs in by providing their username and password. Once validated, the user’s authentication status and role are encrypted in a JWT with an expiration date and time, and it is sent back to the browser.</p>
    <p class="normal">Our Angular (or any other) application can cache this token in local or session storage securely so that the user isn’t forced to log in with every request. This way, we don’t resort to insecure practices like storing user credentials in cookies to provide a good UX.</p>
    <div class="note">
      <p class="normal">Our technical reviewer, Jurgen Van de Moere, points out that cookies don’t necessarily have to be insecure.</p>
      <p class="normal">See <a href="https://www.youtube.com/watch?v=9ZOpUtQ_4Uk"><span class="url">https://www.youtube.com/watch?v=9ZOpUtQ_4Uk</span></a> by Philippe De Ryck, explaining how cookies can be a valid mechanism to store a JWT token in specific cases.</p>
    </div>
    <p class="normal">You <a id="_idIndexMarker467"/>will get a better understanding of the JWT life cycle when you implement your own auth service later in this chapter. In the following sections, we will design a fully featured auth workflow around the <strong class="screenText">User</strong> data entity as follows:</p>
    <figure class="mediaobject"><img src="../Images/B20960_05_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.2: The User entity</p>
    <p class="normal">The <strong class="screenText">User</strong> entity described is slightly different from our initial entity model. The entity model reflects how data is stored in the database. </p>
    <p class="normal">The entity is a flattened (or simplified) representation of the user record. Even a flattened entity has complex objects, like a <strong class="keyWord">name</strong>, with properties like first, middle, and last. Furthermore, not all properties are required. Additionally, when interacting with auth systems and other APIs, we may receive incomplete, incorrect, or maliciously formed data, so our code must effectively deal with <code class="inlineCode">null</code> and <code class="inlineCode">undefined</code> variables.</p>
    <p class="normal">Next, let’s see how we can leverage TypeScript operators to effectively deal with unexpected data.</p>
    <h1 id="_idParaDest-169" class="heading-1">TypeScript operators for safe data handling</h1>
    <p class="normal">JavaScript is a dynamically typed<a id="_idIndexMarker468"/> language. At runtime, the JavaScript engine executing our code, like Chrome’s V8, doesn’t know the type of variable we’re using. As a result, the engine must infer the type. We can have basic types like <code class="inlineCode">boolean</code>, <code class="inlineCode">number</code>, <code class="inlineCode">array</code>, or <code class="inlineCode">string</code>, or we can have a complex type, which is essentially a JSON object. In addition, variables can be <code class="inlineCode">null</code> or <code class="inlineCode">undefined</code>. In broad terms, <code class="inlineCode">undefined</code> represents something that hasn’t been declared or initialized, and <code class="inlineCode">null</code> represents the intentional absence of the value of a declared variable.</p>
    <p class="normal">In strongly typed languages, the concept of <code class="inlineCode">undefined</code> doesn’t exist. Basic types have default values, like a <code class="inlineCode">number</code> being a zero or a <code class="inlineCode">string</code> being an empty string. However, complex types can be <code class="inlineCode">null</code>. A <code class="inlineCode">null</code> reference means the variable is defined, but there’s no value behind it.</p>
    <div class="packt_tip">
      <p class="normal">The inventor of the <code class="inlineCode">null</code> reference, Tony Hoare, called it his “billion-dollar mistake.”</p>
    </div>
    <p class="normal">TypeScript brings the concepts of strongly typed languages to JavaScript, so it must bridge the gap between the two worlds. As a result, TypeScript defines types like <code class="inlineCode">null</code>, <code class="inlineCode">undefined</code>, <code class="inlineCode">any</code>, and <code class="inlineCode">never</code> to make sense of JavaScript’s type semantics. I’ve added links to relevant TypeScript documentation in the <em class="italic">Further reading</em> section for a deeper dive into TypeScript types.</p>
    <p class="normal">As the TypeScript documentation puts it, TypeScript treats <code class="inlineCode">null</code> and <code class="inlineCode">undefined</code> differently to match the JavaScript semantics. For example, the union type <code class="inlineCode">string | null</code> is a different type than <code class="inlineCode">string | undefined</code> and <code class="inlineCode">string | undefined | null</code>.</p>
    <p class="normal">There’s another nuance: checking to see whether a value equals <code class="inlineCode">null</code> using <code class="inlineCode">==</code> versus <code class="inlineCode">===</code>. Using the double equals operator, checking that <code class="inlineCode">foo != null</code> means that <code class="inlineCode">foo</code> is defined and not <code class="inlineCode">null</code>. However, using the triple-equals operator, <code class="inlineCode">foo !== null</code> means that <code class="inlineCode">foo</code> is not <code class="inlineCode">null</code> but could be <code class="inlineCode">undefined</code>. However, these two operators don’t consider the truthiness of the variable, which includes the case of an empty string.</p>
    <p class="normal">These subtle differences have a great impact on how you write code, especially when using the strict TypeScript rules that are applied when you create your Angular application using the <code class="inlineCode">--strict</code> option. It is important to remember that TypeScript is a compile-time tool and not a runtime tool. At runtime, we’re still dealing with the realities of a dynamically typed language. Just because we declared a type to be a string doesn’t mean<a id="_idIndexMarker469"/> that we will receive a string.</p>
    <p class="normal">Next, let’s see how we can deal with issues related to working with unexpected values.</p>
    <h2 id="_idParaDest-170" class="heading-2">Null and undefined checking</h2>
    <p class="normal">When working with other libraries or dealing with information sent or received outside of your application, you must deal with the fact <a id="_idIndexMarker470"/>that the variable you receive might<a id="_idIndexMarker471"/> be <code class="inlineCode">null</code> or <code class="inlineCode">undefined</code>.</p>
    <p class="normal">Outside of your application means dealing with user input, reading from a cookie or <code class="inlineCode">localStorage</code>, URL parameters from the router, or an API call over HTTP, to name a few examples.</p>
    <p class="normal">In our code, we mostly care about the truthiness of a variable. This means that a variable is defined, not null, and if it’s a basic type, it has a non-default value. Given a <code class="inlineCode">string</code>, we can check whether the <code class="inlineCode">string</code> is truthy with a simple <code class="inlineCode">if</code> statement:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">if</span>(foo) {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'truthy'</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'falsy'</span>)
}
</code></pre>
    <p class="normal">If <code class="inlineCode">foo</code> is <code class="inlineCode">null</code>, <code class="inlineCode">undefined</code>, or an empty string, the variable will be considered <code class="inlineCode">falsy</code>. For certain situations, we can use the conditional or ternary operator instead of <code class="inlineCode">if-else</code>.</p>
    <h2 id="_idParaDest-171" class="heading-2">The conditional or ternary operator</h2>
    <p class="normal">The<a id="_idIndexMarker472"/> conditional or ternary operator has the <code class="inlineCode">?:</code> syntax. On the left-hand side of the question mark, the operator takes a conditional<a id="_idIndexMarker473"/> statement. On the right-hand side, we provide the outcomes for true and false around the colon: <code class="inlineCode">conditional ? true-outcome : false-outcome</code>. The conditional or ternary operator is a compact way to represent <code class="inlineCode">if-else</code> conditions and can be very useful to increase the readability of your code base. This operator is not a replacement for an <code class="inlineCode">if-else</code> block, but it is of great use when using the output of the <code class="inlineCode">if-else</code> condition.</p>
    <p class="normal">Consider the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>
<span class="hljs-keyword">if</span>(foo) {
  result = <span class="hljs-string">'truthy'</span>
} <span class="hljs-keyword">else</span> {
  result = <span class="hljs-string">'falsy'</span>
}
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(result)
</code></pre>
    <p class="normal">The preceding <code class="inlineCode">if-else</code> block can be rewritten as:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(foo ? <span class="hljs-string">'truthy'</span> : <span class="hljs-string">'falsy'</span>)
</code></pre>
    <p class="normal">In this case, the <a id="_idIndexMarker474"/>conditional or ternary <a id="_idIndexMarker475"/>operator makes the code more compact and easier to understand. Another common scenario is returning a default value, where the variable is <code class="inlineCode">falsy</code>.</p>
    <p class="normal">Next, we consider the null coalescing operator.</p>
    <h2 id="_idParaDest-172" class="heading-2">The null coalescing operator</h2>
    <p class="normal">The null coalescing <a id="_idIndexMarker476"/>operator<a id="_idIndexMarker477"/> is <code class="inlineCode">||</code>. This operator saves us from repetition when the truthy result of the conditional is the same as the conditional itself.</p>
    <p class="normal">Consider the example where if <code class="inlineCode">foo</code> is defined, we would like to use the value of <code class="inlineCode">foo</code>, but if it is <code class="inlineCode">undefined</code>, we need a default value of <code class="inlineCode">'bar'</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(foo ? foo : <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">As you can see, <code class="inlineCode">foo</code> is repeated twice. We can avoid the duplication by using the null coalescing operator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(foo || <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">So, if <code class="inlineCode">foo</code> is <code class="inlineCode">undefined</code>, <code class="inlineCode">null,</code> or an empty string, <code class="inlineCode">bar</code> will be output. Otherwise, the value of <code class="inlineCode">foo</code> will<a id="_idIndexMarker478"/> be used. But in some<a id="_idIndexMarker479"/> cases, we need only to use the default value if the value is <code class="inlineCode">undefined</code> or <code class="inlineCode">null</code>. </p>
    <p class="normal">Let’s have a look at the nullish coalescing operator next.</p>
    <h2 id="_idParaDest-173" class="heading-2">The nullish coalescing operator</h2>
    <p class="normal">The nullish coalescing operator<a id="_idIndexMarker480"/> is <code class="inlineCode">??</code>. This operator is like the null coalescing <a id="_idIndexMarker481"/>operator, with one crucial difference. Checking the truthiness of a variable is not enough when dealing with data received from an API or user input, where an empty string may be a valid value. As we covered earlier in this section, checking for <code class="inlineCode">null</code> and <code class="inlineCode">undefined</code> is not as straightforward as it seems. However, we know that by using the double equals operator, we can ensure that <code class="inlineCode">foo</code> is defined and not null:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(foo != <span class="hljs-literal">null</span> ? foo : <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">In the preceding case, if <code class="inlineCode">foo</code> is an empty string or another value, we will get the value of the <code class="inlineCode">foo</code> output. If it is <code class="inlineCode">null</code> or <code class="inlineCode">undefined</code>, we will get <code class="inlineCode">'bar'</code>. A more compact way to do this is by using the nullish coalescing operator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">string</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(foo ?? <span class="hljs-string">'bar'</span>)
</code></pre>
    <p class="normal">The preceding code will yield the same result as the previous example. However, when dealing with complex objects, we need to consider whether their properties are <code class="inlineCode">null</code> or <code class="inlineCode">undefined</code> as well. For this, we will consider the optional chaining operator.</p>
    <h2 id="_idParaDest-174" class="heading-2">Optional chaining</h2>
    <p class="normal">The optional chaining<a id="_idIndexMarker482"/> operator<a id="_idIndexMarker483"/> is <code class="inlineCode">?</code>. It is like Angular’s safe navigation operator. Optional chaining ensures that a variable or property is defined and not <code class="inlineCode">null</code> before attempting to access a child property or invoke a function. So the statement <code class="inlineCode">foo?.bar?.callMe()</code> executes without throwing an error, even if <code class="inlineCode">foo</code> or <code class="inlineCode">bar</code> is <code class="inlineCode">null</code> or <code class="inlineCode">undefined</code>.</p>
    <p class="normal">Consider the <code class="inlineCode">user</code> entity, which has a <code class="inlineCode">name</code> object with properties for <code class="inlineCode">first</code>, <code class="inlineCode">middle</code>, and <code class="inlineCode">last</code>. Let’s see what it would take to safely provide a default value of an empty string for a middle name, using the <a id="_idIndexMarker484"/>nullish coalescing<a id="_idIndexMarker485"/> operator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">const</span> user = {
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">first</span>: <span class="hljs-string">'Doguhan'</span>,
    <span class="hljs-attr">middle</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">last</span>: <span class="hljs-string">'Uluca'</span>
  } 
}
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>((user &amp;&amp; user.<span class="hljs-property">name</span> &amp;&amp; user.<span class="hljs-property">name</span>.<span class="hljs-property">middle</span>) ?? <span class="hljs-string">''</span>)
</code></pre>
    <p class="normal">As you can see, we need to check whether a parent object is <code class="inlineCode">truthy</code> before accessing a child property. If <code class="inlineCode">middle</code> is <code class="inlineCode">null</code>, an empty string is output. Optional chaining makes this task simpler:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(user?.<span class="hljs-property">name</span>?.<span class="hljs-property">middle</span> ?? <span class="hljs-string">''</span>)
</code></pre>
    <p class="normal">Using optional chaining and the nullish coalescing operator together, we can eliminate repetition and deliver robust code that can effectively deal with the realities of JavaScript’s dynamic runtime.</p>
    <p class="normal">So, when designing your code, you must decide whether to introduce the concept of null to your logic or work with default values like empty strings. In the next section, as we implement the User entity, you will see how these choices play out. So far, we have only used interfaces to define the shape of our data. Next, let’s build the User entity, leveraging OOP concepts like classes, enums, and abstraction to implement it, along with an auth service.</p>
    <p class="normal">Let’s start simple and see how these patterns are implemented within the context of JavaScript classes and TypeScript fundamentals.</p>
    <h1 id="_idParaDest-175" class="heading-1">Implementing data entities and interfaces</h1>
    <p class="normal">In this section, I will <a id="_idIndexMarker486"/>demonstrate how you can use classes in your own code design <a id="_idIndexMarker487"/>to define and encapsulate the behavior of your models, such as the <code class="inlineCode">User</code> class. Later in this chapter, you will see examples of class inheritance with abstract base classes, which allows us to standardize our implementation and reuse base functionality in a clean and easy-to-maintain manner.</p>
    <div class="note">
      <p class="normal">I must point out that OOP has very useful patterns that can increase the quality of your code; however, if you overuse it, then you will start losing the benefits of the dynamic, flexible, and functional nature of JavaScript.</p>
      <p class="normal">Sometimes, all you need is a bunch of functions in a file, and you’ll see examples of that throughout the book.</p>
    </div>
    <p class="normal">A great way to demonstrate the value of classes would be to standardize the creation of a default <code class="inlineCode">User</code> object. We need this because a <code class="inlineCode">BehaviorSubject</code> object needs to be initialized with a default object. It is best to do this in one place, rather than copy and paste the same implementation in multiple places. It makes a lot of sense for the <code class="inlineCode">User</code> object to own this functionality instead of an Angular service creating default <code class="inlineCode">User</code> objects. So, let’s implement a <code class="inlineCode">User</code> class to achieve this goal.</p>
    <h2 id="_idParaDest-176" class="heading-2">Classes, Interfaces, and Enums</h2>
    <p class="normal">As mentioned, we have only worked with interfaces to represent data. We still want to continue using interfaces when passing data around various components and services. Interfaces are great for describing the kind of properties or functions an implementation has, but they suggest nothing about the behavior of these properties or functions.</p>
    <p class="normal">With ES2015 (ES6), JavaScript gained native support for classes, which is a crucial concept of the OOP paradigm. Classes are <a id="_idIndexMarker488"/>actual implementations of behavior. As opposed to just having a collection of functions in a file, a class can properly encapsulate behavior. A class can then be instantiated as an object using the new keyword.</p>
    <p class="normal">TypeScript takes the ES2015 (and beyond) implementation of classes and introduces necessary concepts like abstract classes, private, protected, and public properties, and interfaces to make it possible to implement OOP patterns.</p>
    <p class="normal">We will begin by defining enums and interfaces for the data entities we need, utilizing the best two features of Typescript.</p>
    <p class="normal">Interfaces<a id="_idIndexMarker489"/> help us practice the Dependency Inversion Principle from SOLID design: depend on abstractions, not on concretions. This means between components or services, it is better to pass the interface of an object (an instantiated class) instead of the object itself. This is why every class we define will implement an interface. Further, interfaces are usually the first thing you can start coding in a new project, using them to implement your walking skeleton and API integrations.</p>
    <p class="normal">Enums <a id="_idIndexMarker490"/>help ensure another important rule: never use string literals. Enums are powerful and awesome.</p>
    <p class="normal">Let’s jump in and define<a id="_idIndexMarker491"/> the interfaces<a id="_idIndexMarker492"/> and enums we need:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Define user roles as an <code class="inlineCode">enum</code> at the location <code class="inlineCode">src/app/auth/auth.enum.ts</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">enum</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title">Role</span> {
  <span class="hljs-title">None</span> = <span class="hljs-string">'none'</span>,
  <span class="hljs-title">Clerk</span> = <span class="hljs-string">'clerk'</span>,
  <span class="hljs-title">Cashier</span> = <span class="hljs-string">'cashier'</span>,
  <span class="hljs-title">Manager</span> = <span class="hljs-string">'manager'</span>,
}
</code></pre>
      </li>
      <li class="numberedList">Create a <code class="inlineCode">user.ts</code> file under the <code class="inlineCode">src/app/user/user</code> folder.</li>
      <li class="numberedList">Define a new interface named <code class="inlineCode">IUser</code> in the <code class="inlineCode">user.ts</code> file:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/user/user.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Role</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../auth/auth.enum'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUser</span> {
  <span class="hljs-attr">_id</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">name</span>: <span class="hljs-title">IName</span>
  <span class="hljs-attr">picture</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">role</span>: <span class="hljs-title">Role</span> | <span class="hljs-built_in">string</span>
  <span class="hljs-attr">userStatus</span>: <span class="hljs-built_in">boolean</span>
  <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-title">Date</span> | <span class="hljs-literal">null</span> | <span class="hljs-built_in">string</span>
  <span class="hljs-attr">level</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">address</span>: {
    <span class="hljs-attr">line1</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">line2?</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">state</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">zip</span>: <span class="hljs-built_in">string</span>
  }
  <span class="hljs-attr">phones</span>: <span class="hljs-title">IPhone</span>[]
}
</code></pre>
        <div class="note">
          <p class="normal">Note that every complex property defined on the interface can also be represented as a <code class="inlineCode">string</code>. In transit, all objects are converted to strings using <code class="inlineCode">JSON.stringify()</code>. No type of information is included. We also leverage interfaces to represent <code class="inlineCode">Class</code> objects in memory, which can have complex types. So, our interface properties must reflect both cases using union types. For example, the <code class="inlineCode">role</code> can either be of type <code class="inlineCode">Role</code> or <code class="inlineCode">string</code>. Similarly, <code class="inlineCode">dateOfBirth</code> can be a <code class="inlineCode">Date</code> or a <code class="inlineCode">string</code>.</p>
        </div>
      
    <p class="normal">We define the <code class="inlineCode">address</code> as an inline type because we don’t use the concept of an address outside of this class. In contrast, we define <code class="inlineCode">IName</code> as its own interface because in <em class="chapterRef">Chapter 8</em>, <em class="italic">Recipes – Reusability, Forms, and Caching</em>, we will implement a separate component for names. We also define a separate interface for phones because they are represented as an array. When <a id="_idIndexMarker493"/>developing a form, we need to be able to address individual <a id="_idIndexMarker494"/>array elements, like <code class="inlineCode">IPhone</code>, in the template code.</p>
    <div class="packt_tip">
      <p class="normal">It is the norm to prepend interface names with a capital <code class="inlineCode">I</code> so that they can be easily identified. Don’t worry; there are no compatibility issues with using the <code class="inlineCode">IPhone</code> interface on Android phones!</p>
    </div></li>
    </ol>



    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">In <code class="inlineCode">user.ts</code>, define the <code class="inlineCode">IName</code> and <code class="inlineCode">IPhone</code> interfaces, and implement the <code class="inlineCode">PhoneType</code> enum:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/user/user.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IName</span> {
  <span class="hljs-attr">first</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">middle?</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">last</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title">PhoneType</span> {
  <span class="hljs-title">None</span> = <span class="hljs-string">'none'</span>,
  <span class="hljs-title">Mobile</span> = <span class="hljs-string">'mobile'</span>,
  <span class="hljs-title">Home</span> = <span class="hljs-string">'</span><span class="hljs-string">home'</span>,
  <span class="hljs-title">Work</span> = <span class="hljs-string">'work'</span>,
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPhone</span> {
  <span class="hljs-attr">type</span>: <span class="hljs-title">PhoneType</span>
  <span class="hljs-attr">digits</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>
}
</code></pre>
        <div class="note">
          <p class="normal">Note that in the <code class="inlineCode">PhoneType</code> enum, we explicitly defined <code class="inlineCode">string</code> values. By default, <code class="inlineCode">enum</code> values are converted into strings as they’re typed, which can lead to issues with values stored in a database falling out of sync with how a developer chooses to spell a variable name. With explicit and all lowercase values, we reduce the risk of bugs.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Next, define<a id="_idIndexMarker495"/> the <code class="inlineCode">User</code> class, which <a id="_idIndexMarker496"/>implements the <code class="inlineCode">IUser</code> interface:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/user/user.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUser</span> {
  <span class="hljs-title">constructor</span>(
<span class="hljs-params">    </span><span class="hljs-comment">// tslint:disable-next-line: variable-name</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> _id = </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> email = </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> name = { first: </span><span class="hljs-string">''</span><span class="hljs-params">, middle: </span><span class="hljs-string">''</span><span class="hljs-params">, last: </span><span class="hljs-string">''</span><span class="hljs-params"> } </span><span class="hljs-keyword">as</span><span class="hljs-params"> </span><span class="hljs-title">IName</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> picture = </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> role = </span><span class="hljs-title">Role</span><span class="hljs-params">.</span><span class="hljs-title">None</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> </span><span class="hljs-attr">dateOfBirth</span><span class="hljs-params">: </span><span class="hljs-title">Date</span><span class="hljs-params"> | </span><span class="hljs-literal">null</span><span class="hljs-params"> = </span><span class="hljs-literal">null</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> userStatus = </span><span class="hljs-literal">false</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> level = </span><span class="hljs-number">0</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> address = {</span>
<span class="hljs-params">      line1: </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">      city: </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">      state: </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">      zip: </span><span class="hljs-string">''</span><span class="hljs-params">,</span>
<span class="hljs-params">    },</span>
<span class="hljs-params">    </span><span class="hljs-keyword">public</span><span class="hljs-params"> </span><span class="hljs-attr">phones</span><span class="hljs-params">: </span><span class="hljs-title">IPhone</span><span class="hljs-params">[] = []</span>
<span class="hljs-params">  </span>) {}
  <span class="hljs-keyword">static</span> <span class="hljs-title">Build</span>(<span class="hljs-attr">user</span>: <span class="hljs-title">IUser</span>) {
    <span class="hljs-keyword">if</span> (!user) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">User</span>()
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">User</span>(
      user.<span class="hljs-property">_id</span>,
      user.<span class="hljs-property">email</span>,
      user.<span class="hljs-property">name</span>,
      user.<span class="hljs-property">picture</span>,
      user.<span class="hljs-property">role</span> <span class="hljs-keyword">as</span> <span class="hljs-title">Role</span>,
      <span class="hljs-keyword">typeof</span> user.<span class="hljs-property">dateOfBirth</span> === <span class="hljs-string">'string'</span>
        ? <span class="hljs-keyword">new</span> <span class="hljs-title">Date</span>(user.<span class="hljs-property">dateOfBirth</span>)
        : user.<span class="hljs-property">dateOfBirth</span>, 
      user.<span class="hljs-property">userStatus</span>,
      user.<span class="hljs-property">level</span>,
      user.<span class="hljs-property">address</span>,
      user.<span class="hljs-property">phones</span>
    )
  }
}
</code></pre>
      
    <div class="note">
      <p class="normal">Note that by defining all properties with default values in the constructors as <code class="inlineCode">public</code> properties, we kill two birds with one stone; otherwise, we would need to define properties and initialize them separately. This way, we achieve a concise implementation.</p>
    </div>
    <p class="normal">Using a<a id="_idIndexMarker497"/> static <code class="inlineCode">Build</code> function, we can quickly hydrate the object <a id="_idIndexMarker498"/>with data received from the server. We can also implement the <code class="inlineCode">toJSON()</code> function to customize the serialization behavior of our object before sending the data to the server. But before that, let’s add a calculated property.</p>
    <p class="normal">We can use calculated properties in templates or toast messages to conveniently display values assembled from multiple parts. A great example is extracting a full name from the <code class="inlineCode">name</code> object as a property in the <code class="inlineCode">User</code> class.</p>
    <div class="packt_tip">
      <p class="normal">A calculated property for assembling a full name encapsulates the logic for combining a first, middle, and last name, so you don’t have to rewrite this logic in multiple places, adhering to the DRY principle!</p>
    </div></li>
    </ol>




    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Implement a <code class="inlineCode">fullName</code> property getter in the <code class="inlineCode">User</code> class:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/user/user.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUser</span> {
  ...
  <span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">get</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">fullName</strong><strong class="hljs-slc">(): </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc"> {</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (!</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">name</strong><strong class="hljs-slc">) {</strong></span>
      <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">''</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">name</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">middle</strong><strong class="hljs-slc">) {</strong></span>
      <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong></span>
        <span class="code-highlight"><strong class="hljs-string-slc">`</strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-subst-slc">.name.first}</strong><strong class="hljs-string-slc"> </strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-subst-slc">.name.middle}</strong><strong class="hljs-string-slc"> </strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-subst-slc">.name.last}</strong><strong class="hljs-string-slc">`</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">`</strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-subst-slc">.name.first}</strong><strong class="hljs-string-slc"> </strong><strong class="hljs-subst-slc">${</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-subst-slc">.name.last}</strong><strong class="hljs-string-slc">`</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Add <code class="inlineCode">fullName</code> to <code class="inlineCode">IUser</code> as an optional <code class="inlineCode">readonly</code> property:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/user/user.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IUser</span> {
  ...
  <span class="hljs-keyword">readonly</span> fullName?: <span class="hljs-built_in">string</span>
}
</code></pre>
      
    <p class="normal">You<a id="_idIndexMarker499"/> can now <a id="_idIndexMarker500"/>use the <code class="inlineCode">fullName</code> property through the <code class="inlineCode">IUser</code> interface.</p></li>
    </ol>

    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Implement the <code class="inlineCode">toJSON</code> function:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/user/user.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUser</span> {
  ...
  
<span class="code-highlight"><strong class="hljs-title-slc">toJSON</strong><strong class="hljs-slc">(): </strong><strong class="hljs-built_in-slc">object</strong><strong class="hljs-slc"> {</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> serialized = </strong><strong class="hljs-title-slc">Object</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">assign</strong><strong class="hljs-slc">(</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">)</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">delete</strong><strong class="hljs-slc"> serialized.</strong><strong class="hljs-property-slc">_id</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">delete</strong><strong class="hljs-slc"> serialized.</strong><strong class="hljs-property-slc">fullName</strong></span>
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> serialized</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Note that when serializing the object, we delete the <code class="inlineCode">_id</code> and <code class="inlineCode">fullName</code> fields. These are values that we don’t want to be stored in the database. The <code class="inlineCode">fullName</code> field is a calculated property, so it doesn’t need storage. The <code class="inlineCode">_id</code> is normally passed as a parameter in a <code class="inlineCode">GET</code> or a <code class="inlineCode">PUT</code> call to locate the record. This avoids mistakes that may result in overwriting the <code class="inlineCode">id</code> fields of existing objects.</p>
    <p class="normal">Now that we have the <code class="inlineCode">User data</code> entity implemented, let’s implement the auth service next.</p>
    <h1 id="_idParaDest-177" class="heading-1">Reusable services leveraging OOP concepts</h1>
    <p class="normal">OOP is <a id="_idIndexMarker501"/>an imperative programming style compared to the reactive programming style that RxJS enables. Classes form the bedrock of OOP, whereas observables do the same for reactive programming using RxJS.</p>
    <p class="normal">I encourage you to become familiar with OOP terminology. Please see the <em class="italic">Further reading</em> section for some useful resources. You should become familiar with:</p>
    <ul>
      <li class="bulletList">Classes versus objects</li>
      <li class="bulletList">Composition (interfaces)</li>
      <li class="bulletList">Encapsulation (private, protected, and public properties, and property getters and setters)</li>
      <li class="bulletList">Polymorphism (inheritance, abstract classes, and method overriding)</li>
    </ul>
    <p class="normal">As you know, Angular uses OOP patterns to implement components and services. For example, interfaces implement life cycle hooks such as <code class="inlineCode">OnInit</code>. We aim to design a flexible auth service that can implement multiple auth providers. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Implementing Role-Based Navigation</em>, we will implement an in-memory provider and a Google Firebase provider. In <em class="chapterRef">Chapter 7</em>, <em class="italic">Working with REST and GraphQL APIs</em>, we will implement two custom <a id="_idIndexMarker502"/>providers to interact with our backend and see how <strong class="keyWord">Role-based Access Control </strong>(<strong class="keyWord">RBAC</strong>) is implemented.</p>
    <p class="normal">By declaring an abstract base class, we can describe the common login and logout behavior of our application, so when we implement another auth provider, we don’t have to re-engineer our application.</p>
    <p class="normal">In addition, we can declare abstract functions, which the implementors of our base class would have to implement, enforcing our design. Any class that implements the base class would also get the benefit of the code implemented in the base class, so we wouldn’t need to repeat the same logic in two different places.</p>
    <p class="normal">The following class diagram reflects the architecture and inheritance hierarchy of our abstract <code class="inlineCode">AuthService</code>:</p>
    <figure class="mediaobject"><img src="../Images/B20960_05_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.3: The AuthService inheritance structure</p>
    <p class="normal"><code class="inlineCode">AuthService</code> implements<a id="_idIndexMarker503"/> the interface <code class="inlineCode">IAuthService</code>, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAuthService</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">authStatus$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IAuthStatus</span>&gt;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">currentUser$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IUser</span>&gt;
  <span class="hljs-title">login</span>(<span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-built_in">void</span>&gt;
  <span class="hljs-title">logout</span>(clearToken?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span>
  <span class="hljs-title">getToken</span>(): <span class="hljs-built_in">string</span>
}
</code></pre>
    <p class="normal">The interface reflects the public properties that the service exposes. The service provides the authentication status as the <code class="inlineCode">authStatus$</code> observable and the current user as <code class="inlineCode">currentUser$</code>, and it provides three functions, <code class="inlineCode">login</code>, <code class="inlineCode">logout</code>, and <code class="inlineCode">getToken</code>.</p>
    <p class="normal"><code class="inlineCode">AuthService</code> requires caching functionality from another service called <code class="inlineCode">CacheService</code>. Instead of using inheritance to incorporate cache functionality, we can inject it into the base class. Since <code class="inlineCode">AuthService</code> is an abstract class, it can’t be used independently, so we will implement the three auth providers, <code class="inlineCode">InMemoryAuthService</code>, <code class="inlineCode">FirebaseAuthService</code>, and <code class="inlineCode">CustomAuthService</code>, shown at the bottom of the preceding diagram.</p>
    <div class="note">
      <p class="normal">Composition is preferred over inheritance, so you must ensure you’re using inheritance correctly. Inheritance describes an is-a relationship and composition describes a has-a relationship. In this case, we’re using the correct mixture of inheritance and composition because <code class="inlineCode">FirebaseAuthService</code> is an <code class="inlineCode">AuthService</code>, and <code class="inlineCode">AuthService</code> has a <code class="inlineCode">CacheService</code>.</p>
    </div>
    <p class="normal">Note that all three auth services implement all abstract functions. In addition, the <code class="inlineCode">FirebaseAuthService</code> overrides the base <code class="inlineCode">logout</code> function to implement its own behavior. All three classes inherit from the same abstract class and expose the same public interface. All three will execute the same auth workflow against different auth servers.</p>
    <div class="note">
      <p class="normal">The in-memory auth service doesn’t communicate with a server. The service is for demonstration purposes only. It implements fake JWT encoding, so we can demonstrate how the JWT life cycle works.</p>
    </div>
    <p class="normal">Let’s start by creating the auth service.</p>
    <h1 id="_idParaDest-178" class="heading-1">Creating an auth service</h1>
    <p class="normal">We will start by creating the abstract<a id="_idIndexMarker504"/> auth service and the in-memory service:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add an auth service:
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng g s auth --flat false
<span class="hljs-con-meta">$</span> npx ng g s auth/inMemoryAuth --skip-tests
</code></pre>
      </li>
      <li class="numberedList">Rename <code class="inlineCode">in-memory-auth.service.ts</code> to <code class="inlineCode">auth.in-memory.service.ts</code> so that the different auth providers visually group together in File Explorer.</li>
      <li class="numberedList">Remove the <code class="inlineCode">@Injectable()</code> decorator of <code class="inlineCode">auth.service.ts</code> , but keep it on <code class="inlineCode">auth.in-memory.service.ts</code>.</li>
      <li class="numberedList">Ensure that <code class="inlineCode">authService</code> is provided in <code class="inlineCode">app.module.ts</code> and that <code class="inlineCode">InMemoryAuthService</code> is used and not the abstract class:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">module</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { </strong><strong class="hljs-title-slc">AuthService</strong><strong class="hljs-slc"> } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'./auth/auth.service'</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { </strong><strong class="hljs-title-slc">InMemoryAuthService</strong><strong class="hljs-slc"> } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'./auth/auth.in-memory.service'</strong></span>
...
  <span class="hljs-attr">providers</span>: [
    <span class="code-highlight"><strong class="hljs-slc">{</strong></span>
      <span class="code-highlight"><strong class="hljs-attr-slc">provide</strong><strong class="hljs-slc">: </strong><strong class="hljs-title-slc">AuthService</strong><strong class="hljs-slc">,</strong></span>
      <span class="code-highlight"><strong class="hljs-attr-slc">useClass</strong><strong class="hljs-slc">: </strong><strong class="hljs-title-slc">InMemoryAuthService</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">},</strong></span>
    ...
]
</code></pre>
      </li>
    </ol>
    <p class="normal">Creating a separate <a id="_idIndexMarker505"/>folder for the service organizes various components related to auth, such as the <code class="inlineCode">enum</code> definition for the user role. Additionally, we will be able to add an <code class="inlineCode">authService</code> fake to the same folder for automated testing.</p>
    <h2 id="_idParaDest-179" class="heading-2">Implement an abstract auth service</h2>
    <p class="normal">Now, let’s build an<a id="_idIndexMarker506"/> abstract auth service that will orchestrate logins and logouts while encapsulating the logic of managing JWTs, auth status, and information regarding the current user. By leveraging the abstract class, we should be able to implement our own auth service against any auth provider without modifying the internal behavior of our application.</p>
    <p class="normal">The abstract auth service that we will demonstrate enables rich and intricate workflows. It is a solution that you can drop into your applications without modifying the internal logic. As a result, it is a complicated solution.</p>
    <p class="normal">This auth service will enable us to demonstrate logging in with an email and password, caching, and conditional navigation concepts based on authentication status and a user’s role:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start by installing a JWT decoding library and, to fake authentication, a JWT encoding library:
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npm install jwt-decode 
<span class="hljs-con-meta">$</span> npm install -D @types/jwt-decode
</code></pre>
      </li>
      <li class="numberedList">Implement<a id="_idIndexMarker507"/> an <code class="inlineCode">IAuthStatus</code> interface to store decoded user information, a helper interface, and the secure by default <code class="inlineCode">defaultAuthStatus</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Role</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.enum'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAuthStatus</span> {
  <span class="hljs-attr">isAuthenticated</span>: <span class="hljs-built_in">boolean</span>
  <span class="hljs-attr">userRole</span>: <span class="hljs-title">Role</span>
  <span class="hljs-attr">userId</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IServerAuthResponse</span> {
  <span class="hljs-attr">accessToken</span>: <span class="hljs-built_in">string</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">defaultAuthStatus</span>: <span class="hljs-title">IAuthStatus</span> = {
  <span class="hljs-attr">isAuthenticated</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">userRole</span>: <span class="hljs-title">Role</span>.<span class="hljs-property">None</span>,
  <span class="hljs-attr">userId</span>: <span class="hljs-string">''</span>,
}
...
</code></pre>
     
    <p class="normal"><code class="inlineCode">IAuthStatus</code> is an interface that represents the shape of a typical JWT that you may receive from your authentication service. It contains minimal information about the user and the user’s role. The auth status object can be attached to the header of every REST call to APIs to verify the user’s identity. The auth status can be optionally cached in <code class="inlineCode">localStorage</code> to remember the user’s login state; otherwise, they would have to re-enter their password with every page refresh.</p>
    <p class="normal">In the preceding implementation, we assume the default role of <code class="inlineCode">None</code>, as defined in the <code class="inlineCode">Role</code> enum. By not giving any role to the user by default, we’re following a least-privileged access model. The user’s correct role will be set after they log in successfully with the information received from the auth API.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Define the <code class="inlineCode">IAuthService</code> interface in <code class="inlineCode">auth.service.ts</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.service.ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAuthService</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">authStatus$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IAuthStatus</span>&gt;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">currentUser$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IUser</span>&gt;
  <span class="hljs-title">login</span>(<span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-built_in">void</span>&gt;
  <span class="hljs-title">logout</span>(clearToken?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span>
  <span class="hljs-title">getToken</span>(): <span class="hljs-built_in">string</span>
}
</code></pre>
      </li>
      <li class="numberedList">Make <code class="inlineCode">AuthService</code> an <code class="inlineCode">abstract</code> class, as shown here:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span>
</code></pre>
      </li>
      <li class="numberedList">Implement <a id="_idIndexMarker508"/>the interface, <code class="inlineCode">IAuthService</code>, using VS Code’s quick-fix functionality:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="code-highlight"><strong class="hljs-keyword-slc">implements</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">IAuthService</strong></span> {
  <span class="hljs-attr">authStatus$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IAuthStatus</span>&gt;
  <span class="hljs-attr">currentUser$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IUser</span>&gt;
  
  <span class="code-highlight"><strong class="hljs-title-slc">constructor</strong><strong class="hljs-slc">() {}</strong></span>
  
  <span class="hljs-title">login</span>(<span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
  <span class="hljs-title">logout</span>(clearToken?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
  <span class="hljs-title">getToken</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Error</span>(<span class="hljs-string">'Method not implemented.'</span>)
  }
}
</code></pre>
      </li>
      <li class="numberedList">Implement the <code class="inlineCode">authStatus$</code> and <code class="inlineCode">currentUser$</code> properties as <code class="inlineCode">readonly</code> and initialize our data anchors with their default values:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">IUser</span>, <span class="code-highlight"><strong class="hljs-title-slc">User</strong></span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../user/user/user'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAuthService</span> {
  <span class="code-highlight"><strong class="hljs-keyword-slc">readonly</strong></span> authStatus$ = 
    <span class="code-highlight"><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">BehaviorSubject</strong><strong class="hljs-slc">&lt;</strong><strong class="hljs-title-slc">IAuthStatus</strong><strong class="hljs-slc">&gt;(defaultAuthStatus)  </strong></span>
  <span class="code-highlight"><strong class="hljs-keyword-slc">readonly</strong></span> currentUser$ = 
    <span class="code-highlight"><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">BehaviorSubject</strong><strong class="hljs-slc">&lt;</strong><strong class="hljs-title-slc">IUser</strong><strong class="hljs-slc">&gt;(</strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">User</strong><strong class="hljs-slc">())</strong></span>
  ...
}
</code></pre>
      </li>
    </ol>
    <div class="note">
      <p class="normal">Note that we removed the type definitions of the properties. Instead, we’re letting TypeScript infer the type from the initialization.</p>
    </div>
    <div class="packt_tip">
      <p class="normal">You must always declare your data anchors as <code class="inlineCode">readonly</code> so that you don’t accidentally overwrite the data stream by re-initializing a data anchor as a new <code class="inlineCode">BehaviorSubject</code>. Doing so would render any prior subscribers orphaned, leading to memory leaks, which has many unintended consequences.</p>
    </div>
    <p class="normal">All implementors<a id="_idIndexMarker509"/> of <code class="inlineCode">IAuthService</code> must be able to log the user in, transform the token we get back from the server so that we can read and store it, support access to the current user and the auth status, and provide a way to log the user out. We have successfully put in the functions for our public methods and implemented default values for our data anchors, creating hooks for the rest of our application. But so far, we have only defined what our service can do and not how it can do it.</p>
    <p class="normal">As always, the devil is in the details, and the hard part is the “how.” Abstract functions can help us to complete the implementation of a workflow in a service within our application, while leaving the portions of the service that must implement external APIs undefined.</p>
    <h2 id="_idParaDest-180" class="heading-2">Abstract functions</h2>
    <p class="normal">Auth services that implement the<a id="_idIndexMarker510"/> abstract class should be able to support any kind of auth provider and any kind of token transformation while being able to modify behaviors, like user retrieval logic. We must be able to implement login, logout, token, and auth status management without implementing calls to specific services.</p>
    <p class="normal">By defining abstract functions, we can declare a series of methods that must implement a given set of inputs and outputs—a signature without an implementation. We can then use these abstract functions to orchestrate the implementation of our auth workflow.</p>
    <div class="note">
      <p class="normal">The Open/Closed principle drives our design goal here. The <code class="inlineCode">AuthService</code> will be open to extension through its ability to be extended to work with any kind of token-based auth provider, but it is closed to modification. Once we’re done implementing the <code class="inlineCode">AuthService</code>, we won’t need to modify its code to add additional auth providers.</p>
    </div>
    <p class="normal">Now, we need to define the abstract functions that our auth providers must implement, as shown in <em class="italic">Figure 5.3</em> from earlier in the chapter:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">authProvider(email, password)</code>: <code class="inlineCode">Observable&lt;IServerAuthResponse&gt;</code> can log us in via a provider and return a standardized <code class="inlineCode">IServerAuthResponse</code></li>
      <li class="bulletList"><code class="inlineCode">transformJwtToken(token)</code>: <code class="inlineCode">IAuthStatus</code> can normalize the token a provider returns to the interface of <code class="inlineCode">IAuthStatus</code></li>
      <li class="bulletList"><code class="inlineCode">getCurrentUser()</code>: <code class="inlineCode">Observable&lt;User&gt;</code> can retrieve the user profile of the logged-in user</li>
    </ul>
    <p class="normal">We can then use <a id="_idIndexMarker511"/>these functions in our <code class="inlineCode">login</code>, <code class="inlineCode">logout</code>, and <code class="inlineCode">getToken</code> methods to implement the auth workflow:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Define the abstract methods that the derived classes should implement as protected properties so that they’re accessible in the derived class, but not publicly:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="code-highlight"><strong class="hljs-keyword-slc">export</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">abstract</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">class</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">AuthService</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">implements</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">IAuthService</strong><strong class="hljs-slc"> {</strong></span>
     <span class="code-highlight"><strong class="hljs-keyword-slc">protected</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">abstract</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">authProvider</strong><strong class="hljs-slc">(</strong></span>
       <span class="code-highlight"><strong class="hljs-attr-slc">email</strong><strong class="hljs-slc">: </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc">,</strong></span>
       <span class="code-highlight"><strong class="hljs-attr-slc">password</strong><strong class="hljs-slc">: </strong><strong class="hljs-built_in-slc">string</strong></span>
     <span class="code-highlight"><strong class="hljs-slc">): </strong><strong class="hljs-title-slc">Observable</strong><strong class="hljs-slc">&lt;</strong><strong class="hljs-title-slc">IServerAuthResponse</strong><strong class="hljs-slc">&gt;</strong></span>
     <span class="code-highlight"><strong class="hljs-keyword-slc">protected</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">abstract</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">transformJwtToken</strong><strong class="hljs-slc">(</strong><strong class="hljs-attr-slc">token</strong><strong class="hljs-slc">: </strong><strong class="hljs-built_in-slc">unknown</strong><strong class="hljs-slc">):</strong></span>
       <span class="code-highlight"><strong class="hljs-title-slc">IAuthStatus</strong></span>
     <span class="code-highlight"><strong class="hljs-keyword-slc">protected</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">abstract</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">getCurrentUser</strong><strong class="hljs-slc">(): </strong><strong class="hljs-title-slc">Observable</strong><strong class="hljs-slc">&lt;</strong><strong class="hljs-title-slc">User</strong><strong class="hljs-slc">&gt;</strong></span>
     ...
}
</code></pre>
     
    <p class="normal">Leveraging these stubbed-out methods, we can now implement a login method to log a user in and retrieve the currently logged-in user, updating the <code class="inlineCode">authStatus$</code> and <code class="inlineCode">currentUser$</code> data streams.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Before we move on, implement a <code class="inlineCode">transformError</code> function to handle errors of different types like <code class="inlineCode">HttpErrorResponse</code> and <code class="inlineCode">string</code>, providing them in an observable stream. In a new file named <code class="inlineCode">common.ts</code> under <code class="inlineCode">src/app/common</code>, create the <code class="inlineCode">transformError</code> function:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/common/common.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">HttpErrorResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>
<span class="hljs-keyword">import</span> { throwError } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">transformError</span>(<span class="hljs-attr">error</span><span class="hljs-params">: </span><span class="hljs-title">HttpErrorResponse</span><span class="hljs-params"> | </span><span class="hljs-built_in">string</span>) {
  <span class="hljs-keyword">let</span> errorMessage = <span class="hljs-string">'An unknown error has occurred'</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">'string'</span>) {
    errorMessage = error
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">error</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title">ErrorEvent</span>) {
    errorMessage = <span class="hljs-string">`Error! </span><span class="hljs-subst">${error.error.message}</span><span class="hljs-string">`</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.<span class="hljs-property">status</span>) {
    errorMessage = 
      <span class="hljs-string">`Request failed with </span><span class="hljs-subst">${error.status}</span><span class="hljs-string"> </span><span class="hljs-subst">${error.statusText}</span><span class="hljs-string">`</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Error</span>) {
    errorMessage = error.<span class="hljs-property">message</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title">throwError</span>(errorMessage)
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">auth.service.ts</code>, implement <a id="_idIndexMarker512"/>the <code class="inlineCode">login</code> method:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> * <span class="code-highlight"><strong class="hljs-keyword-slc">as</strong></span> decode <span class="hljs-keyword">from</span> <span class="hljs-string">'jwt-decode'</span>
<span class="hljs-keyword">import</span> { transformError } <span class="hljs-keyword">from</span> <span class="hljs-string">'</span><span class="hljs-string">../common/common'</span>
...
  <span class="hljs-title">login</span>(<span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> loginResponse$ = <span class="hljs-variable">this</span>.<span class="hljs-title">authProvider</span>(email, password)
      .<span class="hljs-title">pipe</span>(
        <span class="hljs-title">map</span>((value) =&gt; {
          const token = <span class="hljs-title">decode</span>(value.accessToken)
          <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">transformJwtToken</span>(token)
        }),
        <span class="hljs-title">tap</span>((status) =&gt; <span class="hljs-variable">this</span>.authStatus$.<span class="hljs-title">next</span>(status)),
        <span class="hljs-title">filter</span>((<span class="hljs-attr">status</span>: <span class="hljs-title">IAuthStatus</span>) =&gt; status.isAuthenticated),
        <span class="hljs-title">flatMap</span>(() =&gt; <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentUser</span>()),
        <span class="hljs-title">map</span>(user =&gt; <span class="hljs-variable">this</span>.currentUser$.<span class="hljs-title">next</span>(user)),
        <span class="hljs-title">catchError</span>(transformError)
      )
    loginResponse$.<span class="hljs-title">subscribe</span>({
      <span class="hljs-attr">error</span>: err =&gt; {
        <span class="hljs-variable">this</span>.<span class="hljs-title">logout</span>()
        <span class="hljs-keyword">return</span> <span class="hljs-title">throwError</span>(err)
      },
    })
    <span class="hljs-keyword">return</span> loginResponse$
  }
</code></pre>
     
    <p class="normal">The <code class="inlineCode">login</code> method encapsulates the correct order of operations by calling the <code class="inlineCode">authProvider</code> with the <code class="inlineCode">email</code> and <code class="inlineCode">password</code> information, then decoding the received JWT, transforming it, and updating <code class="inlineCode">authStatus$</code>. Then, <code class="inlineCode">getCurrentUser()</code> is called only if <code class="inlineCode">status.isAuthenticated</code> is <code class="inlineCode">true</code>. Later, <code class="inlineCode">currentUser$</code> is updated, and finally, we catch any errors using our custom <code class="inlineCode">transformError</code> function.</p>
    <p class="normal">We activate the observable stream by calling <code class="inlineCode">subscribe</code> on it. In the case of an error, we call <code class="inlineCode">logout()</code> to maintain the correct status of our application and bubble up errors to consumers of <code class="inlineCode">login</code> by re-throwing the error, using <code class="inlineCode">throwError</code>.</p>
    <p class="normal">Now, the<a id="_idIndexMarker513"/> corresponding <code class="inlineCode">logout</code> function needs to be implemented. Logout is triggered by the <strong class="screenText">Logout</strong> button from the application toolbar in the case of a failed login attempt, as shown earlier, or if an unauthorized access attempt is detected. We can detect unauthorized access attempts by using a router auth guard as the user navigates the application, which is a topic covered later in the chapter.</p> </li>
    </ol>


    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Implement the <code class="inlineCode">logout</code> method:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
  ...
  <span class="hljs-title">logout</span>(clearToken?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">next</span>(defaultAuthStatus), <span class="hljs-number">0</span>)
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">We log out by pushing out the <code class="inlineCode">defaultAuthStatus</code> as the next value in the <code class="inlineCode">authStatus$</code> stream. Note the use of <code class="inlineCode">setTimeout</code>, which allows us to avoid timing issues when core elements of the application all change statuses at once.</p>
    <div class="packt_tip">
      <p class="normal">Think about how the <code class="inlineCode">login</code> method adheres to the Open/Closed principle. The method is open to extension through the abstract functions <code class="inlineCode">authProvider</code>, <code class="inlineCode">transformJwtToken</code>, and <code class="inlineCode">getCurrentUser</code>. By implementing these functions in a derived class, we can externally supply different auth providers without modifying the <code class="inlineCode">login</code> method. As a result, the implementation of the method remains closed to modification, thus adhering to the Open/Closed principle.</p>
    </div>
    <div class="note">
      <p class="normal">The true value of creating abstract classes is the ability to encapsulate common functionality in an extensible way.</p>
    </div>
    <p class="normal">You may ignore<a id="_idIndexMarker514"/> the <code class="inlineCode">getToken</code> function for now, as we are not yet caching our JWT. Without caching, the user would have to log in with every page refresh. Let’s implement caching next.</p>
    <h1 id="_idParaDest-181" class="heading-1">A cache service using localStorage</h1>
    <p class="normal">We must be able to cache the authentication status of the logged-in user. As mentioned, otherwise, with every page refresh, the user must go through the login routine. We need to update <code class="inlineCode">AuthService</code> so that it persists the auth status.</p>
    <p class="normal">There are three main ways to store data:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">cookie</code></li>
      <li class="bulletList"><code class="inlineCode">localStorage</code></li>
      <li class="bulletList"><code class="inlineCode">sessionStorage</code></li>
    </ul>
    <p class="normal">Cookies, while they have their use<a id="_idIndexMarker515"/> cases, should not be used to store secure data because they can be sniffed or stolen by bad actors. In addition, cookies can store only 4 KB of data and can be set to expire.</p>
    <p class="normal"><code class="inlineCode">localStorage</code> and <code class="inlineCode">sessionStorage</code> are similar. They <a id="_idIndexMarker516"/>are protected and isolated browser-side stores that allow the storage of larger amounts of data for your application. Unlike cookies, you can’t <a id="_idIndexMarker517"/>set an expiration date-time on values stored in either store. Values stored in either store survive page reloads and restores, making them better candidates than cookies for caching information.</p>
    <p class="normal">The major difference between <code class="inlineCode">localStorage</code> and <code class="inlineCode">sessionStorage</code> is how values are persisted across browser tabs. With <code class="inlineCode">sessionStorage</code>, stored values are removed when the browser tab or window is closed. However, <code class="inlineCode">localStorage</code> persists across reboots. In most cases, user logins are cached anywhere from minutes to a month or more, depending on your business, so relying on whether the user closes the browser window isn’t very useful. Through this process of elimination, I prefer <code class="inlineCode">localStorage</code> because of its isolation and long-term storage capabilities.</p>
    <div class="note">
      <p class="normal">JWTs can be encrypted and include a timestamp for expiration. In theory, this counters the weaknesses of both cookies and <code class="inlineCode">localStorage</code>. If implemented correctly, either option should be secure for use with JWTs, but <code class="inlineCode">localStorage</code> is still preferred.</p>
    </div>
    <p class="normal">Let’s start by implementing a caching service<a id="_idIndexMarker518"/> that can provide a centralized caching method for our application. We can then derive from this service to cache our authentication information:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start by creating an abstract <code class="inlineCode">cacheService</code> that encapsulates the method of caching:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/common/cache.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-meta">@Injectable</span>({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CacheService</span> {
  <span class="hljs-keyword">protected</span> getItem&lt;T&gt;(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): T | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">const</span> data = <span class="hljs-variable">localStorage</span>.<span class="hljs-title">getItem</span>(key)
    <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title">JSON</span>.<span class="hljs-title">parse</span>(data)
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">'Parsing error:'</span>, error)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
      }     
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
  }
  <span class="hljs-keyword">protected</span> <span class="hljs-title">setItem</span>(<span class="hljs-attr">key</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span><span class="hljs-params">, </span><span class="hljs-attr">data</span><span class="hljs-params">: </span><span class="hljs-built_in">object</span><span class="hljs-params"> | </span><span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'string'</span>) {
      <span class="hljs-variable">localStorage</span>.<span class="hljs-title">setItem</span>(key, data)
    }
    <span class="hljs-variable">localStorage</span>.<span class="hljs-title">setItem</span>(key, <span class="hljs-title">JSON</span>.<span class="hljs-title">stringify</span>(data))
  }
  <span class="hljs-keyword">protected</span> <span class="hljs-title">removeItem</span>(<span class="hljs-attr">key</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span>) {
    <span class="hljs-variable">localStorage</span>.<span class="hljs-title">removeItem</span>(key)
  }
  <span class="hljs-keyword">protected</span> <span class="hljs-title">clear</span>() {
    <span class="hljs-variable">localStorage</span>.<span class="hljs-title">clear</span>()
  }
}
</code></pre>
      
    <p class="normal">This cache <a id="_idIndexMarker519"/>service class can give caching capabilities to any service. While it creates a centralized caching method you can inject into another service, it is not meant to be a centralized value store. You should never use it to synchronize state, so we can avoid introducing side effects and coupling between services and components.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Update <code class="inlineCode">AuthService</code> to inject the <code class="inlineCode">CacheService</code>, which will enable us to implement caching of the JWT in the next section:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAuthService</span> { 
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> cache = <span class="hljs-title">inject</span>(<span class="hljs-title">CacheService</span>)
  ... 
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Let’s go over an example of how to use the base class’s functionality by caching the value of the <code class="inlineCode">authStatus</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
authStatus$ = <span class="hljs-keyword">new</span> <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">IAuthStatus</span>&gt;(
  <span class="hljs-variable">this</span>.<span class="hljs-title">getItem</span>(<span class="hljs-string">'authStatus'</span>) ?? defaultAuthStatus
)
<span class="hljs-title">constructor</span>() {
  <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">pipe</span>(
    <span class="hljs-title">tap</span>(<span class="hljs-params">authStatus</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title">setItem</span>(<span class="hljs-string">'authStatus'</span>, authStatus))
  )
}
</code></pre>
    <p class="normal">The technique demonstrated in the example leverages RxJS observable streams to update the cache whenever the value of <code class="inlineCode">authStatus$</code> changes. You can use this pattern to persist any kind of data without cluttering your business logic with caching code. In this case, we wouldn’t need to update the <code class="inlineCode">login</code> function to call <code class="inlineCode">setItem</code> because it already calls <code class="inlineCode">this.authStatus.next</code>, and we can just tap into the data stream. This helps with staying stateless and avoiding side effects, by decoupling functions from each other.</p>
    <div class="note">
      <p class="normal">Note that we also initialize the <code class="inlineCode">BehaviorSubject</code> using the <code class="inlineCode">getItem</code> function. Using the nullish coalescing operator, we only use cached data if it is not <code class="inlineCode">undefined</code> or <code class="inlineCode">null</code>. Otherwise, we provide the default value.</p>
    </div>
    <div class="packt_tip">
      <p class="normal">You can implement your own custom cache expiration scheme in the <code class="inlineCode">setItem</code> and <code class="inlineCode">getItem</code> functions or leverage a service created by a third party.</p>
    </div>
    <p class="normal">However, for an additional layer of security, we won’t cache the <code class="inlineCode">authStatus</code> object. Instead, we will only cache the encoded JWT, which contains just enough information, so we can authenticate requests sent to the server.</p>
    <div class="note">
      <p class="normal">In the Implementing JWT auth section of <em class="chapterRef">Chapter 7</em>, <em class="italic">Working with REST and GraphQL APIs,</em> we discuss how you should encrypt and verify JWT token validity to avoid token-based exploits.</p>
    </div>
    <p class="normal">It is important <a id="_idIndexMarker520"/>to understand how token-based authentication works to avoid revealing compromising secrets. Review the JWT life cycle earlier in this chapter to improve your understanding.</p>
    <p class="normal">Next, let’s cache the token.</p>
    <h2 id="_idParaDest-182" class="heading-2">Caching the JWT</h2>
    <p class="normal">Let’s update the<a id="_idIndexMarker521"/> authentication service so that it can cache the token:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Update <code class="inlineCode">AuthService</code> to be able to set, get, and clear the token, as shown here:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
  <span class="hljs-keyword">protected</span> <span class="hljs-title">setToken</span>(<span class="hljs-attr">jwt</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span>) {
    <span class="hljs-variable">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title">setItem</span>(<span class="hljs-string">'jwt'</span>, jwt)
  }
  <span class="hljs-title">getToken</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title">getItem</span>(<span class="hljs-string">'jwt'</span>) ?? <span class="hljs-string">''</span>
  }
  <span class="hljs-keyword">protected</span> <span class="hljs-title">clearToken</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title">removeItem</span>(<span class="hljs-string">'jwt'</span>)
  }
</code></pre>
      </li>
      <li class="numberedList">Call <code class="inlineCode">clearToken</code> and <code class="inlineCode">setToken</code> during <code class="inlineCode">login</code>, and <code class="inlineCode">clearToken</code> during <code class="inlineCode">logout</code>, as shown here:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
  <span class="hljs-title">login</span>(<span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">clearToken</strong><strong class="hljs-slc">()</strong></span>
    <span class="hljs-keyword">const</span> loginResponse$ = <span class="hljs-variable">this</span>.<span class="hljs-title">authProvider</span>(email, password)
      .<span class="hljs-title">pipe</span>(
        <span class="hljs-title">map</span>(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> {
          <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">setToken</strong><strong class="hljs-slc">(value.</strong><strong class="hljs-property-slc">accessToken</strong><strong class="hljs-slc">)</strong></span>
          <span class="hljs-keyword">const</span> token = <span class="hljs-title">decode</span>(value.<span class="hljs-property">accessToken</span>)
          <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">transformJwtToken</span>(token)
        }),
        <span class="hljs-title">tap</span>(<span class="hljs-function">(</span><span class="hljs-params">status</span><span class="hljs-function">) =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">next</span>(status)),
        ...
  }
  <span class="hljs-title">logout</span>(<span class="hljs-params">clearToken?: </span><span class="hljs-built_in">boolean</span>) {
    <span class="code-highlight"><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (clearToken) {</strong></span>
      <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">clearToken</strong><strong class="hljs-slc">()</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">}</strong></span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">next</span>(defaultAuthStatus), <span class="hljs-number">0</span>)
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">Every subsequent<a id="_idIndexMarker522"/> request will contain the JWT in the request header. You should secure every API to check for and validate the token received. For example, if a user wants to access their profile, the <code class="inlineCode">AuthService</code> will validate the token to check whether the user is authenticated or not; however, a further database call will still be required to check whether the user is also authorized to view the data. This ensures an independent confirmation of the user’s access to the system and prevents any abuse of an unexpired token.</p>
    <p class="normal">If an authenticated user makes a call to an API where they don’t have the proper authorization (say, if a clerk wants to get access to a list of all users), then the <code class="inlineCode">AuthService</code> will return a <code class="inlineCode">falsy</code> status, and the client will receive a <code class="inlineCode">403 Forbidden</code> response, which will be displayed as an error message to the user.</p>
    <p class="normal">A user can make a request with an expired token; when this happens, a <code class="inlineCode">401 Unauthorized</code> response is sent to the client. As a good UX practice, we should automatically prompt <a id="_idIndexMarker523"/>the user to log in again and let them resume their workflow without any data loss.</p>
    <p class="normal">In summary, true security is achieved with robust server-side implementation. Any client-side implementation is largely there to enable a good UX around good security practices.</p>
    <h1 id="_idParaDest-183" class="heading-1">An in-memory auth service</h1>
    <p class="normal">Now, let’s implement a concrete <a id="_idIndexMarker524"/>version of the auth service that we can use:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start by installing a JWT decoding library and, to fake authentication, a JWT encoding library:
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npm install fake-jwt-sign
</code></pre>
      </li>
      <li class="numberedList">Extend the abstract <code class="inlineCode">AuthService</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">in</strong><strong class="hljs-slc">-memory.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">AuthService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>
<span class="hljs-meta">@Injectable</span>({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryAuthService</span> <span class="code-highlight"><strong class="hljs-keyword-slc">extends</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">AuthService</strong></span> {
  <span class="hljs-title">constructor</span>() {
    <span class="hljs-variable">super</span>()
    <span class="code-highlight"><strong class="hljs-variable-slc">console</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">warn</strong><strong class="hljs-slc">(</strong></span>
      <span class="code-highlight"><strong class="hljs-string-slc">'You're using the InMemoryAuthService. Do not use this service in production.'</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">)</strong></span>
  }
  …
}
</code></pre>
      </li>
      <li class="numberedList">Implement a fake <code class="inlineCode">authProvider</code> function that simulates the authentication process, including creating a fake JWT on the fly:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">in</strong><strong class="hljs-slc">-memory.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
  <span class="hljs-keyword">import</span> { sign } <span class="hljs-keyword">from</span> <span class="hljs-string">'fake-jwt-sign'</span><span class="hljs-comment">//For InMemoryAuthService only</span>
...
  <span class="hljs-keyword">protected</span> <span class="hljs-title">authProvider</span>(
    <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">IServerAuthResponse</span>&gt; {
    email = email.<span class="hljs-title">toLowerCase</span>()
    <span class="hljs-keyword">if</span> (!email.<span class="hljs-title">endsWith</span>(<span class="hljs-string">'@test.com'</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-title">throwError</span>(
        <span class="hljs-string">'Failed to login! Email needs to end with @test.com.'</span>
      )
    }
    <span class="hljs-keyword">const</span> authStatus = {
      <span class="hljs-attr">isAuthenticated</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">userId</span>: <span class="hljs-variable">this</span>.<span class="hljs-property">defaultUser</span>.<span class="hljs-property">_id</span>,
      <span class="hljs-attr">userRole</span>: email.<span class="hljs-title">includes</span>(<span class="hljs-string">'cashier'</span>)
        ? <span class="hljs-title">Role</span>.<span class="hljs-property">Cashier</span>
        : email.<span class="hljs-title">includes</span>(<span class="hljs-string">'clerk'</span>)
        ? <span class="hljs-title">Role</span>.<span class="hljs-property">Clerk</span>
        : email.<span class="hljs-title">includes</span>(<span class="hljs-string">'manager'</span>)
        ? <span class="hljs-title">Role</span>.<span class="hljs-property">Manager</span>
        : <span class="hljs-title">Role</span>.<span class="hljs-property">None</span>,
    } <span class="hljs-keyword">as</span> <span class="hljs-title">IAuthStatus</span>
    <span class="hljs-variable">this</span>.<span class="hljs-property">defaultUser</span>.<span class="hljs-property">role</span> = authStatus.<span class="hljs-property">userRole</span>
    <span class="hljs-keyword">const</span> authResponse = {
      <span class="hljs-attr">accessToken</span>: <span class="hljs-title">sign</span>(authStatus, <span class="hljs-string">'secret'</span>, {
        <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">'1h'</span>,
        <span class="hljs-attr">algorithm</span>: <span class="hljs-string">'</span><span class="hljs-string">none'</span>,
      }),
    } <span class="hljs-keyword">as</span> <span class="hljs-title">IServerAuthResponse</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title">of</span>(authResponse)
  }
...
</code></pre>
     
    <p class="normal">The <code class="inlineCode">authProvider</code> implements <a id="_idIndexMarker525"/>what would otherwise be a server-side method right in the service, so we can conveniently experiment with the code while fine-tuning our auth workflow. The provider creates and signs a JWT with the temporary <code class="inlineCode">fake-jwt-sign</code> library so that I can also demonstrate how to handle a properly formed JWT.</p>
    <div class="note">
      <p class="normal">Do not ship your Angular application with the <code class="inlineCode">fake-jwt-sign</code> dependency, since it is meant to be server-side code.</p>
    </div>
    <p class="normal">In contrast, a real auth provider would include a <code class="inlineCode">POST</code> call to a server. See the example code that follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">private</span> <span class="hljs-title">exampleAuthProvider</span>(
  <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>
): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">IServerAuthResponse</span>&gt; { <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">httpClient</span>.<span class="hljs-property">post</span>&lt;<span class="hljs-title">IServerAuthResponse</span>&gt;(
    <span class="hljs-string">`</span><span class="hljs-subst">${environment.baseUrl}</span><span class="hljs-string">/v1/login`</span>, 
    { <span class="hljs-attr">email</span>: email, <span class="hljs-attr">password</span>: password }
  )
}
</code></pre>
    <p class="normal">It is pretty straightforward, since the hard work is done on the server side. This call can also be made to a third-party auth provider, which I cover in the Firebase authentication recipe later in this chapter.</p>
    <div class="packt_tip">
      <p class="normal">Note that the API version, <code class="inlineCode">v1</code>, in the URL path is defined at the service and not as part of the <code class="inlineCode">baseUrl</code>. This is because each API can change versions independently. Login may remain <code class="inlineCode">v1</code> for a long time, while other APIs may be upgraded to <code class="inlineCode">v2</code>, <code class="inlineCode">v3</code>, and so on.</p>
    </div> </li>
    </ol>



    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Implementing <code class="inlineCode">transformJwtToken</code> will be trivial because the login function provides us <a id="_idIndexMarker526"/>with a token that adheres to <code class="inlineCode">IAuthStatus</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">in</strong><strong class="hljs-slc">-memory.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">protected</span> <span class="hljs-title">transformJwtToken</span>(<span class="hljs-attr">token</span>: <span class="hljs-title">IAuthStatus</span>): 
  <span class="hljs-title">IauthStatus</span> {
    <span class="hljs-keyword">return</span> token
  }
</code></pre>
      </li>
      <li class="numberedList">Finally, implement <code class="inlineCode">getCurrentUser</code>, which should return some default user:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">in</strong><strong class="hljs-slc">-memory.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">protected</span> <span class="hljs-title">getCurrentUser</span>(): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">User</span>&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title">of</span>(<span class="hljs-variable">this</span>.<span class="hljs-property">defaultUser</span>)
}
</code></pre>
      
    <p class="normal">Next, provide a <code class="inlineCode">defaultUser</code> as a private property to the class; what follows is one that I’ve created.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Add a private <code class="inlineCode">defaultUser</code> property to the <code class="inlineCode">InMemoryAuthService</code> class:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">in</strong><strong class="hljs-slc">-memory.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">PhoneType</span>, <span class="hljs-title">User</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../user/user/user'</span>
...
<span class="hljs-keyword">private</span> defaultUser = <span class="hljs-title">User</span>.<span class="hljs-title">Build</span>({
  <span class="hljs-attr">_id</span>: <span class="hljs-string">'5da01751da27cc462d265913'</span>,
  <span class="hljs-attr">email</span>: <span class="hljs-string">'duluca@gmail.com'</span>,
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">first</span>: <span class="hljs-string">'Doguhan'</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">'Uluca'</span> },
  <span class="hljs-attr">picture</span>: <span class="hljs-string">'https://secure.gravatar.com/</span>
<span class="hljs-string">    avatar/7cbaa9afb5ca78d97f3c689f8ce6c985'</span>,
  <span class="hljs-attr">role</span>: <span class="hljs-title">Role</span>.<span class="hljs-property">Manager</span>,
  <span class="hljs-attr">dateOfBirth</span>: <span class="hljs-keyword">new</span> <span class="hljs-title">Date</span>(<span class="hljs-number">1980</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),
  <span class="hljs-attr">userStatus</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">address</span>: {
    <span class="hljs-attr">line1</span>: <span class="hljs-string">'101 Sesame St.'</span>,
    <span class="hljs-attr">city</span>: <span class="hljs-string">'Bethesda'</span>,
    <span class="hljs-attr">state</span>: <span class="hljs-string">'Maryland'</span>,
    <span class="hljs-attr">zip</span>: <span class="hljs-string">'20810'</span>,
  },
  <span class="hljs-attr">level</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">phones</span>: [
    {
      <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">type</span>: <span class="hljs-title">PhoneType</span>.<span class="hljs-property">Mobile</span>,
      <span class="hljs-attr">digits</span>: <span class="hljs-string">'5555550717'</span>,
    },
  ],
})
</code></pre>
      </li>
    </ol>
    <p class="normal">Congratulations! You’ve<a id="_idIndexMarker527"/> implemented a concrete, but still fake, auth service. Now that you have the in-memory auth service in place, be sure to run your Angular application and ensure no errors are present.</p>
    <p class="normal">Let’s test our auth service by implementing a simple login and logout functionality accessible through the UI.</p>
    <h2 id="_idParaDest-184" class="heading-2">Simple login</h2>
    <p class="normal">Before we implement a<a id="_idIndexMarker528"/> fully-featured <code class="inlineCode">login</code> component, let’s wire up the pre-baked login behavior to the <strong class="keyWord">Login as manager</strong> button we have in the <code class="inlineCode">HomeComponent</code>. We can test the behavior of our auth service before getting into the details of delivering a rich UI component.</p>
    <p class="normal">Our goal is to simulate logging in as a manager. To accomplish this, we need to hardcode an email address and a password to log in and, upon successful login, maintain the functionality of navigating to the <code class="inlineCode">/manager</code> route.</p>
    <div class="packt_tip">
      <p class="normal">Note that on GitHub, the code sample for this section resides in a file named <code class="inlineCode">home.component.simple.ts</code> under the folder structure of <code class="inlineCode">projects/stage8</code>. The alternate file exists for reference purposes only because the code from this section dramatically changes later in the chapter. Ignore the filename difference, as it will not impact your coding for this section.</p>
    </div>
    <p class="normal">Let’s implement a<a id="_idIndexMarker529"/> simple login mechanism:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In the <code class="inlineCode">HomeComponent</code>, implement a <code class="inlineCode">login</code> function that uses the <code class="inlineCode">AuthService</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/home/home.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">AuthService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../auth/auth.service'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HomeComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span> {
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">authService</span><span class="hljs-params">: </span><span class="hljs-title">AuthService</span>) {}
  <span class="hljs-title">ngOnInit</span>(): <span class="hljs-built_in">void</span> {}
  <span class="hljs-title">login</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">authService</span>.<span class="hljs-title">login</span>(<span class="hljs-string">'manager@test.com'</span>, <span class="hljs-string">'</span><span class="hljs-string">12345678'</span>)
  }
}
</code></pre>
      </li>
      <li class="numberedList">Update the template to remove the <code class="inlineCode">routerLink</code> and, instead, call the <code class="inlineCode">login</code> function:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/home/home.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-attr">template</span>: <span class="hljs-string">`</span>
<span class="hljs-string">    &lt;div fxLayout="column" fxLayoutAlign="center center"&gt;</span>
<span class="hljs-string">      &lt;span class="mat-display-2"&gt;Hello, Limoncu!&lt;/span&gt;</span>
<span class="hljs-string">      &lt;button mat-raised-button color="primary" </span><span class="code-highlight"><strong class="hljs-string-slc">(click)="login()"</strong></span><span class="hljs-string">&gt;</span>
<span class="hljs-string">        Login as Manager</span>
<span class="hljs-string">      &lt;/button&gt;</span>
<span class="hljs-string">    &lt;/div&gt;</span>
<span class="hljs-string">  `</span>,
</code></pre>
      
    <p class="normal">On successful login, we need to navigate to the <code class="inlineCode">/manager</code> route. We can verify that we’re successfully logged in by listening to the <code class="inlineCode">authStatus$</code> and <code class="inlineCode">currentUser$</code> observables exposed by the <code class="inlineCode">AuthService</code>. If <code class="inlineCode">authStatus$.isAuthenticated</code> is <code class="inlineCode">true</code> and <code class="inlineCode">currentUser$._id</code> is a non-empty string, we have a valid login. We can listen to both observables by using RxJS’s <code class="inlineCode">combineLatest</code> operator. Given a valid login condition, we can then use the <code class="inlineCode">filter</code> operator to reactively navigate to the <code class="inlineCode">/manager</code> route.</p></li>
    </ol>



    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Update <a id="_idIndexMarker530"/>the <code class="inlineCode">login()</code> function to implement the login conditional, and upon success, navigate to the <code class="inlineCode">/manager</code> route:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/home/home.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-title">constructor</span>(
<span class="hljs-params">  </span><span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">authService</span><span class="hljs-params">: </span><span class="hljs-title">AuthService</span><span class="hljs-params">,</span>
<span class="hljs-params">  </span><span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-params-slc"> </strong><strong class="hljs-attr-slc">router</strong><strong class="hljs-params-slc">: </strong><strong class="hljs-title-slc">Router</strong></span>
) {}
  
<span class="hljs-title">login</span>() {
  <span class="hljs-variable">this</span>.<span class="hljs-property">authService</span>.<span class="hljs-title">login</span>(<span class="hljs-string">'manager@test.com'</span>, <span class="hljs-string">'12345678'</span>)
<span class="code-highlight"><strong class="hljs-title-slc">combineLatest</strong><strong class="hljs-slc">([</strong></span>
  <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">authService</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">authStatus$</strong><strong class="hljs-slc">, </strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">authService</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">currentUser$</strong></span>
<span class="code-highlight"><strong class="hljs-slc">]) </strong></span>
  <span class="code-highlight"><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">pipe</strong><strong class="hljs-slc">(</strong></span>
    <span class="code-highlight"><strong class="hljs-title-slc">filter</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-params-slc">[authStatus, user]</strong><strong class="hljs-function-slc">) =&gt;</strong><strong class="hljs-slc"> </strong></span>
      <span class="code-highlight"><strong class="hljs-slc">authStatus.</strong><strong class="hljs-property-slc">isAuthenticated</strong><strong class="hljs-slc"> &amp;&amp; user?.</strong><strong class="hljs-property-slc">_id</strong><strong class="hljs-slc"> !== </strong><strong class="hljs-string-slc">''</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">),</strong></span>
    <span class="code-highlight"><strong class="hljs-title-slc">tap</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-params-slc">[authStatus, user]</strong><strong class="hljs-function-slc">) =&gt;</strong><strong class="hljs-slc"> {</strong></span>
      <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">router</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">navigate</strong><strong class="hljs-slc">([</strong><strong class="hljs-string-slc">'/manager'</strong><strong class="hljs-slc">])</strong></span>
    <span class="code-highlight"><strong class="hljs-slc">})</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">)</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">subscribe</strong><strong class="hljs-slc">()</strong></span>
}
</code></pre>
        <div class="note">
          <p class="normal">Note that we subscribe to the <code class="inlineCode">combineLatest</code> operator at the end, which is critical in activating the observable streams. Otherwise, our login action will remain dormant unless some other component subscribes to the stream. You only need to activate a stream once.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Now, test out the new <code class="inlineCode">login</code> functionality. Verify that the JWT is created and stored in <code class="inlineCode">localStorage</code> using the <strong class="screenText">Chrome DevTools | Application</strong> tab, as shown here:
    <figure class="mediaobject"><img src="../Images/B20960_05_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.4: DevTools showing Application | Local Storage</p></li>
    </ol>
    <p class="normal">You can<a id="_idIndexMarker531"/> view <strong class="screenText">Local Storage</strong> under the <strong class="screenText">Application</strong> tab. Make sure that the URL of your application is highlighted. In <em class="italic">step 3</em>, you can see that we have a key named <code class="inlineCode">jwt</code> with a valid-looking token.</p>
    <div class="note">
      <p class="normal">Note <em class="italic">steps 4</em> and <em class="italic">5</em>, highlighting two warnings, which, respectively, advise us not to use the <code class="inlineCode">InMemoryAuthService</code> and the <code class="inlineCode">fake-jwt-sign</code> package in production code.</p>
    </div>
    <div class="packt_tip">
      <p class="normal">Use breakpoints to debug and step through the code to get a more concrete understanding of how <code class="inlineCode">HomeComponent</code>, <code class="inlineCode">InMemoryAuthService</code>, and <code class="inlineCode">AuthService</code> work together to log the user in.</p>
    </div>
    <p class="normal">When you refresh the page, note that you’re still logged in because we’re caching the token in local storage.</p>
    <p class="normal">Since we’re caching the login status, we must also implement a logout experience to complete the auth workflow.</p>
    <h1 id="_idParaDest-185" class="heading-1">Logout</h1>
    <p class="normal">The logout button<a id="_idIndexMarker532"/> on the application toolbar is already wired up to navigate to the <code class="inlineCode">logout</code> component we created before. Let’s update this component so that it can log the user out when navigated to:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Implement the <code class="inlineCode">logout</code> component:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/user/logout/logout.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Component</span>, <span class="hljs-title">OnInit</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span> 
<span class="hljs-keyword">import</span> { <span class="hljs-title">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">AuthService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../auth/auth.service'</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-logout'</span>, 
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;p&gt;Logging out...&lt;/p&gt;`</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LogoutComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span> { 
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">router</span><span class="hljs-params">: </span><span class="hljs-title">Router</span><span class="hljs-params">, </span><span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">authService</span><span class="hljs-params">: </span><span class="hljs-title">AuthService</span>) {}
  <span class="hljs-title">ngOnInit</span>() { 
    <span class="hljs-variable">this</span>.<span class="hljs-property">authService</span>.<span class="hljs-title">logout</span>(<span class="hljs-literal">true</span>)
    <span class="hljs-variable">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title">navigate</span>([<span class="hljs-string">'/'</span>])
  }
}
</code></pre>
     
    <div class="note">
      <p class="normal">Note that we explicitly clear the JWT by passing in <code class="inlineCode">true</code> to the <code class="inlineCode">logout</code> function. After we call <code class="inlineCode">logout</code>, we navigate the user back to the home page.</p>
    </div> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Test out the <code class="inlineCode">logout</code> button.</li>
      <li class="numberedList">Verify that local storage is cleared after logout.</li>
    </ol>
    <p class="normal">We have nailed a solid login and logout implementation. However, we’re not yet done with the fundamentals of our auth workflow.</p>
    <p class="normal">Next, we need to consider the expiration status of our JWT.</p>
    <h2 id="_idParaDest-186" class="heading-2">Resuming a JWT session</h2>
    <p class="normal">It wouldn’t be a <a id="_idIndexMarker533"/>great UX if you had to log in to Gmail or Amazon every time you visited the site. This is why we cache the JWT, but it would be an equally bad UX to keep you logged in forever. A JWT has an expiration date policy, where the provider can select a few minutes or even months to allow your token to be valid, depending on security needs. The in-memory service creates tokens that expire in one hour, so if a user refreshes their browser window within that frame, we should honor the valid token and let the user continue using the application, without asking them to log back in.</p>
    <p class="normal">On the flip side, if<a id="_idIndexMarker534"/> the token is expired, we should automatically navigate the user to the login screen for a smooth UX.</p>
    <p class="normal">Let’s get started:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Update the <code class="inlineCode">AuthService</code> class to implement a function named <code class="inlineCode">hasExpiredToken</code> to check whether the token is expired, and a helper function named <code class="inlineCode">getAuthStatusFromToken</code> to decode the token, as shown here:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
  <span class="hljs-keyword">protected</span> <span class="hljs-title">hasExpiredToken</span>(): <span class="hljs-built_in">boolean</span> {
    <span class="hljs-keyword">const</span> jwt = <span class="hljs-variable">this</span>.<span class="hljs-title">getToken</span>()
    <span class="hljs-keyword">if</span> (jwt) {
      <span class="hljs-keyword">const</span> payload = <span class="hljs-title">decode</span>(jwt) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title">Date</span>.<span class="hljs-title">now</span>() &gt;= payload.<span class="hljs-property">exp</span> * <span class="hljs-number">1000</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
  <span class="hljs-keyword">protected</span> <span class="hljs-title">getAuthStatusFromToken</span>(): <span class="hljs-title">IAuthStatus</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">transformJwtToken</span>(<span class="hljs-title">decode</span>(<span class="hljs-variable">this</span>.<span class="hljs-title">getToken</span>()))
  }
</code></pre>
        <div class="packt_tip">
          <p class="normal">Keep your code DRY! Update the <code class="inlineCode">login()</code> function to use <code class="inlineCode">getAuthStatusFromToken()</code> instead.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Update the constructor of <code class="inlineCode">AuthService</code> to check the status of the token:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-title">constructor</span>() {
  <span class="hljs-variable">super</span>()
  <span class="hljs-keyword">if</span> (<span class="hljs-variable">this</span>.<span class="hljs-title">hasExpiredToken</span>()) {
    <span class="hljs-variable">this</span>.<span class="hljs-title">logout</span>(<span class="hljs-literal">true</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">next</span>(<span class="hljs-variable">this</span>.<span class="hljs-title">getAuthStatusFromToken</span>())
  }
}
</code></pre>
      
    <p class="normal">If the token is expired, we log the user out and clear the token from <code class="inlineCode">localStorage</code>. Otherwise, we decode the token and push the auth status to the data stream.</p>
    <p class="normal">A corner case to consider here is to also trigger the reloading of the current user in the event of a resumption. We can do this by implementing a new pipe that reloads the current user if activated.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">First, let’s<a id="_idIndexMarker535"/> refactor the existing user update logic in the <code class="inlineCode">login()</code> function to a private property named <code class="inlineCode">getAndUpdateUserIfAuthenticated</code> so that we can reuse it:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAuthService</span> {
  <span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-slc"> getAndUpdateUserIfAuthenticated = </strong><strong class="hljs-title-slc">pipe</strong><strong class="hljs-slc">(</strong></span>
    <span class="code-highlight"><strong class="hljs-title-slc">filter</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-attr-slc">status</strong><strong class="hljs-params-slc">: </strong><strong class="hljs-title-slc">IAuthStatus</strong><strong class="hljs-function-slc">) =&gt;</strong><strong class="hljs-slc"> status.</strong><strong class="hljs-property-slc">isAuthenticated</strong><strong class="hljs-slc">),</strong></span>
    <span class="code-highlight"><strong class="hljs-title-slc">flatMap</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">() =&gt;</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">getCurrentUser</strong><strong class="hljs-slc">()),</strong></span>
    <span class="code-highlight"><strong class="hljs-title-slc">map</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-attr-slc">user</strong><strong class="hljs-params-slc">: </strong><strong class="hljs-title-slc">IUser</strong><strong class="hljs-function-slc">) =&gt;</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">currentUser$</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">next</strong><strong class="hljs-slc">(user)),</strong></span>
    <span class="code-highlight"><strong class="hljs-title-slc">catchError</strong><strong class="hljs-slc">(transformError)</strong></span>
  <span class="code-highlight"><strong class="hljs-slc">)</strong></span>
  ...
  <span class="hljs-title">login</span>(<span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-variable">this</span>.<span class="hljs-title">clearToken</span>()
    <span class="hljs-keyword">const</span> loginResponse$ = <span class="hljs-variable">this</span>.<span class="hljs-title">authProvider</span>(email, password)
      .<span class="hljs-title">pipe</span>(
        <span class="hljs-title">map</span>(<span class="hljs-function">(</span><span class="hljs-params">value</span><span class="hljs-function">) =&gt;</span> {
          <span class="hljs-variable">this</span>.<span class="hljs-title">setToken</span>(value.<span class="hljs-property">accessToken</span>)
          <span class="hljs-keyword">const</span> token = <span class="hljs-title">decode</span>(value.<span class="hljs-property">accessToken</span>)
          <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">transformJwtToken</span>(token)
        }),
        <span class="hljs-title">tap</span>(<span class="hljs-function">(</span><span class="hljs-params">status</span><span class="hljs-function">) =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">next</span>(status)),
        <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">getAndUpdateUserIfAuthenticated</strong></span>
      )
    ...
  }
  ...
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">AuthService</code>, define an observable property named <code class="inlineCode">resumeCurrentUser$</code> as a fork of <code class="inlineCode">authStatus$</code>, and use the <code class="inlineCode">getAndUpdateUserIfAuthenticated</code> logic:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">readonly</span> resumeCurrentUser$ = <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">pipe</span>(
    <span class="hljs-variable">this</span>.<span class="hljs-property">getAndUpdateUserIfAuthenticated</span> 
  )
</code></pre>
      
    <p class="normal">Once <code class="inlineCode">resumeCurrentUser$</code> is activated and <code class="inlineCode">status.isAuthenticated</code> is <code class="inlineCode">true</code>, then <code class="inlineCode">this.getCurrentUser()</code> will be invoked and <code class="inlineCode">currentUser$</code> will be updated.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Update the<a id="_idIndexMarker536"/> constructor of <code class="inlineCode">AuthService</code> to activate the pipeline if the token has not expired:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-title">constructor</span>() {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable">this</span>.<span class="hljs-title">hasExpiredToken</span>()) {
    <span class="hljs-variable">this</span>.<span class="hljs-title">logout</span>(<span class="hljs-literal">true</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable">this</span>.<span class="hljs-property">authStatus$</span>.<span class="hljs-title">next</span>(<span class="hljs-variable">this</span>.<span class="hljs-title">getAuthStatusFromToken</span>())
    <span class="hljs-comment">// To load user on browser refresh,</span>
    <span class="hljs-comment">// resume pipeline must activate on the next cycle</span>
    <span class="hljs-comment">// Which allows for all services to constructed properly</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">resumeCurrentUser$</span>.<span class="hljs-title">subscribe</span>(), <span class="hljs-number">0</span>)
  }
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Using the preceding technique, we can retrieve the latest user profile data without dealing with caching issues.</p>
    <div class="packt_tip">
      <p class="normal">To experiment with token expiration, I recommend creating a faster-expiring token in <code class="inlineCode">InMemoryAuthService</code>.</p>
    </div>
    <div class="note">
      <p class="normal">As demonstrated earlier in the caching section, it is possible to cache the user profile data using <code class="inlineCode">this.cache.setItem</code> and the profile data from the cache on the first launch. This would provide a faster UX and cover cases where users may be offline. After the application launches, you could asynchronously fetch fresh user data and update <code class="inlineCode">currentUser$</code> when new data comes in. You would need to add additional caching and tweak the <code class="inlineCode">getCurrentUser()</code> logic to get such functionality working. Oh, and you would need a whole lot of testing! It takes a lot of testing to create a high-quality auth experience.</p>
    </div>
    <p class="normal">Congratulations! We’re done implementing a robust auth workflow! Next, we need to integrate auth with Angular’s HTTP client to attach the token to the HTTP header of every request.</p>
    <h1 id="_idParaDest-187" class="heading-1">An HTTP interceptor</h1>
    <p class="normal">Implement an <a id="_idIndexMarker537"/>HTTP interceptor to inject the JWT into the header of every request sent to the API, and gracefully handle authentication failures by asking the user to log back in:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an <code class="inlineCode">AuthHttpInterceptor</code> under <code class="inlineCode">auth</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/auth/auth.</strong><strong class="hljs-property-slc">http</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">interceptor</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">HttpHandlerFn</span>, <span class="hljs-title">HttpRequest</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">inject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">throwError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">catchError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">environment</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/environments/environment'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">UiService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../common/ui.service'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">AuthService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./auth.service'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">AuthHttpInterceptor</span>(
  <span class="hljs-attr">req</span><span class="hljs-params">: </span><span class="hljs-title">HttpRequest</span><span class="hljs-params">&lt;</span><span class="hljs-built_in">unknown</span><span class="hljs-params">&gt;, </span><span class="hljs-attr">next</span><span class="hljs-params">: </span><span class="hljs-title">HttpHandlerFn</span>
) {
  <span class="hljs-keyword">const</span> authService = <span class="hljs-title">inject</span>(<span class="hljs-title">AuthService</span>)
  <span class="hljs-keyword">const</span> router = <span class="hljs-title">inject</span>(<span class="hljs-title">Router</span>)
  <span class="hljs-keyword">const</span> uiService = <span class="hljs-title">inject</span>(<span class="hljs-title">UiService</span>)
  <span class="hljs-keyword">const</span> jwt = authService.<span class="hljs-title">getToken</span>()
  <span class="hljs-keyword">const</span> baseUrl = environment.<span class="hljs-property">baseUrl</span>
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">url</span>.<span class="hljs-title">startsWith</span>(baseUrl)) {
    <span class="hljs-keyword">const</span> authRequest = req.<span class="hljs-title">clone</span>({
      <span class="hljs-attr">setHeaders</span>: {
        <span class="hljs-attr">authorization</span>: <span class="hljs-string">`Bearer </span><span class="hljs-subst">${jwt}</span><span class="hljs-string">`</span>
      }
    })
    <span class="hljs-keyword">return</span> <span class="hljs-title">next</span>(authRequest).<span class="hljs-title">pipe</span>(
      <span class="hljs-title">catchError</span>(<span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> {
        uiService.<span class="hljs-title">showToast</span>(err.<span class="hljs-property">error</span>.<span class="hljs-property">message</span>)
        <span class="hljs-keyword">if</span> (err.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) {
          router.<span class="hljs-title">navigate</span>([<span class="hljs-string">'/login'</span>], {
            <span class="hljs-attr">queryParams</span>: {
              <span class="hljs-attr">redirectUrl</span>: router.<span class="hljs-property">routerState</span>.<span class="hljs-property">snapshot</span>.<span class="hljs-property">url</span>
            },
          })
        }
        <span class="hljs-keyword">return</span> <span class="hljs-title">throwError</span>(<span class="hljs-function">() =&gt;</span> err)
      })
    )
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title">next</span>(req)
  }
} 
</code></pre>
      
    <div class="note">
      <p class="normal">Note that <code class="inlineCode">AuthService</code> is leveraged to retrieve the token, and the <code class="inlineCode">redirectUrl</code> is set for the <code class="inlineCode">login</code> component after a <code class="inlineCode">401</code> error.</p>
      <p class="normal">Note the if statement <code class="inlineCode">if (req.url.startsWith(baseUrl))</code> filters out any outgoing requests not made to our API. This way, we don’t leak our JWT token to external services.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Update <code class="inlineCode">app.config.ts</code> to provide the<a id="_idIndexMarker538"/> interceptor:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">config</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">appConfig</span>: <span class="hljs-title">ApplicationConfig</span> = {
  <span class="hljs-attr">providers</span>: [
    <span class="hljs-title">provideAnimations</span>(),
    <span class="hljs-title">provideHttpClient</span>(
      <span class="code-highlight"><strong class="hljs-title-slc">withInterceptors</strong><strong class="hljs-slc">([</strong><strong class="hljs-title-slc">AuthHttpInterceptor</strong><strong class="hljs-slc">])</strong></span>
    ),
    ...
</code></pre>
      </li>
      <li class="numberedList">Ensure that the interceptor adds the token to requests. To do this, open the <strong class="screenText">Chrome DevTools | Network</strong> tab, log in, and then refresh the page:
    <figure class="mediaobject"><img src="../Images/B20960_05_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 5.5: The request header for lemon.svg</p></li>
    </ol>
    <p class="normal">In <em class="italic">step 4</em>, you can<a id="_idIndexMarker539"/> now observe the interceptor in action. The request for the <code class="inlineCode">lemon.svg</code> file has the bearer token in the request header.</p>
    <p class="normal">Now that we have our auth mechanism implemented, let’s take advantage of all the supporting code we have written with dynamic UI components and a conditional navigation system, creating a role-based UX in the next chapter.</p>
    <h1 id="_idParaDest-188" class="heading-1">Summary</h1>
    <p class="normal">You should now have a solid understanding of how JWT works, how to use TypeScript for safe data handling, and how to build extendable services. In this chapter, we defined a <code class="inlineCode">User</code> object that we can hydrate from or serialize to JSON objects, applying object-oriented class design and TypeScript operators for safe data handling.</p>
    <p class="normal">We leveraged OOP design principles, using inheritance and abstract classes to implement a base auth service that demonstrates the Open/Closed principle.</p>
    <p class="normal">We covered the fundamentals of token-based authentication and JWTs so that you don’t leak any critical user information. You learned that caching and HTTP interceptors are necessary so that users don’t have to input their login information with every request. Following that, we implemented an in-memory auth service that doesn’t require any external dependencies, which is great for testing.</p>
    <p class="normal">Coming up, in <em class="chapterRef">Chapter 6</em>, <em class="italic">Implementing Role Based Navigation</em>, we will build a dynamic UI with navigation and component states reacting to the auth status of the app, using router and auth guards, flex layout media queries, Material components, and a service factory. We will also implement a Firebase auth provider so that you can host your apps on Google Firebase. In <em class="chapterRef">Chapter 7</em>, <em class="italic">Working with REST and GraphQL APIs</em>, we will bring it all together with two custom auth providers that can authenticate against LemonMart Server, using the Minimal MEAN stack.</p>
    <h1 id="_idParaDest-189" class="heading-1">Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">Salted Password Hashing - Doing it Right, Defuse Security</em>, 2019; <a href="https://crackstation.net/hashing-security.htm"><span class="url">https://crackstation.net/hashing-security.htm</span></a>.</li>
      <li class="bulletList"><em class="italic">Object-oriented programming</em>; <a href="https://en.wikipedia.org/wiki/Object-oriented_programming"><span class="url">https://en.wikipedia.org/wiki/Object-oriented_programming</span></a>.</li>
      <li class="bulletList"><em class="italic">TypeScript Classes</em>; <a href="https://www.typescriptlang.org/docs/handbook/classes.html"><span class="url">https://www.typescriptlang.org/docs/handbook/classes.html</span></a>.</li>
      <li class="bulletList"><em class="italic">TypeScript Basic Types</em>; <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html"><span class="url">https://www.typescriptlang.org/docs/handbook/basic-types.html</span></a>.</li>
      <li class="bulletList"><em class="italic">TypeScript Advanced Types</em>; <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html"><span class="url">https://www.typescriptlang.org/docs/handbook/advanced-types.html</span></a>.</li>
      <li class="bulletList"><em class="italic">TypeScript 3.7 Features</em>; <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html"><span class="url">https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html</span></a>.</li>
      <li class="bulletList"><em class="italic">Authentication General Guidelines</em>; <a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md"><span class="url">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Authentication_Cheat_Sheet.md</span></a>.</li>
      <li class="bulletList"><em class="italic">How to secure your Firebase project even when your API key is publicly available</em>; paachu, 2019, <a href="https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843"><span class="url">https://medium.com/@impaachu/how-to-secure-your-firebase-project-even-when-your-api-key-is-publicly-available-a462a2a58843</span></a>.</li>
    </ul>
    <h1 id="_idParaDest-190" class="heading-1">Questions</h1>
    <p class="normal">Answer the following questions as best as possible to ensure you’ve understood the key concepts from this chapter without googling anything. Do you know if you got all the answers right? Visit <a href="https://angularforenterprise.com/self-assessment"><span class="url">https://angularforenterprise.com/self-assessment</span></a> for more:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What’s in-transit and at-rest security?</li>
      <li class="numberedList">What’s the difference between authentication and authorization?</li>
      <li class="numberedList">Explain inheritance and polymorphism.</li>
      <li class="numberedList">What is an abstract class?</li>
      <li class="numberedList">What is an abstract method?</li>
      <li class="numberedList">Explain how the <code class="inlineCode">AuthService</code> adheres to the Open/Closed principle.</li>
      <li class="numberedList">How does JWT verify your identity?</li>
      <li class="numberedList">What is the difference between RxJS’s <code class="inlineCode">combineLatest</code> and <code class="inlineCode">merge</code> operators?</li>
      <li class="numberedList">What is a route guard?</li>
      <li class="numberedList">What does a service factory allow you to do?</li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers:</p>
    <p class="normal"><a href="Chapter_5.xhtml"><span class="url">https://packt.link/AngularEnterpise3e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1116411172100421421.png" alt="" role="presentation"/></p>
  </div>
</body></html>