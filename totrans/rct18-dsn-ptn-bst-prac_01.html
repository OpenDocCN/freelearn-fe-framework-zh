<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer013">
<h1 class="chapterNumber">1</h1>
<h1 class="chapterTitle" id="_idParaDest-14">Taking Your First Steps with React </h1>
<p class="normal">Hello, readers!</p>
<p class="normal">This book assumes that you already know what React<a id="_idIndexMarker000"/> is and what problems it can solve for you. You may have written a small/medium application with React, and you want to improve your skills and answer all your questions. You should know that React is maintained by the developers at Meta and hundreds of contributors within the JavaScript community. React is one of the most popular libraries for creating UIs, and it is well known to be fast, thanks to its smart way of working with<a id="_idIndexMarker001"/> the <strong class="keyWord">Document Object Model</strong> (<strong class="keyWord">DOM</strong>). It comes with JSX, a new<a id="_idIndexMarker002"/> syntax for writing markup in JavaScript, which requires you to change your thinking regarding the separation of concerns. It has many cool features, such as server-side rendering, which gives you the power to write universal applications.</p>
<p class="normal">In this chapter, we will go through some basic concepts that are essential to master in order to use React effectively, but are straightforward enough for beginners to figure out:</p>
<ul>
<li class="bulletList">The difference between imperative and declarative programming</li>
<li class="bulletList">React components and their instances, and how React uses elements to control the UI flow</li>
<li class="bulletList">How React changed the way we build web applications, enforcing a different new concept of separation of concerns, and the reasons behind its unpopular design choice</li>
<li class="bulletList">Why people feel JavaScript fatigue, and what you can do to avoid the most common errors developers make when approaching the React ecosystem</li>
</ul>
<h1 class="heading-1" id="_idParaDest-15">Technical requirements</h1>
<p class="normal">To follow this book, you need to have some experience in using the terminal to run a few Unix commands. Also, you need to install <strong class="keyWord">Node.js</strong>. You have two options: the first one is to download Node.js directly from the official website (<a href="https://nodejs.org"><span class="url">https://nodejs.org</span></a>), and the second option (recommended) is to install <strong class="keyWord">Node Version Manager</strong> (<strong class="keyWord">NVM</strong>) from <a href="https://github.com/nvm-sh/nvm"><span class="url">https://github.com/nvm-sh/nvm</span></a>.</p>
<p class="normal">If you decide to go with NVM, you can install any version of Node.js you want and switch the versions with the <code class="inlineCode">nvm install</code> command:</p>
<ul>
<li class="bulletList"><code class="inlineCode">node</code> is an alias for the latest version:
        <pre class="programlisting con"><code class="hljs-con">nvm install node
</code></pre>
</li>
<li class="bulletList">You can also install a global version of Node.js (<code class="inlineCode">nvm</code> will install the latest version of Node.js locally to a user’s computer):
        <pre class="programlisting con"><code class="hljs-con">nvm install 19
nvm install 18
nvm install 17
nvm install 16
nvm install 15
</code></pre>
</li>
<li class="bulletList">Or you can install a very specific version:
        <pre class="programlisting con"><code class="hljs-con">nvm install 12.14.3
</code></pre>
</li>
<li class="bulletList">After you have installed the different versions, you can switch between them by using the <code class="inlineCode">nvm use</code> command:
        <pre class="programlisting con"><code class="hljs-con">nvm use node # for latest version
nvm use 16 # for the latest version of node 16.X.X
nvm use 12.14.3 # Specific version
</code></pre>
</li>
<li class="bulletList">Finally, you can specify a default Node.js version by running the following command:
        <pre class="programlisting con"><code class="hljs-con">nvm alias default node
nvm alias default 16
nvm alias default 12.14.3
</code></pre>
</li>
</ul>
<p class="normal">In short, here is a list of the requirements to complete the chapter:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Node.js (19+)</strong>: <a href="https://nodejs.org"><span class="url">https://nodejs.org</span></a> </li>
<li class="bulletList"><strong class="keyWord">NVM</strong>: <a href="https://github.com/nvm-sh/nvm"><span class="url">https://github.com/nvm-sh/nvm</span></a></li>
<li class="bulletList"><strong class="keyWord">VS Code</strong>: <a href="https://code.visualstudio.com"><span class="url">https://code.visualstudio.com</span></a></li>
<li class="bulletList"><strong class="keyWord">TypeScript</strong>: <a href="https://www.npmjs.com/package/typescript"><span class="url">https://www.npmjs.com/package/typescript</span></a></li>
</ul>
<p class="normal">You can find the code in the book’s GitHub repository: <a href="https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition"><span class="url">https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition</span></a>. </p>
<h1 class="heading-1" id="_idParaDest-16">Differentiating between declarative and imperative programming</h1>
<p class="normal">When reading the React documentation or blog posts about React, you will have undoubtedly come across the term <strong class="keyWord">declarative</strong>. One of the reasons why React is so powerful is that it enforces a declarative programming<a id="_idIndexMarker003"/> paradigm.</p>
<p class="normal">Therefore, to master React, it is essential to understand what declarative programming means and what the main differences between imperative and declarative programming are. The easiest way to approach this is to think about imperative programming as a way of describing how things work, and declarative programming as a way of describing what you want to achieve.</p>
<p class="normal">Entering a bar for a beer is a real-life example in the imperative world, where normally you will give the following instructions to the bartender: </p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Find a glass and collect it from the shelf.</li>
<li class="numberedList">Place the glass under the tap.</li>
<li class="numberedList">Pull down the handle until the glass is full.</li>
<li class="numberedList">Hand me the glass.</li>
</ol>
<p class="normal">In the declarative world, you would just say, “Can I have a beer, please?”</p>
<p class="normal">The declarative approach assumes that the bartender already knows how to serve a beer, an important aspect of the way declarative programming works.</p>
<p class="normal">Let’s move into a JavaScript example. Here we will write a simple function that, given an array of lowercase strings, returns an array with the same strings in uppercase:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">toUpperCase</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>]) <span class="hljs-comment">// ['FOO', 'BAR']</span>
</code></pre>
<p class="normal">An<a id="_idIndexMarker004"/> imperative function to solve the problem would be implemented as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">toUpperCase</span> = input =&gt; { 
  <span class="hljs-keyword">const</span> output = []
   
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-property">length</span>; i++) { 
    output.<span class="hljs-title">push</span>(input[i].<span class="hljs-title">toUpperCase</span>())
  } 
    
  <span class="hljs-keyword">return</span> output
}
</code></pre>
<p class="normal">First, an empty array to contain the result is created. Then, the function loops through all the elements of the input array and pushes the uppercase values into the empty array. Finally, the output array is returned.</p>
<p class="normal">A declarative solution would be as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">toUpperCase</span> = input =&gt; input.<span class="hljs-title">map</span>(<span class="hljs-params">value</span><span class="hljs-function"> =&gt;</span> value.<span class="hljs-title">toUpperCase</span>())
</code></pre>
<p class="normal">The items of the input array are passed to a <code class="inlineCode">map</code> function that returns a new array containing the uppercase values. There are some significant differences to note: the former example is less elegant, and it requires more effort to be understood. The latter is terser and easier to read, which makes a huge difference in big code bases, where maintainability is crucial.</p>
<p class="normal">Another aspect worth mentioning is that in the declarative example, there is no need to use variables or to keep their values updated during the execution. Declarative programming tends to avoid creating and mutating a state.</p>
<p class="normal">As a final <a id="_idIndexMarker005"/>example, let’s <a id="_idIndexMarker006"/>see what it means for React to be declarative. The problem we will try to solve is a common task in web development: creating a toggle button.</p>
<p class="normal">Imagine a simple UI component such as a toggle button. When you click it, it turns green (on) if it was previously gray (off), and switches to gray (off) if it was previously green (on).</p>
<p class="normal">The imperative way of doing this would be as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> toggleButton = <span class="hljs-variable">document</span>.<span class="hljs-title">querySelector</span>(<span class="hljs-string">'#toggle'</span>)
toogleButton.<span class="hljs-title">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">if</span> (toggleButton.<span class="hljs-property">classList</span>.<span class="hljs-title">contains</span>(<span class="hljs-string">'on'</span>)) {
    toggleButton.<span class="hljs-property">classList</span>.<span class="hljs-title">remove</span>(<span class="hljs-string">'on'</span>)
    toggleButton.<span class="hljs-property">classList</span>.<span class="hljs-title">add</span>(<span class="hljs-string">'</span><span class="hljs-string">off'</span>)
  } <span class="hljs-keyword">else</span> {
    toggleButton.<span class="hljs-property">classList</span>.<span class="hljs-title">remove</span>(<span class="hljs-string">'off'</span>)
    toggleButton.<span class="hljs-property">classList</span>.<span class="hljs-title">add</span>(<span class="hljs-string">'on'</span>)
  }
})
</code></pre>
<p class="normal">It is imperative because of all the instructions needed to change the classes. In contrast, the declarative approach using React would be as follows:</p>
<pre class="programlisting code"><code class="hljs-code">// To turn on the Toggle
<span class="hljs-tag">&lt;</span><span class="hljs-name">Toggle</span><span class="hljs-tag"> </span><span class="hljs-attr">on</span><span class="hljs-tag"> /&gt;</span>
// To turn off the toggle
<span class="hljs-tag">&lt;</span><span class="hljs-name">Toggle</span><span class="hljs-tag"> /&gt;</span>
</code></pre>
<p class="normal">In <a id="_idIndexMarker007"/>declarative programming, developers <a id="_idIndexMarker008"/>only describe what they want to achieve, and there’s no need to list all the steps to make it work. The fact that React offers a declarative approach makes it easy to use, and consequently, the resulting code is simple, which often leads to fewer bugs and more maintainability.</p>
<p class="normal">In the next section, you will learn how React elements work and you will get more context on how props are being passed on a React component.</p>
<h1 class="heading-1" id="_idParaDest-17">How React elements work</h1>
<p class="normal">In this book, we assume that you are familiar with components and their instances, but there is another object you should know about if you want to use React effectively – the element. Elements <a id="_idIndexMarker009"/>are lightweight immutable descriptions of what should be rendered, while components are more complex stateful objects responsible for generating elements.</p>
<p class="normal">Whenever you <code class="inlineCode">call</code> <strong class="keyWord">createClass</strong>, <strong class="keyWord">extend Component</strong>, or <strong class="keyWord">declare a stateless function</strong>, you are creating a component. React manages all the instances of your components at runtime, and there can be more than one instance of the same component in memory at a given point in time.</p>
<p class="normal">As mentioned previously, React <a id="_idIndexMarker010"/>follows a declarative paradigm, and there’s no need to tell it how to interact with the DOM; you declare what you want to see on the screen, and React does the job for you. One of the tools that makes this process more expressive and readable is JSX, which allows you to write HTML-like syntax directly in your JavaScript code. JSX is not mandatory, but it’s widely used in the React community.</p>
<p class="normal">To control the UI flow, React uses a particular type of object called an element. These elements are created using the <code class="inlineCode">React.createElement()</code> function, or more commonly, with JSX syntax. Elements contain only the information that is strictly needed to represent the interface.</p>
<p class="normal">Here is an example of an<a id="_idIndexMarker011"/> element created with JSX:</p>
<pre class="programlisting code"><code class="hljs-code">  <span class="hljs-tag">&lt;</span><span class="hljs-name">Title</span><span class="hljs-tag"> </span><span class="hljs-attr">color</span><span class="hljs-tag">=</span><span class="hljs-string">"red"</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Hello, H1!<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">Title</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">This JSX code is converted into JavaScript objects like the following:</p>
<pre class="programlisting code"><code class="hljs-code">  {
    <span class="hljs-attr">type</span>: <span class="hljs-title">Title</span>,
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
      <span class="hljs-attr">children</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'h1'</span>,
        <span class="hljs-attr">props</span>: {
          <span class="hljs-attr">children</span>: <span class="hljs-string">'Hello, H1!'</span>
        }
      }
    }
  }
</code></pre>
<p class="normal">The element’s type is crucial because it informs React on how to handle it. If the type is a string, the element represents a DOM node, while if it’s a function, the element represents a component.</p>
<p class="normal">You can nest DOM elements and components to create a render tree, representing the structure of your application’s user interface. By organizing your elements and components in a hierarchical manner, you can create complex and dynamic UIs.</p>
<p class="normal">React uses a technique called the<a id="_idIndexMarker012"/> Virtual DOM, which is an in-memory representation of the actual DOM. It compares the current and new trees to minimize the number of actual DOM updates. This process is called reconciliation<a id="_idIndexMarker013"/> and is used by both React DOM<a id="_idIndexMarker014"/> and React Native<a id="_idIndexMarker015"/> to create UIs for their respective platforms.</p>
<p class="normal">When an element’s type is a function, React invokes that function, passing in the element’s props to obtain the underlying elements. It recursively repeats this process on the result until it constructs a tree of DOM nodes that can be rendered on the screen.</p>
<p class="normal">In summary, elements <a id="_idIndexMarker016"/>play a crucial role in React’s declarative paradigm, allowing you to create complex user interfaces without manually managing the<a id="_idIndexMarker017"/> creation and destruction of DOM elements. </p>
<p class="normal">By understanding how elements and components work together, and how React efficiently updates the UI using the Virtual DOM and reconciliation, you’ll be well equipped to build dynamic and efficient web applications.</p>
<h1 class="heading-1" id="_idParaDest-18">Unlearning everything</h1>
<p class="normal">When working with React for the first time, it’s essential to approach it with an open mind. This is because React represents a new way of designing web and mobile applications, breaking away from many traditional best practices.</p>
<p class="normal">In the last two decades, we’ve learned that separation of concerns is crucial, often involving separating logic from templates. We aim to write JavaScript and HTML in different files, and various templating solutions have been created to aid developers in achieving this goal.</p>
<p class="normal">However, the problem with this approach is that it often creates an illusion of separation. In reality, JavaScript and HTML are tightly coupled, no matter where they live. To illustrate this, let’s consider an example template:</p>
<pre class="programlisting code"><code class="hljs-code">{{#items}} 
  {{#first}} 
    &lt;li&gt;<span class="hljs-tag">&lt;</span><span class="hljs-name">strong</span><span class="hljs-tag">&gt;</span>{{name}}<span class="hljs-tag">&lt;/</span><span class="hljs-name">strong</span><span class="hljs-tag">&gt;</span>&lt;<span class="hljs-regexp">/li&gt; </span>
<span class="hljs-regexp">  {{/</span>first}} 
  {{#link}} 
    &lt;li&gt;<span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">"{{url}}"</span><span class="hljs-tag">&gt;</span>{{name}}<span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>&lt;<span class="hljs-regexp">/li&gt; </span>
<span class="hljs-regexp">  {{/</span>link}} 
{{/items}}
</code></pre>
<p class="normal">The preceding snippet is taken from the Mustache website, one of the most popular templating systems.</p>
<p class="normal">The first row tells Mustache to loop through a collection of items. Inside the loop, there is some conditional logic to check whether the <code class="inlineCode">#first</code> and <code class="inlineCode">#link</code> properties exist and, depending on their values, a different piece of HTML is rendered. Variables are wrapped in curly braces.</p>
<p class="normal">If your application only has to display some variables, a templating library could represent a good solution, but when it comes to starting to work with complex data structures, things change. Templating<a id="_idIndexMarker018"/> systems and their <strong class="keyWord">Domain-Specific Language</strong> (<strong class="keyWord">DSL</strong>) offer a <a id="_idIndexMarker019"/>subset of features, and they try to provide the functionalities of a real programming language without reaching the same level of completeness. As shown in the example, templates highly depend on the models they receive from the logic layer to display the information.</p>
<p class="normal">On the other hand, JavaScript interacts with the DOM elements rendered by the templates to update the UI, even if they are loaded from separate files. The same problem applies to styles – they are defined in a different file, but they are referenced in the templates, and the CSS selectors follow the structure of the markup, so it is almost impossible to change one without breaking the other, which is the <a id="_idIndexMarker020"/>definition of <strong class="keyWord">coupling</strong>. That is why the classic separation of concerns ended up being more the separation of technologies, which is, of course, not a bad thing, but it doesn’t solve any real problems.</p>
<p class="normal">React tries to move a step forward by putting the templates where they belong – next to the logic. The reason it does that is that React suggests you organize your applications by composing small bricks<a id="_idIndexMarker021"/> called components. The framework should not tell you how to separate the concerns because every application has its own, and only the developers should decide how to limit the boundaries of their applications.</p>
<p class="normal">The component-based approach drastically changes the way we write web applications, which is why the classic concept of separation of concerns is gradually being taken over by a much more modern structure. The paradigm enforced by React is not new, and it was not invented by its creators, but React has contributed to making the concept mainstream and, most importantly, popularized it in such a way that it is easier to understand for developers with different levels of expertise.</p>
<p class="normal">Rendering a React component looks like this:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> ( 
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{{</span><span class="hljs-tag"> </span><span class="hljs-attr">color:</span><span class="hljs-tag"> '</span><span class="hljs-attr">red</span><span class="hljs-tag">' }} </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span> 
    Click me! 
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span> 
)
</code></pre>
<p class="normal">We all agree that it seems a bit weird in the beginning, but that is just because we are not used to that kind of syntax. As soon as we learn it and we realize how powerful it is; we understand its potential. Using JavaScript for both logic and templating not only helps us separate our concerns in a better way, but it also gives us more power and more expressivity, which is what we need to build complex UIs.</p>
<p class="normal">That is why even if the idea of mixing JavaScript and HTML sounds weird in the beginning, it is vital to give React 5 minutes. The best way to get started with new technology is to try it on a small side project and see how it goes. In general, the right approach is always to be ready to unlearn everything and change your mindset if the long-term benefits are worth it.</p>
<p class="normal">There is another concept that is pretty controversial and hard to accept, and that the engineers behind React are trying to push to the community: moving the styling logic inside the component, too. The end goal is to encapsulate every single technology used to create our components and separate the concerns according to their domain and functionalities. Here is an example of a style object taken from the React documentation:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> divStyle = { 
  <span class="hljs-attr">color</span>: <span class="hljs-string">'white'</span>, 
  <span class="hljs-attr">backgroundImage</span>: <span class="hljs-string">`url(</span><span class="hljs-subst">${imgUrl}</span><span class="hljs-string">)`</span>, 
  <span class="hljs-title">WebkitTransition</span>: <span class="hljs-string">'all'</span>, <span class="hljs-comment">// note the capital 'W' here </span>
  <span class="hljs-attr">msTransition</span>: <span class="hljs-string">'all'</span> <span class="hljs-comment">// 'ms' is the only lowercase vendor prefix </span>
}
   
<span class="hljs-title">ReactDOM</span>.<span class="hljs-title">render</span>(<span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{divStyle}</span><span class="hljs-tag">&gt;</span>Hello World!<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>, mountNode)
</code></pre>
<p class="normal">This set of solutions, where developers use JavaScript to write their styles, is known as <strong class="keyWord">#CSSinJS</strong>, and we<a id="_idIndexMarker022"/> will talk about it extensively in <em class="chapterRef">Chapter 6</em>, <em class="italic">Making Your Components Look Beautiful</em>.</p>
<p class="normal">In the next section, we will see how to avoid JavaScript fatigue, which is caused by the large number of configurations that are needed to run a React application (webpack mainly).</p>
<h1 class="heading-1" id="_idParaDest-19">Understanding JavaScript fatigue</h1>
<p class="normal">There is a prevailing opinion that React consists of a vast set of technologies and tools, and if you want to use it, you are forced to deal with package managers, transpilers, module bundlers, and an infinite list of different libraries. This idea is so widespread and shared <a id="_idIndexMarker023"/>among people that it has been clearly defined and given the name <strong class="keyWord">JavaScript fatigue</strong>. </p>
<h2 class="heading-2" id="_idParaDest-20">Misconceptions about React</h2>
<p class="normal">It is not hard to<a id="_idIndexMarker024"/> understand the reasons behind JavaScript fatigue. All the repositories and libraries in the React ecosystem are made using shiny new technologies, the latest version of JavaScript, and the most advanced techniques and paradigms. Moreover, there is a massive amount of React boilerplate code on GitHub, each with tens of dependencies to offer solutions for any problem.</p>
<p class="normal">However, it is essential to understand that React is a pretty tiny library, and it can be used inside any page (or even inside JSFiddle) in the same way everyone used to use jQuery or Backbone, just by including the script on the page before the closing body element.</p>
<h2 class="heading-2" id="_idParaDest-21">Getting started with React without the fatigue</h2>
<p class="normal">React is split into two packages:</p>
<ul>
<li class="bulletList"><strong class="keyWord">react</strong>: Implements the <a id="_idIndexMarker025"/>core features of the library</li>
<li class="bulletList"><strong class="keyWord">react-dom</strong>: Contains <a id="_idIndexMarker026"/>all the browser-related features</li>
</ul>
<p class="normal">The reason behind this is that the core package is used to support different targets, such as React DOM in browsers and React Native on mobile devices. Running a React application inside a single HTML page does not require any package manager or complex operation.</p>
<p class="normal">Here are the URLs to be included in the HTML to start using React:</p>
<ul>
<li class="bulletList"><a href="mailto:https://unpkg.com/react@18.2.0/umd/react.production.min.js"><span class="url">https://unpkg.com/react@18.2.0/umd/react.production.min.js</span></a> </li>
<li class="bulletList"><a href="mailto:https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"><span class="url">https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js</span></a> </li>
</ul>
<p class="normal">For a simple UI, we could just use <strong class="keyWord">createElement</strong> (<strong class="keyWord">_jsx</strong> since React 17) and only when we start building something more complex can we include a transpiler to enable JSX and convert it into JavaScript. As the app grows, we may need a router, API endpoints, and external dependencies.</p>
<h2 class="heading-2" id="_idParaDest-22">Advantages of the JavaScript ecosystem</h2>
<p class="normal">Despite the fast pace and <a id="_idIndexMarker027"/>constant change in the JavaScript ecosystem, it offers several advantages. The community plays a significant role in driving innovation and rapid evolution. As soon as a specification is announced or drafted, someone in the community implements it as a transpiler plugin or a polyfill, letting everyone else experiment with it while the browser vendors agree and start supporting it.</p>
<p class="normal">This makes JavaScript and the browser a unique environment compared to other languages or platforms. The downside is that things change quickly, but it is just a matter of finding the right balance between betting on new technologies versus staying safe.</p>
<h2 class="heading-2" id="_idParaDest-23">Bye to Create-React-App, welcome to Vite!</h2>
<p class="normal">Recently, the React team decided to<a id="_idIndexMarker028"/> remove <strong class="keyWord">create-react-app</strong> from their official documentation, indicating that it is no longer the default method for setting up a new React project. Instead, React now recommends using a framework such as Next.js, Remix, or Gatsby for more comprehensive solutions. However, if these frameworks do not fit your needs and you are looking for a simpler alternative, you can opt for build tools like Vite or Parcel.</p>
<h3 class="heading-3" id="_idParaDest-24">Vite as a solution</h3>
<p class="normal">Vite<a id="_idIndexMarker029"/> is a build tool and development server created by Evan You, the creator of Vue.js. It leverages the native ES modules feature in modern browsers for fast development and efficient production builds.</p>
<p class="normal">To use <a id="_idIndexMarker030"/>Vite with React, first, install Vite globally using the following command:</p>
<pre class="programlisting con"><code class="hljs-con">  npm install -g create-vite
</code></pre>
<p class="normal">Next, create a new Vite project using the React TypeScript template:</p>
<pre class="programlisting con"><code class="hljs-con">  create-vite my-react-app --template react-ts
</code></pre>
<p class="normal">Finally, move into the newly created project folder and start the development server: </p>
<pre class="programlisting con"><code class="hljs-con">  cd my-react-app
  npm install
  npm run dev
</code></pre>
<p class="normal">You should see the project running on port <strong class="keyWord">5173</strong> by default.</p>
<figure class="mediaobject"><img alt="" height="504" src="../Images/B18414_01.png" width="516"/></figure>
<p class="packt_figref">Figure 1.1: Vite default application</p>
<p class="normal">If you want to<a id="_idIndexMarker031"/> change the port to <code class="inlineCode">3000</code>, you can modify the <code class="inlineCode">vite.config.ts</code> file like this:</p>
<pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
  <span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-react'</span>
  <span class="hljs-comment">// https://vitejs.dev/config/</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">defineConfig</span>({
    <span class="hljs-attr">plugins</span>: [<span class="hljs-title">react</span>()],
    <span class="hljs-attr">server</span>: {
      <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>
    }
  })
</code></pre>
<p class="normal">By using <a id="_idIndexMarker032"/>Vite, you can scaffold and run a React application with minimal dependencies and still have access to all the features needed to build a complete React application using the most advanced techniques.</p>
<h1 class="heading-1" id="_idParaDest-25">Summary</h1>
<p class="normal">In this first chapter, we have learned about some basic concepts that are very important for following the rest of the book, and that are crucial to working with React daily. We now know how to write declarative code, and we have a clear understanding of the difference between the components we create and the elements that React uses to display their instances on the screen.</p>
<p class="normal">We learned the reasons behind the choice of locating logic and templates together, and why that unpopular decision has been a big win for React. We went through the reasons why it is common to feel fatigued in the JavaScript ecosystem, but we have also seen how to avoid those problems by following an iterative approach.</p>
<p class="normal">Finally, we have seen what the new <code class="inlineCode">create-vite</code> CLI is, and we are now ready to start writing some real code.</p>
<p class="normal">In the next chapter, you will learn TypeScript and how to use it in your projects.</p>
<h1 class="heading-1" id="_idParaDest-26">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussion with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/React18DesignPatterns4e"><span class="url">https://packt.link/React18DesignPatterns4e</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code2450023176943770109.png" width="177"/></p>
</div>
</div></body></html>