- en: Tables - Display Complex Collection Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格 - 显示复杂集合数据
- en: 'In this chapter, you''ll learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Stateful tables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态化表格
- en: Sortable columns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可排序的列
- en: Filtering rows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤行
- en: Selecting rows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择行
- en: Row actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行操作
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: If your application needs to display tabular data, you can use the Material-UI `Table` component,
    along with all of its supporting components. Unlike grid components, which you
    might have seen or used in other React libraries, the Material-UI component is
    unopinionated. This means that you have to write your own code to control table
    data. On the plus side, the `Table` component stays out of your way and lets you
    implement things your own way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要显示表格数据，你可以使用Material-UI的`Table`组件及其所有支持组件。与你在其他React库中可能看到或使用过的网格组件不同，Material-UI组件是无偏见的。这意味着你必须编写自己的代码来控制表格数据。好处是，`Table`组件不会妨碍你，让你能够以自己的方式实现。
- en: Stateful tables
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态化表格
- en: With `Table` components, it's rare that you'll have static markup that defines
    the row data of the table. Instead, component state will map to the rows that
    make up your table data. For example, you might have a component that fetches
    API data that you want displayed in a table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Table`组件时，很少会遇到静态标记来定义表格的行数据。相反，组件状态将映射到构成你的表格数据的行。例如，你可能有一个从API获取数据并希望在表格中显示的组件。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have a component that fetches data from an API endpoint.
    When the data loads, you want to display the tabular data in a Material-UI `Table`
    component. Here''s what the code looks like:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个从API端点获取数据的组件。当数据加载时，你希望在Material-UI的`Table`组件中显示表格数据。以下是代码的样子：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you load the screen, you''ll see a table populated with data after one
    second:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你加载屏幕时，你将在一秒后看到一个填充了数据的表格：
- en: '![](img/d2c62425-5743-4950-be34-ed1e5c408211.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2c62425-5743-4950-be34-ed1e5c408211.png)'
- en: How it works...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the `fetchData()` function, which resolves the data
    that is eventually set as the component state:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看`fetchData()`函数开始，该函数解析最终设置为组件状态的数据：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function returns a `Promise` that resolves an array of objects after one
    second. The idea is to simulate a function that calls a real API using `fetch()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个`Promise`，在一秒后解析为一个对象数组。其想法是模拟一个使用`fetch()`调用真实API的函数。
- en: The objects shown in the array are truncated for brevity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，数组中显示的对象被截断了。
- en: 'Next, let''s look at the initial component state and what happens when your
    component is mounted:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看初始组件状态以及你的组件挂载时会发生什么：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `items` state represents the table rows that are to be rendered within
    the `Table` component. When your component is mounted, the `fetchData()` call
    is made, and when the `Promise` resolves, the `items` state is set. Lastly, let''s
    look at the markup that''s responsible for rendering the table rows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`状态表示要在`Table`组件内渲染的表格行。当你的组件挂载时，会调用`fetchData()`，当`Promise`解析时，`items`状态被设置。最后，让我们看看负责渲染表格行的标记：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Table` components typically have two children—a `TableHead` and a `TableBody`
    component. Inside `TableHead`, you''ll find a `TableRow` component with several
    `TableCell` components. These are the table column headings. Inside `TableBody`,
    you''ll see that the `items` state is mapped to `TableRow` and `TableCell` components.
    When the `items` state changes, the rows are changed too. You can already see
    this in action, because the `items` state defaults to an empty array. After the
    API data resolves, the `items` state changes and the rows are visible on the screen.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`组件通常有两个子组件——一个`TableHead`组件和一个`TableBody`组件。在`TableHead`内部，你会找到一个包含多个`TableCell`组件的`TableRow`组件。这些是表格列标题。在`TableBody`内部，你会看到`items`状态被映射到`TableRow`和`TableCell`组件。当`items`状态改变时，行也会改变。你已经在实际操作中看到了这一点，因为`items`状态默认为空数组。在API数据解析后，`items`状态改变，行在屏幕上可见。'
- en: There's more...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One suboptimal aspect of this example is the user's experience while they wait
    for table data to load. Showing the column headers upfront is fine, since you
    know what they are ahead of time and the user might too. What's needed is some
    sort of indicator that the actual row data is, in fact, loading.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的一个次优方面是用户在等待表格数据加载时的体验。提前显示列标题是可以的，因为你事先知道它们是什么，用户也可能知道。需要的是某种指示器，表明实际的行数据确实正在加载。
- en: One way to fix this issue is to add a circular progress indicator underneath
    the column headers. This should help the user understand that not only are they
    waiting for data to load, but that it's the table row data specifically, thanks
    to the position of the progress indicator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是在列标题下方添加一个环形进度指示器。这应该有助于用户理解他们不仅正在等待数据加载，而且具体是等待表格行数据，多亏了进度指示器的位置。
- en: 'First, let''s introduce a new component for displaying a `CircularProgress`
    component along with some new styles:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍一个新的组件来显示`CircularProgress`组件和一些新的样式：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's a new `progress` style that's applied to the `CircularProgress` component.
    This adds `margin` to the progress indicator. The `textAlign` property has been
    added to the `root` style so that the progress indicator is horizontally centered
    within the `Paper` component. The `MaybeLoading` component renders the `CircularProgress`
    component if the `loading` property is `true`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 新增了一种应用于`CircularProgress`组件的`progress`样式。这为进度指示器添加了`margin`。`textAlign`属性已被添加到`root`样式，以便进度指示器在`Paper`组件内水平居中。如果`loading`属性为`true`，则`MaybeLoading`组件会渲染`CircularProgress`组件。
- en: 'This means that you now have to keep track of the `loading` state of the API
    call. Here''s the new state, which defaults to `true`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你现在必须跟踪API调用的`loading`状态。以下是新的状态，默认为`true`：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the API call returns, you can set the `loading` state to `false`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当API调用返回时，您可以设置`loading`状态为`false`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, you need to render the `MaybeLoading` component after the `Table` component:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要在`Table`组件之后渲染`MaybeLoading`组件：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s what your users will see while waiting for the table data to load:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的用户等待表格数据加载时，他们会看到以下内容：
- en: '![](img/d9ac9bca-e739-4648-a7f7-0d25e9151a05.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d9ac9bca-e739-4648-a7f7-0d25e9151a05.png)'
- en: See also
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Table` API documentation: [https://material-ui.com/api/table/](https://material-ui.com/api/table/)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table` API文档：[https://material-ui.com/api/table/](https://material-ui.com/api/table/)'
- en: Sortable columns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可排序列
- en: Material-UI tables have tools that help you implement sortable columns. If you're
    rendering a `Table` component in your application, your users will likely expect
    to be able to sort the table data by column.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI表格具有帮助您实现可排序列的工具。如果您在应用程序中渲染`Table`组件，您的用户可能会期望能够按列排序表格数据。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'When the users clicks on a column header, there should be a visual indication
    that table rows are now sorted by this column and the row order should change.
    When clicked on again, the column should appear in reverse order. Here''s the
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击列标题时，应该有一个视觉指示表明表格行现在按此列排序，行顺序应改变。再次点击时，列应以相反的顺序出现。以下是代码：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you click on the Name column header, here''s what you''ll see:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击名称列标题，你会看到以下内容：
- en: '![](img/23804a51-b62d-4a73-a07c-5e549d9a7703.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23804a51-b62d-4a73-a07c-5e549d9a7703.png)'
- en: 'The column changes to indicate the sort order. If you click on the name column
    again, the sort order will reverse:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列会改变以指示排序顺序。如果您再次点击名称列，排序顺序将反转：
- en: '![](img/f7bcc0a9-01fb-441b-acde-af3a58a60364.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7bcc0a9-01fb-441b-acde-af3a58a60364.png)'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s break down the code used to render this table, starting with the markup
    used to render the column headers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解用于渲染此表格的代码，从用于渲染列标题的标记开始：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Each column in the table is defined in the `columns` state. This array is mapped
    to `TableCell` components. Inside each `TableCell`, there''s a `TableSortLabel`
    component. This component makes the column header text bold when it''s the active
    column for sorting. It also adds the sort arrow to the right of the text. `TableSortLabel`
    takes `active`, `direction`, and `onClick` properties. The `active` property is
    based on the `active` state of the column, which changes when the column is clicked
    on. The `direction` property determines whether the rows are sorted in ascending
    or descending order for the given column. The `onClick` property takes an event
    handler that makes the necessary state changes when the column is clicked on.
    Here''s the `onSortClick()` handler:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的每一列都在`columns`状态中定义。此数组映射到`TableCell`组件。在每个`TableCell`内部，有一个`TableSortLabel`组件。当它是排序的激活列时，此组件会使列标题文本加粗，并在文本右侧添加排序箭头。`TableSortLabel`接受`active`、`direction`和`onClick`属性。`active`属性基于列的`active`状态，当列被点击时改变。`direction`属性确定对于给定列，行是按升序还是降序排序。`onClick`属性接受一个事件处理器，当列被点击时，它会进行必要的状态更改。以下是`onSortClick()`处理器：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function takes an `index` argument—the column index—and returns a new
    function for the column. The returned function has two purposes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个`index`参数——列索引——并返回一个新的列函数。返回的函数有两个目的：
- en: To update the column state so that the correct column is marked as active and
    that it has the correct sort direction
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更新列状态，以便正确标记为激活的列，并具有正确的排序方向
- en: To update the row state so that the table rows are in the correct order
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更新行状态，使表格行按正确顺序排列
- en: 'Once these state changes have been made, the `active` column and the table
    rows will reflect them. The last piece of code to look at is the `comparator()`
    function. This is another higher-order function that takes the name of a column,
    and returns a new function that can be passed to `Array.sort()` to sort an array
    of objects by the given column:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些状态变化已经完成，`active`列和表格行将反映这些变化。接下来要查看的最后一段代码是`comparator()`函数。这是一个高阶函数，它接受一个列名，并返回一个新的函数，该函数可以被传递给`Array.sort()`以按给定列对对象数组进行排序：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function is generic enough that you can use it with any tables in your
    app. In this case, the column name and order are passed to `comparator()` from
    the component state. As the state of the component changes, so too does the sorting
    behavior in `comparator()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数足够通用，可以用于你应用中的任何表格。在这种情况下，列名和顺序是从组件状态传递给`comparator()`的。随着组件状态的变化，`comparator()`中的排序行为也会发生变化。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What if your data is already sorted by a particular column when it arrives from
    the API? If this is the case, you'll probably want to indicate which columns the
    rows are sorted by and in what direction, before the user starts interacting with
    the table.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据在从API到达时已经按特定列排序，你会怎么办？如果是这种情况，你可能会想在用户开始与表格交互之前，指出哪些列的行是按什么方向排序的。
- en: 'To do so, you just need to change the default column state. For example, let''s
    say that the Average column is sorted in descending order by default. Here''s
    what your initial `column` state would look like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，你只需要更改默认的列状态。例如，假设平均值列默认按降序排序。以下是你的初始`column`状态的外观：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Average column is now active by default. You didn''t need to specify the
    order since the default is ascending. Here''s what the table looks like when the
    screen first loads:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值列默认为激活状态。由于默认为升序，因此不需要指定顺序。以下是屏幕首次加载时的表格外观：
- en: '![](img/be2b1f68-131e-4634-8711-ca17e96217cb.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be2b1f68-131e-4634-8711-ca17e96217cb.png)'
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table`演示：[https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
- en: Filtering rows
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤行
- en: Where there are tables, there's potential for too much information. This is
    why adding a search feature to your tables is a good idea. It allows the user
    to remove irrelevant rows from the table as they type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在有表格的地方，信息量过多是潜在的问题。这就是为什么在表格中添加搜索功能是个好主意。它允许用户在输入时从表格中删除不相关的行。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s say that you have a table with lots of rows in it, meaning that the
    user is going to have a tough time scrolling through the entire table. To make
    things easier for them, you decide to add a search feature to your table that
    filters rows by checking whether the search text exists within the name column.
    Here''s the code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含许多行的表格，这意味着用户将很难滚动查看整个表格。为了让他们更容易操作，你决定在你的表格中添加一个搜索功能，通过检查搜索文本是否存在于名称列中来过滤行。以下是代码：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s what the table and search input fields look like when the screen first
    loads:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕首次加载时，表格和搜索输入字段看起来如下：
- en: '![](img/12f6ec74-4c3e-4b8b-a651-3c6eb5fe6bb2.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12f6ec74-4c3e-4b8b-a651-3c6eb5fe6bb2.png)'
- en: 'The search input is just above the table. Try typing in a filter string, such
    as Fourth—you should see the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索输入位于表格上方。尝试输入一个过滤器字符串，例如 第四——你应该看到以下内容：
- en: '![](img/e635e51a-3080-441d-8d60-77bdb4aafb14.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e635e51a-3080-441d-8d60-77bdb4aafb14.png)'
- en: If you delete the filter text from the search input, all rows in the table data
    will be rendered again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从搜索输入中删除过滤器文本，表格数据中的所有行将再次渲染。
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the state of the `FilteringRows` component:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`FilteringRows`组件的状态：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The search string is the actual filter that changes the rows that are rendered
    within the `Table` element. Next, let''s look at the `TextField` component that
    renders the search input:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索字符串是实际过滤器，它会改变在`Table`元素中渲染的行。接下来，让我们看看渲染搜索输入的`TextField`组件：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `onSearchChange()` function is responsible for maintaining the search state
    as the user types. You should render the search input component close to the table
    that it filters. In this example, the position of the search input feels like
    it belongs to the table.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSearchChange()` 函数负责在用户输入时维护搜索状态。你应该在过滤表格附近渲染搜索输入组件。在这个例子中，搜索输入的位置感觉像是属于表格的。'
- en: 'Lastly, let''s look at how the table rows are filtered and rendered:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看表格行是如何过滤和渲染的：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of calling `map()` directly on the item's state, `filter()` is used
    to produce an array of items that match the search criteria. As the `search` state
    changes, the `filter()` call is repeated. The condition that checks whether the
    item matches what the user has typed checks to see whether the `name` property
    of the item contains the search string. But first, you have to make sure that
    the user is actually filtering. For example, if the search string is empty, every
    item should be returned. How the item is searched is specific to your application—you
    could search every item property if you wanted to.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于直接在项目状态上调用 `map()`，使用 `filter()` 来生成一个与搜索标准匹配的项目数组。随着 `search` 状态的变化，`filter()`
    调用会重复进行。检查项目是否匹配用户输入的条件是查看项目的 `name` 属性是否包含搜索字符串。但首先，你必须确保用户实际上正在进行过滤。例如，如果搜索字符串为空，则应返回每个项目。项目是如何被搜索的取决于你的应用程序——如果你想的话，你可以搜索每个项目的每个属性。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table` 示例：[https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
- en: Selecting rows
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择行
- en: Users often need to interact with specific rows in a table. For example, they
    might select a row and then perform an action that uses data from the selected
    row. Or, the user selects multiple rows, which produces new data related to their
    selection. With Material-UI tables, you can mark rows as selected using a single
    `TableRow` property.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常需要与表格中的特定行进行交互。例如，他们可能会选择一行，然后执行使用所选行数据的操作。或者，用户选择多行，这会产生与他们的选择相关的新数据。使用
    Material-UI 表格，你可以使用单个 `TableRow` 属性来标记选中的行。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this example, let''s assume that the user needs to be able to select multiple
    rows in your table. As rows are selected, another section on the screen is updated
    with data that reflects the selected rows. Let''s start by looking at the `Card`
    component, which displays data from the selected table rows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设用户需要能够在你的表格中选择多行。随着行的选择，屏幕上的另一个部分会更新，以显示反映所选行的数据。让我们首先看看显示所选表格行数据的
    `Card` 组件：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at the rest of the components now:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看其余的组件：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s what the screen looks like when it first loads:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是屏幕首次加载时的样子：
- en: '![](img/ba4e04ff-17c3-4a51-9181-5e6890c3b8a3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba4e04ff-17c3-4a51-9181-5e6890c3b8a3.png)'
- en: 'Now, you can try making some row selections. Here''s what you''ll see if you
    select the second and fourth rows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以尝试进行一些行选择。如果你选择了第二行和第四行，你会看到以下内容：
- en: '![](img/aa0fef0d-d84c-41b6-b2c3-0794937e2d56.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa0fef0d-d84c-41b6-b2c3-0794937e2d56.png)'
- en: When you click on a table row, it changes visually so that the user can see
    that it is selected. Also note that the `Card` component contents change to reflect
    the selected rows. It also tells you how many rows are selected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击表格行时，它会从视觉上发生变化，以便用户可以看到它已被选中。此外，请注意，`Card` 组件的内容也会改变，以反映选中的行。它还会告诉你已选中多少行。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Card` component relies on a few helper functions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Card` 组件依赖于几个辅助函数：'
- en: '`selectedLow`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedLow`'
- en: '`selectedHigh`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedHigh`'
- en: '`selectedAverage`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedAverage`'
- en: 'The return values of these functions change when the table row selection changes.
    Let''s take a closer look at how these values are computed:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的返回值会随着表格行选择的变化而变化。让我们更仔细地看看这些值是如何计算的：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `selectedLow()` and `selectedHigh()` functions work the same way—they just
    operate on the `low` and `high` fields respectively. The `filter()` call is used
    to make sure that you're only working with selected rows. The `reduce()` call
    adds the values of the given field for the selected rows and returns the result
    as the property value. The `selectedAverage()` function uses the `selectedLow()`
    and `selectedHigh()` functions to compute a new average for the row selections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectedLow()`和`selectedHigh()`函数以相同的方式工作——它们只是分别操作`low`和`high`字段。`filter()`调用用于确保你只处理选中的行。`reduce()`调用将选中的行给定字段的值相加，并将结果作为属性值返回。`selectedAverage()`函数使用`selectedLow()`和`selectedHigh()`函数来计算行选择的新的平均值。'
- en: 'Next, let''s look at the handler that''s called when a row is selected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当选择行时被调用的处理程序：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `onRowClick()` function finds the selected row in the `rows` state based
    on the `id` argument. Then, it toggles the selected state of the row. As a result,
    the computed properties that you just looked at are updated, and so is the appearance
    of the row itself:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRowClick()`函数根据`id`参数在`rows`状态中找到选中的行。然后，它切换行的选中状态。结果，你刚才看到的计算属性被更新，行的外观也是如此：'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `TableRow` component has a `selected` property, which changes the style
    of the row to mark it as selected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableRow`组件有一个`selected`属性，它会改变行的样式以标记它为已选择。'
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`表格`演示：[https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
- en: Row actions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行操作
- en: Table rows often represent an object that you can perform actions on. For example,
    you might have a table of servers where each row represents a server that can
    be turned on or off. Instead of making your users click a link that takes them
    away from the table to perform an action, you can include common actions directly
    in each table row.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表格行通常代表你可以执行操作的实体。例如，你可能有一个包含服务器的表格，其中每一行代表一个可以开启或关闭的服务器。而不是让用户点击一个将他们从表格带到另一个页面去执行操作的链接，你可以在每一行表格中直接包含常见的操作。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's say that you have a table with rows that have servers that can be turned
    on or off, depending on their current state. You want to include both of these
    actions as part of each table row, so that the user can more easily control their
    servers without spending lots of time navigating. The buttons also need to change
    their color and disabled state based on the state of the row.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个表格，其中包含可以开启或关闭的服务器行，这取决于它们当前的状态。你希望将这两个操作作为每一行表格的一部分包含进来，这样用户就可以更容易地控制他们的服务器，而无需花费大量时间导航。按钮还需要根据行的状态改变它们的颜色和禁用状态。
- en: 'Here''s the code to do this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成这个功能的代码：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s what the screen looks like when it first loads:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是屏幕首次加载时的样子：
- en: '![](img/35feccdc-ed17-4395-8cba-c7d2f7277c2c.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35feccdc-ed17-4395-8cba-c7d2f7277c2c.png)'
- en: 'Depending on the status of the row data, the action buttons will show differently.
    For example, in the first row, the start button is disabled because `status` is
    `running`. The second row has a disabled stop button because the `status` is `off`.
    Let''s try clicking on the stop button in the first row and the start button in
    the second row. Here''s how the UI changes once this is done:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 根据行数据的`状态`，操作按钮将显示不同。例如，在第一行中，启动按钮被禁用，因为`状态`是`running`。第二行有一个禁用的停止按钮，因为`状态`是`off`。让我们尝试点击第一行的停止按钮和第二行的启动按钮。完成这些操作后，UI将如何变化：
- en: '![](img/2fa663ae-417c-4c41-8444-818dc9e94b9f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fa663ae-417c-4c41-8444-818dc9e94b9f.png)'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by looking at the two components that are used as the row actions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看用作行操作的两种组件开始：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `StartButton` and `StopButton` components are very similar. Both of these
    components are rendered in every row of the table. There's the `onClick` property,
    a function that changes the state of the row data when clicked. The `color` of
    the icon changes based on the `status` of the row. Likewise, the `disabled` property
    changes based on the `status` of the row.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartButton`和`StopButton`组件非常相似。这两个组件在表格的每一行中都被渲染。有一个`onClick`属性，这是一个函数，当点击时它会改变行数据的当前状态。图标的`颜色`会根据行的`状态`改变。同样，`disabled`属性也会根据行的`状态`改变。'
- en: 'Next, let''s look at the `toggleStatus()` handler, which changes the status
    state of the row when an action button is clicked:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当点击操作按钮时被调用的`toggleStatus()`处理程序，它会改变行的状态状态：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `StartButton` and `StopButton` components both use the same handler function—it
    toggles the `status` value between `running` and `off`. Finally, let''s look at
    the `TableCell` component where these `row` actions are rendered:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartButton` 和 `StopButton` 组件都使用相同的处理函数——它在 `status` 值之间切换 `running` 和 `off`。最后，让我们看看
    `TableCell` 组件，这些 `row` 动作在这里被渲染：'
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The row data is passed as the `row` property. The `toggleStatus()` function
    takes a `row id` argument and returns a new handler function that acts on this
    row.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 行数据作为 `row` 属性传递。`toggleStatus()` 函数接受一个 `row id` 参数，并返回一个作用于该行的新处理函数。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '`Table` demos: [https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Table` 示例：[https://material-ui.com/demos/tables/](https://material-ui.com/demos/tables/)'
