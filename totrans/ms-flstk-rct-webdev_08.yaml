- en: Docker and the EC2 Container Service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker和EC2容器服务
- en: We have done all the stuff related to database-as-a-backend with mLab. The publishing
    application should be working 100 percent remotely on the mLab MongoDB instance,
    so you don't need to run the `mongod` command anymore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了与数据库作为后端的所有相关事宜，使用的是mLab。发布应用程序应该在mLab MongoDB实例上100%远程工作，所以你不再需要运行`mongod`命令了。
- en: It's time to prepare our Docker container and deploy it on EC2 completely with
    the use of ECS (EC2 Container Service) and load balancers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候准备我们的Docker容器，并使用ECS（EC2容器服务）和负载均衡器将其完全部署到EC2上了。
- en: What is Docker? It's a very useful piece of software that is open source and
    helps you pack, ship, and run any app as a light (in comparison to a virtual machine,
    for example) container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Docker？它是一个非常实用的开源软件，可以帮助你打包、运输和运行任何应用程序作为一个轻量级的容器（例如，与虚拟机相比）。
- en: A container's goals are similar to virtual machines--the big difference is that
    Docker was created with software development in mind, as opposed to VMs. You need
    to also be aware that a fully virtualized system has its own resources allocated
    to it, which causes minimal resource sharing, which is different for Docker containers.
    Of course, in VMs, you get more isolation, but the cost is that the VMs are much
    heavier (requiring more disk space, RAM, and other resources). Docker's containers
    are lightweight and are able to share more things among different containers in
    comparison to VMs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的目标与虚拟机类似--最大的区别是Docker是为了软件开发而创建的，而不是VM。你还需要意识到，一个完全虚拟化的系统为其分配了自身的资源，这导致了最小资源共享，这与Docker容器不同。当然，在VM中，你得到更多的隔离，但代价是VM要重得多（需要更多的磁盘空间、RAM和其他资源）。Docker的容器轻量级，并且与VM相比，能够在不同的容器之间共享更多东西。
- en: The good part is that Docker's containers are hardware and platform independent,
    so all worries about whether what you are working on will run everywhere are disappearing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好的一点是，Docker的容器是硬件和平台无关的，所以关于你正在工作的内容是否能在任何地方运行的担忧都消失了。
- en: Generally, Docker's benefits are that it increases developers' productivity,
    helps them ship software faster, helps move the software from local development
    machines to production deployments on AWS, and so on. Docker also allows versioning
    (similar to Git) of your software, which can be helpful when you need a quick
    rollback on the production server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Docker的好处是它提高了开发者的生产力，帮助他们更快地发布软件，帮助他们将软件从本地开发机器移动到AWS上的生产部署，等等。Docker还允许对软件进行版本控制（类似于Git），这在需要快速在生产服务器上回滚时非常有帮助。
- en: 'In this chapter, you will learn the following things:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Installing the Docker app on your machine with Docker Toolbox on non-Linux machines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非Linux机器上使用Docker Toolbox安装Docker应用程序
- en: Testing whether your Docker setup is correct
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的Docker设置是否正确
- en: Preparing the publishing app in order to use mLab Mongo for the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备发布应用程序以使用mLab Mongo作为数据库
- en: Creating a new Docker container for the publishing app
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为发布应用程序创建一个新的Docker容器
- en: Creating your first Dockerfile, which will deploy the publishing app on Linux
    CentOS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个Dockerfile，该文件将在Linux CentOS上部署发布应用程序
- en: EC2 Container Service
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2容器服务
- en: AWS load balancers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS负载均衡器
- en: Using Amazon Route 53 for DNS services
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Route 53进行DNS服务
- en: AWS identity and access management (IAM)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS身份和访问管理（IAM）
- en: Docker installation with Docker Toolbox
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Toolbox安装Docker
- en: Installing Docker is quite easy. Visit the official installation page at [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)
    because it will guide you best depending on your operating system. There are easy-to-follow
    installers for iOS and Windows and a lot of instructions for different Linux distributions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker相当简单。访问官方安装页面[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)，因为它会根据你的操作系统提供最佳指导。有适用于iOS和Windows的易于遵循的安装程序，以及针对不同Linux发行版的许多说明。
- en: 'If you are using a non-Linux machine, then you also need to install Docker
    Toolbox for Windows or OS X. This is quite simple with its installers, which are
    available at [https://www.docker.com/products/docker-toolbox](https://www.docker.com/products/docker-toolbox),
    as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是非Linux机器，那么你还需要安装Docker Toolbox for Windows或OS X。这很简单，因为它的安装程序可以在[https://www.docker.com/products/docker-toolbox](https://www.docker.com/products/docker-toolbox)找到，如下面的截图所示：
- en: '![](img/00094.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: 'If you are using Linux, there are some extra steps to be performed as you need
    to turn on virtualization in BIOS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Install the Docker machine with instructions from the official docs at [https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Ubuntu, you need to install VirtualBox manually from [https://help.ubuntu.com/community/VirtualBox](https://help.ubuntu.com/community/VirtualBox)[](https://docs.docker.com/machine/install-machine/)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other Linux distributions visit [https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you have installed Docker (together with Toolbox on OS X and Windows)
    on your local machine, run in the Terminal the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you run this command, you will be able to see something similar to the
    following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: If you can see something like this, then your installation is successful. Let's
    continue with Docker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub - an hello world example
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating the publishing app's Docker container, let's start
    playing with an official Docker *hello world* example that will make you aware
    of how the Docker Hub works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Hub is to Docker containers as GitHub is to Git''s repositories. You
    can have public and private containers in Docker. The main page of Docker Hub
    look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Just to give you a feel for it, if you visit [https://hub.docker.com/explore/](https://hub.docker.com/explore/),
    you can see different containers that are ready for use, like this, for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Just for our demo exercise, we will use a container called `hello world`, which
    is publicly available at [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run this `hello-world` example, run the following in your Terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After you run this, you will see something similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand what''s just happened: we use the `docker run` command in
    order to start the container based on an image (in our example, we have used the
    hello world container image). In this case, we do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Run the command that tells Docker to start the container named `hello-world`
    with no extra commands.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you hit Enter, Docker will download Docker Hub.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it will start the container in the VM, using Docker Toolbox on non-Linux
    systems.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `hello-world` image comes from the public registry called Docker Hub as
    mentioned before (which you can visit at [https://hub.docker.com/r/library/hello-world/](https://hub.docker.com/r/library/hello-world/)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile example
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every image is composed of a Dockerfile. An example Dockerfile for the `hello-world`
    example looks like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A Dockerfile is a set of instructions that tell Docker how to build a container
    image. We will create our own in a moment. An analogy for a Dockerfile can be
    the Bash language that you can use on any Linux/Unix machine. Of course, it's
    different, but the general idea of writing instructions to create the job is similar.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一组指令，告诉Docker如何构建容器镜像。我们将在稍后创建自己的。Dockerfile的一个类比可以在任何Linux/Unix机器上使用的Bash语言。当然，它不同，但编写指令以创建工作的总体思想是相似的。
- en: Modifications to our codebase in order to create it
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了创建它，我们需要对我们的代码库进行修改
- en: Currently, we are sure that our Docker application's setup is working correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们确信我们的Docker应用程序的设置是正确的。
- en: First of all, we need to make some modifications to our current codebase as
    there are small tweaks to make it work properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的当前代码库进行一些修改，因为有一些小的调整才能使其正常工作。
- en: Make sure that the following files have the proper content.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以下文件具有适当的内容。
- en: 'The `server/.env` file''s content has to be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/.env`文件的内容必须如下：'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For now, we will load the environment variables from a file, but later we will
    load them from the AWS panel. It's not really production-secure to keep all that
    secret data on the server. We use it now for the sake of brevity; later, we'll
    delete it in favor of a more secure approach.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从文件中加载环境变量，但稍后我们将从AWS面板加载它们。将所有这些机密数据保留在服务器上并不真正符合生产安全。我们现在是出于简洁的考虑使用它；稍后，我们将删除它，转而采用更安全的方法。
- en: Regarding the Mongo environment variables, we learned them in the previous chapter
    about setting up mLab (get to back to the chapter if you missed any of the details
    required at this point).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Mongo环境变量，我们在上一章关于设置mLab（如果遗漏了此点所需的任何细节，请回到该章节）中学习了它们。
- en: 'The `server/index.js` file''s content has to be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/index.js`文件的内容必须如下：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure you are loading `.env` from the file at the beginning of `server/index.js`.
    It will be required in order to load the mLab Mongo details from the environment
    variables (`server/.env`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在`server/index.js`的开始处加载`.env`文件。这将是为了从环境变量（`server/.env`）中加载mLab Mongo详细信息所必需的。
- en: 'The `server/configMongoose.js` file''s content has to be replaced. Find the
    following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`server/configMongoose.js`文件的内容必须替换。找到以下代码：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new version of the same improved code has to be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样改进的代码的新版本必须如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have added the ability to connect with a specific DB's user.
    We need it because the localhost on which we were working didn't require any user,
    but when we start using the mLab MongoDB, then specifying our database's user
    is a must. Otherwise, we won't be able to authenticate correctly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们增加了连接到特定数据库用户的可能性。我们需要它，因为我们之前工作的localhost不需要任何用户，但当我们开始使用mLab MongoDB时，指定我们的数据库用户是必须的。否则，我们无法正确认证。
- en: From this point, you don't need to run the `mongod` process in the background
    of your system, because the app will connect with the mLab MongoDB node that you
    created in the previous chapter. The mLab MongoDB (free version) runs 24/7, but
    if you plan to use it for production-ready apps, then you need to update it and
    start using the replica set feature as well (which was mentioned in the previous
    chapter).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你不需要在你的系统后台运行`mongod`进程，因为应用程序将连接到你在上一章中创建的mLab MongoDB节点。mLab MongoDB（免费版）全天候运行，但如果计划将其用于生产就绪应用程序，那么你需要更新它并开始使用副本集功能（这在上一章中已提及）。
- en: 'You can try to run the project with this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试使用以下命令运行项目：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then you should be able to load the app:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该能够加载应用程序：
- en: '![](img/00099.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00099.jpeg)'
- en: The important difference now is that all the CRUD operations (read/write via
    our publishing app) are done on our remote MongoDB (not on the local one).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的重要区别是，所有的CRUD操作（通过我们的发布应用程序的读写）都是在我们的远程MongoDB（而不是本地）上完成的。
- en: After the publishing app uses the mLab MongoDB, we are ready to prepare our
    Docker image and then deploy it on several instances of AWS EC2 with AWS Load
    Balancer and EC2 Container Service.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布应用程序使用mLab MongoDB之后，我们就可以准备我们的Docker镜像，然后使用AWS Load Balancer和EC2 Container
    Service在AWS EC2的几个实例上部署它。
- en: Working on the publishing app Docker image
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在发布应用程序的Docker镜像上工作
- en: Before continuing, you should be able to run your project locally by using remote
    mLab MongoDB. It's required because we will start running our publishing app in
    the Docker container. Our app will then connect with Mongo remotely. We won't
    run any MongoDB process in any Docker container. This is why it's so important
    to use mLab in the following steps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Dockerfile by executing the following command in a terminal/command
    line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Enter the following content in your new Dockerfile:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s look step by step at the Dockerfile we are going to use in our publishing
    app together with Docker:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM centos:centos7`: This says that we will use as a starting point the CentOS
    7 Linux distribution from the [https://hub.docker.com/r/_/centos/](https://hub.docker.com/r/_/centos/)
    public Docker repository.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use any other package as a starting point, such as Ubuntu, but we are
    using CentOS 7 because it's more lightweight and generally very good for web app
    deployment. You can find further details at [https://www.centos.org/](https://www.centos.org/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Documentation of all commands is available at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN yum update -y`: This updates packages from the command line with `yum--`standard
    for any Linux setup.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN yum install -y tar wget`: This installs two packages as `tar` (for unpacking
    files) and `wget` (for downloading files).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN wget -q https://nodejs.org/dist/v4.0.0/node-v4.0.0-linux-x64.tar.gz -O
    - | tar xzf - -C /opt/*`: This command downloads `node4.0.0` to our CentOS container,
    unpacks it, and puts all the files into the `/opt/` directory.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN mv /opt/node-v /opt/node*`: This renames the folder we just downloaded
    and unpacked (with `node`) to simply `node` without version naming.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN ln -s /opt/node/bin/node /usr/bin/node`: We are linking the `/opt/node/bin/node`
    location with a `/usr/bin/node` link, so we are able to use a simple `$ node`
    command in the Terminal. This is standard stuff for Linux users.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN ln -s /opt/node/bin/npm /usr/bin/npm`: The same as with `node`, but with
    `npm`. We are linking it in order to make usage easier and linking it to `$ npm`
    on our CentOS 7.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY . /opt/publishing-app/`: This copies all the files in the context (The
    `.` (dot) sign is the location when you start the container build. We will do
    that in a moment.) It copies all the files into the `/opt/publishing-app/` location
    in our container.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we have created the Dockerfile in our publishing app's directory,
    so it will copy all the project files in the container to the given location at
    `/opt/publishing-app/`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR /opt/publishing-app`: After we have our publishing app''s files in
    our Docker container, we need to choose the working directory. It''s similar to
    `$ cd /opt/publishing-app` on any Unix/Linux machine.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN npm install`: When we are in our working directory, which is `/opt/publishing-app`,
    then we run the standard `npm install` command.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN yum clean all`: We clean the `yum` cache.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE 80`: We define the port that is using our publishing application.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["npm", "start"]`: Then, we specify how to run the application in our
    Docker container.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also create in the main project directory, a `.dockerignore` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The file content will be as following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We don't want to copy over the mentioned files `(.DS_Store` is specific to OS
    X).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Building the publishing app container
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, you will be able to build the Docker's container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main directory of the project, you need to run the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `login` command will prompt you to insert your Docker username and password.
    After you are authenticated correctly, you can run the `build` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, the username and the container name combination has to be yours.
    Replace it with your details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'That preceding command will build the container with the use of Dockerfile
    commands. This is what you will see (step 1, step 2, and so on):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'After a successful build, you will see in your Terminal/command line something
    similar to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see here from the Docker Terminal, we have built a container in a
    successful manner. The next step is to test it locally and then learn a little
    bit more of Docker's basics and finally start working on our AWS deployment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Running the publishing app container locally
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to test whether the container has been built correctly, perform the
    following steps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command will give you output similar to this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are looking for the `DOCKER_HOST` IP address; in this case, it's `192.168.99.100`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This Docker host IP will be used to check whether our application is running
    correctly in the container. Note it down.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to run our local container with the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Regarding flags: the `d` flag stands for "detached," so the process will run
    in the background. You can list all running Docker processes with the following
    command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An example output would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: The `-p` flag is telling us that the container's port `80` is bound to port
    `80` on the Docker IP host. So if we expose our Node app on port `80` in the container,
    then it will be able to run on a standard port `80` on the IP (in the examples,
    it will be `192.168.99.100:80`; obviously, port `80` is for all HTTP requests).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The `przeor/pub-app-docker` command will specify the name of the container that
    we want to run.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: With `npm start`, we tell which command we want to run in the Docker container
    right after starting (otherwise, the container would run and stop immediately).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: More references about `docker run` are available at [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will run the app, as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: As you can see, the IP address in the browser's URL bar is http://192.168.99.100\.
    It's our Docker host IP.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a container
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case the container doesn''t work for you, like in the following screenshot,
    use the following command to debug and find the reason:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command with the `-i -t -p` flags will show you all the logs in the Terminal/command
    line, like in the following screenshot (this is just an example in order to show
    you the ability to debug a Docker container locally):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Pushing a Docker container to a remote repository
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a container works for you locally, then it's almost ready for AWS deployment.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Before pushing the container, let''s add the `.env` file to`.dockerignore`,
    because you have in it all the sensitive data that you won''t put into containers.
    So, into the `.dockerignore` file, add the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After you add `.env` to `.gitignore`, we need to change the `server/index.js`
    file and add an additional `if` statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This `if` statement checks whether we're running the app locally (with an `.env`
    file) or remotely on an AWS instance (then we pass the `env` variables in a more
    secure manner).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have added the `.env` file into `.dockerignore` (and modified `server/index.js`),
    build the container that will be ready for the push:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Regarding the environment variables, we will add them via AWS advanced options.
    You will learn about this later, but to get a general idea of how to add them
    when running them on the localhost, check out the following example (fake data
    provided in the command''s flag):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Make sure that you have provided your correct `AWS_REGION_NAME`. Mine is `eu-central-1`,
    but yours can be different.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, everything from the `server/.env` file has been moved to the
    Docker run command in the Bash terminal:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can find here, the `-e` flag is for an `env` variable. The last thing
    is to push the container to the remote repository hosted by Docker Hub:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then you will be able to find in your Bash/command line something similar to
    the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'The link to the pushed repo will be similar to this one:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot has been made from the pushed Docker repository.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: A summary of useful Docker commands
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few useful Docker commands:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will list all the images, and `docker rm` can delete the repo
    from your local machine in case you want to delete it:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can use just the first three characters from `CONTAINER-ID`. You don't need
    to write down whole container ID. This is a convenience.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This one is used for stopping a running Docker container:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can use version tag of your containers with the following approach:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After you have listed the Docker images, you may notice that you have two containers,
    one with the tag `latest` and the other with `0.1`. This is a way to track changes,
    because if you push the container, the tag will also be listed on Docker Hub.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check your container''s local IP:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build your container from a Dockerfile:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建你的容器：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run your container in "detached" mode:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以“分离”模式运行你的容器：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run your container to debug it without detaching it so that you can find what
    is going on in the container''s Bash terminal:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的容器以调试它，而不将其分离，这样你就可以在容器的Bash终端中找到正在发生的事情：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Introduction to Docker on AWS EC2
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS EC2上的Docker简介
- en: Two chapters ago, we implemented Amazon AWS S3 for static image uploading. You
    should already have an AWS account, so you are ready for the following steps to
    create our deployment on AWS.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在两章之前，我们实现了亚马逊AWS S3用于静态图像上传。你应该已经有了AWS账户，因此你已准备好进行以下步骤以在AWS上创建我们的部署。
- en: In general, you can use the steps with free AWS tiers, but we will use the paid
    version in this tutorial. Read the AWS EC2 pricing before starting this section
    on how to deploy Docker containers on AWS.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以使用免费AWS层级的步骤，但在这个教程中，我们将使用付费版本。在开始本节关于如何在AWS上部署Docker容器的部分之前，请阅读AWS EC2定价。
- en: AWS also has great Docker container support with their service called **EC2
    Container Service** (**ECS**).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: AWS还通过其名为**EC2容器服务**（**ECS**）的服务提供了对Docker容器的强大支持。
- en: If you bought this book, it probably means you haven't been using AWS so far.
    Because of this, we will first deploy Docker manually on EC2 in order to show
    you how the EC2 instances work so that you can get more knowledge from the book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你购买了这本书，这可能意味着你之前还没有使用过AWS。因此，我们将首先在EC2上手动部署Docker，以便向你展示EC2实例的工作原理，这样你就可以从这本书中获得更多知识。
- en: Our main goal is to make the deployment of our Docker containers automatic,
    but for now, we will start with a manual approach. If you have already used EC2,
    you can skip the next subsection and go straight to ECS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是使我们的Docker容器部署自动化，但现在是手动方法。如果你已经使用过EC2，你可以跳过下一个子节，直接进入ECS。
- en: Manual approach - Docker on EC2
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动方法 - EC2上的Docker
- en: 'We were running our Docker container locally with the following command (a
    few pages previously):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前（几页之前）使用以下命令在本地运行我们的Docker容器：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will do the same thing, not locally but on the EC2 instance, 100% manually
    for now; later, we will do it 100% automatically with AWS ECS.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做同样的事情，但不是在本地，而是在EC2实例上，现在100%手动；稍后，我们将使用AWS ECS 100%自动完成。
- en: Before we continue, let's understand what EC2 is. It's a scalable computing
    capacity located in the Amazon Web Services cloud. In EC2, you don't need to invest
    money upfront in buying any hardware. Everything you pay is for the time spent
    using an EC2 instance. This allows you to deploy applications faster. Very quickly,
    you can add new virtual servers (when there is a bigger web traffic demand). There
    are some mechanisms to scale the number of EC2 instances automatically with the
    use of **AWS CloudWatch**. Amazon EC2 gives you the ability to scale up or down
    to handle changed requirements (such as spikes in popularity)--this feature reduces
    your need to forecast traffic (and saves you time and money).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们了解什么是EC2。它位于亚马逊网络服务云中的可扩展计算能力。在EC2中，你不需要预先投资购买任何硬件。你所支付的一切都是为了使用EC2实例所花费的时间。这允许你更快地部署应用程序。非常快，你就可以添加新的虚拟服务器（当有更大的网络流量需求时）。有一些机制可以自动使用**AWS
    CloudWatch**来扩展EC2实例的数量。亚马逊EC2让你能够根据变化的需求（如流行度的激增）进行扩展或缩减，这个功能减少了你需要预测流量的需求（并为你节省时间和金钱）。
- en: For now, we will use only one EC2 instance (later in the book, we will see more
    EC2 instances with load balancers and ECS).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只将使用一个EC2实例（在本书的后面部分，我们将看到带有负载均衡器和ECS的更多EC2实例）。
- en: Basics - launching an EC2 instance
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础 - 启动EC2实例
- en: We will launch an EC2 instance, then log in to it via SSH (you can use **Putty**
    on Windows OS).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个EC2实例，然后通过SSH登录到它（在Windows操作系统上，你可以使用**PuTTY**）。
- en: 'Log in to AWS Console by visiting this link: [https://eu-central-1.console.aws.amazon.com/console/home](https://eu-central-1.console.aws.amazon.com/console/home).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问此链接登录AWS控制台：[https://eu-central-1.console.aws.amazon.com/console/home](https://eu-central-1.console.aws.amazon.com/console/home)。
- en: 'Click on the EC2 link: [https://eu-central-1.console.aws.amazon.com/ec2/v2/home](https://eu-central-1.console.aws.amazon.com/ec2/v2/home)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 点击EC2链接：[https://eu-central-1.console.aws.amazon.com/ec2/v2/home](https://eu-central-1.console.aws.amazon.com/ec2/v2/home)
- en: 'Then click on the blue Launch Instance button:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击蓝色的“启动实例”按钮：
- en: '![](img/00106.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00106.jpeg)'
- en: 'The button looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮看起来是这样的：
- en: '![](img/00107.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00107.jpeg)'
- en: 'After you click on the button, you will be redirected to the **Amazon Machine
    Image** (**AMI**) page:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，你将被重定向到**亚马逊机器镜像**（**AMI**）页面：
- en: '![](img/00108.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00108.jpeg)'
- en: 'The AMI has a list of images that you can run an EC2 instance with. Each image
    has a list of preinstalled software. For example, the most standard image is the
    following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: It has preinstalled software; for example, the Amazon Linux AMI is an EBS-backed,
    AWS-supported image. The default image includes AWS command-line tools, Python,
    Ruby, Perl, and Java. The repositories include Docker, PHP, MySQL, PostgreSQL,
    and other packages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'On the same page, you can also find other AMIs to buy on the marketplace or
    created and shared by the community for free. You can also filter the images so
    that it will list only the free tier:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: For the sake of making this step-by-step guide simple, let's choose the image
    that is in the preceding screenshot; its name will be similar to `Amazon Linux
    AMI 2016.03.3 (HVM), SSD Volume Type`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The name of the image may slightly vary; don't worry about it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the blue Select button. Then you will be transferred to the Step 2:
    Choose an Instance Type page, as shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'From this page, select the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on this button:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'The simplest method is to choose the default options:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Review.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure security group (we will make some changes in this tab).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag instance (keep the options default).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add storage (keep the options default).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the instance (keep the options default).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an instance type.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an AMI.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, keep clicking on the next button until we get to the Configure security.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An indicator of progress you can find at the top is this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Our goal for now is to get to the security configuration page because we need
    to customize slightly the allowed ports. A security group consists of rules that
    control network traffic for an EC2 instance (a.k.a. firewall options). For security,
    set the name to `ssh-and-http-security-group`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: As you can find here, you also need to click on the Add Rule button and add
    a new one called HTTP. This will allow our new EC2 instance to be available via
    port 80 for all the IPs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have added the name and HTTP port 80 as the new rule, you can click
    on the Review and Launch button:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Then, after you are happy with reviewing the instance, click on the blue button
    called Launch in that view:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: 'After you click on the Launch button, you will see a modal that says Select
    an existing key pair or create a new key pair:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: 'Usually, you''ll need to create a new key pair. Give it the name `pubapp-ec2-key-pair`
    and then click on the Download button, as shown in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'After you have downloaded `pubapp-ec2-key-pai`, you will be able to click on
    the blue Launch button. Next, you will see the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'From this screen, you can go directly to the EC2 launch logs (click on the
    View launch log link) so that you will be able to find your instance listed, as
    seen in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Great. Your first EC2 has been launched successfully! We need to log in to it
    and set up the Docker container from there.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Save the public IP of your EC2 instance. In the preceding launch log, you can
    find that the machine we've just created has the public IP 52.29.107.244.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Your IP will be different (of course, this is just an example). Save it somewhere;
    we will use it in a moment as you'll need it to log in via SSH to the server and
    install the Docker app.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: SSH access via PuTTy - Windows users only
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't work on Windows, you can skip this subsection.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using PuTTy, which is available for download at [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)
    (`putty.exe`, `pageant.exe`, and `puttygen.exe`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Download key pairs for the EC2 instance, and convert them to `ppk` using `puttygen.exe`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Click on the Load button and choose the `pubapp-ec2-key-pair.pem` file, and
    then covert it to `ppk`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you need to click on the Save private key button. You are done; you can
    close `puttygen.exe` and open `pageant.exe`. From it, do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Choose Add Key
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then check whether your key has been added correctly to the Pageant key list
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your private key is on the list, you are ready to use `putty.exe`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: If you have opened the PuTTy program, you need to log in via SSH by typing your
    EC2 instance IP and clicking on the Open button, as shown in the preceding screenshot.
    PuTTy allows using SSH connections on Windows.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an EC2 instance via SSH
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a previous chapter, after we launched the EC2 instance, we found out our
    public IP (remember that your public IP will be different): `52.29.107.244`. We
    need to connect to the remote EC2 instance with this public IP.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve saved `pubapp-ec2-key-pair.pem` in my `Downloads` directory, so go to
    the directory where you have downloaded your `.pem` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In PuTTy on Windows, it will look similar after this step. You need to provide
    in the PuTTy box the IP and ports in order to correctly log in to the machine.
    When you get a prompt to type a username, use `ec2-user`, as in the SSH example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful login, you will be able to see this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'The following instructions are for all OS users (OS X, Linux, and Windows)
    as we are logged in to the EC2 instance via SSH. The following commands are required
    next:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These commands will update the `yum` package manager and install and start
    the Docker service in the background:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After you run the `docker info` command, it will show something similar to
    the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the preceding screenshot, you''ll see that everything is all
    right, and we can continue with running the publishing app''s Docker container
    with the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Make sure you have provided your correct `AWS_REGION_NAME`. Mine is `eu-central-1`,
    but yours could be different.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, everything from the `server/.env` file has been moved to the
    `docker run` command in the Bash terminal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Also make sure to rename `AWS_BUCKET_NAME`, `AWS_REGION_NAME`, or `MONGO_ENV`
    if you have a different one (if you set it differently than what was suggested
    in the previous chapters).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in order to check whether everything went well, you can also use the
    following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This command will show you whether the Docker process runs correctly in the
    background as a detached container. And after 10-30 seconds, when `npm start`
    will run the whole project, you can test with this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the application has been bootstraped correctly, you can see output similar
    to the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'After you visit the EC2 instance''s public IP (in our example, it is `52.29.107.244`),
    you will be able to find our publishing app available online as we have set up
    the security group of our EC2 instance with the exposed port `80` to the world.
    The following is the screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: If you see our publishing app under a public IP, then you have just deployed
    a Docker container on Amazon AWS EC2 successfully!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The process we just went through is very inefficient and manual, but shows exactly
    what is going on under the hood when we start using ECS.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'We are missing the following in our current approach:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Integration with other Amazon services, such as load balancing, monitoring,
    alerting, crash recovery, and route 53.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation, as currently we are unable to efficiently deploy 10 Docker containers
    quickly. This is also important if you want to deploy different Docker containers
    for different services as, for example, you can have separate containers for serving
    the frontend, backend, and even the database (in our case, we use mLab, so we
    don't need one here).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You've just learned the basics of Amazon Web Services.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Basics of ECS - AWS EC2
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The EC2 Container Service helps you create a cluster of Docker Container instances
    (many copies of the same container on several EC2 instances). Each container is
    deployed automatically--this means you don't need to log in to any of the EC2
    instances via SSH as we did it in the previous chapter (manual approach). The
    whole job is done by the AWS and Docker software, which you will learn to use
    in the future (a more automated approach).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: For example, you set that you want to have five different EC2 instances--the
    group of EC2 instances in the exposed port 80 so you are able to find the publishing
    application under the `http://[[EC2_PUBLIC_IP]]` address. Additionally, we are
    adding a load balancer between all the EC2 instances and the rest of the world
    so that in case there is any spike in traffic or any of the EC2 instances break,
    the load balancer will replace the broken EC2 instance with a new one or scale
    down/up the number of EC2 instances based on the traffic.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: A great feature of the AWS load balancer is that it pings each EC2 instance
    with port 80, and if the pinged instance doesn't respond with the correct code
    (200), then it terminates the broken instance and turns on a fresh new instance
    with the Docker Container that has the image of our publishing app. This helps
    us maintain continuous availability of our application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will use Amazon Route 53 in order to have a highly available
    and scalable cloud **domain name system** (**DNS**) web service so we will be
    able to set up a top level domain; in our case, I will use a domain I have bought
    specially for the book: `http://reactjs.space`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: That will be our HTTP address, of course. If you build a different service,
    you need to buy your own domain in order to follow the instructions and learn
    how Amazon Route 53 works.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Working with ECS
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start working on ECS, let''s understand some basic nomenclature:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Cluster**: This is the main part of our process that will pool underlying
    resources as EC2 instances and any attached storage. It clusters many EC2 instances
    into one containerized application that aims to be scalable.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task definition**: This task determines what Docker Containers you are going
    to run on each EC2 instance (that is, the `docker run` command) and it also helps
    you define more advanced options, such as environment variables that you want
    to pass down into a container.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: This is a kind of glue between the cluster and a task definition.
    The service handles the login of a running task on our cluster. This also contains
    the management of revisions of the task (combination of a container and its settings)
    you want to run. Every time you change any setting in your task, it creates a
    new revision of your task. In the service, you specify what the task is and its
    revision that you want to run on your EC2 instances in your ECS.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visit the AWS Console and find the ECS. Click on the link to go to the EC2
    Container Service Console. There, you will find a blue button named Get started:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'After that, you will see an ECS wizard with the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Create a task definition.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure service.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure cluster.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 1 - creating a task definition
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ECS, a task definition is a recipe for a container. It's something that helps
    an ECS understand what Docker Container you want to run on the EC2 instances.
    It's a recipe or a blueprint of steps that the ECS has automatically done in order
    to successfully deploy our publishing app's container.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'The details for this step are shown in the following screenshot:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can find that our task definition name is `pubapp-task`.
    The container name is `pubapp-container`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: For Image, we use the same argument as when we were running a container locally
    with `docker run`. In the case of `przeor/pub-app-docker`, ECS will know that
    it has to download the container from [https://hub.docker.com/r/przeor/pub-app-docker/](https://hub.docker.com/r/przeor/pub-app-docker/).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's keep the maximum memory at the default value (`300`). Set both
    port mappings to `80`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, there are some problems if your container
    doesn't expose port `80`. It's probably a bug with the ECS wizard; without the
    wizard, any port can be used on the container.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Advanced options in the task definition view:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
- en: 'You will see a slide panel with additional options:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: 'We need to specify the following things:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Command**: This has to be separated with commas, so we use `npm,start`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working directory**: We use `/opt/publishing-app` (identical path is set
    in the Dockerfile).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Env variables**: Here, we specify all values from the `server/.env` file.
    This part is important to set up; the app will not work correctly without the
    correct details provided via the environment variables.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rest of the values/inputs**: Keep them at the default without changes.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's very important to add all the environment variables. We need to be very
    careful as it's easy to make a mistake here that will break the app inside an
    EC2 instance.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: After all these changes, you can click on the Next button.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - configuring the service
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, a service is a mechanism that keeps a certain amount of EC2 instances
    running while checking their health at the same time (using the **Elastic Load
    Balancing** (**ELB**)).  ELB automatically distributes incoming application traffic
    across multiple Amazon EC2 instances. If a server doesn't respond on port 80 (the
    default but can be changed to more advanced health checks), then the service runs
    a new service while the unhealthy one is being shut down. This helps you maintain
    very high availability for your application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: The service name is `pubapp-service`. In this book, we will set up three different
    EC2 instances (you can set up fewer or more; it's up to you), so this is the number
    for the *desired number of tasks* input.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same step, we also have to set up the **Elastic Load Balancer** (**ELB**):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: 'Container name:host port: Choose from the drop-down list `pubapp-container:80`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELB listener protocol*: HTTP'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELB listener port*: `80`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ELB health check: Keep default; you can change it while you are out of the
    wizard (on the specific ELB''s page)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Service IAM role: The wizard will create this for us'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After all this, you can click on the Next step button to continue:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: Step 3 - configuring the cluster
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you'll set up the details of the ECS container agent, called a cluster.
    Here, you specify the name of your cluster, what kind of instances you'd like
    to use, the number of instances (it has to be bigger than the number required
    by the service), and the key pair.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'Cluster name: Our cluster name is `pubapp-ecs-cluster`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EC2 instance type: `t2.micro` (in production, use a bigger one).'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number of instances: Five, and that means the service will keep three instances
    alive and another two instances will be on the bench, waiting for any fatal situations.
    By bench, I mean that at a time (with our setup), we''ll use only three instances,
    whereas another two are ready for use, but not actively used (traffic is not redirected
    to them).'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Key pair: I specified the key pair called `pubapp-ec2-key-pair` earlier in
    this chapter. Always keep them in a safe place for later use.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the same page, you will also find the security group and container instance
    IAM roles setup, but we''ll keep it at the default for now:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00136.jpeg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Step 4 - reviewing
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing is to review whether everything looks good:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: 'Then, choose Launch instances & run service:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: Launch status
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have clicked on the Launch button, you will find a page with the
    status. Keep it open until you get all the boxes green with success indicators:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what it looks like all up and running:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00140.jpeg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: 'After all the boxes have a success indicator, then you will be able to click
    on the View service button that is at the top:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: Click on that button (View service) after it becomes available.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Finding your load balancer address
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you click on the View service button, you will see the main dashboard,
    where all your clusters are listed (currently there will only be one):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: 'Click on pubapp-ecs-cluster and you will see the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00143.jpeg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: 'On the preceding screen, click on pubapp-service from the list:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00144.jpeg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will see the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: 'From this page, choose the Elastic Balancer:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: 'The final view of ELB is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding view, you will find (under the Description Name tab) an elastic
    balancer address like this one:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you try to open the address and it doesn't work, then give it more time.
    The EC2 instances may be in progress in terms of running our Docker publishing
    app container. We must be patient during the initial run of our ECS cluster.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the address of your ELB, which you can put into the browser and see
    the publishing app:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: AWS Route 53
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last step left in this chapter is to set up Route 53, which is a highly
    available and scalable cloud DNS web service.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'For this step, you have two options:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Having your own domain already registered
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a new domain via Route 53
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following procedure, we will use the first option, so we assume that
    we have already registered the `reactjs.space` domain (of course, you need to
    have your own domain in order to successfully follow these steps).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: We will route end users to the publishing app by translating the name `http://reactjs.space`
    into the address of our ELB (`EC2Contai-EcsElast-1E4Y3WOGMV6S4-39378274.eu-central-1.elb.amazonaws.com`)
    so that users will be able to visit our application in a more user-friendly manner
    by typing `reactjs.space` into the browser's address bar.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose Route 53 from the AWS services list:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: 'You will be able to see a main page like the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to create a hosted zone on Route 53, so click on the blue
    button called Create Hosted Zone:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: 'After this, you won''t see any hosted zones, so click again on the blue button:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: 'The form will have a Domain Name field, where you put your domain name (in
    our case, it''s `reactjs.space`):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
- en: 'Success! Now you will be able to see your DNS names:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to park the DNSes on your domain''s provider. The last step
    is to change DNS settings at your domain registrar; in my case, they''re as follows
    (yours will be different):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice the `.` (dots) at the end; you can get rid of them so the final DNSes
    that we have to change are as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After all these steps, you can visit the `http://reactjs.space` website (the
    DNS change may take up to 48 hours).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing is to create an alias of the `reactjs.space` domain that points
    to our Elastic Load Balancer. Click the following button:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
- en: 'Then, you''ll have the following view:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: 'Choose Yes from the alias''s radio button and then select the ELB from the
    list, as shown in the following example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
- en: Currently, everything will be working after the DNS changes are finished (which
    may take up to 48 hours). To improve the experience with our application, let's
    also make an alias from `www.reactjs.space` to `reactjs.space`, so if anyone types
    `www.` before the domain name, it will work as intended.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Click again on the button called Create Record Set, choose an alias, and type
    `www`., after which you will be able to choose the `www.reactjs.space` domain.
    Do so and hit the Create button:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are done with all the AWS/Docker setup. After a successful DNS change, you
    will be able to find our application under the `http://reactjs.space` address:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: The next chapter will talk about the basics of continuous integration and also
    help you wrap up the remaining things in the app before it is 100% production
    ready (minification is missing so far).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue in the next chapter with a more detailed description of the remaining
    topics that are going to be covered in the book.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
