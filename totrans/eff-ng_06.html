<html><head></head><body>
<div id="_idContainer027">
<h1 class="chapter-number" id="_idParaDest-98"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-99"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.2.1">Applying Code Conventions and Design Patterns in Angular</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will explore code conventions, best practices, and design patterns commonly used within Angular applications. </span><span class="koboSpan" id="kobo.3.2">You will also create a generic HTTP service and mock API responses using an </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">HTTP interceptor.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Following good code conventions allows you to write code consistently. </span><span class="koboSpan" id="kobo.5.2">Whether you write your code solo or in a team, conventions ensure that you use similar syntax for common occurrences and follow best practices. </span><span class="koboSpan" id="kobo.5.3">Using good design patterns helps you to write code implementations that scale well and </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">are battle-tested.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Code conventions and best practices focus more on processes and style-related aspects such as using the CLI, naming, using types, or preventing nested observables. </span><span class="koboSpan" id="kobo.7.2">Design patterns, on the other hand, focus on how you set up, handle, and implement common occurrences, problems, and flows within your </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of this chapter, you will know all about code conventions, best practices, and commonly used design patterns within Angular applications. </span><span class="koboSpan" id="kobo.9.2">Some patterns and principles you will learn about in this chapter are inheritance, facade services, observables, reactive programming, and anti-patterns. </span><span class="koboSpan" id="kobo.9.3">This chapter will provide a good foundation for the following chapters, where we dive deep into reactive programming and state management. </span><span class="koboSpan" id="kobo.9.4">The chapter will help you understand the benefits of good design patterns and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">code conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This chapter will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Exploring commonly used code conventions and best practices in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Angular applications</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Exploring commonly used design patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Angular applications</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Building a generic HTTP service containing a </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">model adapter</span></span></li>
</ul>
<h1 id="_idParaDest-100"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.19.1">Exploring commonly used code conventions and best practices in Angular applications</span></h1>
<p><span class="koboSpan" id="kobo.20.1">In this chapter’s </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.21.1">first section, you will learn about </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">code conventions</span></strong><span class="koboSpan" id="kobo.23.1"> and best practices within Angular applications. </span><span class="koboSpan" id="kobo.23.2">Using code conventions ensures that everyone working on your project uses similar naming for variables, files, and folders. </span><span class="koboSpan" id="kobo.23.3">Good code conventions also make code more readable and allow you to recognize certain features, implementations, or data types quickly. </span><span class="koboSpan" id="kobo.23.4">In addition, code conventions make your code consistent and easier to debug, refactor, and understand. </span><span class="koboSpan" id="kobo.23.5">Setting up good code conventions for your project promotes the usage of best practices. </span><span class="koboSpan" id="kobo.23.6">Code conventions also make it easier for new developers to be onboarded into the code base, as they have a set of rules they can follow that allows them to write code in a similar way to the rest of the people working on the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Personally, I think it’s a good practice to create a document with all code conventions and best practices you adopt within your project. </span><span class="koboSpan" id="kobo.25.2">This way, new people have something to go off of besides what they see in the code. </span><span class="koboSpan" id="kobo.25.3">What code conventions your company adopts is entirely </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.26.1">up to the people writing and maintaining the code base. </span><span class="koboSpan" id="kobo.26.2">However, some commonly used conventions and best practices within the Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">community exist.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">For starters, Angular has a </span><em class="italic"><span class="koboSpan" id="kobo.29.1">style guide</span></em><span class="koboSpan" id="kobo.30.1"> in which it declares everything it considers a good practice and why. </span><span class="koboSpan" id="kobo.30.2">You can find the style guide on the official Angular website </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">at </span></span><a href="https://angular.io/guide/styleguide"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://angular.io/guide/styleguide</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Next, we learn about common conventions and best practices for Angular applications. </span><span class="koboSpan" id="kobo.34.2">We will start with naming and structural conventions and follow this up with </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">best practices.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.36.1">Naming conventions</span></h2>
<p><span class="koboSpan" id="kobo.37.1">Naming is </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.38.1">the main focus of conventions. </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Naming conventions</span></strong><span class="koboSpan" id="kobo.40.1"> are essential to ensuring maintainability and readability. </span><span class="koboSpan" id="kobo.40.2">Good naming conventions </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.41.1">allow you to navigate the code base easily and find content quickly. </span><span class="koboSpan" id="kobo.41.2">Naming conventions apply to several aspects of the code, so we will divide them up, starting with folders </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">and files.</span></span></p>
<h3><span class="koboSpan" id="kobo.43.1">Naming folders and files</span></h3>
<p><span class="koboSpan" id="kobo.44.1">File and folder names should clearly describe the intent of the folder or file. </span><span class="koboSpan" id="kobo.44.2">This way, you can quickly locate files and folders you need even when the project grows. </span><span class="koboSpan" id="kobo.44.3">For folders, you should use single words, but if you do use multiple words, you can separate them with a dash (</span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">-</span></strong><span class="koboSpan" id="kobo.46.1">). </span><span class="koboSpan" id="kobo.46.2">For file names, you can use the format </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">feature.type.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">The feature </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.51.1">describes what the file entails and the type refers to things such as components, services, directives, pipes, and so on (some examples include </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">expenses-list.component.ts</span></strong><span class="koboSpan" id="kobo.53.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">expenses.service.ts</span></strong><span class="koboSpan" id="kobo.55.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">unit.directive.ts</span></strong><span class="koboSpan" id="kobo.57.1">). </span><span class="koboSpan" id="kobo.57.2">Use conventional names for the file types (</span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">.component</span></strong><span class="koboSpan" id="kobo.59.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">.directive</span></strong><span class="koboSpan" id="kobo.61.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">.service</span></strong><span class="koboSpan" id="kobo.63.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">.pipe</span></strong><span class="koboSpan" id="kobo.65.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">.module</span></strong><span class="koboSpan" id="kobo.67.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">.directive</span></strong><span class="koboSpan" id="kobo.69.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">.store</span></strong><span class="koboSpan" id="kobo.71.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">.actions</span></strong><span class="koboSpan" id="kobo.73.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">.stories</span></strong><span class="koboSpan" id="kobo.75.1">). </span><span class="koboSpan" id="kobo.75.2">For unit tests, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">.spec</span></strong><span class="koboSpan" id="kobo.77.1"> for the type. </span><span class="koboSpan" id="kobo.77.2">Lastly, it’s wise to prevent duplicate folder or file names. </span><span class="koboSpan" id="kobo.77.3">As your monorepo grows, avoiding duplicate file or folder names might not always be possible, but try to prevent it for as long </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Besides naming conventions for files and folders, adhering to naming conventions within your code is vital. </span><span class="koboSpan" id="kobo.79.2">It would be best to keep naming consistent for your classes, properties, functions, selectors, and other aspects of your code. </span><span class="koboSpan" id="kobo.79.3">Having good naming conventions within your code helps you to quickly identify different parts of your code, improving readability and making refactoring and maintaining your </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">code easier.</span></span></p>
<h3><span class="koboSpan" id="kobo.81.1">Naming conventions within your code</span></h3>
<p><span class="koboSpan" id="kobo.82.1">Angular is predominantly a class-based framework, so let’s start by naming classes. </span><span class="koboSpan" id="kobo.82.2">All classes should </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.83.1">use upper camel case. </span><span class="koboSpan" id="kobo.83.2">Upper camel case is when you start every word with an uppercase letter. </span><span class="koboSpan" id="kobo.83.3">The class names should equal the file feature combined with the file type. </span><span class="koboSpan" id="kobo.83.4">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">expenses-list.component.ts</span></strong><span class="koboSpan" id="kobo.85.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">ExpensesListComponent</span></strong><span class="koboSpan" id="kobo.87.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">expenses.service.ts</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.89.1">becomes </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">ExpensesService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Another important part of Angular applications is the selectors of components, directives, and pipes. </span><span class="koboSpan" id="kobo.92.2">For components and directives, it’s a convention to prefix the selectors. </span><span class="koboSpan" id="kobo.92.3">Make the selector prefix unique so you can distinguish it from selectors from any third-party libraries you </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">might use.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Component selectors are all lowercase and words are separated with dashes. </span><span class="koboSpan" id="kobo.94.2">For directive selectors, you use regular camel case. </span><span class="koboSpan" id="kobo.94.3">With regular camel case, the first word is in lowercase and all subsequent words start with a capital letter. </span><span class="koboSpan" id="kobo.94.4">With selectors for pipes, you should use a single word in all lowercase without a prefix. </span><span class="koboSpan" id="kobo.94.5">For pipes, use regular camel case if you have to use multiple words for the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">pipe selector.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">There are also some common conventions when we look at the code within classes (or </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">function files):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.98.1">First, we use camel case to declare properties, functions, and methods. </span><span class="koboSpan" id="kobo.98.2">Using descriptive names for your properties, functions, and methods is also important. </span><span class="koboSpan" id="kobo.98.3">When you </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.99.1">handle events or component outputs with functions, you should prefixed these functions with </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">on</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">onClick</span></strong><span class="koboSpan" id="kobo.103.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">onAddExpense</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">onHover</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.108.1">
&lt;div (click)="</span><strong class="bold"><span class="koboSpan" id="kobo.109.1">onClick()</span></strong><span class="koboSpan" id="kobo.110.1">"&gt;&lt;/div&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.111.1">When declaring a component output, you don’t prefix it </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">on</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
@Output() </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">saved</span></strong><span class="koboSpan" id="kobo.117.1"> = new EventEmitter&lt;boolean&gt;();   </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">// Good</span></strong><span class="koboSpan" id="kobo.119.1">
@Output() </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">onSaved</span></strong><span class="koboSpan" id="kobo.121.1"> = new EventEmitter&lt;boolean&gt;(); </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">// Bad</span></strong></pre></li> <li><span class="koboSpan" id="kobo.123.1">Lastly, when you declare observable properties, you suffix them with a dollar </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">sign (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.127.1">
import { interval } from 'rxjs'
</span><strong class="bold"><span class="koboSpan" id="kobo.128.1">numbers$</span></strong><span class="koboSpan" id="kobo.129.1"> = interval(1000);</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.130.1">Now that you know about naming conventions for files and naming conventions for your code, let’s look at some conventions for structuring your files </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">and projects.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.132.1">Structural conventions</span></h2>
<p><span class="koboSpan" id="kobo.133.1">Besides naming conventions, you can have conventions for structuring your files and projects. </span><span class="koboSpan" id="kobo.133.2">Like </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.134.1">good naming, having a predictable and good structure </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.135.1">inside your files and projects helps with readability and maintainability. </span><span class="koboSpan" id="kobo.135.2">With a good file structure, you can easily recognize and find the parts of code that </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">you need.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">First, it’s a good convention to use the </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">rule of one</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">Each file should serve a single purpose. </span><span class="koboSpan" id="kobo.139.3">Having a single purpose for each file makes it easier to read and maintain them, and it keeps the files small. </span><span class="koboSpan" id="kobo.139.4">A single purpose for each file also makes it easy to locate bugs. </span><span class="koboSpan" id="kobo.139.5">It would be best if you also tried to limit files to a maximum of 400 lines. </span><span class="koboSpan" id="kobo.139.6">When a file exceeds 400 lines of code, it’s a good indicator that you might need to split it up and move some methods to a </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">separate file.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">You should watch the size of your file and also the size of your functions. </span><span class="koboSpan" id="kobo.141.2">Ideally, functions should not be more than 50 lines, and it’s best to keep them under 25 lines. </span><span class="koboSpan" id="kobo.141.3">Some exceptions might exist, but splitting them into separate functions when they grow larger is better. </span><span class="koboSpan" id="kobo.141.4">When functions grow too large, they become hard to read, test, </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">and debug.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">In Angular, you can write the template, CSS, and logic in a single file, but extracting the template and CSS into their own files is recommended. </span><span class="koboSpan" id="kobo.143.2">Using a separate file for the template and CSS promotes the rule of one, where each file has a single purpose, and it also helps with </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.144.1">readability and maintainability. </span><span class="koboSpan" id="kobo.144.2">If your template consists of one or two HTML tags without additional styling, you can make an exception and </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.145.1">place everything in a single file. </span><span class="koboSpan" id="kobo.145.2">However, I would still separate the template and component class. </span><span class="koboSpan" id="kobo.145.3">Besides separating your files into dedicated HTML, CSS, and TypeScript files, a good folder structure also helps with maintaining a clear overview, so let’s look at some conventions for our </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">folder structure.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Try to maintain a flat folder structure for as long as possible. </span><span class="koboSpan" id="kobo.147.2">Having a lot of nested folders makes it easier to find the folders and files you need and can make your overview of the folder and file structure clearer. </span><span class="koboSpan" id="kobo.147.3">Create a folder or, better yet, a library for each domain in your project. </span><span class="koboSpan" id="kobo.147.4">You should split your code inside these libraries into </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">data-access</span></strong><span class="koboSpan" id="kobo.149.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">features</span></strong><span class="koboSpan" id="kobo.151.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">UI</span></strong><span class="koboSpan" id="kobo.153.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">utils</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">Each element inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">data-access</span></strong><span class="koboSpan" id="kobo.157.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">features</span></strong><span class="koboSpan" id="kobo.159.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">UI</span></strong><span class="koboSpan" id="kobo.161.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">utils</span></strong><span class="koboSpan" id="kobo.163.1"> libraries should also be its </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">own library.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Using libraries promotes an API-driven architecture and ensures good separation of concerns. </span><span class="koboSpan" id="kobo.165.2">By having an API-driven architecture, you also start to write more reusable code. </span><span class="koboSpan" id="kobo.165.3">Inside each library, you have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">index.ts</span></strong><span class="koboSpan" id="kobo.167.1"> file to export what you need to </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">consume elsewhere.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Next, it’s </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.170.1">recommended to use the </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">DRY principle</span></strong><span class="koboSpan" id="kobo.172.1">. </span><span class="koboSpan" id="kobo.172.2">DRY stands for “Don’t repeat yourself.” </span><span class="koboSpan" id="kobo.172.3">When your mono repository grows larger, sometimes you can’t help repeating yourself, but in general, you should try to write code only once and share it where you </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">need it.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">Lastly, you need a way to order your code within your files. </span><span class="koboSpan" id="kobo.174.2">A common way to order your code is by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">following structure:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Input()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1"> decorators</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Output()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.181.1"> decorators</span></span></li>
<li><span class="koboSpan" id="kobo.182.1">Public properties and </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">private properties</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.184.1">Constructor</span></span></li>
<li><span class="koboSpan" id="kobo.185.1">Getters </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">and setters</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Lifecycle hooks</span></span></li>
<li><span class="koboSpan" id="kobo.188.1">Public methods and </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">private methods</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.190.1">Sort properties </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.191.1">and methods alphabetically (after dividing them into public and private properties and methods). </span><span class="koboSpan" id="kobo.191.2">Initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">@Input()</span></strong><span class="koboSpan" id="kobo.193.1"> directives whenever possible, and when using lifecycle hooks, implement the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">You can extend </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.196.1">the before-mentioned conventions to make your project more robust and uniform. </span><span class="koboSpan" id="kobo.196.2">The number of conventions you should come up with and try to use is unlimited, but for now, you have a good starting point and idea of what your conventions should look like and focus on. </span><span class="koboSpan" id="kobo.196.3">Next, we will discuss some best practices within </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">Angular applications.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.198.1">Using best practices in Angular applications</span></h2>
<p><span class="koboSpan" id="kobo.199.1">Using best practices ensures that you do things properly and your code stays robust, maintainable, </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">and scalable.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">The first best </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.202.1">practice is to use the Angular CLI (or the Nx CLI when using Nx) as much as possible. </span><span class="koboSpan" id="kobo.202.2">Using the CLI to generate components, services, directives, projects, libraries, and other elements ensures consistency. </span><span class="koboSpan" id="kobo.202.3">When using the Nx CLI, you’re also assured that all dependencies and settings are </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">configured properly.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">Use the new standalone components, directives, and pipes as much as possible. </span><span class="koboSpan" id="kobo.204.2">Using the new standalone API helps better isolate your logic, making debugging and testing your components, pipes, and directives easier. </span><span class="koboSpan" id="kobo.204.3">Using the standalone API also helps to reduce your bundle sizes, resulting in faster load times. </span><span class="koboSpan" id="kobo.204.4">You should also use the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">inject</span></strong><span class="koboSpan" id="kobo.206.1"> function over constructor injection for dependency injection. </span><span class="koboSpan" id="kobo.206.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">inject</span></strong><span class="koboSpan" id="kobo.208.1"> function provides more flexibility and is no hindrance when you </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">use inheritance.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Always use </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.211.1">access modifiers on your properties and methods. </span><span class="koboSpan" id="kobo.211.2">In Angular, we have three access modifiers: </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">public</span></strong><span class="koboSpan" id="kobo.213.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">private</span></strong><span class="koboSpan" id="kobo.215.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">protected</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">Using the correct access modifiers makes it easy to identify what can be used where and helps to prevent bugs and </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">unintended behavior.</span></span></p>
<h3><span class="koboSpan" id="kobo.219.1">Performance-related best practices</span></h3>
<p><span class="koboSpan" id="kobo.220.1">There are a bunch of best practices related to performance. </span><span class="koboSpan" id="kobo.220.2">First, always use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">trackBy</span></strong><span class="koboSpan" id="kobo.222.1"> function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">*ngFor</span></strong><span class="koboSpan" id="kobo.224.1"> directive. </span><span class="koboSpan" id="kobo.224.2">When you use the new control flow syntax </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.225.1">introduced in Angular 17, you are required to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">track</span></strong><span class="koboSpan" id="kobo.227.1"> function. </span><span class="koboSpan" id="kobo.227.2">Using the new control flow </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.228.1">syntax is recommended as it improves readability, and you don’t need to import the common module to use them, so it will reduce your bundle sizes </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">a bit.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Next, you should use </span><em class="italic"><span class="koboSpan" id="kobo.231.1">lazy loading</span></em><span class="koboSpan" id="kobo.232.1"> as much </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.233.1">as possible as this ensures that you only download what your user requests. </span><span class="koboSpan" id="kobo.233.2">With the new standalone components, you can easily lazy load every route, and with new defer blocks introduced in Angular 17, you can even lazy load different parts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">HTML templates.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">You should try to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">OnPush</span></strong><span class="koboSpan" id="kobo.237.1"> change detection strategy inside your components as much as possible. </span><span class="koboSpan" id="kobo.237.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">OnPush</span></strong><span class="koboSpan" id="kobo.239.1"> change detection reduces the number of times Angular renders your template. </span><span class="koboSpan" id="kobo.239.2">For even better change detection and performance, you should also utilize Angular signals as much as possible to manage the synchronous state in your application (we will discuss signals in detail in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.240.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.241.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">For asynchronous data flows, you should use </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">RxJS</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">Observables should be handled with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">async</span></strong><span class="koboSpan" id="kobo.246.1"> pipe as much as possible. </span><span class="koboSpan" id="kobo.246.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">async</span></strong><span class="koboSpan" id="kobo.248.1"> pipe unsubscribes automatically for you when the component is destroyed or the property is assigned with a new observable; this prevents memory leaks and improves the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Don’t use function calls or getters in your HTML templates. </span><span class="koboSpan" id="kobo.250.2">Calling functions or using getters </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.251.1">in the template negatively impacts the performance of your application. </span><span class="koboSpan" id="kobo.251.2">Use </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">CDK virtual scroll</span></strong><span class="koboSpan" id="kobo.253.1"> to display large lists. </span><span class="koboSpan" id="kobo.253.2">The CDK virtual scroll will only render the elements displayed inside the view instead of the entire list. </span><span class="koboSpan" id="kobo.253.3">Use pure pipes as much </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">as possible:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
&lt;cdk-virtual-scroll-viewport itemSize="50" class="example-viewport"&gt;
  &lt;div *cdkVirtualFor="let item of items" class="example-item"&gt;{{item}}&lt;/div&gt;
&lt;/cdk-virtual-scroll-viewport&gt;</span></pre> <p><span class="koboSpan" id="kobo.256.1">For example, when using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">ngOnChanges</span></strong><span class="koboSpan" id="kobo.258.1"> lifecycle to assign a property based on the newly </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.259.1">received input values, there is a big chance you can handle the same using a pipe. </span><span class="koboSpan" id="kobo.259.2">Using pure pipes is better for performance and promotes reusability. </span><span class="koboSpan" id="kobo.259.3">Don’t use </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">filter</span></strong><span class="koboSpan" id="kobo.261.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">forEach</span></strong><span class="koboSpan" id="kobo.263.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">reduce</span></strong><span class="koboSpan" id="kobo.265.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">map</span></strong><span class="koboSpan" id="kobo.267.1"> on arrays inside pipes, as this negatively affects </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">the performance.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Lastly, you should cache API requests for as long as feasible and do the same with resource-intensive </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">methods.</span></span></p>
<h3><span class="koboSpan" id="kobo.271.1">Preventing bugs with best practices</span></h3>
<p><span class="koboSpan" id="kobo.272.1">Besides performance-related best practices, there are some best practices to prevent bugs and </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.273.1">improve testability and maintainability. </span><span class="koboSpan" id="kobo.273.2">Avoid </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">any</span></strong><span class="koboSpan" id="kobo.275.1"> types in your code. </span><span class="koboSpan" id="kobo.275.2">Having everything strongly typed prevents bugs, improves suggestions, and makes debugging and </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">testing easier.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">When you have observables inside component classes that aren’t used within the template, use the RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">takeUntilDestroyed</span></strong><span class="koboSpan" id="kobo.279.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">takeUntil</span></strong><span class="koboSpan" id="kobo.281.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">take</span></strong><span class="koboSpan" id="kobo.283.1"> operators. </span><span class="koboSpan" id="kobo.283.2">These three operators ensure that your subscriptions on observables are </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">unsubscribed correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">Also, don’t use nested observables; instead, use RxJS operators such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">combineLatest</span></strong><span class="koboSpan" id="kobo.287.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">withLatestFrom</span></strong><span class="koboSpan" id="kobo.289.1"> to handle scenarios where you need nested observables. </span><span class="koboSpan" id="kobo.289.2">Nested observables can quickly lead to memory leaks and bugs that are difficult to debug. </span><span class="koboSpan" id="kobo.289.3">Nested observables are also hard to write </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">tests for.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Additionally, avoid using multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">ng-container</span></strong><span class="koboSpan" id="kobo.293.1"> elements with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">async</span></strong><span class="koboSpan" id="kobo.295.1"> pipe when you must await multiple observables before rendering a piece </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">of HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
&lt;ng-container </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">*ngIf="obs$ | async as observable"</span></strong><span class="koboSpan" id="kobo.301.1">&gt;
  &lt;ng-container </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">*ngIf=»obs2$ | async as observable2»</span></strong><span class="koboSpan" id="kobo.303.1">&gt;
  &lt;/ng-container&gt;
&lt;/ng-container&gt;</span></pre> <p><span class="koboSpan" id="kobo.304.1">Instead, map both observables into a single observable inside your component class and use the single observable in the template with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1"> pipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
observables$ = </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">combineLatest</span></strong><span class="koboSpan" id="kobo.309.1">({a: of(123), b: of(456)}).pipe(map(({a, b}) =&gt; ({obs: a, obs2: b})));</span></pre> <p><span class="koboSpan" id="kobo.310.1">Combining </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.311.1">the observables will prevent bugs, make your template more readable, and ensure everything is updated correctly when an observable receives </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">new values.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Now that you know some best practices that prevent bugs, let’s explore best practices regarding your setup </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">and architecture.</span></span></p>
<h3><span class="koboSpan" id="kobo.315.1">Best practices for your project setup and architecture</span></h3>
<p><span class="koboSpan" id="kobo.316.1">A good setup helps with better maintainability and standards throughout your codebase. </span><span class="koboSpan" id="kobo.316.2">We already discussed how to set up a project in </span><a href="B21625_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.317.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.318.1">, but to recap, use smart </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.319.1">and </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">dumb components.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.321.1">Smart components</span></em><span class="koboSpan" id="kobo.322.1"> connect with your state management and </span><em class="italic"><span class="koboSpan" id="kobo.323.1">dumb components</span></em><span class="koboSpan" id="kobo.324.1"> only receive data through inputs and output changes to the parents. </span><span class="koboSpan" id="kobo.324.2">This ensures you don’t have unintended dependencies and your component focuses on a single responsibility. </span><span class="koboSpan" id="kobo.324.3">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">export default</span></strong><span class="koboSpan" id="kobo.326.1"> on your components as much as possible to auto unwrap when lazy loading. </span><span class="koboSpan" id="kobo.326.2">Using default exports with automated unwraps keeps your routing files clean </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">and readable.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">canMatch</span></strong><span class="koboSpan" id="kobo.330.1"> route guard over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">canActivate</span></strong><span class="koboSpan" id="kobo.332.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">canLoad</span></strong><span class="koboSpan" id="kobo.334.1"> guards. </span><span class="koboSpan" id="kobo.334.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">canMatch</span></strong><span class="koboSpan" id="kobo.336.1"> guard will not download the code if the guard returns false. </span><span class="koboSpan" id="kobo.336.2">Lastly, you need to use lint rules to enforce your conventions and </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">best practices.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">You have learned about naming and structural conventions. </span><span class="koboSpan" id="kobo.338.2">You also learned about best practices you can use within your Angular applications. </span><span class="koboSpan" id="kobo.338.3">Going forward, I will mention other best practices as we go, but first, we will learn about common design patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">Angular applications.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.340.1">Exploring commonly used design patterns in Angular applications</span></h1>
<p><span class="koboSpan" id="kobo.341.1">Design patterns help solve common software development problems in a predefined approach. </span><span class="koboSpan" id="kobo.341.2">Design </span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.342.1">patterns are like blueprints </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.343.1">for building your application. </span><span class="koboSpan" id="kobo.343.2">Design patterns tell you how your code should behave and how to create a structure or separate parts of your code base. </span><span class="koboSpan" id="kobo.343.3">Using design patterns ensures that you have battle-tested solutions for common problems with a good level of abstraction so your code can scale without becoming a mess, entangled with dependencies all over the place, which is commonly referred to as “</span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">spaghetti code.”</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.345.1">Abstraction</span></strong><span class="koboSpan" id="kobo.346.1"> in software </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.347.1">development means you separate the details and behavior of your system from the implementation logic. </span><span class="koboSpan" id="kobo.347.2">For example, if you have a state management solution in your Angular application, you should separate the implementation of your state management from your component layer. </span><span class="koboSpan" id="kobo.347.3">By separating the component layer and state management solution, you can change your state management solution without touching your component layer. </span><span class="koboSpan" id="kobo.347.4">This provides extra flexibility and can save you some severe refactoring down the road as your application grows and its </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">needs change.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">To stay with the state management example, in the beginning, you might manage your state using a simple approach with RxJS </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Subject</span></strong><span class="koboSpan" id="kobo.351.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.353.1">, but when the application grows and your state becomes more complex, you might want to change it for something </span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.354.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">NgRx</span></strong><span class="koboSpan" id="kobo.356.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">NgXs</span></strong><span class="koboSpan" id="kobo.358.1"> as they offer a safer, more robust and flexible approach for handling complex </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">application state.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Suppose your </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.361.1">component layer is entangled with your state management. </span><span class="koboSpan" id="kobo.361.2">In that case, you have to refactor your entire application to switch the state management implementation. </span><span class="koboSpan" id="kobo.361.3">In contrast, if you have a good level of abstraction between the component layer and the state management solution, you can change the state management implementation without touching </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">your components.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">Design patterns are a good starting point for solving common problems in software development, but they are no holy grail or a one-size-fits-all solution. </span><span class="koboSpan" id="kobo.363.2">You should always consider what is useful for your application; don’t overdo it by using design patterns where none are needed. </span><span class="koboSpan" id="kobo.363.3">When it makes sense to follow design patterns to the letter, you can do so, but when it doesn’t, adapt the patterns to fit your </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">specific needs.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Now, without further ado, let’s explore some commonly used design patterns in </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">Angular applications.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.367.1">Creational design patterns in Angular</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.368.1">Creational design patterns</span></strong><span class="koboSpan" id="kobo.369.1"> form the foundation of how we create classes and objects </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.370.1">within our applications. </span><span class="koboSpan" id="kobo.370.2">Within Angular </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.371.1">applications, creational patterns are used by the framework for the creation of components, services, and other essential building blocks of the application. </span><span class="koboSpan" id="kobo.371.2">Developers can ensure modular, reusable, and maintainable code by implementing creational patterns, such as factory and </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">singleton patterns.</span></span></p>
<h3><span class="koboSpan" id="kobo.373.1">Singleton pattern</span></h3>
<p><span class="koboSpan" id="kobo.374.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">singleton pattern</span></strong><span class="koboSpan" id="kobo.376.1"> is used to create a single instance of an object or class. </span><span class="koboSpan" id="kobo.376.2">Using the singleton </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.377.1">pattern ensures that all code </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.378.1">interacting with the singleton uses the same instance. </span><span class="koboSpan" id="kobo.378.2">Another advantage of the singleton pattern is good memory usage, as you only have to allocate memory for the object or the class once. </span><span class="koboSpan" id="kobo.378.3">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.379.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.380.1">.1</span></em><span class="koboSpan" id="kobo.381.1">, you can see a visual representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">singleton pattern:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.383.1"><img alt="Figure 6.1: Singleton pattern" src="image/B21625_06_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.384.1">Figure 6.1: Singleton pattern</span></p>
<p><span class="koboSpan" id="kobo.385.1">As you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.387.1">.1</span></em><span class="koboSpan" id="kobo.388.1">, there is one single instance of a class used by different consumers. </span><span class="koboSpan" id="kobo.388.2">When you don’t use the singleton pattern, you have multiple instances of the global configuration class, where each consumer uses its own instance. </span><span class="koboSpan" id="kobo.388.3">Now that you know what the singleton pattern is, let’s explore how the pattern is commonly used in the context </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">of Angular.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Within the context of Angular, the singleton pattern is mostly used in combination with dependency injection. </span><span class="koboSpan" id="kobo.390.2">When you create a service or provide other dependencies in your Angular applications, it’s generally done as a singleton, meaning only one instance of the dependency is </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.391.1">created and shared by all consumers throughout the application. </span><span class="koboSpan" id="kobo.391.2">Because there is only one instance, you can safely use singleton services and classes </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.392.1">to manage the state within your Angular application or handle other logic where each consumer needs access to the same instance, such as configurations </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">and caching.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">To provide a dependency as a singleton, you must provide it within your application’s </span><em class="italic"><span class="koboSpan" id="kobo.395.1">root providers array</span></em><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">When working on an Angular application without modules, the root providers array is located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.398.1"> object you provide to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">bootstrapApplication</span></strong><span class="koboSpan" id="kobo.400.1"> method. </span><span class="koboSpan" id="kobo.400.2">If you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">ngModules</span></strong><span class="koboSpan" id="kobo.402.1"> in your Angular application, you make a dependency a singleton by providing it in the app module. </span><span class="koboSpan" id="kobo.402.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">providedIn</span></strong><span class="koboSpan" id="kobo.404.1"> root configuration object when it comes </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">to services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.406.1">
@Injectable({ providedIn: 'root'})
export class ExpensesService {}</span></pre> <p><span class="koboSpan" id="kobo.407.1">In general, you can really only create a single instance of objects utilizing the singleton pattern. </span><span class="koboSpan" id="kobo.407.2">In the case of Angular dependencies, a singleton is created within the context of the provider array where the dependency is provided. </span><span class="koboSpan" id="kobo.407.3">We already explained the providers array and creation of dependencies in more detail in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.408.1">Chapter 2</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">To further </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.411.1">clarify the singleton pattern, let’s look at some real-world examples of when the pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">is useful:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.413.1">Managing the logged-in user</span></strong><span class="koboSpan" id="kobo.414.1">: If you have a class to manage the logged-in user, you want there to be a single instance of that class so that there is a single source of truth. </span><span class="koboSpan" id="kobo.414.2">If there are multiple copies of the class, the user data, login state, and other properties could vary amongst the different instances of the class, resulting in </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">unintended behavior.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.416.1">State management</span></strong><span class="koboSpan" id="kobo.417.1">: When you have a class to manage the global application state, the singleton pattern is also a good fit. </span><span class="koboSpan" id="kobo.417.2">You want to ensure that everyone who needs </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.418.1">the global application state receives the same value and can update it in the same source. </span><span class="koboSpan" id="kobo.418.2">If there are many instances of the state class, these instances can hold different values, resulting in a corrupted state. </span><span class="koboSpan" id="kobo.418.3">Keeping different instances synchronized can be a hard task, so using a single source of truth makes sense and uses </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">less memory.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.420.1">Now that you know about the singleton pattern and when it’s used within the Angular application, let’s explore the </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">factory pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.422.1">Factory pattern</span></h3>
<p><span class="koboSpan" id="kobo.423.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">factory pattern</span></strong><span class="koboSpan" id="kobo.425.1"> serves as a versatile blueprint for object creation. </span><span class="koboSpan" id="kobo.425.2">The factory pattern is </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.426.1">beneficial in scenarios where the exact </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.427.1">type of object needed is determined at runtime, allowing for dynamic instantiation based on certain conditions or parameters. </span><span class="koboSpan" id="kobo.427.2">By encapsulating object creation, the factory pattern prevents tight coupling between client code and specific classes, promoting maintainability, scalability, and easier modifications. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.428.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.429.1">.2</span></em><span class="koboSpan" id="kobo.430.1"> shows a visual representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">factory pattern:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.432.1"><img alt="Figure 6.2: Factory pattern" src="image/B21625_06_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.433.1">Figure 6.2: Factory pattern</span></p>
<p><span class="koboSpan" id="kobo.434.1">As you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.435.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.436.1">.2</span></em><span class="koboSpan" id="kobo.437.1">, we send the factory some information (in the figure, it’s a list of product details) and the factory creates what we want it to create and returns the result. </span><span class="koboSpan" id="kobo.437.2">In the figure, the factory creates and returns a product to the component using the factory. </span><span class="koboSpan" id="kobo.437.3">Now that you have a better idea of what the factory pattern is, let’s see how it is commonly used in the context of an </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">Angular application.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Within the context of Angular, the factory pattern is also mainly used in combination with dependency injection. </span><span class="koboSpan" id="kobo.439.2">You can create a provider with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">useFactory</span></strong><span class="koboSpan" id="kobo.441.1"> property and provide a </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.442.1">factory method for creating the dependency value. </span><span class="koboSpan" id="kobo.442.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">useFactory</span></strong><span class="koboSpan" id="kobo.444.1"> property in a provider can be useful when you want to provide different classes </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.445.1">based on a condition or when you want to provide a value to the created class that is only accessible </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">upon runtime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
providers: [
  { provide: LoggerService, </span><strong class="bold"><span class="koboSpan" id="kobo.448.1">useFactory</span></strong><span class="koboSpan" id="kobo.449.1">: env.prod ? </span><span class="koboSpan" id="kobo.449.2">ProdLogger : DevLogger }
]</span></pre> <p><span class="koboSpan" id="kobo.450.1">Another place where you commonly use factory methods within Angular applications is in services. </span><span class="koboSpan" id="kobo.450.2">Oftentimes, services are used to create specific objects; this can be done with a factory method so you have a concise way to create </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the objects.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
createProduct(name: string, props: ProductProps): Product {
  return new Product(name, props);
}</span></pre> <p><span class="koboSpan" id="kobo.453.1">Now you know the factory pattern is used to create objects and classes in a predictable manner. </span><span class="koboSpan" id="kobo.453.2">Next, we will talk about the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">injection pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.455.1">Dependency injection pattern</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.456.1">Dependency injection</span></strong><span class="koboSpan" id="kobo.457.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.458.1">DI</span></strong><span class="koboSpan" id="kobo.459.1">) stands </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.460.1">at the </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.461.1">core of the Angular </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.462.1">framework. </span><span class="koboSpan" id="kobo.462.2">Strictly speaking, DI falls under the umbrella of the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">inversion of control</span></strong><span class="koboSpan" id="kobo.464.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.465.1">IoC</span></strong><span class="koboSpan" id="kobo.466.1">) principle. </span><span class="koboSpan" id="kobo.466.2">IoC essentially delegates control of certain aspects of a program to an external framework or container, allowing it to manage the flow and connections between components. </span><span class="koboSpan" id="kobo.466.3">But because DI is in charge of the creation and distribution of dependencies within your Angular application, we can place it under the category of creational </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">design patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">DI promotes modularity by decoupling components and services, making them more reusable across the application. </span><span class="koboSpan" id="kobo.468.2">By facilitating the management of dependencies, DI makes it easier to scale applications by adding or modifying functionality without needing to make significant </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">code changes.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">The Angular </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.471.1">DI system </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.472.1">helps identify and prevent circular dependencies, which can lead to runtime errors and hard-to-debug issues. </span><span class="koboSpan" id="kobo.472.2">Dependency injection also enforces type safety, reducing the risk of errors related to incorrect data types </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">being injected.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">We already discussed Angular DI in great detail in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.475.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.476.1">, so for now we will move on to structural </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">design patterns.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.478.1">Structural design patterns in Angular</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.479.1">Structural design patterns</span></strong><span class="koboSpan" id="kobo.480.1"> are fundamental in shaping the architecture of your Angular </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.481.1">applications. </span><span class="koboSpan" id="kobo.481.2">Structural design patterns help organize components, services, and modules, defining how they interact and collaborate </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.482.1">within your applications. </span><span class="koboSpan" id="kobo.482.2">Angular leverages these patterns to establish a clear structure, facilitating the development of scalable, modular, and </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">maintainable applications.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">For instance, patterns such as component-based architecture and module structure are inherent in Angular applications. </span><span class="koboSpan" id="kobo.484.2">The decorator pattern is also heavily used in Angular (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">@Component</span></strong><span class="koboSpan" id="kobo.486.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">@Injectable</span></strong><span class="koboSpan" id="kobo.488.1">). </span><span class="koboSpan" id="kobo.488.2">The facade pattern is often used in Angular applications to provide abstraction between the services and component layer of your </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Overall, using structural design patterns in Angular guides developers in creating well-organized, scalable, and adaptable applications by defining how components, services, and modules interconnect and collaborate within the </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">framework’s architecture.</span></span></p>
<h3><span class="koboSpan" id="kobo.492.1">Component-based architecture</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.493.1">Component-based architecture</span></strong><strong class="bold"><span class="koboSpan" id="kobo.494.1"> (CBA)</span></strong><span class="koboSpan" id="kobo.495.1"> is a design pattern where we build applications by composing individual, self-contained, and reusable components. </span><span class="koboSpan" id="kobo.495.2">It’s obvious </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.496.1">where CBA comes into play within Angular applications. </span><span class="koboSpan" id="kobo.496.2">When building components, it’s important </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.497.1">to keep them as self-contained and reusable as possible. </span><span class="koboSpan" id="kobo.497.2">Because we want to build reusable components, it’s important to use the smart/dumb principle within your </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">Angular components.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">We already talked about smart and dumb components in </span><a href="B21625_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.500.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.501.1"> and </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.502.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.503.1">, but to reiterate, smart components are mainly pages or large feature components and have a connection with your business logic and state management (or the </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">facade services).</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Dumb components are UI elements that are used to build up the smart components. </span><span class="koboSpan" id="kobo.505.2">Dumb components receive their data through inputs and notify other components of changes with outputs. </span><span class="koboSpan" id="kobo.505.3">Using this smart/dumb approach enforces good architecture and reusability of </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">your components.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">Now that we have briefly reiterated the CBA pattern, let’s move on and learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">decorator pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.509.1">Decorator pattern</span></h3>
<p><span class="koboSpan" id="kobo.510.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">decorator pattern</span></strong><span class="koboSpan" id="kobo.512.1"> is a structural design pattern that enables you to modify the behavior </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.513.1">of classes, functions, and properties </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.514.1">without altering the object itself. </span><span class="koboSpan" id="kobo.514.2">The most commonly used decorators within the Angular framework are </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">@Component</span></strong><span class="koboSpan" id="kobo.517.1">: This decorates a class as an Angular component, providing metadata for Angular’s compiler. </span><span class="koboSpan" id="kobo.517.2">It includes information about the component’s template, styles, and other configurations such as the standalone flag, imports, the component selector, and </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">directive decomposition.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">@Injectable</span></strong><span class="koboSpan" id="kobo.520.1">: This decorates a class as an injectable service, allowing it to be injected into other components or services through Angular’s </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">DI system.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">@NgModule</span></strong><span class="koboSpan" id="kobo.523.1">: This decorates a class as an Angular module, providing metadata that defines the module’s dependencies, components, directives, </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">services, etc.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">@Input</span></strong><span class="koboSpan" id="kobo.526.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">@Output</span></strong><span class="koboSpan" id="kobo.528.1">: These are decorators used in component properties to define inputs and outputs for communication </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">between components.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">@HostListener</span></strong><span class="koboSpan" id="kobo.531.1">: This decorates a class method to declare a DOM event listener. </span><span class="koboSpan" id="kobo.531.2">It’s used within directives to listen for events on the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">host element.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">@HostBinding</span></strong><span class="koboSpan" id="kobo.534.1">: This decorates a class property to bind it to a host element property within </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">a directive.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">@ViewChild</span></strong><span class="koboSpan" id="kobo.537.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">@ViewChildren</span></strong><span class="koboSpan" id="kobo.539.1">: These are decorators used to query and obtain references to child components or DOM elements within a parent component </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">or directive.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.541.1">You can </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.542.1">also create your own custom </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.543.1">decorators. </span><span class="koboSpan" id="kobo.543.2">We can, for example, make a custom decorator that will log when a function is called and include the provided function parameters in the log. </span><span class="koboSpan" id="kobo.543.3">To start, you need to set </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">experimentalDecorators</span></strong><span class="koboSpan" id="kobo.545.1"> to true inside </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">your </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">tsconfig.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.549.1">
{
  "compilerOptions": { "experimentalDecorators": true}
}</span></pre> <p><span class="koboSpan" id="kobo.550.1">In the case of Angular, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">experimentalDecorators</span></strong><span class="koboSpan" id="kobo.552.1"> property is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">true</span></strong><span class="koboSpan" id="kobo.554.1"> by default because Angular already uses decorators within the framework. </span><span class="koboSpan" id="kobo.554.2">To create a decorator, you have to create a function that takes three arguments: </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">target</span></strong><span class="koboSpan" id="kobo.556.1"> (class prototype), </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">propertyKey</span></strong><span class="koboSpan" id="kobo.558.1"> (name of the method), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">descriptor</span></strong><span class="koboSpan" id="kobo.560.1"> (property descriptor of the method). </span><span class="koboSpan" id="kobo.560.2">Within the decorator, you modify the behavior of the decorated method by wrapping its original logic inside a new function. </span><span class="koboSpan" id="kobo.560.3">This new function logs a message before invoking the </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">original method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
export function LogMethod(target: unknown, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function (...args: unknown[]) {
    console.log(`Method ${propertyKey} is called with args: ${JSON.stringify(args)}`);
    return originalMethod.apply(this, args);
  };
  return descriptor;
}</span></pre> <p><span class="koboSpan" id="kobo.563.1">Now, to use </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.564.1">the decorator, you simply add it above a method, </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">like this:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.566.1">@LogMethod</span></strong><span class="koboSpan" id="kobo.567.1">
test(a: number, b: number) {
  return a + b;
}</span></pre> <p><span class="koboSpan" id="kobo.568.1">If you now </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.569.1">call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">test</span></strong><span class="koboSpan" id="kobo.571.1"> method, the decorator makes sure it is logged, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">a</span></strong><span class="koboSpan" id="kobo.573.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">b</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1"> parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
this.test(1, 2);
Logs: Method test is called with args: [1,2]</span></pre> <p><span class="koboSpan" id="kobo.577.1">You can place the custom decorator in a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">custom-decorators</span></strong><span class="koboSpan" id="kobo.579.1"> library of type util in the shared domain. </span><span class="koboSpan" id="kobo.579.2">I created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">func-logger.decorator.ts</span></strong><span class="koboSpan" id="kobo.581.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">custom-decorators</span></strong><span class="koboSpan" id="kobo.583.1"> library and placed the logic of the decorator in </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">that file.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">You now know where Angular uses the decorator pattern and how you can use it yourself to extend or modify the behavior of objects, functions, and classes without modifying the objects themselves. </span><span class="koboSpan" id="kobo.585.2">Next, you will learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">facade pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.587.1">Facade pattern</span></h3>
<p><span class="koboSpan" id="kobo.588.1">We mentioned the </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">facade pattern</span></strong><span class="koboSpan" id="kobo.590.1"> a couple of times throughout this book. </span><span class="koboSpan" id="kobo.590.2">Now it’s time to explain </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.591.1">what the facade pattern is. </span><span class="koboSpan" id="kobo.591.2">The facade </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.592.1">pattern is a structural design pattern that provides a simplified interface to a larger, more complex system of classes, subsystems, or APIs. </span><span class="koboSpan" id="kobo.592.2">In the context of Angular applications, the facade pattern is commonly used to create a simple interface for and an abstraction layer between the component layers and your services where you implement your state management solution and business logic. </span><span class="koboSpan" id="kobo.592.3">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.593.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.594.1">.3</span></em><span class="koboSpan" id="kobo.595.1">, you’ll find a visual representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">facade pattern:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.597.1"><img alt="Figure 6.3: Facade pattern" src="image/B21625_06_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.598.1">Figure 6.3: Facade pattern</span></p>
<p><span class="koboSpan" id="kobo.599.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.600.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.601.1">.3</span></em><span class="koboSpan" id="kobo.602.1">, to get the data needed in the component, three different services need to be called. </span><span class="koboSpan" id="kobo.602.2">If you have to do this for all your components, you create a lot of dependencies and you need to create a lot of logic inside your components. </span><span class="koboSpan" id="kobo.602.3">Instead of directly calling the services from the components, we place a facade in between the components and services. </span><span class="koboSpan" id="kobo.602.4">The facade provides a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">get data</span></strong><span class="koboSpan" id="kobo.604.1"> method to retrieve the data we </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.605.1">need inside the components. </span><span class="koboSpan" id="kobo.605.2">Instead of having dependencies inside the components, the facade has all the dependencies to the services. </span><span class="koboSpan" id="kobo.605.3">By using </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.606.1">the façade, you can keep your components simple and clean without dependencies. </span><span class="koboSpan" id="kobo.606.2">Furthermore, you create a level of abstraction, and because of that, you can change the how you retrieve the data without changing the component layer; you simply change how the facade gets the data and the component still calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">get data</span></strong><span class="koboSpan" id="kobo.608.1"> method from the facade service. </span><span class="koboSpan" id="kobo.608.2">In most cases, you have your state management on the right side of the facade and your components on the left side of </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">the facade.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">In large applications and monorepos, the state management layer can become large and complex to handle. </span><span class="koboSpan" id="kobo.610.2">For something as simple as getting all expenses in a large monorepo of business tool applications, you can find yourself accessing multiple state files (commonly named stores) and selectors of these stores. </span><span class="koboSpan" id="kobo.610.3">Because the pieces of the state can live in different files or even different libraries, it’s not as easy as creating a function that combines the parts inside the state itself. </span><span class="koboSpan" id="kobo.610.4">You need another place, and that would be the facade service. </span><span class="koboSpan" id="kobo.610.5">The same goes for updating; in large systems, this can involve updating multiple stores and handling multiple callbacks </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">or effects.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">Let’s say you create an expenses facade. </span><span class="koboSpan" id="kobo.612.2">In this facade, you create methods that are simple to call and give you access to everything you need in your component layer. </span><span class="koboSpan" id="kobo.612.3">Think of things such as getting all expenses, getting filtered expenses, updating a single expense, or updating expenses in bulk. </span><span class="koboSpan" id="kobo.612.4">The facade helps keep things simple in your component layers and ensures that you only have to call a single function to get or do what you need to make your components work and update your </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">state accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">The facade </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.615.1">makes accessing and updating your </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.616.1">state easy and provides an extra level of abstraction, decoupling your state management implementation from your component layer. </span><span class="koboSpan" id="kobo.616.2">This abstraction layer allows you to change your state management solution without touching your component layer. </span><span class="koboSpan" id="kobo.616.3">You only have to change your state management and update the facade and your component layer will keep working as if </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">nothing changes.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">If you do not have the facade in between, you need to go into every component where you use the state and update them all independently, resulting in more work and a higher chance of you missing something. </span><span class="koboSpan" id="kobo.618.2">So, even if you have a simple state where you can access and update most things with a single method, adding a facade between your component layer and state management is </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">still wise.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">The following is a simple example of how a facade service </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">might look:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">
@Injectable({ providedIn: 'root' })
export class ExpenseFacadeService {
  protected readonly expenses: inject(ExpensesStore);
  protected readonly approvedExpenses: inject(ApprovedExpensesStore);
  getAllExpenses(): Expense[] {
    return [...this.expenses.getAll(), ...this.approvedExpenses.getAll()];
  }
  addExpense(expense: Expense): void {
    this.expenses.addExpense(new Expense(expense));
  }
  updateExpense(expense: Expense): void {
    if (expense.isApproved) {
      this.approvedExpenses.addExpense(expense);
    } else {
      this.expenses.addExpense(expense);
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.623.1">In the preceding example, we made a façade service that exposes two methods: one to get all expenses </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.624.1">and one to update expenses. </span><span class="koboSpan" id="kobo.624.2">If the implementation in the state management now changes, you only have to change it in the facade </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.625.1">instead of everywhere you get or update the expenses in your components. </span><span class="koboSpan" id="kobo.625.2">The preceding code is just an example; you don’t have to add this in the monorepo. </span><span class="koboSpan" id="kobo.625.3">In </span><a href="B21625_08.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.626.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.627.1">, we will create a facade in our monorepo. </span><span class="koboSpan" id="kobo.627.2">For now, you just need to know what the facade pattern is and why </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">it’s useful.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">Next, we will take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">inheritance pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.631.1">Model adapter pattern</span></h3>
<p><span class="koboSpan" id="kobo.632.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">model adapter pattern</span></strong><span class="koboSpan" id="kobo.634.1"> is an </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.635.1">implementation </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.636.1">of the adapter pattern. </span><span class="koboSpan" id="kobo.636.2">The model adapter pattern is commonly used to map objects received from the API to a representation of those models used within the frontend (not specifically into models used within the view layer). </span><span class="koboSpan" id="kobo.636.3">You might ask yourself, why is </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">this useful?</span></span></p>
<p><span class="koboSpan" id="kobo.638.1">Imagine you receive an object from the API with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">title</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.640.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
{
  title: "My Title",
  ……
}</span></pre> <p><span class="koboSpan" id="kobo.642.1">Let’s say </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.643.1">you use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">title</span></strong><span class="koboSpan" id="kobo.645.1"> property in 100 different places throughout </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.646.1">your application. </span><span class="koboSpan" id="kobo.646.2">If, for some reason, the backend has to change the property name from </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">title</span></strong><span class="koboSpan" id="kobo.648.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">subject</span></strong><span class="koboSpan" id="kobo.650.1">, you need to go to all 100 places within your application to change them from </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">title</span></strong><span class="koboSpan" id="kobo.652.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">subject</span></strong><span class="koboSpan" id="kobo.654.1">. </span><span class="koboSpan" id="kobo.654.2">If you have a model adapter, you can change them in one place and map the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">subject</span></strong><span class="koboSpan" id="kobo.656.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">title</span></strong><span class="koboSpan" id="kobo.658.1"> property of your </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">frontend model.</span></span></p>
<h3><span class="koboSpan" id="kobo.660.1">Inheritance pattern</span></h3>
<p><span class="koboSpan" id="kobo.661.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">inheritance pattern</span></strong><span class="koboSpan" id="kobo.663.1">, a foundational concept in object-oriented programming, establishes a </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.664.1">hierarchical relationship </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.665.1">between classes, enabling one class (the subclass or derived class) to inherit properties, methods, and behaviors from another class (the superclass or base class). </span><span class="koboSpan" id="kobo.665.2">In Angular applications, services and components can utilize inheritance to form hierarchical relationships and share generic functionalities and properties. </span><span class="koboSpan" id="kobo.665.3">The base class exposes the shared functionalities and properties with the </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">child class.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">Inheritance is a powerful and useful design pattern, but it should be used in moderation, especially within the component layer of your Angular applications. </span><span class="koboSpan" id="kobo.667.2">Excessive use of inheritance can create tight coupling between the base and child components. </span><span class="koboSpan" id="kobo.667.3">Changes in the base component might inadvertently impact multiple derived components, making the system fragile and harder to maintain. </span><span class="koboSpan" id="kobo.667.4">Deep hierarchies with multiple levels of inheritance can introduce complexity, making the codebase harder to understand and maintain. </span><span class="koboSpan" id="kobo.667.5">Over-engineering by creating overly complex inheritance structures might hinder rather than </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">aid development.</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">Also, in the context of the component layer, you can often create pipes and directives to share common functionalities. </span><span class="koboSpan" id="kobo.669.2">For example, you can have a base class where you add common logic for handling disabled states, handling some commonly used component stylings such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">primary</span></strong><span class="koboSpan" id="kobo.671.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">alert</span></strong><span class="koboSpan" id="kobo.673.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">danger</span></strong><span class="koboSpan" id="kobo.675.1">, and adding the option to change this styling when clicked </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">or double-clicked.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">This might seem like a valid solution, but you might only need one or two of the options in some scenarios. </span><span class="koboSpan" id="kobo.677.2">Some components might have different styling types but should not be able to change the styling type based on a click, and others should not be able to be disabled. </span><span class="koboSpan" id="kobo.677.3">It’s generally a bad practice to expose behavior to a component that does not apply to the component. </span><span class="koboSpan" id="kobo.677.4">So, in this scenario, it would be better to create three directives that handle disabling, styling, and styling change behaviors and apply them using </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">directive composition.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">So, inheritance </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.680.1">can be used to share common functionalities, but make sure it is the right solution for the problem so that you </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.681.1">don’t create base classes that expose a lot of functionalities and behaviors that most child classes will not use. </span><span class="koboSpan" id="kobo.681.2">One way I like to use the inheritance pattern is for creating a generic HTTP service. </span><span class="koboSpan" id="kobo.681.3">We will create a generic HTTP service with a model adapter in the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">Now that you have learned about the most used structural design patterns within Angular applications, we will start learning about common behavioral design patterns within </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">Angular applications.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.685.1">Behavioral design patterns in Angular</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.686.1">Behavioral design patterns</span></strong><span class="koboSpan" id="kobo.687.1"> focus on how objects and classes communicate and delegate </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.688.1">responsibilities to each other. </span><span class="koboSpan" id="kobo.688.2">Using </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.689.1">behavioral patterns ensures that your code remains flexible, modular, </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">and maintainable.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">The most common behavioral pattern within Angular applications is the observer pattern, but others, such as the interceptor, redux, and strategy patterns, are also commonly used. </span><span class="koboSpan" id="kobo.691.2">Let’s start with the most commonly used: the </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">observer pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.693.1">Observer pattern</span></h3>
<p><span class="koboSpan" id="kobo.694.1">If you have </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.695.1">ever used Angular, you know the </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.696.1">framework heavily relies on </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">observables</span></strong><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">The Angular framework integrated RxJS to manage observables and handle asynchronous data streams effectively and in a reactive manner. </span><span class="koboSpan" id="kobo.698.3">RxJS is a library focused on handling observable data streams. </span><span class="koboSpan" id="kobo.698.4">The </span><strong class="bold"><span class="koboSpan" id="kobo.699.1">observer pattern</span></strong><span class="koboSpan" id="kobo.700.1"> allows you to create one-to-many relationships so that when one object changes, all the dependent elements within your code are notified and </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">updated automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">Within the observer pattern, you have the </span><strong class="bold"><span class="koboSpan" id="kobo.703.1">observable</span></strong><span class="koboSpan" id="kobo.704.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.705.1">observers</span></strong><span class="koboSpan" id="kobo.706.1">, which are more commonly referred to as the subscribers. </span><span class="koboSpan" id="kobo.706.2">I like to explain the Observer pattern with a magazine </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">subscription analogy.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Let’s say there is a magazine that releases a new issue weekly. </span><span class="koboSpan" id="kobo.708.2">The magazine is the observable and the people subscribing to the magazine are the observers or subscribers. </span><span class="koboSpan" id="kobo.708.3">Each time the magazine releases a new issue, all subscribers are notified and receive the new issue </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.709.1">automatically in their mailboxes. </span><span class="koboSpan" id="kobo.709.2">The </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.710.1">subscribers to the magazine will receive the magazine for as long as they are subscribed, and when they unsubscribe, they will no longer receive </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">the magazine.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">The magazine can be subscribed to by all people who want to receive it. </span><span class="koboSpan" id="kobo.712.2">There is one magazine issue and many readers of the issue, hence the one-to-many relationship, as we have in the observer pattern. </span><span class="koboSpan" id="kobo.712.3">There are also observers and an observable, just as with the </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">observer pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">Observables come in two types, hot and cold observables, and within the context of Angular applications and RxJS, there are a couple of ways you can set up observables; we will dive deeper into observable types, RxJS, and handling observable streams in </span><a href="B21625_07.xhtml#_idTextAnchor129"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.715.1">Chapter 7</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.717.1">Interceptor pattern</span></h3>
<p><span class="koboSpan" id="kobo.718.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">interceptor pattern</span></strong><span class="koboSpan" id="kobo.720.1"> allows </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.721.1">you to intercept communications </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.722.1">and perform some logic on the data that is being transferred and either stop or continue the </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">intercepted communication.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Within the context of Angular applications, you commonly see the interceptor pattern in two </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">different places:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.726.1">Route guards</span></strong><span class="koboSpan" id="kobo.727.1"> intercept </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.728.1">route changes and </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.729.1">either allow or block the route change based on </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">some logic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.731.1">HTTP interceptors</span></strong><span class="koboSpan" id="kobo.732.1"> intercept </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.733.1">HTTP requests and </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.734.1">responses. </span><span class="koboSpan" id="kobo.734.2">The HTTP interceptor is commonly used to add authorization headers to HTTP requests and handle retry logic </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">or logging.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.736.1">We will create a route guard in </span><a href="B21625_09.xhtml#_idTextAnchor170"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.737.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.738.1">. </span><span class="koboSpan" id="kobo.738.2">For now, we will only create an </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">HTTP interceptor.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">Creating an HTTP interceptor </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.741.1">can be done through a class-based or functional </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.742.1">approach. </span><span class="koboSpan" id="kobo.742.2">We will use the functional approach, as this is the newer method and requires less </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">boilerplate code.</span></span></p>
<p><span class="koboSpan" id="kobo.744.1">To create an HTTP interceptor, you first need to make some adjustments to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.746.1"> object. </span><span class="koboSpan" id="kobo.746.2">Start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">provideHttpClient</span></strong><span class="koboSpan" id="kobo.748.1"> function inside your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">providers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1"> array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
providers: [</span><strong class="bold"><span class="koboSpan" id="kobo.752.1">provideHttpClient()</span></strong><span class="koboSpan" id="kobo.753.1">, …… ]</span></pre> <p><span class="koboSpan" id="kobo.754.1">Next, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">provideHttpClient</span></strong><span class="koboSpan" id="kobo.756.1"> function, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">withInterceptors</span></strong><span class="koboSpan" id="kobo.758.1"> function and provide it with </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">an array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
provideHttpClient(</span><strong class="bold"><span class="koboSpan" id="kobo.761.1">withInterceptors([])</span></strong><span class="koboSpan" id="kobo.762.1">)</span></pre> <p><span class="koboSpan" id="kobo.763.1">Inside the array, within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">withInterceptors</span></strong><span class="koboSpan" id="kobo.765.1"> function, you will register your HTTP interceptors. </span><span class="koboSpan" id="kobo.765.2">You create an interceptor by creating a function that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">HttpInterceptorFn</span></strong><span class="koboSpan" id="kobo.767.1"> interface. </span><span class="koboSpan" id="kobo.767.2">The function takes an </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.769.1"> and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">HttpHandlerFn</span></strong><span class="koboSpan" id="kobo.771.1"> as function parameters. </span><span class="koboSpan" id="kobo.771.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.773.1"> gives you access to the request and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">HttpHandlerFn</span></strong><span class="koboSpan" id="kobo.775.1"> is called to continue the request after you perform </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">your logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.777.1">
export const AuthInterceptor: HttpInterceptorFn = (
  req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn) =&gt;  next(req.clone({ setHeaders: { Authorization: 'auth_token' } }));</span></pre> <p><span class="koboSpan" id="kobo.778.1">The preceding code is just a simple example; we add a string as our authorization token. </span><span class="koboSpan" id="kobo.778.2">In reality, you should store your token in a safe place, such as in your environment variables, and retrieve it from there. </span><span class="koboSpan" id="kobo.778.3">You can also add more logic to the interceptor; this is just a simple example to illustrate how you create an interceptor. </span><span class="koboSpan" id="kobo.778.4">To activate the interceptor, you need to add it to the array of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">withInterceptors</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.780.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
provideHttpClient(withInterceptors([</span><strong class="bold"><span class="koboSpan" id="kobo.782.1">AuthInterceptor</span></strong><span class="koboSpan" id="kobo.783.1">]))</span></pre> <p><span class="koboSpan" id="kobo.784.1">Now the interceptor is active and an authorization header with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">auth_token</span></strong><span class="koboSpan" id="kobo.786.1"> will be added to all your HTTP requests. </span><span class="koboSpan" id="kobo.786.2">Now that you know what the interceptor pattern is and how you can create functional HTTP interceptors, let’s move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">Redux pattern.</span></span></p>
<h3><span class="koboSpan" id="kobo.788.1">Redux pattern</span></h3>
<p><span class="koboSpan" id="kobo.789.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">Redux pattern</span></strong><span class="koboSpan" id="kobo.791.1"> is another </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.792.1">commonly used design pattern within Angular applications. </span><span class="koboSpan" id="kobo.792.2">When you think about the Redux pattern, you might think of the Redux library, commonly used within the React framework, but the Redux pattern and the Redux </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.793.1">library are two different things. </span><span class="koboSpan" id="kobo.793.2">The Redux pattern is a design pattern implemented by multiple state management libraries. </span><span class="koboSpan" id="kobo.793.3">Within Angular, the Redux pattern is commonly implemented by using the </span><em class="italic"><span class="koboSpan" id="kobo.794.1">NgRx</span></em><span class="koboSpan" id="kobo.795.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.796.1">NgXs</span></em><span class="koboSpan" id="kobo.797.1"> state </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">management libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">The Redux pattern focuses on predictable state management where the entire application state is stored in a single immutable state tree. </span><span class="koboSpan" id="kobo.799.2">The core principles of Redux involve defining actions that describe state changes and reducers that specify how those actions modify the state. </span><span class="koboSpan" id="kobo.799.3">The Redux pattern enforces a unidirectional data flow, allowing data changes to flow in a single direction, from actions to reducers to updating the application state. </span><span class="koboSpan" id="kobo.799.4">Changes to the state are made with pure functions called reducers (pure functions are functions that have the same output given the same input without performing any side effects). </span><span class="koboSpan" id="kobo.799.5">Retrieving the state is done by using pure functions </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">named selectors.</span></span></p>
<p><span class="koboSpan" id="kobo.801.1">In Angular applications, we create reactive code using observable streams. </span><span class="koboSpan" id="kobo.801.2">Because Angular uses observable streams, the libraries implementing the Redux pattern for Angular combine it with RxJS so that we can use the Redux Pattern in a reactive manner. </span><span class="koboSpan" id="kobo.801.3">This means actions are dispatched asynchronously, and you can use RxJS pipe operators in combination with the selectors for </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">your state.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">The Redux pattern is a bit too complex to explain in a couple of paragraphs, so we will come back to this topic in </span><a href="B21625_08.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.804.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.805.1">. </span><span class="koboSpan" id="kobo.805.2">For now, you just need to know that the Redux pattern focuses on handling state in an immutable and unidirectional way and has four </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">key elements:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.807.1">Actions</span></strong><span class="koboSpan" id="kobo.808.1">: It describes </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.809.1">unique events to modify </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">the state.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.811.1">Reducers</span></strong><span class="koboSpan" id="kobo.812.1">: It has pure </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.813.1">function implementations to modify the state based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">described actions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.815.1">Selectors</span></strong><span class="koboSpan" id="kobo.816.1">: It has a </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.817.1">pure function to retrieve pieces of </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">the state.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.819.1">Store</span></strong><span class="koboSpan" id="kobo.820.1">: It has a </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.821.1">class defining </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">the state.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.823.1">You now know about creational, structural, and behavioral design patterns within Angular applications. </span><span class="koboSpan" id="kobo.823.2">You learned about patterns such as the singleton, factory, decorator, facade, observer, and Redux patterns. </span><span class="koboSpan" id="kobo.823.3">You learned when these patterns are used by the framework and how you can use them to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">your code.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.825.1">Building a generic HTTP service containing a model adapter</span></h1>
<p><span class="koboSpan" id="kobo.826.1">To build </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.827.1">your generic HTTP service </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.828.1">with a model adapter, start by creating a new library named </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">generic-http of type data-access</span></strong><span class="koboSpan" id="kobo.830.1"> in the domain shared. </span><span class="koboSpan" id="kobo.830.2">In this library, create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">generic-http.service.ts</span></strong><span class="koboSpan" id="kobo.832.1"> and a file </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">model-adapter.interface.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">model-adapter</span></strong><span class="koboSpan" id="kobo.838.1"> interface file, add </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">this interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.840.1">
export interface </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">ModelAdapter&lt;T, S&gt;</span></strong><span class="koboSpan" id="kobo.842.1"> {
  fromDto(dto: T): S;
  toDto(model: S): T;
}</span></pre> <p><span class="koboSpan" id="kobo.843.1">We use </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.844.1">generic types so we can make our model adapter type-safe. </span><span class="koboSpan" id="kobo.844.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">T</span></strong><span class="koboSpan" id="kobo.846.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">S</span></strong><span class="koboSpan" id="kobo.848.1"> are placeholders for the </span><strong class="bold"><span class="koboSpan" id="kobo.849.1">data transfer object</span></strong><span class="koboSpan" id="kobo.850.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.851.1">DTO</span></strong><span class="koboSpan" id="kobo.852.1">) and frontend model we will provide to the adapter. </span><span class="koboSpan" id="kobo.852.2">After creating the interface, start with the generic </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">HTTP service.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">The generic HTTP service will need a property for the API URL and the default HTTP headers, and the service needs to inject the </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">HTTP client.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.856.1">
@Injectable({
  providedIn: 'root'
})
export abstract class </span><strong class="bold"><span class="koboSpan" id="kobo.857.1">GenericHttpService&lt;T, S&gt;</span></strong><span class="koboSpan" id="kobo.858.1"> {
  protected url;
  defaultHeaders = new HttpHeaders();
  protected readonly httpClient = inject(HttpClient);
}</span></pre> <p><span class="koboSpan" id="kobo.859.1">As you can see, we also use generic types in the model adapter so we can maintain a type-safe </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.860.1">generic HTTP service. </span><span class="koboSpan" id="kobo.860.2">For </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.861.1">the HTTP service, we will also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">T</span></strong><span class="koboSpan" id="kobo.863.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">S</span></strong><span class="koboSpan" id="kobo.865.1"> as placeholders for the generic types. </span><span class="koboSpan" id="kobo.865.2">Next, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">constructor</span></strong><span class="koboSpan" id="kobo.867.1"> so we can pass an API endpoint, base URL, and model adapter to the generic </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">HTTP service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.869.1">
constructor(
  private endpoint: string,
  private baseUrl: string,
  private adapter: ModelAdapter&lt;T, S&gt;
) {
  this.url = this.baseUrl + '/api' + this.endpoint;
}</span></pre> <p><span class="koboSpan" id="kobo.870.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">constructor</span></strong><span class="koboSpan" id="kobo.872.1"> function brackets, we will construct the API URL from the base URL and the endpoint we receive from the constructor parameters. </span><span class="koboSpan" id="kobo.872.2">Now, you need to implement the API requests. </span><span class="koboSpan" id="kobo.872.3">The generic HTTP service will be used for common API requests: </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">get</span></strong><span class="koboSpan" id="kobo.874.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">get by id</span></strong><span class="koboSpan" id="kobo.876.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">post</span></strong><span class="koboSpan" id="kobo.878.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">put</span></strong><span class="koboSpan" id="kobo.880.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">patch</span></strong><span class="koboSpan" id="kobo.882.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">delete</span></strong><span class="koboSpan" id="kobo.884.1">. </span><span class="koboSpan" id="kobo.884.2">Each request will use the URL we constructed, so this approach will only work if your API shares the same API route for these requests. </span><span class="koboSpan" id="kobo.884.3">Otherwise, you need to add an additional parameter to your constructor for the API routes (this can be done with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">Record</span></strong><span class="koboSpan" id="kobo.886.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">for example).</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">The API requests will include the request headers, and there will be an option to append additional headers if needed. </span><span class="koboSpan" id="kobo.888.2">Each request will also implement the model adapter so the objects received from the API will automatically be adapted to the frontend models. </span><span class="koboSpan" id="kobo.888.3">Here is an example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">get</span></strong><span class="koboSpan" id="kobo.890.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">post</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.892.1"> request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.893.1">
public get(extraHttpRequestParams?: Partial&lt;HttpHeaders&gt;): Observable&lt;S[]&gt; {
  return this.httpClient.get&lt;T[]&gt;(`${this.url}`, this.prepareRequestOptions(extraHttpRequestParams)).pipe(
      map((data: T[]) =&gt; data.map(item =&gt; this.adapter.fromDto(item) as S)));
}
public post(body: S, extraHttpRequestParams?: Partial&lt;HttpHeaders&gt;): Observable&lt;S&gt; {
    return this.httpClient.post(`${this.url}`, this.adapter.toDto(body), this.prepareRequestOptions(extraHttpRequestParams)).pipe(map(data =&gt; this.adapter.fromDto(data as T) as S)) as Observable&lt;S&gt;;
}</span></pre> <p><span class="koboSpan" id="kobo.894.1">You can </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.895.1">implement the other </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.896.1">requests by yourself or take them from the GitHub repository from </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.898.1">As you can see, the requests implement a function </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">prepareRequestOptions</span></strong><span class="koboSpan" id="kobo.900.1">. </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">This </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">prepare</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">
RequestOptions</span></strong><span class="koboSpan" id="kobo.904.1"> function is used to append additional API headers if needed. </span><span class="koboSpan" id="kobo.904.2">The implementation for this function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.906.1">
public prepareRequestOptions(extraHttpRequestParams = {}) {
  return {
    headers: Object.assign(this.defaultHeaders, extraHttpRequestParams)
  };
}</span></pre> <p><span class="koboSpan" id="kobo.907.1">Now you can add additional HTTP headers if needed. </span><span class="koboSpan" id="kobo.907.2">Now that you’ve created a generic HTTP service, let’s explore how you can use </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">the service.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.909.1">Using the generic HTTP service</span></h2>
<p><span class="koboSpan" id="kobo.910.1">Using the generic HTTP service is done with inheritance when you create other HTTP services. </span><span class="koboSpan" id="kobo.910.2">For </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.911.1">example, we need an HTTP service in our finance </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">data-access</span></strong><span class="koboSpan" id="kobo.913.1"> library to get, update, and delete our expenses. </span><span class="koboSpan" id="kobo.913.2">Suppose you’re not using the generic HTTP service with a model adapter. </span><span class="koboSpan" id="kobo.913.3">In that case, you will create an HTTP file in the finance </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">data-access</span></strong><span class="koboSpan" id="kobo.915.1"> library that would look similar to the generic HTTP file, only with predefined types API URLs </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">and models.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">Because all these HTTP services commonly look more or less the same, with the exception of the API URL and the models, we created the generic HTTP service so we don’t have to rewrite the same every time. </span><span class="koboSpan" id="kobo.917.2">Instead, we can inherit the generic HTTP service and share the </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">common functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">Let’s implement the generic HTTP service and start by creating a new folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">HTTP</span></strong><span class="koboSpan" id="kobo.921.1"> inside the finance </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">data-access</span></strong><span class="koboSpan" id="kobo.923.1"> library in your </span><em class="italic"><span class="koboSpan" id="kobo.924.1">Nx monorepo</span></em><span class="koboSpan" id="kobo.925.1">. </span><span class="koboSpan" id="kobo.925.2">Inside this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">HTTP</span></strong><span class="koboSpan" id="kobo.927.1"> folder, create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">expenses.http.ts</span></strong><span class="koboSpan" id="kobo.929.1">. </span><span class="koboSpan" id="kobo.929.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">expenses.http.ts</span></strong><span class="koboSpan" id="kobo.931.1"> file, you have to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">ExpensesHttpService</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.933.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.934.1">
@Injectable({ providedIn: 'root' })
export class </span><strong class="bold"><span class="koboSpan" id="kobo.935.1">ExpensesHttpService</span></strong><span class="koboSpan" id="kobo.936.1">{}</span></pre> <p><span class="koboSpan" id="kobo.937.1">Next, create an interface for the expense model and expense DTO. </span><span class="koboSpan" id="kobo.937.2">The DTO represents the object structure we receive from the API and the model of the object structure we use in the frontend. </span><span class="koboSpan" id="kobo.937.3">I created a new folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">models</span></strong><span class="koboSpan" id="kobo.939.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">lib folder</span></strong><span class="koboSpan" id="kobo.941.1"> of the finance </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">data-access</span></strong><span class="koboSpan" id="kobo.943.1"> library and added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">expenses.interfaces.ts</span></strong><span class="koboSpan" id="kobo.945.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">models</span></strong><span class="koboSpan" id="kobo.947.1"> folder. </span><span class="koboSpan" id="kobo.947.2">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">expenses.interfaces.ts</span></strong><span class="koboSpan" id="kobo.949.1"> file, I will create the expense model and </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">DTO interfaces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.951.1">
export interface ExpenseDto {
  id: number | null;
  title: string;
  amount: number;
  vatPercentage: number;   date: string;
  tags?: string[];
}
export interface ExpenseModel {
  id: number | null;
  description: string;
  amount: {
    amountExclVat: number;
    vatPercentage: number;
  };
  date: string;
  tags?: string[];
}</span></pre> <p><span class="koboSpan" id="kobo.952.1">Next, you can </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.953.1">create a new folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">adapters</span></strong><span class="koboSpan" id="kobo.955.1">. </span><span class="koboSpan" id="kobo.955.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">adapters</span></strong><span class="koboSpan" id="kobo.957.1"> folder is located in the same place as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">models</span></strong><span class="koboSpan" id="kobo.959.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">HTTP</span></strong><span class="koboSpan" id="kobo.961.1"> folders. </span><span class="koboSpan" id="kobo.961.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">adapters</span></strong><span class="koboSpan" id="kobo.963.1"> folder, create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">expense.adapter.ts</span></strong><span class="koboSpan" id="kobo.965.1"> file, which will contain the model adapter for the expense DTO </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">and model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.967.1">
export class ExpensesModelAdapter implements ModelAdapter&lt;ExpenseDto, ExpenseModel&gt; {
  fromDto(dto: ExpenseDto): ExpenseModel {
    return {
      description: dto.title,
      amount: {
        amountExclVat: dto.amount,
        vatPercentage: dto.vatPercentage
      },
      date: dto.date,
      tags: dto.tags,
      id: dto.id
    };
  }
  toDto(model: ExpenseModel): ExpenseDto {
    return {
      id: model.id ? </span><span class="koboSpan" id="kobo.967.2">model.id : null,
      title: model.description,
      amount: model.amount.amountExclVat,
      vatPercentage: model.amount.vatPercentage,
      date: model.date,
      tags: model.tags ? </span><span class="koboSpan" id="kobo.967.3">model.tags : []
    };
  }
}</span></pre> <p><span class="koboSpan" id="kobo.968.1">As you can see, the model adapter maps the expense DTO to the expense model and the expense </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.969.1">model to the expense DTO. </span><span class="koboSpan" id="kobo.969.2">We will provide this model adapter to the constructor of the generic HTTP service so that our models will automatically be mapped when we receive them from or send them to the API. </span><span class="koboSpan" id="kobo.969.3">The last step is to inherit the generic HTTP service in your expenses HTTP service. </span><span class="koboSpan" id="kobo.969.4">You inherit by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">extends</span></strong><span class="koboSpan" id="kobo.971.1"> keyword and adding the class name of the generic </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">HTTP service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
@Injectable({
  providedIn: 'root'
})
export class ExpensesHttpService extends GenericHttpService&lt;ExpenseDto, ExpenseModel&gt; {
  constructor() {
    super(
      ‹/expenses',
      ‹›,
      new ExpensesModelAdapter()
    );
  }
}</span></pre> <p><span class="koboSpan" id="kobo.974.1">As you can see, we also call a </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">super()</span></strong><span class="koboSpan" id="kobo.976.1"> method and provide it with some arguments. </span><span class="koboSpan" id="kobo.976.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">super()</span></strong><span class="koboSpan" id="kobo.978.1"> method is used to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">constructor</span></strong><span class="koboSpan" id="kobo.980.1"> method of the inherited class – in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">GenericHttpService</span></strong><span class="koboSpan" id="kobo.982.1">. </span><span class="koboSpan" id="kobo.982.2">You provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">super()</span></strong><span class="koboSpan" id="kobo.984.1"> method with the properties that </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.985.1">the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">GenericHttpService</span></strong><span class="koboSpan" id="kobo.987.1"> expects to receive, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">endpoint</span></strong><span class="koboSpan" id="kobo.989.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">baseUrl</span></strong><span class="koboSpan" id="kobo.991.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">model adapter.</span></span></p>
<p><span class="koboSpan" id="kobo.993.1">You might also notice we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">arrow</span></strong><span class="koboSpan" id="kobo.995.1"> syntax after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">GenericHttpService</span></strong><span class="koboSpan" id="kobo.997.1"> and provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">ExpenseDto</span></strong><span class="koboSpan" id="kobo.999.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">ExpenseModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1"> inside:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1002.1">
GenericHttpService&lt;ExpenseDto, ExpenseModel&gt;</span></pre> <p><span class="koboSpan" id="kobo.1003.1">Using the before-mentioned syntax provides the generic HTTP service with the generic types we added in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">GenericHttpService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1006.1">
GenericHttpService&lt;T, S&gt;</span></pre> <p><span class="koboSpan" id="kobo.1007.1">By using generic types, we make sure the generic HTTP service remains type-safe, and we receive typed objects when we use the methods of our HTTP services. </span><span class="koboSpan" id="kobo.1007.2">After inheriting the generic HTTP service inside the expenses HTTP service, you are ready to use the expenses HTTP service. </span><span class="koboSpan" id="kobo.1007.3">All the methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">get</span></strong><span class="koboSpan" id="kobo.1009.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">get by id</span></strong><span class="koboSpan" id="kobo.1011.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">post</span></strong><span class="koboSpan" id="kobo.1013.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">delete</span></strong><span class="koboSpan" id="kobo.1015.1">, and so forth, are inherited by the generic HTTP service and don’t have to be </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">implemented again.</span></span></p>
<p><span class="koboSpan" id="kobo.1017.1">If you want to use the expenses HTTP service, you </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">inject</span></strong><span class="koboSpan" id="kobo.1019.1"> it as you would with any other HTTP service </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">or dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
protected readonly expensesApi = inject(ExpensesHttpService);</span></pre> <p><span class="koboSpan" id="kobo.1022.1">After injecting the HTTP service, you can call any method the </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">service exposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1024.1">
this.expensesApi.get()
  .pipe(takeUntilDestroyed(this.destroyRef))
  .subscribe((data) =&gt; { console.log(‹data ==&gt;›, data); });</span></pre> <p><span class="koboSpan" id="kobo.1025.1">When we </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.1026.1">make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">get</span></strong><span class="koboSpan" id="kobo.1028.1"> request, you might notice the request is failing; this is because we don’t have an actual API running and the request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">/api/expenses</span></strong><span class="koboSpan" id="kobo.1030.1"> returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">404 not found</span></strong><span class="koboSpan" id="kobo.1032.1"> error code. </span><span class="koboSpan" id="kobo.1032.2">Let’s resolve this issue and provide some mock data when we make our </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">API requests.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.1034.1">Providing mock data for our API requests</span></h2>
<p><span class="koboSpan" id="kobo.1035.1">There are many ways to provide mock data; we will use an HTTP interceptor to get our mock data </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.1036.1">from the assets folder. </span><span class="koboSpan" id="kobo.1036.2">This is just a simple implementation, and it has some flaws, but for demonstration purposes, it works very well, and it doesn’t take much effort to </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">set up.</span></span></p>
<p><span class="koboSpan" id="kobo.1038.1">We start by creating an interceptors folder with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">mock.interceptor.ts</span></strong><span class="koboSpan" id="kobo.1040.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">generic-http</span></strong><span class="koboSpan" id="kobo.1042.1"> library in our Nx monorepo. </span><span class="koboSpan" id="kobo.1042.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">mock.interceptor.ts</span></strong><span class="koboSpan" id="kobo.1044.1"> file, we will create an interceptor that returns the HTTP request untouched if we are not in </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">development mode.</span></span></p>
<p><span class="koboSpan" id="kobo.1046.1">If we are in development mode, the interceptor will adjust the request URL and request method so that all requests are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">GET</span></strong><span class="koboSpan" id="kobo.1048.1"> requests, and it will try to get a JSON file to place in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">assets</span></strong><span class="koboSpan" id="kobo.1050.1"> folder of our applications (in our case, the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1051.1">expenses-registration application</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1053.1">We will also intercept the HTTP response, and if we do not make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">GET</span></strong><span class="koboSpan" id="kobo.1055.1"> request, we will return the request body instead of the data from our JSON file in the assets folder of </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">the project.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1057.1">
export const MockInterceptor: HttpInterceptorFn = (
  req: HttpRequest&lt;unknown&gt;,
  next: HttpHandlerFn,
) =&gt; {
  if (!isDevMode()) return next(req);
  const clonedRequest = req.clone({
    url: `assets${req.url}.json`,
    method: ‹GET›,
  });
  return next(clonedRequest).pipe(
    map((event: HttpEvent&lt;unknown&gt;) =&gt; {
      if (event instanceof HttpResponse &amp;&amp; req.method !== 'GET') {
        // Modify the response body here
        return event.clone({ body: req.body });
      }
      return event;
    }));
};</span></pre> <p><span class="koboSpan" id="kobo.1058.1">As you </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.1059.1">can see, we first check that we are not in development mode, and if that is the case, we directly return the request. </span><span class="koboSpan" id="kobo.1059.2">If we are in development mode, we clone the request and adjust the request URL and method. </span><span class="koboSpan" id="kobo.1059.3">The method is set to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">GET</span></strong><span class="koboSpan" id="kobo.1061.1">, regardless of what request we try to make. </span><span class="koboSpan" id="kobo.1061.2">The URL is prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">assets</span></strong><span class="koboSpan" id="kobo.1063.1">, so we target the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">assets</span></strong><span class="koboSpan" id="kobo.1065.1"> folder of our application and postfix it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">.json</span></strong><span class="koboSpan" id="kobo.1067.1"> because we will fetch a JSON file from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">assets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1070.1">Adjusting the URL in this manner makes sure that a request to the following API URL </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">/api/expenses</span></strong><span class="koboSpan" id="kobo.1072.1"> will be transformed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">/assets/api/expenses.json</span></strong><span class="koboSpan" id="kobo.1074.1">. </span><span class="koboSpan" id="kobo.1074.2">Next, we use the RxJS pipe and map operator to listen for the HTTP response and simply return the request body if the original request method wasn’t a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1"> request.</span></span></p>
<p><span class="koboSpan" id="kobo.1077.1">Next, you </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.1078.1">have to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">api</span></strong><span class="koboSpan" id="kobo.1080.1"> folder inside the assets folder of the </span><em class="italic"><span class="koboSpan" id="kobo.1081.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.1082.1">, and in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">api</span></strong><span class="koboSpan" id="kobo.1084.1"> folder, you need to create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">expenses.json</span></strong><span class="koboSpan" id="kobo.1086.1"> file with your </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">mock data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1088.1">
[
  {
    "id": 1,
    "title": "Office Supplies",
    "amount": 50.0,
    "vatPercentage": 20,
    "date": "2019-01-04",
    "tags": [
       "printer"
    ]
  },
  ………
]</span></pre> <p><span class="koboSpan" id="kobo.1089.1">Lastly, you need to register the interceptor in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">ApplicationConfig</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1092.1">
provideHttpClient(withInterceptors([</span><strong class="bold"><span class="koboSpan" id="kobo.1093.1">MockInterceptor</span></strong><span class="koboSpan" id="kobo.1094.1">])),</span></pre> <p><span class="koboSpan" id="kobo.1095.1">After adding the interceptor in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">ApplicationConfig</span></strong><span class="koboSpan" id="kobo.1097.1">, your API request will return with your mock data for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">GET</span></strong><span class="koboSpan" id="kobo.1099.1"> requests and the request body for all other types </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">of requests.</span></span></p>
<p><span class="koboSpan" id="kobo.1101.1">If you make API requests to other API endpoints, you need to add additional JSON files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">assets</span></strong><span class="koboSpan" id="kobo.1103.1"> folder to mock the response for these requests. </span><span class="koboSpan" id="kobo.1103.2">That was it for the generic HTTP service and model adapter. </span><span class="koboSpan" id="kobo.1103.3">In the next chapter, we will start implementing RxJS and signals and use the observer pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">in practice.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.1105.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1106.1">In this chapter, you learned about Angular code conventions and best practices. </span><span class="koboSpan" id="kobo.1106.2">You learned about naming conventions for your folders and files and naming conventions for properties, functions, and classes within your Angular applications. </span><span class="koboSpan" id="kobo.1106.3">You also learned about best practices to improve performance and prevent bugs and </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">hard-to-debug code.</span></span></p>
<p><span class="koboSpan" id="kobo.1108.1">Besides conventions and best practices, we looked at some of the most commonly used design patterns within Angular applications. </span><span class="koboSpan" id="kobo.1108.2">You learned when the Angular framework uses specific patterns and how you can write cleaner and more scalable code using design patterns such as the facade, decorator, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">inheritance patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.1110.1">We finished the chapter by creating a generic HTTP service using the inheritance pattern. </span><span class="koboSpan" id="kobo.1110.2">The HTTP service can easily be used to construct HTTP services for all your data access libraries. </span><span class="koboSpan" id="kobo.1110.3">The generic HTTP service also has a model adapter to transform DTOs into your frontend models automatically. </span><span class="koboSpan" id="kobo.1110.4">Lastly, because we don’t have an API, we made an HTTP interceptor to intercept our HTTP requests and provide </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">mock data.</span></span></p>
<p><span class="koboSpan" id="kobo.1112.1">In the next chapter, we will learn about reactive programming and implement RxJS and signals within our </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">expenses application.</span></span></p>
</div>
</body></html>