- en: '*Chapter 12*: Embracing Ahead-of-Time Compilation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular Ivy is the most recent generation of the Angular framework. It features
    a new compiler and a new runtime, both of which maintain compatibility with most
    of the APIs used by the previous generation of Angular's compiler and runtime
    known as Angular View Engine.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about how Angular Ivy makes **ahead-of-time**
    the default Angular compiler across all phases of development and what impact
    it has on our developer workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we will explore metadata errors that might occur when using
    the ahead-of-time Angular compiler, with accompanying techniques to fix the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will demonstrate two techniques for resolving asynchronous dependencies
    before bootstrapping our Angular Ivy application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the ahead-of-time compiler for all development phases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with the ahead-of-time compiler's limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing asynchronous dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will be aware of how Angular Ivy made it feasible
    for the ahead-of-time Angular compiler to become the default compiler for all
    phases of our development workflow. You will understand how the ahead-of-time
    compiler affects the different phases of our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces edge cases that are incompatible with the ahead-of-time
    Angular compiler but also teaches you how to deal with them or get around them.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn two techniques for resolving asynchronous dependencies before
    bootstrapping your Angular application and the trade-offs they bring.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technicalities discussed in this chapter apply to applications at or higher
    than the following versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular Ivy version 12.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript version 4.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More metadata errors might occur in earlier versions of Angular and TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: You can find complete code examples for the feature flags and the feature flag
    initializer in this book's companion GitHub repository at [https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter12](https://github.com/PacktPublishing/Accelerating-Angular-Development-with-Ivy/tree/main/projects/chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Using the ahead-of-time compiler for all development phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous generations of Angular, the ahead-of-time compiler was significantly
    slower than the just-in-time Angular compiler. Because of this and other factors,
    just-in-time was the default compiler in all or several phases of development
    depending on the Angular version. This in turn led to issues because errors were
    only discovered when doing a production build or—even worse—in the production
    environment at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Ivy uses its **ahead-of-time compiler** by default in all development
    phases, including while running the development server, when running tests, for
    server-side rendering, and in the browser, instead of bundling and running the
    **just-in-time compiler** at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses how the ahead-of-time Angular compiler affects these
    phases of our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-time compilation for builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides improved compilation speed in Angular Ivy, another key to using the
    ahead-of-time compiler by default is that Angular Ivy decreases our application's
    bundle size under certain conditions. In general, both small and large applications
    see a decrease in overall size when comparing View Engine to Ivy compilation,
    while medium-sized applications might not see a significant change.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, the bundle sizes of small and simple applications decrease
    when using Angular Ivy. For complex applications, the main bundle size increases
    while lazy-loaded chunks become smaller when compared to Angular View Engine.
    This is a bit of a trade-off, considering that a bigger main bundle size increases
    several performance timing measurements.
  prefs: []
  type: TYPE_NORMAL
- en: The secret to unlocking the opportunity for smaller bundles is the transition
    from View Engine's data structures interpreted at runtime to the so-called **Ivy
    Instruction Set**, which reuses runtime commands—or instructions—rather than having
    a unique data structure for each part of your application as was the case with
    View Engine.
  prefs: []
  type: TYPE_NORMAL
- en: View Engine's compiled data structures have the downside that there is an inflection
    point at which the compiled data structures become larger than the source code
    of the compiler and our application.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, the Ivy Instruction Set is tree-shakable, meaning that only the
    instructions used by our application are included in a production bundle. For
    example, internationalization instructions are removed from a production bundle
    if our application is not multilingual. Similarly, animation instructions are
    excluded from a production bundle if our application does not use animations.
  prefs: []
  type: TYPE_NORMAL
- en: The Ivy Instruction Set is used by a significantly faster runtime when compared
    to View Engine because the precompiled instructions are immediately executable
    in contrast to the View Engine data structures, which must be interpreted to instructions
    at runtime before being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-time compilation for component templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Angular Ivy's ahead-of-time compiler, it is recommended to enable
    strict template type checking as mentioned in [*Chapter 2*](B16295_02_ePub_RK.xhtml#_idTextAnchor031),
    *Boosting Developer Productivity Through Tooling, Configuration, and Convenience*.
  prefs: []
  type: TYPE_NORMAL
- en: Strict template type checking catches most type errors in Angular metadata,
    component models, and component templates. They will appear either when building
    our application or inline in our code editors when using the Angular Language
    Service.
  prefs: []
  type: TYPE_NORMAL
- en: Without strict template type checking, these errors might appear as frustrating
    bugs at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-time compilation for unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular Ivy decreases both build time and rebuild time. This is a time-saving
    improvement both for the development server and for unit tests. In addition to
    faster compilation speed, Angular Ivy introduces a compile cache so that compiled
    Angular modules, components, directives, pipes, and services are cached between
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular View Engine, ahead-of-time compilation is not supported for unit
    tests. Angular Ivy introduces ahead-of-time compilation support for unit tests
    while still allowing the dynamic creation of Angular modules, components, directives,
    and pipes for the purpose of testing. Dynamic creation during unit tests still
    uses the just-in-time Angular compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-time compilation for the runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the ahead-of-time Angular compiler, our Angular application is loaded
    faster because the just-in-time Angular compiler is not bundled with our application.
    Our application is bootstrapped faster because the compiler is run at build time
    rather than at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular Ivy runtime is faster than the Angular View Engine runtime thanks
    to the Ivy Instruction Set. The View Engine runtime has to interpret the view
    compiler data structures before initializing or updating the DOM managed by an
    Angular component template. By comparison, Ivy instructions are executed immediately.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the impact the ahead-of-time Angular compiler
    has on the different phases of our development workflow. In the following section,
    we will shine a light on the ahead-of-time compiler's limitations and explore
    how we address them through simple code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the ahead-of-time compiler's limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The upside of using Angular Ivy's ahead-of-time compiler is faster runtime speed
    and a smaller bundle because of not having to ship a compiler to the runtime bundle
    or compiler before rendering the application.
  prefs: []
  type: TYPE_NORMAL
- en: When using the ahead-of-time compiler, there is a trade-off to be aware of.
    Declarables—that is, directives, components, and pipes—cannot rely on runtime
    information because they must be compiled ahead of time, that is, at build time
    rather than at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This sets a limitation for dynamically creating declarables at runtime, for
    example, based on server-side configuration or a static configuration file. Unless,
    of course, we bundle the Angular compiler with our application and use it at runtime,
    but then what would be the point?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that injected dependencies—that is, class-based services, provided
    values, or functions—can be resolved at runtime. Keep in mind that only synchronously
    resolved values can be provided directly. If we need an asynchronous process to
    resolve a value, we must wrap it in a class-based service, a function, a promise,
    or an observable. This is discussed and solved in the final sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will briefly discuss metadata errors when using the ahead-of-time
    Angular compiler. We will not discuss metadata errors that are solved by using
    strict TypeScript compilation or strict template type checking, as was discussed
    in [*Chapter 2*](B16295_02_ePub_RK.xhtml#_idTextAnchor031), *Boosting Developer
    Productivity Through Tooling, Configuration, and Convenience*.
  prefs: []
  type: TYPE_NORMAL
- en: Providing values using functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Passing the result of a function call to a value provider is not supported.
    Instead, we use factory functions and declare them as providers known as factory
    providers. For example, say we have the following ahead-of-time-incompatible **value
    provider**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace it with the following ahead-of-time-compatible **factory provider**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This configures Angular to run the factory function at an appropriate time of
    our application life cycle to resolve the time zone dependency represented by
    `timeZoneToken` while maintaining compatibility with the ahead-of-time Angular
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring metadata using functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A known ahead-of-time compilation edge case is using functions or static methods
    to determine declared metadata such as the `imports` or `declarations` of an Angular
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following use case, we attempt to bootstrap a fake root component in
    Angular development mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we try to compile this code ahead of time, we hit a limitation on Angular
    metadata. Functions used for metadata declaration must only contain a single `return`
    statement, nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'To comply with metadata limitations, we refactor the `determineAppComponent`
    function to the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function now contains only a single expression, a `return` statement that
    evaluates a ternary expression. This is compliant with the ahead-of-time Angular
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using tagged template literals in component templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unfortunately, ahead-of-time Angular does not support tagged template literals.
    For example, the following component results in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can use a regular function to create a compile-time dynamic part
    of our template, as seen in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We must stay clear of tagged template literals for component template metadata
    to comply with the ahead-of-time Angular compiler''s limitations on Angular metadata.
    However, we can use tagged template literals in UI properties that we use in template
    bindings, as seen in the following refactored implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Choose either of these two techniques to deal with or support tagged template
    literals for Angular component templates, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing metadata variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Metadata must be immediately available for the ahead-of-time compiler. The
    following example is invalid because of late initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `greeting` variable has not been initialized when the component metadata
    is converted to annotations by the ahead-of-time Angular compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'More surprisingly, the following example is also invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While not a common use case, keep this limitation in mind because it is quite
    surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first see the fixed implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `greeting` variable is now defined and initialized at the same time so the
    component template works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the value of the `greeting` variable just after initializing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When using the ahead-of-time Angular compiler, the template is `<h1>Hello, World!</h1>`.
    If we change to the just-in-time Angular compiler, the template is `<h1>Hello,
    JIT compiler!</h1>`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables used for declarable metadata must be defined and initialized at the
    same time when using the ahead-of-time Angular compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the edge cases of ahead-of-time compiler compatibility
    and learned how to address them. In the next section, we will learn how to initialize
    asynchronous dependencies before bootstrapping our application.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing asynchronous dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Referring to asynchronous values is toxic because every value computed from
    the referred value must be asynchronous as well. A couple of techniques to get
    around this are available, but they both come at the cost of delaying application
    bootstrapping until the value has been resolved. These techniques are demonstrated
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Providing an asynchronous dependency with a static platform provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To convert an asynchronous dependency resolver to a static dependency, we can
    delay bootstrapping our application to provide the static provider at the platform
    level, making it available as a static dependency in our application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have a JSON file containing an object with Boolean values.
    We create it in the `src/app/assets/features.json` file of our application project.
    This file contains our **feature flags**, which are loaded at runtime. The settings
    in this file can be changed after compiling our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/load-feature-flags.ts` file of our application project, we add
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Before calling this function in the main file of our application, we create
    a dependency injection token to represent the feature flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows the `src/app/feature-flags.token.ts` file of
    our application project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we modify our main file so that it contains something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are loading the feature flags, then passing them as the value
    for the platform provider of the feature flags token before being able to bootstrap
    our Angular application module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can inject the feature flags in any Angular-specific class, such as
    a component, as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Feature flags are a good use case for this technique. Other configurations are
    also well suited for this approach. Additionally, if multiple application initializers
    need a shared dependency, this technique is the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will walk through an alternative technique and discuss
    the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving an asynchronous dependency with an application initializer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another technique for dealing with a dependency that is asynchronously resolved
    is an application initializer.
  prefs: []
  type: TYPE_NORMAL
- en: An application initializer is resolved before the root application component
    is bootstrapped. This is ideal for setting up the initial root-level state that
    is not needed for other application initializers.
  prefs: []
  type: TYPE_NORMAL
- en: We will consider an alternative approach for dealing with feature flags. This
    time, we are using a feature flag service that is configured using an application
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature flag service has the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature flag initializer loads the feature flags using `HttpClient` before
    calling `FeatureFlagService#configureFeatures`. This is seen in the following
    code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we register the feature flag initializer in our root module by adding
    it to the `providers` array, as seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting all of this up, any Angular-specific class can inject an instance
    of the `FeatureFlagService` class and use its `isEnabled` method to check the
    state of a feature flag, as seen in the following code listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of using an application initializer is that multiple of them can
    be run in parallel, which speeds up the overall application bootstrap time compared
    to delaying the entire bootstrap process until a response has finished, as was
    the case in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off is that we must wrap the feature flags in a service-based class
    with methods for writing and reading the feature flag configuration, whereas with
    the first technique we explored, the feature flags were available as a static
    dependency, a dead simple object. Choose whichever technique fits your use case
    best.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how the enhanced Angular Ivy compiler and runtime
    make the ahead-of-time Angular compiler a good choice for all phases of development.
    The tree-shakable, reusable Ivy Instruction Set leaves a smaller bundle for a
    range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how ahead-of-time compilation affects our application builds, component
    templates, unit tests, and the browser at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored solutions for metadata errors that occur when using the ahead-of-time
    Angular compiler. Metadata errors that are detected by strict TypeScript and Angular
    compilation settings were not discussed. Read about strict template type checking
    in [*Chapter 2*](B16295_02_ePub_RK.xhtml#_idTextAnchor031), *Boosting Developer
    Productivity Through Tooling, Configuration, and Convenience*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final sections, we learned how to resolve and initialize asynchronous
    dependencies before bootstrapping our application using two techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing an asynchronous dependency with a static platform provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving an asynchronous dependency with an application initializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques are great for feature flags and other configurations, but they
    each have trade-offs that you are now able to recognize.
  prefs: []
  type: TYPE_NORMAL
- en: That is the end of this book. We hope that you enjoyed learning about some of
    the most interesting stable features introduced by Angular Ivy and its accompanying
    versions of TypeScript. Angular is an ever-evolving framework with several feature
    releases every year.
  prefs: []
  type: TYPE_NORMAL
- en: Keep learning!
  prefs: []
  type: TYPE_NORMAL
