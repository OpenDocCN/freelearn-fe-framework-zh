- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn what asynchronous code is, let''s first cover what synchronous code
    is. With synchronous code, you have one statement being executed after another.
    The code is predictable; you know what happens and when. This is because you can
    read the code from top to bottom like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with asynchronous code you lose all the nice predictability that the synchronous
    code offers. In fact, there is very little you know about asynchronous code other
    than that it finishes executing, eventually. So asynchronous, or async, code looks
    more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the order in which a statement finishes is not determined by
    when a statement occurs in the code. Instead, there is a time element involved
    that decides when a statement has run its course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous code runs in an event loop. This means that async code runs in
    the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Run async code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the response to be ready, then fire an interrupt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the event handler
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An important thing to stress here is that async code is non-blocking—other operations
    can take place while async code is running. Therefore, async code is a good candidate
    to be used when dealing with I/O, long-running tasks, and network requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn what asynchronous programming is and how it differs from synchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the callback model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe promises and how they completely reformed how we write asynchronous
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at which other asynchronous libraries exist and in what cases they should
    be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover the new standard async/await
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, we described what asynchronous and synchronous code looks like
    when you encounter it in your everyday life as a developer. What might be of interest
    is to know how an operating system looks at such code and how it deals with it.
    An operating system deals with asynchronous code by thinking of it in terms of
    the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Events, these are messages that signals to the operating system that a certain
    type of action has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handler, this is the piece of code that should run when an event has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event queue, this is where all events and their event handlers are placed, waiting
    to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s illustrate this flow in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/479cdc64-c4d1-459e-86d2-c0d74e1b9a52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What we can see in the preceding image is how events are being picked from
    an event queue. Here, the **CLICK** event is being run when a Dispatcher tells
    it to and its corresponding event handler is executed. The event handler runs
    the associated lines of code in the event handler and when that''s done, gives
    control back to the Dispatcher. Thereafter, the cycle begins anew for the next
    event in the queue. This is what it usually looks like in a single-threaded system,
    where only one event handler is executed at a time. There is also such a thing
    as a multithreaded system. In a multithreaded system, multiple threads exist.
    This means we might have several event handlers being executed at once. But even
    though there are multiple threads, there is only one active thread. The system
    itself is still single-threaded. Confused? Here is the thing: threads in a multithreaded
    system are cooperative, which means they can be interrupted. This means that the
    active thread is changed after a unit of work has been carried out. This creates
    an effect where it seems like everything happens in parallel. Let''s illustrate
    this for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72f27ff3-d8a0-471b-942d-cd3010f29b8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that a piece of code is divided into different regions. When
    a certain region has been executed, it gives control to the next **Thread**, which
    becomes the new **Active thread**. Once that thread has executed code through
    one of its regions, it gives control to the next thread. With the arrival of multiple
    CPUs, we are able to go from perceived parallelism (described previously) to actual
    parallel execution. In such a reality, one thread per CPU exists and we therefore
    have multiple active threads.
  prefs: []
  type: TYPE_NORMAL
- en: These are the different ways you can execute asynchronous code. We will focus
    on single-threaded execution, as this is how it is implemented in JavaScript and
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: The callback pattern on the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way to go about it is to attach functions to future events. When the event
    occurs, our attached function gets executed. An example of this is `XMLHttpRequest`,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see here is that all lines are executed synchronously except for
    `xhr.onload`. Attaching the function to `onload` happens synchronously, but running
    the function that `onload` is pointing to doesn''t happen until the request finishes.
    We can also define other events, such as `onreadystatechange` , and attach a function
    to that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As the web is single-threaded, this is how we deal with asynchronous code. The
    `onreadystatechange` object and its callback are registered with the operating
    system. Once the asynchronous part has been completed the operating system is
    woken up by an event being dispatched. Thereafter, the callback is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The callback pattern in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js is single-threaded, just like the web. To handle long running operations
    it also uses a callback pattern. The callback pattern in Node.js has a a few more
    details to it and can be described as having the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: There is only one function to handle success and error responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback is called only once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function is the last parameter of the calling function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback consists of the parameter's errors and results, in that order,
    which is also called error-first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now showcase what the calling code looks like, with a callback supplied
    as the function''s last argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code fulfills all the properties laid out by the pattern, namely
    that the last parameter in the function call is the callback function. Furthermore,
    the callback function has the error as the first parameter and the response as
    the second parameter. In addition, the body of the callback function checks whether
    there is an error first and then, in the absence of an error, deals with the response
    we get back.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, let''s also look at how `callAsync()` is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation is just a mockup but it does show off two important
    aspects. One aspect is the time factor the `setTimeout()` function represents
    and the fact that the function takes time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspect is our third parameter, `fn()` which is invoked differently.
    We call `fn(null, 'success')` when everything is alright and `fn('error', null)`
    when an error has occurred. The way we invoke `fn()` is how we communicate success
    and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with structuring async code – callback hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we introduced the callback pattern as a way to deal
    with asynchronous calls. The pattern offers a structured way of dealing with such
    calls, in that we can always know what to expect in its method signature; the
    error is the first parameter, the second parameter is the response, and so on.
    But the pattern does have its shortcomings. The shortcomings might not be obvious
    at first, because you might only call the code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What we see here is how we invoke the method `openFile()`. Once that runs to
    completion, the callback is called and, inside of the callback, we continue invoking
    `statement4` and `statement5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks okay in the sense that it is still readable. The problem arises
    when you need to do several async calls one after another and those calls are
    dependent upon each other. It might be that you first need to log in to a system
    and then fetch the other data, or it might mean that you need to make a call as
    to whose data needs to be used as input for the next call, like in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The anti-pattern we see emerging here is that of tabulation and lost readability.
    For each call we make, we see the code is tabbed one step in; it's nested. When
    we have three calls like this, we can see that the code doesn't look very nice;
    it is readable, but not very pleasing to the eye. Another drawback is it's also
    technically hard to get right, in that we might struggle to place the parentheses
    and curly brackets in the correct place. Throw a few `if...else` clauses in there
    and you will have a hard time matching all the symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways you can address this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the code shallow and use named functions over anonymous ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the cognitive load and move functions into their own modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use more advanced constructs, such as promises, generators, and async functions
    from ES7 and other async libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keeping the code shallow is about giving our anonymous functions a dedicated
    name and breaking them out into their own functions; this will make our code look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This clearly flattens out the code and makes it more easier to read. It also
    removes the need to match curly brackets correctly as the functions are only one
    level deep.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gets the code part out of the way, but there is still a cognitive load
    as we have to process three function definitions and one function call. We can
    move them out to their own dedicated modules, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the other method, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we have removed quite a lot of the cognitive code. It may not have paid
    for itself in this case, as the methods were not that long, but imagine the methods
    spanned 30 or 40 lines in size; putting them in a separate module would have made
    a lot more sense.
  prefs: []
  type: TYPE_NORMAL
- en: The third option is to deal with this kind of code using more advanced constructs.
    We will address these in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Promises came about as a response to the callback hell problem described in
    the previous section. They have quite a long history, stretching back to the early
    80s, when the legendary *Barbara Liskov* coined the term `Promise`. The idea of
    a `Promise` is to flatten out async code. A promise is said to have the following
    states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pending**: This means it has not yet been decided or that the data is not
    available yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fulfilled**: The data has come back'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rejected**: An error happened during the operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thenables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Something important to know is that a `Promise` returns straight away, but
    the result is not available straight away. Promises are also known as *thenables*,
    because you need to register a callback with its `then()` method once the data
    has been received, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we demonstrated how to create a promise and how to register
    it with the `then()` method. The `promise` variable instance contains a construct
    that is returned straight away. The callback in the `then()` method gets invoked
    once the data is ready for us to use. In that sense, a `Promise` resembles a callback
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A `Promise` is really just a wrapping around an asynchronous construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, to use Promises we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `promise` and make sure to call `resolve()` or `reject()` when the
    data has arrived or an error has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register a callback with its `then()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register a callback to handle errors as well, as that is the responsible thing
    to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To put a promise to use, we need to instantiate it and make it part of a method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that; when we instantiate a `Promise` object, its constructor takes
    two parameters, `resolve` and `reject`. Let''s connect this to the states we know
    a promise can have, namely, pending, fulfilled, and rejected. When `getData()`
    is initially called, the `promise` returned and has the state `pending`. After
    a second, the promise will be fulfilled, because we called the `resolve()` method.
    Let''s look at the `getMoreData()` method to see how we can put a `Promise` into
    a rejected state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we call the `reject()` method after a second. This will put the
    promise into a rejected state. To get the data from a `promise` instance, we need
    to call the `then()` method on it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A promise''s `then()` method takes two callbacks: the first callback is the
    data callback and the second callback is an optional error callback. Let''s put
    this in use on our defined `getData()` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's clear that we can't just call `getData()` on the method straight away to
    get the data, but we need to call `.then()` on the `promise` it returns. Once
    we provide a callback, we are able to get the data and deal with it as we see
    fit.
  prefs: []
  type: TYPE_NORMAL
- en: Handling rejected promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a rejected promise, we have two ways of handling it: we can either use
    the second callback in the `.then()` method, or we can use the `.catch()` method.
    Here are the two versions available to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, we have a second callback added to the `then()` method, and
    in the second version, we chain a `catch()` method to the existing `then()` method.
    They are equivalent so you can use either one, but only one.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining – dealing with several promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most powerful feature of the promise lies in its ability to chain calls,
    thereby making code look synchronous. A chain looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the code very easy to read. You are able to tell in which order
    things happen; namely, `getData()` followed by `getMoreData()`, followed by `getEvenMoreData()`.
    Not only are we able to run the methods in the order that we want, but we are
    also able to access the data from the previous `promise`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can also see how we can add the `.catch()` method to the end to handle errors.
    The nature of chained promises are such that an error propagates all the way down
    to the `catch()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, however, quite possible to handle an error at a specific level, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two error handlers, one at a local level `.then(getMoreData, (err)
    => {})` as the second argument in the `then()` method. This has a different effect
    than only adding `.catch()` to the bottom of our call chain. If only the `.catch()`
    method at the bottom exists, then the chain is short-circuited. As it stands,
    the current chain will call the local error function, the `.catch()` method, and
    the last `.then()` method when a `promise` is rejected from the `getMoreData()`
    method. The data parameter in the last `.then()` method will, however, not be
    set if the `promise` is rejected. Chaining is powerful and gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An ordered way of calling async methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previously resolved promise data as input to our method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to handle errors globally as well as per promise, though with different
    results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have discussed callback patterns and how using promises gives your
    code that badly needed sense of order. Writing asynchronous code isn''t just about
    stopping yourself from drowning in messy code, it''s about being productive as
    well. Libraries exist out there that will make you really productive if you mean
    business about taking asynchronous coding head on. The best known libraries at
    the time of writing are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Async**: This is by far the best known. It can be found at [https://caolan.github.io/async/](https://caolan.github.io/async/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step**: This library sells itself as a library that will help you with serial
    execution, parallel execution, and promises to make error handling painless. It
    can be found at [https://github.com/creationix/step](https://github.com/creationix/step).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node fibers**: This is a very different library than the first two and can
    be thought of more as bringing a light-thread support to JavaScript. It can be
    found at [https://github.com/laverdet/node-fibers](https://github.com/laverdet/node-fibers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have so far shown callbacks and Promises. We went from the problem with
    callbacks, namely callback hell, and how Promises solved that. However, there
    is a library called **async**, which is an alternative to callbacks and promises.
    So why would we want to use the async library instead? The async library is meant
    to operate on collections in an asynchronous context. The library authors themselves
    say this about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Async is a utility module which provides straight-forward, powerful functions
    for working with asynchronous JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: So, if your asynchronous code starts to become unmanageable and you find yourself
    wanting to operate on asynchronous collections rather than a few calls here and
    there, this library might be for you. In most scenarios, promises are most likely
    what you want though.
  prefs: []
  type: TYPE_NORMAL
- en: The async library comes with a lot of nice functionality. The idea of the async
    library is to make your code look a lot better so you can focus on building things
    instead of struggling to see what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, simply install it by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: async.map()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at an example where `async` shines and is able to remove
    unnecessary code. The following example shows how we call the `fs.stat()` method
    that will asynchronously tell us about a file, such as its size, when it was created,
    and so on. A normal call `fs.stat()` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we wanted to make several calls and wanted to know the stats of several
    files? Firing off a number of calls- one per file- would mean our calls would
    come back at different times, depending on the size of the file. What if we don''t
    care about the response until everything comes back? This is what the async library
    can help us with. There is a `map()` function that will allow us to fire off several
    calls at once and only return once all the calls are done, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what makes this so great? First off, our code aims to find out some file
    statistics about every file. Let''s look at what life would look like without
    the async library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we need to introduce a states array just to collect all the
    results and even then, we probably need to add some logic to know that we are
    on the last item in the array and can therefore start processing based on the
    fact that we now have all the results. Conversely, using `async.map()` means we
    have access to a function that collects the result in an array and also waits
    until the full array has been processed and all the results have come back.
  prefs: []
  type: TYPE_NORMAL
- en: So, the takeaway from all this is that `async.map()` helps us call a list of
    asynchronous calls into one call enabling us to process all the results once every
    single call is done, not before.
  prefs: []
  type: TYPE_NORMAL
- en: async.parallel()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important method in this library is `async.parallel()`, which lets
    us send off a lot of statements in parallel, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What we can see from the previous code is that it allows us to kick off several
    calls in parallel. We specify the calls in an array that we provide to the `async.parallell([])`
    method. From what you can discern here, the functions we provide take one parameter,
    `fn`, which is the callback, for example `getOrders(fn) {}`.
  prefs: []
  type: TYPE_NORMAL
- en: async.series()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another scenario is that you might want to actually have the calls happen one
    after another. For that, we get the `async.series()` method, which we call like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running the code like this guarantees the order in which it will be run, but
    also ensures that the chain of calls does not continue if there is an error.
  prefs: []
  type: TYPE_NORMAL
- en: There are a ton of useful functions in this library and we urge you to have
    a look at the documentation at [https://caolan.github.io/async/docs.html](https://caolan.github.io/async/docs.html).
  prefs: []
  type: TYPE_NORMAL
- en: Async/await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The async/await is part of the ECMAScript standard ES2017\. This construct
    provides a synchronous-looking experience when dealing with async. Currently,
    you need something like Babel to run it in the frontend, but for Node.js it is
    sufficient to run it on version >= 8\. Async/await is currently implemented with
    a concept called generators in the background. Generators are functions that can
    be exited and re-entered later. To read more about generators, have a look at
    the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*).
    It is the new way of dealing with asynchronous code and it really helps make our
    code look synchronous, which takes away a lot of the cognitive pain associated
    with asynchronous programming.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remind ourselves of our old example, illustrating the callback hell
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We clearly see the downsides to calling the code this way. The async/await
    plays the role of a savior, in that it really cleans things up here. However,
    let''s first explain the different parts and how we can work towards refactoring
    the previous example. A method using async/await is usually the highest-level
    method; the highest level in the sense that it is the first method to be called
    in a chain of `async` methods. In the previous example, this would be the `getData()`
    method. Let''s transform `getData()` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'What we need to realize at this point, is that we need to refactor the other
    two methods, `getMoreData()` and `getEvenMoreData()`, into methods that return
    promises instead of being callback-based. Why is that, you might wonder? Well,
    when we use async/await, we want to call the code in a certain way. As hinted
    at earlier, we will use the keyword `async` in front of our `getData()` function.
    What''s more is that we want to use the keyword `await` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding code, we realize that there is a mismatch in our existing
    method signature. The mismatch is not the main reason we need to switch our implementation
    to being promise-based. The real reason is the fact the `await` keyword is able
    to unwrap promises but not callback based methods. Unwrapping means it can take
    the resulting value of our asynchronous operation and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current state of our methods before changing them into promises is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning them into promise-based methods means they should now look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are ready to return back to our `getData()` method and add
    the missing code. When we call `getMoreData()` and `getEvenMoreData()`, we can
    now use the keyword `await` to wait for the promise to resolve, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What we get now is completely synchronous-looking code. How do we retrieve
    the data from `getData()` though? Easy—it returns a `promise`. So, we can call
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The async/await is a truly powerful construct, in that it takes away a lot of
    the cognitive pain caused by callback hell and further improves upon the concept
    of promises.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered asynchronous code, when it is used, and for
    what purposes. It is clear that asynchronous code becomes harder and harder to
    read and maintain as it grows, giving rise to patterns such as callback hell.
    There are several techniques to deal with this, as described throughout this chapter.
    Changing your coding style a little is one way. Looking at constructs such as
    promises, especially in conjunction with async/await, is another way. Using async/await
    means we suddenly get something that can be likened to order in your async code.
    We have tried to keep things as framework free as possible as it is important
    to understand all the mentioned concepts without mixing them up with concepts
    from a specific application framework. One thing can be said though: Angular allows
    you to use whichever asynchronous method you want to organize your code. Doing
    HTTP calls, for example, uses an Angular service that is strongly tied to the
    RxJS library, but you are free to use a promise-based style such as the `fetch()`
    API. It is also possible to leverage async/await with Angular using Babel and
    the transformer that supports it.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has laid a foundation for what asynchronous coding is. The next
    chapter will build on that foundation by introducing the concept of **Functional
    Reactive Programming** (**FRP**). It deals more with how to reason around the
    fact that data arrives seemingly when it wants to. As messy as that sounds, even
    that can be modeled to create a sense of structure and order if we think of our
    data as a stream. More on that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
