<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">NgRx – Reduxing that Angular App</h1>
                </header>
            
            <article>
                
<p>We have reached the last chapter of this book. The time has come to understand the NgRx<span> </span><span>library. So far, different topics have been covered, making you as a reader more used to thinking about things such as immutable data structures and reactive programming. We did all this so it would be easier for you to digest what is to come in this chapter. NgRx is an implementation of Redux made for Angular, so concepts such as store, action creators, actions, selectors, and reducers are well used. What you have hopefully picked up on by reading the past chapters is how Redux works. By reading the previous </span><span>chapter, you will have discovered how what you learned about Redux translates to NgRx and its principles on how to organize your code. This chapter aims to describe the core library <kbd>@ngrx-store</kbd>, how to handle side effects with <kbd>@ngrx-effects</kbd>, and how to debug like a pro with <kbd>@ngrx/store-devtools</kbd>, among other things. </span></p>
<p class="mce-root">In this chapter, we will learn:</p>
<ul>
<li>State management with <kbd>@ngrx/store</kbd></li>
<li>Handling side effects with <kbd>@ngrx/effects</kbd></li>
<li>How to debug with <kbd>@ngrx/store-devtools</kbd></li>
<li>How to capture and transform the router state with <kbd>@ngrx/router-store</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NgRx overview</h1>
                </header>
            
            <article>
                
<p>NgRx consists of the following parts:</p>
<ul>
<li><kbd>@ngrx/store</kbd>: This is the core that contains a way for us to maintain state and dispatch actions.</li>
<li><kbd>@ngrx/effects</kbd>: This will handle side effects such as, AJAX requests, for example. </li>
<li><kbd>@ngrx/router-store</kbd>: This ensures we can integrate NgRx with the Angular routing.</li>
<li><kbd>@ngrx/store-devtools</kbd>: This will install a tool that gives us the opportunity to debug NgRx by, for example, giving us a time travel debugging functionality.</li>
<li><kbd>@ngrx/entity</kbd>: This is a library that helps us manage record collections.</li>
<li><kbd>@ngrx/schematics</kbd>: This is a scaffolder library that helps you when using NgRx.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A word on state management</h1>
                </header>
            
            <article>
                
<p>Some components must have state. When there is a need for another component to know about that very same state, the first component needs to find a way to communicate that to the other component. There are many ways to achieve this. One way is to ensure that all state that should be shared lives in a centralized store. Think of this store as a single source of truth, from which all components can read. Every state does not necessarily need to end up in the centralized store, as the state may only concern a specific component. Before NgRx and Redux, one way of solving this was to put everything in a globally accessible object or service. The store, as we mentioned, is just that. It is globally accessible in the sense that it can be injected into any component that might need it. A word of caution; even though it is tempting to put all of our state in our store, we really shouldn't. State that we notice needs to be shared between components is worth putting there. </p>
<p>Another benefit we get from having a centralized store is that it is very easy to save down the application's state for later recovery. If state only lives in one place, a user, or the system, can easily persist that state to a backend so that next time, if they want to continue from where they left off, they can easily do so by querying the backend for that state. So, there does exist another reason for wanting a centralized store other than wanting to share the data between many components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@ngrx/store – state management</h1>
                </header>
            
            <article>
                
<p>All of the files in this section points to <kbd>Chapter9/State</kbd> project.</p>
<p>This is the moment we have been waiting for. How do we actually get started? It's really easy. Let's first ensure we have installed Angular CLI. We do so by typing the following in our terminal:</p>
<pre><strong>npm install -g @angular/cli</strong></pre>
<p>At this point, we need an Angular project. We use the Angular CLI for that, and scaffold ourselves a new project using the following command:</p>
<pre><strong>ng new &lt;my new project&gt;</strong></pre>
<p>Once the scaffolding process is done, we navigate to our newly created director project with a simple <kbd>cd &lt;project dir&gt;</kbd>.We want to use the core functionality provided in the <kbd>@ngrx/store</kbd> library, therefore we install it by typing the following:</p>
<pre><strong>npm install @ngrx/store --save</strong> </pre>
<p>Let's now open up the <kbd>app.module.ts</kbd> <span>file </span>in our scaffolded project. The time has come to import and register NgRx with <kbd>AppModule</kbd>:</p>
<pre>// app.module.ts<br/><br/>import { BrowserModule } from "@angular/platform-browser";<br/>import { NgModule } from "@angular/core";<br/><strong>import { StoreModule } from "@ngrx/store";</strong><br/>import { AppComponent } from "./app.component";<br/><strong>import { counterReducer } from "./reducer";</strong><br/><br/>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    <strong>StoreModule.forRoot({ counter: counterReducer }),</strong><br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</pre>
<p>In the preceding code, we've highlighted the important part, which is importing <kbd>StoreModule</kbd> and registering it with <kbd>AppModule</kbd> by typing:</p>
<pre>StoreModule.forRoot({ counter: counterReducer })</pre>
<p>Here, we are telling the store what state should exist, which is <kbd>counter</kbd>, and that <kbd>counterReducer</kbd> is the reducer meant to take care of that slice of state. As you can see, the code doesn't quite work yet because we haven't created <kbd>counterReducer</kbd> yet, let's do that next:</p>
<pre>// reducer.ts<br/><br/>export function counterReducer(state = 0, action) {<br/>  switch(action.type) {<br/>    case 'INCREMENT':<br/>      return state + 1;<br/>    case 'DECREMENT':<br/>      return state -1;<br/>    default:<br/>      return state;<br/>  }<br/>}</pre>
<p>Hopefully, you have read <a href="e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml">Chapter 8</a>, <em>Redux</em>, and understand why we write the reducer file as we have done. Let's recap a bit, and declare that a reducer is just a function that takes a state and produces a new state given an action. It's also important to stress that reducers are so called pure functions that do not change the state, but produce a new state, given the old state plus the incoming action. Let's show here how we would theoretically use our reducer if we wanted to use it outside of Redux. We do this just to demonstrate how reducers work:</p>
<pre>let state = counterReducer(0, { type: 'INCREMENT' });<br/>// state is 1<br/>state = counterReducer(state, { type: 'INCREMENT' });<br/>// state is 2</pre>
<p>As we can see from this, we start off with an initial value of <kbd>0</kbd>, and it computes a new value that results in <kbd>1</kbd>. Upon the second execution of the function, we provide it with the existing state, which has the value <kbd>0</kbd>. This results in our state now being <kbd>2</kbd>. This may look simple, but this is pretty much as complicated as a reducer can get. Normally, you wouldn't execute the reducer function yourself but rather register it with the store and dispatch actions towards the store. This will lead to the reducer being invoked. So, how do we tell the store to dispatch? Simple, we use the function <kbd>dispatch()</kbd> on the store. For this code, let's move to the <kbd>app.component.ts</kbd> file. We also need to create a file called <kbd>app-state.ts</kbd><span>,</span> which is an interface, a typed representation of our store:</p>
<pre>// app-state.ts<br/>export interface AppState {<br/>  counter: number;<br/>}<br/><br/>// app.component.ts<br/>import { Component } from "@angular/core";<br/><strong>import { Store } from "@ngrx/store";</strong><br/><strong>import { Observable } from "rxjs/Observable";</strong><br/><strong>import { AppState } from "./app-state";</strong><br/><br/>@Component({<br/>  selector: "app-root",<br/>  <strong>template:</strong> `<br/>  {{ counter$ | async }}<br/> `<br/>})<br/>export class AppComponent {<br/>  counter$;<br/><br/>  constructor(<strong>private store: Store&lt;AppState&gt;</strong>) {<br/>    <strong>this.counter$ = store.select("counter");</strong><br/>  }<br/>}</pre>
<p>What we can see from the preceding code is how we inject a store service into the constructor, like so:</p>
<pre>constructor(private store: Store&lt;AppState&gt;) {<br/>  this.counter$ = store.select("counter");<br/>}</pre>
<p>Thereafter, we call <kbd>store.select("count")</kbd>, which means we are asking our store for the <kbd>count</kbd> property part of its state as that's all this component cares about. A call <kbd>store.select()</kbd> returns an <kbd>Observable</kbd> that when resolved contains a value. We can easily show this value by adding it to the template markup, like so:</p>
<pre>{{ counter$ | async }}</pre>
<p>That takes care of getting and displaying the state. What about dispatching an action? The store instance has a method on it called <kbd>dispatch()</kbd>, which takes an object containing the property type. So the following is perfectly good input:</p>
<pre>// example input to a store<br/><br/>store.dispatch({ type: 'INCREMENT' });<br/>store.dispatch({ type: 'INCREMENT', payload: 1 });<br/>store.dispatch({})<br/>// will throw an error, as it is missing the type property</pre>
<p>Now, let's build out our component a little, and create some methods and markup that will allow us to dispatch actions and see the end result of doing so:</p>
<pre>// app.component.ts<br/><br/>import { Component } from "@angular/core";<br/>import { Store } from "@ngrx/store";<br/>import { AppState } from "./app-state";<br/><br/>@Component({<br/>  selector: "app-root",<br/>  template: `<br/>  {{ counter$ | async }}<br/>  <strong>&lt;button (click)="increment()" &gt;Increment&lt;/button&gt;</strong><br/><strong>  &lt;button (click)="decrement()" &gt;Decrement&lt;/button&gt;</strong><br/> `<br/>})<br/>export class AppComponent {<br/>  counter$;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    this.counter$ = store.select("counter");<br/>  }<br/><br/>  <strong>increment() {</strong><br/><strong>    this.store.dispatch({ type: 'INCREMENT' });</strong><br/><strong>  }</strong><br/><br/><strong>  decrement() {</strong><br/><strong>    this.store.dispatch({ type: 'DECREMENT' }); </strong><br/><strong>  }</strong><br/>}</pre>
<p>We added the <kbd>increment()</kbd> and <kbd>decrement()</kbd> methods to the class body, and also added two buttons to the markup that invoke said functions. Trying this out, we can see how our UI is updated for every press of the button. The reason for this working is, of course, that each dispatched action calls our <kbd>counterReducer</kbd> implicitly, and also because we hold a reference to our state in the form of the <kbd>counter$</kbd> variable. As this is an <kbd>Observable</kbd>, it means it will be updated when a change happens. The change is then pushed out to our <kbd>counter$</kbd> variable when an action is dispatched. It's simple, but powerful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A more complex example – a list</h1>
                </header>
            
            <article>
                
<p>We have so far learned how to set up NgRx by importing and registering its module. We have also been taught about the <kbd>select()</kbd> function that gives us a slice of state, and the <kbd>dispatch()</kbd> function that allows us to dispatch an action. These are the basics, we will use these very same basics and create a new reducer to reinforce what we already know, while introducing the concept payload.</p>
<p>We need to do the following:</p>
<ul>
<li>Tell the store we have a new state, <kbd>jedis</kbd></li>
<li>Create a <kbd>jediListReducer</kbd> and register it with the store</li>
<li>Create a component that supports showing our <kbd>jediList</kbd>, but is also able to dispatch actions that will change our slice of state  <kbd>jedis</kbd></li>
</ul>
<p>Let's get down to business by defining our reducer, <kbd>jediListReducer</kbd>:</p>
<pre>// jedi-list.reducer.ts<br/>export function jediListReducer(state = [], action) {<br/>  switch(action.type) {<br/>    case 'ADD_JEDI':<br/>      return [ ...state, { ...action.payload }];<br/>    case 'REMOVE_JEDI':<br/>      return state.filter(jedi =&gt; jedi.id !== action.payload.id);<br/>    case 'LOAD_JEDIS':<br/>      return action.payload.map(jedi =&gt; ({...jedi}));<br/>    default:<br/>      return state;<br/>  }<br/>}</pre>
<p>Let's explain what goes on here for each case in our switch. First off, we have <kbd>ADD_JEDI</kbd>. We take our <kbd>action.payload</kbd> and add it to the list. Or technically, we take our existing list and construct a new list based on the old list, plus our new list item found in <kbd>action.payload</kbd>.  Secondly we have <kbd>REMOVE_JEDI</kbd> that uses the <kbd>filter()</kbd> function to take away the list item that we don't want to see. Lastly we have <kbd>LOAD_JEDIS</kbd> that takes in an existing list and replaces our state. Now, let's demo this reducer by invoking it here:</p>
<pre>let state = jediListReducer([], { type: 'ADD_JEDI', payload : { id: 1, name: 'Yoda' });<br/>// now contains [{ id: 1, name: 'Yoda' }]<br/><br/>state = jediListReducer(state, { type: 'ADD_JEDI', payload: { id: 2, name: 'Darth Vader'} });<br/>// now contains [{ id: 1, name: 'Yoda' }, { id: 2, name: 'Darth Vader'}];<br/><br/>state = jediListReducer(state, { type: 'REMOVE JEDI', payload: { id: 1 } });<br/>// now contains [{ id: 2, name: 'Darth Vader'}];<br/><br/>state = jediListReducer(state, { type: 'LOAD_JEDIS', payload: [] });<br/>// now contains []</pre>
<p>Now, let's register this reducer with the store. We will therefore return to <kbd>app.module.ts</kbd>:</p>
<pre>// app.module.ts<br/><br/>import { BrowserModule } from "@angular/platform-browser";<br/>import { NgModule } from "@angular/core";<br/>import { StoreModule } from "@ngrx/store";<br/>import { AppComponent } from "./app.component";<br/>import { counterReducer } from "./reducer";<br/><strong>import { jediListReducer } from "./jedi-list-reducer";</strong><br/><br/>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({ <br/>      count: counterReducer, <br/><strong>      jediList: jediListReducer</strong> }),<br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</pre>
<p>Because we just added a new state to our store, we should make the <kbd>app-state.ts</kbd> file aware of it, and we should also create a <kbd>Jedi</kbd> model so we can use that in our component later on:</p>
<pre>// jedi.model.ts<br/><br/>export interface Jedi {<br/>  id: number;<br/>  name: string;<br/>}<br/><br/>// app-state.ts<br/><br/>import<span> { Jedi } </span><span>from</span><span> </span><span>"./jedi.model"</span><span>;<br/></span><br/>export<span> </span><span>interface</span><span> AppState {<br/></span>  counter<span>:</span><span> number;</span><span><br/></span>  <strong>jediList:</strong><span><strong> Array&lt;Jedi&gt;;</strong><br/></span>}</pre>
<p>From the preceding code, we can see that <kbd>jediListReducer</kbd>, as well as the state <kbd>jediList</kbd>, is added to the object that serves as input to the <kbd>StoreModule.forRoot()</kbd> function. This means that NgRx is aware of this state and will let us retrieve it and dispatch actions to it. To do so, let's build a component with just that. We need to create the <kbd>jedi-list.component.ts</kbd> file:</p>
<pre>// jedi-list.component.ts<br/><br/>import { Component } from "@angular/core";<br/>import { Store } from "@ngrx/store";<br/>import { AppState } from "../app-state";<br/>import { Jedi } from "./jedi.model";<br/><br/>@Component({<br/>  selector: "jedi-list",<br/>  template: `<br/>  &lt;div *ngFor="let jedi of list$ | async"&gt;<br/>    {{ jedi.name }}&lt;button (click)="remove(jedi.id)" &gt;Remove&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;input [(ngModel)]="newJedi" placeholder="" /&gt;<br/>  &lt;button (click)="add()"&gt;Add&lt;/button&gt;<br/>  &lt;button (click)="clear()" &gt;Clear&lt;/button&gt;<br/> `<br/>})<br/>export class JediListComponent {<br/>  list$: Observable&lt;Array&lt;Jedi&gt;&gt;;<br/>  counter = 0;<br/>  newJedi = "";<br/><br/>  constructor(<strong>private store: Store&lt;AppState&gt;</strong>) {<br/>    <strong>this.list$ = store.select("jediList");</strong><br/>  }<br/><br/>  add() {<br/>    <strong>this.store.dispatch({ </strong><br/><strong>      type: 'ADD_JEDI', </strong><br/><strong>      payload: { id: this.counter++, name: this.newJedi } </strong><br/><strong>    });</strong><br/>    this.newJedi = '';<br/>  }<br/><br/>  remove(id) {<br/>    <strong>this.store.dispatch({ type: 'REMOVE_JEDI', payload: { id } });</strong> <br/>  }<br/><br/>  clear() {<br/>    <strong>this.store.dispatch({ type: 'LOAD_JEDIS', payload: [] });</strong><br/>    this.counter = 0;<br/>  }<br/>}</pre>
<p>The last thing we need to do is to register this component with our module, and we should have a working application:</p>
<pre>// app.module.ts<br/><br/>import { BrowserModule } from "@angular/platform-browser";<br/>import { NgModule } from "@angular/core";<br/>import { StoreModule } from "@ngrx/store";<br/>import { AppComponent } from "./app.component";<br/>import { counterReducer } from "./reducer";<br/>import { jediListReducer } from "./jedi-list.reducer";<strong> </strong> <br/><strong>import { JediListComponent } from './jedi-list.component';</strong><br/><br/>@NgModule({<br/>  declarations: [AppComponent, <strong>JediListComponent</strong> ],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({ count: counterReducer, jediList: JediListReducer }),<br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Best practices</h1>
                </header>
            
            <article>
                
<p>The following files points to the demo project <kbd>Chapter9/BestPractices</kbd>.</p>
<p>So far, we have created some working code, but it could look a lot better, and be less error prone as well. There are steps we can take to improve the code, those are:</p>
<ul>
<li>Get rid of so-called magic strings and rely on constants</li>
<li>Add a default state to your reducer</li>
<li>Create so-called action creators</li>
<li>Move everything into a dedicated module and split up it up into several components</li>
</ul>
<p>Let's have a look at our first bullet point. Given the type of actions we perform on our <kbd>jediList</kbd>, we can create a <kbd>constants.ts</kbd> file for them, like so:</p>
<pre>// jedi.constants.ts<br/><br/>export const ADD_JEDI = 'ADD_JEDI';<br/>export const REMOVE_JEDI = "REMOVE_JEDI";<br/>export const LOAD_JEDIS ="LOAD_JEDIS";</pre>
<p>Now, when we refer to these actions we can instead import this file and use these constants instead, decreasing the risk of us mistyping.</p>
<p>The second thing we can do is to simplify the creation of actions by creating the so-called action creator. We are so far used to typing the following to create an action:</p>
<pre>const action = { type: 'ADD_JEDI', payload: { id: 1, name: 'Yoda' } };</pre>
<p>A better habit here is to create a function that does this for us. For the case with the list reducer, there are three possible actions that can take place, so let's put all these in a <kbd>actions.ts</kbd><span> file:</span></p>
<pre>// jedi.actions.ts<br/><br/>import<span> { <br/>  ADD_JEDI, <br/>  REMOVE_JEDI, <br/>  LOAD_JEDIS <br/>} </span><span>from</span><span> </span><span>"./jedi.constants"</span><span>;<br/></span><br/>export<span> </span><span>const</span><span> addJedi </span><span>=</span><span> (id, name) </span><span>=&gt;</span><span> ({ type: ADD_JEDI, payload: { id, name } });<br/></span>export<span> </span><span>const</span><span> removeJedi </span><span>=</span><span> (id) </span><span>=&gt;</span><span> ({ type: REMOVE_JEDI, payload:{ id } });<br/></span><span>export const loadJedis = (jedis) =&gt; ({ type: LOAD_JEDIS, payload: jedis });</span></pre>
<p>The point of creating the <kbd>actions.ts</kbd> file was so that we would have to write less code when we dispatch actions. Instead of writing the following:</p>
<pre>store.dispatch({ type: 'ADD_JEDI', payload: { id: 3, name: 'Luke' } });</pre>
<p>We can now write this as:</p>
<pre>// example of how we can dispatch to store using an actions method<br/><br/>import { addJedi } from './jedi.actions';<br/>store.dispatch(addJedi(3, 'Luke'));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A cleanup example</h1>
                </header>
            
            <article>
                
<p>The following scenario can be found in the <strong><kbd>Chapter9/BestPractices</kbd></strong> folder of the code repository. </p>
<p>Let's explain where we are coming from, and why there might be a need to clean up your code. If you are starting out with a very simple app, you might add the reducer, the actions, and components in the root module of your project. This might create a mess as soon as you want to add another component. Let's illustrate what our file structure might look like before we start cleaning up:</p>
<pre>app.component.ts<br/>app.module.ts<br/>jedi-list-reducer.ts<br/>jedi-constants.ts<br/>jedi-list-actions.ts<br/>jedi-list-component.ts</pre>
<p>From this,  it's pretty clear that this will only hold up if our app will only consist of that one component. As soon as we add more components, things will start to look messy.</p>
<p>Let's list what we need to do to create a better file structure, but also utilize the action creator, constants, and reducers in the best way possible:</p>
<ul>
<li>Create a dedicated feature module and directory</li>
<li>Create action constants that the reducer and actions file can use</li>
<li>Create an action creator file with all the actions we mean to perform</li>
<li>Create a reducer that handles dispatches</li>
<li>Create a <kbd>JediList</kbd> component that is able to handle all actions we mean to use</li>
<li>Register our reducer and state with the store</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create a dedicated directory and feature module</h1>
                </header>
            
            <article>
                
<p>For that reason, we want to place everything in a dedicated directory, <kbd>jedi</kbd>. The easiest way to do that is to use the Angular CLI and run the following commands:</p>
<pre><strong>ng g module jedi</strong></pre>
<p>The preceding code will generate the following files:</p>
<pre><strong>jedi/</strong><br/><strong>  jedi.module.ts</strong></pre>
<p>Place yourself in your newly created <kbd>jedi</kbd> directory and type the following:</p>
<pre><strong>ng g component jedi-list</strong></pre>
<p>This will add the following structure to your <kbd>jedi</kbd> directory:</p>
<pre>jedi/<br/>  jedi.module.ts<br/>  <strong>jedi-list/</strong><br/><strong>    jedi-list.component.html</strong><br/><strong>    jedi-list.component.ts</strong><br/><strong>    jedi-list.component.css</strong><br/><strong>    jedi-list.component.spec.ts</strong></pre>
<p>However, we have created the <kbd>jedi-list.component</kbd> and its belonging files in a previous section, so we will remove those scaffolded files for now and just move in the already created files under the <kbd>jedi-list</kbd> directory. So, your directory should look like:</p>
<pre>jedi/<br/>  jedi.module.ts<br/>  <strong>jedi-list/</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Add reducer and constants</h1>
                </header>
            
            <article>
                
<p>Let's create our reducer, like so:</p>
<pre>// jedi/jedi-list/jedi-list.reducer.ts<br/><br/>import { <br/>  ADD_JEDI, <br/>  REMOVE_JEDI, <br/>  LOAD_JEDIS <br/>} from './jedi-list.constants.ts'<br/><br/>const initialState = [];<br/><br/>export function jediListReducer(state = initialState, action) {<br/>  switch(action.type) {<br/>    case ADD_JEDI:<br/>      return [ ...state, { ...action.payload }];<br/>    case REMOVE_JEDI:<br/>      return state.filter(jedi =&gt; jedi.id !== action.payload.id);<br/>    case LOAD_JEDIS:<br/>      return action.payload.map(jedi =&gt; ({ ...jedi}));<br/>    default:<br/>      return state;<br/>  }<br/>}</pre>
<p>Our next order of business is our constants file, which has already been created and just need to move, like so:</p>
<pre>// jedi/jedi-list/jedi-list-constants.ts<br/><br/>export const ADD_JEDI = 'ADD_JEDI';<br/>export const REMOVE_JEDI = "REMOVE_JEDI";<br/>export const LOAD_JEDIS ="LOAD_JEDIS";</pre>
<p>A general tip is if you find the number of components and files growing, consider creating a dedicated directory for it.</p>
<p>Next up is the action creator file that we have also already created, and that we just need to move to our <kbd>jedi</kbd> directory, like so:</p>
<pre>// jedi/jedi-list/jedi-list-actions.ts<br/><br/>import<span> { ADD_JEDI, REMOVE_JEDI, LOAD_JEDIS } </span><span>from</span><span> </span><span>"./jedi-list-constants"</span><span>;<br/></span><br/>let counter = 0;<br/><br/>export<span> </span><span>const</span><span> addJedi </span><span>=</span><span> (name) </span><span>=&gt;</span><span> ({ type: ADD_JEDI, payload: { id: counter++, name }});<br/></span>export<span> </span><span>const</span><span> removeJedi </span><span>=</span><span> (id) </span><span>=&gt;</span><span> ({ type: REMOVE_JEDI, payload: { id } });<br/></span><span>export const loadJedis = (jedis) =&gt; ({ type: LOAD_JEDIS, payload: jedis });</span></pre>
<p>Our directory should now look like this:</p>
<pre>jedi/<br/>  jedi.module.ts<br/>  jedi-list/<strong><br/></strong>  <strong>  jedi-list.reducer.ts</strong><br/><strong>    jedi-list.actions.ts</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving the component to our jedi directory</h1>
                </header>
            
            <article>
                
<p>The next point is about moving our <kbd>JediListComponent</kbd> to our <kbd>jedi</kbd> directory, like so:</p>
<pre>// jedi/jedi-list/jedi-list.component.ts<br/><br/>import { Component } from "@angular/core";<br/>import { Store } from "@ngrx/store";<br/>import { Observable } from "rxjs/Observable";<br/>import { AppState } from "../app-state";<br/><strong>import { <br/>  addJedi, <br/>  removeJedi, <br/>  loadJedis <br/>} from './jedi-list-actions';</strong><br/><br/>@Component({<br/>  selector: "jedi-list",<br/>  template: `<br/>  &lt;div *ngFor="let jedi of list$ | async"&gt;<br/>    {{ jedi.name }}&lt;button (click)="remove(jedi.id)" &gt;Remove&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;input [(ngModel)]="newJedi" placeholder="" /&gt;<br/>  &lt;button (click)="add()"&gt;Add&lt;/button&gt;<br/>  &lt;button (click)="clear()" &gt;Clear&lt;/button&gt;<br/> `<br/>})<br/>export class JediListComponent {<br/>  list$: Observable&lt;number&gt;;<br/>  counter = 0;<br/>  newJedi = "";<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    this.list$ = store.select("jediList");<br/>  }<br/><br/>  add() {<br/>    this.store.dispatch(<strong>addJedi(this.newJedi)</strong>);<br/>    this.newJedi = '';<br/>  }<br/><br/>  remove(id) {<br/>    this.store.dispatch(<strong>removeJedi(id)</strong>); <br/>  }<br/><br/>  clear() {<br/>    this.store.dispatch(<strong>loadJedis([])</strong>);<br/>    this.counter = 0;<br/>  }<br/>}</pre>
<p>After moving our <kbd>jedi-list</kbd> component, our directory should now look like the following:</p>
<pre>jedi/<br/>  jedi.module.ts<br/>  jedi-list/<strong><br/></strong>    jedi-list.reducer.ts<br/>    jedi-list.actions.ts<strong><br/></strong>    <strong>jedi-list.component.ts</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering our reducer with the store</h1>
                </header>
            
            <article>
                
<p>Lastly, we just need to do a slight update to the <kbd>app.module.ts</kbd> file to have it point correctly to our <kbd>JediListReducer</kbd>, like so:</p>
<pre>// app.module.ts<br/><br/>import { BrowserModule } from "@angular/platform-browser";<br/>import { NgModule } from "@angular/core";<br/>import { StoreModule } from "@ngrx/store";<br/>import { AppComponent } from "./app.component";<br/>import { counterReducer } from "./reducer";<br/><strong>import { JediModule } from './jedi/jedi.module';</strong><br/><strong>import { jediListReducer } from "./jedi/jedi-list/jedi-list.reducer"; </strong> <br/><br/>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({ <br/>      counter: counterReducer, <br/><strong>      jediList: JediListReducer</strong> <br/>    }),<br/>    <strong>JediModule</strong><br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export class AppModule {}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging types and feature modules</h1>
                </header>
            
            <article>
                
<p>The following files is pointing to the demo project <kbd>Chapter9/FeatureModules</kbd>.</p>
<p>OK, one thing we can definitely improve is how we tell the <kbd>StoreModule</kbd> about what state and reducers exist in our app. Let's do a quick recap and look at its current state:</p>
<pre>// from app.module.ts<br/><br/>StoreModule.forRoot({ count: counterReducer, <strong>jediList: JediListReducer</strong> })</pre>
<p>So, we are essentially feeding the <kbd>forRoot()</kbd> method an object. What's wrong with that? Well, imagine you have ten different feature modules and every feature module may have three to four states, then the object you pass to <kbd>forRoot()</kbd> will grow in size and the number of imports that you need to do in your <kbd>app.module.ts</kbd> will grow. It will look something like this:</p>
<pre>StoreModule.forRoot({ <br/>  featureModuleState1: featureModuleState1Reducer, <br/>  featureModuleState2 : featureModuleState2Reducer<br/>  .<br/>  .<br/>  .<br/>  .<br/>  .<br/>  .<br/>  .<br/>  .<br/>})</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going from forRoot() to forFeature()</h1>
                </header>
            
            <article>
                
<p>To solve the mess we are creating in <kbd>app.module.ts,</kbd> we will now use a method called <kbd>forFeature()</kbd> on <kbd>StoreModule</kbd> that will allow us to set up the states we need per feature module. Let's take the existing setup and refactor that:</p>
<pre>// app.module.ts<br/><br/>StoreModule.forRoot({  }) // this would be empty</pre>
<p>We move our two reducer entries to their respective feature modules, <kbd>counter.module.ts</kbd> and <kbd>jedi.module.ts</kbd>. That would now look like this:</p>
<pre>// counter.module.ts<br/>@NgModule({<br/>  imports: [StoreModule.forFeature(<br/>    // add reducer object here<br/>  )]<br/>})<br/><br/>// jedi.module.ts<br/>@NgModule({<br/>  imports : [StoreModule.forFeature(<br/>  // add reducer here<br/>  )]<br/>})</pre>
<p>We left out the implementation on purpose here because we need to take a step back. Remember when we called <kbd>StoreModule.forRoot()</kbd>, we could just pass it an object. It doesn't look quite the same with <kbd>forFeature()</kbd>. There is a little bit of difference, so let's try to explain what that difference is. We are used to setting up our store by passing it an object, which looks like this:</p>
<pre>{<br/>  sliceOfState : reducerFunction,<br/>  anotherSliceOfState: anotherReducerFunction<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up forFeature() from string to selection function</h1>
                </header>
            
            <article>
                
<p>We can set it up in pretty much the same way, but we need to pass it the name of a feature as well. Let's take our <kbd>counter.module.ts</kbd> and add a little code to it:</p>
<pre>// counter.module.ts<br/><br/>@NgModule({<br/>  imports: [<br/>    StoreModule.forFeature('counter',{<br/>      data: counterReducer    <br/>    })<br/>  ]<br/>})</pre>
<p>This will change how we select our state, though. Imagine we are inside of <kbd>counter.component.ts</kbd> with the current implementation looking like the following:</p>
<pre>// counter.component.ts<br/><br/>@Component({<br/>  selector: 'counter',<br/>  template: `{{ counter$ | async }}`<br/>})<br/>export class CounterComponent {<br/>  counter$;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    // this needs to change..<br/>    this.counter$ = this.store.select('counter');<br/>  }<br/>}</pre>
<p>Because we changed what the state looked like in <kbd>counter.module.ts</kbd>, we now need to reflect that in <kbd>counter.component.ts</kbd>, like so:</p>
<pre>// counter.component.ts<br/>@Component({<br/>  selector: 'counter',<br/>  template: `{{ counter$ | async }}`<br/>})<br/>export class CounterComponent {<br/>  counter$;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    <strong>this.counter$ = this.store.select((state) =&gt; {</strong><br/><strong>      return state.counter.data;</strong><br/><strong>    });</strong><br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing NgRx types for setting up the state</h1>
                </header>
            
            <article>
                
<p>Up to this point, we have learned how we move the store state declaration from <kbd>app.module.ts</kbd> and register it in each  feature module instead. This will provide us with a little more order. Let's take a close look at the types used for registering state. <kbd>ActionReducerMap</kbd> is a type we have been using implicitly so far. We have been using it every time we call <kbd>StoreModule.forRoot()</kbd> or <kbd>StoreModule.forFeature()</kbd>. We have been using it in the sense that, the object we pass containing state and their reducers consists of this type. Let's prove that is the case by turning to our <kbd>counter.module.ts</kbd>:</p>
<pre>// counter.module.ts<br/><br/>@NgModule({<br/>  imports: [<br/>    StoreModule.forFeature('counter',{<br/>      data: counterReducer    <br/>    })<br/>  ]<br/>})</pre>
<p>Let's change that a bit, to this:</p>
<pre>// counter.reducer.ts<br/><br/><strong>export interface CounterState = {</strong><br/><strong>  data: number</strong><br/><strong>};</strong><br/><br/><strong>export reducer: ActionReducerMap&lt;CounterState&gt; = {</strong><br/><strong>  data: counterReducer</strong><br/><strong>}</strong><br/><br/>// counter.module.ts<br/><br/>@NgModule({<br/>  imports: [<br/>    StoreModule.forFeature('counter', <strong>reducer</strong>)<br/>  ]<br/>})</pre>
<p>Now, we can see that we are leveraging <kbd>ActionReducerMap</kbd>, which is a generic that forces us to provide it with a type. In this case, the type is <kbd>CounterState</kbd>. Running this code should just work. So, why use <kbd>ActionReducerMap</kbd> explicitly like this?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Giving forFeature() a type</h1>
                </header>
            
            <article>
                
<p>Well, the <kbd>forFeature()</kbd> method is a generic as well, and we can specify this one explicitly like so:</p>
<pre>// counter.module.ts<br/><br/>const CounterState = {<br/>  data: number<br/>};<br/><br/>const reducers: ActionReducerMap&lt;CounterState&gt; = {<br/>  data: counterReducer<br/>}<br/><br/>@NgModule({<br/>  imports: [<br/>    StoreModule.forFeature<strong>&lt;CounterState, Action&gt;</strong>('counter', reducers)<br/>  ]<br/>})</pre>
<p>This protects us from adding a state mapping object that it does not expect to the <kbd>forFeature()</kbd> method. For instance, the following would render an error:</p>
<pre>// example of what NOT to do<strong><br/><br/>interface State {<br/>  test: string;<br/>}</strong><br/><br/><strong>function testReducer(state ="", action: Action) {<br/>  switch(action.type) {<br/>    default:<br/>      return state;<br/>  }</strong><br/><strong>}</strong><br/><br/><strong>const reducers: ActionReducerMap&lt;State&gt; = {<br/>  test: testReducer</strong><br/><strong>};</strong><br/><br/>@NgModule({<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forFeature&lt;<strong>CounterState</strong>, Action&gt;(<span>'counter'</span><span>, <strong>reducers</strong>)</span><br/>  ],<br/>  exports: [CounterComponent, CounterListComponent],<br/>  declarations: [CounterComponent, CounterListComponent],<br/>  providers: [],<br/>})<br/>export<span> </span><span>class</span><span> CounterModule { }</span></pre>
<p>The reason for this is that we are providing the wrong type to the <kbd>forFeature()</kbd> method. It expects a reducer parameter to be something of type <kbd>ActionReducerMap&lt;CounterState&gt;</kbd>, which it clearly is not, as we are sending in <kbd>ActionReducerMap&lt;State&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Several states in the same feature module</h1>
                </header>
            
            <article>
                
<p><span>The following scenario can be found in the </span><kbd>Chapter9/TypesDemo</kbd><span> folder of the code repository. </span></p>
<p>OK, so now we know about the <kbd>ActionReducerMap</kbd> type, and we also know that we can provide a type to the <kbd>forFeature()</kbd> method and make it safer to use. What happens if we've got several states in our feature module, what then? The answer is quite simple, but let's first have a closer look at what we mean exactly by several states. Our counter module contains the <kbd>counter.value</kbd> state. This is displayed in our <kbd>counter.component.ts</kbd>. If we want to add a <kbd>counter.list</kbd> state, we need to add the supporting constants, reducers, actions, and a component file so we can properly display it. Our file structure should therefore look like the following:</p>
<pre>/counter<br/>  counter.reducer.ts<br/>  counter.component.ts<br/>  counter.constants.ts<br/>  counter.actions.ts<br/>  /counter-list<br/><strong>    counter-list.reducer.ts</strong><br/><strong>    counter-list.component.ts</strong><br/><strong>    counter-list.constants.ts</strong><br/><strong>    counter-list.action.ts<br/></strong>    <strong>counter.model.ts</strong><br/>counter.module.ts</pre>
<p>We need to add implementation for all of these bold files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the counter-list reducer</h1>
                </header>
            
            <article>
                
<p>Let's start off with the reducer:</p>
<pre>// counter/counter-list/counter-list.reducer.ts<br/><br/>import<span> {<br/></span>  ADD_COUNTER_ITEM,<br/>  REMOVE_COUNTER_ITEM<br/>} <span>from</span><span> </span><span>"./counter-list.constants"</span><span>;<br/></span>import<span> { ActionPayload } </span><span>from</span><span> </span><span>"../../action-payload"</span><span>;<br/></span>import<span> { Counter } </span><span>from</span><span> </span><span>"./counter.model"</span><span>;<br/></span><br/>export<span> </span><span>function</span><span> counterListReducer(state </span><span>=</span><span> [], action</span><span>:</span><span> ActionPayload&lt;Counter&gt;) {<br/></span>  switch<span> (action.type) {<br/></span>    case<span> ADD_COUNTER_ITEM:<br/></span>      return<span> [</span><span>...</span><span>state, Object.assign(action.payload)];<br/></span>    case<span> REMOVE_COUNTER_ITEM:<br/></span>      return<span> state.filter(item </span><span>=&gt;</span><span> item.id </span><span>!==</span><span> action.payload.id);<br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}</pre>
<p>This reducer supports two types, <kbd>ADD_COUNTER_ITEM</kbd> and <kbd>REMOVE_COUNTER_ITEM</kbd>, which will let us add and remove items from the list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the component</h1>
                </header>
            
            <article>
                
<p>This one comes in two parts, the HTML template and the class file. Let's start with the class file:</p>
<pre>// counter/counter-list/counter-list.component.ts<br/><br/>import<span> { Component, OnInit } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { AppState } </span><span>from</span><span> </span><span>"../../app-state"</span><span>;<br/></span>import<span> { Store } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { addItem, removeItem } </span><span>from</span><span> </span><span>"./counter-list.actions"</span><span>;<br/><br/></span>@Component({<br/>  selector: <span>"app-counter-list"</span><span>,<br/></span>  templateUrl: <span>"./counter-list.component.html"</span><span>,<br/></span>  styleUrls: [<span>"./counter-list.component.css"</span><span>]<br/></span>})<br/>export<span> </span><span>class</span><span> CounterListComponent </span><span>implements</span><span> OnInit {<br/></span>  list$;<br/>  newItem<span>:</span><span> string;<br/></span>  counter<span>:</span><span> number;<br/><br/></span>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.counter </span><span>=</span><span> </span><span>0</span><span>;<br/></span>    this<span>.list$ </span><span>=</span><span> </span><span>this</span><span>.store.select(state </span><span>=&gt;</span><span> state.counter.list);<br/></span>  }<br/><br/>  ngOnInit() {}<br/><br/>  add() {<br/>    this<span>.store.dispatch(addItem(</span><span>this</span><span>.newItem, </span><span>this</span><span>.counter</span><span>++</span><span>));<br/></span>    this<span>.newItem </span><span>=</span><span> </span><span>""</span><span>;<br/></span>  }<br/><br/>  remove(id) {<br/>    this<span>.store.dispatch(removeItem(id));<br/></span>  }<br/>}</pre>
<p>The HTML template file is quite simple, and looks like this:</p>
<pre>// counter/counter-list/counter-list.component.html<br/><br/>&lt;<span>div</span><span>&gt;<br/></span>  &lt;<span>input</span><span> </span><span>type</span><span>=</span><span>"text"</span><span> [(</span><span>ngModel</span><span>)]=</span><span>"newItem"</span><span>&gt;<br/></span>  &lt;<span>button</span><span> (</span><span>click</span><span>)=</span><span>"add()"</span><span>&gt;</span><span>Add</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>&lt;/<span>div</span><span>&gt;<br/></span>&lt;<span>div</span><span> *</span><span>ngFor</span><span>=</span><span>"let item of list$ | async"</span><span>&gt;<br/></span>  {{item.title}}<br/>  &lt;<span>button</span><span> (</span><span>click</span><span>)=</span><span>"remove(item.id)"</span><span>&gt;</span><span>Remove</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>&lt;/<span>div</span><span>&gt;</span></pre>
<p>In the preceding code, we are supporting the following:</p>
<ul>
<li>Showing a list of counter objects</li>
<li>Adding an item to the list</li>
<li>Removing an item from the list</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the constants</h1>
                </header>
            
            <article>
                
<p>Next up is adding the constants. Constants are a nice thing to have; they protect us from making mistakes due to us mistyping when we deal with action creators as well as reducers:</p>
<pre>// counter/counter-list/counter-list.constants.ts<br/><br/>export<span> </span><span>const</span><span> ADD_COUNTER_ITEM </span><span>=</span><span> </span><span>"add counter item"</span><span>;<br/></span>export<span> </span><span>const</span><span> REMOVE_COUNTER_ITEM </span><span>=</span><span> </span><span>"remove counter item"</span><span>;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the action methods</h1>
                </header>
            
            <article>
                
<p>We also need to define the action methods. These are just functions that will help us create our actions, so it's less for us to type:</p>
<pre>// counter/counter-list/counter-list.actions.ts<br/><br/>import<span> {<br/></span>  ADD_COUNTER_ITEM,<br/>  REMOVE_COUNTER_ITEM<br/>} <span>from</span><span> </span><span>"./counter-list.constants"</span><span>;<br/></span><br/>export<span> </span><span>const</span><span> addItem </span><span>=</span><span> (title, id) </span><span>=&gt;</span><span> ({<br/></span>  type: ADD_COUNTER_ITEM,<br/>  payload: { id, title }<br/>});<br/><br/>export<span> </span><span>const</span><span> removeItem </span><span>=</span><span> id </span><span>=&gt;</span><span> ({<br/></span>  type: REMOVE_COUNTER_ITEM,<br/>  payload: { id }<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the model</h1>
                </header>
            
            <article>
                
<p>We need to type what our counter-list should contain. For that we need to create a model:</p>
<pre>// counter/counter-list/counter.model.ts<br/><br/>export<span> </span><span>interface</span><span> Counter {<br/></span>  title<span>:</span><span> string;<br/></span>  id<span>:</span><span> number;<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Register our reducers</h1>
                </header>
            
            <article>
                
<p>We do need to add and implement all the files in bold, but we also need to update the <kbd>counter.module.ts</kbd> file so we are able to handle the added state:</p>
<pre>// counter/counter.module.ts<br/><br/>import<span> { NgModule } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { CommonModule } </span><span>from</span><span> </span><span>"@angular/common"</span><span>;<br/></span>import<span> { CounterComponent } </span><span>from</span><span> </span><span>"./counter.component"</span><span>;<br/></span>import<span> { StoreModule, ActionReducerMap } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { counterReducer } </span><span>from</span><span> </span><span>"./counter.reducer"</span><span>;<br/></span>import<span> { CounterListComponent } </span><span>from</span><span> </span><span>"./counter-list/counter-list.component"</span><span>;<br/></span><strong>import { Counter } from "./counter-list/counter.model"</strong><span><strong>;</strong><br/></span><strong>import { counterListReducer } from "./counter-list/counter-list.reducer"</strong><span><strong>;</strong><br/></span>import<span> { FormsModule } </span><span>from</span><span> </span><span>"@angular/forms"</span><span>;<br/></span><br/>export<span> </span><span>interface</span><span> CounterState {<br/></span>  data<span>:</span><span> number;<br/></span>  <strong>list:</strong><span><strong> Array&lt;Counter&gt;;</strong><br/></span>}<br/><br/>const<span> combinedReducers</span><span>:</span><span> ActionReducerMap&lt;CounterState&gt; </span><span>=</span><span> {<br/></span>  data: counterReducer,<br/> <strong> list: counterListReducer</strong><br/>};<br/><br/>@NgModule({<br/>  imports: [<br/>    CommonModule,<br/>    StoreModule.forFeature(<span>"counter"</span><span>, combinedReducers),<br/></span>    FormsModule<br/>  ],<br/>  declarations: [CounterComponent, <strong>CounterListComponent</strong>],<br/>  exports: [CounterComponent, <strong>CounterListComponent</strong>]<br/>})<br/>export<span> </span><span>class</span><span> CounterModule {}</span></pre>
<p>We need to add a <kbd>CombinedState</kbd> interface that represents all of our reducers with their state. Lastly, we change the call to <kbd>StoreModule.forFeature()</kbd>. That concludes how we deal with several states and reducers within the same module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component architecture</h1>
                </header>
            
            <article>
                
<p>There are different kinds of components. Two types of components are of interest in the context of NgRx: smart components and dumb components.</p>
<p>Smart components are also called container components. They should be on the highest level of your application, and handle routes. For example, <kbd>ProductsComponent</kbd> should be a container component if it handles the <kbd>route/products</kbd>. It should also know about the store. </p>
<p>The definition of a dumb component is that it has no knowledge of a store and relies solely on the <kbd>@Input</kbd> and <kbd>@Output</kbd> properties—it's all about presentation, which is why it is also called a presentational component. A presentational component in this context can therefore be a <kbd>ProductListComponent</kbd> or a <kbd>ProductCreateComponent</kbd>. A quick overview of a feature module could therefore look like this:</p>
<pre>ProductsComponent // container component<br/>ProductsListComponent // presentational component<br/>ProductsCreateComponent // presentational component</pre>
<p>Let's look at a small code example so you get the idea:</p>
<pre>// products.component.ts  - container component<br/>@Component({<br/>  template: `<br/>    &lt;products-list [products]="products$ | async"&gt;<br/>  `<br/>})<br/>export class ProductsComponent {<br/>  products$: Observable&lt;Product&gt;;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    this.products$ = this.store.select('products'); <br/>  }<br/>}<br/><br/>// products-list.component.ts  - dumb component<br/>@Component({<br/>  selector: 'products-list',<br/>  template : `<br/>  &lt;div *ngFor="let product of products"&gt;<br/>  {{ products.name }}<br/>  &lt;/div&gt;<br/>  `<br/>})</pre>
<pre>export class ProductsListComponent {<br/>  @Input() products;<br/>}</pre>
<p>Our <kbd>ProductsComponent</kbd> is responsible for handling the route to <kbd>/products</kbd>. <kbd>ProductsListComponent</kbd> is a dumb component and just gets a list assigned to it that it is more than happy to render to the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@ngrx/store-devtools – debugging</h1>
                </header>
            
            <article>
                
<p>The following scenario can be found in the code repository under <kbd>Chapter9/DevTools</kbd>.</p>
<p>There are three things we need to do to get DevTools to work:</p>
<ul>
<li>Install the NPM package: <kbd><span>npm install @ngrx/store-devtools --save<kbd>.</kbd></span></kbd></li>
<li>Install the Chrome extension: <kbd>http://extension.remotedev.io/</kbd>. This is called the Redux DevTools extension.</li>
<li>Set it up in your Angular module: this requires us to import DevTools into our Angular project.</li>
</ul>
<p>Providing we have done the two first steps, we should only have the set up stage left, so we need to open up the <kbd>app.module.ts</kbd> file for that:</p>
<pre>import<span> { BrowserModule } </span><span>from</span><span> </span><span>"@angular/platform-browser"</span><span>;<br/></span>import<span> { NgModule } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { StoreModule } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { AppComponent } </span><span>from</span><span> </span><span>"./app.component"</span><span>;<br/></span>import<span> { counterReducer } </span><span>from</span><span> </span><span>"./reducer"</span><span>;</span><span><br/></span><strong>import { StoreDevtoolsModule } from '@ngrx/store-devtools'</strong><span><strong>;</strong><br/></span><br/>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({<br/>      counter: counterReducer,<br/>      <strong>StoreDevtoolsModule.instrument({</strong><br/><strong>        maxAge: 25 // Retains last 25 states<br/>      })</strong><br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export<span> </span><span>class</span><span> AppModule {}</span></pre>
<p>Ok, so now everything is set up and we are ready to take our application for a spin and see what our debug tool can tell us. Let's start up our application with <kbd>ng serve</kbd> and surf to <kbd>http://localhost:4200/</kbd>. First thing we want to do is open developer tools in Chrome and click on a tab called <span class="packt_screen">Redux</span>. You should see something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c7818d9f-9121-49c7-af28-4e4f4524deae.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Redux tab</div>
<p>To the left we have our application UI, and to the right we have our Redux plugin. At this point, no actions have been carried out other than the initialization of the store, which we can see under the plugin part marked as <span class="packt_screen">Inspector</span>. There is but one log entry, <kbd>@ngrx/store/init</kbd>. Let's interact with the UI by clicking on the<span> </span><span class="packt_screen">Increment</span><span> button</span> <span>and see what happens with our store:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bb2388fa-38d0-4a20-b48d-2b8c23239336.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Increment button</div>
<p>As you can see, we have a new entry called <span class="packt_screen">INCREMENT</span>. Two things are of interest now from a debug perspective:</p>
<ul>
<li>What actions were dispatched?</li>
<li>What impact did these actions have on the store?</li>
</ul>
<p>We learn the answer to both these questions by interacting with the tab buttons on the right-hand side of our plugin. The button called <span class="packt_screen">Action</span> will tell us what action was dispatched and what payload it had, if any:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/95fceeaa-999a-406f-b37f-a47dce810345.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Action button</div>
<p>Here, it is clearly stated that an action with type value <span><span class="packt_screen">Increment</span></span> was dispatched. Now to our second question; what was the impact to our store? To find that out, we simply click the <span class="packt_screen">State</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae545d45-0bca-445c-9082-09af2a3d29c8.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">State button</div>
<p>Our state tells us it consists of three properties, <kbd>count</kbd>, <kbd>todos</kbd> and <kbd>jediList</kbd>. Our <kbd>count</kbd> property has the value <span class="packt_screen">1</span>, and is the one affected by us clicking the <span class="packt_screen">Increment</span> button. Let's hit the <span class="packt_screen">Increment</span> button a few more times to see that really is the case:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/54f3ef2f-6319-4ab2-88c4-1612837dbb4a.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Increment button</div>
<p>We now see that our <kbd>count</kbd> property has the value <kbd>3</kbd>, and we have three entries of <span class="packt_screen">Increment</span> actions. </p>
<p>Now let's talk about a really cool feature, time-travel debugging. Yes, you read that correctly, we can control time in our store by replaying dispatched actions, and even change history by removing dispatched actions, all in the name of debugging. The Redux plugin gives us several ways to do this:</p>
<ul>
<li>Click on a specific dispatched action on your left, and choose to skip dispatching it</li>
<li>Use a slider to control and replay all the events, and traverse back and forth in time as you see fit  </li>
</ul>
<p>Let's investigate the first way — click on a specific action:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/536749d5-d146-47c5-b158-b4e21df2aa0a.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Click on a specific action</div>
<p>Here we've clicked on the <span class="packt_screen">Skip</span> button for one dispatch action and the end result is that this dispatched action is removed, which is indicated by the action being overstricken. We can also see that our <kbd>count</kbd> property now has the value <kbd>2</kbd>, as the action never took place. We can easily toggle this back if we want to by hitting <span class="packt_screen">Skip</span> again.</p>
<p>We mentioned there was another way to control the flow of dispatched actions, namely by using a slider. There is a button called <span class="packt_screen">Slider</span> that toggles the slider. Clicking it results in us being shown a slider control with a <span class="packt_screen">Play</span> button, like so:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0997df04-8a9a-47f8-a426-0e765c7139d1.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Play button</div>
<p>If you press the <span class="packt_screen">Play</span> button, it will simply play all the dispatched actions. However, if you choose to interact with the cursor on the slider itself you are able to pull it both to the left, to move back in time, and to the right, to move forward in time.</p>
<p>As you can see, the Redux plugin is a truly powerful tool to use in order to quickly gain an understanding of the following aspects:</p>
<ul>
<li>What your app's state is at a given point in time</li>
<li>What part of the UI leads to what effects in the store</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@ngrx/effects – working with side effects</h1>
                </header>
            
            <article>
                
<p>At this point, we have a basic understanding of NgRx. We know how to set up our state and create all the artifacts that go with it such as actions, action creators, and reducers. Additionally, we have also gained familiarity with the Redux plugin for Chrome and understood what a valuable tool it can be to help us quickly gain an understanding of the state in our app, and most importantly how it can aid us in debugging any problems we may have related to NgRx.</p>
<p>Now, the time has come to talk about something that doesn't quite fit in to our organized and synchronous world of reducers and actions. I am talking about something called side effects. Side effects are operations such as accessing files or network resources, and is not really related to our applications state even though they may be the vessels that contain the data we want, or be the place we persist data to. As we just said, a dispatched action is dispatched in a synchronous way and the change to our state happens straight away. A side effect is something that may take time.  Imagine that we access a large file or ask for a resource over the network using AJAX. This request will finish sometime in the future and, when done, it may affect our state. How do we make these time consuming and asynchronous operations fit in with our synchronous and momentary world? The answer in NgRx is a library called <kbd>@ngrx/effects</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing and setting it up </h1>
                </header>
            
            <article>
                
<p>Installing it is as easy as performing the following command in your terminal:</p>
<pre><strong>npm install @ngrx/effects --save</strong></pre>
<p>The next step is to set it up. The setup can be seen as consisting of two steps:</p>
<ul>
<li>Create our effect</li>
<li>Register the effect with the <kbd>EffectsModule</kbd></li>
</ul>
<p>An effect is just an injectable service that listens for a specific action. Once the effect is in focus, it can carry out a number of operations and transformations before leaving over control. It leaves over control by dispatching an action. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our first effect – a realistic scenario</h1>
                </header>
            
            <article>
                
<p>The following scenario can be found in the code repository under <kbd>Chapter9/DemoEffects</kbd>.</p>
<p>This sounds a bit cryptic, so let's take a realistic scenario. You want to fetch products using AJAX from an endpoint. If you think about what you are about to undertake in the following steps:</p>
<ol>
<li>Dispatch a <kbd>FETCHING_PRODUCTS</kbd>, this sets up our state so we can see that an AJAX request is under way and we can thereby use this to display a spinner for as long as the AJAX request is waiting to complete.</li>
<li>Perform an AJAX call and retrieve your products.</li>
<li>If successfully retrieving the products, then dispatch <kbd>FETCHING_PRODUCTS_SUCCESSFULLY</kbd>.</li>
<li>If there is an error, then dispatch <kbd>FETCHING_PRODUCTS_ERROR</kbd>. </li>
</ol>
<p>Let's solve this task in the following steps:</p>
<ol>
<li>Create a reducer for it.</li>
<li>Create actions and action creators.</li>
<li>Create an effect.</li>
<li>Register the preceding effect with our effects module.</li>
</ol>
<p>To perform all of this, we will create a feature module. To do so, we create the <kbd>product/</kbd> <span>directory </span>with the following files:</p>
<ul>
<li><kbd>product.component.ts</kbd></li>
<li><kbd>product.actions.ts</kbd></li>
<li><kbd>product.constants.ts</kbd></li>
<li><kbd>product.reducer.ts</kbd></li>
<li><kbd>product.selectors.ts</kbd></li>
<li><kbd>product.module.ts</kbd></li>
<li><kbd>product.effect.ts</kbd></li>
</ul>
<p>All of these files are known to us before, except for <kbd>product.effect.ts</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our constants</h1>
                </header>
            
            <article>
                
<p>Let's start with our constants file. What we need are constants that will support us firing away an AJAX request. We also need a constant for when we get our data back successfully, but we also need to cater to any error that might occur. This means we need the following three constants:</p>
<pre>// product/product.constants.ts<br/><br/>export const FETCHING_PRODUCTS = "FETCHING_PRODUCTS";<br/>export const FETCHING_PRODUCTS_SUCCESSFULLY = "FETCHING_PRODUCTS_SUCCESSFULLY";<br/>export const FETCHING_PRODUCTS_ERROR = "FETCHING_PRODUCTS_ERROR";</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Action creators</h1>
                </header>
            
            <article>
                
<p>We need to expose a number of functions that can build objects for us containing a type and a payload property. Depending on what function we invoke, we will assign it with a different constant, and of course a different payload, if using one. The action creator <kbd>fetchProducts()</kbd> will create an object where only the type is set. This is followed by a <kbd>fetchSuccessfully()</kbd> action creator, which will be invoked once the data comes back from an endpoint. Lastly, we have the <kbd>fetchError()</kbd> action creator, which we will invoke if an error occurs:</p>
<pre>// product/product.actions.ts<br/><br/>import { <br/>  FETCHING_PRODUCTS_SUCCESSFULLY, <br/>  FETCHING_PRODUCTS_ERROR,<br/>  FETCHING_PRODUCTS <br/>} from "./product.constants";<br/><br/>export const fetchSuccessfully = (products) =&gt; ({ <br/>  type: FETCHING_PRODUCTS_SUCCESSFULLY, <br/>  payload: products <br/>});<br/><br/>export const fetchError = (error) =&gt; ({ <br/>  type: FETCHING_PRODUCTS_ERROR, <br/>  payload: error <br/>});<br/><br/>export const fetchProductsSuccessfully = (products) =&gt; ({ <br/>  type: FETCHING_PRODUCTS_SUCCESSFULLY, <br/>  payload: products <br/>});<br/><br/>export const fetchProducts =() =&gt; ({ type: FETCHING_PRODUCTS });</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducer with a new type of default state</h1>
                </header>
            
            <article>
                
<p>At first glance, the following reducer is just like any reducer you have written before. It is a function that takes a parameters' state and action, and it contains a switch construct that switches between different actions. So far, everything is familiar. The <kbd>initialState</kbd> variable is different though. It contains the <kbd>loading</kbd>, <kbd>list</kbd>, and <kbd>error</kbd> properties. <kbd>loading</kbd> is simply a Boolean that indicates whether our AJAX request is still pending. <kbd>list</kbd> is our data property that will contain our list of products once they are are returned. The <kbd>error</kbd> property is simply a property that contains the error if any comes back from the AJAX request:</p>
<pre>// product/product.reducer.ts<br/><br/>import<span> {<br/></span>  FETCHING_PRODUCTS_SUCCESSFULLY,<br/>  FETCHING_PRODUCTS_ERROR,<br/>  FETCHING_PRODUCTS<br/>} <span>from</span><span> </span><span>"./product.constants"</span><span>;<br/></span>import<span> { Product } </span><span>from</span><span> </span><span>"./product.model"</span><span>;<br/></span>import<span> { ActionReducerMap } </span><span>from</span><span> </span><span>"@ngrx/store/src/models"</span><span>;<br/></span><br/>const<span> initialState </span><span>=</span><span> {<br/></span>  loading: <span>false</span><span>,<br/></span>  list: [{ name: <span>"init"</span><span> }],<br/></span>  error: <span>void</span><span> </span><span>0<br/></span>};<br/><br/>export<span> </span><span>interface</span><span> ProductState {<br/></span>  loading<span>:</span><span> boolean;<br/></span>  list<span>:</span><span> Array&lt;Product&gt;;<br/></span>  error<span>:</span><span> string;<br/></span>}<br/><br/>export<span> </span><span>interface</span><span> FeatureProducts {<br/></span>  products<span>:</span><span> ProductState;<br/></span>}<br/><br/>export<span> </span><span>const</span><span> ProductReducers</span><span>:</span><span> ActionReducerMap&lt;FeatureProducts&gt; </span><span>=</span><span> {<br/></span>  products: productReducer<br/>};<br/><br/>export<span> </span><span>function</span><span> productReducer(state </span><span>=</span><span> initialState, action) {<br/></span>  switch<span> (action.type) {<br/></span>    case<span> FETCHING_PRODUCTS_SUCCESSFULLY:<br/></span>      return<span> { </span><span>...</span><span>state, list: action.payload, loading: </span><span>false</span><span> };<br/></span>    case<span> FETCHING_PRODUCTS_ERROR:<br/></span>      return<span> { </span><span>...</span><span>state, error: action.payload, loading: </span><span>false</span><span> };<br/></span>    case<span> FETCHING_PRODUCTS:<br/></span>      return<span> { </span><span>...</span><span>state, loading: </span><span>true</span><span> };<br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The effect – listening to a specific dispatched action</h1>
                </header>
            
            <article>
                
<p>So we come to the effect. Our effect acts like a listener to a dispatched action. This gives us the opportunity to carry out a unit of work, but also to dispatch an action once that work is done. </p>
<p>We have created all the usual bits that we are used to, so now it is time to create our effect that will handle the entire workflow:</p>
<pre>// product/product.effect.ts<br/><br/>import { Actions, Effect } from "@ngrx/effects";<br/><br/>@Injectable()<br/>export<span> </span><span>class</span><span> ProductEffects {<br/></span>  @Effect() products$<span>:</span><span> Observable&lt;Action&gt;;</span><br/><br/>  constructor<span>(</span><span><br/></span>    private<span> actions$</span><span>:</span><span> Actions&lt;Action&gt;&gt;<br/></span>  ) {}<br/>}</pre>
<p>The effect is just a class decorated with the <kbd>@Injectable</kbd> decorator. It also contains two members: one member of <kbd>Actions</kbd> type and another of the <kbd>Observable&lt;Action&gt;</kbd> <span>type. </span>Actions come from the <kbd>@ngrx/effects</kbd> module and are nothing more than a specialized <kbd>Observable</kbd> with the <kbd>ofType()</kbd> <span>method </span>on it. <kbd>ofType()</kbd> is the method that takes a string constant, which is the event we are listening for. In the previous code, the <kbd>products$</kbd> is the <kbd>Observable</kbd> that we decorate with the <kbd>@Effect</kbd> decorator. Our next step is to connect <kbd>products$</kbd> with <kbd>actions$</kbd>, and define how our effect should work. We do that with the following code:</p>
<pre>// product/product.effect.ts, starting out..<br/><br/>import { Actions, Effect, <strong>ofType</strong> } from "@ngrx/effects";<br/>import { switchMap } from "rxjs/operators";<br/>import { Observable } from "rxjs/Observable";<br/>import { Injectable } from "@angular/core";<br/><br/>@Injectable()<br/>export<span> </span><span>class</span><span> ProductEffects {<br/></span>  @Effect() products$<span>:</span><span> Observable&lt;Action&gt; = <strong>this.actions$.pipe(</strong><br/><strong>    ofType(FETCHING_PRODUCTS),</strong><br/><strong>    switchMap(action =&gt; {</strong><br/><strong>     // do something completely else that returns an Observable</strong><br/><strong>    })</strong><br/><strong>  );</strong></span><br/><br/>  constructor<span>(</span><span><br/></span>    private<span> actions$</span><span>:</span><span> Actions&lt;Action&gt;&gt;<br/></span>  ) {}<br/>}</pre>
<p>Ok, so we have set up our effect a little more. The call to <kbd>ofType()</kbd> ensures we set ourselves up to listen to a specific dispatched action. The call to <kbd>switchMap()</kbd> ensures we are able to take the current <kbd>Observable</kbd> that we are currently on, and turn it into something completely different, such as a call to an AJAX service. </p>
<p>Let's now return back to our example and see how we can fit in some product-related logic in there:</p>
<pre>// product/product.effect.ts<br/><br/>import<span> { Actions, Effect, ofType } </span><span>from</span><span> </span><span>"@ngrx/effects"</span><span>;<br/></span>import<span> { HttpClient } </span><span>from</span><span> </span><span>"@angular/common/http"</span><span>;<br/></span>import<span> { FETCHING_PRODUCTS } </span><span>from</span><span> </span><span>"./product.constants"</span><span>;<br/></span>import<span> { Injectable } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { Observable } </span><span>from</span><span> </span><span>"rxjs/Observable"</span><span>;<br/></span>import<span> { delay, map, catchError, switchMap } </span><span>from</span><span> </span><span>"rxjs/operators"</span><span>;<br/></span>import<span> { fetchProductsSuccessfully, fetchError } </span><span>from</span><span> </span><span>"./product.actions"</span><span>;<br/></span>import<span> { Action } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/><br/></span>@Injectable()<br/>export<span> </span><span>class</span><span> ProductEffects {<br/>  <strong>@Effect()</strong><br/></span>  products$ <span>=</span><span> </span><span>this</span><span>.actions$.pipe(<br/></span>    ofType(<strong>FETCHING_PRODUCTS</strong>),<br/>    switchMap(action <span>=&gt;<br/></span>      <strong>this.http<br/>      .get("data/products.json")<br/>      .pipe(</strong><br/><strong>        delay(3000),<br/>        map(fetchProductsSuccessfully),</strong><br/><strong>        catchError(err =&gt; of(fetchError(err)))<br/>      )</strong><br/>    )<br/>  );<br/><br/>  constructor<span>(</span><span>private</span><span> </span><span>actions$</span><span>:</span><span> </span><span>Actions&lt;Action&gt;,</span><span> </span><span>private</span><span> </span><span>http</span><span>:</span><span> </span><span>HttpClient) {}<br/></span>}</pre>
<p>What we do in the preceding code is listen to our <kbd>FETCHING_PRODUCTS</kbd> action and carry out a call to an AJAX service. We added a call to the <kbd>delay()</kbd> operator so as to simulate that our AJAX call takes some time to carry out. This will give us a chance to show a loading spinner. The <kbd>map()</kbd> operator ensures we dispatch an action when we get the AJAX response back. We can see that we call the action creator, <kbd>fetchProductsSuccessfully()</kbd>, which implicitly calls the reducer and sets a new state on the products property. </p>
<p>At this point, we need to register the effect before moving on. We can do so in the root module or in the feature module. It's a very similar call, so let's describe both ways of doing it:</p>
<pre>// app.module.ts - registering our effect in the root module, alternative I<br/><br/><span>/* omitting the other imports for brevity */<br/></span><strong>import { EffectsModule } from "@ngrx/effects"</strong><span><strong>;<br/>import { ProductEffects } from "./products/product.effect";</strong><br/><br/></span>@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({}),<br/>    ProductsModule,<br/>    StoreDevtoolsModule.instrument({<br/>      maxAge: <span>25</span><span> </span><span>// Retains last 25 states<br/></span>    }),<br/>    <strong>EffectsModule.forRoot([ ProductEffects ])</strong><br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export<span> </span><span>class</span><span> AppModule {}</span></pre>
<p>If we have a feature module, on the other hand, we could be using the <kbd>forFeature()</kbd> method on the <kbd>EffectsModule</kbd> and call that in our feature module like so:</p>
<pre>// product/product.module.ts, registering in the feature module, alternative II<br/><br/>import<span> { NgModule } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { ProductComponent } </span><span>from</span><span> </span><span>"./product.component"</span><span>;<br/></span>import<span> { BrowserModule } </span><span>from</span><span> </span><span>"@angular/platform-browser"</span><span>;<br/></span>import<span> { ProductEffects } </span><span>from</span><span> </span><span>"./product.effect"</span><span>;<br/></span>import<span> { EffectsModule } </span><span>from</span><span> </span><span>"@ngrx/effects"</span><span>;<br/></span>import<span> { StoreModule, Action } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { ProductReducers } </span><span>from</span><span> </span><span>"./product.reducer"</span><span>;<br/></span>import<span> { HttpClientModule } </span><span>from</span><span> </span><span>"@angular/common/http"</span><span>;<br/></span>import<span> { ActionReducerMap } </span><span>from</span><span> </span><span>"@ngrx/store/src/models"</span><span>;<br/></span><br/>@NgModule({<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forFeature(<span>"featureProducts"</span><span>, ProductReducers),<br/></span>    <strong>EffectsModule.forFeature([ProductEffects]),</strong><br/>    HttpClientModule<br/>  ],<br/>  exports: [ProductComponent],<br/>  declarations: [ProductComponent],<br/>  providers: []<br/>})<br/>export<span> </span><span>class</span><span> ProductModule {}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a component – introducing selectors</h1>
                </header>
            
            <article>
                
<p><span>That's it, thats all you need to create an effect. We're not done here though, we need a component to display our data, as well as a spinner, while we are waiting for the AJAX request to finish.</span></p>
<p>Ok, first things first: what do we know of components that should be using NgRx? The obvious answer is that they should be injecting the store so we can listen to a slice of state from the store. The way we listen to a slice of state is by calling the stores <kbd>select()</kbd> function. This will return an <kbd>Observable</kbd>. We know we can easily show Observables in the template through the use of the async pipe. So let's start sketching our component:</p>
<pre>// product/product.component.ts<br/><br/>import<span> { Component, OnInit } </span><span>from</span><span> "</span><span>@angular/core"</span><span>;<br/></span><strong>import { AppState } from "../app-state";<br/>import { Store } from "@ngrx/store";</strong><span><br/><br/></span>@Component({<br/><span>  </span>selector: "<span>products"</span><span>,<br/>  </span>template: <span>`<br/>    </span>&lt;<span>div</span><span> </span><span>*ngFor</span><span>=</span><span>"let product of products$ | async"</span><span>&gt;<br/></span>      Product: {{ product.name }}<br/>    &lt;/<span>div</span><span>&gt;</span><span><br/></span>  &lt;/<span>div</span><span>&gt;<br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> ProductsComponent</span><span> {<br/></span>  products$;<br/>  loading$;<br/><br/>  constructor<span>(</span><strong>private store:</strong><span><strong> Store&lt;AppState&gt;</strong>) {<br/></span>    <strong>this.products$ = this.store.select((state) =&gt; {<br/>      return state.products.list;<br/>    });</strong><br/>  }<br/>}</pre>
<p>This part of our component here shouldn't come as too much of a surprise; we inject the store into the constructor, call <kbd>select()</kbd>, and get an Observable back. But, there is a <em>but</em> here, we are calling the <kbd>select()</kbd> method differently. We used to pass a string to the <kbd>select()</kbd> function, and now we pass it a function. Why is that? Well, because we changed how our state looked. Let's show our new state again, for clarity:</p>
<pre>const initialState = {<br/>  loading: false,<br/>  list: [],<br/>  error: void 0<br/>}</pre>
<p>The preceding code shows that we can't just do <kbd>store.select("products")</kbd> because that would give us the whole object back. So we need a way to dig into the previous object in order to get a hold of the list property that should contain our list of products. The way to do that is to use the variant of the <kbd>select</kbd> method that takes a function instead. We do just that with the following code:</p>
<pre>this<span>.products$ </span><span>=</span><span> </span><span>this</span><span>.store.select((state) </span><span>=&gt;</span><span> {<br/></span>  return<span> state.products.list;<br/></span>});<span><br/></span></pre>
<p>Ok, but will this really be type safe? Won't the <kbd>AppState</kbd> interface complain? Does it know of our changed state structure? Well, we can tell it knows about it, but we need to ensure that our reducer exports an interface that represents our new state structure. We therefore change the reducer to look like the following:</p>
<pre>// product/products-reducer.ts<br/><br/>import { <br/>  FETCHING_PRODUCTS_SUCCESSFULLY, <br/>  FETCHING_PRODUCTS_ERROR,<br/>  FETCHING_PRODUCTS <br/>} from "./product-constants";<br/><br/><strong>export interface ProductsState {</strong><br/><strong>  loading: boolean;</strong><br/><strong>  list: Array&lt;Product&gt;;</strong><br/><strong>  error: string;</strong><br/><strong>}</strong><br/><br/>const initialState: <strong>ProductsState</strong> = {<br/>  loading: false,<br/>  list: [],<br/>  error: void 0<br/>}<br/><br/>export function productReducer(state = initialState, action) {<br/>  switch(action.type) {<br/>    case FETCHING_PRODUCTS_SUCCESSFULLY:<br/>      return { ...state, list: action.payload, loading: false };<br/>    case FETCHING_PRODUCTS_ERROR:<br/>      return { ...state, error: action.payload, loading: false };<br/>    case FETCHING_PRODUCTS:<br/>      return { ...state, loading: true };<br/>    default:<br/>      return state;<br/>  }<br/>}</pre>
<p>And of course, we need to update the <kbd>AppState</kbd> interface to look like this:</p>
<pre>// app-state.ts<br/><br/>import<span> { FeatureProducts } </span><span>from</span><span> </span><span>"./product/product.reducer"</span><span>;<br/></span><br/>export<span> </span><span>interface</span><span> AppState {<br/></span>  featureProducts<span>:</span><span> FeatureProducts;<br/></span>}<span><br/></span></pre>
<p>Ok, this made our <kbd>AppState</kbd> know what kind of beast our <kbd>products</kbd> property really is, and is thereby what makes the <kbd>store.select(&lt;Fn&gt;)</kbd> call possible. The function we gave the <kbd>select</kbd> method is called a selector, and is actually something that doesn't have to live inside the component. The reason for this is that we might want to access that slice of state somewhere else. Let's therefore create a <kbd>product.selectors.ts</kbd> file. We will add to this later as we keep supporting CRUD:</p>
<pre>// product/product.selectors.ts<br/>import { AppState } from "../app-state";<br/><br/>export const getList = (state:AppState) =&gt; state.featureProducts.products.list; <br/>export const getError = (state:AppState) =&gt; state.featureProducts.products.error;<br/>export const isLoading = (state:AppState) =&gt; state.featureProducts.products.loading;</pre>
<p>Ok, so now we have created our selectors file, and we can immediately start improving our components code and clean it up a bit before we continue to add things to it:</p>
<pre>// product/product.component.ts<br/><br/>import<span> { Component, OnInit } </span><span>from</span><span> "</span><span>@angular/core"</span><span>;<br/></span>import { AppState } from "../app-state";<br/>import { Store } from "@ngrx/store";<strong><br/></strong><span><strong>import { getList } from './product.selectors';</strong><br/><br/></span>@Component({<br/><span>  </span>selector: "<span>products"</span><span>,<br/>  </span>template: <span>`<br/>    </span>&lt;<span>div</span><span> </span><span>*ngFor</span><span>=</span><span>"let product of products$ | async"</span><span>&gt;<br/></span>      Product: {{ product.name }}<br/>    &lt;/<span>div</span><span>&gt;</span><span><br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> ProductsComponent</span><span> {<br/></span>  products$;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    this.products$ = this.store.select(<strong>getList</strong>);<br/>  }<br/>}</pre>
<p>Our code looks much better. It's time to start caring about the other aspect of this; what if our HTTP service takes a few seconds, or even one second to return? This is a real concern especially with our users being potentially on a 3G connection. To take care of this, we grab the <kbd>loading</kbd> property from our products state and  use that as a conditional in our template. We will basically say that if the HTTP call is still pending, show some text or an image that indicates to the user that something is loading. Let's add that piece of functionality to the component:</p>
<pre>import<span> { Component, OnInit } </span><span>from</span><span> "</span><span>@angular/core"</span><span>;<br/></span>import { AppState } from "../app-state";<br/>import { Store } from "@ngrx/store";<strong><br/></strong><span>import { getList, <strong>isLoading</strong> } from "./products.selectors";<br/><br/></span>@Component({<br/><span>  </span>selector: "<span>products"</span><span>,<br/>  </span>template: <span>`<br/>    </span>&lt;<span>div</span><span> </span><span>*ngFor</span><span>=</span><span>"let product of products$ | async"</span><span>&gt;<br/></span>      Product: {{ product.name }}<br/>    &lt;/<span>div</span><span>&gt;<br/></span>    <strong>&lt;div *ngIf="loading$ | async; let loading"&gt;<br/>      &lt;div *ngIf="loading"&gt;<br/>      loading...</strong><br/><strong>      &lt;/div&gt;<br/>    &lt;/div</strong><span><strong>&gt;</strong><br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> ProductsComponent</span><span> {<br/></span>  products$;<br/>  loading$;<br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    this.products$ = this.store.select(getList);<br/>    <strong>this.loading$ = this.store.select(isLoading);</strong><br/>  }<br/>}</pre>
<p>Let's also ensure that we show any errors by subscribing to <kbd>products.error</kbd>. We simply update the component with the following alterations:</p>
<pre>import<span> { Component, OnInit } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import { AppState } from "../app-state";<br/>import { Store } from "@ngrx/store";<strong><br/></strong><span>import { getList, isLoading, <strong>getError</strong> } from "./products.selectors";<br/><br/></span>@Component({<br/><span>  </span>selector: "<span>products"</span><span>,<br/>  </span>template: <span>`<br/>    </span>&lt;<span>div</span><span> </span><span>*ngFor</span><span>=</span><span>"let product of products$ | async"</span><span>&gt;<br/></span>      Product: {{ product.name }}<br/>    &lt;/<span>div</span><span>&gt;<br/></span>    &lt;div *ngIf="loading$ | async; let loading"&gt;<br/>      &lt;div *ngIf="loading"&gt;<br/>      loading...<br/>      &lt;/div&gt;<br/>    &lt;/div<span>&gt;<br/><strong>    &lt;div *ngIf="error$ | async; let error" &gt;</strong><br/><strong>      &lt;div *ngIf="error"&gt;{{ error }}&lt;/div&gt; </strong><br/><strong>    &lt;/div&gt;</strong><br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> ProductsComponent</span><span> {<br/></span>  products$;<br/>  loading$;<br/> <strong> error$;</strong><br/><br/>  constructor(private store: Store&lt;AppState&gt;) {<br/>    this.products$ = this.store.select(getList);<br/>    this.loading$ = this.store.select(isLoading);<br/>    <strong>this.error$ = this.store.select(getError);</strong><br/>  }<br/>}</pre>
<p>Ok, we fire up our application at this point. There is just one teeny tiny problem; we don't see any products at all. Why is that? The explanation is simple. We don't actually dispatch an action that will lead to the AJAX call being made. Let's fix that by adding the following code to our component:</p>
<pre>import<span> { Component, OnInit } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import { AppState } from "../app-state";<br/>import { Store } from "@ngrx/store";<strong><br/></strong><span>import { getList, isLoading, getError } from "./products.selectors";<br/><strong>import { fetchProducts } from "./products.actions";</strong><br/><br/></span>@Component({<br/><span>  </span>selector: "<span>products"</span><span>,<br/>  </span>template: <span>`<br/>    </span>&lt;<span>div</span><span> </span><span>*ngFor</span><span>=</span><span>"let product of products$ | async"</span><span>&gt;<br/></span>      Product: {{ product.name }}<br/>    &lt;/<span>div</span><span>&gt;<br/></span>    &lt;div *ngIf="loading$ | async; let loading"&gt;<br/>      &lt;div *ngIf="loading"&gt;<br/>      loading...<br/>      &lt;/div&gt;<br/>    &lt;/div<span>&gt;<br/>    </span><span>&lt;div *ngIf="error$ | async; let error" &gt;<br/>      &lt;div *ngIf="error"&gt;{{ error }}&lt;/div&gt; <br/>    &lt;/div&gt;<strong><br/></strong></span>  `<br/>})<br/>export<span> </span><span>class</span><span> ProductsComponent </span><span>implements</span><span> OnInit {<br/></span> products$;<br/> loading$;<br/> error$;<br/><br/> constructor(private store: Store&lt;AppState&gt;) {<br/>   this.products$ = this.store.select(getList);<br/>   this.loading$ this.store.select(isLoading);<br/>   this.error$ = this.store.select(getError);<strong><br/></strong> }<br/><br/> ngOnInit() {<br/>   <strong>this.store.dispatch(fetchProducts);</strong> <br/> }<br/>}</pre>
<p>This will of course trigger our effect, which will lead to our HTTP call, which will lead to <span><kbd>fetchProductsSuccessfully()</kbd> being called, and thereby our state will be updated and <kbd>products.list</kbd> will no longer be an empty array, meaning our UI will show a list of products. Success!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending our example with the create effect</h1>
                </header>
            
            <article>
                
<p>So far, we have gone through the full flow of adding an effect, building a component, and improved the code with selectors. To make sure we really understand how to work with effects and how the application scales with it, let's add another effect, this time let's add an effect to support an HTTP POST call. What we want to happen from an application standpoint is that we add another product to the list. This should update the UI and show our added product. What happens data-wise is that our store should reflect that change and, as a side effect, a HTTP POST should be carried out. We need the following to accomplish this:</p>
<ul>
<li>A reducer that supports adding a product to our products list</li>
<li>An effect that listens to a product being added action and that carries out a HTTP POST</li>
<li>We also need to register the created effect</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the constants file</h1>
                </header>
            
            <article>
                
<p>Just like with the fetching of products, we need to support one action that triggers everything. We need another action for when the HTTP request succeeds and one last action to support error handling:</p>
<pre>// product.constants.ts<br/><br/>export<span> </span><span>const</span><span> FETCHING_PRODUCTS </span><span>=</span><span> "</span><span>FETCHING_PRODUCTS"</span><span>;<br/></span>export<span> </span><span>const</span><span> FETCHING_PRODUCTS_SUCCESSFULLY </span><span>=</span><span> "</span><span>FETCHING_PRODUCTS_SUCCESSFULLY"</span><span>;<br/></span>export<span> </span><span>const</span><span> FETCHING_PRODUCTS_ERROR </span><span>=</span><span> "</span><span>FETCHING_PRODUCTS_ERROR"</span><span>;<br/></span><strong>export const ADD_PRODUCT = "ADD_PRODUCT";<br/>export const ADD_PRODUCT_SUCCESSFULLY = "ADD_PRODUCT_SUCCESSFULLY";<br/>export const ADD_PRODUCT_ERROR ="ADD_PRODUCT_ERROR";</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the reducer</h1>
                </header>
            
            <article>
                
<p>At this point we take our existing <kbd>reducer.ts</kbd> file and add what we need to support adding a product:</p>
<pre>// products.reducer.ts<br/><br/>import<span> {<br/></span>  FETCHING_PRODUCTS_SUCCESSFULLY,<br/>  FETCHING_PRODUCTS_ERROR,<br/>  FETCHING_PRODUCTS,<br/>  <strong>ADD_PRODUCT,</strong><br/><strong>  ADD_PRODUCT_SUCCESSFULLY,</strong><br/><strong>  ADD_PRODUCT_ERROR</strong><br/>} <span>from</span><span> "</span><span>./product.constants"</span><span>;<br/></span><br/>import<span> { Product } </span><span>from</span><span> "</span><span>./product.model"</span><span>;<br/></span><br/>const<span> initialState </span><span>=</span><span> {<br/></span>  loading: <span>false</span><span>,<br/></span>  list: [],<br/>  error: <span>void</span><span> </span><span>0<br/></span>}<br/><br/>export<span> </span><span>interface</span><span> ProductsState {<br/></span>  loading<span>:</span><span> boolean;<br/></span>  list<span>:</span><span> Array&lt;Product&gt;,<br/></span>  error<span>:</span><span> string;<br/></span>}<br/><br/><strong>function addProduct(list, product) {<br/>  return [ ...list, product];<br/>}</strong><br/><br/>export<span> </span><span>function</span><span> productsReducer(state </span><span>=</span><span> initialState, action) {<br/></span>  switch<span>(action.type) {<br/></span>    case<span> FETCHING_PRODUCTS_SUCCESSFULLY:<br/></span>      return<span> { </span><span>...</span><span>state, list: action.payload, loading: </span><span>false</span><span> };<br/></span>    case<span> FETCHING_PRODUCTS_ERROR:<br/>    <strong>case ADD_PRODUCT_ERROR:</strong><br/></span>      return<span> { </span><span>...</span><span>state, error: action.payload, loading: </span><span>false</span><span> };<br/></span>    case<span> FETCHING_PRODUCTS:<br/>    <strong>case ADD_PRODUCT:</strong><br/></span>      return<span> { </span><span>...</span><span>state, loading: </span><span>true</span><span> };<br/></span>    <strong>case ADD_PRODUCT_SUCCESSFULLY:<br/>      return { ...</strong><span><strong>state, list: addProduct(state.list, action.payload) };</strong><br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}</pre>
<p>It's worth noting how we create the help function, <kbd>addProduct()</kbd>, which allows us to create a new list containing the old content and our new product. It's also worth noting that we can group <kbd>FETCHING_PRODUCTS_ERROR</kbd> and <kbd>ADD_PRODUCT_ERROR</kbd> actions, and also <kbd>ADD_PRODUCT</kbd> and <kbd>ADD_PRODUCT_SUCCESSFULLY</kbd>.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional actions </h1>
                </header>
            
            <article>
                
<p>The next order of business is to update our <kbd>products.actions.ts</kbd> file with the new methods that we need to support the preceding code:</p>
<pre>// products.actions.ts<br/><br/>import<span> {<br/></span>  FETCHING_PRODUCTS_SUCCESSFULLY,<br/>  FETCHING_PRODUCTS_ERROR,<br/>  FETCHING_PRODUCTS,<br/><strong>  ADD_PRODUCT,</strong><br/><strong>  ADD_PRODUCT_SUCCESSFULLY,</strong><br/><strong>  ADD_PRODUCT_ERROR</strong><br/>} <span>from</span><span> "</span><span>./product.constants"</span><span>;<br/></span><br/>export<span> </span><span>const</span><span> fetchProductsSuccessfully </span><span>=</span><span> (products) </span><span>=&gt;</span><span> ({ </span><span><br/></span>  type: FETCHING_PRODUCTS_SUCCESSFULLY,<br/>  payload: products<br/>});<br/><br/>export<span> </span><span>const</span><span> fetchError </span><span>=</span><span> (error) </span><span>=&gt;</span><span> ({ <br/>  type: FETCHING_PRODUCTS_ERROR, <br/>  payload: error <br/>});<br/></span>export<span> </span><span>const</span><span> fetchProductsLoading </span><span>=</span><span> () </span><span>=&gt;</span><span> ({ type: FETCHING_PRODUCTS });<br/></span>export<span> </span><span>const</span><span> fetchProducts </span><span>=</span><span> () </span><span>=&gt;</span><span> ({ type: FETCHING_PRODUCTS });<br/></span><strong>export const addProductSuccessfully (product) =&gt; ({ <br/>  type: ADD_PRODUCT_SUCCESSFULLY },<br/>  payload: product<br/>);<br/>export const addProduct = (product) =&gt; ({ <br/>  type: ADD_PRODUCT,<br/>  payload: product<br/>});<br/>export const addProductError = (error) =&gt; ({ <br/>  type: ADD_PRODUCT_ERROR, <br/>  payload: error <br/>});</strong></pre>
<p>What is worth noting with the created actions is that the <kbd>addProduct()</kbd> method takes a product as a parameter. The reason for that is that we want the side effect to use that as body data for the forthcoming HTTP POST.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding another effect</h1>
                </header>
            
            <article>
                
<p>Now we are finally ready to construct our effect. It's going to look very similar to the existing one:</p>
<pre>import<span> { Injectable } </span><span>from</span><span> "</span><span>@angular/core"</span><span>;<br/></span>import<span> { HttpClient } </span><span>from</span><span> "</span><span>@angular/common/http"</span><span>;<br/></span>import<span> { Action } </span><span>from</span><span> "</span><span>@ngrx/store"</span><span>;<br/></span>import<span> { Actions, Effect, ofType } </span><span>from</span><span> "</span><span>@ngrx/effects"</span><span>;<br/></span>import<span> { Observable } </span><span>from</span><span> "</span><span>rxjs/Observable"</span><span>;<br/></span>import<span> { of } </span><span>from</span><span> "</span><span>rxjs/observable/of"</span><span>;<br/></span>import<span> "</span><span>rxjs/add/observable/of"</span><span>;<br/></span>import<span> { <br/>  catchError, <br/>  map, <br/>  mergeMap, <br/>  delay, <br/>  tap, <br/>  switchMap <br/>} </span><span>from</span><span> "</span><span>rxjs/operators"</span><span>;<br/></span>import<span> { FETCHING_PRODUCTS, <strong>ADD_PRODUCT</strong> } </span><span>from</span><span> "</span><span>./product.constants"</span><span>;<br/></span>import<span> { <br/>  fetchProductsSuccessfully, <br/>  fetchError, <br/>  <strong>addProductSuccessfully, </strong><br/><strong>  addProductError</strong> <br/>} </span><span>from</span><span> "</span><span>./product.actions";<br/></span>import<span> { Product } </span><span>from</span><span> "</span><span>./product.model"</span><span>;<br/></span>import<span> { ActionPayload } </span><span>from</span><span> "</span><span>../interfaces"</span><span>;<br/><br/></span>@Injectable()<br/>export class ProductEffects {<strong><br/></strong>  <strong>@Effect() productsAdd$: Observable&lt;Action&gt; = this.actions$.pipe(</strong><br/><strong>    ofType(ADD_PRODUCT),</strong><br/><strong>    switchMap(action =&gt;</strong><br/><strong>      this.http.post("products/", action.payload).pipe(</strong><br/><strong>        map(addProductSuccessfully),</strong><br/><strong>        catchError((err) =&gt; of(addProductError(err)))&lt;/strong&gt;<br/><strong>      )</strong><br/><strong>    )</strong><br/><strong>  );<br/><br/>  </strong>@Effect() productsGet$<span>:</span><span> Observable&lt;Action&gt; </span><span>=</span><span> </span><span>this</span><span>.actions$.pipe(<br/></span>    ofType(FETCHING_PRODUCTS),<br/>    switchMap(action <span>=&gt;<br/></span>      this<span>.http.get("</span><span>data/products.json"</span><span>).pipe(<br/></span>        delay(<span>3000</span><span>),<br/></span>        map(fetchProductsSuccessfully),<br/>        catchError((err) <span>=&gt;</span><span> </span><span>of</span><span>(fetchError(err)))<br/></span>      )<br/>    )<br/>  );<br/><strong><br/> </strong> constructor(<br/>    private http: HttpClient,<br/>    private actions$: Actions&lt;ActionPayload&lt;Product&gt;&gt;<br/>  ) {}<br/>}<br/><br/></strong></pre>
<p>The first thing we do here is to reuse our <kbd>ProductEffects</kbd> class and add a new member <kbd>productsAdd$</kbd> to it. While at it, we rename <kbd>products$</kbd> to <kbd>productsGet$</kbd>. As long as we are dealing with products we can keep on adding to this class.</p>
<p>The similarities we see with the existing effect is that we set up our <kbd>ofType()</kbd> operator to listen for a dispatched action of our choice. Thereafter, we continue with our side effect, that is the call to the <kbd>HttpClient</kbd> service that ends up being an HTTP POST call. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supporting the effect in our component</h1>
                </header>
            
            <article>
                
<p>We don't need to do much in our component. Of course, we need to add some things in the template to support adding a product. In terms of NgRx, we just need to dispatch the <kbd>ADD_PRODUCT</kbd> action. Let's have a look at the code:</p>
<pre>import<span> { Component, OnInit } </span><span>from</span><span> "</span><span>@angular/core"</span><span>;<br/></span>import<span> { AppState } </span><span>from</span><span> </span><span>"../app-state"</span><span>;<br/></span>import<span> { Store } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { fetchProducts, <strong>addProduct</strong> } </span><span>from</span><span> "</span><span>./product.actions"</span><span>;<br/></span>import<span> { getList, isLoading, getError } </span><span>from</span><span> "</span><span>./products.selectors"</span><span>;<br/></span><br/>@Component({<br/>selector: "<span>products"</span><span>,<br/></span>  template: <span>`<br/></span>  <strong>&lt;div&gt;<br/>    &lt;input [(ngModel)]="newProduct" placeholder="new product..." /&gt;<br/>    &lt;button (click)="addNewProduct()"&gt;&lt;/button&gt;<br/>  &lt;/div</strong><span><strong>&gt;</strong><br/></span>  &lt;<span>div</span><span> </span><span>*ngFor</span><span>=</span><span>"let product of products$ | async"</span><span>&gt;<br/></span>  Product: {{ product.name }}<br/>  &lt;/<span>div</span><span>&gt;<br/></span>  &lt;<span>div</span><span> </span><span>*ngIf</span><span>=</span><span>"loading$ | async; let loading"</span><span>&gt;<br/></span>    &lt;<span>div</span><span> </span><span>*ngIf</span><span>=</span><span>"loading"</span><span>&gt;<br/></span>    loading...<br/>    &lt;/<span>div</span><span>&gt;<br/></span>  &lt;/<span>div</span><span>&gt;<br/></span>  &lt;<span>div</span><span> </span><span>*ngIf</span><span>=</span><span>"error$ | async; let error"</span><span>&gt;<br/></span>  {{ error }}<br/>  &lt;/<span>div</span><span>&gt;<br/></span>  `<br/>})<br/>export<span> </span><span>class</span><span> ProductsComponent </span><span>implements</span><span> OnInit {<br/></span>  products$;<br/>  loading$;<br/>  error$;<br/>  <strong>newProduct: string;<br/></strong><br/>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.products$ </span><span>=</span><span> </span><span>this</span><span>.store.select(getList);<br/></span>    this<span>.loading$ </span><span>=</span><span> store.select(isLoading);<br/></span>    this<span>.error$ </span><span>=</span><span> store.select(getError);<br/></span>  }<br/><br/>  ngOnInit() {<br/>    this<span>.store.dispatch(fetchProducts());<br/></span>  }<br/><br/>  <strong>addNewProduct() {</strong><br/><strong>    this.store.dispatch(addProduct(this.newProduct));<br/>    this.newProduct = "";<br/>  }</strong><br/>}</pre>
<p>Ok, from this code we set up an input control and a button to be able to handle the user inputting a new product. For the class, we added the <kbd>newProduct</kbd> field and we also added the <kbd>addNewProduct()</kbd> method that, in its body, invokes the <kbd>addProduct()</kbd>, method and thereby passes an <kbd>ADD_PRODUCT</kbd> action. We really don't need to do more. Our product addition sets the loading state before carrying out the HTTP call, so we can show a spinner if we want, and our error state picks up on any errors that might occur and presents them in the UI. Lastly, don't forget to add the <kbd>FormsModule</kbd> to the <kbd>import</kbd> property in the <kbd>product.module.ts</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running a demo of the app</h1>
                </header>
            
            <article>
                
<p>To try out our app, we can simply run the <kbd>ng serve</kbd> command in the terminal. What we expect to see is a screen that for three seconds states it is loading, just to be replaced by the fetched data. This will demonstrate both the dispatch of the loaded state, as well as us dispatching the data to the store once it arrives. The following is the <span>initial screen when our data is yet to arrive. We fire off the <kbd>FETCHING_PRODUCTS</kbd> action, which makes our loading text appear:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/322941c2-5f58-4f91-97a7-e8c27e8e020b.png" style=""/></div>
<p> The next screen is when our data arrives. Subsequently, we fire off <kbd>ADD_PRODUCT_SUCCESSFULLY</kbd> to ensure that the fetched data is placed in the store:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6c69a9eb-ebef-413a-b7f5-47e5509acea2.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have gone through a lot in this chapter. Among the things covered have been installing and using the store. To that knowledge, we have added some sound best practices to organize your code. It's important to note that consistency is key. There are many ways to organize code, so as long as that chosen way remains consistent throughout the app, that is the most important factor. With that said, organizing your code by domain is what is prescribed for most things Angular. Whether that holds true for NgRx is up to you, dear reader. See best practices as a guide rather than a rule. Furthermore, we covered side effects and how to handle those with <kbd>@ngrx/effects</kbd>. <kbd>@store-devtools</kbd> was another thing we covered, which lets us use our browser to easily debug our store. In the next, and final, chapter, we will cover <kbd>@ngrx/schematics</kbd> and <kbd>@ngrx/entity</kbd>, so we really cover everything NgRx has to offer us. Also, we will showcase how you can build NgRx yourself to gain further understanding on what goes on under the hood. If knowing what goes on under the hood isn't exciting to you, then you are in the wrong profession! Everything is really set up to make the final chapter a very interesting one.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>