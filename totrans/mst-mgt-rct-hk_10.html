<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-92"><em class="italic"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.1.1">Chapter 7</span></em><span class="koboSpan" id="kobo.2.1">: Use Case Scenario 1 – Zustand</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">So far, we have been exploring some basic patterns we can use to implement a global state in React. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will learn about a real implementation that is publicly available as a package, called Zustand.</span></p>
			<p><span class="L2-L3-bullet-characters"><span class="koboSpan" id="kobo.4.1">Zustand (</span></span><a href="https://github.com/pmndrs/zustand"><span class="koboSpan" id="kobo.5.1">https://github.com/pmndrs/zustand</span></a><span class="koboSpan" id="kobo.6.1">) is a tiny library primarily designed to create module state for React. </span><span class="koboSpan" id="kobo.6.2">It's based on an immutable update model, in which state objects can't be modified but always have to be newly created. </span><span class="koboSpan" id="kobo.6.3">Render optimization is done manually using selectors. </span><span class="koboSpan" id="kobo.6.4">It has a straightforward and yet powerful </span><strong class="source-inline"><span class="koboSpan" id="kobo.7.1">store</span></strong><span class="koboSpan" id="kobo.8.1"> creator interface.</span></p>
			<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will explore how module state and subscriptions are used and see what the library API looks like.</span></p>
			<p><span class="koboSpan" id="kobo.10.1">In this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.11.1">Understanding module state and immutable state</span></li>
				<li><span class="koboSpan" id="kobo.12.1">Adding React hooks to optimize re-renders</span></li>
				<li><span class="koboSpan" id="kobo.13.1">Working with read state and update state</span></li>
				<li><span class="koboSpan" id="kobo.14.1">Handling structured data</span></li>
				<li><span class="koboSpan" id="kobo.15.1">Pros and cons of this approach and library</span></li>
			</ul>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.17.1">You are expected to have moderate knowledge of React, including React hooks. </span><span class="koboSpan" id="kobo.17.2">Please refer to the official site, </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.18.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.19.1">, to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.20.1">In some of the code in this chapter, we will be using TypeScript (</span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.21.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.22.1">), so you should have basic knowledge of it.</span></p>
			<p><span class="koboSpan" id="kobo.23.1">The code in this chapter is available on GitHub at </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_07"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_07</span></a><span class="koboSpan" id="kobo.25.1">.</span></p>
			<p><span class="koboSpan" id="kobo.26.1">To run the code snippets in this chapter, you will need a React environment, such as Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.27.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.28.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.29.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.30.1">).</span></p>
			<p><span class="koboSpan" id="kobo.31.1">At the time of writing, the current version of Zustand is v3. </span><span class="koboSpan" id="kobo.31.2">Future versions may provide some different APIs.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.32.1">Understanding module state and immutable state</span></h1>
			<p><span class="koboSpan" id="kobo.33.1">Zustand is a library that's used to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">store</span></strong><span class="koboSpan" id="kobo.35.1"> that holds a state. </span><span class="koboSpan" id="kobo.35.2">It's primarily designed for </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.36.1">module state, which means you define this </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">store</span></strong><span class="koboSpan" id="kobo.38.1"> in a module and export it. </span><span class="koboSpan" id="kobo.38.2">It's based on the immutable state model, in which you are not allowed to </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.39.1">modify state object properties. </span><span class="koboSpan" id="kobo.39.2">Updating states must be done by creating new objects, while unmodified state objects must be reused. </span><span class="koboSpan" id="kobo.39.3">The benefit of the immutable state model is that you only need to check state object referential equality to know if there's any update; you don't have to check equality deeply.</span></p>
			<p><span class="koboSpan" id="kobo.40.1">The following is a minimal example that can be used to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">count</span></strong><span class="koboSpan" id="kobo.42.1"> state. </span><span class="koboSpan" id="kobo.42.2">It takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">store</span></strong><span class="koboSpan" id="kobo.44.1"> creator function that returns an initial state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.45.1">// store.ts</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.46.1">import create from "zustand";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.47.1">export const store = create(() =&gt; ({ count: 0 }));</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">store</span></strong><span class="koboSpan" id="kobo.49.1"> exposes some functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">getState</span></strong><span class="koboSpan" id="kobo.51.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">setState</span></strong><span class="koboSpan" id="kobo.53.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">subscribe</span></strong><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">getState</span></strong><span class="koboSpan" id="kobo.57.1"> to get the state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">store</span></strong><span class="koboSpan" id="kobo.59.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">setState</span></strong><span class="koboSpan" id="kobo.61.1"> to set the state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">store</span></strong><span class="koboSpan" id="kobo.63.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.64.1">console.log(store.getState()); // ---&gt; { count: 0 }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.65.1">store.setState({ count: 1 });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.66.1">console.log(store.getState()); // ---&gt; { count: 1 }</span></p>
			<p><span class="koboSpan" id="kobo.67.1">The state is immutable, and you can't mutate it like you can </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">++state.count</span></strong><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">The following example is an invalid usage that violates the state's immutability:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.70.1">const state1 = store.getState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.71.1">state1.count = 2; // invalid</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.72.1">store.setState(state1);</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">state1.count = 2</span></strong><span class="koboSpan" id="kobo.74.1"> is the invalid usage, so it doesn't work as expected. </span><span class="koboSpan" id="kobo.74.2">With this invalid usage, the new state has the same reference as the old state, and the library can't detect the change properly.</span></p>
			<p><span class="koboSpan" id="kobo.75.1">The state must be updated with a new object such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">store.setState({ count: 2 })</span></strong><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">store.setState</span></strong><span class="koboSpan" id="kobo.79.1"> function also accepts a function to update:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.80.1">store.setState((prev) =&gt; ({ count: prev.count + 1 }));</span></p>
			<p><span class="koboSpan" id="kobo.81.1">This is called a function update, and it makes it easy to update the state with the previous state.</span></p>
			<p><span class="koboSpan" id="kobo.82.1">So far, we only </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.83.1">have one </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">count</span></strong><span class="koboSpan" id="kobo.85.1"> property in the state. </span><span class="koboSpan" id="kobo.85.2">The state can have </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.86.1">multiple properties. </span><span class="koboSpan" id="kobo.86.2">The following example has an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">text</span></strong><span class="koboSpan" id="kobo.88.1"> property:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.89.1">export const store = create(() =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.90.1">  count: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.91.1">  text: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.92.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.93.1">Again, the state must be updated immutably, like so:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.94.1">store.setState({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.95.1">  count: 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.96.1">  text: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.97.1">});</span></p>
			<p><span class="koboSpan" id="kobo.98.1">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">store.setState()</span></strong><span class="koboSpan" id="kobo.100.1"> will merge the new state and the old state. </span><span class="koboSpan" id="kobo.100.2">Hence, you can only specify the properties you want to set:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.101.1">console.log(store.getState());</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.102.1">store.setState({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.103.1">  count: 2,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.104.1">});</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.105.1">console.log(store.getState());</span></p>
			<p><span class="koboSpan" id="kobo.106.1">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">console.log</span></strong><span class="koboSpan" id="kobo.108.1"> statement outputs </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">{ count: 1, text: 'hello' }</span></strong><span class="koboSpan" id="kobo.110.1">, while the second one outputs </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">{ count: 2, text: 'hello' }</span></strong><span class="koboSpan" id="kobo.112.1">.</span></p>
			<p><span class="koboSpan" id="kobo.113.1">As this only changes </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">count</span></strong><span class="koboSpan" id="kobo.115.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">text</span></strong><span class="koboSpan" id="kobo.117.1"> property isn't changed. </span><span class="koboSpan" id="kobo.117.2">Internally, this is implemented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Object.assign()</span></strong><span class="koboSpan" id="kobo.119.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.120.1">Object.assign({}, oldState, newState);</span></p>
			<p><span class="koboSpan" id="kobo.121.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Object.assign</span></strong><span class="koboSpan" id="kobo.123.1"> function will return a new object by merging the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">oldState</span></strong><span class="koboSpan" id="kobo.125.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">newState</span></strong><span class="koboSpan" id="kobo.127.1"> properties.</span></p>
			<p><span class="koboSpan" id="kobo.128.1">The last </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.129.1">piece of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">store</span></strong><span class="koboSpan" id="kobo.131.1"> function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">store.subscribe</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">store.subscribe</span></strong><span class="koboSpan" id="kobo.135.1"> function allows you to register a callback function, which will be invoked </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.136.1">every time the state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">store</span></strong><span class="koboSpan" id="kobo.138.1"> is updated. </span><span class="koboSpan" id="kobo.138.2">It works like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.139.1">store.subscribe(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.140.1">  console.log("store state is changed");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.141.1">});</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.142.1">store.setState({ count: 3 });</span></p>
			<p><span class="koboSpan" id="kobo.143.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">store.setState</span></strong><span class="koboSpan" id="kobo.145.1"> statement, the </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">store state is changed</span></strong><span class="koboSpan" id="kobo.147.1"> message will be shown on the console, thanks to the subscription. </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">store.subscribe</span></strong><span class="koboSpan" id="kobo.149.1"> is an important function for implementing React hooks.</span></p>
			<p><span class="koboSpan" id="kobo.150.1">In this section, we learned about the basics of Zustand. </span><span class="koboSpan" id="kobo.150.2">You might notice that this is very close to what we learned in </span><a href="B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066"><em class="italic"><span class="koboSpan" id="kobo.151.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.152.1">, </span><em class="italic"><span class="koboSpan" id="kobo.153.1">Sharing Module State with Subscription</span></em><span class="koboSpan" id="kobo.154.1">. </span><span class="koboSpan" id="kobo.154.2">Essentially, Zustand is a thin library built around the idea of an immutable state model and subscription.</span></p>
			<p><span class="koboSpan" id="kobo.155.1">In the next section, we will learn how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">store</span></strong><span class="koboSpan" id="kobo.157.1"> in React.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.158.1">Using React hooks to optimize re-renders</span></h1>
			<p><span class="koboSpan" id="kobo.159.1">For global states, optimizing re-renders is important because not all components use all the properties </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.160.1">in a global state. </span><span class="koboSpan" id="kobo.160.2">Let's learn how Zustand addresses this. </span></p>
			<p><span class="koboSpan" id="kobo.161.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">store</span></strong><span class="koboSpan" id="kobo.163.1"> in React, we need a custom hook. </span><span class="koboSpan" id="kobo.163.2">Zustand's </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">create</span></strong><span class="koboSpan" id="kobo.165.1"> function creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">store</span></strong><span class="koboSpan" id="kobo.167.1"> that can be used as a hook.</span></p>
			<p><span class="koboSpan" id="kobo.168.1">To follow </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.169.1">the naming convention of React hooks, we have named the created value </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">useStore</span></strong><span class="koboSpan" id="kobo.171.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">store</span></strong><span class="koboSpan" id="kobo.173.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.174.1">// store.ts</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.175.1">import create from "zustand";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.176.1">export const useStore = create(() =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.177.1">  count: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.178.1">  text: "hello",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.179.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.180.1">Next, we must use the created </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">useStore</span></strong><span class="koboSpan" id="kobo.182.1"> hook in React components. </span><span class="koboSpan" id="kobo.182.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">useStore</span></strong><span class="koboSpan" id="kobo.184.1"> hook, if it's invoked, returns the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">state</span></strong><span class="koboSpan" id="kobo.186.1"> object, including all its properties. </span><span class="koboSpan" id="kobo.186.2">For example, let's define a component that shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">count</span></strong><span class="koboSpan" id="kobo.188.1"> value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">store</span></strong><span class="koboSpan" id="kobo.190.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.191.1">import { useStore } from "./store.ts";</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.192.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.193.1">  const { count, text } = useStore();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.194.1">  return &lt;div&gt;count: {count}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.195.1">};</span></p>
			<p><span class="koboSpan" id="kobo.196.1">This component shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">count</span></strong><span class="koboSpan" id="kobo.198.1"> value and that whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">store</span></strong><span class="koboSpan" id="kobo.200.1"> state is changed, it will re-render. </span><span class="koboSpan" id="kobo.200.2">While this works fine of the time, if only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">text</span></strong><span class="koboSpan" id="kobo.202.1"> value is changed and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">count</span></strong><span class="koboSpan" id="kobo.204.1"> value is not changed, the component will output essentially the same </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">JavaScript Syntax Extension</span></strong><span class="koboSpan" id="kobo.206.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.207.1">JSX</span></strong><span class="koboSpan" id="kobo.208.1">) element and users won't see any change onscreen. </span><span class="koboSpan" id="kobo.208.2">Hence, this means that changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">text</span></strong><span class="koboSpan" id="kobo.210.1"> value causes extra re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.211.1">When we </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.212.1">need to avoid extra re-renders, we can specify a selector function; that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">useStore</span></strong><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">The previous component can be rewritten with a selector function, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.215.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.216.1">  const count = useStore((state) =&gt; state.count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.217.1">  return &lt;div&gt;count: {count}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.218.1">};</span></p>
			<p><span class="koboSpan" id="kobo.219.1">By making </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.220.1">this change, but only when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">count</span></strong><span class="koboSpan" id="kobo.222.1"> value </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.223.1">is changed, the component will re-render.</span></p>
			<p><span class="koboSpan" id="kobo.224.1">This selector-based </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.225.1">extra re-render control is what we call </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">manual render optimization</span></strong><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">The way the selector works to avoid re-renders is to compare the results of what the selector function returns. </span><span class="koboSpan" id="kobo.227.3">You need to be careful when you're defining a selector function to return stable results to avoid re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.228.1">For example, the following example doesn't work well because the selector function creates a new array with a new object in it:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.229.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.230.1">  const [{ count }] = useStore(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.231.1">    (state) =&gt; [{ count: state.count }]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.232.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.233.1">  return &lt;div&gt;count: {count}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.234.1">};</span></p>
			<p><span class="koboSpan" id="kobo.235.1">As a result, the component will re-render, even if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">count</span></strong><span class="koboSpan" id="kobo.237.1"> value is unchanged. </span><span class="koboSpan" id="kobo.237.2">This is a pitfall when we use selectors for render optimization.</span></p>
			<p><span class="koboSpan" id="kobo.238.1">In summary, the benefit of selector-based render optimization is that the behavior is fairly predictable because you explicitly write selector functions. </span><span class="koboSpan" id="kobo.238.2">However, the downside of selector-based render optimization is that it requires an understanding of object references.</span></p>
			<p><span class="koboSpan" id="kobo.239.1">In this </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.240.1">section, we learned how to use a hook </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.241.1">that's been created with Zustand, as well as how to optimize re-renders with selectors.</span></p>
			<p><span class="koboSpan" id="kobo.242.1">Next, we will learn how to use Zustand with React using a minimal example.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.243.1">Working with read state and update state</span></h1>
			<p><span class="koboSpan" id="kobo.244.1">While Zustand </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.245.1">is a library that can be used in various ways, it has </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.246.1">a pattern to read state and update state. </span><span class="koboSpan" id="kobo.246.2">Let's learn how to use Zustand with a small example.</span></p>
			<p><span class="koboSpan" id="kobo.247.1">Here's our small </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">store</span></strong><span class="koboSpan" id="kobo.249.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">count1</span></strong><span class="koboSpan" id="kobo.251.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">count2</span></strong><span class="koboSpan" id="kobo.253.1"> properties:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.254.1">type StoreState = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.255.1">  count1: number;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.256.1">  count2: number;                                        </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.257.1">};                      </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.258.1">const useStore = create&lt;StoreState&gt;(() =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.259.1">  count1: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.260.1">  count2: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.261.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.262.1">This creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">store</span></strong><span class="koboSpan" id="kobo.264.1"> with two properties called </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">count1</span></strong><span class="koboSpan" id="kobo.266.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">count2</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">Notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">StoreState</span></strong><span class="koboSpan" id="kobo.270.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">type</span></strong><span class="koboSpan" id="kobo.272.1"> definition in TypeScript.</span></p>
			<p><span class="koboSpan" id="kobo.273.1">Next, we must define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Counter1</span></strong><span class="koboSpan" id="kobo.275.1"> component, which shows a </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">count1</span></strong><span class="koboSpan" id="kobo.277.1"> value. </span><span class="koboSpan" id="kobo.277.2">We must define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">selectCount1</span></strong><span class="koboSpan" id="kobo.279.1"> selector function in advance and pass it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">useStore</span></strong><span class="koboSpan" id="kobo.281.1"> to optimize re-renders:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.282.1">const selectCount1 = (state: StoreState) =&gt; state.count1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.283.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.284.1">  const count1 = useStore(selectCount1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.285.1">  const inc1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.286.1">    useStore.setState(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.287.1">      (prev) =&gt; ({ count1: prev.count1 + 1 })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.288.1">    );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.289.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.290.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.291.1">    &lt;div&gt;           </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.292.1">      count1: {count1} &lt;button onClick={inc1}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.293.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.294.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">};</span></p>
			<p><span class="koboSpan" id="kobo.296.1">Notice that </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.297.1">the inline </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">inc1</span></strong><span class="koboSpan" id="kobo.299.1"> function is defined. </span><span class="koboSpan" id="kobo.299.2">We invoke </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.300.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">setState</span></strong><span class="koboSpan" id="kobo.302.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">store</span></strong><span class="koboSpan" id="kobo.304.1">. </span><span class="koboSpan" id="kobo.304.2">This is a typical pattern and we can define the function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">store</span></strong><span class="koboSpan" id="kobo.306.1"> for more reusability and readability.</span></p>
			<p><span class="koboSpan" id="kobo.307.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">store</span></strong><span class="koboSpan" id="kobo.309.1"> creator function that is passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">create</span></strong><span class="koboSpan" id="kobo.311.1"> function takes some arguments; the first argument is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">setState</span></strong><span class="koboSpan" id="kobo.313.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">store</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">Let's redefine our </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">store</span></strong><span class="koboSpan" id="kobo.317.1"> with this capability:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.318.1">type StoreState = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.319.1">  count1: number;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.320.1">  count2: number;                                        </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.321.1">  inc1: () =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.322.1">  inc2: () =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.323.1">};                      </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.324.1">const useStore = create&lt;StoreState&gt;((set) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.325.1">  count1: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.326.1">  count2: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.327.1">  inc1: () =&gt; set(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.328.1">    (prev) =&gt; ({ count1: prev.count1 + 1 })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.329.1">  ),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.330.1">  inc2: () =&gt; set(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.331.1">    (prev) =&gt; ({ count2: prev.count2 + 1 })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.332.1">  ),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.333.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.334.1">Now, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">store</span></strong><span class="koboSpan" id="kobo.336.1"> has two new properties called </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">inc1</span></strong><span class="koboSpan" id="kobo.338.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">inc2</span></strong><span class="koboSpan" id="kobo.340.1">, which are function properties. </span><span class="koboSpan" id="kobo.340.2">Note </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.341.1">that it's a good convention to name the first </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.342.1">argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">set</span></strong><span class="koboSpan" id="kobo.344.1">, which is short for </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">setState</span></strong><span class="koboSpan" id="kobo.346.1">.</span></p>
			<p><span class="koboSpan" id="kobo.347.1">Using the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">store</span></strong><span class="koboSpan" id="kobo.349.1">, we must define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Counter2</span></strong><span class="koboSpan" id="kobo.351.1"> component. </span><span class="koboSpan" id="kobo.351.2">You can compare it to the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Counter1</span></strong><span class="koboSpan" id="kobo.353.1"> component and notice that it can be refactored in the same way:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">const selectCount2 = (state: StoreState) =&gt; state.count2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">const selectInc2 = (state: StoreState) =&gt; state.inc2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.356.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.357.1">  const count2 = useStore(selectCount2);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.358.1">  const inc2 = useStore(selectInc2);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.359.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.360.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.361.1">      count2: {count2} &lt;button onClick={inc2}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.362.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.363.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.364.1">};</span></p>
			<p><span class="koboSpan" id="kobo.365.1">In this example, we have a new selector function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">selectInc2</span></strong><span class="koboSpan" id="kobo.367.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">inc2</span></strong><span class="koboSpan" id="kobo.369.1"> function is just the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">useStore</span></strong><span class="koboSpan" id="kobo.371.1">. </span><span class="koboSpan" id="kobo.371.2">Likewise, we could add more functions to </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">store</span></strong><span class="koboSpan" id="kobo.373.1">, which allows some logic to reside outside the components. </span><span class="koboSpan" id="kobo.373.2">You can co-locate state updating logic close to the state values. </span><span class="koboSpan" id="kobo.373.3">This is the reason why Zustand's </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">setState</span></strong><span class="koboSpan" id="kobo.375.1"> merges old state and new state. </span><span class="koboSpan" id="kobo.375.2">We also discussed this in the </span><em class="italic"><span class="koboSpan" id="kobo.376.1">Understanding module state and immutable state</span></em><span class="koboSpan" id="kobo.377.1"> section, where we learned how </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">Object.assign</span></strong><span class="koboSpan" id="kobo.379.1"> is used.</span></p>
			<p><span class="koboSpan" id="kobo.380.1">What if we </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.381.1">want to create a derived state? </span><span class="koboSpan" id="kobo.381.2">We can use a selector </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.382.1">for a derived state. </span><span class="koboSpan" id="kobo.382.2">First, let's look at a naive example. </span><span class="koboSpan" id="kobo.382.3">The following is a new component that shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">total</span></strong><span class="koboSpan" id="kobo.384.1"> number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">count1</span></strong><span class="koboSpan" id="kobo.386.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">count2</span></strong><span class="koboSpan" id="kobo.388.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.389.1">const Total = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.390.1">  const count1 = useStore(selectCount1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.391.1">  const count2 = useStore(selectCount2);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.392.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.393.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.394.1">      total: {count1 + count2}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.395.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.396.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.397.1">};</span></p>
			<p><span class="koboSpan" id="kobo.398.1">This is a valid pattern and it can stay as-is. </span><span class="koboSpan" id="kobo.398.2">There is an edge case where extra re-renders happen, which is when </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">count1</span></strong><span class="koboSpan" id="kobo.400.1"> is increased and </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">count2</span></strong><span class="koboSpan" id="kobo.402.1"> is decreased by the same amount. </span><span class="koboSpan" id="kobo.402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">total</span></strong><span class="koboSpan" id="kobo.404.1"> number won't change, but it will re-render. </span><span class="koboSpan" id="kobo.404.2">To avoid this, we can use a selector function for the derived state.</span></p>
			<p><span class="koboSpan" id="kobo.405.1">The following example shows a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">selectTotal</span></strong><span class="koboSpan" id="kobo.407.1"> function being used to calculate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">total</span></strong><span class="koboSpan" id="kobo.409.1"> number:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.410.1">const selectTotal = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.411.1">  (state: StoreState) =&gt; state.count1 + state.count2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.412.1">const Total = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.413.1">  const total = useStore(selectTotal);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.414.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.415.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.416.1">      total: {total}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.417.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.418.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.419.1">};</span></p>
			<p><span class="koboSpan" id="kobo.420.1">This will only re-render when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">total</span></strong><span class="koboSpan" id="kobo.422.1"> number is changed.</span></p>
			<p><span class="koboSpan" id="kobo.423.1">With that, we have calculated the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">total</span></strong><span class="koboSpan" id="kobo.425.1"> number in a selector. </span><span class="koboSpan" id="kobo.425.2">While this is a valid solution, let's look at another approach where we can create the total number in the store. </span><span class="koboSpan" id="kobo.425.3">If we </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.426.1">could create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">total</span></strong><span class="koboSpan" id="kobo.428.1"> number in </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">store</span></strong><span class="koboSpan" id="kobo.430.1">, it could </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.431.1">remember the result and we can avoid unnecessary calculations when many components are using the value. </span><span class="koboSpan" id="kobo.431.2">This is not very common, but it's important if the calculation is very computation-heavy. </span><span class="koboSpan" id="kobo.431.3">A naive way to do this would be as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.432.1">const useStore = create((set) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.433.1">  count1: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.434.1">  count2: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.435.1">  total: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.436.1">  inc1: () =&gt; set((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.437.1">    ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.438.1">    count1: prev.count1 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.439.1">    total: prev.count1 + 1 + prev.count2,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.440.1">  })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.441.1">  inc2: () =&gt; set((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.442.1">    ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.443.1">    count2: prev.count2 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.444.1">    total: prev.count2 + 1 + prev.count1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.445.1">  })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.446.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.447.1">There is a </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.448.1">more sophisticated way to do this, but the base </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.449.1">idea is to calculate multiple properties at the same time and keep them in sync. </span><span class="koboSpan" id="kobo.449.2">Another library, Jotai, handles this well. </span><span class="koboSpan" id="kobo.449.3">Refer to </span><a href="B17780_08_Final_VK_ePub.xhtml#_idTextAnchor100"><em class="italic"><span class="koboSpan" id="kobo.450.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.451.1">, </span><em class="italic"><span class="koboSpan" id="kobo.452.1">Use Case Scenario 2 – Jotai</span></em><span class="koboSpan" id="kobo.453.1">, to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.454.1">The last missing piece for running the example app is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">App</span></strong><span class="koboSpan" id="kobo.456.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.457.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.459.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.460.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.461.1">    &lt;Total /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.462.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.463.1">);</span></p>
			<p><span class="koboSpan" id="kobo.464.1"> When you run this app, you will see something like the following:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<span class="koboSpan" id="kobo.465.1"><img src="image/Figure_7.1_B17780.jpg" alt="Figure 7.1 – Screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.466.1">Figure 7.1 – Screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.467.1">If you click the first button, you will see that both numbers on the screen – after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">count1</span></strong><span class="koboSpan" id="kobo.469.1"> label and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">total</span></strong><span class="koboSpan" id="kobo.471.1"> number – increase. </span><span class="koboSpan" id="kobo.471.2">If you click the second button, you will see that </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.472.1">both numbers on the screen – after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">count2</span></strong><span class="koboSpan" id="kobo.474.1"> label </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.475.1">and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">total</span></strong><span class="koboSpan" id="kobo.477.1"> number – increase.</span></p>
			<p><span class="koboSpan" id="kobo.478.1">In this section, we learned about reading and updating the state in a way that is often used in Zustand. </span><span class="koboSpan" id="kobo.478.2">Next, we will learn about how to handle structured data and how to use arrays.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.479.1">Handling structured data</span></h1>
			<p><span class="koboSpan" id="kobo.480.1">An example </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.481.1">that deals with a set of numbers is fairly easy. </span><span class="koboSpan" id="kobo.481.2">In reality, we need to handle objects, arrays, and a combination of them. </span><span class="koboSpan" id="kobo.481.3">Let's learn how to use Zustand by covering another example. </span><span class="koboSpan" id="kobo.481.4">This is a well-known Todo app example. </span><span class="koboSpan" id="kobo.481.5">It's an app where you can do the following things:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.482.1">Create a new Todo item.</span></li>
				<li><span class="koboSpan" id="kobo.483.1">See the list of Todo items.</span></li>
				<li><span class="koboSpan" id="kobo.484.1">Toggle a Todo item's done status.</span></li>
				<li><span class="koboSpan" id="kobo.485.1">Remove a Todo item.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.486.1">First, we must </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.487.1">define some types before creating a store. </span><span class="koboSpan" id="kobo.487.2">The following is the type definition for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Todo</span></strong><span class="koboSpan" id="kobo.489.1"> object. </span><span class="koboSpan" id="kobo.489.2">It has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">id</span></strong><span class="koboSpan" id="kobo.491.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">title</span></strong><span class="koboSpan" id="kobo.493.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">done</span></strong><span class="koboSpan" id="kobo.495.1"> properties:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.496.1">type Todo = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">  id: number;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.498.1">  title: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.499.1">  done: boolean;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.500.1">};</span></p>
			<p><span class="koboSpan" id="kobo.501.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">StoreState</span></strong><span class="koboSpan" id="kobo.503.1"> type can be defined with </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Todo</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">The value part of the store is </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">todos</span></strong><span class="koboSpan" id="kobo.507.1">, which is a list of Todo items. </span><span class="koboSpan" id="kobo.507.2">In addition to this, there are three functions – </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">addTodo</span></strong><span class="koboSpan" id="kobo.509.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">removeTodo</span></strong><span class="koboSpan" id="kobo.511.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.513.1"> – that can be used to manipulate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">todos</span></strong><span class="koboSpan" id="kobo.515.1"> property:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.516.1">type StoreState = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.517.1">  todos: Todo[];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">  addTodo: (title: string) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.519.1">  removeTodo: (id: number) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.520.1">  toggleTodo: (id: number) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.521.1">};</span></p>
			<p><span class="koboSpan" id="kobo.522.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">todos</span></strong><span class="koboSpan" id="kobo.524.1"> property is an array of objects. </span><span class="koboSpan" id="kobo.524.2">Having an array of objects in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">store</span></strong><span class="koboSpan" id="kobo.526.1"> state is a typical practice and will be the focus of this section.</span></p>
			<p><span class="koboSpan" id="kobo.527.1">Next, we must define </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">store</span></strong><span class="koboSpan" id="kobo.529.1">. </span><span class="koboSpan" id="kobo.529.2">It's also a hook that's called </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">useStore</span></strong><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">When it's created, </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">store</span></strong><span class="koboSpan" id="kobo.533.1"> has an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">todos</span></strong><span class="koboSpan" id="kobo.535.1"> property and three functions called </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">addTodo</span></strong><span class="koboSpan" id="kobo.537.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">removeTodo</span></strong><span class="koboSpan" id="kobo.539.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.541.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">nextId</span></strong><span class="koboSpan" id="kobo.543.1"> is defined outside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">create</span></strong><span class="koboSpan" id="kobo.545.1"> function as a naive solution to provide a unique </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">id</span></strong><span class="koboSpan" id="kobo.547.1"> for a new Todo item:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.548.1">let nextId = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.549.1">const useStore = create&lt;StoreState&gt;((set) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.550.1">  todos: [],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.551.1">  addTodo: (title) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.552.1">    set((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.553.1">      todos: [</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.554.1">        ...prev.todos,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.555.1">        { id: ++nextId, title, done: false },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.556.1">      ],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.557.1">    })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.558.1">  removeTodo: (id) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.559.1">    set((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.560.1">      todos: prev.todos.filter((todo) =&gt; todo.id !== id),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.561.1">    })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.562.1">  toggleTodo: (id) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.563.1">    set((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.564.1">      todos: prev.todos.map((todo) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.565.1">        todo.id === id ? </span><span class="koboSpan" id="kobo.565.2">{ ...todo, done: !todo.done } :</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.566.1">          todo</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.567.1">      ),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.568.1">    })),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.569.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.570.1">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">addTodo</span></strong><span class="koboSpan" id="kobo.572.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">removeTodo</span></strong><span class="koboSpan" id="kobo.574.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.576.1"> functions are implemented in an immutable manner. </span><span class="koboSpan" id="kobo.576.2">They don't mutate existing objects and arrays; they create new ones instead.</span></p>
			<p><span class="koboSpan" id="kobo.577.1">Before we </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.578.1">define a main </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">TodoList</span></strong><span class="koboSpan" id="kobo.580.1"> component, let's look at a </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">TodoItem</span></strong><span class="koboSpan" id="kobo.582.1"> component that is responsible for rendering one item:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.583.1">const selectRemoveTodo = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.584.1">  (state: StoreState) =&gt; state.removeTodo;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.585.1">const selectToggleTodo = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.586.1">  (state: StoreState) =&gt; state.toggleTodo;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.587.1">const TodoItem = ({ todo }: { todo: Todo }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.588.1">  const removeTodo = useStore(selectRemoveTodo);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.589.1">  const toggleTodo = useStore(selectToggleTodo);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.590.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.591.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.592.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.593.1">        type="checkbox"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.594.1">        checked={todo.done}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.595.1">        onChange={() =&gt; toggleTodo(todo.id)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.596.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.597.1">      &lt;span</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.598.1">        style={{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.599.1">          textDecoration: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.600.1">            todo.done ? </span><span class="koboSpan" id="kobo.600.2">"line-through" : "none",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.601.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.602.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.603.1">        {todo.title}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.604.1">      &lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.605.1">      &lt;button</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.606.1">        onClick={() =&gt; removeTodo(todo.id)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.607.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.608.1">        Delete</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.609.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.610.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.611.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.612.1">};</span></p>
			<p><span class="koboSpan" id="kobo.613.1">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">TodoItem</span></strong><span class="koboSpan" id="kobo.615.1"> component takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">todo</span></strong><span class="koboSpan" id="kobo.617.1"> object in </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">props</span></strong><span class="koboSpan" id="kobo.619.1">, it's a fairly simple component in terms of states. </span><span class="koboSpan" id="kobo.619.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">TodoItem</span></strong><span class="koboSpan" id="kobo.621.1"> component has two controls: a button that is handled by </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">removeTodo</span></strong><span class="koboSpan" id="kobo.623.1"> and a checkbox that is handled by </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.625.1">. </span><span class="koboSpan" id="kobo.625.2">These are the two functions from </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">store</span></strong><span class="koboSpan" id="kobo.627.1"> for each control. </span><span class="koboSpan" id="kobo.627.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">selectRemoveTodo</span></strong><span class="koboSpan" id="kobo.629.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">selectToggleTodo</span></strong><span class="koboSpan" id="kobo.631.1"> functions are passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">useStore</span></strong><span class="koboSpan" id="kobo.633.1"> function to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">removeTodo</span></strong><span class="koboSpan" id="kobo.635.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.637.1"> functions, respectively.</span></p>
			<p><span class="koboSpan" id="kobo.638.1">Let's create </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.639.1">a memoized version of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">TodoItem</span></strong><span class="koboSpan" id="kobo.641.1"> component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.643.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.644.1">const MemoedTodoItem = memo(TodoItem);</span></p>
			<p><span class="koboSpan" id="kobo.645.1">Now, we will discuss how this will help in our app. </span><span class="koboSpan" id="kobo.645.2">We are ready to define the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">TodoList</span></strong><span class="koboSpan" id="kobo.647.1"> component. </span><span class="koboSpan" id="kobo.647.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">selectTodos</span></strong><span class="koboSpan" id="kobo.649.1">, a function that's used to select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">todos</span></strong><span class="koboSpan" id="kobo.651.1"> property from </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">store</span></strong><span class="koboSpan" id="kobo.653.1">. </span><span class="koboSpan" id="kobo.653.2">Then, it maps over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">todos</span></strong><span class="koboSpan" id="kobo.655.1"> array and renders </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.657.1"> for each todo item.</span></p>
			<p><span class="koboSpan" id="kobo.658.1">It is important to use the memoized component here to avoid extra re-renders. </span><span class="koboSpan" id="kobo.658.2">Because we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">store</span></strong><span class="koboSpan" id="kobo.660.1"> state in an immutable manner, most of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">todo</span></strong><span class="koboSpan" id="kobo.662.1"> objects in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">todos</span></strong><span class="koboSpan" id="kobo.664.1"> array are not changed. </span><span class="koboSpan" id="kobo.664.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">todo</span></strong><span class="koboSpan" id="kobo.666.1"> object we pass to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.668.1"> props is not changed, the component won't re-render. </span><span class="koboSpan" id="kobo.668.2">Whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">todos</span></strong><span class="koboSpan" id="kobo.670.1"> array is changed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">TodoList</span></strong><span class="koboSpan" id="kobo.672.1"> component re-renders. </span><span class="koboSpan" id="kobo.672.2">However, its child components only re-render if the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">todo</span></strong><span class="koboSpan" id="kobo.674.1"> item is changed.</span></p>
			<p><span class="koboSpan" id="kobo.675.1">The following code shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">selectTodos</span></strong><span class="koboSpan" id="kobo.677.1"> function and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">TodoList</span></strong><span class="koboSpan" id="kobo.679.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.680.1">const selectTodos = (state: StoreState) =&gt; state.todos;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.681.1">const TodoList = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.682.1">  const todos = useStore(selectTodos);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.683.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.684.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.685.1">      {todos.map((todo) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.686.1">        &lt;MemoedTodoItem key={todo.id} todo={todo} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.687.1">      ))}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.688.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.689.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.690.1">};</span></p>
			<p><span class="koboSpan" id="kobo.691.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">TodoList</span></strong><span class="koboSpan" id="kobo.693.1"> component maps over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">todos</span></strong><span class="koboSpan" id="kobo.695.1"> list and, for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">todo</span></strong><span class="koboSpan" id="kobo.697.1"> item, renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.699.1"> component.</span></p>
			<p><span class="koboSpan" id="kobo.700.1">What remains </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.701.1">is to add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">todo</span></strong><span class="koboSpan" id="kobo.703.1"> item. </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">NewTodo</span></strong><span class="koboSpan" id="kobo.705.1"> is a component that can be used to render a text box and a button, as well as to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">addTodo</span></strong><span class="koboSpan" id="kobo.707.1"> function when the button is clicked. </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">selectAddTodo</span></strong><span class="koboSpan" id="kobo.709.1"> is a function that can be used to select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">addTodo</span></strong><span class="koboSpan" id="kobo.711.1"> function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">store</span></strong><span class="koboSpan" id="kobo.713.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.714.1">const selectAddTodo = (state: StoreState) =&gt; state.addTodo;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.715.1">const NewTodo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.716.1">  const addTodo = useStore(selectAddTodo);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.717.1">  const [text, setText] = useState("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.718.1">  const onClick = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.719.1">    addTodo(text);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.720.1">    setText(""); // [1]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.721.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.722.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.723.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.724.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.725.1">        value={text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.726.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.727.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.728.1">      &lt;button onClick={onClick} disabled={!text}&gt; // [2]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.729.1">        Add</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.730.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.731.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.732.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.733.1">};</span></p>
			<p><span class="koboSpan" id="kobo.734.1">There are </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.735.1">two minor notes we should mention regarding improving the behavior in </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">NewTodo</span></strong><span class="koboSpan" id="kobo.737.1">:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.738.1">It clears the text box when the button is clicked </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">[1]</span></strong><span class="koboSpan" id="kobo.740.1">.</span></li>
				<li><span class="koboSpan" id="kobo.741.1">It disables the button when the text box is empty </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">[2]</span></strong><span class="koboSpan" id="kobo.743.1">.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.744.1">Finally, to finish up the Todo app, we must define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">App</span></strong><span class="koboSpan" id="kobo.746.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.747.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.748.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.749.1">    &lt;TodoList /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.750.1">    &lt;NewTodo /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.751.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.752.1">);</span></p>
			<p><span class="koboSpan" id="kobo.753.1">Running this app will show only a text box and a disabled </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">Add</span></strong><span class="koboSpan" id="kobo.755.1"> button at first:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<span class="koboSpan" id="kobo.756.1"><img src="image/Figure_7.2_B17780.jpg" alt="Figure 7.2 – First screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.757.1">Figure 7.2 – First screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.758.1">If you enter some text and click the </span><strong class="bold"><span class="koboSpan" id="kobo.759.1">Add</span></strong><span class="koboSpan" id="kobo.760.1"> button, the item will appear:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<span class="koboSpan" id="kobo.761.1"><img src="image/Figure_7.3_B17780.jpg" alt="Figure 7.3 – Second screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.762.1">Figure 7.3 – Second screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.763.1">Clicking a </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.764.1">checkbox will toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">done</span></strong><span class="koboSpan" id="kobo.766.1"> status of the item:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<span class="koboSpan" id="kobo.767.1"><img src="image/Figure_7.4_B17780.jpg" alt="Figure 7.4 – Third screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.768.1">Figure 7.4 – Third screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.769.1">Clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.770.1">Delete</span></strong><span class="koboSpan" id="kobo.771.1"> button on the screen will delete the item:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<span class="koboSpan" id="kobo.772.1"><img src="image/Figure_7.5_B17780.jpg" alt="Figure 7.5 – Fourth screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.773.1">Figure 7.5 – Fourth screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.774.1">You can add as many items as you want. </span><span class="koboSpan" id="kobo.774.2">All these features are implemented with all the code we have discussed in this section. </span><span class="koboSpan" id="kobo.774.3">Re-renders are optimized, thanks to the immutable update of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">store</span></strong><span class="koboSpan" id="kobo.776.1"> state and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">memo</span></strong><span class="koboSpan" id="kobo.778.1"> function provided by React.</span></p>
			<p><span class="koboSpan" id="kobo.779.1">In this section, we learned how to handle arrays with a typical Todo app example. </span><span class="koboSpan" id="kobo.779.2">Next, we will discuss the pros and cons of this library and the approach in general.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.780.1">Pros and cons of this approach and library</span></h1>
			<p><span class="koboSpan" id="kobo.781.1">Let's discuss the </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.782.1">pros and cons of using Zustand or any other libraries to implement </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.783.1"> this approach.</span></p>
			<p><span class="koboSpan" id="kobo.784.1">To recap, the following are the reading and writing states of Zustand:</span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.785.1">Reading state</span></strong><span class="koboSpan" id="kobo.786.1">: This utilizes </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.787.1">selector functions to optimize re-renders.</span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.788.1">Writing state</span></strong><span class="koboSpan" id="kobo.789.1">: This is </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.790.1">based on the immutable state model.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.791.1">The key point is that React is based on object immutability for optimization. </span><span class="koboSpan" id="kobo.791.2">One example is </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">useState</span></strong><span class="koboSpan" id="kobo.793.1">. </span><span class="koboSpan" id="kobo.793.2">React optimizes re-renders with object referential equality based on immutability. </span><span class="koboSpan" id="kobo.793.3">The following example illustrates this behavior:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.794.1">const countObj = { value: 0 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.795.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.796.1">  const [count, setCount] = useState(countObj);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.797.1">  const handleClick = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.798.1">    setCount(countObj);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.799.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.800.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.801.1">    console.log("component updated");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.802.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.803.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.804.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.805.1">      {count.value}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.806.1">      &lt;button onClick={handleClick}&gt;Update&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.807.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.808.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.809.1">};</span></p>
			<p><span class="koboSpan" id="kobo.810.1">Here, even if you click the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">Update</span></strong><span class="koboSpan" id="kobo.812.1"> button, it won't show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">"component updated"</span></strong><span class="koboSpan" id="kobo.814.1"> message. </span><span class="koboSpan" id="kobo.814.2">This is </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.815.1">because React assumes that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">countObj</span></strong><span class="koboSpan" id="kobo.817.1"> value will not </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.818.1">change if the object reference is the same. </span><span class="koboSpan" id="kobo.818.2">This means that changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">handleClick</span></strong><span class="koboSpan" id="kobo.820.1"> function doesn't make any changes:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.821.1">  const handleClick = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.822.1">    countObj.value += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.823.1">    setCount(countObj);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.824.1">  };</span></p>
			<p><span class="koboSpan" id="kobo.825.1">If you call </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">handleClick</span></strong><span class="koboSpan" id="kobo.827.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">countObj</span></strong><span class="koboSpan" id="kobo.829.1"> value will change, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">countObj</span></strong><span class="koboSpan" id="kobo.831.1"> object won't. </span><span class="koboSpan" id="kobo.831.2">Hence, React assumes it's unchanged. </span><span class="koboSpan" id="kobo.831.3">This is what we mean by React being based on immutability for optimization. </span><span class="koboSpan" id="kobo.831.4">This same behavior can be observed with functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">memo</span></strong><span class="koboSpan" id="kobo.833.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">useMemo</span></strong><span class="koboSpan" id="kobo.835.1">.</span></p>
			<p><span class="koboSpan" id="kobo.836.1">The Zustand state model is perfectly in line with this object immutability assumption (or convention). </span><span class="koboSpan" id="kobo.836.2">Zustand's render optimization with selector functions is also based on immutability – that is, if a selector function returns the same object referentially (or value), it assumes that the object is not changed and avoids re-rendering.</span></p>
			<p><span class="koboSpan" id="kobo.837.1">Zustand having the same model as React gives us a huge benefit in terms of library simplicity and its small bundle size. </span></p>
			<p><span class="koboSpan" id="kobo.838.1">On the other hand, a limitation of Zustand is its manual render optimization with selectors. </span><span class="koboSpan" id="kobo.838.2">It requires that we understand object referential equality and the code for selectors tends to require more boilerplate code.</span></p>
			<p><span class="koboSpan" id="kobo.839.1">In summary, Zustand – or any other libraries with this approach – is a simple addition to the React principle. </span><span class="koboSpan" id="kobo.839.2">It's a good recommendation if you need a library with a small bundle size, if you are familiar with referential equality and memoization, or you prefer manual render optimization.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.840.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.841.1">In this chapter, we learned about the Zustand library. </span><span class="koboSpan" id="kobo.841.2">It's a tiny library that uses module state in React. </span><span class="koboSpan" id="kobo.841.3">We looked at a counting example and a Todo example to grasp how to use the library. </span><span class="koboSpan" id="kobo.841.4">We typically use this library to understand object referential equality. </span><span class="koboSpan" id="kobo.841.5">You can choose this library or similar approaches based on your requirements and what you have learned in this chapter.</span></p>
			<p><span class="koboSpan" id="kobo.842.1">We didn't discuss some aspects of Zustand in this chapter, including middleware, which allows you to give some features to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">store</span></strong><span class="koboSpan" id="kobo.844.1"> creator, and non-module state usage, which creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">store</span></strong><span class="koboSpan" id="kobo.846.1"> in the React life cycle. </span><span class="koboSpan" id="kobo.846.2">These can be other considerations when you're choosing a library. </span><span class="koboSpan" id="kobo.846.3">You should always refer to the library documentation for more – and the latest – information.</span></p>
			<p><span class="koboSpan" id="kobo.847.1">In the next chapter, we will learn about another library, Jotai.</span></p>
		</div>
	</body></html>