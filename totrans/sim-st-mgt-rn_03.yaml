- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Planning and Setting Up the Funbook App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划和设置Funbook应用
- en: 'In the previous chapter, we learned how to set up a React Native app. The steps
    we followed, installing dependencies and building and running the app, are common
    for most apps you may want to build. Now, it’s time to focus on the specifics
    of the app we will be building in this book. We want to create a social media
    clone app so that we can compare different state management solutions in that
    app. In this chapter, we will plan and build our example app using only React
    Native built-in solutions – state, props, hooks, and context. We will take the
    following steps:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何设置React Native应用。我们遵循的步骤，安装依赖项、构建和运行应用，对于您可能想要构建的大多数应用都是通用的。现在，是时候关注我们将在这本书中构建的应用的具体细节了。我们想要创建一个社交媒体克隆应用，以便我们可以比较该应用中不同的状态管理解决方案。在本章中，我们将仅使用React
    Native内置解决方案（状态、属性、钩子和上下文）规划和构建我们的示例应用。我们将采取以下步骤：
- en: Planning the needed surfaces and components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划所需界面和组件
- en: Planning data flows in the app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用中规划数据流
- en: Getting comfortable previewing and debugging the app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 舒适地预览和调试应用
- en: By the end of this chapter, you will have a good idea of planning out development
    work for the Funbook app. You will also find out how to work comfortably with
    a React Native app.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将很好地了解如何规划Funbook应用的开发工作。您还将了解到如何舒适地与React Native应用一起工作。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to follow along with this chapter, you will need some knowledge of
    JavaScript and ReactJS. If you have followed the first two chapters of this book,
    you should be able to go forward without any issues.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，您需要具备一些JavaScript和ReactJS的知识。如果您已经跟随了本书的前两章，您应该能够无任何问题地继续前进。
- en: Feel free to use an IDE of your choice, as React Native does not need any specific
    functionality. Currently, the most popular IDEs for frontend developers are Microsoft’s
    VSCode, Atom, Sublime Text, and WebStorm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由选择您喜欢的IDE，因为React Native不需要任何特定功能。目前，前端开发者中最受欢迎的IDE是微软的VSCode、Atom、Sublime
    Text和WebStorm。
- en: 'You may have followed the setup guide from the previous chapter. In case you
    didn’t set up your own app, you can clone the repo dedicated to this book:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经遵循了上一章中的设置指南。如果您没有设置自己的应用，您可以从以下地址克隆为本书专设的存储库：
- en: https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native.
- en: In this repository, you will find a very basic app, as it was set up in the
    previous chapter. You will also find folders with chapter names. Not surprisingly,
    each folder holds a version of the Funbook app as described in a given chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个存储库中，您将找到一个非常基础的应用，正如它在上一章中设置的那样。您还将找到以章节名称命名的文件夹。不出所料，每个文件夹都包含一个描述在给定章节中所述的Funbook应用的版本。
- en: Planning the needed surfaces and components
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划所需界面和组件
- en: 'As I’ve mentioned before, we can divide our app into surfaces, and then break
    down the surfaces into smaller, reusable components. Our app will need the following
    surfaces:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，我们可以将我们的应用分为界面，然后将界面分解成更小、可重用的组件。我们的应用将需要以下界面：
- en: '**Login**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录**'
- en: '**Feed** (which is also our **Home** surface)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**（这同样是我们的**主页**界面）'
- en: '**Add Post**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加帖子**'
- en: '**Favorites**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收藏**'
- en: '**Profile**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人资料**'
- en: 'We have those surfaces set up as files in our project. Let’s take a quick look
    at the free design file we’ll be using for our app. You can find the file here:
    [https://www.pixeltrue.com/free-ui-kits/social-media-app](https://www.pixeltrue.com/free-ui-kits/social-media-app).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些界面作为项目中的文件设置。让我们快速查看我们将为应用使用的免费设计文件。您可以在以下位置找到文件：[https://www.pixeltrue.com/free-ui-kits/social-media-app](https://www.pixeltrue.com/free-ui-kits/social-media-app)。
- en: 'You can download this file and open it in Figma or import it at [https://www.figma.com](https://www.figma.com).
    If you don’t have a Figma account yet – don’t worry, they’re free. You can take
    a moment right now to look at the actual file, or if a screenshot is enough for
    you, let’s look together:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载此文件并在Figma中打开它，或者将其导入到[https://www.figma.com](https://www.figma.com)。如果您还没有Figma账户，请不要担心，它们是免费的。您现在可以花点时间查看实际文件，或者如果您对截图就足够了，我们就一起看看：
- en: '![Figure 3.1 – Figma website with the design template ](img/Figure_3.01_B18396.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 带有设计模板的Figma网站](img/Figure_3.01_B18396.jpg)'
- en: Figure 3.1 – Figma website with the design template
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Figma网站上的设计模板
- en: 'Let’s zoom in on the home page:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放大查看主页：
- en: '![Figure 3.2 – Design of the home surface ](img/Figure_3.02_B18396.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 主页面的设计](img/Figure_3.02_B18396.jpg)'
- en: Figure 3.2 – Design of the home surface
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 主页表面的设计
- en: 'You may have noticed there are five items in the bottom tabs on the design.
    Which one are we missing? The chat bubble. Let’s go ahead and add this surface
    to our app. I encourage you to add this file on your own and then come back here
    and check against my example. Here’s what my `Conversations` surface looks like
    so far:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到设计底部标签栏中有五个项目。我们遗漏了哪一个？聊天气泡。让我们继续将这个表面添加到我们的应用中。我鼓励你亲自添加这个文件，然后回到这里对照我的例子进行检查。以下是我的`Conversations`表面目前的样子：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here’s the `App.js` file with the newly added screen:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是带有新添加屏幕的`App.js`文件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Okay! Looking good so far!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！到目前为止看起来不错！
- en: Now that we have our main surfaces set up, let’s try to analyze which elements
    are good candidates for reusable components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了主要表面，让我们尝试分析哪些元素是可重复使用的组件的良好候选者。
- en: Looking back at the design file, let’s start with the **Home** surface. At the
    top, we see a horizontal list of avatars and a list of repetitive cards below.
    Each card has an author image, a title, a favorite count, and a conversation count.
    So, the home component should be built out of avatar and card components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾设计文件，让我们从**主页**表面开始。在顶部，我们看到一个横向的头像列表和下面的重复卡片列表。每个卡片都有一个作者图像、标题、收藏数量和对话数量。因此，主页组件应该由头像和卡片组件构建。
- en: 'Moving on to the **Conversations** screen: it consists of a search bar and
    a list of cards with the name of the person in the conversation and the last message
    exchanged. When a message is clicked, we will go to the screen named **Messaging**
    in the Figma file, where we will see a bigger avatar, a list of messages, and
    an input box. Remember we already have avatars on the home page; let’s see whether
    we can reuse an avatar component. Maybe only to some extent, since the styles
    are not the same for the home avatars, the conversations avatars, and the messaging
    avatars. They are all round images, but they have different borders and sizes.
    Maybe we could create an avatar component that accepts size and border style as
    a prop. That’s a pretty good idea! We’ll try to achieve this when we get to writing
    code.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**对话**屏幕：它由一个搜索栏和一张显示对话中人的名字和最后一条交换的消息的卡片列表组成。当点击消息时，我们将进入Figma文件中名为**消息**的屏幕，在那里我们将看到一个更大的头像、一条消息列表和一个输入框。记住我们已经在主页上有头像了；让我们看看我们是否可以重用头像组件。也许只能在一定程度上，因为主页头像、对话头像和消息头像的样式并不相同。它们都是圆形图像，但它们的边框和大小不同。也许我们可以创建一个接受大小和边框样式作为属性的头像组件。这是一个相当不错的想法！当我们开始编写代码时，我们将尝试实现这一点。
- en: 'The last detailed surface we will in our free design file is **Profile**. We
    have yet another avatar here; this one is not even round. It’s followed by the
    username, some statistics, and a two-column list of pictures and bookmarks. Since
    we’re not going to be implementing bookmarks, we will exchange the bookmarks from
    the design for favorites. You may notice that the two columns are built with two
    different styles of elements, and that’s probably how we should also create our
    components: one component for cards in the images column and one component for
    the **Favorites** card column.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的免费设计文件中，我们将要详细设计的最后一个表面是**个人资料**。这里还有一个头像；这个头像甚至不是圆形的。它后面跟着用户名、一些统计数据和一个两列的图片和书签列表。由于我们不会实现书签功能，我们将用收藏夹替换设计中的书签。你可能注意到两列是用两种不同样式的元素构建的，我们可能也应该这样创建我们的组件：一个用于图片列的卡片组件，一个用于**收藏夹**卡片列的组件。
- en: 'Last but not least: the bottom tab bar. Our design file includes four regular
    icons and one with a different style. Styling React Navigation components is a
    separate task altogether, as we will need to read the documentation to find out
    how to implement a custom icon, active and inactive styles, as well as custom
    styles.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是：底部的标签栏。我们的设计文件包括四个常规图标和一个不同风格的图标。对React Navigation组件进行样式化是一个完全不同的任务，因为我们需要阅读文档来找出如何实现自定义图标、激活和未激活样式，以及自定义样式。
- en: Since we are using a free design file, it does not cover all the surfaces we
    want to create. I am very happy we have this free resource at our fingertips,
    and we’ll try to use the general styles and components to figure out what the
    remaining two of our surfaces should look like.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是免费的设计文件，它并没有涵盖我们想要创建的所有表面。我很高兴我们手头有这个免费资源，我们将尝试使用通用样式和组件来确定剩余的两个表面应该是什么样子。
- en: 'The **Login** surface should surely consist of two inputs: the username and
    password. We will re-use the input visible on the **Messaging** screen in Figma,
    and the background of the splash screen. As for the surface needed for adding
    posts, we’ll have a rounded square for the image –to match the **Home** surface
    – and an input for the title of the post.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录**表面当然应该包括两个输入：用户名和密码。我们将重用Figma上**消息**屏幕上的可见输入和启动屏幕的背景。至于添加帖子的表面所需的表面，我们将有一个与**主页**表面匹配的圆形方形图像，以及帖子标题的输入。'
- en: 'Let’s summarize our plan: we have all our surfaces created. We will proceed
    to create the components necessary for the surfaces. We will create an avatar
    component, that we will use on the **Home**, **Conversations**, and **Messaging**
    surfaces. We will create a card component for the **Home** surface. We will then
    create another card component for the **Conversations** surface, along with a
    search box component. We will need to hook up the navigation to move correctly
    from **Conversations** to **Messaging**. On the **Messaging** surface, we will
    reuse the avatar component, a component for displaying messages, and a reusable
    input component. Moving on to the **Profile** screen, we will create a profile
    avatar component, components for profile statistics and components for cards of
    images, and different components for cards of favorited items. We will then move
    on to composing the **Login** screen using input box components created previously
    for the messaging screen. We will finish by completing the **Add Post** surface,
    using a version of the **Home** surface card and input. I don’t recommend creating
    all the files beforehand, as a lot of things may change while we create the actual
    components.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们的计划：我们已经创建了所有表面。接下来，我们将创建为表面所需的组件。我们将创建一个头像组件，用于**主页**、**对话**和**消息**表面。我们将为**主页**表面创建一个卡片组件。然后，我们将为**对话**表面创建另一个卡片组件，以及一个搜索框组件。我们需要将导航连接起来，以便正确地从**对话**切换到**消息**。在**消息**表面上，我们将重用头像组件、用于显示消息的组件以及一个可重用的输入组件。接下来，我们将转到**个人资料**屏幕，创建个人资料头像组件、个人资料统计数据组件以及图像卡片组件和收藏物品卡片组件的不同组件。然后，我们将使用之前为消息屏幕创建的输入框组件来组合**登录**屏幕。最后，我们将完成**添加帖子**表面，使用**主页**表面卡片和输入的版本。我不建议事先创建所有文件，因为在创建实际组件的过程中，很多东西可能会发生变化。
- en: Before we start writing components let’s try to analyze what data will be needed
    for our app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写组件之前，让我们尝试分析我们的应用需要哪些数据。
- en: Planning data flows in the app
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用中规划数据流
- en: This is a part of app development that usually does not fall under the responsibilities
    of the frontend developer. The clients will often determine what data they want,
    and that data is organized by the backend developers. However, if you can participate
    in the way the data flows are organized, you will make your future work easier.
    Given that we are only building the frontend of an app using example data, we
    are free to organize it however we like.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是前端开发者职责之外的应用开发部分。客户通常会确定他们想要的数据，这些数据由后端开发者组织。然而，如果您能参与数据流组织的规划，您将使您未来的工作更加容易。鉴于我们只使用示例数据构建应用的前端，我们可以自由地组织它。
- en: 'We will use the design file again, as the basis for what work needs to be done.
    Starting with the **Home** screen, we know we need a list of users and a list
    of items to be displayed on the **Home** surface. As per the **Conversations**
    surface, we will need a list of conversations with respective usernames and messages.
    We will also need data for each one of the conversations, so we can display it
    on the **Messaging** surface. On the **Profile** surface, we will need a list
    of data pertinent to the user (name, avatar image, statistics), and two lists
    of images: added images and liked images. As per the surfaces missing from the
    design, we will need a login and password for the **Login** screen. We will not
    need any sample data for the **Add** **Post** surface.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用设计文件，作为确定需要完成的工作的基础。从**主页**屏幕开始，我们知道我们需要一个用户列表和一个要在**主页**表面上显示的项目列表。至于**对话**表面，我们需要一个包含相应用户名和消息的对话列表。我们还需要每个对话的数据，以便我们可以在**消息**表面上显示它。在**个人资料**表面上，我们需要与用户相关的数据列表（姓名、头像图像、统计数据），以及两个图像列表：添加的图像和喜欢的图像。至于设计中缺失的表面，我们需要**登录**屏幕的登录名和密码。对于**添加帖子**表面，我们不需要任何示例数据。
- en: 'Working with real data makes it easier to visualize the future shape of the
    app and of specific components. That is why I set up GitHub pages of the book
    repository to hold our sample data. You can find them on GitHub Pages (https://packtpublishing.github.io/Simplifying-State-Management-in-React-Native/)
    or in the main book repository in the `docs/` folder: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用真实数据工作可以更容易地可视化应用和特定组件的未来形态。这就是为什么我设置了书籍仓库的GitHub页面来保存我们的示例数据。您可以在GitHub Pages（https://packtpublishing.github.io/Simplifying-State-Management-in-React-Native/）或主书库的`docs/`文件夹中找到它们：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/docs)。
- en: Browsing through sample data
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览示例数据
- en: 'You can see the example data used in the app whenever you’d like. Check out
    the data branch of the main repository here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/data/docs/index.md](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/data/docs/index.md)
    and look in the `docs/` folder. You can copy anything you’d like to your own projects.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何时候查看应用中使用的示例数据。请查看主仓库的数据分支：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/data/docs/index.md](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/data/docs/index.md)，并在`docs/`文件夹中查找。您可以复制任何您想要的内容到您自己的项目中。
- en: 'The biggest and most obvious piece of the data puzzle we will need is a list
    of users. You can view the file on GitHub here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/main/docs/users.json](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/main/docs/users.json).
    Our app will consume the raw JSON file, which can be accessed through the following
    link: [https://raw.githubusercontent.com/PacktPublishing/Simplifying-State-Management-in-React-Native/main/docs/users.json](https://raw.githubusercontent.com/PacktPublishing/Simplifying-State-Management-in-React-Native/main/docs/users.json).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的数据拼图中最大、最明显的一部分是用户列表。您可以在GitHub上查看该文件：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/main/docs/users.json](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/blob/main/docs/users.json)。我们的应用将消费原始JSON文件，可以通过以下链接访问：[https://raw.githubusercontent.com/PacktPublishing/Simplifying-State-Management-in-React-Native/main/docs/users.json](https://raw.githubusercontent.com/PacktPublishing/Simplifying-State-Management-in-React-Native/main/docs/users.json)。
- en: You may wonder why I added user IDs if we’re building a simple app with example
    data. The reason is that we will use the user data for a list of avatars on the
    `key` prop. Theoretically, we could use the image URL as our unique key and then
    try to remember not to use the same picture for more than one person. However,
    using an ID is a much cleaner solution. It is also closer to what you would see
    in a real-world app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，如果我们正在构建一个使用示例数据的简单应用，为什么还要添加用户ID。原因是我们将使用用户数据作为`key`属性上的头像列表。从理论上讲，我们可以使用图片URL作为我们的唯一键，然后尝试记住不要为多个人使用相同的图片。然而，使用ID是一个更干净、更接近真实世界应用的做法。
- en: 'Now that we have a user list, let’s take a look at what a specific user profile
    might look like. Our user will need an ID, which should match the record with
    their name in the `users.json` file. They also have a name and avatar image URL.
    We need to know how many posts, followers, and users following the given user
    has. Finally, we need two lists of images: added and liked images. Take a look
    at the `john_doe.json` file – that’s what our example user profile data looks
    like.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用户列表，让我们看看一个特定用户配置文件可能是什么样子。我们的用户需要一个ID，这个ID应该与`users.json`文件中他们名字的记录相匹配。他们还有一个名字和头像图片URL。我们需要知道给定用户有多少帖子、关注者和被关注者。最后，我们需要两个图片列表：添加的和喜欢的图片。看看`john_doe.json`文件——这就是我们的示例用户配置数据的样子。
- en: Moving on to the `users.json` file here to display the list of avatars, so we
    don’t need to add any additional avatar list data here. It will be followed by
    a list of items to be displayed in the form of cards with images. The example
    data is available in the `home.json` file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转到`users.json`文件，以显示头像列表，因此我们在这里不需要添加任何额外的头像列表数据。接下来将是一个以卡片形式显示的物品列表，其中包含图片。示例数据可以在`home.json`文件中找到。
- en: Let’s create our sample dataset for the conversations. It’s not very complicated;
    it includes a username, a user avatar URL, a message, and an ID. We will need
    the conversation ID to correctly display conversation details on the **Messaging**
    surface.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为对话创建一个示例数据集。它并不复杂；它包括用户名、用户头像URL、消息和ID。我们需要对话ID来正确地在**消息**界面显示对话详情。
- en: Finally, we should create sample data for the `messages`. Inside that folder,
    we will create a few files for conversations. Every file is named by the conversation
    ID, which should make data fetching easier and more readable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该为`messages`创建示例数据。在这个文件夹中，我们将为对话创建几个文件。每个文件都按对话ID命名，这将使数据检索更容易、更易读。
- en: As for the **Login** screen, we will use a very small JSON file, which will
    hold a username and password. We will use this data to create user flows when
    the **Login** form is filled out correctly or incorrectly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 至于**登录**界面，我们将使用一个非常小的JSON文件，其中将包含用户名和密码。当**登录**表单正确或错误地填写时，我们将使用这些数据来创建用户流程。
- en: Looking at the JSON files, you will notice some data is repeated in a few files;
    namely, the user ID, user’s name, and avatar image URL. In a real-world app, this
    could cause issues in the future, where data updated in place of the app will
    not be properly updated or available somewhere else. That is why we will remove
    all references to user names and avatar images and leave only the user ID, which
    we will use to get the other data from the `users.json` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看JSON文件，你会注意到一些数据在几个文件中重复；具体来说，是用户ID、用户名和头像图像URL。在现实世界的应用程序中，这可能会在未来引起问题，即更新应用程序中的数据将不会正确更新或在其他地方可用。这就是为什么我们将删除对用户名和头像图像的所有引用，只留下用户ID，我们将使用它从`users.json`文件中获取其他数据。
- en: And there we have it! A big list of users that we will use in different parts
    of the app, data for the **Home** surface, the **Profile** surface, and **Conversations**.
    We’re ready to create our components! Right? Right! However, we need to get comfortable
    previewing and debugging our app first.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们有一个大型的用户列表，我们将在应用程序的不同部分使用，包括**主页**界面的数据、**个人资料**界面和**对话**。我们准备好创建我们的组件了！对吧？对！然而，我们首先需要熟悉预览和调试我们的应用程序。
- en: Getting comfortable previewing and debugging the app
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉预览和调试应用程序
- en: 'Have you been looking to see whether your code runs correctly on a device or
    a simulator? If not, let’s see how you can see it. The first thing you need to
    do is run this command in your terminal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在查看你的代码是否在设备或模拟器上正确运行？如果不是，让我们看看你如何查看它。你需要做的第一件事是在你的终端中运行这个命令：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When `expo` is done setting up your development server, you can hit “*i*” for
    an iPhone simulator (if you’re working on a Mac computer), “*a*” for an android
    simulator (if you have Android Studio installed), or you can take your phone and
    use the Expo Go app.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当`expo`完成设置你的开发服务器后，你可以按“*i*”为iPhone模拟器（如果你在Mac电脑上工作），按“*a*”为Android模拟器（如果你已安装Android
    Studio），或者你可以拿起你的手机并使用Expo Go应用程序。
- en: 'Whichever one you choose, you will see a browser window open automatically
    on your device. This browser window looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个，你都会在你的设备上自动打开一个浏览器窗口。这个浏览器窗口看起来是这样的：
- en: '![Figure 3.3 – Expo developer tools in the browser ](img/Figure_3.03_B18396.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 浏览器中的Expo开发者工具](img/Figure_3.03_B18396.jpg)'
- en: Figure 3.3 – Expo developer tools in the browser
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 浏览器中的Expo开发者工具
- en: If you want to see your app on your phone, you’ll find the QR code to scan in
    the Expo Go app right here. You will see error messages here; you can even use
    this page to publish your app.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在手机上查看你的应用程序，你将在这里找到Expo Go应用程序中的扫描二维码。你将在这里看到错误消息；你甚至可以使用这个页面来发布你的应用程序。
- en: 'I like working with an iPhone simulator open. Here’s what our app looks like
    set up on my computer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在iPhone模拟器打开的情况下工作。这是我电脑上设置的应用程序的外观：
- en: '![Figure 3.4 – iPhone 13 with iOS 15.2 simulator screenshot ](img/Figure_3.04_B18396.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – iPhone 13与iOS 15.2模拟器截图](img/Figure_3.04_B18396.jpg)'
- en: Figure 3.4 – iPhone 13 with iOS 15.2 simulator screenshot
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – iPhone 13与iOS 15.2模拟器截图
- en: 'Hopefully, you see something similar. If you don’t, you can always clone the
    GitHub repository, or compare your code to the one that’s published. The state
    of the app you see in the preceding screenshot is what should be seen on the `main`
    branch of the repo located here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到类似的东西。如果你没有，你总是可以克隆GitHub仓库，或者比较你的代码与已发布的代码。你前面截图中所看到的app状态应该是位于此处仓库的`main`分支上应看到的状态：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native)。
- en: Take some time to play around with the app. Try creating some obvious errors,
    such as writing plain text outside of the `<Text />` component, maybe using a
    `<div>` tag, or not closing a tag.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间在应用上玩玩。尝试创建一些明显的错误，比如在`<Text />`组件外写入纯文本，可能使用`<div>`标签，或者没有关闭标签。
- en: We will practice code changes on our bottom tab navigation. We will not be creating
    any components for that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在底部标签导航上进行代码更改练习。我们不会为那个创建任何组件。
- en: Customizing the appearance of the tab navigator can be achieved by setting properties
    when the navigator is set up. We can also add some specific per-screen options.
    Our bottom tab navigator will use icons for tabs, so we will need to start by
    importing an icon library into the main `App.js` file. We will use a library called
    `@expo/vector-icons`. This library is installed by default on all projects initialized
    with `expo`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在设置导航器时设置属性，可以自定义标签导航的外观。我们还可以添加一些特定的屏幕选项。我们的底部标签导航将使用图标作为标签，因此我们需要首先将图标库导入到主`App.js`文件中。我们将使用名为`@expo/vector-icons`的库。这个库默认安装在所有使用`expo`初始化的项目中。
- en: Adding libraries
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 添加库
- en: Before adding any additional dependencies and libraries, make sure to check
    the Expo documentation to see whether the library you want is not installed already.
    If you do need to add something, make sure to add libraries compatible with the
    Expo workflow.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何额外的依赖和库之前，请确保检查Expo文档，看看你想要的库是否已经安装。如果你确实需要添加某些内容，请确保添加与Expo工作流程兼容的库。
- en: 'Expo has done all the heavy lifting for us; we have a big icon library at our
    fingertips. All we need to do is use it to add icons to our navigator. We will
    start by adding simple icons to four of the five items:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Expo已经为我们做了所有繁重的工作；我们手头有一个庞大的图标库。我们所需做的就是使用它来为我们的导航器添加图标。我们将从为五个项目中的四个添加简单图标开始：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We added a simple `if` statement to `<Tab.Navigator>`, where we give it specific
    instructions on what component should be displayed. Every time we’re displaying
    a `<Ionicons>` component from the `@expo/vector-icons` library, however, we’re
    feeding it different props. We’ll leave the `AddPost` item for now. Once we create
    a reusable button component, we’ll come back here and add it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`<Tab.Navigator>`中添加了一个简单的`if`语句，其中我们给出了关于应该显示哪个组件的特定指令。然而，每次我们显示来自`@expo/vector-icons`库的`<Ionicons>`组件时，我们都在给它提供不同的属性。现在我们将保留`AddPost`项。一旦我们创建了一个可重用的按钮组件，我们就会回到这里并添加它。
- en: 'What we can customize further now is the `tabBa`r label. As per the design,
    the label should not be displayed. We need to add another property to `<Tab.Navigator>`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进一步自定义的是`tabBar`标签。根据设计，标签不应显示。我们需要向`<Tab.Navigator>`添加另一个属性：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Looking good! Now, how about the header? Our app has a very generic header
    with a white background and the title of the given surface. As you can see on
    the design, some surfaces don’t have titles (such as `<Tab.Navigator>`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！现在，关于头部呢？我们的应用有一个非常通用的头部，背景为白色，标题为给定表面的标题。正如你在设计中所看到的，一些表面没有标题（例如`<Tab.Navigator>`）：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yay! That worked – but wait, the text that was displayed on the screen is now
    behind a fixed, transparent header!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！这成功了——但是等等，屏幕上显示的文本现在在固定的透明头部后面！
- en: '![Figure 3.5 – iPhone simulator showing UI issues ](img/Figure_3.05_B18396.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – iPhone模拟器显示UI问题](img/Figure_3.05_B18396.jpg)'
- en: Figure 3.5 – iPhone simulator showing UI issues
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – iPhone模拟器显示UI问题
- en: 'We need to make sure the contents of our app won’t ever fly off the screen
    like this. It’s not an easy task to achieve, especially with so many screen shapes,
    notches, and digital buttons. Luckily for us, the creators of React Navigation
    added a wrapper component called `<SafeAreaView>`. We have to add the `SafeAreaProvider`
    component around `<NavigationContainer>`. This component uses React Context “under
    the hood.” In order to use this context, we need to add `<SafeAreaView>` around
    each one of our surfaces. The main app component will look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保我们应用的内容永远不会像这样飞离屏幕。这是一个不容易完成的任务，尤其是在有这么多屏幕形状、凹口和数字按钮的情况下。幸运的是，React Navigation
    的制作者添加了一个名为 `<SafeAreaView>` 的包装组件。我们必须在 `<NavigationContainer>` 周围添加 `SafeAreaProvider`
    组件。该组件在“幕后”使用 React Context。为了使用此上下文，我们需要在每个表面周围添加 `<SafeAreaView>`。主应用组件将看起来是这样的：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s add `<SafeAreaView>` around the `<Feed>` component. Do you see any improvement
    over what we saw before? No? That’s because there’s one more gotcha: we need to
    add the `{{flex: 1}}` style to the wrapper component. Okay, the surface looks
    better – the text is contained on the screen – but it’s still behind the header…'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们在 `<Feed>` 组件周围添加 `<SafeAreaView>`。您看到有任何改进吗？没有？那是因为还有一个需要注意的地方：我们需要在包装组件中添加
    `{{flex: 1}}` 样式。好吧，表面看起来更好了——文本被包含在屏幕上——但它仍然在标题后面…'
- en: '![Figure 3.6 – Close-up of the iPhone simulator with changes to the UI ](img/Figure_3.06_B18396.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – iPhone 模拟器 UI 变更的特写](img/Figure_3.06_B18396.jpg)'
- en: Figure 3.6 – Close-up of the iPhone simulator with changes to the UI
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – iPhone 模拟器 UI 变更的特写
- en: 'We want to add padding to the top of the surface so that our content will begin
    below the header. We want to determine the height of the header without having
    to hardcode any pixel values. `useHeaderHeight()`. The `Feed` component looks
    like this now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望给表面的顶部添加填充，这样我们的内容就会在标题下方开始。我们希望确定标题的高度，而无需硬编码任何像素值。使用 `useHeaderHeight()`。现在的
    `Feed` 组件看起来是这样的：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the app should look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用应该看起来像这样：
- en: '![Figure 3.7 – iPhone simulator with fixed UI ](img/Figure_3.07_B18396.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 固定 UI 的 iPhone 模拟器](img/Figure_3.07_B18396.jpg)'
- en: Figure 3.7 – iPhone simulator with fixed UI
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 固定 UI 的 iPhone 模拟器
- en: 'Make sure to add `<SafeAreaView>` to all surfaces if you’re following along
    with this book. If you prefer to see the code changes on GitHub, you will find
    them on the branch called `chapter-3`: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在跟随本书学习时，将 `<SafeAreaView>` 添加到所有表面。如果您更喜欢在 GitHub 上查看代码更改，您可以在名为 `chapter-3`
    的分支上找到它们：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-3).
- en: 'If you’re wondering why we’re adding header styles to the `<Tab.Navigator>`
    and not the root component, I invite you to take a look at the `<Stack.Navigator>`
    we have set up at the root of our app, in preparation for a `<Stack.Screen>` component,
    you will notice the following option:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么我们要在 `<Tab.Navigator>` 中添加标题样式而不是根组件，我邀请您查看我们应用根部的 `<Stack.Navigator>`，为
    `<Stack.Screen>` 组件做准备，您会注意到以下选项：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are telling React Navigation to hide the header of `<Stack.Navigator>` and
    display the header of the nested `<Tab.Navigator>`. This nested `<Tab.Navigator>`
    is also the one we need to style. Go ahead and change the `headerShown` option
    in your project and observe what happens. You should see another header show up
    in the app with the `Home` title! That’s because we’ve named `Home` the main parent
    component, used for creating `<Tab.Navigator>`. Make sure to change the `headerShown`
    option back to `false`, before getting back to work on our app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在告诉 React Navigation 隐藏 `<Stack.Navigator>` 的标题并显示嵌套的 `<Tab.Navigator>` 的标题。这个嵌套的
    `<Tab.Navigator>` 也是我们需要样式的。继续更改您项目中的 `headerShown` 选项并观察会发生什么。您应该在应用中看到另一个带有“主页”标题的标题！那是因为我们将
    `Home` 命名为主要父组件，用于创建 `<Tab.Navigator>`。确保在回到我们的应用工作之前，将 `headerShown` 选项改回 `false`。
- en: 'I hope you’re getting comfortable with making changes and previewing them in
    your app. Let’s finish this section by adding a custom font. We’ll use a library
    provided by Expo again: Expo Google Fonts. If you take a quick look at the design
    file, you’ll find the name of the font used, it’s a Google font called Poppins.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在应用中修改和预览更改方面感到越来越舒适。让我们通过添加自定义字体来完成本节。我们再次使用Expo提供的库：Expo Google Fonts。如果你快速查看设计文件，你会找到所使用的字体名称，它是一个名为Poppins的Google字体。
- en: We’ll go ahead and import the font into the `Feed` component, add it as a `style`
    prop to the `<Text>` component, and… oh no! Problem!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把字体导入到`Feed`组件中，将其作为`style`属性添加到`<Text>`组件中，然后……哦不！问题！
- en: '![Figure 3.8 – iPhone simulator displaying an error ](img/Figure_3.08_B18396.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – iPhone模拟器显示错误](img/Figure_3.08_B18396.jpg)'
- en: Figure 3.8 – iPhone simulator displaying an error
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – iPhone模拟器显示错误
- en: 'Even though this huge red box seems to be screaming at us, there’s no need
    to worry. All we need to do is read the error. It states that `@expo-google-fonts/poppins`
    is not defined. Of course! We need to install this font in our project. Let’s
    run the following commands in the terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个巨大的红色框似乎在向我们尖叫，但无需担心。我们只需要阅读错误信息。它指出`@expo-google-fonts/poppins`未定义。当然！我们需要在我们的项目中安装这个字体。让我们在终端中运行以下命令：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The error should be gone. Now, we can safely add our font family to the `<Text>`
    component. Or can we?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 错误应该已经消失了。现在，我们可以安全地将我们的字体家族添加到`<Text>`组件中。或者我们可以吗？
- en: '![Figure 3.9 – iPhone simulators displaying an error toast message and details
    ](img/Figure_3.09_B18396.jpg)![Figure 3.9 – iPhone simulators displaying an error
    toast message and details ](img/Figure_3.10_B18396.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – iPhone模拟器显示错误提示消息和详细信息](img/Figure_3.09_B18396.jpg)![图3.9 – iPhone模拟器显示错误提示消息和详细信息](img/Figure_3.10_B18396.jpg)'
- en: Figure 3.9 – iPhone simulators displaying an error toast message and details
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – iPhone模拟器显示错误提示消息和详细信息
- en: The font has not been loaded… Let’s go back to the Expo documentation and make
    sure we loaded everything correctly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字体尚未加载……让我们回到Expo文档中，确保我们正确地加载了所有内容。
- en: 'According to the documentation, we first need to use the `useFont` hook with
    an `AppLoading` wrapper around the root component! Here’s what we need to add
    to the `App.js` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档说明，我们首先需要在根组件周围使用带有`AppLoading`包装器的`useFont`钩子！以下是我们需要添加到`App.js`文件中的内容：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And there we have it. Now, the app works correctly, and we can add the `fontFamily`
    style wherever we’d like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们就完成了。现在，应用可以正确运行，我们可以在任何我们想要的地方添加`fontFamily`样式：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we got comfortable changing code, previewing our app, and handling
    errors. Now, we’re ready to write and style components in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们熟悉了修改代码、预览我们的应用和处理错误。现在，我们准备好在下一章中编写和样式化组件。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we planned our app and got comfortable previewing and debugging
    it. Both of these steps are vital to creating a good developer experience. First
    of all, we do not want to face any major surprises – that’s why we want to plan
    ahead. You could compare this to how a building is built. No self-respecting construction
    worker would start setting up walls and doors before making, or at least looking
    at, a blueprint. We, as software developers, are building a digital product and
    not a building, but we’re using the word “to build” for very good reasons.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们规划了我们的应用并熟悉了预览和调试它。这两个步骤对于创建良好的开发者体验至关重要。首先，我们不希望遇到任何重大惊喜——这就是为什么我们要提前规划。你可以将这比作建筑物的建造过程。没有自尊的施工工人会在制作或至少查看蓝图之前开始搭建墙壁和门。我们作为软件开发者，正在构建一个数字产品而不是建筑物，但我们使用“构建”这个词是非常有原因的。
- en: Second of all, we need to know how to check whether what we’re writing is actually
    working. Your code may look logical to you, but that does not mean that it will
    work after JavaScript tries to understand your logic. That is why every web developer
    has a browser window open while working, and why a mobile app developer needs
    to look at a phone or a phone simulator. Since we will be spending quite a lot
    of time looking at our apps on phones, it’s good to get comfortable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要了解如何检查我们所写的代码是否真的在起作用。你的代码可能在你看来逻辑清晰，但这并不意味着在JavaScript尝试理解你的逻辑后它仍然会工作。这就是为什么每个网页开发者都会在工作的同时打开浏览器窗口，以及为什么移动应用开发者需要查看手机或手机模拟器。由于我们将花费相当多的时间在手机上查看我们的应用，所以让自己感到舒适是很重要的。
- en: Now, dear reader, we are ready to continue our journey into the weeds of React
    Native! In the next chapter, we will build the components we planned above. We
    will also add styles to match our beautiful design. We will encounter a few classical
    problems of React Native and a few quirks – and we will have a nice-looking app
    at the end!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，亲爱的读者，我们准备好继续深入React Native的细节之旅了！在下一章中，我们将构建我们上面计划中的组件。我们还将添加样式以匹配我们的美丽设计。我们将遇到一些React
    Native的经典问题以及一些怪癖——最终我们将拥有一个看起来很棒的App！
- en: Further reading
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://docs.expo.dev/guides/icons/](https://docs.expo.dev/guides/icons/)
    – Expo icons guide.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.expo.dev/guides/icons/](https://docs.expo.dev/guides/icons/)
    – Expo 图标指南.'
- en: '[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
    – React context.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
    – React 上下文。'
- en: '[https://github.com/expo/google-fonts](https://github.com/expo/google-fonts)
    – Expo Google Fonts.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expo/google-fonts](https://github.com/expo/google-fonts)
    – Expo Google Fonts.'
