- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Reactive Patterns in Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的响应式模式
- en: Handling asynchronous information is a common task in our everyday lives as
    developers. **Reactive programming** is a paradigm that helps us consume, digest,
    and transform asynchronous information using data streams. **RxJS** is a JavaScript
    library that provides methods to manipulate data streams using **observables**
    .
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步信息是开发者日常生活中的常见任务。**响应式编程**是一种范式，它帮助我们通过数据流来消费、消化和转换异步信息。**RxJS**是一个 JavaScript
    库，它提供了使用**可观察对象**来操作数据流的方法。
- en: Angular provides an unparalleled toolset to help us when working with asynchronous
    data. Observable streams are at the forefront of this toolset, giving developers
    a rich set of capabilities when creating Angular applications. The core of the
    Angular framework is lightly dependent on RxJS. Other Angular packages, such as
    the router and the HTTP client, are more tightly coupled with observables. However,
    at the time of writing, the Angular team is currently investigating making the
    preceding packages less dependent on observables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一套无与伦比的工具集，帮助我们处理异步数据。可观察流是这套工具集的前沿，为开发者创建 Angular 应用提供了丰富的功能。Angular
    框架的核心对 RxJS 的依赖性较小。其他 Angular 包，如路由器和 HTTP 客户端，与可观察对象的耦合性更紧密。然而，在撰写本文时，Angular
    团队目前正在调查如何使上述包减少对可观察对象的依赖。
- en: 'In this chapter, we will learn about the following concepts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下概念：
- en: Strategies for handling asynchronous information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步信息的策略
- en: Reactive programming in Angular
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的响应式编程
- en: The RxJS library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS 库
- en: Subscribing to observables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅可观察对象
- en: Unsubscribing from observables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从可观察对象中退订
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through observables and
    RxJS. You can find the related source code in the `ch06` folder of the following
    GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，引导您了解可观察对象和 RxJS。您可以在以下 GitHub 仓库的 `ch06` 文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
- en: Strategies for handling asynchronous information
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步信息的策略
- en: We manage data asynchronously in different forms, such as consuming data from
    a backend API, a typical operation in our daily development workflow, or reading
    contents from the local file system. We always consume data over HTTP, such as
    when authenticating users by sending credentials to an authentication service.
    We also use HTTP when fetching the latest posts in our favorite social network
    application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以不同的形式异步管理数据，例如从后端 API 消费数据，这是我们日常开发工作流程中的典型操作，或者从本地文件系统中读取内容。我们总是通过 HTTP
    消费数据，例如通过向认证服务发送凭证来验证用户。我们还在获取我们最喜欢的社交网络应用中的最新帖子时使用 HTTP。
- en: Modern mobile devices have introduced a unique way of consuming remote services.
    They defer requests and response consumption until mobile connectivity is available.
    Responsivity and availability have become a big deal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现代移动设备引入了一种独特的消费远程服务的方式。它们将请求和响应消费推迟到移动连接可用时。响应性和可用性已经成为一大问题。
- en: Although internet connections are high-speed nowadays, response time is always
    involved when serving such information. Thus, as we will see in this section,
    we put in place mechanisms to handle the state of our applications transparently
    for the end user.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在的互联网连接速度很快，但在提供此类信息时，响应时间总是存在的。因此，正如我们将在本节中看到的，我们为最终用户透明地处理应用程序的状态设置了机制。
- en: Shifting from callback hell to promises
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从回调地狱转向承诺
- en: Sometimes we might need to build functionalities in our application that change
    its state asynchronously once time has elapsed. In these cases we must introduce
    code patterns, such as the **callback pattern** , to handle this deferred change
    in the application state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要在应用程序中构建一些功能，这些功能在时间经过后异步地改变其状态。在这些情况下，我们必须引入代码模式，例如**回调模式**，来处理应用程序状态的这种延迟变化。
- en: In a callback, the function that triggers asynchronous action accepts another
    function as a parameter. The function is executed when the asynchronous operation
    has been completed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调中，触发异步操作的功能接受另一个函数作为参数。当异步操作完成后，该函数将被执行。
- en: 'You will need the source code of the Angular application we created in *Chapter
    5* , *Managing Complex Tasks with Services* , to follow along with the rest of
    the chapter. After you get the code, we suggest you take the following actions
    for simplicity:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要我们在*第5章*，*使用服务管理复杂任务*中创建的Angular应用程序的源代码，才能跟随本章的其余部分。在您获取代码后，我们建议您为简单起见采取以下行动：
- en: Remove the `favorites` folder
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`favorites`文件夹
- en: Remove the `favorites.service.ts` and its unit test file
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`favorites.service.ts`及其单元测试文件
- en: Remove the `favorite.ts` file
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`favorite.ts`文件
- en: Remove the `numeric.directive.ts` file and its unit test file
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`numeric.directive.ts`文件及其单元测试文件
- en: Remove the `product-view` folder
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`product-view`文件夹
- en: 'Let’s see how to use a callback through an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看如何使用回调：
- en: 'Open the `app.component.html` file and add a `<header>` HTML element to display
    the `title` component property using interpolation:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.html`文件，并添加一个`<header>`HTML元素来显示`title`组件属性，使用插值表达式：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `app.component.ts` file and create the following property:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`文件并创建以下属性：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `setTitle` property is used to change the `title` component property based
    on the `title` property from application settings. It returns an arrow function
    because we will use it as a callback to another method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTitle`属性用于根据应用程序设置中的`title`属性更改`title`组件属性。它返回一个箭头函数，因为我们将其用作另一个方法的回调。'
- en: 'Next, create a `changeTitle` method that calls another method, named, by convention,
    `callback` , after two seconds:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`changeTitle`的方法，该方法在两秒后调用另一个方法，按照惯例命名为`callback`：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a `constructor` to call the `changeTitle` method, passing the `setTitle`
    property as a parameter:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`constructor`来调用`changeTitle`方法，并将`setTitle`属性作为参数传递：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet, we use the `setTitle` property without parentheses
    because we pass function signatures and not actual function calls when we use
    callbacks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`setTitle`属性而没有括号，因为我们使用回调时传递的是函数签名，而不是实际的函数调用。
- en: If we run the Angular application using the `ng serve` command, we see that
    the `title` property changes after two seconds. The problem with the pattern we
    just described is that the code can become confusing and cumbersome as we introduce
    more nested callbacks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`ng serve`命令运行Angular应用程序，我们会看到`title`属性在两秒后改变。我们刚才描述的模式的问题在于，随着我们引入更多的嵌套回调，代码可能会变得混乱和繁琐。
- en: 'Consider the following scenario where we need to drill down into a folder hierarchy
    to access photos on a device:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景，我们需要钻入文件夹层次结构以访问设备上的照片：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We depend on the previous asynchronous call and the data it brings back before
    we can do the next call. We must execute a method inside a callback that executes
    another method with a callback. The code quickly looks complex and difficult to
    read, leading to a situation known as **callback hell** .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够进行下一个调用之前，我们必须依赖于之前的异步调用及其返回的数据。我们必须在执行另一个带有回调的方法的方法内部执行一个方法。代码很快就会变得复杂且难以阅读，导致一种称为**回调地狱**的情况。
- en: We can avoid callback hell using **promises** . Promises introduce a new way
    of envisioning asynchronous data management by conforming to a neater and more
    solid interface. Different asynchronous operations can be chained at the same
    level and even be split and returned from other functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**promises**来避免回调地狱。Promises通过遵循更整洁、更稳定的接口，引入了一种新的异步数据管理方式。不同的异步操作可以在同一级别上串联，甚至可以从其他函数中拆分并返回。
- en: 'To better understand how promises work, let’s refactor our previous callback
    example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解promises的工作原理，让我们重构先前的回调示例：
- en: 'Create a new method in the `AppComponent` class named `onComplete` that returns
    a `Promise` object. A promise can either be **resolved** or **rejected** . The
    `resolve` parameter indicates that the promise was completed successfully and
    optionally returns a result:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`类中创建一个名为`onComplete`的新方法，该方法返回一个`Promise`对象。Promise可以是**已解决**或**拒绝**的。`resolve`参数表示promise已成功完成，并可选择返回一个结果：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Introduce a timeout of two seconds in the promise so that it resolves after
    this time has elapsed:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在promise中引入两秒的超时，以便在这段时间过后解决：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, replace the `changeTitle` call in the `constructor` with the promise-based
    method. To execute a method that returns a promise, we invoke the method and chain
    it with the `then` method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`constructor`中的`changeTitle`调用替换为基于promise的方法。要执行返回promise的方法，我们调用该方法，并用`then`方法链式调用：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should not notice any significant difference if we rerun the Angular application.
    The real value of promises lies in the simplicity and readability afforded to
    our code. We could now refactor the previous folder hierarchy example accordingly:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行Angular应用程序，我们不应该注意到任何显著的差异。承诺的真实价值在于它为我们代码带来的简洁性和可读性。我们现在可以相应地重构先前的文件夹层次结构示例：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The chaining of the `then` method in the preceding code shows how we can line
    up one asynchronous call after another. Each previous asynchronous call passes
    its result in the upcoming asynchronous method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中`then`方法的链式调用展示了我们如何将一个异步调用紧接另一个异步调用。每个先前的异步调用都会将其结果传递给即将到来的异步方法。
- en: Promises are compelling, but sometimes we might need to produce a response output
    that follows a more complex digest process or even cancel the whole process. We
    cannot accomplish such behavior with promises because they are triggered as soon
    as they are instantiated. In other words, promises are not lazy. On the other
    hand, the possibility of tearing down an asynchronous operation after it has been
    fired but not completed yet can become quite handy in specific scenarios. Promises
    allow us to resolve or reject an asynchronous operation, but sometimes we might
    want to abort everything before getting to that point.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺很有吸引力，但有时我们可能需要生成一个响应输出，它遵循更复杂的消化过程，甚至取消整个过程。我们不能用承诺实现这种行为，因为它们在实例化时就会触发。换句话说，承诺不是懒加载的。另一方面，在异步操作已经触发但尚未完成的情况下，取消该操作的可能性在特定场景中可能非常有用。承诺允许我们解决或拒绝异步操作，但有时我们可能想在达到那个点之前取消一切。
- en: 'On top of that, promises behave as one-time operations. Once they are resolved,
    we cannot expect to receive any further information or state change notifications
    unless we run everything from scratch. To summarize the limitations of promises:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，承诺作为一次性操作。一旦它们被解决，除非我们从零开始运行一切，否则我们无法期望收到任何进一步的信息或状态变化通知。总结承诺的限制：
- en: They cannot be canceled
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能被取消
- en: They are immediately executed
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们立即执行
- en: They are one-time operations; there is no easy way to retry them
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是单次操作；没有简单的方法可以重试它们
- en: They respond with only one value
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只响应一个值
- en: 'Let’s illustrate some of the limitations with an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明一些限制：
- en: 'Replace `setTimeout` with `setInterval` in the `onComplete` method:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onComplete`方法中将`setTimeout`替换为`setInterval`：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The promise will now resolve repeatedly every two seconds.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺现在将每两秒解析一次。
- en: 'Modify the `setTitle` property to append the current `timestamp` in the `title`
    property of the component:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`setTitle`属性修改为在组件的`title`属性中附加当前的`timestamp`：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the Angular application and you will notice that the timestamp is set only
    once after two seconds and never changes again. The promise resolves itself, and
    the entire asynchronous event terminates at that very moment.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Angular应用程序，你会注意到时间戳在两秒后只设置了一次，之后再也没有改变。承诺自行解决，整个异步事件在那个时刻终止。
- en: We may need a more proactive implementation of asynchronous data handling to
    fix the preceding behavior, which is where observables come into the picture.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要一个更主动的异步数据处理实现来修复前面的行为，这就是可观察对象出现的地方。
- en: Observables in a nutshell
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简而言之，可观察对象
- en: An observable is an object that maintains a list of dependents, called **observers**
    , and informs them about state and data changes by emitting events asynchronously.
    To do so, the observable implements all the necessary machinery to produce and
    emit such events. It can be triggered and canceled at any time, regardless of
    whether it has emitted the expected data already.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是一个对象，它维护一个依赖者列表，称为**观察者**，并通过异步方式发出事件来通知它们关于状态和数据的变化。为了做到这一点，可观察对象实现了所有必要的机制来产生和发出这些事件。它可以随时触发和取消，无论它是否已经发出了预期的数据。
- en: 'Observers must subscribe to an observable to be notified and react to reflect
    the state change. This pattern, known as the **observer pattern** , allows concurrent
    operations and more advanced logic. These observers, also known as **subscribers**
    , keep listening to whatever happens in the observable until it is destroyed.
    We can see all this with more transparency in an actual example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者必须订阅一个可观察对象以接收通知并响应状态变化。这种模式被称为**观察者模式**，它允许并发操作和更高级的逻辑。这些观察者，也称为**订阅者**，会持续监听可观察对象中发生的事情，直到它被销毁。我们可以在实际示例中更清晰地看到这一切：
- en: 'Import the `Observable` artifact from the `rxjs` npm package:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`rxjs` npm包中导入`Observable`对象：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a component property named `title$` that creates an `Observable` object.
    The constructor of an observable accepts an `observer` object as a parameter.
    The `observer` is an arrow function that contains the business logic that will
    be executed when someone uses the observable. Call the `next` method of the `observer`
    every two seconds to indicate a data or application state change:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `title$` 的组件属性，该属性创建一个 `Observable` 对象。可观察对象的构造函数接受一个 `observer` 对象作为参数。`observer`
    是一个箭头函数，包含当有人使用可观察对象时将执行的业务逻辑。每隔两秒调用 `observer` 的 `next` 方法以指示数据或应用程序状态的变化：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we define an observable variable, we tend to append the `$` sign to the
    variable name. It is a convention that we follow to identify observables in our
    code efficiently and quickly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个可观察变量时，我们倾向于在变量名后附加 `$` 符号。这是我们遵循的一种约定，以便在我们的代码中高效且快速地识别可观察对象。
- en: 'Modify the `constructor` component to use the newly created `title$` property:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `constructor` 组件以使用新创建的 `title$` 属性：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `subscribe` method to register to the `title$` observable and get
    notified of any changes. If we do not call this method, the `setTitle` method
    will never execute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `subscribe` 方法注册到 `title$` 可观察对象，并接收任何变化的通知。如果我们不调用此方法，`setTitle` 方法将永远不会执行。
- en: An observable will not do anything unless a subscriber subscribes to it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有订阅者订阅它，否则可观察对象不会做任何事情。
- en: If you run the application, you will notice that the timestamp changes every
    two seconds. Congratulations! You have entered the world of observables and reactive
    programming!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你会注意到时间戳每两秒变化一次。恭喜！你已经进入了可观察对象和反应式编程的世界！
- en: Observables return a stream of events, and our subscribers receive prompt notifications
    of those events so that they can act accordingly. They do not perform an asynchronous
    operation and terminate (although we can configure them to do so) but start a
    stream of ongoing events to which we can subscribe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象返回一个事件流，我们的订阅者会收到这些事件的即时通知，以便他们可以相应地采取行动。它们不执行异步操作并终止（尽管我们可以配置它们这样做），而是启动一个持续的流，我们可以订阅它。
- en: That’s not all, however. This stream can combine many operations before hitting
    observers subscribed to it. Just as we can manipulate arrays with methods such
    as `map` or `filter` to transform them, we can do the same with the stream of
    events emitted by observables. It is a pattern known as reactive programming,
    and Angular makes the most of this paradigm to handle asynchronous information.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不算完。这个流可以在到达订阅它的观察者之前组合许多操作。就像我们可以使用 `map` 或 `filter` 等方法来操作数组并对其进行转换一样，我们也可以对由可观察对象发出的事件流做同样的事情。这是一个被称为反应式编程的模式，Angular
    充分利用这种范式来处理异步信息。
- en: Reactive programming in Angular
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的反应式编程
- en: 'The observer pattern stands at the core of reactive programming. The most basic
    implementation of a reactive script encompasses several concepts that we need
    to become familiar with:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是反应式编程的核心。反应脚本最基本实现包括几个我们需要熟悉的概念：
- en: An observable
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象
- en: An observer
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: A timeline
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线
- en: A stream of events
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列事件
- en: A set of composable operators
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组可组合的操作符
- en: It may sound daunting, but it isn’t. The big challenge here is to change our
    mindset and learn how to think reactively, which is the primary goal of this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来令人畏惧，但实际上并非如此。这里的重大挑战是改变我们的思维方式，学习如何进行反应式思考，这是本节的主要目标。
- en: Reactive programming entails applying asynchronous subscriptions and transformations
    to observable streams of events.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程涉及对事件流的可观察对象应用异步订阅和转换。
- en: Let’s explain through a more descriptive example. Think about an interaction
    device such as a keyboard. It has keys that the user presses. Each one of those
    keystrokes triggers a specific keyboard event, such as `keyUp` . The keyUp event
    features a wide range of metadata, including—but not limited to—the numeric code
    of the specific key the user pressed at a given moment. As the user continues
    hitting keys, more keyUp events are triggered and piped through an imaginary timeline.
    The timeline is a continuous stream of data where the keyUp event can happen at
    any time; after all, the user decides when to press those keys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个更具描述性的例子来解释。想象一下一个交互设备，比如键盘。它有用户可以按下的键。每个按键都会触发一个特定的键盘事件，例如 `keyUp`。`keyUp`
    事件具有广泛的元数据，包括但不限于用户在特定时刻按下的特定键的数字代码。随着用户继续按键，将触发更多的 `keyUp` 事件，并通过一个想象的时间线传递。时间线是一个连续的数据流，其中
    `keyUp` 事件可以在任何时间发生；毕竟，用户决定何时按下这些键。
- en: 'Recall the example with observables from the previous section. That code could
    notify an observer that every two seconds, another value was emitted. We know
    how often a timer interval is triggered. In the case of keyUp events, we don’t
    know because they are not under our control. Let’s try to explain it further by
    implementing a key logger in our application:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节中关于可观察对象的例子。那段代码可以通知观察者每两秒发出另一个值。我们知道定时器间隔触发的频率。在 keyUp 事件的情况下，我们不知道，因为它们不受我们的控制。让我们通过在我们的应用程序中实现一个键记录器来进一步解释：
- en: 'Create a new Angular component named `key-logger` :'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `key-logger` 的新 Angular 组件：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open the `key-logger.component.html` file and replace its content with the
    following HTML template:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `key-logger.component.html` 文件，并用以下 HTML 模板替换其内容：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding template, we added an `<input>` HTML element and attached the
    `keyContainer` template reference variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们添加了一个 `<input>` HTML 元素，并附加了 `keyContainer` 模板引用变量。
- en: A template reference variable can be added to any HTML element, not just components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量可以添加到任何 HTML 元素中，而不仅仅是组件。
- en: We also display a `keys` property representing all the keyboard keys the user
    has pressed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还显示了一个 `keys` 属性，表示用户按下的所有键盘键。
- en: 'Open the `key-logger.component.ts` file and import the `OnInit` , `viewChild`
    , and `ElementRef` artifacts from the `@angular/core` npm package:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `key-logger.component.ts` 文件，并从 `@angular/core` npm 包导入 `OnInit`、`viewChild`
    和 `ElementRef` 工具：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the following properties in the `KeyLoggerComponent` class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `KeyLoggerComponent` 类中创建以下属性：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `input` property is used to query the `<input>` HTML element using the `keyContainer`
    template reference variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`input` 属性用于使用 `keyContainer` 模板引用变量查询 `<input>` HTML 元素。'
- en: 'Add the following `import` statement to import the `fromEvent` artifact from
    the `rxjs` npm package:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `import` 语句以从 `rxjs` npm 包导入 `fromEvent` 工具：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The RxJS library has various helpful artifacts, called **operators** , that
    we can use with observables. The `fromEvent` operator creates an observable from
    the DOM event of a native HTML element.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 库拥有各种有用的工具，称为 **操作符**，我们可以与可观察对象一起使用。`fromEvent` 操作符从一个原生 HTML 元素的 DOM
    事件创建一个可观察对象。
- en: 'Implement the `ngOnInit` method from the `OnInit` interface to listen for `keyup`
    events in the `<input>` element and save pressed keys in the `keys` property:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ngOnInit` 方法，从 `OnInit` 接口监听 `<input>` 元素中的 `keyup` 事件，并将按下的键保存在 `keys`
    属性中：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we get access to the native HTML input element through the `nativeElement`
    property of the template reference variable. The result of querying using the
    `viewChild` function is an `ElementRef` object, which is a wrapper over the actual
    HTML element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过模板引用变量的 `nativeElement` 属性访问原生 HTML 输入元素。使用 `viewChild` 函数查询的结果是一个 `ElementRef`
    对象，它是实际 HTML 元素的包装器。
- en: 'Open the `app.component.ts` file and import the `KeyLoggerComponent` class:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 文件，并从 `@angular/core` npm 包导入 `KeyLoggerComponent` 类：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open the `app.component.html` file and add the `<app-key-logger>` selector
    in the template:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.html` 文件，并在模板中添加 `<app-key-logger>` 选择器：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the application using the `ng serve` command and start pressing keys to
    verify the usage of the key logger that we have just created:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ng serve` 命令运行应用程序，并开始按键以验证我们刚刚创建的键记录器的使用情况：
- en: '![img](img/B21418_06_01.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B21418_06_01.png)'
- en: 'Figure 6.1: Key logger output'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：键记录器输出
- en: An essential aspect of observables is using operators and chaining observables
    together, enabling **rich composition** . Observable operators look like array
    methods when we want to use them. For example, a `map` operator for observables
    is used similarly to the `map` method of an array. In the following section, we
    will learn about the RxJS library, which provides these operators, and learn about
    some of them through examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象的一个基本方面是使用操作符并将可观察对象链接在一起，从而实现 **丰富的组合**。当我们想要使用它们时，可观察对象操作符看起来像数组方法。例如，用于可观察对象的
    `map` 操作符与数组的 `map` 方法用法相似。在下一节中，我们将学习 RxJS 库，它提供了这些操作符，并通过示例了解其中的一些。
- en: The RxJS library
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS 库
- en: 'As mentioned previously, Angular comes with a peer dependency on RxJS, the
    JavaScript flavor of the **ReactiveX** library, which allows us to create observables
    out of a large variety of scenarios, including the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular 依赖于 RxJS，这是 **ReactiveX** 库的 JavaScript 版本，它允许我们从各种场景中创建可观察对象，包括以下内容：
- en: Interaction events
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互事件
- en: Promises
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises
- en: Callback functions
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: Events
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Reactive programming does not aim to replace asynchronous patterns like promises
    or callbacks. All the way around, it can leverage them as well to create observable
    sequences.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程并不旨在取代异步模式，如承诺或回调。相反，它也可以利用它们来创建可观察序列。
- en: RxJS has built-in support for various composable operators to transform, filter,
    and combine the resulting event streams. Its API provides convenient methods for
    observers to subscribe to these streams so that our components can respond accordingly
    to state changes or input interaction. Let’s see some of these operators in action
    in the following subsections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS内置了对各种可组合操作符的支持，用于转换、过滤和组合结果事件流。它的API为观察者提供了方便的方法来订阅这些流，以便我们的组件能够相应地响应状态变化或输入交互。以下小节中，我们将看到一些这些操作符的实际应用。
- en: Creating observables
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可观察对象
- en: We have already learned how to create an observable from a DOM event using the
    `fromEvent` operator. Two other popular operators concerned with observable creation
    are the `of` and `from` operators.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用`fromEvent`操作符从DOM事件创建可观察对象。与可观察对象创建相关的另外两个流行的操作符是`of`和`from`操作符。
- en: 'The `of` operator is used to create an observable from values such as numbers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`of`操作符用于从数字等值创建可观察对象：'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous snippet prints the numbers **1** , **2** , and **3** in the browser
    console window *in order* .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段按顺序在浏览器控制台窗口中打印了数字**1**、**2**和**3**。
- en: 'The `from` operator is used to convert an array to an observable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`操作符用于将数组转换为可观察对象：'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `from` operator is also very useful when converting promises or callbacks
    to observables. We could wrap the `onComplete` method in the `constructor` of
    the `AppComponent` class as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`操作符在将承诺或回调转换为可观察对象时也非常有用。我们可以在`AppComponent`类的`constructor`中将`onComplete`方法包装如下：'
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `from` operator is an excellent way to migrate to observables if you use
    promises in an existing application!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个现有的应用程序中使用承诺，`from`操作符是迁移到可观察对象的一个极好方式！
- en: Besides creating observables, the RxJS library also contains a couple of handy
    operators to manipulate and transform data emitted from observables.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建可观察对象外，RxJS库还包含了一些实用的操作符，用于操作和转换从可观察对象发出的数据。
- en: Transforming observables
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换可观察对象
- en: 'We have already learned how to create a numeric-only directive in *Chapter
    4* , *Enriching Applications Using Pipes and Directives* . We will now use RxJS
    operators to accomplish the same thing in our key logger component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*第4章*，*使用管道和指令丰富应用*中学习了如何创建只包含数字的指令。现在，我们将使用RxJS操作符在我们的键记录器组件中完成相同的事情：
- en: 'Open the `key-logger.component.ts` file and import the `tap` operator from
    the `rxjs` npm package:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`key-logger.component.ts`文件，并从`rxjs` npm包中导入`tap`操作符：
- en: '[PRE25]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Refactor the `ngOnInit` method as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式重构`ngOnInit`方法：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `pipe` operator links and combines multiple operators separated by commas.
    We can think of it as a recipe that defines the operators that should be applied
    to an observable. One of them is the `tap` operator, which is used when we want
    to do something with the data emitted without modifying it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`操作符将用逗号分隔的多个操作符链接和组合起来。我们可以将其视为一个配方，定义了应用于可观察对象的操作符。其中之一是`tap`操作符，当我们想要对数据执行某些操作而不修改它时使用。'
- en: 'We want to exclude non-numeric values that the `logger$` observable emits.
    We already get the actual key pressed from the `evt` property, but it returns
    alphanumeric values. It would not be efficient to list all non-numeric values
    and exclude them manually. Instead, we will use the `map` operator to get the
    actual Unicode value of the key. It behaves similarly to the `map` method of an
    array as it returns an observable with a modified version of the initial data.
    Import the `map` operator from the `rxjs` npm package:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要排除`logger$`可观察对象发出的非数字值。我们已经从`evt`属性中获取了实际按下的键，但它返回的是字母数字值。列出所有非数字值并手动排除它们将不会很高效。相反，我们将使用`map`操作符来获取键的实际Unicode值。它的工作方式与数组的`map`方法类似，因为它返回一个包含修改后初始数据的可观察对象。从`rxjs`
    npm包中导入`map`操作符：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following snippet above the `tap` operator in the `ngOnInit` method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`方法中`tap`操作符上方添加以下代码片段：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now add the `filter` operator, which operates similarly to the `filter`
    method of an array for excluding non-numeric values. Import the `filter` operator
    from the `rxjs` npm package:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以添加`filter`操作符，它的工作方式与数组的`filter`方法类似，用于排除非数字值。从`rxjs` npm包中导入`filter`操作符：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following snippet after the `map` operator in the `ngOnInit` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`方法中`map`运算符之后添加以下代码片段：
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The observable currently emits Unicode character codes. We must convert them
    back to keyboard characters to display them on the HTML template. Refactor the
    `tap` operator to accommodate this change:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前可观察对象发出的是Unicode字符码。我们必须将它们转换回键盘字符以便在HTML模板中显示。重构`tap`运算符以适应这一变化：
- en: '[PRE31]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As a final touch, we will add an input binding in the component to toggle the
    numeric-only feature on and off conditionally:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们将在组件中添加一个输入绑定，以有条件地切换仅数字功能：
- en: 'Add the `input` function in the `import` statement of the `@angular/core` npm
    package:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@angular/core` npm包的`import`语句中添加`input`函数：
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a `numeric` input property in the `KeyLoggerComponent` class:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`KeyLoggerComponent`类中添加一个`numeric`输入属性：
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Refactor the `filter` operator in the `ngOnInit` method so that it takes into
    account the `numeric` property:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构`ngOnInit`方法中的`filter`运算符，使其考虑`numeric`属性：
- en: '[PRE34]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `logger$` observable will filter non-numeric values only if the `numeric`
    input property is `true` .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`numeric`输入属性为`true`时，`logger$`可观察对象才会过滤非数字值。
- en: 'The `ngOnInit` method should finally look like the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ngOnInit`方法最终应如下所示：'
- en: '[PRE35]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open the `app.component.html` file and add a binding to the `numeric` property
    in the `<app-key-logger>` selector:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.html`文件，并在`<app-key-logger>`选择器中添加对`numeric`属性的绑定：
- en: '[PRE36]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the application using the `ng serve` command and enter `Angular 19` inside
    the input box:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，并在输入框中输入`Angular 19`：
- en: '![Εικόνα που περιέχει κείμενο, γραμματοσειρά, στιγμιότυπο οθόνης, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_06_02.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、字体、屏幕截图、描述的图像](img/B21418_06_02.png)'
- en: 'Figure 6.2: Numeric key logger'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：数字键盘记录器
- en: We have seen RxJS operators manipulating observables that return primitive data
    types such as numbers, strings, and arrays. In the following section, we will
    learn how to use observables in our e-shop application.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了RxJS运算符如何操作返回原始数据类型（如数字、字符串和数组）的可观察对象。在下一节中，我们将学习如何在我们的电子商务应用程序中使用可观察对象。
- en: Subscribing to observables
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅可观察对象
- en: 'We have already learned that an observer needs to subscribe to an observable
    to get emitted data. The observer in our case will be the product list component
    and the observable will reside inside the `products.service.ts` file. Thus, we
    first need to convert the `ProductsService` class to use observables instead of
    plain arrays so that components can subscribe to get data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到观察者需要订阅一个可观察对象以获取发出的数据。在我们的例子中，观察者将是产品列表组件，而可观察对象将位于`products.service.ts`文件中。因此，我们首先需要将`ProductsService`类转换为使用可观察对象而不是普通数组，以便组件可以订阅以获取数据：
- en: 'Open the `products.service.ts` file and add the following `import` statement:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`products.service.ts`文件，并添加以下`import`语句：
- en: '[PRE37]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Extract the product data used in the `getProducts` method into a separate service
    property to enhance code readability:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`getProducts`方法中使用的商品数据提取到单独的服务属性中，以增强代码可读性：
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Modify the `getProducts` method so that it returns the `products` property
    as an observable:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`getProducts`方法，使其返回`products`属性作为可观察对象：
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding snippet, we use the `of` operator to create a new observable
    from the `products` array.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`of`运算符从`products`数组创建一个新的可观察对象。
- en: 'The `ProductsService` class now emits product data using observables. We must
    modify the component to subscribe and get this data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsService`类现在使用可观察对象发出产品数据。我们必须修改组件以订阅并获取这些数据：'
- en: 'Open the `product-list.component.ts` file and create a `getProducts` method
    in the `ProductListComponent` class:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件，并在`ProductListComponent`类中创建一个`getProducts`方法：
- en: '[PRE40]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding method, we subscribe to the `getProducts` method of the `ProductsService`
    class because it returns an observable instead of a plain array. The `products`
    array is returned inside the `subscribe` method, where we set the `products` component
    property to the array emitted from the observable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们订阅了`ProductsService`类的`getProducts`方法，因为它返回一个可观察对象而不是一个普通数组。`products`数组在`subscribe`方法中返回，在那里我们将`products`组件属性设置为从可观察对象发出的数组。
- en: 'Modify the `ngOnInit` method so that it calls the newly created `getProducts`
    method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ngOnInit`方法，使其调用新创建的`getProducts`方法：
- en: '[PRE41]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We could have added the body of the `getProducts` method inside the `ngOnInit`
    method directly. We did not as component lifecycle event methods should be as
    clear and concise as possible. Always try to extract their logic in a separate
    method for clarity.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将`getProducts`方法的主体直接放在`ngOnInit`方法中。我们没有这样做，因为组件生命周期事件方法应该尽可能清晰简洁。始终尝试将它们的逻辑提取到单独的方法中以提高清晰度。
- en: 'Run the application using the `ng serve` command, and you should see the product
    list displayed on the page successfully:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ng serve`命令运行应用程序，你应该能够成功地在页面上显示产品列表：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, λογότυπο  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_06_03.png)Figure 6.3: Product list'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含文本、屏幕截图、字体、标志的图像，自动生成的描述](img/B21418_06_03.png)图6.3：产品列表'
- en: As depicted in the previous image, we have achieved the same result of displaying
    the product list as in *Chapter 5* , *Managing Complex Tasks with Services* ,
    but using observables. It may not be evident at once, but we have set the foundation
    for working with the Angular HTTP client which is based on observables. In *Chapter
    8* , *Communicating with Data Services over HTTP* , we will explore the HTTP client
    in more detail.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张图所示，我们已经达到了与*第5章*中*使用服务管理复杂任务*相同的结果，即显示产品列表，但使用了可观察对象。这可能一开始并不明显，但我们已经为使用基于可观察对象的Angular
    HTTP客户端奠定了基础。在*第8章*，*通过HTTP与数据服务通信*中，我们将更详细地探讨HTTP客户端。
- en: When we subscribe to observables, we are prone to potential memory leaks if
    we do not clean them up on time. In the following section, we will learn about
    different ways to accomplish that.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅可观察对象时，如果我们没有及时清理它们，我们容易受到潜在内存泄漏的影响。在下一节中，我们将了解不同的方法来完成这项任务。
- en: Unsubscribing from observables
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从可观察对象中取消订阅
- en: When we subscribe to an observable, we create an observer that listens for changes
    in a data stream. The observer watches the stream continuously while the subscription
    remains active. When a subscription is active, it reserves memory in the browser
    and consumes certain resources. If we do not tell the observer to unsubscribe
    at some point and clean up any resources, the subscription to the observable will
    *possibly* lead to a memory leak.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们订阅一个可观察对象时，我们创建一个观察者来监听数据流中的变化。在订阅保持活跃的同时，观察者会持续监视该流。当订阅活跃时，它会在浏览器中保留内存并消耗一定资源。如果我们没有告诉观察者在某个时刻取消订阅并清理任何资源，对可观察对象的订阅可能会*可能地*导致内存泄漏。
- en: An observer usually needs to unsubscribe when the Angular component that created
    the subscription must be destroyed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者通常需要在创建订阅的Angular组件必须被销毁时取消订阅。
- en: 'Some of the most well-known techniques to use for unsubscribing from observables
    are the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从可观察对象中取消订阅的最知名的技术如下：
- en: Unsubscribe from an observable manually
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动取消可观察对象的订阅
- en: Use the `async` pipe in a component template
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件模板中使用`async`管道
- en: Let’s see both techniques in action in the following subsections.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下小节中看到这两种技术的实际应用。
- en: Destroying a component
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁组件
- en: A component has lifecycle events we can use to hook on and perform custom logic,
    as we learned in *Chapter 3* , *Structuring User Interfaces with Components* .
    One of them is the `ngOnDestroy` event, which is called when the component is
    destroyed and no longer exists.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有我们可以用来挂钩并执行自定义逻辑的生命周期事件，正如我们在*第3章*，*使用组件构建用户界面*中学到的。其中之一是`ngOnDestroy`事件，它在组件被销毁且不再存在时被调用。
- en: 'Recall `ProductListComponent` and `ProductViewComponent` , which we used earlier
    in our examples. They subscribe to the appropriate methods of `ProductsService`
    and `ProductViewService` upon component initialization. When components are destroyed,
    the reference of the subscriptions stays active, which may lead to unpredictable
    behavior. We need to manually unsubscribe when components are destroyed to clean
    up any resources properly:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前在示例中使用的`ProductListComponent`和`ProductViewComponent`，它们在组件初始化时订阅了`ProductsService`和`ProductViewService`的相应方法。当组件被销毁时，订阅的引用仍然保持活跃，这可能会导致不可预测的行为。我们需要在组件销毁时手动取消订阅以正确清理任何资源：
- en: 'Open the `product-list.component.ts` file and add the following `import` statement:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件并添加以下`import`语句：
- en: '[PRE42]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the following property in the `ProductListComponent` class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductListComponent`类中创建以下属性：
- en: '[PRE43]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assign the `productsSub` property to the subscription result in the `getProducts`
    method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getProducts`方法中将`productsSub`属性分配给订阅结果：
- en: '[PRE44]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Import the `OnDestroy` lifecycle hook from the `@angular/core` npm package:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`@angular/core` npm包中导入`OnDestroy`生命周期钩子：
- en: '[PRE45]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add `OnDestroy` to the implemented interface list of the `ProductListComponent`
    class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnDestroy`添加到`ProductListComponent`类的实现接口列表中：
- en: '[PRE46]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `ngOnDestroy` method as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现`ngOnDestroy`方法：
- en: '[PRE47]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `unsubscribe` method removes an observer from the active listeners of a
    subscription and cleans up any reserved resources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsubscribe`方法从订阅的活跃监听器中移除观察者，并清理任何预留的资源。'
- en: That’s a lot of boilerplate code to unsubscribe from a single subscription.
    It may quickly become unreadable and unmaintainable if we have many subscriptions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了取消一个订阅就需要这么多的样板代码，如果我们有很多订阅，这可能会很快变得难以阅读和维护。
- en: 'Alternatively, we can use a particular type of operator called `takeUntilDestroyed`
    **,** which is available in the `@angular/core/rxjs-interop` package. We will
    explore the way of unsubscribing from observables using this operator in the product
    list component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一种特定类型的操作符，称为`takeUntilDestroyed` **,** 它在`@angular/core/rxjs-interop`包中可用。我们将在产品列表组件中探索使用此操作符取消订阅观察者的方式：
- en: 'Open the `product-list.component.ts` file and import the `inject` , `DestroyRef`
    , and `takeUntilDestroyed` artifacts as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件，并按照以下方式导入`inject`、`DestroyRef`和`takeUntilDestroyed`实体：
- en: '[PRE48]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `takeUntilDestroyed` artifact is an operator that unsubscribes from an observable
    when the component is destroyed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`takeUntilDestroyed`实体是一个操作符，当组件被销毁时，它会取消订阅观察者。'
- en: 'Declare the following property to inject the `DestroyRef` service:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下属性以注入`DestroyRef`服务：
- en: '[PRE49]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Modify the `getProducts` method as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改`getProducts`方法：
- en: '[PRE50]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding method, we use the `pipe` operator to chain the `takeUntilDestroyed`
    operator with the subscription from the `getProducts` method of the `ProductsService`
    class. The `takeUntilDestroyed` operator accepts a parameter of the `DestroyRef`
    service.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用`pipe`操作符将`takeUntilDestroyed`操作符与`ProductsService`类的`getProducts`方法的订阅链接起来。`takeUntilDestroyed`操作符接受`DestroyRef`服务的参数。
- en: Remove any code related to the `ngOnDestroy` method.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除与`ngOnDestroy`方法相关的任何代码。
- en: That’s it! We have now converted our subscription to be more declarative and
    readable. However, the problem of maintainability still exists. Our components
    are now unsubscribing from their observables manually. We can solve that using
    a special-purpose Angular pipe, the `async` pipe, which allows us to unsubscribe
    automatically with less code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经将我们的订阅转换为更声明性和易读的形式。然而，可维护性的问题仍然存在。我们的组件现在正在手动取消它们的观察者订阅。我们可以使用一个专门的Angular管道，即`async`管道，来解决这个问题，它允许我们用更少的代码自动取消订阅。
- en: Using the async pipe
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步管道
- en: 'The `async` pipe is a built-in Angular pipe used in conjunction with observables,
    and its role is two-fold. It helps us to type less code and saves us from having
    to set up and tear down a subscription. It automatically subscribes to an observable
    and unsubscribes when the component is destroyed. We will use it to simplify the
    code of the product list component:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`管道是Angular内置的管道，与观察者一起使用，其作用有两方面。它帮助我们编写更少的代码，并使我们免于设置和取消订阅。它自动订阅观察者，并在组件销毁时取消订阅。我们将使用它来简化产品列表组件的代码：'
- en: 'Open the `product-list.component.ts` file and add the following `import` statements:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.ts`文件，并添加以下`import`语句：
- en: '[PRE51]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the `AsyncPipe` class into the `imports` array of the `@Component` decorator:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AsyncPipe`类添加到`@Component`装饰器的`imports`数组中：
- en: '[PRE52]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Convert the `products` component property to an observable:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`products`组件属性转换为观察者：
- en: '[PRE53]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Assign the `getProducts` method of the `ProductsService` class to the `products$`
    component property:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ProductsService`类的`getProducts`方法分配给`products$`组件属性：
- en: '[PRE54]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The body of the `getProducts` method has now been reduced to one line and has
    become more readable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProducts`方法的主体现在已经被缩减到一行，并且变得更加易读。'
- en: 'Open the `product-list.component.html` file and add the following snippet at
    the beginning of the file:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`product-list.component.html`文件，并在文件开头添加以下片段：
- en: '[PRE55]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding snippet, we subscribe to the `products$` observable using the
    `async` pipe and create a template variable using the `@let` keyword. The template
    variable has the same name as the respective component property we had previously,
    so we do not need to change the component template further.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用 `async` 管道订阅了 `products$` 观察者，并使用 `@let` 关键字创建了一个模板变量。这个模板变量的名称与之前相应的组件属性相同，因此我们不需要进一步更改组件模板。
- en: That’s it! We do not need to subscribe or unsubscribe from the observable manually
    anymore! The `async` pipe takes care of everything for us.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们不再需要手动订阅或取消订阅观察者了！`async` 管道会为我们处理一切。
- en: We have learned that observables react to application events and emit values
    asynchronously in registered observers. We could visualize observables as wrapper
    objects around emitted values. Angular enriches the reactivity field of web applications
    by providing a similar wrapper that works synchronously and reacts to application
    state changes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到观察者会对应用程序事件做出反应，并异步地向注册的观察者发出值。我们可以将观察者想象为围绕发出值的包装对象。Angular 通过提供类似的包装器，该包装器同步工作并响应应用程序状态变化，从而丰富了
    Web 应用的响应式领域。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It takes much more than a single chapter to cover in detail all the great things
    we can do with reactivity in Angular. The good news is that we have covered all
    the tools and classes we need for basic Angular development.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细涵盖 Angular 中所有我们可以用响应式编程做到的伟大事情，需要不止一个章节。好消息是，我们已经涵盖了进行基本 Angular 开发所需的所有工具和类。
- en: We learned what reactive programming is and how it can be used in Angular. We
    saw how to apply reactive techniques like observables to interact with data streams.
    We explored the RxJS library and how to use some operators to manipulate observables.
    We learned different ways of subscribing and unsubscribing from observables in
    Angular components.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了什么是响应式编程以及如何在 Angular 中使用它。我们看到了如何应用响应式技术，如观察者，来与数据流交互。我们探讨了 RxJS 库以及如何使用一些操作符来操作观察者。我们学习了在
    Angular 组件中订阅和取消订阅观察者的不同方法。
- en: The rest is just left to your imagination, so feel free to go the extra mile
    and put all of this knowledge into practice in your Angular applications. The
    possibilities are endless, and you have strategies ranging from promises and observables.
    You can leverage the incredible functionalities of the reactive patterns and build
    amazing reactive experiences for your Angular applications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就留给你的想象力了，所以请尽情发挥，将所有这些知识应用到你的 Angular 应用程序中。可能性是无限的，你有从承诺和观察者到响应式模式的各种策略。你可以利用响应式模式的惊人功能，为你的
    Angular 应用程序构建令人惊叹的响应式体验。
- en: As we have already highlighted, the sky’s the limit. However, we still have
    a long and exciting road ahead. In the next chapter, we will explore signals,
    an alternate reactive pattern built into the Angular framework. We will learn
    how to use Angular signals to handle the state of an Angular application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经强调的，天空才是极限。然而，我们仍然有一条漫长而激动人心的道路要走。在下一章中，我们将探索信号，这是 Angular 框架中内置的另一种响应式模式。我们将学习如何使用
    Angular 信号来处理 Angular 应用程序的状态。
