<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-100"><em class="italic"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1.1">Chapter 8</span></em><span class="koboSpan" id="kobo.2.1">: Use Case Scenario 2 – Jotai</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">Jotai (</span><a href="https://github.com/pmndrs/jotai"><span class="koboSpan" id="kobo.4.1">https://github.com/pmndrs/jotai</span></a><span class="koboSpan" id="kobo.5.1">) is a small library for the global state. </span><span class="koboSpan" id="kobo.5.2">It's modeled after </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">useState</span></strong><span class="koboSpan" id="kobo.7.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">useReducer</span></strong><span class="koboSpan" id="kobo.9.1"> and with what are called atoms, which are usually small pieces of state. </span><span class="koboSpan" id="kobo.9.2">Unlike Zustand, it is a component state, and like Zustand, it is an immutable update model. </span><span class="koboSpan" id="kobo.9.3">The implementation is based on the Context and Subscription patterns we learned about in </span><a href="B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Sharing Component State with Context and Subscription</span></em><span class="koboSpan" id="kobo.13.1">.</span></p>
			<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will learn about the basic usage of the Jotai library and how it deals with optimizing re-renders. </span><span class="koboSpan" id="kobo.14.2">With atoms, the library can track dependencies and trigger re-renders based on the dependencies. </span><span class="koboSpan" id="kobo.14.3">Because Jotai internally uses Context and atoms themselves do not hold values, atom definitions are reusable, unlike the module state. </span><span class="koboSpan" id="kobo.14.4">We will also discuss </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.15.1">a novel pattern with atoms, called </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.17.1">, which is a technique to optimize re-renders with an array structure.</span></p>
			<p><span class="koboSpan" id="kobo.18.1">In this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.19.1">Understanding Jotai</span></li>
				<li><span class="koboSpan" id="kobo.20.1">Exploring render optimization</span></li>
				<li><span class="koboSpan" id="kobo.21.1">Understanding how Jotai works to store atom values</span></li>
				<li><span class="koboSpan" id="kobo.22.1">Adding an array structure</span></li>
				<li><span class="koboSpan" id="kobo.23.1">Using the different features of Jotai</span></li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.25.1">You are expected to have moderate knowledge of React, including React hooks. </span><span class="koboSpan" id="kobo.25.2">Refer to the official site, </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.26.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.27.1">, to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.28.1">In some code, we use TypeScript (</span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.29.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.30.1">), and you should have basic knowledge of it.</span></p>
			<p><span class="koboSpan" id="kobo.31.1">The code in this chapter is available on GitHub at </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_08"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_08</span></a><span class="koboSpan" id="kobo.33.1">.</span></p>
			<p><span class="koboSpan" id="kobo.34.1">To run the code snippets in this chapter, you need a React environment—for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.35.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.36.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.37.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.38.1">).</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.39.1">Understanding Jotai</span></h1>
			<p><span class="koboSpan" id="kobo.40.1">To understand </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.41.1">the Jotai </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">application programming interface</span></strong><span class="koboSpan" id="kobo.43.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.44.1">API</span></strong><span class="koboSpan" id="kobo.45.1">), let's remind ourselves </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.46.1">of a simple counter example and the solution with Context.</span></p>
			<p><span class="koboSpan" id="kobo.47.1">Here is an example with two separate counters:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.48.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.49.1">  const [count, setCount] = useState(0); // [1]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.50.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.51.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.52.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.53.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.54.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.55.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.56.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.57.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.58.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.59.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.60.1">    &lt;div&gt;&lt;Counter1 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.61.1">    &lt;div&gt;&lt;Counter2 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.62.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.63.1">);</span></p>
			<p><span class="koboSpan" id="kobo.64.1">Because these </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">Counter1</span></strong><span class="koboSpan" id="kobo.66.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Counter2</span></strong><span class="koboSpan" id="kobo.68.1"> components have their own local states, the numbers shown in these components are isolated.</span></p>
			<p><span class="koboSpan" id="kobo.69.1">If we want </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.70.1">those two components to share a single count state, we can lift the state up and use Context to pass it down, as we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.71.1">Effectively using local states</span></em><span class="koboSpan" id="kobo.72.1"> section of </span><a href="B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035"><em class="italic"><span class="koboSpan" id="kobo.73.1">Chapter 2</span></em></a><span class="koboSpan" id="kobo.74.1">, </span><em class="italic"><span class="koboSpan" id="kobo.75.1">Using Local and Global States</span></em><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">Let's see an example that is solved with Context.</span></p>
			<p><span class="koboSpan" id="kobo.77.1">First, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">Context</span></strong><span class="koboSpan" id="kobo.79.1"> variable to hold the count state, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.80.1">const CountContext = createContext();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.81.1">const CountProvider = ({ children }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.82.1">  &lt;CountContext.Provider value={useState(0)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.83.1">    {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.84.1">  &lt;/CountContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.85.1">);</span></p>
			<p><span class="koboSpan" id="kobo.86.1">Notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">Context</span></strong><span class="koboSpan" id="kobo.88.1"> value is the same state, </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">useState(0)</span></strong><span class="koboSpan" id="kobo.90.1">, as we used in the previous example (marked </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">[1]</span></strong><span class="koboSpan" id="kobo.92.1">).</span></p>
			<p><span class="koboSpan" id="kobo.93.1">Then, the following are the modified components, where we replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">useState(0)</span></strong><span class="koboSpan" id="kobo.95.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">useContext(CountContext)</span></strong><span class="koboSpan" id="kobo.97.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.98.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.99.1">  const [count, setCount] = useContext(CountContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.100.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.101.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.102.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.103.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.104.1">  const [count, setCount] = useContext(CountContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.105.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.106.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.107.1">};</span></p>
			<p><span class="koboSpan" id="kobo.108.1">Finally, we wrap those components with </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">CountProvider</span></strong><span class="koboSpan" id="kobo.110.1">, like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.111.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.112.1">  &lt;CountProvider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.113.1">    &lt;div&gt;&lt;Counter1 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.114.1">    &lt;div&gt;&lt;Counter2 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.115.1">  &lt;/CountProvider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.116.1">);</span></p>
			<p><span class="koboSpan" id="kobo.117.1">This makes </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.118.1">it possible to have a shared count state, and you will see that two </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">count</span></strong><span class="koboSpan" id="kobo.120.1"> numbers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">Counter1</span></strong><span class="koboSpan" id="kobo.122.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Counter2</span></strong><span class="koboSpan" id="kobo.124.1"> components are incremented at once.</span></p>
			<p><span class="koboSpan" id="kobo.125.1">Now, let's see how Jotai is helpful compared to Context. </span><span class="koboSpan" id="kobo.125.2">There are two benefits when using Jotai, as follows: </span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.126.1">Syntax simplicity</span></li>
				<li><span class="koboSpan" id="kobo.127.1">Dynamic atom creation</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.128.1">Let's start with the first benefit—how Jotai can help to simplify the syntax.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.129.1">Syntax simplicity</span></h2>
			<p><span class="koboSpan" id="kobo.130.1">To understand </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.131.1">syntax simplicity, let's look at the same counter </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.132.1">example with Jotai. </span><span class="koboSpan" id="kobo.132.2">First, we need to import some functions from the Jotai library, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.133.1">import { atom, useAtom } from "jotai";</span></p>
			<p><span class="koboSpan" id="kobo.134.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">atom</span></strong><span class="koboSpan" id="kobo.136.1"> function and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">useAtom</span></strong><span class="koboSpan" id="kobo.138.1"> hook are basic functions provided by Jotai.</span></p>
			<p><span class="koboSpan" id="kobo.139.1">An atom represents a piece of a state. </span><span class="koboSpan" id="kobo.139.2">An atom is usually a small piece of state, and it is a minimum unit of triggering re-renders. </span><span class="koboSpan" id="kobo.139.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">atom</span></strong><span class="koboSpan" id="kobo.141.1"> function creates a definition of an atom. </span><span class="koboSpan" id="kobo.141.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">atom</span></strong><span class="koboSpan" id="kobo.143.1"> function takes one argument to specify an initial value, just as </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">useState</span></strong><span class="koboSpan" id="kobo.145.1"> does. </span><span class="koboSpan" id="kobo.145.2">The following code is used to define a new atom:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.146.1">const countAtom = atom(0);</span></p>
			<p><span class="koboSpan" id="kobo.147.1">Notice </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.148.1">the similarity with </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">useState(0)</span></strong><span class="koboSpan" id="kobo.150.1">.</span></p>
			<p><span class="koboSpan" id="kobo.151.1">Now, we use </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.152.1">the atom in counter components. </span><span class="koboSpan" id="kobo.152.2">Instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">useState(0)</span></strong><span class="koboSpan" id="kobo.154.1">, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">useAtom(countAtom)</span></strong><span class="koboSpan" id="kobo.156.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.157.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.158.1">  const [count, setCount] = useAtom(countAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.159.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.160.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.161.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.162.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.163.1">  const [count, setCount] = useAtom(countAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.164.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.165.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.166.1">};</span></p>
			<p><span class="koboSpan" id="kobo.167.1">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">useAtom(countAtom)</span></strong><span class="koboSpan" id="kobo.169.1"> returns the same tuple, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">[count, setCount]</span></strong><span class="koboSpan" id="kobo.171.1">, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">useState(0)</span></strong><span class="koboSpan" id="kobo.173.1"> does, the rest of the code doesn't need to be changed.</span></p>
			<p><span class="koboSpan" id="kobo.174.1">Finally, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">App</span></strong><span class="koboSpan" id="kobo.176.1"> component is the same as in the first example of this chapter, which is without Context, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.177.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.178.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.179.1">    &lt;div&gt;&lt;Counter1 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.180.1">    &lt;div&gt;&lt;Counter2 /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.181.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.182.1">);</span></p>
			<p><span class="koboSpan" id="kobo.183.1">Unlike the second example of this chapter, which is with Context, we don't need a provider. </span><span class="koboSpan" id="kobo.183.2">This is possible due to the "default store" in Context, as we learned in the </span><em class="italic"><span class="koboSpan" id="kobo.184.1">Implementing the Context and Subscription pattern</span></em><span class="koboSpan" id="kobo.185.1"> section of </span><a href="B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073"><em class="italic"><span class="koboSpan" id="kobo.186.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.187.1">, </span><em class="italic"><span class="koboSpan" id="kobo.188.1">Sharing Component State with Context and Subscription</span></em><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">We can optionally use a provider when we need to provide different values for different subtrees.</span></p>
			<p><span class="koboSpan" id="kobo.190.1">To have a </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.191.1">better understanding of the syntax simplicity in Jotai, let's </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.192.1">suppose you want to add another global state—say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">text</span></strong><span class="koboSpan" id="kobo.194.1">; you would end up adding the following code:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.195.1">const TextContext = createContext();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.196.1">const TextProvider = ({ children }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.197.1">  &lt;TextContext.Provider value={useState("")}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.198.1">    {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.199.1">  &lt;/TextContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.200.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.201.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.202.1">  &lt;TextProvider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.203.1">    ...</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.204.1">  &lt;/TextProvider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.205.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.206.1">// When you use it in a component</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.207.1">  const [text, setText] = useContext(TextContext);</span></p>
			<p><span class="koboSpan" id="kobo.208.1">This is not too bad. </span><span class="koboSpan" id="kobo.208.2">What we added is a Context definition and a provider definition, and we wrapped </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">App</span></strong><span class="koboSpan" id="kobo.210.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">Provider</span></strong><span class="koboSpan" id="kobo.212.1"> component. </span><span class="koboSpan" id="kobo.212.2">You can also avoid provider nesting, as we learned in the </span><em class="italic"><span class="koboSpan" id="kobo.213.1">Best practices for using Context</span></em><span class="koboSpan" id="kobo.214.1"> section of </span><a href="B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049"><em class="italic"><span class="koboSpan" id="kobo.215.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.216.1">, </span><em class="italic"><span class="koboSpan" id="kobo.217.1">Sharing the Component State with Context</span></em><span class="koboSpan" id="kobo.218.1">.</span></p>
			<p><span class="koboSpan" id="kobo.219.1">However, the same example could be done with Jotai atoms, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.220.1">const textAtom = atom("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.221.1">// When you use it in a component</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.222.1">  const [text, setText] = useAtom(textAtom);</span></p>
			<p><span class="koboSpan" id="kobo.223.1">This is far </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.224.1">simpler. </span><span class="koboSpan" id="kobo.224.2">Essentially, we added just a one-line atom definition. </span><span class="koboSpan" id="kobo.224.3">Even if </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.225.1">we had more atoms, we would just need a line for each atom definition in Jotai. </span><span class="koboSpan" id="kobo.225.2">On the other hand, using Context would require creating a Context for each piece of state. </span><span class="koboSpan" id="kobo.225.3">It's possible to do it with Context, but not trivial. </span><span class="koboSpan" id="kobo.225.4">Jotai's syntax is much more simplified. </span><span class="koboSpan" id="kobo.225.5">This is the first benefit of Jotai.</span></p>
			<p><span class="koboSpan" id="kobo.226.1">While the syntax simplicity is great, it doesn't give any new capability. </span><span class="koboSpan" id="kobo.226.2">Let's briefly discuss the second benefit.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.227.1">Dynamic atom creation</span></h2>
			<p><span class="koboSpan" id="kobo.228.1">The second benefit of Jotai is a new capability—that is, dynamic atom creation. </span><span class="koboSpan" id="kobo.228.2">Atoms can be </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.229.1">created and destroyed in the React component lifecycle. </span><span class="koboSpan" id="kobo.229.2">This is not possible with the multiple-Context approach, because adding a </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.230.1">new state means adding a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Provider</span></strong><span class="koboSpan" id="kobo.232.1"> component. </span><span class="koboSpan" id="kobo.232.2">If you add a new component, all its child components will be remounted, throwing away their states. </span><span class="koboSpan" id="kobo.232.3">We will cover a use case of dynamic atom creation in the </span><em class="italic"><span class="koboSpan" id="kobo.233.1">Adding an array structure</span></em><span class="koboSpan" id="kobo.234.1"> section.</span></p>
			<p><span class="koboSpan" id="kobo.235.1">The implementation of Jotai is based on what we learned in </span><a href="B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073"><em class="italic"><span class="koboSpan" id="kobo.236.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.237.1">, </span><em class="italic"><span class="koboSpan" id="kobo.238.1">Sharing Component State with Context and Subscription</span></em><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">Jotai's store is basically a </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">WeakMap</span></strong><span class="koboSpan" id="kobo.241.1"> object (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"><span class="koboSpan" id="kobo.242.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap</span></a><span class="koboSpan" id="kobo.243.1">) of atom config objects and </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.244.1">atom values. </span><span class="koboSpan" id="kobo.244.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">atom config object</span></strong><span class="koboSpan" id="kobo.246.1"> is a definition </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.247.1">created with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">atom</span></strong><span class="koboSpan" id="kobo.249.1"> function. </span><span class="koboSpan" id="kobo.249.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">atom value</span></strong><span class="koboSpan" id="kobo.251.1"> is a value that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">useAtom</span></strong><span class="koboSpan" id="kobo.253.1"> hook returns. </span><span class="koboSpan" id="kobo.253.2">Subscription in Jotai is atom-based, which means the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">useAtom</span></strong><span class="koboSpan" id="kobo.255.1"> hook subscribes to a certain atom in </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">store</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">Atom-based Subscription gives the ability to avoid extra re-renders. </span><span class="koboSpan" id="kobo.257.3">We will discuss this further in the next section.</span></p>
			<p><span class="koboSpan" id="kobo.258.1">In this </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.259.1">section, we discussed the basic mental model and the </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.260.1">API of the Jotai library. </span><span class="koboSpan" id="kobo.260.2">Next up, we will dive into how the atom model solves render optimization.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.261.1">Exploring render optimization</span></h1>
			<p><span class="koboSpan" id="kobo.262.1">Let's recap </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.263.1">on selector-based render optimization. </span><span class="koboSpan" id="kobo.263.2">We will start by using an example from </span><a href="B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066"><em class="italic"><span class="koboSpan" id="kobo.264.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.265.1">, </span><em class="italic"><span class="koboSpan" id="kobo.266.1">Sharing Module State with Subscription</span></em><span class="koboSpan" id="kobo.267.1">, where we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">createStore</span></strong><span class="koboSpan" id="kobo.269.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.271.1">.</span></p>
			<p><span class="koboSpan" id="kobo.272.1">Let's define a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">store</span></strong><span class="koboSpan" id="kobo.274.1"> person with </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">createStore</span></strong><span class="koboSpan" id="kobo.276.1">. </span><span class="koboSpan" id="kobo.276.2">We define three properties: </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">firstName</span></strong><span class="koboSpan" id="kobo.278.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">lastName</span></strong><span class="koboSpan" id="kobo.280.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">age</span></strong><span class="koboSpan" id="kobo.282.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.283.1">const personStore = createStore({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.284.1">  firstName: "React",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.285.1">  lastName: "Hooks",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.286.1">  age: 3,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.287.1">});</span></p>
			<p><span class="koboSpan" id="kobo.288.1">Suppose we would like to create a component that shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">firstName</span></strong><span class="koboSpan" id="kobo.290.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">lastName</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">One straightforward way is to select those properties. </span><span class="koboSpan" id="kobo.292.3">Here is an example with </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.294.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">const selectFirstName = (state) =&gt; state.firstName;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.296.1">const selectLastName = (state) =&gt; state.lastName;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.297.1">const PersonComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.298.1">  const firstName =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.299.1">    useStoreSelector(store, selectFirstName);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.300.1">  const lastName = useStoreSelector(store, selectLastName);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.301.1">  return &lt;&gt;{firstName} {lastName}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.302.1">};</span></p>
			<p><span class="koboSpan" id="kobo.303.1">As we have selected only two properties from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">store</span></strong><span class="koboSpan" id="kobo.305.1">, when the non-selected property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">age</span></strong><span class="koboSpan" id="kobo.307.1">, is changed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">PersonComponent</span></strong><span class="koboSpan" id="kobo.309.1"> will not re-render.</span></p>
			<p><span class="koboSpan" id="kobo.310.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">store</span></strong><span class="koboSpan" id="kobo.312.1"> and selector </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.313.1">approach is what we call </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">top-down</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">We create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">store</span></strong><span class="koboSpan" id="kobo.317.1"> that holds everything and select pieces of state from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">store</span></strong><span class="koboSpan" id="kobo.319.1"> as necessary.</span></p>
			<p><span class="koboSpan" id="kobo.320.1">Now, what would </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.321.1">Jotai atoms look like for the same example? </span><span class="koboSpan" id="kobo.321.2">First, we define atoms, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.322.1">const firstNameAtom = atom("React");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.323.1">const lastNameAtom = atom("Hooks");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.324.1">const ageAtom = atom(3);</span></p>
			<p><span class="koboSpan" id="kobo.325.1">Atoms are units of triggering re-renders. </span><span class="koboSpan" id="kobo.325.2">You can make atoms as small as you want to control re-renders, like primitive values. </span><span class="koboSpan" id="kobo.325.3">But atoms can be objects too.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">PersonComponent</span></strong><span class="koboSpan" id="kobo.327.1"> can be implemented with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">useAtom</span></strong><span class="koboSpan" id="kobo.329.1"> hook, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.330.1">const PersonComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.331.1">  const [firstName] = useAtom(firstNameAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.332.1">  const [lastName] = useAtom(lastNameAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.333.1">  return &lt;&gt;{firstName} {lastName}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.334.1">};</span></p>
			<p><span class="koboSpan" id="kobo.335.1">Because this has no relationship with </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">ageAtom</span></strong><span class="koboSpan" id="kobo.337.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">PersonComponent</span></strong><span class="koboSpan" id="kobo.339.1"> won't re-render when the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ageAtom</span></strong><span class="koboSpan" id="kobo.341.1"> is changed.</span></p>
			<p><span class="koboSpan" id="kobo.342.1">Atoms can be as small as possible, but that means we would probably have too many atoms to organize. </span><span class="koboSpan" id="kobo.342.2">Jotai has a notion of derived atoms, where you can create another atom from existing atoms. </span><span class="koboSpan" id="kobo.342.3">Let's create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">personAtom</span></strong><span class="koboSpan" id="kobo.344.1"> variable that holds the first name, last name, and age. </span><span class="koboSpan" id="kobo.344.2">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">atom</span></strong><span class="koboSpan" id="kobo.346.1"> function, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">read</span></strong><span class="koboSpan" id="kobo.348.1"> function to generate a derived value. </span><span class="koboSpan" id="kobo.348.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.349.1">const personAtom = atom((get) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.350.1">  firstName: get(firstNameAtom),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.351.1">  lastName: get(lastNameAtom),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.352.1">  age: get(ageAtom),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.353.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.354.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">read</span></strong><span class="koboSpan" id="kobo.356.1"> function takes an argument called </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">get</span></strong><span class="koboSpan" id="kobo.358.1">, with which you can refer to other atoms and </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.359.1">get their values. </span><span class="koboSpan" id="kobo.359.2">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">personAtom</span></strong><span class="koboSpan" id="kobo.361.1"> is an object with three properties—</span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">firstName</span></strong><span class="koboSpan" id="kobo.363.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">lastName</span></strong><span class="koboSpan" id="kobo.365.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">age</span></strong><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">This value is updated whenever one of the properties is changed, which means when </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">firstNameAtom</span></strong><span class="koboSpan" id="kobo.369.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">lastNameAtom</span></strong><span class="koboSpan" id="kobo.371.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">ageAtom</span></strong><span class="koboSpan" id="kobo.373.1"> is updated. </span><span class="koboSpan" id="kobo.373.2">This is called dependency tracking and is automatically done by the Jotai library.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.374.1">Important Note </span></p>
			<p class="callout"><span class="koboSpan" id="kobo.375.1">Dependency tracking is dynamic and works for conditional evaluations. </span><span class="koboSpan" id="kobo.375.2">For example, suppose a </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">read</span></strong><span class="koboSpan" id="kobo.377.1"> function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">(get) =&gt; get(a) ? </span><span class="koboSpan" id="kobo.378.2">get(b) : get(c)</span></strong><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">In this case, if the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">a</span></strong><span class="koboSpan" id="kobo.381.1"> is truthy, the dependency is </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">a</span></strong><span class="koboSpan" id="kobo.383.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">b</span></strong><span class="koboSpan" id="kobo.385.1">, whereas if the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">a</span></strong><span class="koboSpan" id="kobo.387.1"> is falsy, the dependency is </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">a</span></strong><span class="koboSpan" id="kobo.389.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">c</span></strong><span class="koboSpan" id="kobo.391.1">.</span></p>
			<p><span class="koboSpan" id="kobo.392.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">personAtom</span></strong><span class="koboSpan" id="kobo.394.1">, we could re-implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">PersonComponent</span></strong><span class="koboSpan" id="kobo.396.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.397.1">const PersonComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.398.1">  const person = useAtom(personAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.399.1">  return &lt;&gt;{person.firstName} {person.lastName}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.400.1">};</span></p>
			<p><span class="koboSpan" id="kobo.401.1">However, this is </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.402.1">not what we expect. </span><span class="koboSpan" id="kobo.402.2">It will re-render when </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">ageAtom</span></strong><span class="koboSpan" id="kobo.404.1"> changes its value, hence causing extra re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.405.1">To avoid extra re-renders, we should create a derived atom including only values we use. </span><span class="koboSpan" id="kobo.405.2">Here is another atom, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">fullNameAtom</span></strong><span class="koboSpan" id="kobo.407.1"> this time:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.408.1">const fullNameAtom = atom((get) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.409.1">  firstName: get(firstNameAtom),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.410.1">  lastName: get(lastNameAtom),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.411.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.412.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">fullNameAtom</span></strong><span class="koboSpan" id="kobo.414.1">, we can implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">PersonComponent</span></strong><span class="koboSpan" id="kobo.416.1"> once again, like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.417.1">const PersonComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.418.1">  const person = useAtom(fullNameAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.419.1">  return &lt;&gt;{person.firstName} {person.lastName}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.420.1">};</span></p>
			<p><span class="koboSpan" id="kobo.421.1">Thanks to </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">fullNameAtom</span></strong><span class="koboSpan" id="kobo.423.1">, this doesn't re-render even when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">ageAtom</span></strong><span class="koboSpan" id="kobo.425.1"> value is changed.</span></p>
			<p><span class="koboSpan" id="kobo.426.1">We call this a </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">bottom-up</span></strong><span class="koboSpan" id="kobo.428.1"> approach. </span><span class="koboSpan" id="kobo.428.2">We </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.429.1">create small atoms and combine them to create bigger atoms. </span><span class="koboSpan" id="kobo.429.2">We can optimize re-renders by adding only atoms that will be used in components. </span><span class="koboSpan" id="kobo.429.3">The optimization is not automatic, but more straightforward with the atom model.</span></p>
			<p><span class="koboSpan" id="kobo.430.1">How could </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.431.1">we do the last example with a store and selector approach? </span><span class="koboSpan" id="kobo.431.2">Here is an example with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">identity</span></strong><span class="koboSpan" id="kobo.433.1"> selector:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.434.1">const identity = (x) =&gt; x;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.435.1">const PersonComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.436.1">  const person = useStoreSelector(store, identity);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.437.1">  return &lt;&gt;{person.firstName} {person.lastName}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.438.1">};</span></p>
			<p><span class="koboSpan" id="kobo.439.1">As you might guess, this causes extra re-renders. </span><span class="koboSpan" id="kobo.439.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">age</span></strong><span class="koboSpan" id="kobo.441.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">store</span></strong><span class="koboSpan" id="kobo.443.1"> is changed, the component re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.444.1">A possible fix would be to select only </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">firstName</span></strong><span class="koboSpan" id="kobo.446.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">lastName</span></strong><span class="koboSpan" id="kobo.448.1">. </span><span class="koboSpan" id="kobo.448.2">The following example illustrates this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.449.1">const selectFullName = (state) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.450.1">  firstName: state.firstName,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.451.1">  lastName: state.lastName,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.452.1">});</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.453.1">const PersonComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.454.1">  const person = useStoreSelector(store, selectFullName);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.455.1">  return &lt;&gt;{person.firstName} {person.lastName}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.456.1">};</span></p>
			<p><span class="koboSpan" id="kobo.457.1">Unfortunately, this doesn't work. </span><span class="koboSpan" id="kobo.457.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">age</span></strong><span class="koboSpan" id="kobo.459.1"> is changed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">selectFullName</span></strong><span class="koboSpan" id="kobo.461.1"> function is re-evaluated, and it returns a new object with the same property values. </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.463.1"> assumes the new object may contain new values and trigger re-renders, which causes extra re-renders. </span><span class="koboSpan" id="kobo.463.2">This is a well-known issue with the selector approach, and typical solutions are to use either a custom equality function or a memoization technique.</span></p>
			<p><span class="koboSpan" id="kobo.464.1">The benefit </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.465.1">of the atom model is that the composition of atoms can easily relate to what will be shown in a component. </span><span class="koboSpan" id="kobo.465.2">Thus, it's straightforward to control re-renders. </span><span class="koboSpan" id="kobo.465.3">Render optimization with atoms doesn't require the custom equality function or the memoization technique.</span></p>
			<p><span class="koboSpan" id="kobo.466.1">Let's look at a counter example to learn more about the derived atoms. </span><span class="koboSpan" id="kobo.466.2">First, we define two </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">count</span></strong><span class="koboSpan" id="kobo.468.1"> atoms, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.469.1">const count1Atom = atom(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.470.1">const count2Atom = atom(0);</span></p>
			<p><span class="koboSpan" id="kobo.471.1">We define a component to use those </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">count</span></strong><span class="koboSpan" id="kobo.473.1"> atoms. </span><span class="koboSpan" id="kobo.473.2">Instead of defining two counter components, we define a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">Counter</span></strong><span class="koboSpan" id="kobo.475.1"> component that works for both atoms. </span><span class="koboSpan" id="kobo.475.2">To this end, the component receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">countAtom</span></strong><span class="koboSpan" id="kobo.477.1"> in its </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">props</span></strong><span class="koboSpan" id="kobo.479.1">, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.480.1">const Counter = ({ countAtom }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.481.1">  const [count, setCount] = useAtom(countAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.482.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.483.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.484.1">};</span></p>
			<p><span class="koboSpan" id="kobo.485.1">This is reusable for any </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">countAtom</span></strong><span class="koboSpan" id="kobo.487.1"> configs. </span><span class="koboSpan" id="kobo.487.2">Even if we define a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">count3Atom</span></strong><span class="koboSpan" id="kobo.489.1"> config, we don't need to define a new component.</span></p>
			<p><span class="koboSpan" id="kobo.490.1">Next, we define a derived atom that calculates the total number of two counts. </span><span class="koboSpan" id="kobo.490.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">atom</span></strong><span class="koboSpan" id="kobo.492.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">read</span></strong><span class="koboSpan" id="kobo.494.1"> function as the first argument, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.495.1">const totalAtom = atom(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.496.1">  (get) =&gt; get(count1Atom) + get(count2Atom)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">);</span></p>
			<p><span class="koboSpan" id="kobo.498.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">read</span></strong><span class="koboSpan" id="kobo.500.1"> function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">atom</span></strong><span class="koboSpan" id="kobo.502.1"> will create a derived atom. </span><span class="koboSpan" id="kobo.502.2">The value of the derived atom is the result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">read</span></strong><span class="koboSpan" id="kobo.504.1"> function. </span><span class="koboSpan" id="kobo.504.2">The derived atom will re-evaluate its </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">read</span></strong><span class="koboSpan" id="kobo.506.1"> function and update its value only when dependencies are changed. </span><span class="koboSpan" id="kobo.506.2">In this case, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">count1Atom</span></strong><span class="koboSpan" id="kobo.508.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">count2Atom</span></strong><span class="koboSpan" id="kobo.510.1"> is changed.</span></p>
			<p><span class="koboSpan" id="kobo.511.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Total</span></strong><span class="koboSpan" id="kobo.513.1"> component is a component to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">totalAtom</span></strong><span class="koboSpan" id="kobo.515.1"> and show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">total</span></strong><span class="koboSpan" id="kobo.517.1"> number, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">const Total = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.519.1">  const [total] = useAtom(totalAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.520.1">  return &lt;&gt;{total}&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.521.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">totalAtom</span></strong><span class="koboSpan" id="kobo.523.1"> is a derived </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.524.1">atom and it's read-only because its value is the result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">read</span></strong><span class="koboSpan" id="kobo.526.1"> function. </span><span class="koboSpan" id="kobo.526.2">Hence, there's no notion of setting a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">totalAtom</span></strong><span class="koboSpan" id="kobo.528.1">.</span></p>
			<p><span class="koboSpan" id="kobo.529.1">Finally, we define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">App</span></strong><span class="koboSpan" id="kobo.531.1"> component. </span><span class="koboSpan" id="kobo.531.2">It passes </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">count1Atom</span></strong><span class="koboSpan" id="kobo.533.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">count2Atom</span></strong><span class="koboSpan" id="kobo.535.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">Counter</span></strong><span class="koboSpan" id="kobo.537.1"> components, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.538.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.539.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.540.1">    (&lt;Counter countAtom={count1Atom} /&gt;)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.541.1">    +</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.542.1">    (&lt;Counter countAtom={count2Atom} /&gt;)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.543.1">    =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.544.1">    &lt;Total /&gt;  </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.545.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.546.1">);</span></p>
			<p><span class="koboSpan" id="kobo.547.1">Atoms can be passed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">props</span></strong><span class="koboSpan" id="kobo.549.1">, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Counter</span></strong><span class="koboSpan" id="kobo.551.1"> atom in this example, or they can be passed by any other means—constants at the module level, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">props</span></strong><span class="koboSpan" id="kobo.553.1">, contexts, or even as values in other atoms. </span><span class="koboSpan" id="kobo.553.2">We will learn about the use case of putting atoms in another atom in the </span><em class="italic"><span class="koboSpan" id="kobo.554.1">Adding an array structure</span></em><span class="koboSpan" id="kobo.555.1"> section.</span></p>
			<p><span class="koboSpan" id="kobo.556.1">When you run the app, you will see an equation of the first count, the second count, and the total number. </span><span class="koboSpan" id="kobo.556.2">By clicking the buttons shown right after the counts, you will see the count </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.557.1">incremented as well as the total number, as illustrated in the following screenshot:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<span class="koboSpan" id="kobo.558.1"><img src="image/Figure_8.1_B17780.jpg" alt="Figure 8.1 – Screenshot of the counter app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.559.1">Figure 8.1 – Screenshot of the counter app</span></p>
			<p><span class="koboSpan" id="kobo.560.1">In this section, we learned about the atom model and render optimization in the Jotai library. </span><span class="koboSpan" id="kobo.560.2">Next up, we'll look into how Jotai stores atom values.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.561.1">Understanding how Jotai works to store atom values</span></h1>
			<p><span class="koboSpan" id="kobo.562.1">So far, we haven't discussed how Jotai uses Context. </span><span class="koboSpan" id="kobo.562.2">In this section, we'll show how Jotai stores </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.563.1">atom values and how atoms are reusable.</span></p>
			<p><span class="koboSpan" id="kobo.564.1">First, let's revisit a simple atom definition, </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">countAtom</span></strong><span class="koboSpan" id="kobo.566.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">atom</span></strong><span class="koboSpan" id="kobo.568.1"> takes an initial value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">0</span></strong><span class="koboSpan" id="kobo.570.1"> and returns an atom config, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.571.1">const countAtom = atom(0);</span></p>
			<p><span class="koboSpan" id="kobo.572.1">Implementation-wise, </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">countAtom</span></strong><span class="koboSpan" id="kobo.574.1"> is an object holding some properties representing the atom behavior. </span><span class="koboSpan" id="kobo.574.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">countAtom</span></strong><span class="koboSpan" id="kobo.576.1"> is a primitive atom, which is an atom with a value that can be updated with a value or an updating function. </span><span class="koboSpan" id="kobo.576.2">A primitive atom is designed to behave like </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">useState</span></strong><span class="koboSpan" id="kobo.578.1">.</span></p>
			<p><span class="koboSpan" id="kobo.579.1">What is important is that atom configs such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">countAtom</span></strong><span class="koboSpan" id="kobo.581.1"> don't hold their values. </span><span class="koboSpan" id="kobo.581.2">We have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">store</span></strong><span class="koboSpan" id="kobo.583.1"> that holds atom values. </span><span class="koboSpan" id="kobo.583.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">store</span></strong><span class="koboSpan" id="kobo.585.1"> has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">WeakMap</span></strong><span class="koboSpan" id="kobo.587.1"> object whose key is an atom config object and whose value is an atom value.</span></p>
			<p><span class="koboSpan" id="kobo.588.1">When we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">useAtom</span></strong><span class="koboSpan" id="kobo.590.1">, by default, it uses a default </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">store</span></strong><span class="koboSpan" id="kobo.592.1"> defined at the module level. </span><span class="koboSpan" id="kobo.592.2">However, Jotai provides a component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">Provider</span></strong><span class="koboSpan" id="kobo.594.1">, which lets you create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">store</span></strong><span class="koboSpan" id="kobo.596.1"> at the component level. </span><span class="koboSpan" id="kobo.596.2">We can import </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Provider</span></strong><span class="koboSpan" id="kobo.598.1"> from the Jotai library along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">atom</span></strong><span class="koboSpan" id="kobo.600.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">useAtom</span></strong><span class="koboSpan" id="kobo.602.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.603.1">import { atom, useAtom, Provider } from "jotai";</span></p>
			<p><span class="koboSpan" id="kobo.604.1">Let's suppose we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">Counter</span></strong><span class="koboSpan" id="kobo.606.1"> component defined, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.607.1">const Counter = ({ countAtom }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.608.1">  const [count, setCount] = useAtom(countAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.609.1">  const inc = () =&gt; setCount((c) =&gt; c + 1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.610.1">  return &lt;&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.611.1">};</span></p>
			<p><span class="koboSpan" id="kobo.612.1">This is the </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.613.1">same component we defined in the </span><em class="italic"><span class="koboSpan" id="kobo.614.1">Understanding Jotai</span></em><span class="koboSpan" id="kobo.615.1"> section and the </span><em class="italic"><span class="koboSpan" id="kobo.616.1">Exploring render optimization</span></em><span class="koboSpan" id="kobo.617.1"> section.</span></p>
			<p><span class="koboSpan" id="kobo.618.1">We then define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">App</span></strong><span class="koboSpan" id="kobo.620.1"> component using </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Provider</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">We use two </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Provider</span></strong><span class="koboSpan" id="kobo.624.1"> components and put in two </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">Counter</span></strong><span class="koboSpan" id="kobo.626.1"> components for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Provider</span></strong><span class="koboSpan" id="kobo.628.1"> component, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.629.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.630.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.631.1">    &lt;Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.632.1">      &lt;h1&gt;First Provider&lt;/h1&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.633.1">      &lt;div&gt;&lt;Counter /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.634.1">      &lt;div&gt;&lt;Counter /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.635.1">    &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.636.1">    &lt;Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.637.1">      &lt;h1&gt;Second Provider&lt;/h1&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.638.1">      &lt;div&gt;&lt;Counter /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.639.1">      &lt;div&gt;&lt;Counter /&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.640.1">    &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.641.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.642.1">);</span></p>
			<p><span class="koboSpan" id="kobo.643.1">The two </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Provider</span></strong><span class="koboSpan" id="kobo.645.1"> components in </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">App</span></strong><span class="koboSpan" id="kobo.647.1"> isolate stores. </span><span class="koboSpan" id="kobo.647.2">Hence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">countAtom</span></strong><span class="koboSpan" id="kobo.649.1"> used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">Counter</span></strong><span class="koboSpan" id="kobo.651.1"> components is isolated. </span><span class="koboSpan" id="kobo.651.2">The two </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Counter</span></strong><span class="koboSpan" id="kobo.653.1"> components under the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">Provider</span></strong><span class="koboSpan" id="kobo.655.1"> component share the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">countAtom</span></strong><span class="koboSpan" id="kobo.657.1"> value, but the other two </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Counter</span></strong><span class="koboSpan" id="kobo.659.1"> components </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.660.1">under the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Provider</span></strong><span class="koboSpan" id="kobo.662.1"> component have different values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">countAtom</span></strong><span class="koboSpan" id="kobo.664.1"> from the value in the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Provider</span></strong><span class="koboSpan" id="kobo.666.1"> component, as shown here:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<span class="koboSpan" id="kobo.667.1"><img src="image/Figure_8.2_B17780.jpg" alt="Figure 8.2 – Screenshot of the two-provider app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.668.1">Figure 8.2 – Screenshot of the two-provider app</span></p>
			<p><span class="koboSpan" id="kobo.669.1">Again, what is important is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">countAtom</span></strong><span class="koboSpan" id="kobo.671.1"> itself doesn't hold a value. </span><span class="koboSpan" id="kobo.671.2">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">countAtom</span></strong><span class="koboSpan" id="kobo.673.1"> is reusable for multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">Provider</span></strong><span class="koboSpan" id="kobo.675.1"> components. </span><span class="koboSpan" id="kobo.675.2">This is a notable difference from module states.</span></p>
			<p><span class="koboSpan" id="kobo.676.1">We could define a derived atom. </span><span class="koboSpan" id="kobo.676.2">Here is a derived atom to define the doubled number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">countAtom</span></strong><span class="koboSpan" id="kobo.678.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.679.1">const doubledCountAtom = atom(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.680.1">  (get) =&gt; get(countAtom) * 2</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.681.1">);</span></p>
			<p><span class="koboSpan" id="kobo.682.1">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">countAtom</span></strong><span class="koboSpan" id="kobo.684.1"> doesn't hold a value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.686.1"> doesn't either. </span><span class="koboSpan" id="kobo.686.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.688.1"> is used in the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">Provider</span></strong><span class="koboSpan" id="kobo.690.1"> component, it represents the doubled value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">countAtom</span></strong><span class="koboSpan" id="kobo.692.1"> value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">Provider</span></strong><span class="koboSpan" id="kobo.694.1"> component. </span><span class="koboSpan" id="kobo.694.2">The same applies to the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">Provider</span></strong><span class="koboSpan" id="kobo.696.1"> component, and the values in the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Provider</span></strong><span class="koboSpan" id="kobo.698.1"> component can be different from the values in the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">Provider</span></strong><span class="koboSpan" id="kobo.700.1"> component.</span></p>
			<p><span class="koboSpan" id="kobo.701.1">Because atom </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.702.1">configs are just definitions that don't hold values, the atom configs are reusable. </span><span class="koboSpan" id="kobo.702.2">The example shows it's reusable for two </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">Provider</span></strong><span class="koboSpan" id="kobo.704.1"> components, but essentially, it's reusable for more </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">Provider</span></strong><span class="koboSpan" id="kobo.706.1"> components. </span><span class="koboSpan" id="kobo.706.2">Furthermore, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">Provider</span></strong><span class="koboSpan" id="kobo.708.1"> component can be used dynamically in the React component life cycle. </span><span class="koboSpan" id="kobo.708.2">Implementation-wise, Jotai is totally based on Context, and Jotai can do everything that Context can do. </span><span class="koboSpan" id="kobo.708.3">In this section, we learned that atom configs don't hold values and thus are reusable. </span><span class="koboSpan" id="kobo.708.4">Next up, we will learn how to deal with arrays with Jotai.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.709.1">Adding an array structure</span></h1>
			<p><span class="koboSpan" id="kobo.710.1">An array structure is tricky to handle in React. </span><span class="koboSpan" id="kobo.710.2">When a component renders an array structure, we need </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.711.1">to pass stable </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">key</span></strong><span class="koboSpan" id="kobo.713.1"> properties to the array items. </span><span class="koboSpan" id="kobo.713.2">This is especially necessary when we remove or reorder the array items.</span></p>
			<p><span class="koboSpan" id="kobo.714.1">In this section, we'll learn how to handle array structures in Jotai. </span><span class="koboSpan" id="kobo.714.2">We'll start with a traditional approach, and then </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.715.1">a new pattern that we call </span><strong class="bold"><span class="koboSpan" id="kobo.716.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.717.1">.</span></p>
			<p><span class="koboSpan" id="kobo.718.1">Let's use the same to-do app example that we used in the </span><em class="italic"><span class="koboSpan" id="kobo.719.1">Handling structured data</span></em><span class="koboSpan" id="kobo.720.1"> section of </span><a href="B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092"><em class="italic"><span class="koboSpan" id="kobo.721.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.722.1">, </span><em class="italic"><span class="koboSpan" id="kobo.723.1">Use Case Scenario 1 – Zustand</span></em><span class="koboSpan" id="kobo.724.1">.</span></p>
			<p><span class="koboSpan" id="kobo.725.1">First, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">Todo</span></strong><span class="koboSpan" id="kobo.727.1"> type. </span><span class="koboSpan" id="kobo.727.2">It has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">id</span></strong><span class="koboSpan" id="kobo.729.1"> string, </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">title</span></strong><span class="koboSpan" id="kobo.731.1"> string, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">done</span></strong><span class="koboSpan" id="kobo.733.1"> Boolean properties, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.734.1">type Todo = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.735.1">  id: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.736.1">  title: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.737.1">  done: boolean;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.738.1">};</span></p>
			<p><span class="koboSpan" id="kobo.739.1">Next, we define </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">todosAtom</span></strong><span class="koboSpan" id="kobo.741.1">, which represents an array of defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">Todo</span></strong><span class="koboSpan" id="kobo.743.1"> items, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.744.1">const todosAtom = atom&lt;Todo[]&gt;([]);</span></p>
			<p><span class="koboSpan" id="kobo.745.1">We annotate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">atom()</span></strong><span class="koboSpan" id="kobo.747.1"> function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">Todo[]</span></strong><span class="koboSpan" id="kobo.749.1"> type.</span></p>
			<p><span class="koboSpan" id="kobo.750.1">We then </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.751.1">define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">TodoItem</span></strong><span class="koboSpan" id="kobo.753.1"> component. </span><span class="koboSpan" id="kobo.753.2">This is a pure component that receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">todo</span></strong><span class="koboSpan" id="kobo.755.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">removeTodo</span></strong><span class="koboSpan" id="kobo.757.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.759.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">props</span></strong><span class="koboSpan" id="kobo.761.1">. </span><span class="koboSpan" id="kobo.761.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.762.1">const TodoItem = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.763.1">  todo,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.764.1">  removeTodo,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.765.1">  toggleTodo,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.766.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.767.1">  todo: Todo;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.768.1">  removeTodo: (id: string) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.769.1">  toggleTodo: (id: string) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.770.1">}) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.771.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.772.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.773.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.774.1">        type="checkbox"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.775.1">        checked={todo.done}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.776.1">        onChange={() =&gt; toggleTodo(todo.id)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.777.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.778.1">      &lt;span</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.779.1">        style={{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.780.1">          textDecoration:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.781.1">            todo.done ? </span><span class="koboSpan" id="kobo.781.2">"line-through" : "none",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.782.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.783.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.784.1">        {todo.title}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.785.1">      &lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.786.1">      &lt;button</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.787.1">        onClick={() =&gt; removeTodo(todo.id)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.788.1">      &gt;Delete&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.789.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.790.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.791.1">};</span></p>
			<p><span class="koboSpan" id="kobo.792.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">onChange</span></strong><span class="koboSpan" id="kobo.794.1"> callback in </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">&lt;input&gt;</span></strong><span class="koboSpan" id="kobo.796.1"> invokes </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.798.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">onClick</span></strong><span class="koboSpan" id="kobo.800.1"> callback in </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">&lt;button&gt;</span></strong><span class="koboSpan" id="kobo.802.1"> invokes </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">removeTodo</span></strong><span class="koboSpan" id="kobo.804.1">. </span><span class="koboSpan" id="kobo.804.2">Both </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.805.1">are based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">id</span></strong><span class="koboSpan" id="kobo.807.1"> string.</span></p>
			<p><span class="koboSpan" id="kobo.808.1">We wrap </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">TodoItem</span></strong><span class="koboSpan" id="kobo.810.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">memo</span></strong><span class="koboSpan" id="kobo.812.1"> to create a memoized version, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.813.1">const MemoedTodoItem = memo(TodoItem);</span></p>
			<p><span class="koboSpan" id="kobo.814.1">This allows us to avoid re-renders unless </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">todo</span></strong><span class="koboSpan" id="kobo.816.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">removeTodo</span></strong><span class="koboSpan" id="kobo.818.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.820.1"> are changed.</span></p>
			<p><span class="koboSpan" id="kobo.821.1">Now, we are ready to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">TodoList</span></strong><span class="koboSpan" id="kobo.823.1"> component. </span><span class="koboSpan" id="kobo.823.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">todosAtom</span></strong><span class="koboSpan" id="kobo.825.1">, defines </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">removeTodo</span></strong><span class="koboSpan" id="kobo.827.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.829.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">useCallback</span></strong><span class="koboSpan" id="kobo.831.1">, and </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.832.1">maps over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">todo</span></strong><span class="koboSpan" id="kobo.834.1"> array, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.835.1">const TodoList = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.836.1">  const [todos, setTodos] = useAtom(todosAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.837.1">  const removeTodo = useCallback((id: string) =&gt; setTodos(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.838.1">    (prev) =&gt; prev.filter((item) =&gt; item.id !== id)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.839.1">  ), [setTodos]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.840.1">  const toggleTodo = useCallback((id: string) =&gt; setTodos(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.841.1">    (prev) =&gt; prev.map((item) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.842.1">      item.id === id ? </span><span class="koboSpan" id="kobo.842.2">{ ...item, done: !item.done } : item</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.843.1">    )</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.844.1">  ), [setTodos]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.845.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.846.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.847.1">      {todos.map((todo) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.848.1">        &lt;MemoedTodoItem</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.849.1">          key={todo.id}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.850.1">          todo={todo}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.851.1">          removeTodo={removeTodo}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.852.1">          toggleTodo={toggleTodo}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.853.1">        /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.854.1">      ))}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.855.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.856.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.857.1">};</span></p>
			<p><span class="koboSpan" id="kobo.858.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">TodoList</span></strong><span class="koboSpan" id="kobo.860.1"> component renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.862.1"> component for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">todos</span></strong><span class="koboSpan" id="kobo.864.1"> array item. </span><span class="koboSpan" id="kobo.864.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">key</span></strong><span class="koboSpan" id="kobo.866.1"> prop is specified as </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">todo.id</span></strong><span class="koboSpan" id="kobo.868.1">.</span></p>
			<p><span class="koboSpan" id="kobo.869.1">The next </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.870.1">component is </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">NewTodo</span></strong><span class="koboSpan" id="kobo.872.1">. </span><span class="koboSpan" id="kobo.872.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">todosAtom</span></strong><span class="koboSpan" id="kobo.874.1"> and adds a new item on button click. </span><span class="koboSpan" id="kobo.874.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">id</span></strong><span class="koboSpan" id="kobo.876.1"> value of the new atom should be uniquely generated, and in the following example, it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">nanoid</span></strong><span class="koboSpan" id="kobo.878.1"> (</span><a href="https://www.npmjs.com/package/nanoid"><span class="koboSpan" id="kobo.879.1">https://www.npmjs.com/package/nanoid</span></a><span class="koboSpan" id="kobo.880.1">):</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.881.1">const NewTodo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.882.1">  const [, setTodos] = useAtom(todosAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.883.1">  const [text, setText] = useState("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.884.1">  const onClick = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.885.1">    setTodos((prev) =&gt; [</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.886.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.887.1">      { id: nanoid(), title: text, done: false },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.888.1">    ]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.889.1">    setText("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.890.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.891.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.892.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.893.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.894.1">        value={text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.895.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.896.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.897.1">      &lt;button onClick={onClick} disabled={!text}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.898.1">        Add</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.899.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.900.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.901.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.902.1">};</span></p>
			<p><span class="koboSpan" id="kobo.903.1">For simplicity, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">useAtom</span></strong><span class="koboSpan" id="kobo.905.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">todosAtom</span></strong><span class="koboSpan" id="kobo.907.1">. </span><span class="koboSpan" id="kobo.907.2">However, this actually makes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">NewTodo</span></strong><span class="koboSpan" id="kobo.909.1"> component re-render when the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">todosAtom</span></strong><span class="koboSpan" id="kobo.911.1"> is changed. </span><span class="koboSpan" id="kobo.911.2">We could easily avoid this with an additional utility hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">useUpdateAtom</span></strong><span class="koboSpan" id="kobo.913.1">.</span></p>
			<p><span class="koboSpan" id="kobo.914.1">Finally, we create </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.915.1">an </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">App</span></strong><span class="koboSpan" id="kobo.917.1"> component to render </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">TodoList</span></strong><span class="koboSpan" id="kobo.919.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">NewTodo</span></strong><span class="koboSpan" id="kobo.921.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.922.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.923.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.924.1">    &lt;TodoList /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.925.1">    &lt;NewTodo /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.926.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.927.1">);</span></p>
			<p><span class="koboSpan" id="kobo.928.1">This works perfectly. </span><span class="koboSpan" id="kobo.928.2">You can add, remove, and toggle to-do items without any issues, as shown here:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<span class="koboSpan" id="kobo.929.1"><img src="image/Figure_8.3_B17780.jpg" alt="Figure 8.3 – Screenshot of the Todo app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.930.1">Figure 8.3 – Screenshot of the Todo app</span></p>
			<p><span class="koboSpan" id="kobo.931.1"> There are two concerns, though, from the developer's perspective, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.932.1">The first concern is we need to modify the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">todos</span></strong><span class="koboSpan" id="kobo.934.1"> array to mutate a single item. </span><span class="koboSpan" id="kobo.934.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.936.1"> function, it needs to iterate over all the items and mutate just one item. </span><span class="koboSpan" id="kobo.936.2">In the atomic model, it would be nice if we could simply mutate one item. </span><span class="koboSpan" id="kobo.936.3">This is also related to performance. </span><span class="koboSpan" id="kobo.936.4">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">todos</span></strong><span class="koboSpan" id="kobo.938.1"> array items are mutated, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">todos</span></strong><span class="koboSpan" id="kobo.940.1"> array itself is changed. </span><span class="koboSpan" id="kobo.940.2">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">TodoList</span></strong><span class="koboSpan" id="kobo.942.1"> re-renders. </span><span class="koboSpan" id="kobo.942.2">Thanks to </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.944.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.946.1"> components don't re-render unless the specific item is changed. </span><span class="koboSpan" id="kobo.946.2">Ideally, we want to trigger those specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.948.1"> components to re-render.</span></li>
				<li><span class="koboSpan" id="kobo.949.1">The second concern is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">id</span></strong><span class="koboSpan" id="kobo.951.1"> value of an item. </span><span class="koboSpan" id="kobo.951.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">id</span></strong><span class="koboSpan" id="kobo.953.1"> value is primarily for </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">key</span></strong><span class="koboSpan" id="kobo.955.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">map</span></strong><span class="koboSpan" id="kobo.957.1">, and it would be nice if we could avoid using </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">id</span></strong><span class="koboSpan" id="kobo.959.1">.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.960.1">With Jotai, we propose a new pattern, </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.962.1">, with which we put atom configs in </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.963.1">another atom value. </span><span class="koboSpan" id="kobo.963.2">This pattern addresses the two concerns and is more consistent with Jotai's mental model.</span></p>
			<p><span class="koboSpan" id="kobo.964.1">Let's see how we can re-create the same Todo app we created previously in this section with the new pattern.</span></p>
			<p><span class="koboSpan" id="kobo.965.1">We start by defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">Todo</span></strong><span class="koboSpan" id="kobo.967.1"> type, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.968.1">type Todo = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.969.1">  title: string;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.970.1">  done: boolean;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.971.1">};</span></p>
			<p><span class="koboSpan" id="kobo.972.1">This time, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">Todo</span></strong><span class="koboSpan" id="kobo.974.1"> type doesn't have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">id</span></strong><span class="koboSpan" id="kobo.976.1"> value.</span></p>
			<p><span class="koboSpan" id="kobo.977.1">We then create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">TodoAtom</span></strong><span class="koboSpan" id="kobo.979.1"> type with </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">PrimitiveAtom</span></strong><span class="koboSpan" id="kobo.981.1">, which is a generic type exported by the Jotai library. </span><span class="koboSpan" id="kobo.981.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.982.1">type TodoAtom = PrimitiveAtom&lt;Todo&gt;;</span></p>
			<p><span class="koboSpan" id="kobo.983.1">We use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">TodoAtom</span></strong><span class="koboSpan" id="kobo.985.1"> type to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">todoAtomsAtom</span></strong><span class="koboSpan" id="kobo.987.1"> config, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.988.1">const todoAtomsAtom = atom&lt;TodoAtom[]&gt;([]);</span></p>
			<p><span class="koboSpan" id="kobo.989.1">The name is explicit, to tell that it's an </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">atom</span></strong><span class="koboSpan" id="kobo.991.1"> that represents an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">TodoAtom</span></strong><span class="koboSpan" id="kobo.993.1">. </span><span class="koboSpan" id="kobo.993.2">This structure is why the pattern is named </span><strong class="bold"><span class="koboSpan" id="kobo.994.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.995.1">.</span></p>
			<p><span class="koboSpan" id="kobo.996.1">Here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">TodoItem</span></strong><span class="koboSpan" id="kobo.998.1"> component. </span><span class="koboSpan" id="kobo.998.2">It receives </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1000.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">remove</span></strong><span class="koboSpan" id="kobo.1002.1"> properties. </span><span class="koboSpan" id="kobo.1002.2">The component uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1004.1"> atom with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">useAtom</span></strong><span class="koboSpan" id="kobo.1006.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1007.1">const TodoItem = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1008.1">  todoAtom,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1009.1">  remove,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1010.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1011.1">  todoAtom: TodoAtom;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1012.1">  remove: (todoAtom: TodoAtom) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1013.1">}) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1014.1">  const [todo, setTodo] = useAtom(todoAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1015.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1016.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1017.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1018.1">        type="checkbox"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1019.1">        checked={todo.done}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1020.1">        onChange={() =&gt; setTodo(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1021.1">          (prev) =&gt; ({ ...prev, done: !prev.done })</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1022.1">        )}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1023.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1024.1">      &lt;span</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1025.1">        style={{</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1026.1">          textDecoration: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1027.1">            todo.done ? </span><span class="koboSpan" id="kobo.1027.2">"line-through" : "none",</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1028.1">        }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1029.1">      &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1030.1">        {todo.title}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1031.1">      &lt;/span&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1032.1">      &lt;button onClick={() =&gt; remove(todoAtom)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1033.1">        Delete</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1034.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1035.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1036.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1037.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1038.1">const MemoedTodoItem = memo(TodoItem);</span></p>
			<p><span class="koboSpan" id="kobo.1039.1">Thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">useAtom</span></strong><span class="koboSpan" id="kobo.1041.1"> config in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">TodoItem</span></strong><span class="koboSpan" id="kobo.1043.1"> component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">onChange</span></strong><span class="koboSpan" id="kobo.1045.1"> callback is very simple and only cares about the item. </span><span class="koboSpan" id="kobo.1045.2">It doesn't depend on the fact that it's an item of the array.</span></p>
			<p><span class="koboSpan" id="kobo.1046.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">TodoList</span></strong><span class="koboSpan" id="kobo.1048.1"> component </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.1049.1">should be carefully looked at. </span><span class="koboSpan" id="kobo.1049.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">todoAtomsAtom</span></strong><span class="koboSpan" id="kobo.1051.1">, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">todoAtoms</span></strong><span class="koboSpan" id="kobo.1053.1"> as its value. </span><span class="koboSpan" id="kobo.1053.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">todoAtoms</span></strong><span class="koboSpan" id="kobo.1055.1"> variable holds an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1057.1">. </span><span class="koboSpan" id="kobo.1057.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">remove</span></strong><span class="koboSpan" id="kobo.1059.1"> function is interesting as it takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1061.1"> as the atom config and filters the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1063.1"> array in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">todoAtomsAtom</span></strong><span class="koboSpan" id="kobo.1065.1">. </span><span class="koboSpan" id="kobo.1065.2">The full code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">TodoList</span></strong><span class="koboSpan" id="kobo.1067.1"> is shown here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1068.1">const TodoList = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1069.1">  const [todoAtoms, setTodoAtoms] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1070.1">    useAtom(todoAtomsAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1071.1">  const remove = useCallback(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1072.1">    (todoAtom: TodoAtom) =&gt; setTodoAtoms(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1073.1">      (prev) =&gt; prev.filter((item) =&gt; item !== todoAtom)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1074.1">    ),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1075.1">    [setTodoAtoms]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1076.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1077.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1078.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1079.1">      {todoAtoms.map((todoAtom) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1080.1">        &lt;MemoedTodoItem</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1081.1">          key={`${todoAtom}`}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1082.1">          todoAtom={todoAtom}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1083.1">          remove={remove}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1084.1">        /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1085.1">      ))}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1086.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1087.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1088.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">TodoList</span></strong><span class="koboSpan" id="kobo.1090.1"> maps over the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">todoAtoms</span></strong><span class="koboSpan" id="kobo.1092.1"> variable and renders </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">MemoedTodoItem</span></strong><span class="koboSpan" id="kobo.1094.1"> for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1096.1"> config. </span><span class="koboSpan" id="kobo.1096.2">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">key</span></strong><span class="koboSpan" id="kobo.1098.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">map</span></strong><span class="koboSpan" id="kobo.1100.1">, we specify the stringified </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">todoAtom</span></strong><span class="koboSpan" id="kobo.1102.1"> config. </span><span class="koboSpan" id="kobo.1102.2">An atom config </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.1103.1">returns a </span><strong class="bold"><span class="koboSpan" id="kobo.1104.1">unique identifier</span></strong><span class="koboSpan" id="kobo.1105.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1106.1">UID</span></strong><span class="koboSpan" id="kobo.1107.1">) when evaluated as a string, thus we don't need to </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.1108.1">manage string IDs by ourselves. </span><span class="koboSpan" id="kobo.1108.2">The behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">TodoList</span></strong><span class="koboSpan" id="kobo.1110.1"> component is slightly different from the previous version. </span><span class="koboSpan" id="kobo.1110.2">Because it deals with </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.1112.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">todoAtomsAtom</span></strong><span class="koboSpan" id="kobo.1114.1"> won't be changed if one of the items is toggled with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">toggleTodo</span></strong><span class="koboSpan" id="kobo.1116.1">. </span><span class="koboSpan" id="kobo.1116.2">Thus, it can reduce some extra re-renders by nature.</span></p>
			<p><span class="koboSpan" id="kobo.1117.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">NewTodo</span></strong><span class="koboSpan" id="kobo.1119.1"> component is almost the same as the previous example. </span><span class="koboSpan" id="kobo.1119.2">One exception is that when creating a new item, it will create a new atom config and push it into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">todoAtomsAtom</span></strong><span class="koboSpan" id="kobo.1121.1">. </span><span class="koboSpan" id="kobo.1121.2">The following snippet shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">NewTodo</span></strong><span class="koboSpan" id="kobo.1123.1"> component code:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1124.1">const NewTodo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1125.1">  const [, setTodoAtoms] = useAtom(todoAtomsAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1126.1">  const [text, setText] = useState("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1127.1">  const onClick = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1128.1">    setTodoAtoms((prev) =&gt; [</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1129.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1130.1">      atom&lt;Todo&gt;({ title: text, done: false }),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1131.1">    ]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1132.1">    setText("");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1133.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1134.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1135.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1136.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1137.1">        value={text}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1138.1">        onChange={(e) =&gt; setText(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1139.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1140.1">      &lt;button onClick={onClick} disabled={!text}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1141.1">        Add</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1142.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1143.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1144.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1145.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1146.1">The reset </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1147.1">of the code and the behavior of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">NewTodo</span></strong><span class="koboSpan" id="kobo.1149.1"> component are basically equivalent to the previous example.</span></p>
			<p><span class="koboSpan" id="kobo.1150.1">Finally, we have the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">App</span></strong><span class="koboSpan" id="kobo.1152.1"> component to run the app, as illustrated here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1153.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1154.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1155.1">    &lt;TodoList /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1156.1">    &lt;NewTodo /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1157.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1158.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1159.1">If you run the app, you will see no differences from the previous example. </span><span class="koboSpan" id="kobo.1159.2">As described, the differences are for developers.</span></p>
			<p><span class="koboSpan" id="kobo.1160.1">Let's summarize </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.1161.1">the difference with the </span><strong class="bold"><span class="koboSpan" id="kobo.1162.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.1163.1"> pattern, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.1164.1">An array atom is used to hold an array of item atoms.</span></li>
				<li><span class="koboSpan" id="kobo.1165.1">To add a new item in the array, we create a new atom and add it.</span></li>
				<li><span class="koboSpan" id="kobo.1166.1">Atom configs can be evaluated as strings, and they return UIDs.</span></li>
				<li><span class="koboSpan" id="kobo.1167.1">A component that renders an item uses an item atom in each component. </span><span class="koboSpan" id="kobo.1167.2">It eases mutating the item value and avoids extra re-renders naturally.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.1168.1">In this section, we learned how to handle the array structure. </span><span class="koboSpan" id="kobo.1168.2">We saw two patterns—a naive one and an </span><strong class="bold"><span class="koboSpan" id="kobo.1169.1">Atoms-in-Atom</span></strong><span class="koboSpan" id="kobo.1170.1"> one—and their differences. </span><span class="koboSpan" id="kobo.1170.2">Next up, we will learn about some other features that the Jotai library provides.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.1171.1">Using the different features of Jotai</span></h1>
			<p><span class="koboSpan" id="kobo.1172.1">So far, we've learned some basics of the Jotai library. </span><span class="koboSpan" id="kobo.1172.2">There are some more basic features that </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.1173.1">we will cover in this section. </span><span class="koboSpan" id="kobo.1173.2">These features are necessary if you need to deal with complex scenarios. </span><span class="koboSpan" id="kobo.1173.3">We'll also briefly introduce some advanced features whose use cases are out of the scope of this book.</span></p>
			<p><span class="koboSpan" id="kobo.1174.1">In this section, we'll discuss the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.1175.1">Defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">write</span></strong><span class="koboSpan" id="kobo.1177.1"> function of atoms</span></li>
				<li><span class="koboSpan" id="kobo.1178.1">Using action atoms</span></li>
				<li><span class="koboSpan" id="kobo.1179.1">Understanding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">onMount</span></strong><span class="koboSpan" id="kobo.1181.1"> option of atoms</span></li>
				<li><span class="koboSpan" id="kobo.1182.1">Introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">jotai/utils</span></strong><span class="koboSpan" id="kobo.1184.1"> bundle</span></li>
				<li><span class="koboSpan" id="kobo.1185.1">Understanding library usage</span></li>
				<li><span class="koboSpan" id="kobo.1186.1">Introduction to more advanced features</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.1187.1">Let's take a look at each one now.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.1188.1">Defining the write function of atoms</span></h2>
			<p><span class="koboSpan" id="kobo.1189.1">We have </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.1190.1">seen how to create a derived atom. </span><span class="koboSpan" id="kobo.1190.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.1192.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">countAtom</span></strong><span class="koboSpan" id="kobo.1194.1"> is defined in the </span><em class="italic"><span class="koboSpan" id="kobo.1195.1">Understanding how Jotai works to store atom values</span></em><span class="koboSpan" id="kobo.1196.1"> section, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1197.1">const countAtom = atom(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1198.1">const doubledCountAtom = atom(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1199.1">  (get) =&gt; get(countAtom) * 2</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1200.1">);</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">countAtom</span></strong><span class="koboSpan" id="kobo.1202.1"> is called a </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.1203.1">primitive atom because it's not derived from another atom. </span><span class="koboSpan" id="kobo.1203.2">A primitive atom is a writable atom where you can change the value.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.1205.1"> is a read-only derived atom because its value is fully dependent on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">countAtom</span></strong><span class="koboSpan" id="kobo.1207.1">. </span><span class="koboSpan" id="kobo.1207.2">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.1209.1"> can only be changed by changing the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">countAtom</span></strong><span class="koboSpan" id="kobo.1211.1">, which is a writable atom.</span></p>
			<p><span class="koboSpan" id="kobo.1212.1">To create a writable derived atom, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">atom</span></strong><span class="koboSpan" id="kobo.1214.1"> function accepts an optional second argument for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">write</span></strong><span class="koboSpan" id="kobo.1216.1"> function, in addition to the first argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">read</span></strong><span class="koboSpan" id="kobo.1218.1"> function.</span></p>
			<p><span class="koboSpan" id="kobo.1219.1">For example, let's redefine </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.1221.1"> to be writable. </span><span class="koboSpan" id="kobo.1221.2">We pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">write</span></strong><span class="koboSpan" id="kobo.1223.1"> function that will change the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">countAtom</span></strong><span class="koboSpan" id="kobo.1225.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1226.1">const doubledCountAtom = atom(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1227.1">  (get) =&gt; get(countAtom) * 2,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1228.1">  (get, set, arg) =&gt; set(countAtom, arg / 2)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1229.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1230.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">write</span></strong><span class="koboSpan" id="kobo.1232.1"> function </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.1233.1">takes three arguments, as follows:</span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">get</span></strong><span class="koboSpan" id="kobo.1235.1"> is a function to return the value of an atom. </span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">set</span></strong><span class="koboSpan" id="kobo.1237.1"> is a function to set the value of an atom. </span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">arg</span></strong><span class="koboSpan" id="kobo.1239.1"> is an arbitrary value to receive when updating the atom (in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">doubledCountAtom</span></strong><span class="koboSpan" id="kobo.1241.1">).</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.1242.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">write</span></strong><span class="koboSpan" id="kobo.1244.1"> function, the created atom is writable as if it is a primitive atom. </span><span class="koboSpan" id="kobo.1244.2">Actually, it is not exactly the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">countAtom</span></strong><span class="koboSpan" id="kobo.1246.1"> because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">countAtom</span></strong><span class="koboSpan" id="kobo.1248.1"> accepts an updating function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">setCount((c) =&gt; c + 1)</span></strong><span class="koboSpan" id="kobo.1250.1">.</span></p>
			<p><span class="koboSpan" id="kobo.1251.1">We can </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.1252.1">technically create a new atom that behaves identically to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">countAtom</span></strong><span class="koboSpan" id="kobo.1254.1">. </span><span class="koboSpan" id="kobo.1254.2">What would be the use case? </span><span class="koboSpan" id="kobo.1254.3">For example, you can add logging, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1255.1">const anotherCountAtom = atom(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1256.1">  (get) =&gt; get(countAtom),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1257.1">  (get, set, arg) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1258.1">    const nextCount = typeof arg === 'function' ?</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1259.1">      arg(get(countAtom)) : arg</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1260.1">    set(countAtom, nextCount)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1261.1">    console.log('set count', nextCount)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1262.1">  )</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1263.1">);</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">anotherCountAtom</span></strong><span class="koboSpan" id="kobo.1265.1"> works like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">countAtom</span></strong><span class="koboSpan" id="kobo.1267.1">, and it shows a logging message when it sets a value.</span></p>
			<p><span class="koboSpan" id="kobo.1268.1">Writable derived atoms are a powerful feature that can help in some complex scenarios. </span><span class="koboSpan" id="kobo.1268.2">In the next subsection, we'll see another pattern using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">write</span></strong><span class="koboSpan" id="kobo.1270.1"> functions.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1271.1">Using action atoms</span></h2>
			<p><span class="koboSpan" id="kobo.1272.1">To organize state mutation code, we often create a function or a set of functions. </span><span class="koboSpan" id="kobo.1272.2">We can use </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.1273.1">atoms for that purpose and call them action atoms.</span></p>
			<p><span class="koboSpan" id="kobo.1274.1">To create action atoms, we only use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">write</span></strong><span class="koboSpan" id="kobo.1276.1"> function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">atom</span></strong><span class="koboSpan" id="kobo.1278.1"> function's second argument. </span><span class="koboSpan" id="kobo.1278.2">The first argument can be anything, but we often use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">null</span></strong><span class="koboSpan" id="kobo.1280.1"> as a convention.</span></p>
			<p><span class="koboSpan" id="kobo.1281.1">Let's look at an example. </span><span class="koboSpan" id="kobo.1281.2">We have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">countAtom</span></strong><span class="koboSpan" id="kobo.1283.1"> as usual and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">incrementCountAtom</span></strong><span class="koboSpan" id="kobo.1285.1">, which is an action atom, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1286.1">const countAtom = count(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1287.1">const incrementCountAtom(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1288.1">  null,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1289.1">  (get, set, arg) =&gt; set(countAtom, (c) =&gt; c + 1)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1290.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1291.1">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">write</span></strong><span class="koboSpan" id="kobo.1293.1"> function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">incrementCountAtom</span></strong><span class="koboSpan" id="kobo.1295.1"> only uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">set</span></strong><span class="koboSpan" id="kobo.1297.1">, out of three arguments.</span></p>
			<p><span class="koboSpan" id="kobo.1298.1">We can </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.1299.1">use this atom like normal atoms, and just ignore its value. </span><span class="koboSpan" id="kobo.1299.2">For example, here is a component to show a button to increment the count:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1300.1">const IncrementButton = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1301.1">  const [, incrementCount] = useAtom(incrementCountAtom);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1302.1">  return &lt;button onClick={incrementCount}&gt;Click&lt;/button&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1303.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1304.1">This is a simple case without an argument. </span><span class="koboSpan" id="kobo.1304.2">You could accept an argument and you could create as many action atoms as you want.</span></p>
			<p><span class="koboSpan" id="kobo.1305.1">Next, we will see a less commonly used but important feature.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.1306.1">Understanding the onMount option of atoms</span></h2>
			<p><span class="koboSpan" id="kobo.1307.1">In some use cases, we want to run certain logic once an atom starts to be used. </span><span class="koboSpan" id="kobo.1307.2">A good example </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.1308.1">is to subscribe to an external data source. </span><span class="koboSpan" id="kobo.1308.2">This can be done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">useEffect</span></strong><span class="koboSpan" id="kobo.1310.1"> hook, but to define logic at the atom level, Jotai atoms have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">onMount</span></strong><span class="koboSpan" id="kobo.1312.1"> option.</span></p>
			<p><span class="koboSpan" id="kobo.1313.1">To understand how it is used, let's create an atom that shows a login message on mount and unmount, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1314.1">const countAtom = atom(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1315.1">countAtom.onMount = (setCount) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1316.1">  console.log("count atom starts to be used");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1317.1">  const onUnmount = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1318.1">    console.log("count atom ends to be used");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1319.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1320.1">  return onUnmount;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1321.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1322.1">The body </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.1323.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">onMount</span></strong><span class="koboSpan" id="kobo.1325.1"> function is showing a logging message about the start of use. </span><span class="koboSpan" id="kobo.1325.2">It also returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">onUnmount</span></strong><span class="koboSpan" id="kobo.1327.1"> function, which shows a logging message about the end of use. </span><span class="koboSpan" id="kobo.1327.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">onMount</span></strong><span class="koboSpan" id="kobo.1329.1"> function takes an argument, which is a function to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">countAtom</span></strong><span class="koboSpan" id="kobo.1331.1">.</span></p>
			<p><span class="koboSpan" id="kobo.1332.1">This is a contrived example, but there are many real use cases to connect external data sources.</span></p>
			<p><span class="koboSpan" id="kobo.1333.1">Next, we'll talk about utility functions.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.1334.1">Introducing the jotai/utils bundle</span></h2>
			<p><span class="koboSpan" id="kobo.1335.1">The Jotai library provides two basic functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">atom</span></strong><span class="koboSpan" id="kobo.1337.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">useAtom</span></strong><span class="koboSpan" id="kobo.1339.1">, and an additional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">Provider</span></strong><span class="koboSpan" id="kobo.1341.1"> component in the main bundle. </span><span class="koboSpan" id="kobo.1341.2">While the small API is good to understand the basic features, we want some utility functions to help development.</span></p>
			<p><span class="koboSpan" id="kobo.1342.1">Jotai provides </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.1343.1">a separate bundle named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">jotai/utils</span></strong><span class="koboSpan" id="kobo.1345.1"> that contains a variety of utility functions. </span><span class="koboSpan" id="kobo.1345.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">atomWithStorage</span></strong><span class="koboSpan" id="kobo.1347.1"> is a function to create atoms with a specific feature—that is, to synchronize with persistent storage. </span><span class="koboSpan" id="kobo.1347.2">For more information and other utility functions, refer to the project site at </span><a href="https://github.com/pmndrs/jotai"><span class="koboSpan" id="kobo.1348.1">https://github.com/pmndrs/jotai</span></a><span class="koboSpan" id="kobo.1349.1">.</span></p>
			<p><span class="koboSpan" id="kobo.1350.1">Next, we will discuss how the Jotai library can be used in other libraries.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1351.1">Understanding library usage</span></h2>
			<p><span class="koboSpan" id="kobo.1352.1">Suppose two </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.1353.1">libraries use the Jotai library internally. </span><span class="koboSpan" id="kobo.1353.2">If we develop an app that uses the two libraries, there's an issue of double providers. </span><span class="koboSpan" id="kobo.1353.3">Because Jotai atoms are distinguished by reference, it is possible that the atoms in the first library accidentally connect to the provider in the second library. </span><span class="koboSpan" id="kobo.1353.4">As a result, it may not work as expected by the library authors. </span><span class="koboSpan" id="kobo.1353.5">The Jotai library provides a notion of "scope", which is the way to connect to a specific provider. </span><span class="koboSpan" id="kobo.1353.6">To make it work as expected, we should pass the same scope variable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">Provider</span></strong><span class="koboSpan" id="kobo.1355.1"> component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">useAtom</span></strong><span class="koboSpan" id="kobo.1357.1"> hook.</span></p>
			<p><span class="koboSpan" id="kobo.1358.1">Implementation-wise, this is how Context works. </span><span class="koboSpan" id="kobo.1358.2">The scope feature is just used to put back the </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.1359.1">Context feature. </span><span class="koboSpan" id="kobo.1359.2">It's still under exploration how this feature can be used for other purposes. </span><span class="koboSpan" id="kobo.1359.3">We, as a community, will work on more use cases with this feature.</span></p>
			<p><span class="koboSpan" id="kobo.1360.1">Finally, we'll see some advanced features in the Jotai library.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1361.1">Introduction to more advanced features</span></h2>
			<p><span class="koboSpan" id="kobo.1362.1">There are more advanced features that we didn't cover in this book.</span></p>
			<p><span class="koboSpan" id="kobo.1363.1">Most notably, Jotai supports the React Suspense feature. </span><span class="koboSpan" id="kobo.1363.2">When a derived atom's </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">read</span></strong><span class="koboSpan" id="kobo.1365.1"> function returns </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.1366.1">a promise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">useAtom</span></strong><span class="koboSpan" id="kobo.1368.1"> hook will suspend, and React will show a fallback. </span><span class="koboSpan" id="kobo.1368.2">This feature is experimental and subject to change, but it's a very important feature to explore.</span></p>
			<p><span class="koboSpan" id="kobo.1369.1">Another note is about library integrations. </span><span class="koboSpan" id="kobo.1369.2">Jotai is a library to solve a single problem with the atomic model, which is to avoid extra re-renders. </span><span class="koboSpan" id="kobo.1369.3">By integrating with other libraries, the use case expands. </span><span class="koboSpan" id="kobo.1369.4">The atomic model is flexible to integrate with other libraries, and especially, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">onMount</span></strong><span class="koboSpan" id="kobo.1371.1"> option is necessary for external data sources.</span></p>
			<p><span class="koboSpan" id="kobo.1372.1">To learn more about these advanced features, refer to the project site: </span></p>
			<p><a href="https://github.com/pmndrs/jotai"><span class="koboSpan" id="kobo.1373.1">https://github.com/pmndrs/jotai</span></a></p>
			<p><span class="koboSpan" id="kobo.1374.1">In this section, we discussed some additional features that the Jotai library provides. </span><span class="koboSpan" id="kobo.1374.2">Jotai is a primitive library to provide building blocks, yet is flexible enough to cover real use cases.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1375.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.1376.1">In this chapter, we learned about a library called Jotai. </span><span class="koboSpan" id="kobo.1376.2">It's based on the atomic model and Context. </span><span class="koboSpan" id="kobo.1376.3">We've seen simple examples to learn its basics, yet they show the flexibility of the atomic model. </span><span class="koboSpan" id="kobo.1376.4">The combination of Context and Subscription is the only way to have a React-oriented global state. </span><span class="koboSpan" id="kobo.1376.5">If your requirement is Context without extra re-renders, this approach should be your choice.</span></p>
			<p><span class="koboSpan" id="kobo.1377.1">In the next chapter, we will learn about another library, called Valtio, which is a library primarily for module state, with a unique syntax.</span></p>
		</div>
	</body></html>