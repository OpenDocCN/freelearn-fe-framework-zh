<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor236"/>7</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor237"/>Handling Gestures in React Native</h1>
			<p>One of the most important things that makes good apps stand out against bad apps or mobile websites is good gesture handling. While mobile websites only listen to simple clicks in most cases, apps can and should be controlled with different gestures such as short touches, long touches, swipes, pinching to zoom, or touches with multiple fingers. Using these gestures in a very intuitive way is one of the most important things to consider when developing an app. </p>
			<p>But it doesn’t stop with just listening to these gestures – you have to give an immediate response to the user so that they can see (and maybe abort) what they are doing. Some gestures need to trigger or control animations and therefore have to play together very well with the animation solutions we learned about in <a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations</em>.</p>
			<p>In React Native, there are multiple ways to handle gestures. From simple built-in components to very complex third-party gesture handling solutions, you have a lot of different options to choose from. </p>
			<p>In this chapter, you will learn about the following:</p>
			<ul>
				<li>Using built-in components to respond to user gestures</li>
				<li>Working with <a id="_idTextAnchor238"/>the R<a id="_idTextAnchor239"/>eact Native gesture responder system and React Native <strong class="source-inline">PanResponder</strong></li>
				<li><a id="_idTextAnchor240"/>U<a id="_idTextAnchor241"/>nderstanding React Native Gesture Handler</li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor242"/>Technical requirements</h1>
			<p>To be able to run the code in this chapter, you have to set up the following things: </p>
			<ul>
				<li>A working React Native environment (<a href="http://bit.ly/prn-setup-rn">bit.ly/prn-setup-rn</a> – React Native CLI Quickstart) </li>
				<li>A real iOS or Android device for testing gestures and multitouch</li>
			</ul>
			<p>To access the code for this chapter, follow this link to the book’s GitHub repository:</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor243"/>Using built-in components to respond to user gestures</h1>
			<p>React Native ships with multiple <a id="_idIndexMarker462"/>components that have built-in gesture responder support. Basically, these components are an abstracted use of the gesture responder system, which you will learn about in the next section. The gesture responder system provides support for handling gestures in React Native, as well as support for negotiating which component should handle the user gesture.</p>
			<p>The simplest user interaction is a tap with one finger. With different <strong class="source-inline">Touchable</strong> components, a <strong class="source-inline">Pressable</strong> component, and a <strong class="source-inline">Button</strong> component, React Native provides different options for how to recognize the tap and respond to the user interaction. </p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor244"/>Using components to respond to simple taps</h2>
			<p>The simplest components to<a id="_idIndexMarker463"/> record user taps are the React Native <strong class="source-inline">Touchable</strong> components.</p>
			<h3>Working with Touchable components</h3>
			<p>React Native provides three<a id="_idIndexMarker464"/> different <strong class="source-inline">Touchable</strong> components on iOS and an extra fourth <strong class="source-inline">Touchable</strong> component just for Android:</p>
			<ul>
				<li><strong class="source-inline">TouchableOpacit<a id="_idTextAnchor245"/>y<a id="_idTextAnchor246"/></strong>: Provides user feedback automatically by reducing the opacity of the tapped element (and all child elements), letting the underlying view shine through. You can configure the opacity reduction by setting <strong class="source-inline">activeOpacity</strong>.</li>
				<li><strong class="source-inline">TouchableHighlight</strong>: Provides user feedback automatically by reducing the opacity and showing an underlying color, which darkens or lightens the tapped element. You can define the underlying color by setting <strong class="source-inline">underlayColor</strong> and the opacity reduction by setting <strong class="source-inline">activeOpacit<a id="_idTextAnchor247"/>y<a id="_idTextAnchor248"/></strong>.</li>
				<li><strong class="source-inline">TouchableWithoutFeedback</strong>: Provides no user feedback. You should only use this if you have a good reason since every element that responds to touches should show visual feedback. One reason could be that you handle the visual feedback somewhere else.</li>
				<li><strong class="source-inline">TouchableNativeFeedback</strong>: For Android only. Provides user feedback automatically by triggering the native Android touch effect. On most devices, this is the well-known Android <a id="_idIndexMarker465"/>ripple effect, where the component changes the color by growing a circle from the point of touch. You can define the ripple effect by setting the <strong class="source-inline">background</strong> property.</li>
			</ul>
			<p>All four <strong class="source-inline">Touchable</strong> components provide four methods to listen to user interaction. These methods are called in the order of the following figure:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B16694_07_01.jpg" alt="Figure 7.1 – The onPress call order&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The onPress call order</p>
			<p>The important thing to always keep in mind is that <strong class="source-inline">onPress</strong> is called after <strong class="source-inline">onPressOut</strong>, while <strong class="source-inline">onLongPress</strong> is called before <strong class="source-inline">onPressOut</strong>. Let’s have a look at the methods in more detail: </p>
			<ul>
				<li><strong class="source-inline">onPressIn</strong>: The method is called immediately when the user starts tapping the button.</li>
				<li><strong class="source-inline">onPressOut</strong>: The method is called when the user releases the tap or when the user moves the finger outside of the component.</li>
				<li><strong class="source-inline">onPress</strong>: The method is called when the user completes the tap before a long press delay (defined in <strong class="source-inline">delayLongPress</strong>) is reached.</li>
				<li><strong class="source-inline">onLongPress</strong>: The method is called when the long press delay (defined in <strong class="source-inline">delayLongPress</strong>) is reached and the tap wasn’t released in the meantime.</li>
			</ul>
			<p>With these methods, you<a id="_idIndexMarker466"/> can already handle a lot of different use cases and – never forget – give immediate visual feedback to user touches. </p>
			<p>While the <strong class="source-inline">Touchable</strong> components need some own styling, React Native also provides a <strong class="source-inline">Button</strong> component, which comes with predefined styles.</p>
			<h3>Working with the Button component</h3>
			<p>Under the<a id="_idIndexMarker467"/> hood, <strong class="source-inline">Button</strong> uses <strong class="source-inline">TouchableOpacity</strong> on iOS and <strong class="source-inline">TouchableNativeFeedback </strong>on Android. <strong class="source-inline">Button</strong> comes with some predefined styling so that you can use it without styling it on your own. The following code example shows how simple it is to use <strong class="source-inline">But<a id="_idTextAnchor249"/>t<a id="_idTextAnchor250"/>on</strong>:</p>
			<pre class="source-code">
&lt;Button
  onPress={() =&gt; Alert.alert("Button pressed!")}
      title="Press me!"
      col<a id="_idTextAnchor251"/>o<a id="_idTextAnchor252"/>r="#f7941e"
/&gt;</pre>
			<p>You only have to define an <strong class="source-inline">onPress</strong> method, a button <strong class="source-inline">title</strong>, and the <strong class="source-inline">color</strong> of the button. <strong class="source-inline">Button</strong> then handles the rest such as styling and visual user feedback. Of course, you can use all other methods of the <strong class="source-inline">Touchable</strong> components, too.</p>
			<p><strong class="source-inline">Button</strong> and <strong class="source-inline">Touchable</strong> are quite old components in React Native. Since they work well, you can use them in <a id="_idIndexMarker468"/>most cases. But there is also a new implementation for handling user taps.</p>
			<h3>Working with the Pressable component</h3>
			<p>Besides the <strong class="source-inline">Touchable</strong> and <strong class="source-inline">Button</strong> components, React Native also comes with a <strong class="source-inline">Pressable</strong> component. This <a id="_idIndexMarker469"/>is the latest component and is recommended to be used due to its advanced support for platform-specific visual feedback. </p>
			<p>Have a look at the following code example to understand the advantages of <strong class="source-inline">Pressable</strong>:</p>
			<pre class="source-code">
&lt;Pressable
  onPress={() =&gt; Alert.alert("Button pressed!")}
  style={({ pressed }) =&gt; [
    {
      backgroundColor: pressed
        ? '#f7941e'
        : '#ffffff'
    },
    styles.button
  }&gt;
&gt;
  {
    ({ pressed }) =&gt; (
      &lt;Text style={styles.buttonText}&gt;
        {pressed ? 'Button pressed!' : 'Press  me!'}
      &lt;/Text&gt;
    )
  }
&lt;/Pressable&gt;</pre>
			<p>It provides the same methods as the <strong class="source-inline">Touchable</strong> components, but it also has ripple support on Android and works with custom styling on iOS. You can provide the <strong class="source-inline">style</strong> property as a function and listen to the <strong class="source-inline">pressed</strong> state.</p>
			<p>You can also pass a<a id="_idIndexMarker470"/> functional component as a child to the <strong class="source-inline">Pressable</strong> component and use the <strong class="source-inline">pressed</strong> state there. This means you can change the styling and content of the <strong class="source-inline">Pressable</strong> component based on whether it is pressed at the moment or not. </p>
			<p>Another advantage is that you can define hit and offset areas for the <strong class="source-inline">Pressable</strong> component:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B16694_07_02.jpg" alt="Figure 7.2 – Pressable Hit and Press Areas&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Pressable Hit and Press Areas</p>
			<p>In <em class="italic">Figure 7.2</em>, you can see the visible <strong class="source-inline">Pressable</strong> component in the center. If you want the touchable area to be larger than the visible element, you can do this by setting <strong class="source-inline">hitSlop</strong>. This is a very common thing to do for important buttons or important tappable areas of the screen.</p>
			<p>While <strong class="source-inline">hitSlop</strong> defines the area where the tap starts, <strong class="source-inline">pressRetentionOffset</strong> defines the additional distance outside of the <strong class="source-inline">Pressable</strong> component where the tap does not stop. This means when you start a tap inside the Hit Area and move your finger outside of the Hit Area, normally <strong class="source-inline">onPressOut</strong> is fired and the tap gesture is completed.</p>
			<p>But if you have defined an additional Press Area and your gesture stays inside this Press Area, the tap gesture is considered a lasting gesture as long as your finger moves outside this Press Area. <strong class="source-inline">hitSlop</strong> and <strong class="source-inline">pressRetention</strong> can either be set as a <strong class="source-inline">number</strong> value or as a <strong class="source-inline">Rect</strong> value, which means as an <strong class="source-inline">Object</strong> with <strong class="source-inline">bottom</strong>, <strong class="source-inline">left</strong>, <strong class="source-inline">right</strong>, and <strong class="source-inline">top</strong> properties.</p>
			<p>Hit Area and <a id="_idIndexMarker471"/>Press Area are both great methods to improve the user experience of your app as, for example, they can make it easier for users to press important buttons.</p>
			<p>After looking at simple tap handling, let’s continue with scroll gestures.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor253"/>Working with ScrollView</h2>
			<p>The simplest method to handle scroll gestures is React Native <strong class="source-inline">ScrollView</strong>. This component makes the content inside of it<a id="_idIndexMarker472"/> scrollable if the content is larger than <strong class="source-inline">ScrollView</strong> itself. <strong class="source-inline">ScrollView</strong> detects and handles scroll gestures automatically. It has a lot of options you can configure, so let’s have a look at the most important ones:</p>
			<ul>
				<li><strong class="source-inline">horizontal</strong>: Defines whether <strong class="source-inline">ScrollView</strong> should be horizontal or vertical. The default is vertical.</li>
				<li><strong class="source-inline">decelerationRate</strong>: Defines how fast the scrolling will decelerate when the user releases the touch while scrolling.</li>
				<li><strong class="source-inline">snapToInterval</strong> or <strong class="source-inline">snapToOffsets</strong>: With these two methods, you can define intervals or offsets at which <strong class="source-inline">ScrollView</strong> should stop. This can improve the user experience a lot because the scroll view can, for example, always stop so that the user can see a complete list element.</li>
				<li><strong class="source-inline">scrollEventThrottle</strong> for iOS only: Defines how often a scroll event will be triggered while scrolling. This is very important for performance and UX reasons. The best value for UX is 16, which means the scroll event is fired every 16 ms (until RN supports 120 Hz – then, it will become 8 ms).</li>
			</ul>
			<p>Based on what you are doing with the scroll event, this can lead to performance problems because the scroll event is sent over the bridge every single time (unless you process it directly via the Animated API, as desc<a id="_idTextAnchor254"/>r<a id="_idTextAnchor255"/>ibed in <a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations</em>). So, think about what value you need here and perhaps<a id="_idIndexMarker473"/> increase it to prevent performance problems.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There are a lot more configuration options such as defining over-scroll effects, sticky headers, or bounces. If you want to have a complete overview, please have a look at the documentation (<a href="https://bit.ly/prn-scrollview">https://bit.ly/prn-scrollview</a>). Since this is not a beginner’s guide, we are focusing on the parts that are important to optimize your application. </p>
			<p>Speaking of which, you can of course handle the scroll events by yourself when using the <strong class="source-inline">ScrollView</strong> component. This gi<a id="_idTextAnchor256"/>v<a id="_idTextAnchor257"/>es you a variety of options on how to optimize your UX. <strong class="source-inline">ScrollView</strong> provides the following methods: </p>
			<ul>
				<li><strong class="source-inline">onScro<a id="_idTextAnchor258"/>l<a id="_idTextAnchor259"/>l</strong>: Fires continuously during scrolling. This is a great tool to add awesome user feedback to the scroll gesture by coupling custom animations to the scroll event, as we did in <a href="B16694_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Animations</em>. But when doing so, you should either work with the Animated API with the native driver to prevent the scroll events from being transferred over the bridge every 16 ms or use <strong class="source-inline">scrollEventThrottle</strong> to limit the event count.</li>
				<li><strong class="source-inline">onScrollBeginDrag</strong>: Fires when the user starts the scrolling gesture.</li>
				<li><strong class="source-inline">onScrollEndDrag</strong>: Fires when the user stops the scrolling gesture.</li>
				<li><strong class="source-inline">onMomentumScrollBegin</strong>: Fires when <strong class="source-inline">ScrollView</strong> starts moving.</li>
				<li><strong class="source-inline">onMomentumScrollEnd</strong>: Fires when <strong class="source-inline">ScrollView</strong> stops moving.</li>
			</ul>
			<p>With these five methods, you can give your users a lot of different feedback for a scroll gesture. From simply informing the user when they are scrolling to building advanced animations with <strong class="source-inline">onScroll</strong>, everything is possible.</p>
			<p class="callout-heading">Notice</p>
			<p class="callout"><strong class="source-inline">ScrollView</strong> can become quite slow and memory hungry when it has a very long list of elements as children. This is due to <strong class="source-inline">ScrollView</strong> rendering all children at once. If you need a more performant version with lazy loading of elements, please have a look at React Native <strong class="source-inline">FlatList</strong> or <strong class="source-inline">SectionList</strong>.</p>
			<p>After working with the <a id="_idIndexMarker474"/>built-in React Native components, it’s time to have a look at handling touches completely by yourself. The first option to do that is to work directly with the React Native gesture respond<a id="_idTextAnchor260"/>e<a id="_idTextAnchor261"/>r system.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor262"/>Working with the gesture responder system and PanResponder</h1>
			<p>The gesture responder system is the<a id="_idIndexMarker475"/> foundation of handling gestures in React Native. All the <strong class="source-inline">Touchable</strong> components are based on the gesture responder system. With this system, you can not only listen to gestures but you can also specify which component should be the touch responder.</p>
			<p>This is very important because there are several scenarios in which you have multiple touch responders on your screen (for example, <strong class="source-inline">Slider</strong> in a <strong class="source-inline">ScrollView</strong>). While most of the built-in components negotiate which component should become a touch responder and should handle the user input on their own, you have to think about it yourself when working directly with the gesture responder system. </p>
			<p>The gesture responder system provides a simple API and can be used on any component. The first thing you have to do when working with the gesture responder system is to negotiate which component should become the responder to handle the gesture.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor263"/>Becoming a responder</h2>
			<p>To become a responder, a component <a id="_idIndexMarker476"/>must implement one of these negotiation methods:</p>
			<ul>
				<li><strong class="source-inline">onStartShouldSetResponder</strong>: If this method returns <strong class="source-inline">true</strong>, the component wants to become the responder at the start of a touch event.</li>
				<li><strong class="source-inline">onMoveShouldSetResponder</strong>: If this method returns <strong class="source-inline">true</strong>, the component wants to become the responder of a touch event. This method is called for every touch move event, as long as the component is not the responder.</li>
			</ul>
			<p class="callout-heading">Important tip</p>
			<p class="callout">These two methods are called on the deepest node first. This means that the deepest component will become the responder to the touch event when multiple components implement these methods and return <strong class="source-inline">true</strong>. Please keep that in mind when manually negotiating the responders.</p>
			<p class="callout">You can prevent a child component from becoming the responder by implementing <strong class="source-inline">onStartShouldSetResponderCapture</strong> or <strong class="source-inline">onMoveShouldSetResponderCapture</strong>. </p>
			<p>For these responder<a id="_idIndexMarker477"/> negotiations, it is important for a component to release control if another component asks for it. The gesture responder system also provides handlers for this:</p>
			<ul>
				<li><strong class="source-inline">onResponderTerminationRequest</strong>: If this handler returns <strong class="source-inline">true</strong>, the component releases the responder when another component wants to become the responder. </li>
				<li><strong class="source-inline">onResponseTerminate</strong>: This handler is called when the responder was released. This can be due to <strong class="source-inline">onResponderTerminationRequest</strong> returning <strong class="source-inline">true</strong> or due to OS behavior.</li>
			</ul>
			<p>When a component tries to become the responder, there are two possible outcomes from the negotiation, which can both be handled with a handler method:</p>
			<ul>
				<li><strong class="source-inline">onResponderGrant</strong>: This handler is called when it successfully became the responder and will then listen to touch events. It is best practice to use this method to highlight the component so that the user can see the element that responds to their touches. </li>
				<li><strong class="source-inline">onResponderReject</strong>: This handler is called when another component is currently the responder and will not release control.</li>
			</ul>
			<p>When your component successfully becomes the responder, you can use handlers to listen to the touch events.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor264"/>Handling touches</h2>
			<p>After becoming the responder, there are two handlers you can use to capture the touch events:</p>
			<ul>
				<li><strong class="source-inline">onResponderMove</strong>: This handler is <a id="_idIndexMarker478"/>called when the user moves their finger on the screen. </li>
				<li><strong class="source-inline">onResponderRelease</strong>: This handler is called when the user releases their touch from the device’s screen.</li>
			</ul>
			<p>When working with gestures, you normally use <strong class="source-inline">onResponderMove</strong> and process the position values of the event it returns. When concatenating the positions, you can recreate the path the user draws on the screen. You can then respond to this path in the way you want. </p>
			<p>How this works in practice is shown in the following example:</p>
			<pre class="source-code">
const CIRCLE_SIZE = 50;
export default (props) =&gt; {
  const dimensions = useWindowDimensions();
  const touch = useRef(
    new Animated.ValueXY({ 
      x: dimensions.width / 2 - CIRCLE_SIZE / 2, 
      y: dimensions.height / 2 - CIRCLE_SIZE / 2
      })).current;
  return (
    &lt;View style={{ flex: 1 }}
        onStartShouldSetResponder={() =&gt; true}
        onResponderMove={(event) =&gt; {
          touch.setValue({
            x: event.nativeEvent.pageX, y: event.nativeEvent.pageY
          });
        }}
        onResponderRelease={() =&gt; {
          Animated.spring(touch, {
            toValue: {
              x: dimensions.width / 2 - CIRCLE_SIZE / 2,
              y: dimensions.height / 2 - CIRCLE_SIZE / 2
            },
            useNativeDriver: false
          }).start();
        }}
    &gt;
      &lt;Animated.View
        style={{
          position: 'absolute', backgroundColor: 'blue',
              left: touch.x, top: touch.y,
              height: CIRCLE_SIZE, width: CIRCLE_SIZE,
              borderRadius: CIRCLE_SIZE / 2,
        }}
        onStartShouldSetResponder={() =&gt; false}
      /&gt;
    &lt;/View&gt;
  );
};</pre>
			<p>This example contains two <strong class="source-inline">View</strong>. The outer <strong class="source-inline">View</strong> serves as the touch responder, while the inner <strong class="source-inline">View</strong> is a small circle, which changes position based on where the user moves the finger. The outer <strong class="source-inline">View</strong> implements the gesture responder system handlers, while the inner <strong class="source-inline">View</strong> just<a id="_idIndexMarker479"/> returns <strong class="source-inline">false</strong> for <strong class="source-inline">onStartShouldSetResponder</strong>, to not become the responder. </p>
			<p>You also can see how the gesture responder system works with React Native Animated. When <strong class="source-inline">onResponerMove</strong> is called, we process the touch event and set the <strong class="source-inline">pageX</strong> and <strong class="source-inline">pageY</strong> values of the event to an <strong class="source-inline">Animated.ValueXY</strong>.</p>
			<p>This is the value we then use to calculate the position of the inner <strong class="source-inline">View</strong>. When the user removes the finger from the device, <strong class="source-inline">onResponderRelease</strong> is called and we use an <strong class="source-inline">Animated.spring</strong> function to revert the <strong class="source-inline">Animated.ValueXY</strong> value back to its starting value. This positions the inner <strong class="source-inline">View</strong> back in the middle of the screen. </p>
			<p>The following image shows how the code from the example looks on the screen:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B16694_07_03.jpg" alt="Figure 7.3 – An example of the gesture responder system running on an iPhone&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – An example of the gesture responder system running on an iPhone</p>
			<p>Here, you can see the starting state (the left-hand screen). Then, the user touches the bottom right of the screen and the blue circle follows the touch (mid-screen). After the user releases the touch, the blue circle returns to the center of the screen from the position where the user last touched the screen over a given time period (the right-hand screen shows the circle during the return animation). </p>
			<p>Even with this simple example, you can see that the gesture responder system is a very powerful tool. You have full control over the touch events and can combine them with animations very easily. Nevertheless, most <a id="_idIndexMarker480"/>of the time, you won’t use the gesture responder system directly. This is because of <strong class="source-inline">PanResponder</strong>, which is a lightweight layer on top of the gesture responder system.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor265"/>Using PanResponder</h2>
			<p><strong class="source-inline">PanResponder</strong> basically works<a id="_idIndexMarker481"/> exactly as the gesture responder system does. It provides a similar API; however, you just have to replace <strong class="source-inline">Responder</strong> with <strong class="source-inline">PanResponder</strong>. For example, <strong class="source-inline">onResponderMove</strong> becomes <strong class="source-inline">onPanResponderMove</strong>. The difference is that you don’t just get the raw touch events. <strong class="source-inline">PanResponder</strong> also provides a state object, which represents the state of the whole gesture. This includes the following properties: </p>
			<ul>
				<li><strong class="source-inline">stateID</strong>: A unique identifier of the gesture</li>
				<li><strong class="source-inline">dx</strong>: The horizontal distance since the start of the touch gesture</li>
				<li><strong class="source-inline">dy</strong>: The vertical distance since the start of the touch gesture</li>
				<li><strong class="source-inline">vx</strong>: The current horizontal velocity of the touch gesture</li>
				<li><strong class="source-inline">vy</strong>: The current vertical velocity of the touch gesture</li>
			</ul>
			<p>This state object can be very useful when it comes to interpreting and processing more complex gestures. Due to this, most libraries and projects use <strong class="source-inline">PanResponder</strong> instead of working directly with the gesture responder system.</p>
			<p>While the gesture responder system and <strong class="source-inline">PanResponder</strong> are very good options to respond to user touches, they also come with some downsides. First of all, they have the same limitations as the Animated API without the native driver. Since the touch events have to be transferred via the bridge to the JavaScript thread, we always are one frame behind.</p>
			<p>This may become better with the JSI, but this has to be proven at this point. Another limitation is that no API allows us to define any interaction between the native gesture handlers. This means there will always be cases, which are not solvable with the gesture responder system API. </p>
			<p>Because of these limitations, the team at Software Mansion with the support of Shopify and Expo built a new<a id="_idIndexMarker482"/> solution – React Native Gesture Handler.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor266"/>Understanding React Native Gesture Handler</h1>
			<p>React Native Gesture Handler is a third-party library<a id="_idIndexMarker483"/> that completely replaces the built-in gesture responder system while offering more control and higher performance. </p>
			<p>React Native Gesture Handler works best in combination with Reanimated 2 because it was written by the same team and relies on the worklets provided by Reanimated 2. </p>
			<p class="callout-heading">Information</p>
			<p class="callout">This book refers to React Native Gesture Handler version 2.0. Version 1 is also used in a lot of projects.</p>
			<p>The React Native Gesture Handler 2 API is based on <strong class="source-inline">GestureDetectors</strong> and <strong class="source-inline">Gestures</strong>. While it does also support the API from version 1, I would recommend using the new API, as it is easier to read and understand. </p>
			<p>Let’s create the draggable circle example from the previous section, but this time we use React Native Gesture Handler and Reanimated 2:</p>
			<pre class="source-code">
const CIRCLE_SIZE = 50;
export default props =&gt; {
  const dimensions = useWindowDimensions();
  const touchX = useSharedValue(dimensions.width/
      2-CIRCLE_SIZE/2);
  const touchY = useSharedValue(dimensions.height/
      2-CIRCLE_SIZE/2);
  const animatedStyles = useAnimatedStyle(() =&gt; {
    return {
      left: touchX.value, top: touchY.value,
    };
  });
  const gesture = Gesture.Pan()
   .onUpdate(e =&gt; {
    touchX.value = e.translationX+dimensions.width/
        2-CIRCLE_SIZE/2;
    touchY.value = e.translationY+dimensions.height/
        2-CIRCLE_SIZE/2;
   })
   .onEnd(() =&gt; {
    touchX.value = withSpring(dimensions.width/
        2-CIRCLE_SIZE/2);
    touchY.value = withSpring(dimensions.height/
        2-CIRCLE_SIZE/2);
   });
  return (
    &lt;GestureDetector gesture={gesture}&gt;
      &lt;Animated.View
        style={[
          { 
            position: 'absolute', backgroundColor: 'blue',
                width: CIRCLE_SIZE, height: CIRCLE_SIZE,
                borderRadius: CIRCLE_SIZE / 2 
          },
          animatedStyles,
        ]}
      /&gt;
    &lt;/GestureDetector&gt;
  );
};</pre>
			<p>In this example, you can see how React Native Gesture Handler works. We create <strong class="source-inline">GestureDetector</strong> and<a id="_idIndexMarker484"/> wrap it with the element representing the target of the touch gesture. Then, we create a <strong class="source-inline">Gesture</strong> and assign it to <strong class="source-inline">GestureDetector</strong>. In this example, this is a <strong class="source-inline">Pan</strong> gesture, which means it recognizes dragging on the screen. <strong class="source-inline">Gesture.Pan</strong> provides a lot of different handlers. In this example, we use two: </p>
			<ul>
				<li><strong class="source-inline">onUpdate</strong>: This handler is called every time any position of the gesture updates</li>
				<li><strong class="source-inline">onEnd</strong>: This handler is called when the gesture is released</li>
			</ul>
			<p>We use <strong class="source-inline">onUpdate</strong> to change the value of our Reanimated <strong class="source-inline">sharedValue</strong> and <strong class="source-inline">onEnd</strong> to reset the <strong class="source-inline">sharedValue</strong> to the initial state. </p>
			<p>We then use the <strong class="source-inline">sharedValue</strong> to create <strong class="source-inline">animatedStyle</strong>, which we assign to our <strong class="source-inline">Animated.View</strong>, which is our circle.</p>
			<p>The outcome on the screen is the same as in the previous section, but we have two important advantages here: </p>
			<ul>
				<li><strong class="bold">Better performance</strong>: Since we use Reanimated 2 worklets, our values and our calculation don’t have to pass<a id="_idIndexMarker485"/> the bridge. The gesture input and the animation are completely calculated on the UI thread.</li>
				<li><strong class="bold">More options</strong>: When we want to have more complex gesture handling, React Native Gesture Handler gives us a lot more opportunities compared to the built-in gesture responder system. For example, we can define relations between gestures and decide whether only one gesture can become active at a time (<strong class="source-inline">Race</strong>) or whether multiple gestures can become active at a time (<strong class="source-inline">Simultaneous</strong>). </li>
			</ul>
			<p>In addition to that, React Native Gesture Handler ships with a lot of different gestures, such as <strong class="source-inline">Tap</strong>, <strong class="source-inline">Rotation</strong>, <strong class="source-inline">Pinch</strong>, <strong class="source-inline">Fling</strong>, or <strong class="source-inline">ForceTouch</strong>, as well as built-in components such as <strong class="source-inline">Button</strong>, <strong class="source-inline">Swipeable</strong>, <strong class="source-inline">Touchable</strong>, or <strong class="source-inline">DrawerLayout</strong>, which makes it a very good<a id="_idIndexMarker486"/> replacement for the built-in gesture responder system.</p>
			<p>If you want to get a deeper understanding of all the possible options you have with React Native Gesture Handler, please have a look at the documentation: <a href="http://bit.ly/prn-gesture-handler">bit.ly/prn-gesture-handler</a>.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor267"/>Summary</h1>
			<p>In this chapter, we learned about React Native’s built-in components and solutions to handle user gestures. From simple gestures such as single taps to more complex gestures, React Native provides stable solutions to handle gestures. We also had a look at React Native Gesture Handler, which is a great third-party replacement for these built-in solutions. </p>
			<p>I would recommend using React Native’s built-in components and solutions for all use cases where you can stick to the standard components. As soon as you start writing your own gesture handling, I would recommend using React Native Gesture Handler.</p>
			<p>After Animations and Gesture Handling, we will proceed with another topic, which is very important in terms of performance.</p>
			<p>In the next chapter, you will learn what different JavaScript engines are, what options you have in React Native, and what impact the different engines have on performance and other important key metrics.</p>
		</div>
	</body></html>