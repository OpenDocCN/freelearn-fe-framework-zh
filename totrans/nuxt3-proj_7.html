<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer086">
			<h1 id="_idParaDest-142" class="chapter-number"><a id="_idTextAnchor141"/>7</h1>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Building a Quiz Game Application to Learn about Testing</h1>
			<p>In this chapter, we will continue our journey and build a quiz game application using Nuxt 3, with a deep focus on enhancing our testing skills. This chapter is crafted for developers aiming to refine <a id="_idIndexMarker387"/>their skills in unit testing and <strong class="bold">End-to-End</strong> (<span class="No-Break"><strong class="bold">E2E</strong></span><span class="No-Break">) testing.</span></p>
			<p>Initially, we’ll talk about the importance of testing in software development, illustrating how it serves as the backbone of any application. We’ll kick off with unit testing, where you’ll learn how to construct unit tests for both the Pinia store and Vue components, ensuring each piece of logic and every UI element behaves <span class="No-Break">as intended.</span></p>
			<p>Following this, we’ll continue our testing strategy to learn about E2E tests, simulating real user interactions to affirm the overall functionality of the quiz game. We will also provide visual insights into test results <span class="No-Break">and coverage.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Implementing the quiz <span class="No-Break">game app</span></li>
				<li>Writing unit tests for the <span class="No-Break">Pinia store</span></li>
				<li>Writing unit tests <span class="No-Break">for components</span></li>
				<li>Writing end-to-end tests for the <span class="No-Break">quiz game</span></li>
				<li>Exploring Vitest UI and test <span class="No-Break">coverage tools</span></li>
			</ul>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Technical requirements</h1>
			<p>The code files for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07"><span class="No-Break">https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07</span></a><span class="No-Break">.</span></p>
			<p>The CiA video for this chapter can be found <span class="No-Break">on </span><a href="https://packt.link/tAMjs"><span class="No-Break">https://packt.link/tAMjs</span></a></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Exploring the repository</h2>
			<p>As we did in the previous chapter, let’s quickly review the <strong class="source-inline">starter</strong> folder in our repository. This folder, pre-populated with essential components, a quiz store, and TypeScript interfaces, is ready to be copied into your new project. It serves as the groundwork, allowing us to concentrate on the critical task of this chapter: implementing and learning testing strategies within <span class="No-Break">Nuxt 3.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Essential background – fundamentals of testing</h1>
			<p>As we shift our focus to testing in <a href="B19760_07.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, understanding the foundational aspects of testing becomes <a id="_idIndexMarker388"/>crucial. Testing is a critical process in software development, aimed at ensuring that your application performs correctly under <span class="No-Break">various scenarios.</span></p>
			<p>Traditionally, developers used to test applications manually, which required hands-on effort to find bugs. However, the evolution of testing practices has significantly reduced reliance on manual testing through the adoption of automated testing. Automated testing introduces efficiency and consistency by automating repetitive tasks. It encompasses three <span class="No-Break">primary levels:</span></p>
			<ul>
				<li><strong class="bold">Unit </strong>testing: Focuses <a id="_idIndexMarker389"/>on testing individual components or functions in isolation, making it easier to <span class="No-Break">pinpoint errors.</span></li>
				<li><strong class="bold">Integration </strong>testing: Tests the interaction between integrated units or components <a id="_idIndexMarker390"/>to ensure they work together as intended. While this chapter will not focus heavily on integration testing, it remains an important part of the <span class="No-Break">testing pyramid.</span></li>
				<li><strong class="bold">E2E testing</strong>: Simulates <a id="_idIndexMarker391"/>real-world user behaviors and interactions with the application from start to finish, ensuring the entire system functions <span class="No-Break">as expected.</span></li>
			</ul>
			<p>By implementing automated testing, we can significantly reduce the need for manual testing, allowing for more frequent and comprehensive test runs with less effort. Next, let’s see how to implement the quiz <span class="No-Break">game app.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor146"/>Implementing the quiz game app</h1>
			<p>We will kick off our quiz game application by setting up a new Nuxt 3 project. As with our previous <a id="_idIndexMarker392"/>endeavors, we’ll utilize the <strong class="source-inline">starter</strong> folder to fast-track our development process. Once you’ve created your new project, copy the contents of the starter folder into it. If prompted, agree to replacing the <span class="No-Break">existing files.</span></p>
			<p>Next, we’ll need to install a few essential Nuxt modules, such as Pinia, Tailwind CSS, and Google Fonts. We already discussed each module in previous chapters. Run the following commands in your terminal to add these packages to <span class="No-Break">your project:</span></p>
			<pre class="console">
$ pnpm i -D @nuxtjs/google-fonts @nuxtjs/tailwindcss sass
$ pnpm i @pinia/nuxt</pre>			<p>With the dependencies in place, it’s time to fire up our project and see the initial setup in action. Execute the project <span class="No-Break">as usual:</span></p>
			<pre class="console">
$ pnpm dev</pre>			<p>Upon running the project, you should be greeted with the initial layout of the quiz <span class="No-Break">game application:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B19760_07_01.jpg" alt="Figure 7.1: Quiz game app" width="1210" height="680"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Quiz game app</p>
			<p>Before diving into the testing aspect of our quiz game application, let’s take a moment to understand the structure and components that form the backbone of <span class="No-Break">our project.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Questions data</h2>
			<p>The questions <a id="_idIndexMarker393"/>data is located in <strong class="source-inline">data/questions.ts</strong>. It stores the quiz questions, each with multiple answers, enabling the dynamic generation of quizzes each time a user engages with <span class="No-Break">the app.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Types definitions</h2>
			<p>The structure <a id="_idIndexMarker394"/>and types of data used across the application are meticulously defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">types/index.ts</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export default {}
declare global {
  type Question = {
    id: number
    body: string
    answers: Answer[]
    rightAnswerId: number
  }
  type Answer = {
    id: number
    body: string
  }
  type Result = Question &amp; {
    userAnswer: Answer
    answerIsRight: boolean
  }
}</pre>			<p>Here’s ad <a id="_idIndexMarker395"/>breakdown of <span class="No-Break">the types:</span></p>
			<ul>
				<li><strong class="bold">Question</strong>: Represents each quiz question, containing an ID, the question body, a list of possible answers, and the ID of the correct <span class="No-Break">answer (</span><span class="No-Break"><strong class="source-inline">rightAnswerId</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Answer</strong>: Defines the structure for each answer option for a question, with its own ID and the <span class="No-Break">answer body</span></li>
				<li><strong class="bold">Result</strong>: A composite type that extends the <strong class="source-inline">Question</strong> type by including the user’s selected answer (<strong class="source-inline">userAnswer</strong>) and a flag (<strong class="source-inline">answerIsRight</strong>) indicating whether the chosen answer <span class="No-Break">is correct</span></li>
			</ul>
			<p>Next, let’s see the content of the <span class="No-Break">quiz store.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Quiz Pinia store</h2>
			<p>This store is designed to manage the game’s state using Pinia, from tracking the current question <a id="_idIndexMarker396"/>to calculating the player’s score. Here’s an overview of its <span class="No-Break">key features.</span></p>
			<p>This initial segment sets up the quiz store and initializes the state, including the current question index, quiz completion status, results array, <span class="No-Break">and score:</span></p>
			<pre class="source-code">
const currentQuestionIndex = ref&lt;number&gt;(0)
const quizFinished = ref&lt;boolean&gt;(false)
const result = ref&lt;Result[]&gt;([])
const score = ref&lt;number&gt;(0)</pre>			<p>Next, <strong class="source-inline">quiz</strong> is a computed property that selects five random questions from the provided questions dataset, ensuring a varied quiz experience <span class="No-Break">each time:</span></p>
			<pre class="source-code">
const quiz = computed(() =&gt;
selectRandomQuestions(questions, 5))</pre>			<p>Note that <strong class="source-inline">selectRandomQuestions</strong> is a utility function stored in the <strong class="source-inline">utils</strong> folder. So, it’s automatically imported due to the power of the Nuxt <span class="No-Break">auto-imports feature.</span></p>
			<p>To get the instance of the current question based on <strong class="source-inline">currentQuestionIndex</strong>, we’ll create another <span class="No-Break">computed method:</span></p>
			<pre class="source-code">
const currentQuestion = computed(() =&gt;
quiz.value[currentQuestionIndex.value])</pre>			<p>Now, in order <a id="_idIndexMarker397"/>to update the progress, there is a function <a id="_idIndexMarker398"/><span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">updateProgress</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const updateProgress = (answerId: number) =&gt; {
  const question = currentQuestion.value
  const answerIsRight = question.rightAnswerId === answerId
  if (answerIsRight) score.value++
  result.value.push({
    ...question,
    userAnswer:
      question.answers.find(({ id }) =&gt; id === answerId) ??
      ({ body: 'no answer' } as Answer),
    answerIsRight
  })
  if (currentQuestionIndex.value &lt; quiz.value.length - 1)
    currentQuestionIndex.value++
  else quizFinished.value = true
}</pre>			<p><strong class="source-inline">updateProgress</strong> is a crucial function that evaluates whether the user’s answer is correct, updates the score for correct answers, and appends the question along with the user’s answer and the correct answer to the results array. It also determines whether to move to the next question or conclude <span class="No-Break">the quiz.</span></p>
			<p>Finally, in order to restart the quiz after finishing, we can use the <strong class="source-inline">restartQuiz</strong> function, which <a id="_idIndexMarker399"/>allows users to reset the quiz to its initial state, clearing all progress and scores, and make another attempt with the same set <span class="No-Break">of questions:</span></p>
			<pre class="source-code">
const restartQuiz = () =&gt; {
  currentQuestionIndex.value = 0
  quizFinished.value = false
  result.value = []
  score.value = 0
}</pre>			<p>Make sure to return all refs and functions at the end of the <span class="No-Break">store file:</span></p>
			<pre class="source-code">
return {
    currentQuestionIndex,
    quizFinished,
    quiz,
    currentQuestion,
    updateProgress,
    restartQuiz,
    result,
    score
  }</pre>			<p>Now, let’s move on to see an overview <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>The app.vue file</h2>
			<p>Here is <a id="_idIndexMarker400"/>the skeleton of the <span class="No-Break"><strong class="source-inline">app.vue</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;!-- app.vue --&gt;
&lt;template&gt;
  &lt;div class="bg-violet-950 min-h-screen text-white"&gt;
    &lt;div class="container py-12 text-center"&gt;
      &lt;template v-if="quizStore.quizFinished"&gt;
        &lt;!-- RESULT HERE --&gt;
      &lt;/template&gt;
      &lt;Question v-else /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup&gt;
const quizStore = useQuizStore()
&lt;/script&gt;</pre>			<p>This file contains the main layout and flow of our quiz game. We initiate the quiz store in the <strong class="source-inline">script</strong> section to be accessible within the component. <strong class="source-inline">template</strong> employs a conditional rendering approach with <strong class="source-inline">v-if="quizFinished"</strong>. This condition checks whether the quiz has concluded, based on the <strong class="source-inline">quizFinished</strong> flag from <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">quizStore</strong></span><span class="No-Break">.</span></p>
			<p>Upon completion, it displays the user’s score out of five and lists the questions alongside the user’s answers, as well as the correct answers, applying different background colors to indicate whether the answers were correct or incorrect. There is also a restart quiz button that allows users to reset the quiz and <span class="No-Break">try again.</span></p>
			<p>Otherwise, the app will render <strong class="source-inline">Question.vue</strong>, which will be responsible for rendering the question with answers, capturing user responses, and updating the quiz’s progress. It’s straightforward. You can check its content from the <span class="No-Break">starter file.</span></p>
			<p>Having explored <a id="_idIndexMarker401"/>the foundational components of our quiz game project, we’re now ready to dive into the basics of unit testing and E2E testing. This knowledge equips us with the necessary skills to ensure our application meets the high standards of quality and reliability expected in modern <span class="No-Break">web development.</span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Writing unit tests for the Pinia store</h1>
			<p>As we move <a id="_idIndexMarker402"/>forward, the task at hand involves writing unit <a id="_idIndexMarker403"/>tests for the Pinia store. This step is pivotal in verifying the application’s state management logic and introduces us to the principles of unit testing within a <span class="No-Break">Pinia store.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>Exploring Vitest</h2>
			<p>Vitest, designed with Vite in mind, offers a next-generation testing framework that enhances the <a id="_idIndexMarker404"/>testing experience through integration with Vite’s ecosystem, leading to faster and more efficient tests. It provides a Jest-compatible API, enabling <a id="_idIndexMarker405"/>easy migration and parallel test execution for <span class="No-Break">improved performance.</span></p>
			<p>Compared to Jest, Vitest stands out for projects using Vite due to its seamless integration, faster setup, and execution, making it a preferred choice for modern web development. For more <a id="_idIndexMarker406"/>details, visit the official <span class="No-Break">website: </span><a href="https://vitest.dev"><span class="No-Break">https://vitest.dev</span></a><span class="No-Break">.</span></p>
			<p>To ensure Vitest works seamlessly with Nuxt, we integrate <strong class="source-inline">@nuxt/test-utils</strong> into our setup. This toolkit is designed to work with various testing frameworks and environments, providing flexibility and power to our testing strategy. Let’s clarify the key components of <span class="No-Break">our setup:</span></p>
			<ul>
				<li><strong class="source-inline">@nuxt/test-utils</strong>: Essential for Nuxt applications, offering specialized tools and functionalities, as well as integration with existing testing frameworks, for a smooth testing experience in the <span class="No-Break">Nuxt environment.</span></li>
				<li><strong class="source-inline">Vitest</strong>: Our chosen <span class="No-Break">testing framework.</span></li>
				<li><strong class="source-inline">happy-dom</strong>: A lightweight DOM simulation library, <strong class="source-inline">happy-dom</strong> provides a more accurate and faster simulation of browser environments within tests. It’s chosen for its efficiency in running tests that involve DOM manipulation or browser API interactions, replicating how components behave in a real browser without <span class="No-Break">needing one.</span></li>
			</ul>
			<p>Now, install <a id="_idIndexMarker407"/>these tools with <span class="No-Break">the following:</span></p>
			<pre class="console">
$ pnpm add -D @nuxt/test-utils vitest happy-dom</pre>			<p>We then <a id="_idIndexMarker408"/>create a <strong class="source-inline">vitest.config.ts</strong> file in the root of our project. This configuration file is crucial for specifying our test <span class="No-Break">environment preferences:</span></p>
			<pre class="source-code">
// vitest.config.ts
import { defineVitestConfig } from
'@nuxt/test-utils/config'
export default defineVitestConfig({
  test: {
    environment: 'happy-dom'
  }
})</pre>			<p>By setting the environment to <strong class="source-inline">'happy-dom'</strong>, we instruct Vitest to simulate a browser-like environment using <strong class="source-inline">happy-dom</strong> for <span class="No-Break">our tests.</span></p>
			<p>Next, we create a test file named <strong class="source-inline">temp.spec.ts</strong> in the root folder of our project. The <strong class="source-inline">.spec</strong> suffix in the filename is a convention that stands for “specification.” It signifies that the file contains a series of specifications (tests) that describe how the application or a particular component should behave. This naming convention helps Vitest to automatically locate and execute tests, scanning for files that end with <strong class="source-inline">.spec.ts</strong> or <strong class="source-inline">.test.ts</strong>, when we run the <span class="No-Break"><strong class="source-inline">vitest</strong></span><span class="No-Break"> command.</span></p>
			<p>Let’s now <a id="_idIndexMarker409"/>populate <strong class="source-inline">temp.spec.ts</strong> with a simple test to <a id="_idIndexMarker410"/>get familiar with Vitest’s syntax <span class="No-Break">and capabilities:</span></p>
			<pre class="source-code">
// temp.spec.ts
import { describe, it, expect } from 'vitest'
const sum = (a: number, b: number): number =&gt; a + b
describe('Sample Test', () =&gt; {
  it('should accurately add two numbers', () =&gt; {
    expect(sum(2, 3)).toBe(5)
  })
})</pre>			<p>In this example, <strong class="source-inline">describe</strong> is used to group our test under a common suite, <strong class="source-inline">it</strong> outlines an individual test case, and <strong class="source-inline">expect</strong> formulates an assertion about the code’s behavior. Here, we’ve created a simple test case to ensure that the <strong class="source-inline">sum</strong> function is working properly. We expected the result of <strong class="source-inline">sum(2, 3)</strong> to be equal <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></p>
			<p>To run our newly created test, we first need to make a small adjustment to our project’s <strong class="source-inline">package.json</strong> file. By adding a new script entry for <strong class="source-inline">"test"</strong>, we configure it to execute <strong class="source-inline">vitest</strong>, which in turn runs our <span class="No-Break">test suite:</span></p>
			<pre class="source-code">
// package.json
"scripts": {
  // other scripts
  "test": "vitest"
}</pre>			<p>With this script in place, execute the test suite by running <span class="No-Break">the following:</span></p>
			<pre class="console">
$ pnpm test</pre>			<p>Upon execution, Vitest springs into action, automatically scanning the project for any test files. For our simple test in <strong class="source-inline">temp.spec.ts</strong>, Vitest should recognize it as the sole test file, identifying the single <strong class="source-inline">describe</strong> block and the one test case it contains. If everything is set up correctly, you’ll see output indicating that the test case passed <span class="No-Break">as expected:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B19760_07_02.jpg" alt="Figure 7.2: Vitest output" width="789" height="272"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Vitest output</p>
			<p>Next, let’s introduce <a id="_idIndexMarker411"/>an additional test case to our <strong class="source-inline">temp.spec.ts</strong> file, one that <a id="_idIndexMarker412"/>we anticipate will fail, to observe Vitest’s behavior in handling <span class="No-Break">failing tests:</span></p>
			<pre class="source-code">
// temp.spec.ts
import { describe, it, expect } from 'vitest'
const sum = (a: number, b: number): number =&gt; a + b
describe('Sample Test', () =&gt; {
  // previous test
  // Add this test case within the same describe block
  it('should fail to add two numbers correctly', () =&gt; {
    expect(sum(2, 2)).toBe(5) // incorrect
  })
})</pre>			<p>Vitest continuously monitors for any changes in your test files. So, when you save your <strong class="source-inline">temp.spec.ts</strong> file with the intentionally failing test, Vitest automatically re-runs the tests. This time, you’ll notice in the terminal output that while the first test case passes as before, the new test case fails. This immediate feedback highlights the failing assertion, offering insights into what went wrong and where, directly in <span class="No-Break">your terminal:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B19760_07_03.jpg" alt="Figure 7.3: Vitest output with wrong tests" width="803" height="648"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Vitest output with wrong tests</p>
			<p>Now, with Vitest <a id="_idIndexMarker413"/>actively monitoring our project for changes, let’s <a id="_idIndexMarker414"/>proceed to test the quiz store to ensure its logic performs correctly under <span class="No-Break">various conditions.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Testing the quiz store</h2>
			<p>Our focus now shifts to the quiz store. By unit testing this store, we aim to confirm that our game’s logic <a id="_idIndexMarker415"/>and state management work as intended, providing a solid foundation for a great <span class="No-Break">user experience.</span></p>
			<p>First, let’s clear the stage by removing the <strong class="source-inline">temp.spec.ts</strong> temporary test file and creating <strong class="source-inline">quiz.spec.ts</strong> in the <strong class="source-inline">/stores</strong> folder next to our quiz store. To effectively unit test a Pinia store, we have to establish a fresh Pinia instance for <span class="No-Break">each test:</span></p>
			<pre class="source-code">
// stores/quiz.spec.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
describe('Quiz Store', () =&gt; {
  beforeEach(() =&gt; {
    setActivePinia(createPinia())
  })
})</pre>			<p>The <strong class="source-inline">beforeEach</strong> function is important for maintaining test integrity. It’s a function provided by Vitest that runs before each test case in our <strong class="source-inline">describe</strong> block. By calling <strong class="source-inline">setActivePinia(createPinia())</strong> within <strong class="source-inline">beforeEach</strong>, we guarantee that each test interacts with a fresh instance of Pinia, allowing us to assess the functionality of the quiz store in each <span class="No-Break">test independently.</span></p>
			<p>With our testing setup ready, it’s time to write our <span class="No-Break">first test:</span></p>
			<pre class="source-code">
// stores/quiz.spec.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
describe('Quiz Store', () =&gt; {
  // before each
  it('initializes with a set of 5 quiz questions', () =&gt; {
    const quizStore = useQuizStore()
    expect(quizStore.quiz.length).toBe(5)
  })
})</pre>			<p>This test verifies that the quiz store correctly initializes with a set of five questions, ensuring our game starts with the expected number of challenges for the player. After running the test, the terminal should indicate the test <span class="No-Break">case passed.</span></p>
			<p>To ensure our <a id="_idIndexMarker416"/>quiz store behaves as expected, we need to test each function comprehensively. One crucial aspect is verifying that the store correctly handles incorrect answers. The idea here is to simulate a scenario where a player chooses a wrong answer and to confirm that such an action does not lead to an increase in <span class="No-Break">their score.</span></p>
			<p>Here’s how we implement <span class="No-Break">this test:</span></p>
			<pre class="source-code">
// inside the quiz.spec.ts file
it(`doesn't increment the score when a wrong answer is
selected`, () =&gt; {
  const quizStore = useQuizStore()
  const firstQuestion = quizStore.quiz[0]
  // get a wrong answer
  const wrongAnswerId = firstQuestion.answers.find(
    answer =&gt; answer.id !== firstQuestion.rightAnswerId
  )?.id
  // Simulate the action of choosing a wrong answer
  if (wrongAnswerId !== undefined) {
    quizStore.updateProgress(wrongAnswerId)
    expect(quizStore.score).toBe(0)
  }
})</pre>			<p>To achieve 100% coverage, we should continue using this testing approach for every function within the quiz store, ensuring each aspect of our game’s logic is <span class="No-Break">rigorously validated.</span></p>
			<p>Following the <a id="_idIndexMarker417"/>approach to not increment the score with a wrong answer, we will also test the positive scenario. We implement a similar test case to ensure the score increments by 1 when the correct answer <span class="No-Break">is selected:</span></p>
			<pre class="source-code">
it('increment the score only when the correct answer is
selected', () =&gt; {
  const quizStore = useQuizStore()
  const firstQuestion = quizStore.quiz[0]
  const rightAnswerId = firstQuestion.rightAnswerId
  // Now try with the correct answer
  quizStore.updateProgress(rightAnswerId)
  expect(quizStore.score).toBe(1) // Score should increment
                                     by 1
})</pre>			<p>Next, let’s validate the quiz’s flow with a test to ensure it moves to the next question after an answer is selected. This test starts by checking the initial question index is 0, simulates answering the first question, and then confirms the quiz store correctly updates to indicate the next question <span class="No-Break">is ready:</span></p>
			<pre class="source-code">
it('transitions to the next question upon answering', () =&gt; {
  const quizStore = useQuizStore()
  expect(quizStore.currentQuestionIndex).toBe(0)
  const firstQuestion = quizStore.quiz[0]
  // Select any answer ID from the first question
  const anyAnswerId = firstQuestion.answers[0].id
  quizStore.updateProgress(anyAnswerId)
  // Verify the store has moved to the next question
  expect(quizStore.currentQuestionIndex).toBe(1)
})</pre>			<p>To conclude our testing of the quiz flow, we implement a test to confirm the quiz is marked as finished <a id="_idIndexMarker418"/>after the last question is answered. This test iterates through all questions, simulating correct answers for each, and checks that the quiz store flags the quiz as completed. It further verifies that all questions have been accounted for in the results, ensuring the game concludes <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
it('marks the quiz as finished when the last question is
answered', () =&gt; {
  const quizStore = useQuizStore()
  // Answer each question
  for (let i = 0; i &lt; quizStore.quiz.length; i++) {
    const question = quizStore.quiz[i]
    quizStore.updateProgress(question.rightAnswerId)
  }
  // After answering all questions,
  // the quiz should be marked as finished
  expect(quizStore.quizFinished).toBe(true)
  expect(quizStore.result.length).toBe(5)
})</pre>			<p>With these main test cases covered, we’ve laid a solid foundation for ensuring the quiz store functions correctly. For a complete view of all test cases, please refer to the full suite available in the <span class="No-Break">project repository.</span></p>
			<p>Next, let’s shift <a id="_idIndexMarker419"/>our focus to writing unit tests for the <strong class="source-inline">Question</strong> component, where we’ll apply similar rigor to ensure the components of our quiz game app behave as expected under <span class="No-Break">various scenarios.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Writing unit tests for components</h1>
			<p>When transitioning from testing the store to testing Vue components, our focus moves toward <a id="_idIndexMarker420"/>verifying that components behave as expected when they receive props, interact with the Pinia store, and render correctly. Component testing can include checking that components properly display data passed via props, react to user input, and integrate seamlessly with the store for <span class="No-Break">state management.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>Setting up for component testing</h2>
			<p>To effectively <a id="_idIndexMarker421"/>test Vue components, we introduce two crucial tools: <strong class="source-inline">@vue/test-utils</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">@pinia/testing</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">@vue/test-utils</strong>: This library provides utilities to mount and interact with Vue components in a testing environment. The <strong class="source-inline">mount</strong> function is particularly important as it allows us to render a component in isolation and returns a wrapper object that we can use to examine the rendered output and simulate <span class="No-Break">user interactions.</span></li>
				<li><strong class="source-inline">@pinia/testing</strong>: This offers tools for testing Pinia stores within Vue components. The <strong class="source-inline">createTestingPinia</strong> function is used to create a mock Pinia instance that can be used <span class="No-Break">in tests.</span></li>
			</ul>
			<p>So, let’s install <span class="No-Break">these libraries:</span></p>
			<pre class="console">
$ pnpm add -D @vue/test-utils @pinia/testing</pre>			<p>Next, let’s move on to creating the component <span class="No-Break">test file.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>Creating the Question.spec.ts test file</h2>
			<p>Inside <a id="_idIndexMarker422"/>the <strong class="source-inline">/components</strong> folder, create a file called <strong class="source-inline">Question.spec.ts</strong> and add the following code <span class="No-Break">to it:</span></p>
			<pre class="source-code">
// /components/Question.spec.ts
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import { createTestingPinia } from '@pinia/testing'
import QuestionComponent from '@/components/Question.vue'
const wrapper = mount(QuestionComponent, {
  global: {
    plugins: [
      createTestingPinia({
        createSpy: vi.fn
      })
    ]
  }
})</pre>			<p>Here’s a breakdown of <span class="No-Break">the code:</span></p>
			<ul>
				<li>The <strong class="source-inline">wrapper</strong> object returned by <strong class="source-inline">mount</strong> encapsulates the mounted component, providing a range of methods and properties to query and interact with it. This wrapper allows you to test the component’s rendered output, check its state, and simulate user interactions, such as clicks and <span class="No-Break">input changes..</span></li>
				<li>The <strong class="source-inline">createSpy</strong> option, used in conjunction with <strong class="source-inline">createTestingPinia</strong>, allows us to pass a spy function (<strong class="source-inline">vi.fn</strong> from Vitest) that can be used to monitor <a id="_idIndexMarker423"/>and verify interactions with the store. Spies can track calls to store refs and methods, providing insights into how the component interacts with <span class="No-Break">the store.</span></li>
			</ul>
			<p>With our testing environment configured, let’s proceed to write our first unit test for <span class="No-Break">the component.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Writing the component unit test</h2>
			<p>First, let’s <a id="_idIndexMarker424"/>have a look at the <strong class="source-inline">Question.vue</strong> component that we’ve already copied from the <span class="No-Break"><strong class="source-inline">starter</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;!-- components/Question.vue --&gt;
&lt;template&gt;
  &lt;div class="text-center"&gt;
    &lt;h1 class="text-4xl text-center capitalize font-bold
    mb-8"&gt;
      {{ currentQuestion.body }}
    &lt;/h1&gt;
    &lt;div class="grid grid-cols-2 gap-4"&gt;
      &lt;button
        class="text-2xl font-bold bg-violet-900
          hover:bg-violet-800 transition rounded-lg py-5"
        v-for="answer of currentQuestion.answers"
        @click="answered(answer.id)"
      &gt;
        {{ answer.body }}
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
const quizStore = useQuizStore()
const { currentQuestion } = storeToRefs(quizStore)
const answered = (answerId: number) =&gt; {
  quizStore.updateProgress(answerId)
}
&lt;/script&gt;</pre>			<p>The <strong class="source-inline">Question</strong> component is a key part of our quiz game application, designed to present users with a single question and its multiple-choice answers. Upon rendering, it dynamically <a id="_idIndexMarker425"/>displays the content of the current question retrieved from the Pinia store, including the question text and a set of buttons for each answer option. Users can select their answer by clicking one of these buttons, triggering the answered function that calls the <strong class="source-inline">updateProgress</strong> function from the Pinia store to update the quiz’s progress based on the selected answer ID and move on to the <span class="No-Break">next question.</span></p>
			<p>Our goal in testing the <strong class="source-inline">Question</strong> component is to ensure it functions as intended: displaying the current question and its answers correctly and responding to user <span class="No-Break">interactions appropriately.</span></p>
			<p>The first test case focuses on verifying that the <strong class="source-inline">Question</strong> component correctly displays the current question along with its four corresponding answers. Inside the <strong class="source-inline">Question.spec.ts</strong> file, add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// components/Question.spec.ts
// …previous code
describe('Question Component', () =&gt; {
  it('renders current question and answers', () =&gt; {
    const quizStore = useQuizStore()
    const question = quizStore.currentQuestion
    expect(wrapper.text()).toContain(question.body)
    expect(wrapper.findAll('button')).toHaveLength(4)
    // Dynamically assert each answer is rendered
    question.answers.forEach(answer =&gt; {
      expect(wrapper.html()).toContain(answer.body)
    })
  })
})</pre>			<p>The <a id="_idIndexMarker426"/>following are key points in <span class="No-Break">the code:</span></p>
			<ul>
				<li><strong class="source-inline">wrapper.text()</strong>: Checks the text content of the mounted component to ensure it includes the current <span class="No-Break">question’s body</span></li>
				<li><strong class="source-inline">wrapper.</strong>findAll<strong class="source-inline">('button')</strong>: Verifies that exactly four buttons (answers) <span class="No-Break">are rendered</span></li>
				<li><strong class="source-inline">wrapper.html()</strong>: Used to inspect the HTML output of the component, ensuring each answer’s body <span class="No-Break">is present</span></li>
			</ul>
			<p>The second test case verifies that when a user clicks an answer, the component’s <strong class="source-inline">answered</strong> method is correctly called with the appropriate <strong class="source-inline">answerId</strong>. This test simulates user interaction and checks the component’s logic for <span class="No-Break">processing answers:</span></p>
			<pre class="source-code">
// components/Question.spec.ts
// …previous code
describe('Question Component', () =&gt; {
  // previous test
  it('calls answered method with correct answerId when an
  answer is clicked', async () =&gt; {
    const quizStore = useQuizStore()
    // clicking on the first button
    await wrapper.findAll('button')[0].trigger('click')
    //  verify "updateProgress" was called correctly
    expect(quizStore.updateProgress).toHaveBeenCalledWith(1)
  })
})</pre>			<p>Key points <a id="_idIndexMarker427"/>in the code are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">wrapper.findAll('button')[0].trigger('click')</strong>: Simulates a user clicking the first answer button. The trigger function is used to dispatch DOM events, imitating user actions. If you check the questions data, you’ll notice that the ID of the first answer is always 1. We’ll use the information to check the prop that is passed to the <span class="No-Break"><strong class="source-inline">updateProgress</strong></span><span class="No-Break"> method.</span></li>
				<li><strong class="source-inline">toHaveBeenCalledWith(1)</strong>: Asserts that the <strong class="source-inline">updateProgress</strong> method within the quiz store was called with the correct argument, indicating the user’s selected answer ID (in this case, it’s 1). This ensures the component correctly communicates user selections to <span class="No-Break">the store.</span></li>
			</ul>
			<p>After running the unit tests for our quiz game components and the quiz store, you should see results similar to this in <span class="No-Break">your terminal:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B19760_07_04.jpg" alt="Figure 7.4: Vitest output after testing component" width="545" height="328"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Vitest output after testing component</p>
			<p>Now, let’s <a id="_idIndexMarker428"/>transition to writing E2E tests to ensure the game operates seamlessly from start to finish, as experienced by the <span class="No-Break">end user.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Writing end-to-end tests for the quiz game</h1>
			<p>E2E testing is a technique used to test the entire application from start to finish, simulating <a id="_idIndexMarker429"/>real-user scenarios and interactions. It ensures that the application behaves as expected in a production-like environment, covering UIs, databases, APIs, and other services. E2E testing is crucial for verifying the integrated operation of all application components and detecting issues that unit or integration tests <span class="No-Break">might miss.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>Setting up for E2E testing</h2>
			<p>To conduct E2E tests in our project, we have to install <strong class="source-inline">playwright-core</strong>, a powerful tool for <a id="_idIndexMarker430"/>automating browser interactions, enabling tests that simulate real user actions. It also supports testing across multiple browsers. Run this command to <span class="No-Break">install it:</span></p>
			<pre class="console">
$ pnpm add -D playwright-core</pre>			<p>The <strong class="source-inline">@nuxt/test-utils</strong> package includes utilities such as <strong class="source-inline">setup</strong> and <strong class="source-inline">createPage</strong> to facilitate E2E testing with Playwright or other test runners. Before beginning your E2E tests, initializing the test context with <strong class="source-inline">setup</strong> is necessary. This function prepares the Nuxt environment for testing by configuring the necessary <strong class="source-inline">beforeAll</strong>, <strong class="source-inline">beforeEach</strong>, <strong class="source-inline">afterEach</strong>, and <strong class="source-inline">afterAll</strong> hooks, ensuring your tests run within a correctly set up Nuxt context. <strong class="source-inline">createPage</strong>, on the other hand, allows you to create a configured Playwright browser instance and optionally navigate to a specific path on your running server. We’ll use it to create an instance from the quiz page to be able to simulate the <span class="No-Break">user actions.</span></p>
			<p>Let’s begin by creating our E2E test file, <strong class="source-inline">app.spec.ts</strong>, at the root of our project, then add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { describe, expect, it } from 'vitest'
import questions from '~/data/questions'
import { setup, createPage } from '@nuxt/test-utils/e2e'
describe('E2E Testing for the Quiz Feature in app.vue',
async () =&gt; {
  await setup()
})</pre>			<p>With the initial setup complete, we’re now ready to write specific test cases that will walk through the <span class="No-Break">quiz game.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Writing E2E tests</h2>
			<p>In our E2E testing sequence, we begin by verifying the initial state of the quiz game to ensure it <a id="_idIndexMarker431"/>loads correctly for the user. This includes checking for the presence of a question headline and four corresponding answer buttons, which are fundamental to the quiz’s functionality. Here is the <span class="No-Break">test case:</span></p>
			<pre class="source-code">
// app.spec.ts
// ...inside the describe function, under setup
it('Verifies the quiz initial state: one question headline
and four answer buttons', async () =&gt; {
  const page = await createPage('/')
  const h1Count = await page.locator('h1').count()
  expect(h1Count).toBe(1)
  const buttonCount =
    await page.locator('button').count()
  expect(buttonCount).toBe(4)
})</pre>			<p>Here is a breakdown of <span class="No-Break">the code:</span></p>
			<ul>
				<li><strong class="source-inline">createPage('/')</strong>: This function initializes a new browser page instance and navigates to the root of our application, where the quiz is presumed <span class="No-Break">to start.</span></li>
				<li><strong class="source-inline">page.locator('h1').count()</strong>: This uses Playwright’s locator API to find all <strong class="source-inline">&lt;h1&gt;</strong> elements on the page, then counts them. We expect exactly one <strong class="source-inline">&lt;h1&gt;</strong> element, typically containing the <span class="No-Break">quiz question.</span></li>
				<li><strong class="source-inline">page.locator('button').count()</strong>: Similarly, this line finds and counts all <strong class="source-inline">&lt;button&gt;</strong> elements, which should correspond to the quiz answer options. The expectation is to have exactly four buttons, each representing a <span class="No-Break">potential answer.</span></li>
			</ul>
			<p>Now let’s move on to the next test case. In this test case, we aim to simulate a user accurately <a id="_idIndexMarker432"/>answering all quiz questions to verify that the application correctly transitions to the result page and displays the final score. This process involves <span class="No-Break">the following:</span></p>
			<ol>
				<li>Navigating to <span class="No-Break">the quiz</span></li>
				<li>Iterating through questions: For each question displayed, the test locates the correct answer based on our predefined questions data, then simulates a click on the corresponding <span class="No-Break">answer button.</span></li>
				<li>Verifying the result page : After all questions have been answered correctly, the quiz should transition to a result page. This page displays a message indicating the quiz is finished and shows the <span class="No-Break">user’s score.</span></li>
				<li>Checking the score: The final part verifies that the score displayed matches the expected outcome of answering all <span class="No-Break">questions correctly.</span></li>
			</ol>
			<p>Here is the <span class="No-Break">test case:</span></p>
			<pre class="source-code">
test(––, async () =&gt; {
  const page = await createPage('/')
  for (let i = 0; i &lt; 5; i++) {
    const questionText =
      await page.locator('h1').textContent()
    const question = questions.find(q =&gt; q.body ===
      questionText)
    const answerText = question?.answers.find(a =&gt; a.id ===
      question.rightAnswerId).
    await page.locator(`button:has-text("${answerText}")`)
      .click()
  }
  const finishedText =
    await page.locator('h1').textContent()
  expect(finishedText).toBe('Finished')
  const score = await page.locator('h2').textContent()
  expect(score).toContain('5 / 5')
})</pre>			<p>Some <a id="_idIndexMarker433"/>syntax highlights are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">page.locator(button:has-text("${answerText}")).click()</strong>: Locates the button with the text matching the correct answer and simulates a <span class="No-Break">click event</span></li>
				<li><strong class="source-inline">expect(finishedText).toBe('Finished')</strong>: Checks whether the text Finished is displayed, indicating the <span class="No-Break">quiz completion</span></li>
				<li><strong class="source-inline">expect(score).toContain('5 / 5')</strong>: Validates that the final score, displayed within an <strong class="source-inline">&lt;h2&gt;</strong> element, correctly indicates all questions were <span class="No-Break">answered correctly</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">In this test case, we’ve opted for a more general search approach by using element tags (<strong class="source-inline">h1</strong> and <strong class="source-inline">h2</strong>) directly due to our knowledge of the page structure—there’s only one <strong class="source-inline">h1</strong> element displaying the quiz question and a single <strong class="source-inline">h2</strong> element showing the result. However, for more complex UIs or when multiple elements of the same type exist on a page, it’s advisable to perform more specific searches, such as targeting elements with unique identifiers such as classes or IDs. This will enhance the test’s precision, ensuring we’re interacting with the correct elements even in densely <span class="No-Break">structured pages.</span></p>
			<p>Once we initiate the E2E test, be prepared for it to take a bit longer to complete compared to <a id="_idIndexMarker434"/>unit tests. This delay is because the test involves simulating a real browser environment, requiring the page to fully load before any interactions (such as clicking on answer buttons) can occur. Your output in the terminal should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B19760_07_05.jpg" alt="Figure 7.5: E2E test output" width="571" height="358"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: E2E test output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If this is the first time you’re using the Playwright library on your machine, you might encounter <span class="No-Break">an error:</span></p>
			<pre class="console">
Looks like Playwright Test or Playwright was just installed or updated ║
║ Please run the following command to download new browsers:
pnpm exec playwright install</pre>			<p>In this case, just run the command shown in the terminal, then retry the test. Some developers <a id="_idIndexMarker435"/>have reported the need to run the following as well, in order to make Playwright <span class="No-Break">work properly:</span></p>
			<pre class="console">
pnpm exec playwright-core install</pre>			<p>With our E2E tests now complete, let’s shift our focus to exploring Vitest’s interactive UI and understanding test coverage. This will help us visualize our testing efforts and ensure complete coverage across <span class="No-Break">our application.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Exploring Vitest UI and test coverage tools</h1>
			<p>In our journey toward mastering testing with Vitest, two powerful tools stand out for their ability to <a id="_idIndexMarker436"/>enhance our development workflow: Vitest UI and test coverage tools. Vitest UI offers an interactive interface for running tests and visualizing results in real time, making it easier to manage and debug tests. Meanwhile, the test coverage <a id="_idIndexMarker437"/>tool provides insights into which parts of our code are thoroughly tested and which areas might need <span class="No-Break">more attention.</span></p>
			<p>To incorporate these tools into our project, we first need to <span class="No-Break">install them:</span></p>
			<pre class="console">
$ pnpm i -D @vitest/coverage-v8 @vitest/ui</pre>			<p>With the packages installed, we’ll adjust our testing script to enable both the UI and <span class="No-Break">coverage reporting:</span></p>
			<pre class="source-code">
// package.json script
"test": "vitest --ui --coverage"</pre>			<p>After making this adjustment, stop any currently running test processes and restart them to activate the changes. Upon reinitiating the tests, you’ll observe that Vitest launches a UI project, indicated by a message in the terminal similar <span class="No-Break">to this:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B19760_07_06.jpg" alt="Figure 7.6: Vitest UI dashboard URL" width="454" height="148"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: Vitest UI dashboard URL</p>
			<p>By navigating <a id="_idIndexMarker438"/>to this URL in your web browser, you’re greeted by the Vitest UI dashboard. Let’s explore the UI and coverage reports to gain deeper insights into <a id="_idIndexMarker439"/>our testing landscape and identify opportunities <span class="No-Break">for improvement.</span></p>
			<p>The <strong class="bold">Dashboard</strong> interface summarizes key metrics, including the total number of tests run, the breakdown of passed and failed tests, the total number of test files involved, and the execution time for all tests. This overview provides a clear snapshot of the project’s <span class="No-Break">testing health.</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B19760_07_07.jpg" alt="Figure 7.7: Vitest UI Dashboard" width="960" height="535"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: Vitest UI Dashboard</p>
			<p>As you <a id="_idIndexMarker440"/>explore the sidebar, you’ll find a list of your project’s test files. Clicking <a id="_idIndexMarker441"/>on one, for example, <strong class="source-inline">app.spec.ts</strong>, opens a detailed view of that specific test file. In this detailed view, you’ll see each test case listed along with its execution status—passed, failed, or skipped. Also, you’ll be able to re-run the test cases in this file. This allows for easy identification of which tests have succeeded and which may require further attention <span class="No-Break">or debugging.</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B19760_07_08.jpg" alt="Figure 7.8: Vitest test file" width="1182" height="353"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Vitest test file</p>
			<p>To gain insights <a id="_idIndexMarker442"/>into our code’s test coverage, a simple click on the <a id="_idIndexMarker443"/>coverage icon (located in the top-left corner, next to the play button) reveals a new dimension of our project’s health. The coverage overview presents a summary at the top of tested files, tested statements, branches, functions, and lines. Below the summary, a table lists each file alongside its <span class="No-Break">coverage percentage</span></p>
			<p>Let’s search for the <strong class="source-inline">stores</strong> folder and click on it. It reveals that 88.46% of the code and 50% of functions have <span class="No-Break">been tested.</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B19760_07_09.jpg" alt="Figure 7.9: Vitest coverage UI" width="1183" height="397"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: Vitest coverage UI</p>
			<p>A closer look <a id="_idIndexMarker444"/>at an individual file within this folder highlights untested <a id="_idIndexMarker445"/>code segments, such as the <strong class="source-inline">restartQuiz</strong> function—confirming areas where our test coverage could <span class="No-Break">be improved.</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B19760_07_10.jpg" alt="Figure 7.10: Vitest file coverage" width="1183" height="642"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: Vitest file coverage</p>
			<p>This level of detail pinpoints exactly where we need to enhance our tests. Such an approach to identifying untested code is invaluable, guiding us to achieve more comprehensive test coverage and, by extension, a more <span class="No-Break">reliable application.</span></p>
			<p>Our exploration <a id="_idIndexMarker446"/>of Vitest UI and test coverage concludes here, setting the <a id="_idIndexMarker447"/>stage for a summary of our journey through strong testing practices in enhancing the quiz <span class="No-Break">game application.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Summary</h1>
			<p><a href="B19760_07.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> steered us through the crucial role of testing in the development of a quiz game application with Nuxt 3. We began by laying the groundwork with unit testing, utilizing Vitest to test the logic of our Pinia store and components, ensuring their reliability. By simulating user interactions and asserting expected outcomes, we verified the functionality of critical parts of <span class="No-Break">our application.</span></p>
			<p>Transitioning to E2E testing, we employed Playwright to mimic real-user scenarios, from navigating through quiz questions to completing the game. This phase reinforced our application’s user experience and functionality, highlighting the significance of testing in identifying and rectifying potential issues before they <span class="No-Break">affect users.</span></p>
			<p>The journey concluded with an exploration of Vitest UI and coverage tools, which illuminated untested code segments and provided a visual and interactive approach to managing our test suite. This not only enhanced our testing efficiency but also deepened our understanding of test coverage’s impact on <span class="No-Break">application quality.</span></p>
			<p>Looking ahead, <a href="B19760_08.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> levels up our skills by creating a custom translation module in Nuxt 3. This next chapter will guide us through the intricacies of i18n (Internationalization), from building a custom module to injecting it with the necessary components and functionalities to facilitate seamless language switching <span class="No-Break">and localization.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Practice questions</h1>
			<ul>
				<li>What is the purpose of unit testing in a <span class="No-Break">Vue.js application?</span></li>
				<li>Describe the process of setting up Vitest in a Nuxt <span class="No-Break">3 project.</span></li>
				<li>Explain how to use the <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> blocks to structure your tests <span class="No-Break">in Vitest.</span></li>
				<li>What role does <strong class="source-inline">expect</strong> play in a <span class="No-Break">test case?</span></li>
				<li>How can you mock a user interaction, such as clicking a button, in a <span class="No-Break">unit test?</span></li>
				<li>How do you test a Vue component that interacts with a <span class="No-Break">Pinia store?</span></li>
				<li>How can you simulate browser interactions in an <span class="No-Break">E2E test?</span></li>
				<li>What is the purpose of the <strong class="source-inline">createPage</strong> function in Nuxt’s <span class="No-Break">test utils?</span></li>
				<li>How can Vitest’s UI and coverage tools help improve the quality of <span class="No-Break">your tests?</span></li>
			</ul>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Further reading</h1>
			<ul>
				<li>Vitest official <span class="No-Break">website: </span><a href="https://vitest.dev/"><span class="No-Break">https://vitest.dev/</span></a></li>
				<li>Why <span class="No-Break">Vitest: </span><a href="https://vitest.dev/guide/why.html#why-vitest"><span class="No-Break">https://vitest.dev/guide/why.html#why-vitest</span></a></li>
				<li>Vue <span class="No-Break">testing: </span><a href="https://vuejs.org/guide/scaling-up/testing"><span class="No-Break">https://vuejs.org/guide/scaling-up/testing</span></a></li>
				<li>Pinia <span class="No-Break">testing: </span><a href="https://pinia.vuejs.org/cookbook/testing.html"><span class="No-Break">https://pinia.vuejs.org/cookbook/testing.html</span></a></li>
				<li>Nuxt <span class="No-Break">testing: </span><a href="https://nuxt.com/docs/getting-started/testing"><span class="No-Break">https://nuxt.com/docs/getting-started/testing</span></a></li>
				<li>Vitest <span class="No-Break">UI: </span><a href="https://vitest.dev/guide/ui"><span class="No-Break">https://vitest.dev/guide/ui</span></a></li>
				<li>Vitest <span class="No-Break">coverage: </span><a href="https://vitest.dev/guide/coverage"><span class="No-Break">https://vitest.dev/guide/coverage</span></a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>