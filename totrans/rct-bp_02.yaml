- en: Chapter 2. Creating a Web Shop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 创建网上商店
- en: Selling merchandise online has been a staple of the Web since it was commercialized
    in the 1990s. In this chapter, we will explore how we can leverage the power of
    ReactJS to create our very own web shop.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代网络商业化以来，在线销售商品一直是网络的基础。在本章中，我们将探讨如何利用ReactJS的力量来创建我们自己的网上商店。
- en: We'll start by creating a number of different components, such as a home page,
    a products page, a checkout and receipt page, and we'll fetch products from data
    stores via a concept called **Flux**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建多个不同的组件开始，例如主页、产品页、结账和收据页，我们将通过一个称为**Flux**的概念从数据存储中获取产品。
- en: When we're finished, you'll have a complete blueprint that you can expand upon
    and apply your own styling to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，你将拥有一个完整的蓝图，你可以在此基础上扩展并应用自己的样式。
- en: Let's get started!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: An overview of the components
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件概述
- en: When creating any kind of website, it's often beneficial to create a mock-up
    of how you want the page to look before proceeding to write any code. This makes
    it easier to visualize how you want your site to look and what components you
    need to create. You can use any kind of mockup tool to create this, even a sheet
    of paper will do.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何类型的网站时，在编写任何代码之前创建一个页面外观的原型通常是有益的。这使得更容易可视化你想要网站看起来什么样，以及你需要创建哪些组件。你可以使用任何类型的原型工具来创建这个，甚至一张纸也行。
- en: 'Looking at our website mock-up, we can see that we need to create the following
    components:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们的网站原型，我们可以看到我们需要创建以下组件：
- en: A layout component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布局组件
- en: A home page component for the front page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于主页的首页组件
- en: A menu component with a brand name and the most important links
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有品牌名称和最重要链接的菜单组件
- en: A company information component
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公司信息组件
- en: A product list component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个产品列表组件
- en: An item component
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个商品组件
- en: A checkout component
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个结账组件
- en: A receipt component
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个收据组件
- en: These are just the view components. In addition to these, we'll need to create
    data stores and actions and subcomponents for the main ones. For instance, for
    the product component on the front page, you will need a picture element, description,
    price, and a buy button, and any time you need a list or table, you need to make
    another subcomponent, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是视图组件。除了这些，我们还需要为主要的组件创建数据存储、动作和子组件。例如，对于主页上的产品组件，你需要一个图片元素、描述、价格和一个购买按钮，每次你需要列表或表格时，你都需要创建另一个子组件，等等。
- en: 'We''ll create these as we go along. Let''s take a look at the following image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在进行过程中创建这些。让我们看看下面的图片：
- en: '![An overview of the components](img/B04943_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![组件概述](img/B04943_02_01.jpg)'
- en: The preceding mock-up shows the product list page as seen on a desktop and as
    viewed on a smart phone. It's worthwhile to sketch up mock-ups for all the platforms
    you intend to support. It's also a good idea to make sketches of all the different
    pages and states they can have.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的原型展示了在桌面和智能手机上查看的产品列表页面。为所有你打算支持的平台绘制原型是值得的。同时，绘制所有不同页面及其可能的状态的草图也是一个好主意。
- en: Setting up a shop
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置商店
- en: We'll be using the code from [Chapter 1](ch01.html "Chapter 1. Diving Headfirst
    into ReactJS"), *Diving Headfirst into ReactJS*, as the basis for this web shop.
    Make a duplicate of the code from the first chapter and make sure that it's running
    before you continue making changes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[第一章](ch01.html "第一章. 深入ReactJS")中的代码，*深入ReactJS*，作为这个网上商店的基础。复制第一章的代码，并确保它在继续进行更改之前正在运行。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Copy the code to another directory and run it by executing `node server.js`.
    It should start up a server and automatically open a browser window for you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码复制到另一个目录，并通过执行`node server.js`来运行它。它应该启动一个服务器，并自动为你打开一个浏览器窗口。
- en: Creating the layout
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建布局
- en: First of all, we need a basic layout for our webshop. There are many options
    available for you. For instance, you can choose any one of the many open source
    CSS frameworks, such as **Bootstrap** or **Foundation**, or you can strike your
    own path and build up a basic grid and bring in elements as you see fit.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的网上商店创建一个基本的布局。有许多选项可供选择。例如，你可以选择许多开源CSS框架中的任何一个，如**Bootstrap**或**Foundation**，或者你可以开辟自己的道路，构建一个基本的网格，并按需引入元素。
- en: For simplicity's sake, we'll be going with Bootstrap for this webshop. It's
    a hugely popular framework that is easy to work with and has excellent support
    for React.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将使用Bootstrap来构建这个网上商店。这是一个非常流行的框架，易于使用，并且对React有很好的支持。
- en: 'As noted, we''ll be using the scaffolding from [Chapter 1](ch01.html "Chapter 1. Diving
    Headfirst into ReactJS"), *Diving Headfirst into ReactJS*. In addition, we''re
    going to need a few more packages, most notably: `react-bootstrap`, `react-router`,
    `lodash`, `Reflux`, `superagent` and `react-router-bootstrap`. For simplicities
    sake, replace the dependencies section in your `package.json` with these values
    and run `npm install` in your command line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用来自[第1章](ch01.html "第1章。ReactJS初探")的脚手架，*ReactJS初探*。此外，我们还需要一些额外的包，最重要的是：`react-bootstrap`、`react-router`、`lodash`、`Reflux`、`superagent`和`react-router-bootstrap`。为了简化起见，将你的`package.json`文件中的依赖关系部分替换为这些值，并在命令行中运行`npm
    install`：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `--save-dev` option saves the dependencies in your `package.json` file under
    the `devDependencies` key as shown in the preceding code. On a production build,
    these dependencies will not be installed, and this makes the deployment go faster.
    We'll take a look at how to create a production build in [Chapter 8](ch08.html
    "Chapter 8. Deploying Your App to the Cloud"), *Deploying Your App to the Cloud*.
    If you rather want to put these packages in your regular dependencies section,
    use `--save` instead of `--save-dev` and in your `package.json` the preceding
    packages will reside in your `dependencies` section rather than in your `devDependencies`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`--save-dev`选项将依赖项保存到你的`package.json`文件中的`devDependencies`键下，如前述代码所示。在生产构建中，这些依赖项将不会安装，这使部署更快。我们将在[第8章](ch08.html
    "第8章。将你的应用部署到云端")中查看如何创建生产构建，*将你的应用部署到云端*。如果你更愿意将这些包放在常规依赖关系部分，请使用`--save`而不是`--save-dev`，在你的`package.json`中，上述包将位于`dependencies`部分而不是`devDependencies`部分。'
- en: 'We also need the Bootstrap, and we''ll use a **Content Delivery Network** (**CDN**)
    to fetch it. Add the following code snippet to the `<head>` section of your `index.html`
    file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要Bootstrap，我们将使用**内容分发网络**（**CDN**）来获取它。将以下代码片段添加到你的`index.html`文件的`<head>`部分：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Whether you want to support the older version of Internet Explorer is your
    choice, but if you do, you''re going to need to add this part to the `<head>`
    section of your `index.html` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想支持旧版本的Internet Explorer是你的选择，但如果你这样做，你将需要在你的`index.html`文件的`<head>`部分添加这部分内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This adds a **polyfill** to your code base. A polyfill adds support for HTML5
    features that older browsers don't support.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的代码库中添加一个**polyfill**。polyfill添加了对旧浏览器不支持HTML5功能的支持。
- en: 'We also want to use the modern features of Internet Explorer, so let''s add
    the following `meta` tag:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望使用Internet Explorer的现代功能，所以让我们添加以下`meta`标签：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This setting tells the browser to render according to the most recent version
    of the standard. This tag was introduced in *IE8*, so this tag won't matter if
    your users are using *IE7* or lower. Additional settings are `IE=5` to `IE=11`
    and `IE=EmulateIE7` to `IE=EmulateIE11`. Using the emulate instructions informs
    Internet Explorer how to render in the standards and quirks mode. For instance,
    `EmulateIE9` renders the page as *IE9* in the standards mode and as *IE5* in the
    quirks mode.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置告诉浏览器根据最新的标准版本进行渲染。这个标签是在*IE8*中引入的，所以如果你的用户使用的是*IE7*或更低版本，这个标签就不会起作用。其他设置包括`IE=5`到`IE=11`和`IE=EmulateIE7`到`IE=EmulateIE11`。使用模拟指令告诉Internet
    Explorer如何在标准和怪癖模式下进行渲染。例如，`EmulateIE9`在标准模式下将页面渲染为*IE9*，在怪癖模式下渲染为*IE5*。
- en: Which settings you choose is dependent on your target platform, and unless you
    have a very specific IE version in mind, going with `IE=edge` is probably the
    safest option.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的设置取决于你的目标平台，除非你有非常具体的IE版本在心中，否则选择`IE=edge`可能是最安全的选项。
- en: 'In order for the smart phones to show the page in proper scale, we need to
    add this `meta` tag as well:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让智能手机以正确的比例显示页面，我们还需要添加这个`meta`标签：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This notifies the smart phone browser that you want to display the page in full
    width with a scale of 1\. You can play with the scale and width, but in most cases,
    this setting is what you want.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这条通知智能手机浏览器，你希望以1倍的比例全宽显示页面。你可以调整比例和宽度，但在大多数情况下，这个设置就是你所需要的。
- en: Adding your own CSS code
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加你自己的CSS代码
- en: 'We already have a CSS file in the public folder. We''re going to use a very
    basic CSS layout and rely on Bootstrap for the most part. Edit `public/app.css`
    and replace it with the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在公共文件夹中有一个CSS文件。我们将使用一个非常基本的CSS布局，并在很大程度上依赖Bootstrap。编辑`public/app.css`并将其替换为以下代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The padding is there simply to make sure that the content falls inside the menu
    (that we'll be creating in the upcoming section called *The menu and footer*).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 填充只是为了确保内容落在菜单内（我们将在下一节*菜单和页脚*中创建的菜单内）。
- en: Adding a route handler
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加路由处理器
- en: 'Let''s open the `app.jsx` file, remove everything from the initial scaffold,
    and replace it with the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`app.jsx`文件，移除初始脚手架中的所有内容，并用以下代码替换：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our imports section, we're now adding `react-router` and a new file called
    `routes.jsx`. You'll note that we're fetching `Route` from react-router by encapsulating
    it in braces. This is called **destructuring** and is identical to fetching it
    with `var Route = require("react-router").Route`, which is quite easy to type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的导入部分，我们现在添加`react-router`和一个名为`routes.jsx`的新文件。你会注意到我们通过括号封装来从`react-router`获取`Route`。这被称为**解构**，与使用`var
    Route = require("react-router").Route`获取它是相同的，后者很容易输入。
- en: The next thing we do is let the **router** control our app by applying `Router.run`,
    provide it with the contents of our new `routes` file, then mount it on the `<div>`
    tag with the `id` container as we did before.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过应用`Router.run`让**路由器**控制我们的应用，给它提供我们新的`routes`文件的内容，然后像之前一样将其挂载到具有`id`容器标签的`<div>`标签上。
- en: 'Of course, to run this, you need to create a file called `router.jsx`. It should
    look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要运行这个，你需要创建一个名为`router.jsx`的文件。它应该看起来像这样：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's pretty straightforward as you can see, since we're not creating any routes
    just yet. Again, we're importing `react`, `react-router`, and `route`, and also
    a new file called `layout.jsx`, which will be our primary route handler.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这相当直接，因为我们还没有创建任何路由。同样，我们正在导入`react`、`react-router`和`route`，以及一个名为`layout.jsx`的新文件，它将成为我们的主要路由处理器。
- en: At the end, we're exporting the contents of the Routes as Routes. This is a
    necessary step because this is what allows you to import it later in your other
    scripts. You could simplify this by putting `module.exports =` instead of `const
    Routes =` in the module declaration and then skip the last line. It's your choice,
    but I think it's a good practice to structure your code by putting the imports
    first, the code in the middle, and then what the module exports last.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将Routes的内容导出为Routes。这是一个必要的步骤，因为这允许你在其他脚本中稍后导入它。你可以通过在模块声明中用`module.exports
    =`代替`const Routes =`来简化这一点，然后跳过最后一行。这是你的选择，但我认为将代码结构化，先放导入，然后是代码，最后是模块导出，是一个好的实践。
- en: 'This is what should go into the `layout.jsx` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应该放入`layout.jsx`文件的内容：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This page is completely empty. The only thing we've added for now is the route
    handler. This is where the contents of your route changes will go. Everything
    you put around it will not be changed when you switch to a new route, so this
    is where you place static elements, such as headers, footers, and asides.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面完全是空的。我们现在唯一添加的是路由处理器。这就是你的路由更改内容将放置的地方。你围绕它放置的所有内容在切换到新路由时都不会改变，所以这是放置静态元素（如页眉、页脚和边栏）的地方。
- en: 'When you have put all of this together, you''ve got all the pieces you need
    to start building your webshop. You have now implemented the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把这些东西组合在一起时，你就拥有了开始构建你的网店所需的所有部件。你现在已经实现了以下内容：
- en: The scaffold from [Chapter 1](ch01.html "Chapter 1. Diving Headfirst into ReactJS"),
    *Diving Headfirst into ReactJS*
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[第1章](ch01.html "第1章。深入ReactJS")的脚手架，*深入ReactJS*
- en: Bootstrap for ReactJS
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap for ReactJS
- en: A way to handle route changes
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理路由更改的方法
- en: A polyfill for older browsers
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧浏览器提供的polyfill
- en: Don't be discouraged when your web browser shows a blank web page when you run
    this code. This is the expected output at this point.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，如果你的网络浏览器显示一个空白网页，不要气馁。在这个阶段，这是预期的输出。
- en: The menu and footer
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菜单和页脚
- en: It's time to start working on the visible menu components. Let's begin with
    the menu and the footer. Looking at our mock-up, we see that we want to build
    a full-width section with the brand name of the shop and the menu links, and at
    the bottom, we want a single centered line of text with a copyright notice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始工作于可见的菜单组件了。让我们从菜单和页脚开始。查看我们的原型，我们看到我们想要构建一个全宽的板块，包含商店的品牌名称和菜单链接，底部则想要一条居中的单行文本，包含版权声明。
- en: 'We''ll do this by adding the following import to our `import` section in the
    `layout.jsx` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`layout.jsx`文件的`import`部分添加以下导入来实现这一点：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the `render` function with this code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将`render`函数替换为以下代码片段：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, create a directory called `components` and place a file called `menu.jsx`
    in there. Add the following code inside the `menu.jsx` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `components` 的目录，并在其中放置一个名为 `menu.jsx` 的文件。在 `menu.jsx` 文件中添加以下代码：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These imports pull in `Nav`, `NavItem`, `Navbar`, `Button`, and `LinkContainer`
    via destructuring, as mentioned in [Chapter 1](ch01.html "Chapter 1. Diving Headfirst
    into ReactJS"), *Diving Headfirst into ReactJS*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入通过解构引入了 `Nav`、`NavItem`、`Navbar`、`Button` 和 `LinkContainer`，正如在[第1章](ch01.html
    "第1章。ReactJS初探") *ReactJS初探* 中提到的：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We create a `Navbar` instance with a linked brandname. If you want an image
    instead of a text brand, you can insert a JSX node instead of a text string, like
    this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个带有链接品牌名称的 `Navbar` 实例。如果你想用图片代替文本品牌，你可以插入一个 JSX 节点而不是文本字符串，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `fixedTop` option creates a fixed `Navbar` instance that sticks to the
    top of your screen. Replace it with `staticTop` if you want a floating Navbar
    instance instead. You can also add `inverse` if you want a black Navbar instance
    instead of a grey one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`fixedTop` 选项创建了一个固定在屏幕顶部的 `Navbar` 实例。如果你想有一个浮动的 `Navbar` 实例，请将其替换为 `staticTop`。你也可以添加
    `inverse` 以获得黑色 `Navbar` 实例而不是灰色实例：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We add three navigation items in our navigation bar, like in our mock-up. We
    also provide a **right** keyword so that the items in your Navbar instance are
    aligned to the right. These links redirect to those pages that we haven''t made
    yet, so we will have to make these next:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在导航栏中添加了三个导航项，就像我们的原型一样。我们还提供了一个 **right** 关键字，以便你的 `Navbar` 实例中的项目向右对齐。这些链接将重定向到我们尚未制作的页面，因此我们将在下一步制作这些页面：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s it for the menu. We also need to add the footer, so go ahead and add
    a file called `footer.jsx` in the `components` folder and add the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单部分就到这里。我们还需要添加页脚，所以请继续在 `components` 文件夹中添加一个名为 `footer.jsx` 的文件，并添加以下代码：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating the pages
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建页面
- en: 'Let''s create a subfolder called `pages` and add the following files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `pages` 的子目录，并添加以下文件：
- en: '`pages/products.jsx`:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/products.jsx`:'
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`pages/company.jsx`:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/company.jsx`:'
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`pages/checkout.jsx`:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/checkout.jsx`:'
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`pages/receipt.jsx`:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/receipt.jsx`:'
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`pages/item.jsx`:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/item.jsx`:'
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`pages/home.jsx`:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages/home.jsx`:'
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s add the links we just created in our routes. Open the `routes.jsx`
    file and add the following content to the imports section:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们刚刚创建的链接添加到我们的路由中。打开 `routes.jsx` 文件，并在导入部分添加以下内容：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Replace the `<Route handler={Layout} path="/"></Route>` code block with this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<Route handler={Layout} path="/"></Route>` 代码块替换为以下内容：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've added the `receipt` page to our file structure and the routes, but it
    will not be visible in the menu bar because you should only be redirected to the
    `receipt` page after you've checked out an order.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `receipt` 页面添加到我们的文件结构和路由中，但它不会在菜单栏中可见，因为你应该只在检查订单后重定向到 `receipt` 页面。
- en: If you run the app now, you'll see a menu bar on top of the screen, which you
    can click on. You'll note that when you click on any of the menu options, the
    app will route to the chosen page. You'll also note that the chosen route will
    be highlighted in the menu bar, which makes it easy to know where you are, without
    looking at the route in the address bar.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用，你会在屏幕顶部看到一个菜单栏，你可以点击它。你会注意到，当你点击任何菜单选项时，应用会路由到所选页面。你还会注意到所选路由将在菜单栏中突出显示，这使得在不查看地址栏中的路由的情况下很容易知道你在哪里。
- en: When you open the app in the responsive mode in your web browser or open the
    app on a smartphone, you'll note that the menu collapses and that a **Hamburger**
    button appears instead of the menu links. When you click on this button, the menu
    expands and presents the links in a drop-down menu.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网页浏览器中的响应式模式下打开应用或在智能手机上打开应用时，你会注意到菜单会折叠，并且出现一个**汉堡**按钮而不是菜单链接。当你点击这个按钮时，菜单会展开并显示下拉菜单中的链接。
- en: Creating a database of products
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建产品数据库
- en: Your shops need products, so we're going to provide a small set of items for
    our web shop.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你的商店需要产品，所以我们将为我们的网店提供一组小项目。
- en: This kind of data is usually stored in some kind of database. The database can
    be self provided either locally or remotely or you can use any of the many cloud-based
    database services. Traditionally, you would use a database based on **SQL** (**Structured
    Query Language**), but nowadays, it's common to go for the **NoSQL** document-based
    approach. This is what we'll do for our webshop, and we'll simply use a flat file
    for the data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这类数据通常存储在某种数据库中。数据库可以是本地或远程自行提供的，或者您可以使用众多基于云的数据库服务中的任何一个。传统上，您会使用基于 **SQL**（**结构化查询语言**）的数据库，但如今，选择
    **NoSQL** 基于文档的方法更为常见。这就是我们为我们的网店所采取的方法，我们将简单地使用平面文件来存储数据。
- en: 'Create a file and call it `products.json`, save it in the `public` folder,
    and add the following content:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文件，命名为 `products.json`，保存在 `public` 文件夹中，并添加以下内容：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This file is equivalent to what you would find if you inserted a few products
    in a NoSQL database, such as **MongoDB**. The syntax is **JSON** (**JavaScript
    Object Notation**), an open format that transports data as attribute-value pairs.
    It's simple and language-independent, and just by looking at the preceding structure,
    you can easily understand its data structure and contents.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件相当于在NoSQL数据库中插入一些产品时您会找到的内容，例如 **MongoDB**。语法是 **JSON**（**JavaScript 对象表示法**），一种开放格式，以属性-值对的形式传输数据。它是简单的且与语言无关的，仅通过查看前面的结构，您就可以轻松理解其数据结构和内容。
- en: The fields should be self-explanatory, but let's walk through them. There are
    two groups of products, one for the main range and one for the sales range. The
    main range has only one item and the sales range has six. The products in each
    list have a title, an **SKU** (**store keeping unit**, for example, a product
    code), a price, a conveniently formatted savings text, a description, and an image
    URL. We've elected to insert a placeholder code for the pixel size of the image
    because we want to be able to dynamically alter the sizes when we present the
    pictures to the user.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字段应该是自解释的，但让我们来了解一下。有两种产品组，一个是主系列，另一个是促销系列。主系列只有一个项目，促销系列有六个。每个列表中的产品都有一个标题、一个
    **SKU**（**库存单位**，例如，产品代码）、一个价格、一个方便格式的节省文本、一个描述和一个图片 URL。我们选择插入一个占位符代码来表示图片的像素大小，因为我们希望能够在向用户展示图片时动态更改大小。
- en: 'We want to access this file by going to `http://localhost:3000/products.json`,
    so we need to make an addition to `server.js`. Edit this file, and before the
    line with `app.listen`, add the following code and restart the server:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过访问 `http://localhost:3000/products.json` 来访问此文件，因此我们需要在 `server.js` 中添加一些内容。编辑此文件，并在
    `app.listen` 行之前添加以下代码，然后重新启动服务器：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you access `http://localhost:3000/products.json`, you should be served
    our products.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问 `http://localhost:3000/products.json` 时，应该提供我们的产品。
- en: Creating a data store to fetch the products
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个数据存储来获取产品
- en: The application architecture suggested for use with ReactJS is called **Flux**.
    It's not a framework though, but can be seen as more of a pattern to transmit
    data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 建议与ReactJS一起使用的应用程序架构称为 **Flux**。虽然它不是一个框架，但可以看作是一种传输数据的设计模式。
- en: 'Flux consists of three major parts: the dispatchers, stores, and actions. The
    central idea behind Flux is a concept known as *unidirectional data flow*. The
    idea is that your app should have a store to hold your data and that your components
    should listen to it for updates. You interact with it using dispatchers, which
    you can think of as messengers that pass instructions to your actions. In your
    actions, you can fetch new data and pass it over to the store, which in turn emits
    data to your components.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 由三个主要部分组成：调度器、存储和动作。Flux背后的核心思想是一个称为 *单向数据流* 的概念。这个想法是您的应用应该有一个存储来保存您的数据，并且您的组件应该监听它以获取更新。您通过调度器与之交互，可以将调度器视为传递指令到您的动作的信使。在您的动作中，您可以获取新数据并将其传递给存储，然后存储会向您的组件发射数据。
- en: This pattern avoids the common problem of having multiple places where you need
    to update the state of your application, which often leads to bugs that are hard
    to track down.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式避免了常见的多个地方需要更新应用程序状态的问题，这通常会导致难以追踪的bug。
- en: 'This may be a bit much to digest, so let''s take a quick look at the individual
    components:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点难以消化，所以让我们快速看一下各个组件：
- en: '**Dispatcher**: This is the central hub. It receives actions and sends payloads
    to all of its registered callbacks.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：这是中心枢纽。它接收动作并向所有已注册的回调发送有效载荷。'
- en: '**Actions**: These refer to helper methods that facilitate the passing of data
    to the dispatcher.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：这些是指辅助方法，它们便于将数据传递给分发器。'
- en: '**Stores**: These are logic containers that have callbacks registered on the
    dispatcher, which emits state changes to all registered callbacks.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：这些是逻辑容器，它们在分发器上注册了回调，向所有注册的回调发出状态变化。'
- en: '**Views**: This refers to those React components that get a state from the
    stores and pass data to any of the descendants in their component tree.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这指的是从存储中获取状态并将数据传递给其组件树中任何后代的 React 组件。'
- en: There are a multitude of different Flux implementations. For this chapter, I've
    chosen Reflux as the Flux implementation, but we'll look at a different implementation
    called **Redux** in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced
    React*, and an alternate solution in [Chapter 7](ch07.html "Chapter 7. Reactagram"),
    *Reactagram*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的 Flux 实现。对于本章，我选择了 Reflux 作为 Flux 实现，但在 [第 6 章](ch06.html "第 6 章。高级 React")
    *高级 React* 中，我们将查看一个名为 **Redux** 的不同实现，以及在 [第 7 章](ch07.html "第 7 章。Reactagram")
    *Reactagram* 中的替代方案。
- en: Reflux ditches the concept of a single central dispatcher, choosing to merge
    the concept of dispatcher and action. This lets us get away with less code and
    results in a code base that is easier to understand.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Reflux 放弃了单个中央分发器的概念，选择合并分发器和动作的概念。这使得我们可以用更少的代码实现，并导致代码库更容易理解。
- en: Let's create a **Reflux** implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 **Reflux** 实现。
- en: We already installed *Reflux* and the HTTP request library called **Superagent**
    that we'll use to fetch our product's data when we bootstrapped our application
    at the beginning of the chapter, so we're ready to start with *Reflux* right away.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在章节开头启动应用程序时安装了 *Reflux* 和名为 **Superagent** 的 HTTP 请求库，我们将使用它来获取我们的产品数据，所以我们可以立即开始使用
    *Reflux*。
- en: 'Let''s create our first store. Make two folders: `stores` and `actions`. Create
    two files, `stores/products.js` and `actions/products.js`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个存储。创建两个文件夹：`stores` 和 `actions`。创建两个文件，`stores/products.js` 和 `actions/products.js`。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Stores` and `Actions` are regular JavaScript files, and unlike the ReactJS
    components, they don''t use `.jsx` file ending.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stores` 和 `Actions` 是常规的 JavaScript 文件，并且与 ReactJS 组件不同，它们不使用 `.jsx` 文件扩展名。'
- en: 'In `actions/products.js`, add the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `actions/products.js` 中添加以下代码：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this file, we define a single key called **FetchProducts**. We then assign
    a Reflux action with the same name. It's possible to define a different name,
    but this will only lead to confusion later, so in order to keep the code base
    sane, it's advisable to duplicate the key name.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们定义了一个名为 **FetchProducts** 的单个键。然后我们分配了一个同名的 Reflux 动作。虽然可以定义不同的名称，但这可能会导致后续的混淆，因此为了保持代码库的整洁，建议重复键名。
- en: 'In `stores/products.js`, add the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `stores/products.js` 中添加以下代码：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we import the action that we just created along with `superagent` and
    `reflux`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入我们刚刚创建的动作以及 `superagent` 和 `reflux`：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `init()` method will be executed once and is run immediately on import.
    This means that it starts executing everything that you''ve put in `init()` as
    soon as the page is processed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()` 方法将只执行一次，并在导入时立即运行。这意味着它将立即执行你在 `init()` 中放入的所有内容：'
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we simply access `product.json`, and when it''s loaded, we emit the result
    to all those components that listen to updates from this store. Emits with Reflux
    is done using the `this.trigger()` built-in method and it emits the object that
    you pass within the parentheses:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地访问 `product.json`，当它加载时，我们将结果发出给所有监听这个存储更新的组件。使用 Reflux 的 `this.trigger()`
    内置方法发出，它发出括号内传递的对象：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that this is taken care of, the next step is to listen to updates from
    this store in our code. Open `layout.jsx` and add the following imports:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经处理好了这个问题，下一步是在我们的代码中监听这个存储的更新。打开 `layout.jsx` 并添加以下导入：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, add the following code just above the `render()` method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `render()` 方法之上添加以下代码：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is exciting because we're finally starting to populate our app with content.
    Whenever the store emits data now, this component will pick it up and propagate
    it to its children components via the state object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人兴奋，因为我们终于开始用内容填充我们的应用程序了。现在每当存储发出数据时，这个组件都会接收到并通过状态对象将其传播给其子组件。
- en: Building the product's listing and the item page
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建产品列表和项目页面
- en: The view we're going to build now will present users with a selection of your
    book titles. It will start with the main offering as a full-size column and then
    provide other offerings in three smaller columns.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要构建的视图将向用户展示您的书名选择。它将以一个全尺寸的主要产品列开始，然后提供三个较小的列中的其他产品。
- en: 'Let''s open `pages/products.jsx` and write code that will display the product''s
    data. Replace everything in the file with the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开 `pages/products.jsx` 文件，并编写显示产品数据的代码。将文件中的所有内容替换为以下代码：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We expect to receive a `data` property called products with two lists: a main
    offering and a sales offering. You''ll probably remember these from `products.json`,
    where we defined them. In our render code, we create a Bootstrap grid and create
    two nodes with a new component called **offerings**. We''re providing three properties
    to this component: a list of products, a type, and maximum amount of products
    that we want to display. In this context, `type` is a string and can be either
    `main` or `ribbon`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望接收到一个名为 `products` 的 `data` 属性，包含两个列表：一个主要产品和销售产品。您可能还记得这些内容来自 `products.json`，我们在其中定义了它们。在我们的渲染代码中，我们创建了一个
    Bootstrap 网格，并使用一个名为 **offerings** 的新组件创建了两个节点。我们向这个组件提供了三个属性：产品列表、类型以及我们想要显示的最大产品数量。在这个上下文中，`type`
    是一个字符串，可以是 `main` 或 `ribbon`：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `map` function, we have assigned a new property called **key**. This
    is to help ReactJS uniquely identify the components. Any component with a key
    will be reordered and reused in the rendering process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `map` 函数中，我们分配了一个新的属性名为 **key**。这是为了帮助 ReactJS 唯一地识别组件。任何带有 key 的组件都将在渲染过程中重新排序和复用。
- en: 'When you''re dealing with props, it''s usually a good idea to define a set
    of default properties for the data you want to work with. It''s also a way of
    documenting by writing easily understandable code. In this example, it''s very
    easy to infer just by looking at the property type and the default property that
    `maxProducts` defines the maximum number of products to be displayed. However,
    `type` is still hard to understand. As you know, it''s a string and can be `main`.
    Knowing that it also can be assigned as a *ribbon* is something that you need
    to read the rest of the source code to understand. In these cases, it may be helpful
    to provide the optional values in a docblock code. For instance, documenting this
    property can be done by adding a docblock like this: `@param {string} type "main"|"ribbon"`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理 props 时，通常定义一组默认属性来处理数据是个好主意。这也是通过编写易于理解的代码进行文档记录的一种方式。在这个例子中，仅通过查看属性类型和默认属性，就可以很容易地推断出
    `maxProducts` 定义了要显示的最大产品数量。然而，`type` 仍然难以理解。正如您所知，它是一个字符串，可以是 `main`。知道它也可以被分配为
    *ribbon* 是您需要阅读其余源代码才能理解的事情。在这些情况下，提供可选值在 docblock 代码中可能很有帮助。例如，通过添加如下 docblock
    来记录这个属性：`@param {string} type "main"|"ribbon"`。
- en: 'Reducing the product data is done by applying a `filter` function to the list
    of products and returning the first matches by the `index` value. We then run
    a `map` function on the remaining data and return either a `MainOffering` component
    if `type` is `main` or a `RibbonOffering` component if `type` is `ribbon`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对产品列表应用 `filter` 函数来减少产品数据，通过 `index` 值返回第一个匹配项。然后我们对剩余的数据运行 `map` 函数，如果 `type`
    是 `main`，则返回一个 `MainOffering` 组件；如果 `type` 是 `ribbon`，则返回一个 `RibbonOffering` 组件：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `MainOffering` component creates a full-sized column with a large product
    image to the left and it also creates a price, description, and a buy button to
    the right. The product image gets the 200 x 150 by way of replacing the `{size}`
    template with a `string` value. `Placehold.it` is a convient service that you
    can use to display a dummy image until you''ve got a real image to show. There
    are a number of such services online, ranging from the plain ones, such as `placehold.it`,
    to services showing dogs and cats to nature, technology, and architecture:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainOffering` 组件创建了一个全尺寸的列，左侧有一个大型的产品图片，同时也在右侧创建了一个价格、描述和购买按钮。产品图片通过将 `{size}`
    模板替换为一个 `string` 值来获得 200 x 150 的尺寸。`Placehold.it` 是一个方便的服务，您可以使用它来显示占位图，直到您有真实图片可以展示。网上有众多此类服务，从简单的，如
    `placehold.it`，到展示狗、猫、自然、科技和建筑的服务：'
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s worth mentioning here that in the `render()` method, we either return
    a ReactJS node or `null` if `this.props.productData` has a title. The reason that
    we do this is because when we mount the component, `productData` will be unpopulated.
    If we try to use the property at this point, ReactJS will return an error. It
    will be populated as soon as the data has been fetched in the *store*, and that
    may take a few milliseconds or it may take a bit long depending on a number of
    things, but primarily, it depends on latency, which means it''s very unlikely
    that the data is available when you mount the component. In any case, you shouldn''t
    rely on that, so it''s better to return nothing until the data is available:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得提一下，在`render()`方法中，如果`this.props.productData`有标题，我们要么返回一个ReactJS节点，要么返回`null`。我们这样做的原因是因为当组件挂载时，`productData`将是未填充的。如果我们此时尝试使用该属性，ReactJS将返回一个错误。一旦数据在*store*中获取，它就会填充，这可能需要几毫秒，也可能需要更长的时间，这取决于许多因素，但主要取决于延迟，这意味着在组件挂载时数据很可能不可用。无论如何，你不应该依赖这一点，所以最好在数据可用之前不返回任何内容：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We've defined a number of components in this file, but note that we only export
    the main one, called products. The other components will not be available via
    destructuring because they have not been exported.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个文件中定义了多个组件，但请注意，我们只导出主组件，称为products。其他组件不会通过解构获得，因为它们没有被导出。
- en: We've linked our items to the `item` page, so we need to flesh it out and retrieve
    the item data when the customer visits this page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将项目链接到`item`页面，因此我们需要完善它并在客户访问此页面时检索项目数据。
- en: 'Open `pages/item.jsx` and replace the content with this code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pages/item.jsx`并将内容替换为以下代码：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we take advantage of the fact that all of our products exist as a property
    to this page and that they simply return a filtered object list from the complete
    product list. The filter is based on `this.getParams().id`. This is a built-in
    *mixin* provided by `react-router`, which fetches the `id` key defined in `routes.jsx`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了所有产品都作为此页面的属性存在的事实，并且它们只是从完整的产品列表中返回一个过滤后的对象列表。过滤基于`this.getParams().id`。这是`react-router`提供的一个内置*mixin*，它获取在`routes.jsx`中定义的`id`键。
- en: 'A **mixin** is a piece of code that contains methods that can be included in
    other pieces of code without the use of inheritance. This is advantageous because
    it allows easy code injection and reuse. This has drawbacks as well because uncritical
    use of mixins can lead to confusion regarding the origin of the code you''re using:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**mixin**是一段包含可以在其他代码中包含而不使用继承的方法的代码。这很方便，因为它允许轻松的代码注入和重用。这也存在一些缺点，因为不加批判地使用mixins可能会导致你使用的代码来源混淆：'
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This return declaration checks the new object list for its length and either
    provides the item information or an information block informing the customer that
    the product couldn''t be found:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个返回声明检查新对象列表的长度，并提供项目信息或一个通知客户产品找不到的信息块：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The last piece of code prints out the product information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码打印出产品信息。
- en: 'This is how the final result should appear:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该如下所示：
- en: '![Building the product''s listing and the item page](img/B04943_02_02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![构建产品列表和项目页面](img/B04943_02_02.jpg)'
- en: The final piece of the puzzle adds the action that puts the item in your cart.
    For that, we need to make another action file and a cart store.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图部分添加了将项目放入购物车的动作。为此，我们需要创建另一个动作文件和一个购物车存储。
- en: Creating a cart store
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建购物车存储
- en: 'We''ll need to add two more files to our project, `actions/cart.js` and `store/carts.js`.
    Create these files and add this code to the `actions` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的项目中添加两个额外的文件，`actions/cart.js`和`store/carts.js`。创建这些文件并将以下代码添加到`actions`文件中：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We define three actions, one for adding items, one for removing them, and the
    third for clearing the cart.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个动作，一个用于添加项目，一个用于移除它们，第三个用于清空购物车。
- en: 'Open `store/carts.js` and add the following piece of code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`store/carts.js`并添加以下代码段：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is our `store` object. Initializing it outside `CartStore` itself makes
    it private and hidden, making it impossible to import `CartStore` and modify the
    `store` object directly. It''s customary, but not necessary, to prefix such objects
    with an underscore. It''s simply a way of indicating that we''re working with
    a `private` object:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`store`对象。在`CartStore`本身之外初始化它使其成为私有的和隐藏的，使得无法直接导入`CartStore`并修改`store`对象。通常，但不是必须的，在这样对象前加上下划线。这仅仅是一种表示我们正在处理一个`private`对象的方式：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These are the actions we''ll listen and respond to. Whenever any of the preceding
    actions are called in our code, the function that we connect to the action will
    be executed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将监听并响应的操作。每当在代码中调用前面的任何操作时，我们将连接到该操作的函数将被执行：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we call `CartActions.AddToCart` with an item in our code, this code will
    add the item to our `cart` object. We then call `this.emit()`, which is our store
    emitter. We could just as easily call `this.trigger` directly (which is the native
    `Reflux` function for emitting data), but having a single function responsible
    for emitting data is beneficial if you need to perform any functions or execute
    any code before emitting the data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中调用`CartActions.AddToCart`并传递一个项目时，此代码将项目添加到我们的`cart`对象中。然后我们调用`this.emit()`，这是我们的存储发射器。我们也可以直接调用`this.trigger`（这是原生的`Reflux`函数，用于发出数据），但如果你需要在发出数据之前执行任何函数或代码，有一个负责发出数据的单一函数是有益的：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This function removes an item from our `cart` object using the built-in `filter`
    function in JavaScript. The `filter` function returns a new array when called,
    excluding the item we want removed. We then simply emit the altered `cart` object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用JavaScript内置的`filter`函数从我们的`cart`对象中移除一个项目。`filter`函数在调用时返回一个新数组，排除了我们想要移除的项目。然后我们简单地发出修改后的`cart`对象：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This resets the cart and emits the empty `cart` object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重置购物车并发出空的`cart`对象：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this function, we emit the `cart` object. Any component that listens to
    this store will receive the object and render the new data:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们发出`cart`对象。任何监听此存储的组件都将接收到对象并渲染新数据：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also want to provide the user with some indication of the state of his/her
    cart, so open up `menu.jsx` and replace `NavItemLink` for the `Checkout` section
    with the following piece of code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望向用户提供一些关于其购物车状态的指示，所以打开`menu.jsx`并将`Checkout`部分的`NavItemLink`替换为以下代码片段：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Before `render()`, add a `defaultProps` section with this code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render()`之前，添加一个`defaultProps`部分并包含以下代码：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'All state changes go through `layout.jsx`, so open this file and add the following
    import:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有状态更改都通过`layout.jsx`进行，所以打开此文件并添加以下导入：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `mixins` section, add a listener for the `cart` store and the function
    that is to be run when the cart emits data. The code should now look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mixins`部分，添加对`cart`存储和当购物车发出数据时要运行的函数的监听器。现在的代码应该看起来像这样：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `Menu` component needs to receive the new state, so provide it with this
    code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu`组件需要接收新状态，所以提供以下代码：'
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we need to add the action to the **Add to cart** buttons. Edit `pages/products.jsx`
    and replace the button code in `MainOffering` and `RibbonOffering` with this code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将操作添加到**添加到购物车**按钮上。编辑`pages/products.jsx`并将`MainOffering`和`RibbonOffering`中的按钮代码替换为以下代码：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the following line of code to the imports section as well:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在导入部分添加以下代码行：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You're set. When you click on the **Add to cart** button in the products page
    now, the cart will be updated and the menu count will also be updated immediately.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经设置好了。现在当你点击产品页面上的**添加到购物车**按钮时，购物车将立即更新，菜单计数也将立即更新。
- en: '![Creating a cart store](img/B04943_02_03.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![创建购物车存储](img/B04943_02_03.jpg)'
- en: Checking out
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结账
- en: What good is a webshop if your customers cannot check out? After all, that's
    what they're here for. Let's set up a check out screen and let the customer enter
    a delivery address.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客户不能结账，那么网店有什么用呢？毕竟，他们来这里就是为了这个。让我们设置一个结账屏幕，并让客户输入一个送货地址。
- en: 'We need to create some new files: `stores/customer.js`, `actions/customer.js`,
    and `components/customerdata.jsx`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一些新的文件：`stores/customer.js`、`actions/customer.js`和`components/customerdata.jsx`。
- en: 'Open `actions/customer.js` and add this code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`actions/customer.js`并添加以下代码：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This single action will be responsible for address management.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的操作将负责地址管理。
- en: 'Next, open `stores/customer.js` and add this code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`stores/customer.js`并添加以下代码：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As in `cart.js`, here we define a `private` object to store the state of our
    store. As you can read from the object definition, we''ll store a customer list
    and a Boolean address validator. We will also import the customer action file
    that we just created:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`cart.js`中一样，我们在这里定义一个`private`对象来存储存储的状态。正如你可以从对象定义中读到的，我们将存储客户列表和布尔地址验证器。我们还将导入我们刚刚创建的客户操作文件：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You'll recognize the structure of this code from the `cart.js` file. We listen
    to the `SaveAddress` action and execute the connected function whenever the action
    is called. Finally, the emitter is called every time the state object is changed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `cart.js` 文件中识别出这段代码的结构。我们监听 `SaveAddress` 动作，并在动作被调用时执行连接的函数。最后，每当状态对象发生变化时，都会调用发射器。
- en: 'Before we edit the last new file, let''s open `checkout.jsx` and set up the
    code we need there. Replace the current content with this code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编辑最后一个新文件之前，让我们打开 `checkout.jsx` 并设置我们需要的代码。用以下代码替换当前内容：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We import two new functions from `React-Bootstrap` and two of the new files
    that we just created:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `React-Bootstrap` 导入两个新函数和两个我们刚刚创建的新文件：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In this section, we initialize the component with two properties: a `cart`
    array and a `customer` object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用两个属性初始化组件：一个 `cart` 数组和一个 `customer` 对象：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We define a Boolean variable that controls whether the checkout button is visible
    or not. Our requirements are simply that we want at least one item in our cart
    and that the customer has entered a valid name address.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个布尔变量来控制结账按钮是否可见。我们的要求很简单，我们希望购物车中至少有一件商品，并且客户已经输入了有效的姓名地址。
- en: 'We then display a simple message to our customer inside a Bootstrap well. Next,
    we display the cart contents (which we''ll define in the following code snippet),
    and then, we present a series of input fields where the customer can add an address.
    Finally, we display a button that takes the user to the payment window:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在 Bootstrap well 中向客户显示一条简单的消息。接下来，我们显示购物车内容（我们将在下面的代码片段中定义），然后，我们展示一系列输入字段，客户可以在其中添加地址。最后，我们显示一个按钮，将用户带到支付窗口：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Cart is another React component that takes care of displaying a table with the
    contents of the customer's cart, including a total amount for the order. We initialize
    a variable for the total amount and set it to zero. We then use the built-in `forEach`
    function in JavaScript to loop and walkthrough the `cart` contents and create
    an order total. Since the prices come with a dollar symbol from the JSON file,
    we need to strip out this before adding the sums (or else JavaScript would simply
    concatenate the strings). We also use `parseFloat` to convert the string into
    a float.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车是另一个 React 组件，负责显示包含客户购物车内容的表格，包括订单的总金额。我们初始化一个用于总金额的变量并将其设置为零。然后，我们使用 JavaScript
    内置的 `forEach` 函数遍历 `cart` 内容并创建订单总金额。由于价格从 JSON 文件中带有美元符号，我们需要在添加总和之前将其删除（否则 JavaScript
    将简单地连接字符串）。我们还使用 `parseFloat` 将字符串转换为浮点数。
- en: In reality, this is not an ideal solution because you don't want to use `float`
    values when working with prices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这不是一个理想的解决方案，因为你不想在处理价格时使用浮点数。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Try adding 0.1 and 0.2 with JavaScript to understand why (hint: it won''t equal
    0.3).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 JavaScript 将 0.1 和 0.2 相加，以了解原因（提示：它们不会等于 0.3）。
- en: 'The best solution is to use integers and divide by 100 whenever you want to
    display fractional values. For that reason, `products.json` could be updated to
    include a price field like this: `"display_price": "$21.90","price": "2190"`.
    Then, we''d work with `price` in our code, but use `display_price` in our views.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '最佳解决方案是使用整数，并在需要显示小数时除以 100。因此，`products.json` 可以更新为包含一个价格字段，如下所示：`"display_price":
    "$21.90","price": "2190"`。然后，我们在代码中使用 `price`，但在视图中使用 `display_price`。'
- en: 'Next, we walk through our cart content again, but this time using JavaScript''s
    built-in `map` function. We return a new array populated with `CartElement` nodes.
    We then render a table and insert the new array that we just created:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次遍历我们的购物车内容，但这次使用 JavaScript 内置的 `map` 函数。我们返回一个新数组，该数组包含 `CartElement`
    节点。然后我们渲染一个表格并插入我们刚刚创建的新数组：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `CartElement` component should look familiar to you with one exception,
    the `onClick` method has a bind. We do this because we want to pass along the
    product data when the customer clicks on the **Remove** button. The first element
    in the bind is the event and the second is the data. We don't need to pass along
    the event, so we simply set that to `null`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`CartElement` 组件应该对你很熟悉，只有一个例外，`onClick` 方法有一个绑定。我们这样做是因为我们想在客户点击**删除**按钮时传递产品数据。绑定中的第一个元素是事件，第二个是数据。我们不需要传递事件，所以我们将其简单地设置为
    `null`。'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下截图：
- en: '![Checking out](img/B04943_02_04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![结账](img/B04943_02_04.jpg)'
- en: 'We also need to add the code for `customerdata.jsx` so let''s open this file
    and add the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加 `customerdata.jsx` 的代码，让我们打开这个文件并添加以下代码：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This might look a bit complicated, but the idea here is that we'll set the customer
    name and address validation to the same as `this.props` if it exists, but if not,
    we use the default values of empty strings and set Boolean to `false` for address
    validation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点复杂，但这里的想法是，如果存在，我们将客户名称和地址验证设置为与`this.props`相同，如果不存在，我们使用空字符串的默认值，并将地址验证的布尔值设置为`false`。
- en: 'The reason we do this is that we want to display whatever data the customer
    has entered if he/she chooses to add data to the checkout screen, but then decides
    to visit another part of the store before proceeding to the checkout screen:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因是我们想显示客户如果选择在结账屏幕上添加数据，但后来决定在继续到结账屏幕之前访问商店的另一个部分时输入的数据。
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is the first of four similar sections that deal with input validation.
    The validation is only based on string length, but it can be replaced with any
    desired validation logic.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四个类似部分中的第一个，这些部分处理输入验证。验证仅基于字符串长度，但可以替换为任何所需的验证逻辑。
- en: In `handleChangeName`, we clone the state in a local variable (making sure we
    don't accidentally mutate the state manually), and then, we set the new value
    for the name from the input field. The input value is fetched via `refs`, which
    is a ReactJS concept. A reference can be set to any element and accessed via `this.refs`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleChangeName`中，我们克隆状态到一个局部变量（确保我们不会意外地手动修改状态），然后，我们从输入字段设置新的名称值。输入值通过`refs`获取，这是ReactJS的一个概念。可以将引用设置到任何元素，并通过`this.refs`访问。
- en: Next, on every change, we check all the validations that we've set up. If all
    are valid, we set the address validator to Boolean as `true`. Finally, we save
    the state and then run the action that will store the new address in the customer
    store. This change will be emitted to `layout.jsx`, which will then pass the data
    back to this component, and others which listens to the customer store.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在每次更改时，我们检查我们已设置的所有验证。如果所有验证都有效，我们将地址验证器设置为布尔值`true`。最后，我们保存状态，然后运行将新地址存储在客户存储中的操作。此更改将发出到`layout.jsx`，然后该文件将数据传回此组件以及其他监听客户存储的组件。
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This function returns Boolean as `true` or `false` depending on all validation
    checks:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据所有验证检查返回布尔值`true`或`false`。
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, we use the Bootstrap `FormGroup` and `FormControl` functions and set
    the styling based on the validation check. We set the `ref` parameter here that
    we use to access the value when we save the name in our customer store. Every
    time the input field is changed, it''s sent to the `onChange` handler, `handleChangeName`.
    The rest of the input fields are identical, except that they call upon different
    change handlers and validators:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Bootstrap的`FormGroup`和`FormControl`函数，并根据验证检查设置样式。我们在这里设置`ref`参数，我们使用它来访问在我们在客户存储中保存名称时的值。每次输入字段更改时，它都会发送到`onChange`处理程序，`handleChangeName`。其余的输入字段相同，只是它们调用不同的更改处理程序和验证器：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In order to propagate the changes in the new customer store from the layout
    to the children components, we need to make a change in `layout.jsx`. Open the
    file and add this import:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将新客户存储中的更改从布局传播到子组件，我们需要在`layout.jsx`中进行更改。打开文件并添加以下导入：
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, in the mixins, add this line of code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在mixins中添加以下代码行：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Providing a receipt
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供收据
- en: 'The next logical step is to take care of payment and provide a receipt for
    the customer. For payments, you need an account with a payment provider, such
    as **PayPal**, **Klarna**, **BitPay**, and so on. Integration is usually very
    straightforward, and it goes like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是处理支付并为客户提供一个收据。对于支付，您需要一个支付提供商的账户，例如**PayPal**、**Klarna**、**BitPay**等。集成通常非常直接，如下所示：
- en: You connect to a data API provided by the payment provider.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您连接到支付提供商提供的数据API。
- en: Transmit your API key and the order data.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传输您的API密钥和订单数据。
- en: After the payment process is finished, the payment provider will redirect to
    your receipt page and let you know whether the payment was successful or not.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支付过程完成后，支付提供商将重定向到您的收据页面，并告知支付是否成功。
- en: The connection to the payment API should be hooked up to the **Proceed to checkout**
    button. As the integration with a payment provider differs with every provider,
    we'll simply provide a receipt page without verifying the payment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将支付API的连接设置到**结账**按钮上。由于每个支付提供商的集成方式不同，我们将简单地提供一个收据页面而不验证支付。
- en: 'Open `checkout.jsx` and add the following import:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`checkout.jsx`并添加以下导入：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, replace the checkout button with this code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将结账按钮替换为以下代码：
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Open `receipt.jsx` and replace the content with this code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`receipt.jsx`文件，并用以下代码替换内容：
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we tap into the `history` method and notify it to send the customer to
    the home page if there's no cart data. This is a simple validation to check whether
    the customer has entered the receipt page outside the predefined path.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`history`方法并通知它，如果没有购物车数据，则将客户发送到主页。这是一个简单的验证，用于检查客户是否在预定义路径之外进入了收据页面。
- en: 'This solution is not very robust. When you set it up with a payment provider,
    you will send an identifier to the provider. You need to store this identifier
    and use this instead to decide whether to show the receipt page and what to show:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案并不非常健壮。当你与支付服务提供商设置时，你会向提供商发送一个标识符。你需要存储这个标识符，并使用它来决定是否显示收据页面以及显示什么内容：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We''re reusing code from the checkout page here to show the cart content and
    the order total. We''re also creating a new `OrderElement` component in order
    to display the list of items in the customer''s cart:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里重用了结账页面的代码来显示购物车内容和订单总额。我们还创建了一个新的`OrderElement`组件来显示客户购物车中的项目列表：
- en: '[PRE76]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![Providing a receipt](img/B04943_02_05.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![提供收据](img/B04943_02_05.jpg)'
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've finished our first blueprint, the webshop. You now have a fully functioning
    shop built with ReactJS. Let's take a look at what we've built in this chapter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了第一个蓝图，即网店。你现在拥有了一个使用ReactJS构建的完全功能性的商店。让我们看看在本章中我们构建了什么。
- en: First, we started detailing the components that we needed to create and made
    a basic mock-up of how we wanted the site to look. We wanted the design to be
    responsive and the content visible on a range of devices, from the smallest smart
    phones to tablets and desktop computers screens.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们详细说明了我们需要创建的组件，并制作了一个基本的原型，展示了我们希望网站的外观。我们希望设计能够响应式，内容能够在从最小的智能手机到平板电脑和桌面计算机屏幕的各种设备上可见。
- en: We then worked on the layout and chose to use Bootstrap to help us with the
    responsive functionality. We took the scaffolding from [Chapter 1](ch01.html "Chapter 1. Diving
    Headfirst into ReactJS"), *Diving Headfirst into ReactJS*, and extended it by
    adding a small number of node modules from the `npm` registry, chiefly, `react-router`,
    `react-bootstrap`, and the promise-based request library, `superagent`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们着手布局，并选择使用Bootstrap来帮助我们实现响应式功能。我们采用了[第1章](ch01.html "第1章。深入ReactJS")的脚手架，*深入ReactJS*，并通过添加来自`npm`注册表的一小部分节点模块来扩展它，主要是`react-router`、`react-bootstrap`和基于承诺的请求库`superagent`。
- en: We built the web shop based on the concept of unidirectional data flow, following
    the established Flux pattern where actions go back to the store and the store
    emits data to the components. Furthermore, we set it up so that all data is routed
    through the central app and propagated as properties to the child components.
    This is a powerful pattern because it leaves you with no uncertainty as to where
    your data originates from, and every part of your app has access to the same data
    with the same state.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于单向数据流的概念构建了网店，遵循了已建立的Flux模式，其中动作返回到存储库，存储库向组件发出数据。此外，我们还设置了所有数据都通过中央应用程序路由，并作为属性传播到子组件。这是一个强大的模式，因为它让你对数据的来源没有任何疑问，并且应用程序的每个部分都可以访问相同的数据和状态。
- en: While making the webshop, we resolved a number of technical hurdles, such as
    routing, form validation, and array filtering.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作网店的过程中，我们解决了许多技术难题，例如路由、表单验证和数组过滤。
- en: The final app is a basic working webshop that is ready to be developed and styled
    further.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的应用程序是一个基本的可工作的网店，可以进一步开发和设计。
- en: In the next chapter, we'll look at how to develop responsive apps with ReactJS!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用ReactJS开发响应式应用程序！
