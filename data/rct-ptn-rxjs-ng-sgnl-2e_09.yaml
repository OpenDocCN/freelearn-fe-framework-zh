- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Demystifying Multicasting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘多播
- en: '**Multicasting** refers to sharing the same Observable execution among multiple
    subscribers. This concept can be challenging to grasp initially, especially for
    those unfamiliar with reactive programming paradigms. However, it’s very useful
    and solves many problems in web applications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播**指的是在多个订阅者之间共享相同的 Observable 执行。这个概念最初可能难以理解，尤其是对于那些不熟悉响应式编程范式的人来说。然而，它非常有用，解决了许多
    Web 应用程序中的问题。'
- en: In this chapter, I will demystify this concept, explaining when and where to
    use it, how RxJS subjects are involved, and its advantages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将揭秘这个概念，解释何时何地使用它，RxJS 主题如何参与其中，以及它的优势。
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主要内容：
- en: Explaining multicasting versus unicasting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释多播与单播的区别
- en: Exploring RxJS subjects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 RxJS 主题
- en: Highlighting the advantages of multicasting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突出多播的优势
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of RxJS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对 RxJS 有基本的了解。
- en: All the source code in this chapter is used for demonstration purposes, so you
    don’t need access to this book’s GitHub repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码都是用于演示目的，因此您不需要访问本书的 GitHub 仓库。
- en: Explaining multicasting versus unicasting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释多播与单播的区别
- en: Before we get into explaining multicasting versus unicasting, let’s start by
    explaining another key concept, known as a producer, which we will be using a
    lot in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释多播与单播之前，让我们先解释另一个关键概念，即生产者，我们将在本章中大量使用这个概念。
- en: A **producer** is the source that produces the Observable values – for example,
    DOM events, WebSockets, and HTTP requests are considered producers. It is any
    data source that’s used to get values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产者** 是产生 Observable 值的来源——例如，DOM 事件、WebSockets 和 HTTP 请求被认为是生产者。它是任何用于获取值的
    数据源。'
- en: 'Observables fall into two types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Observables 分为两种类型：
- en: Cold, or unicast, Observables
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冷，或单播，Observables
- en: Hot, or multicast, Observables
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热的，或多播，Observables
- en: Let’s understand the difference between them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解它们之间的区别。
- en: Unicasting and cold Observables
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单播和冷 Observables
- en: A cold Observable in RxJS is like a personal storytelling session. Imagine you’re
    sharing a story with a friend. You narrate the story right there with them, and
    it’s unique to your interaction. Each time you share the story with a different
    friend, it’s like starting a new session with a fresh narrative.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 中，冷 Observable 就像是一个个人讲故事会话。想象一下你正在和一个朋友分享一个故事。你和他们一起讲述这个故事，这是你互动的独特体验。每次你和一个不同的朋友分享这个故事，就像开始了一个新的会话，有一个全新的叙述。
- en: 'In RxJS terms, this means that the Observable itself generates the data it
    emits. Each time someone subscribes to the Observable, they get a private storytelling
    session. The story (or data) isn’t shared between different listeners – it’s a
    one-on-one experience. This is why we call cold Observables “unicast” – each emitted
    value is observed by only one subscriber:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 术语中，这意味着 Observable 本身生成它发出的数据。每次有人订阅 Observable，他们都会得到一个私人的讲故事会话。故事（或数据）不会在不同听众之间共享——这是一个一对一的体验。这就是为什么我们称冷
    Observables 为“单播”——每个发出的值只被一个订阅者观察：
- en: '![Figure 9.1 – Unicast cold Observable](img/B21180_09_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 单播冷 Observable](img/B21180_09_1.jpg)'
- en: Figure 9.1 – Unicast cold Observable
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 单播冷 Observable
- en: So, by default, Observables in RxJS are cold – they create and deliver data
    to each subscriber individually, just like your personalized storytelling sessions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，默认情况下，RxJS 中的 Observables 是冷的——它们为每个订阅者创建和传递数据，就像您的个性化讲故事会话一样。
- en: 'Here’s an example of a cold Observable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个冷 Observable 的例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s break down what’s happening in this code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码中发生了什么。
- en: Here, `Math.random()` is our producer – it is called inside the Observable.
    So, data is produced by the Observable itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Math.random()` 是我们的生产者——它在 Observable 内部被调用。因此，数据是由 Observable 本身产生的。
- en: The first ubscriber will get two random values after the subscription, and the
    second subscriber will get two different values after the subscription. Every
    subscriber starts a new execution, leading to a new invocation of `Math.random()`,
    which results in distinct values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个订阅者在订阅后将会得到两个随机值，而第二个订阅者在订阅后将会得到两个不同的值。每个订阅者都会启动一个新的执行，导致 `Math.random()`
    的新调用，从而产生不同的值。
- en: Each subscriber gets its own unique set of items. It begins to emit items only
    after the observer subscribes to it. Since there are two different executions,
    every Observable will receive a different value. This means that data is unicast
    and not shared among the subscribers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个订阅者都得到自己独特的一组项目。它只在观察者订阅后才开始发出项目。由于有两个不同的执行，每个Observable都将接收到不同的值。这意味着数据是单播的，不会在订阅者之间共享。
- en: 'Briefly looking at a real-world example, when a user logs into an application,
    their personal profile or dashboard information is fetched and displayed. This
    data is unique to each user and should not be shared across multiple users. Using
    a cold Observable ensures that each user receives personalized data upon logging
    in, maintaining privacy and security. So, to summarize, for cold Observables,
    the following applies:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地看一个现实世界的例子，当用户登录应用程序时，他们的个人资料或仪表板信息会被检索并显示出来。这些数据对每个用户都是唯一的，不应该在多个用户之间共享。使用冷Observable确保每个用户在登录时都能收到个性化的数据，从而保持隐私和安全。所以，总结一下，对于冷Observable，以下适用：
- en: The Observable itself generates the data it emits
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observable本身生成它发出的数据
- en: It starts to emit data only after the observer subscribes to it
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只在观察者订阅后才开始发出数据
- en: Each observer (or subscriber) gets its own unique set of items
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个观察者（或订阅者）都得到自己独特的一组项目
- en: Now, let’s look at hot Observables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看热Observable。
- en: Multicasting and hot Observables
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播和热Observable
- en: Multicasting in RxJS is like hosting a live radio show. Imagine you’re broadcasting
    a show from a studio, and listeners can tune in at any time to hear the same content.
    Once you start broadcasting, anyone who tunes in can hear the same music, interviews,
    or discussions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS中，多播就像举办一场现场广播节目。想象一下，你从演播室播出节目，听众可以在任何时候调谐收听相同的内容。一旦开始播出，任何调谐收听的听众都能听到相同的音乐、访谈或讨论。
- en: 'In RxJS terms, a hot or multicast Observable is an Observable whose emitted
    values are shared among subscribers. There’s a single source of data, just like
    the radio station broadcasting content. When you subscribe to a multicasting Observable,
    you’re joining the “broadcast,” and you’ll receive the same data as anyone else
    who’s tuned in:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS术语中，热或多播Observable是一个其发出的值在订阅者之间共享的Observable。有一个单一的数据源，就像广播电台播出内容一样。当你订阅一个多播Observable时，你加入了“广播”，你将收到与其他调谐收听的任何人相同的数据：
- en: '![Figure 9.2 – Multicast hot Observable](img/B21180_09_2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 多播热Observable](img/B21180_09_2.jpg)'
- en: Figure 9.2 – Multicast hot Observable
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 多播热Observable
- en: Unlike cold Observables, where each subscriber gets a private session, multicasting
    allows multiple subscribers to listen to the same stream of data simultaneously.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个订阅者都得到一个私有会话的冷Observable不同，多播允许多个订阅者同时收听相同的数据流。
- en: 'Here’s an example of a hot Observable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个热Observable的例子：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s break down what’s happening in this code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这段代码中发生的事情。
- en: We created an Observable using the `fromEvent` function of RxJS. This Observable
    will emit clicks happening on the DOM document when subscribing to.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用RxJS的`fromEvent`函数创建了一个Observable。当订阅时，这个Observable将发出DOM文档上的点击事件。
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about `fromEvent`, please refer to [https://rxjs.dev/api/index/function/fromEvent](https://rxjs.dev/api/index/function/fromEvent).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`fromEvent`的更多详细信息，请参阅[https://rxjs.dev/api/index/function/fromEvent](https://rxjs.dev/api/index/function/fromEvent)。
- en: In this case, the data is emitted outside the Observable and, as you may have
    guessed, both subscribers will get the same data. This means that the subscribers
    share the same instance of the DOM click event. So, the hot Observable shares
    data between multiple subscribers. We call this behavior multicasting. In other
    words, the Observable multicasts to all subscribers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据是在Observable外部发出的，正如你可能猜到的，两个订阅者将获得相同的数据。这意味着订阅者共享相同的DOM点击事件实例。因此，热Observable在多个订阅者之间共享数据。我们称这种行为为多播。换句话说，Observable对所有订阅者进行多播。
- en: Looking at another real-world scenario, consider a chat application where you
    might have a global chat service that exposes a hot Observable representing the
    stream of incoming messages from all users in the chat room. Multiple components,
    such as message feeds and notifications, can subscribe to this hot Observable
    to display new messages in real-time without needing to create separate Observables
    for each component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个现实世界的场景，比如一个聊天应用，您可能有一个全局聊天服务，该服务公开一个热Observable，表示来自聊天室中所有用户的消息流。多个组件，如消息源和通知，可以订阅这个热Observable以实时显示新消息，而无需为每个组件创建单独的Observables。
- en: 'So, to summarize, for hot Observables, the following applies:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，对于热Observables，以下规则适用：
- en: Data is produced outside the Observable
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是在Observable外部产生的
- en: It may begin emitting items as soon as it is created
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能一创建就开始发射项目
- en: The emitted items are shared between the subscribers (multicasting)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射的项目在订阅者之间共享（多播）
- en: Transforming cold Observables into hot Observables
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将冷Observables转换为热Observables
- en: If we want to transform the cold Observable into a hot one, we have to move
    the producer outside the Observable – this way, our subscribers will receive the
    same data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将冷Observable转换为热Observable，我们必须将生产者移出Observable之外——这样，我们的订阅者将接收到相同的数据。
- en: 'Let’s revisit our example with the cold Observable. Instead of generating values
    within the Observable, we’ll pre-calculate the value by using `Math.random()`
    outside the Observable, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的冷Observable示例。我们不会在Observable内部生成值，而是在Observable外部使用`Math.random()`预先计算值，如下所示：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you may have noticed, after executing this code, all subscribers receive
    the same pre-calculated value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，执行此代码后，所有订阅者都接收到相同的预先计算值。
- en: 'Now, before we wrap up this section, let’s just quickly summarize unicasting
    and multicasting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们结束本节之前，让我们快速总结一下单播和多播：
- en: You should use *unicasting* when you want each subscriber to own independent
    executions and separate data streams for each subscriber.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想要确保每个订阅者拥有独立的执行和为每个订阅者提供独立的数据流时，应该使用*单播*。
- en: On the other hand, you should use *multicasting* when you want to make sure
    multiple subscribers share the same execution and results, particularly in scenarios
    involving hot Observables, broadcasting, or caching results.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，当您想要确保多个订阅者共享相同的执行和结果时，应该使用*多播*，尤其是在涉及热Observables、广播或缓存结果的场景中。
- en: Multicasting also helps optimize and improve performance when executing data
    is expensive. As a quick final example, suppose that the Observable’s execution
    is issuing a network request. If we choose a cold Observable (or unicasting),
    then a network request will be raised for every subscriber. Instead, multicasting
    is a better fit for this particular scenario as it will share the execution of
    the network requests among subscribers and consequently avoid redundant request
    calls.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多播还有助于在执行数据昂贵时优化和改进性能。作为一个快速的最终例子，假设Observable的执行是发起一个网络请求。如果我们选择冷Observable（或单播），那么每个订阅者都会发起一个网络请求。相反，多播更适合这种特定场景，因为它将在订阅者之间共享网络请求的执行，从而避免冗余的请求调用。
- en: Now that we understand multicasting and hot Observables, let’s explore the most
    popular ways to multicast values to observers in RxJS, namely RxJS subjects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了多播和热Observables，让我们来探索在RxJS中将值多播给观察者的最流行方式，即RxJS subjects。
- en: Exploring RxJS subjects
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索RxJS subjects
- en: '**Subjects** are special types of Observables. While plain Observables are
    unicast, subjects are multicast, allowing values to be broadcast to all subscribers.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Subjects**是特殊类型的Observables。而普通的Observables是单播的，subjects是多播的，允许值被广播给所有订阅者。'
- en: 'You can consider subjects as observers and Observables at the same time:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将subjects视为同时是观察者和Observables：
- en: 'You can subscribe to subjects to get values emitted by the producer (that’s
    why they act as Observables):'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以订阅subjects以获取生产者发出的值（这就是为什么它们充当Observables）：
- en: '![Figure 9.3 – An RxJS subject](img/B21180_09_3.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – RxJS subject](img/B21180_09_3.jpg)'
- en: Figure 9.3 – An RxJS subject
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – RxJS subject
- en: 'You can send values, errors, and completes by using the `next`, `error`, and
    `complete` methods that are available in the `Observer` interface (that’s why
    they act as observers):'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用`Observer`接口中可用的`next`、`error`和`complete`方法来发送值、错误和完成信号（这就是为什么它们充当观察者的原因）：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In short, a subject maintains a list of subscribers and notifies them when a
    new value is emitted. But to go a bit deeper, there are multiple types of subjects
    in RxJS. Let’s explore the most used ones.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，主题维护一个订阅者列表，并在新值发出时通知他们。但要深入一点，RxJS中有多种主题类型。让我们探索最常用的几种。
- en: A plain subject
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个普通主题
- en: '`plainSubject` is the parent type of all subjects. Let’s see a quick example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`plainSubject`是所有主题的父类型。让我们看一个快速示例：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we created `plainSubject$`, which emitted `10` and `20`
    as values. Afterward, we created two subscribers that logged the incoming values,
    the errors, and the completion of the stream. Finally, `plainSubject$` emitted
    a value of `30`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了`plainSubject$`，它发出了`10`和`20`作为值。之后，我们创建了两个订阅者，它们记录了传入的值、错误和流的完成。最后，`plainSubject$`发出了一个值为`30`的值。
- en: After executing this code, notice that only `30` is traced twice in the console.
    This means that the subscribers only received `30`. Why have they not received
    `10` and `20`? Because those values were emitted before the subscription to `plainSubject$`
    and every emission that occurs before the subscription will get lost. This is
    how a regular subject multicasts values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，请注意，在控制台中只有`30`被追踪了两次。这意味着订阅者只接收到了`30`。为什么他们没有收到`10`和`20`？因为那些值是在订阅`plainSubject$`之前发出的，并且每个在订阅之前发生的发射都会丢失。这就是普通主题多播值的方式。
- en: And that’s how plain subjects behave and emit values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是普通主题的行为和值发射方式。
- en: You can use subjects as a communication hub in your web application to share
    data between different Angular components, as we explored in [*Chapter 7*](B21180_07.xhtml#_idTextAnchor107),
    *Sharing Data between* *Angular Components*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的Web应用程序中将主题用作通信中心，在Angular组件之间共享数据，正如我们在[*第7章*](B21180_07.xhtml#_idTextAnchor107)中探讨的，*在Angular组件之间共享数据*。
- en: Moreover, subjects can be used to manage the authentication state in a web application.
    For instance, you can use a subject to emit a value whenever the user logs in
    or logs out. This emitted value can then be used to conditionally display certain
    components or trigger specific behaviors based on the user’s authentication status.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，主题可以用来管理Web应用程序中的认证状态。例如，你可以使用主题在用户登录或登出时发出一个值。这个发出的值可以用来有条件地显示某些组件或根据用户的认证状态触发特定的行为。
- en: If you want to keep a buffer of previous values emitted to subscribers coming
    late to the game, then `ReplaySubject` can help!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为后来加入游戏的用户保留之前发出的值的缓冲区，那么`ReplaySubject`可以帮到你！
- en: replaySubject
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: replaySubject
- en: '`replaySubject` is a subject variant, similar to `plainSubject`, but with an
    in-memory feature: they remember and replay previous messages to new subscribers.
    Replay subjects have a memory.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`replaySubject`是一种主题变体，类似于`plainSubject`，但具有内存功能：它们会记住并重放给新订阅者的之前的消息。重放主题有内存。'
- en: 'Let’s explain how it works by exploring the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来解释它是如何工作的：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, all the values were replayed to the new subscribers. Now, to
    control the buffer size (the number of values you want the `Replay` subject to
    store), you can pass it as a parameter when creating `ReplaySubject`, like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有值都被重放给了新的订阅者。现在，为了控制缓冲区大小（你希望`Replay`主题存储的值的数量），你可以在创建`ReplaySubject`时将其作为参数传递，如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will only replay the last two values. The console output will be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会重放最后两个值。控制台输出将如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As a real-world use case, let’s consider a chat application where a user joins
    the chat room late. With `ReplaySubject`, they can still see previous messages
    that were sent before they joined. This is useful for providing a complete chat
    history to new users.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际应用案例，让我们考虑一个用户晚些时候加入聊天室的情况。使用`ReplaySubject`，他们仍然可以看到在他们加入之前发送的之前的消息。这对于向新用户提供完整的聊天历史非常有用。
- en: With that, let’s move on to the other variant of `Subject` – `BehaviorSubject`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们继续探讨`Subject`的另一个变体——`BehaviorSubject`。
- en: BehaviorSubject
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BehaviorSubject
- en: '`BehaviorSubject` is just `ReplaySubject` with a buffer size equal to one,
    so it can only replay only previous item. We used `BehaviorSubject` in [*Chapter
    5*](B21180_05.xhtml#_idTextAnchor083), *Combining Streams*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`只是`ReplaySubject`，缓冲区大小等于一，因此它只能重放之前的项。我们在[*第5章*](B21180_05.xhtml#_idTextAnchor083)中使用了`BehaviorSubject`，*组合流*。'
- en: '`BehaviorSubject` requires an initial value and always retains the last value
    so that it can emit it to new subscribers. In other words, if you have any subscribers
    coming late to the game, they will get the previous value that was emitted by
    the stream. This will always give you value when you subscribe.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 需要一个初始值，并且总是保留最后一个值，以便它可以将其发射给新的订阅者。换句话说，如果你有任何后来加入的订阅者，他们将获得流中之前发射的值。这将在你订阅时始终给你带来价值。'
- en: 'Here’s an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `behaviourSubject$` is created and has an initial value of `1`. Then,
    `behaviourSubject` emitted `10`, `20`, and `50`, respectively. Right after we
    subscribed two times to `behaviourSubject$`, both subscribers will immediately
    receive the last value emitted by `behaviourSubject$`, which is `50` – that’s
    why `50` is traced two times in the console. Finally, `behaviourSubject$` emitted
    `30`; consequently, the subscribers will receive `30` and trace it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`behaviourSubject$` 被创建并具有初始值 `1`。然后，`behaviourSubject` 分别发射了 `10`、`20`
    和 `50`。在我们两次订阅 `behaviourSubject$` 后，两个订阅者将立即接收到 `behaviourSubject$` 发射的最后一个值，即
    `50` —— 这就是为什么在控制台中 `50` 被追踪两次的原因。最后，`behaviourSubject$` 发射了 `30`；因此，订阅者将接收到 `30`
    并追踪它。
- en: 'If no values were emitted before the subscription, then `behaviourSubject$`
    will emit the initial value, which is `1`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在订阅之前没有发射任何值，那么 `behaviourSubject$` 将发射初始值，即 `1`：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As another example, imagine that you’re building a weather app that displays
    the current temperature. You can use `BehaviorSubject` to represent the temperature
    data. Whenever the temperature changes, you update `BehaviorSubject` with the
    new value. Subscribers to `BehaviorSubject` will always receive the latest temperature,
    even if they start using the app after the temperature has changed multiple times.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，想象你正在构建一个显示当前温度的天气应用。你可以使用 `BehaviorSubject` 来表示温度数据。每当温度发生变化时，你都会用新值更新
    `BehaviorSubject`。`BehaviorSubject` 的订阅者将始终接收到最新的温度，即使他们在温度多次变化后才开始使用应用。
- en: To summarize, `PlainSubject`, `BehaviorSubject`, and `ReplaySubject` are the
    most used subjects in RxJS, which is why we discussed them here. However, there
    are other types of subjects, such as `WebSocketSubject`, which are used much less
    (though we will explore that one more in [*Chapter 12*](B21180_12.xhtml#_idTextAnchor180),
    *Processing Real-Time Updates*). For details about the other types, refer to [https://rxjs.dev/guide/subject](https://rxjs.dev/guide/subject).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`PlainSubject`、`BehaviorSubject` 和 `ReplaySubject` 是 RxJS 中使用最频繁的主题，这就是为什么我们在这里讨论它们。然而，还有其他类型的主题，例如
    `WebSocketSubject`，使用得较少（尽管我们将在 [*第 12 章*](B21180_12.xhtml#_idTextAnchor180)，*处理实时更新*）中进一步探讨。有关其他类型的详细信息，请参阅
    [https://rxjs.dev/guide/subject](https://rxjs.dev/guide/subject)。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are also many useful RxJS operators for multicasting (or sharing values/executions)
    in RxJS 6, namely `multicast`, `publish`, `share`, `shareReplay`, `publishReplay`,
    `publishLast`, and `refcount`. For more details about these operators, you can
    check the official docs: [https://rxjs.dev/api/operators](https://rxjs.dev/api/operators).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 6 中，也有许多用于多播（或共享值/执行）的有用 RxJS 操作符，即 `multicast`、`publish`、`share`、`shareReplay`、`publishReplay`、`publishLast`
    和 `refcount`。有关这些操作符的更多详细信息，您可以查看官方文档：[https://rxjs.dev/api/operators](https://rxjs.dev/api/operators)。
- en: In version 7, multicasting operators were consolidated to `share`, `connectable`,
    and `connect`. The other multicasting APIs are now deprecated and will be deleted
    in RxJS 8\. The only operator that wasn’t deprecated is `shareReplay` because
    it is very popular. It is now a wrapper around the highly configurable `share`
    operator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 7 中，多播操作符被合并为 `share`、`connectable` 和 `connect`。其他多播 API 现已弃用，将在 RxJS 8
    中删除。唯一未被弃用的操作符是 `shareReplay`，因为它非常受欢迎。现在它是一个围绕高度可配置的 `share` 操作符的包装器。
- en: Since we are using RxJS 7 in this book, I think it is useless to go through
    all the deprecated operators. Instead, we focus on the `share` operator as it
    satisfies most cases. We will learn the behavior of the `share` operator by considering
    a real-world use case in the next chapter, [*Chapter 10*](B21180_10.xhtml#_idTextAnchor159),
    *Boosting Performance with* *Reactive Caching*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本书中使用 RxJS 7，我认为遍历所有已弃用的操作符是无用的。相反，我们专注于 `share` 操作符，因为它满足大多数情况。我们将在下一章，[*第
    10 章*](B21180_10.xhtml#_idTextAnchor159)，*通过响应式缓存提升性能*中，通过考虑一个现实世界的用例来学习 `share`
    操作符的行为。
- en: For details about RxJS 7 multicasting operators, refer to [https://rxjs.dev/deprecations/multicasting](https://rxjs.dev/deprecations/multicasting).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 RxJS 7 多播操作符的详细信息，请参阅 [https://rxjs.dev/deprecations/multicasting](https://rxjs.dev/deprecations/multicasting)。
- en: Now that you have a good understanding of multicasting and the different ways
    of implementation provided by RxJS, let’s explore the main advantages of multicasting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经很好地理解了多播以及 RxJS 提供的不同实现方式，让我们来探讨多播的主要优点。
- en: Highlighting the advantages of multicasting
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出多播的优点
- en: 'Multicasting in RxJS or having the ability to share the same Observable execution
    among multiple subscribers has many advantages. Here are some key ones:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 中进行多播或能够在多个订阅者之间共享相同的 Observable 执行有许多优点。以下是一些关键点：
- en: '*Optimizing resources*: Multicasting helps optimize resources by avoiding redundant
    treatments. When dealing with expensive operations such as raising HTTP networks
    or performing complex computations, multicasting helps you do the work once and
    share the results among all subscribers.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优化资源*: 多播通过避免冗余处理来帮助优化资源。在处理昂贵的操作，如建立 HTTP 网络或执行复杂计算时，多播可以帮助您一次完成工作，并将结果共享给所有订阅者。'
- en: '*Consistent data and results*: Multicasting ensures that all subscribers receive
    the same set of values emitted by the Observable. This can be crucial in scenarios
    where consistency in data is essential, and you want all subscribers to observe
    the same data sequence.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致的数据和结果*: 多播确保所有订阅者都接收到由 Observable 发出的相同值集。在数据一致性至关重要的场景中，您希望所有订阅者观察相同的数据序列时，这可能至关重要。'
- en: '*Broadcasting*: Multicasting gives you the possibility to send, once and for
    all, the same set of values to multiple subscribers at the same time. This is
    what we call broadcast, and it is beneficial when you have a complex application
    with multiple components that need to react to the same set of values.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*广播*: 多播使您能够一次性将同一组值发送给多个订阅者。这就是我们所说的广播，当您有一个具有多个组件的复杂应用程序，这些组件需要响应同一组值时，这非常有用。'
- en: '*Late subscribers*: Multicasting allows late subscribers to receive the same
    values as subscribers who joined earlier. This is achieved by using `BehaviorSubject`
    and `ReplaySubject`, plus some multicast RxJS operators such as the `shareReplay`
    operator, something we will explain in [*Chapter 10*](B21180_10.xhtml#_idTextAnchor159),
    *Boosting Performance with* *Reactive Caching*.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*迟到订阅者*: 多播允许迟到订阅者接收与较早加入的订阅者相同的值。这是通过使用 `BehaviorSubject` 和 `ReplaySubject`
    以及一些多播 RxJS 操作符（例如 `shareReplay` 操作符）来实现的，我们将在 [*第10章*](B21180_10.xhtml#_idTextAnchor159)
    中解释，*通过响应式缓存提升性能*。'
- en: 'When designing applications with RxJS, multicasting is a powerful mechanism
    that should be put on the table because it enhances performance, efficiency, consistency,
    and interaction between the different parts of your app. However, it’s essential
    to use multicasting carefully and be aware of potential pitfalls, depending on
    your specific use case. Here are some examples:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 RxJS 设计应用程序时，多播是一个强大的机制，应该被考虑，因为它增强了应用程序不同部分之间的性能、效率、一致性和交互。然而，根据您的具体用例，谨慎使用多播并意识到潜在的风险是至关重要的。以下是一些例子：
- en: '*Data alteration*: Multicasting inherently shares the same data stream across
    all subscribers. If a subscriber modifies the data within its subscription logic
    (for example, using operators such as `map` or `filter`), this modification can
    unintentionally affect what other subscribers receive. This can lead to unexpected
    behavior and debugging challenges.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据修改*: 多播本质上会在所有订阅者之间共享相同的数据流。如果一个订阅者在它的订阅逻辑中修改了数据（例如，使用 `map` 或 `filter`
    等操作符），这种修改可能会无意中影响其他订阅者接收到的数据。这可能导致意外的行为和调试挑战。'
- en: For example, imagine a multicast Observable emitting a list of products. A component
    subscribes and filters the list to only show products with discounts. However,
    this filtering modifies the original data stream. If another component later subscribes,
    expecting the complete product list, it will only receive the discounted products
    due to the unintended modification in the first subscription. That’s why keeping
    the subject private and exposing only the read-only part of the data through the
    `asObservable()` method is a common and effective practice. This ensures that
    external components or consumers cannot directly modify the internal state of
    the subject. Instead, they can only observe the emitted values without interfering
    with the data stream.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，想象一个多播Observable发射产品列表。一个组件订阅并过滤列表，只显示有折扣的产品。然而，这种过滤修改了原始数据流。如果稍后另一个组件订阅，期望获得完整的产品列表，它将只会收到由于第一次订阅中的意外修改而导致的折扣产品。这就是为什么将主题保持私有，并通过`asObservable()`方法仅公开数据的只读部分是一种常见且有效的做法。这确保了外部组件或消费者不能直接修改主题的内部状态。相反，他们只能观察发射的值，而不干扰数据流。
- en: '*Memory leaks*: Unlike unicast Observables, which complete after a single subscriber
    unsubscribes, multicasting continues emitting data so long as at least one subscriber
    remains. This can lead to memory leaks if you’re not careful about managing subscriptions,
    especially when dealing with infinite or long-lived Observables.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存泄漏*：与单播Observables不同，单播Observables在单个订阅者取消订阅后即完成，而多播Observables只要至少有一个订阅者存在就会继续发射数据。如果你不仔细管理订阅，这可能会导致内存泄漏，尤其是在处理无限或长期存在的Observables时。'
- en: For example, imagine a multicast Observable that emits real-time stock prices.
    If components subscribe to this Observable but don’t unsubscribe when they are
    no longer needed, the Observable will continue emitting, potentially causing memory
    leaks as references to the Observable and its internal state accumulate.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，想象一个发射实时股票价格的多播Observable。如果组件订阅了这个Observable，但在不再需要时没有取消订阅，Observable将继续发射，这可能导致由于Observable及其内部状态的引用积累而引起的内存泄漏。
- en: We will explore other multicasting pitfalls and best practices in the next chapters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨其他多播陷阱和最佳实践。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I walked you through the most important concepts and vocabulary
    to understand multicasting. We started by explaining the role of a producer, after
    which we learned the difference between cold and hot Observables, leading us to
    the definition of multicasting and unicasting. Then, we explored RxJS subjects,
    the different types of subjects, and the use cases of each before introducing
    multicasting operators in RxJS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向您介绍了理解多播最重要的概念和词汇。我们首先解释了生产者的角色，然后学习了冷Observables和热Observables之间的区别，这使我们到达了多播和单播的定义。然后，我们探讨了RxJS的主题，不同类型的主题以及每种主题的使用案例，在介绍RxJS中的多播操作符之前。
- en: In the next chapter, we’ll practice all of this in a real-world use case. We
    will learn how to put an efficient mechanism of caching in place in our Recipe
    app by using multicasting in RxJS and, more specifically, by combining multicasting
    operators and subjects.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在一个实际用例中练习所有这些内容。我们将学习如何通过在RxJS中使用多播，更具体地说，通过结合多播操作符和主题，在我们的食谱应用中实施一个高效的缓存机制。
