- en: BuckleScript, Belt, and Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a closer look at the BuckleScript-specific features
    that are available to us. We''ll also learn about recursion and recursive data
    structures. By the end of this chapter, we''ll have come full circle in the introduction
    to Reason and its ecosystem. In doing so, we''ll have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned more about Reason's module system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored more of Reason's primitive data structures (arrays and lists)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seen how the various pipe operators can make code more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Become familiar with the Reason and Belt standard libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created bindings to a JavaScript module for use within Reason
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added route transitions to our application by binding to React Transition Group
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To follow along, use any environment you wish. Much of what we'll be doing is
    not ReasonReact-specific. Toward the end of the chapter, we'll resume building
    our ReasonReact app.
  prefs: []
  type: TYPE_NORMAL
- en: Module scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you now know, all `.re` files are modules and all modules are globally available—including
    nested ones. By default, all types and bindings can be accessed from anywhere
    by providing the namespace. However, doing this over and over quickly becomes
    tedious. Luckily, we have a few ways to make this more pleasant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll use the `Foo` module''s `fromFoo` type along with it''s bindings
    within another module in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1**: Without any sugar:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 2**: Alias the module to a shorter name. For example, we can declare
    a new module `F` and bind it to the existing module `Foo`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 3**: Locally open the module using the `Module.()` syntax. This syntax
    only works with a single expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 4**: In the OOP sense, have `Bar` extend `Foo` using `include`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Option 5**: Globally `open` the module. Use `open` sparingly in large scopes,
    since it becomes hard to know which types and bindings belong to which modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Prefer using `open` in local scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding syntax will reformat (via `refmt`) to Option 3''s syntax, but
    remember that Option 3''s syntax only works with single expressions. For example,
    the following isn''t able to be converted into Option 3''s syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Reason standard library is found within a variety of modules that are already
    available to us. For example, Reason's standard library includes an `Array` module,
    and we can access its functions using the dot notation (that is, `Array.length`).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we'll learn how to hide a module's types and bindings so that they aren't globally
    available if we don't want them to be.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen several of Reason's primitive data structures including strings,
    integers, floats, tuples, records, and variants. Let's explore a few more.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason arrays compile to regular JavaScript arrays. Reason arrays are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Homogeneous (all elements must be of the same type)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast at random access and updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing and updating elements of an array are the same as in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, we map over the array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To do the same in Reason, we have a few different options.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Reason standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reason standard library''s `Array` module contains several functions, but
    not all the ones you''d expect coming from JavaScript. It does have a `map` function,
    however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `Array.map` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The type signature says `map` accepts a function of type `''a => ''b`, an array
    of type `''a`, and returns an array of type `''b`. Note that, `''a` and `''b`
    are **type variables**. Type variables are like normal variables, except for types.
    In the preceding example, `map` has a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `'a` and `'b` type variables were both consistently replaced
    with the concrete `string` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, when using `Array.map`, the compiled output does not compile to
    JavaScript''s `Array.prototype.map`—it has its own implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Reason standard library documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reasonml.github.io/api](https://reasonml.github.io/api)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Belt standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reason standard library is actually the OCaml standard library. It was
    not created with JavaScript in mind. The Belt standard library was created by
    the same person who created BuckleScript—Hongbo Zhang—and ships with BuckleScript.
    Belt was made with JavaScript in mind and is especially known for its performance.
    The Belt standard library is accessed via the `Belt` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The Belt standard library documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.html](https://bucklescript.github.io/bucklescript/api/Belt.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using BuckleScript's built-in JavaScript bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another great option is to use BuckleScript''s built-in JavaScript bindings,
    found in the `Js` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This option has the advantage of not requiring any dependencies in the compiled
    output. It also has a very familiar API. However, since not all Reason data structures
    exist in JavaScript, you'll likely be using a standard library. If so, prefer
    Belt.
  prefs: []
  type: TYPE_NORMAL
- en: 'BuckleScript''s binding documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Js.html](https://bucklescript.github.io/bucklescript/api/Js.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s nothing stopping you from writing your own custom bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you should favor using the built-in bindings in the `Js` module instead.
    We'll explore more custom bindings later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using raw JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A last-resort option is to use actual JavaScript within Reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: BuckleScript lets us drop into raw JavaScript as a way to stay productive while
    we're learning. Of course, when doing this, we give up the safety that Reason
    provides us with. So, once you are ready, convert any raw JavaScript code back
    into more idiomatic Reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to using raw JavaScript, use `%` for expressions and `%%` for
    statements. Remember, the `{| |}` is Reason''s multiline string syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the raw expression syntax, we''re also able to annotate types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even annotate function types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although arrays are familiar when coming from JavaScript, you'll likely find
    yourself using lists instead, as they are ubiquitous in functional programming.
    Lists are both immutable and recursive. Let's now see how to use this recursive
    data structure.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason lists are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Homogeneous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast at prepending and accessing the head of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The head of the list, in this case, is `"first"`. By now, we've seen that it's
    not difficult to work with immutable data structures. Instead of mutation, we
    create updated copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with lists, we can''t use JavaScript bindings directly, since
    lists do not exist in JavaScript as a primitive data structure. However, we can
    convert lists to arrays and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also map over a list directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Logging `list` to the console shows that lists are represented as nested arrays
    in JavaScript where each array always has two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This makes sense after understanding that a list is a recursive data structure.
    Reason lists are **singly linked lists**. Each element in a list is either **empty**
    (represented as `0` in JavaScript) or the **combination** of a value and another
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example type definition for `list` reveals that `list` is a variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: type definitions can be recursive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason provides some syntactic sugar that simplifies its more verbose version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since list is a recursive data structure, we typically use recursion when working
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get warmed up, let''s write a (naive) function that sums a list of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a recursive function and therefore requires the `rec` keyword (that
    is, `let rec` instead of just `let`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can pattern match on a list (just like any other variant and many other data
    structures)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the example type definition, `Empty` is represented as `[]` and `Head` is
    represented as `[hd, ...tl]` where `hd` is the **head** of the list and `tl` is
    the rest (that is, the **tail**) of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tl` could be `[]` (that is, `Empty`) and when it is, recursion stops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passing `sum` the list `[1, 2, 3]` results in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get a bit more comfortable with lists and recursion by analyzing another
    (naive) function that reverses a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use `rec` to define a recursive function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we use pattern matching on the list—if it's empty, stop recursion; otherwise,
    continue with a smaller list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@` operator appends the second list to the end of the first list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passing in the previously defined list (`["first", "second", "third"]`) results
    in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation of reverse is naive for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It's not tail call optimized (nor is our `sum` function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses `append` (`@`), which is slower than `prepend`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A better implementation would be to use a local helper function with an accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, its tail call is optimized and it uses prepend instead of append. In Reason,
    you prepend to a list using the `...` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing in the list (`["first", "second", "third"]`) roughly results in the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the non-tail recursive version, Reason cannot create the list
    until recursion completes. In the tail recursive version, the accumulator (that
    is, the second argument of `aux`) is updated after each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursive (that is, tail call optimized) functions have the benefit of
    being able to reuse the current stack frame. As a result, tail recursive functions
    will never have a stack overflow, but non-tail recursive functions may have a
    stack overflow given enough iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason has two pipe operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Both pipe operators pass arguments to functions. The `|>` pipe operator pipes
    to a function's last argument and the `->` fast pipe operator pipes to a function's
    first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'They are equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the function only accepts one argument, then both pipes work the same, since
    the function's first argument is also the function's last argument.
  prefs: []
  type: TYPE_NORMAL
- en: Using these pipe operators is quite popular, since, once you get the hang of
    it, it makes the code a lot more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write it in a way that doesn''t require the reader to read it inside
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using fast pipe looks similar to chaining in JavaScript. Unlike
    JavaScript, we can pass reduce the `+` function, since it is just a normal function
    that accepts two arguments and adds them. The parentheses are necessary to tell
    Reason to treat the infix operator `(+)` as an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Using Belt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use what we've learned so far in this chapter to write a small program
    that creates a deck of cards, shuffles it, and draws five cards from the top of
    the deck. To do so, we'll use Belt's `Option` and `List` modules, as well as the
    fast pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: Option module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Belt''s `Option` module is a collection of utility functions for working with
    the `option` type. For example, to unwrap an option and throw a runtime exception
    if the option''s value is `None`, we can use `getExn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Belt functions that are able to throw runtime exceptions always have the `Exn`
    suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative function to unwrap an option that isn''t able to throw a runtime
    exception is `getWithDefault`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Option` module provides several other functions such as `isSome`, `isNone`,
    `map`, `mapWithDefault`, and more. Check the documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Belt Option module documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.Option.html](https://bucklescript.github.io/bucklescript/api/Belt.Option.html)'
  prefs: []
  type: TYPE_NORMAL
- en: List module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List module are the utilities for list data types. To see what functions Belt
    provides for working with lists, inspect Belt's `List` modules documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Belt List module documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.List.html](https://bucklescript.github.io/bucklescript/api/Belt.List.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus on a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `make` function is used to create a populated list. It accepts an integer
    for the length of the list and a value for each item in the list. Its type is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Belt.List.t` is exposed as an alias of the `list` type, so we can say the
    type of `Belt.List.make` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to create a list containing ten strings, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we will learn about how to explicitly expose or hide types and bindings from a
    module.
  prefs: []
  type: TYPE_NORMAL
- en: makeBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `makeBy` function is like the `make` function, except it accepts a function
    used to determine the value of each item given the item's index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the `makeBy` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to create a list of ten items, where each item is equal to its
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: shuffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `shuffle` function randomly shuffles a list. It has type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It accepts a list and returns a new list. Let''s use it to shuffle our list
    of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: take
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `take` function accepts a list and a length and returns a subset of the
    list starting from the head of the list with length equal to the requested length.
    Since the requested length of the subset may exceed the original list''s length,
    the result is wrapped in an option. Its type is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take the first two items from our shuffled list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Deck of cards example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're ready to combine this with what we've learned from previous chapters.
    How would you write a program that creates a deck of cards, shuffles it, and draws
    the first five cards? Before looking at the following example, give it a shot
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields an array of five cards at random in string format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the Belt standard library functions have a *U* suffix, such as this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the suffix here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The *U* suffix stands for *uncurried*. Before going further, let's define currying.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reason, every function accepts exactly one argument. This seems to contradict
    many of our earlier examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `add` function looks as if it accepts two arguments, but it is
    actually just syntactic sugar for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `add` function accepts a single argument, `a`, which returns a function
    that accepts a single argument, `b`, and then returns the result of `a + b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reason, both versions are valid and have the same compiled output. In JavaScript,
    both of the preceding versions are valid, but they are not the same; they would
    need to be used differently to get the same result. The second would need to be
    called like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because `add` returns a function that then needs to be called again,
    hence the two sets of parenthesis. Reason would accept either usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of currying is that it makes composing functions easier. You can
    easily create a function, `addOne`, that is partially applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This `addOne` function could then be passed to other functions such as `map`.
    Perhaps you'd like to use this feature to pass a function to a ReasonReact child
    component with the parent component's `self` partially applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confusingly, the compiled output of either version of `add` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Where is the intermediate function? Wherever possible, BuckleScript optimizes
    the compiled output to avoid the unnecessary function allocation, which improves
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, since Reason''s infix operators are just normal functions, we could
    have just done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Uncurried functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Due to JavaScript''s dynamic nature, BuckleScript cannot always optimize the
    compiled output to remove the intermediate functions. However, you can tell BuckleScript
    to uncurry a function using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The uncurry syntax is the dot in the argument list. It needs to be present
    at both the declaration and call sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'BuckleScript will throw a compile time error if the call site isn''t using
    the uncurry syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, a compile time error is thrown if some of the function''s arguments are
    missing at the call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The term `arity` refers to the number of arguments a function accepts.
  prefs: []
  type: TYPE_NORMAL
- en: makeByU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can replace `makeBy` with `makeByU` if we uncurry its second argument. This
    will improve performance (a negligible amount in our example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The dot syntax requires parentheses around `i`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **interoperability** refers to the ability for Reason programs to use
    existing JavaScript within Reason. BuckleScript provides an excellent system for
    using existing JavaScript code within Reason, and also makes it easy to use Reason
    code within JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript in Reason
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen how we can use raw JavaScript in Reason. Let's now focus
    on how to bind to existing JavaScript. To bind a value to a named reference, we
    typically use `let`. That binding can then be used in subsequent code. When the
    value we want to bind to lives is JavaScript, we use `external`. The `external`
    binding is like a `let`, in the sense that it can be used in subsequent code.
    Unlike `let`, `external` is typically accompanied by BuckleScript decorators such
    as `[@bs.val]`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the [@bs.val] decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use `[@bs.val]` to bind to global values and functions. In general,
    the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: One or more BuckleScript decorators (that is, `[@bs.val]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `external` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binding's named reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An equal sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The external keyword binds `alert` to a value of type `string => unit` and
    is bound to the string `alert`. The string `alert` is the value of the above external
    declaration and is what is going to be used in the compiled output. When the name
    of the external binding is equal to its string value, the string can be left empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the binding is just like using any other binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the [@bs.scope] decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bind to `window.location.pathname`, we add a scope using `[@bs.scope]`.
    This defines the scope for `[@bs.val]`. For example, if you want to bind to the
    `pathname` property of `window.location`, you can specify the scope as `[@bs.scope
    ("window", "location")]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could include the scope in the string using only `[@bs.val]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the [@bs.send] decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `[@bs.send]` decorator is for binding to an object''s methods and properties.
    When using `[@bs.send]`, the first argument is always the object. If there are
    remaining arguments, they will get applied to the object''s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `Dom` module is also provided by BuckleScript and provides type declarations
    for the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dom module documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Dom.html](https://bucklescript.github.io/bucklescript/api/Dom.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a Node module for use with Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Node.html](https://bucklescript.github.io/bucklescript/api/Node.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful when writing external declarations since you can accidentally lie
    to the type system, which could result in runtime type errors. For example, we
    told Reason that our `getElementById` binding always returns a `Dom.element`,
    but it returns `undefined` when the DOM can''t find an element with the provided
    ID. A more correct binding would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the [@bs.module] decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To import a node module, use `[@bs.module]`. The compiled output depends on
    the `package-specs` configuration used within `bsconfig.json`. We're using `es6` as
    the module format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the module format to `commonjs` results in the following compiled output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When there is no string argument to `[@bs.module]`, the default value is imported.
  prefs: []
  type: TYPE_NORMAL
- en: Reasonable APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When binding to existing JavaScript APIs, think about how you'd like to use
    the API in Reason. Even existing JavaScript APIs that rely heavily on JavaScript's
    dynamic typing can be used in Reason. BuckleScript leverages advanced type system
    techniques that let us take advantage of Reason's type system with such APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the BuckleScript documentation, take a look at the following JavaScript
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to bind to this function in Reason, it would be nice to use `padding`
    as a variant. Here is how we would do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The type of `padLeft` is `(string, some_variant) => string`, where `some_variant` uses
    an advanced type system feature called **polymorphic variant**, which that uses `[@bs.unwrap]`
    to get converted to something JavaScript can understand. We'll learn more about
    polymorphic variants in [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml),
    *Effective ML*.
  prefs: []
  type: TYPE_NORMAL
- en: BuckleScript documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this was just a brief introduction, you can see that BuckleScript has
    a lot of tools to help us communicate with idiomatic JavaScript. I highly encourage
    you to read the BuckleScript docs to learn more about JavaScript interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: 'BuckleScript documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/docs/interop-overview](https://bucklescript.github.io/docs/interop-overview)'
  prefs: []
  type: TYPE_NORMAL
- en: Binding to existing ReactJS components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReactJS components are not Reason components. To use an existing ReactJS component,
    we use `[@bs.module]` to import the node module, and then use the `ReasonReact.wrapJsForReason`
    helper function to convert the ReactJS component to a Reason component. There
    is also a `ReasonReact.wrapReasonForJs` helper function for using Reason in ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: Let's resume building our app from where we left off in [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml),
    *Creating ReasonReact Components:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ll add route transitions by binding to the existing React Transition
    Group components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'React Transition Group documentation can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)'
  prefs: []
  type: TYPE_NORMAL
- en: Importing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run `npm install --save react-transition-group` to install the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `ReactTransitionGroup.re` to house these bindings.
    In this file, we''ll bind to the `TransitionGroup` and `CSSTransition` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Creating the make functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we create the components' required `make` functions. This is where we
    use the `ReasonReact.wrapJsForReason` helper function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `TransitionGroup`, we won''t need any props. Since the `~props` argument
    is required, we pass `Js.Obj.empty()`. The `~reactClass` argument is passed the
    external binding we created in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now, `ReactTransitionGroup.TransitionGroup` is a ReasonReact component that
    can be used in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Using [@bs.deriving abstract]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`CSSTransitionGroup` will need the following props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_in`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classNames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `in` is a reserved word in Reason, the convention is to use `_in` in Reason
    and have BuckleScript compile it to `in` for JavaScript using `[@bs.as "in"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'BuckleScript provides `[@bs.deriving abstract]` for easily working with certain
    types of JavaScript objects. Instead of creating an object in JavaScript and binding
    to that object, we can create that object directly using BuckleScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: `cssTransitionProps` is not a record type, it just looks like one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `[@bs.deriving abstract]`, a helper function is automatically provided
    to create JavaScript objects of that shape. This helper function is also named
    `cssTransitionProps`. We use this helper function in the component''s `make` function
    to create the component''s props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Using the components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in `App.re`, we can change the render function to use these components.
    We''ll change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The key prop is a special ReactJS prop and should not be part of the
    component''s props argument in `ReasonReact.wrapJsForReason`. The same is true
    for the special ReactJS ref prop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, here is the corresponding CSS, which can be found in `ReactTransitionGroup.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to require the preceding in `ReactTransitionGroup.re`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now, when changing routes, the old route's content animates down and fades out
    before the new route's content animates up and fades in.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BuckleScript is incredibly powerful because it lets us interoperate with idiomatic
    JavaScript in a very pleasant way. It also provides the Belt standard library,
    which was created with JavaScript in mind. We learned about arrays and lists,
    and we saw how easy it is to use existing ReactJS components within Reason.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we'll learn about how to use module signatures to hide a component's implementation
    details while building an autocomplete input component. We'll start with hardcoded
    data at first, and in [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml),
    *CSS-in-JS (in Reason)*, we'll move that data to `localStorage` (client-side web
    storage).
  prefs: []
  type: TYPE_NORMAL
