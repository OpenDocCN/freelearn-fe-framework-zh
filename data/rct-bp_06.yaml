- en: Chapter 6. Advanced React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 高级React
- en: In the first part of this chapter, we'll look at **Webpack**, **Redux**, and
    how to write components with the new class syntax introduced in JavaScript 2015\.
    Writing ReactJS components with the class syntax is a little bit different than
    using `React.createClass`, so we'll be looking at the differences and the pros
    and cons.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将探讨**Webpack**、**Redux**以及如何使用JavaScript 2015中引入的新类语法编写组件。使用类语法编写ReactJS组件与使用`React.createClass`略有不同，所以我们将探讨这些差异以及它们的优缺点。
- en: In the second part of this chapter, we'll write an app that handles authentication
    using Redux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们将编写一个使用Redux处理认证的应用程序。
- en: 'This is what we''ll cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中要讨论的内容：
- en: 'A new bundling strategy:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的打包策略：
- en: How Browserify works
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Browserify是如何工作的
- en: How Webpack works
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack是如何工作的
- en: A difficult choice
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个艰难的选择
- en: Creating a new scaffold with Webpack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webpack创建一个新的脚手架
- en: The Babel configuration
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel配置
- en: The Webpack configuration
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack配置
- en: Adding assets
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加资源
- en: Creating an Express server
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Express服务器
- en: Adding ReactJS to the mix
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ReactJS加入其中
- en: Starting the server
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务器
- en: Introducing Redux
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Redux
- en: The single store
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一存储
- en: Actions in Redux
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux中的actions
- en: Understanding reducers
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解reducers
- en: Adding Devtools
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Devtools
- en: Create a login API
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个登录API
- en: A new bundling strategy
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种新的打包策略
- en: Until now, we've been using Browserify, but from now on, we'll switch to Webpack.
    You may wonder why we should make this switch and what the differences between
    the technologies are.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Browserify，但从现在开始，我们将切换到Webpack。你可能想知道为什么我们要进行这种切换，以及这些技术之间的区别是什么。
- en: Let's take a closer look at both of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看它们两个。
- en: How Browserify works
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Browserify是如何工作的
- en: '**Browserify** works by examining the entry point that you specify and building
    a dependency tree based on all the files and modules you require in your code.
    Each dependency gets wrapped in a `closure` code, which contains the module''s
    source code, a map of the module''s dependencies, and a key. It injects features
    that are native to the *node* but don''t exist in JavaScript, such as **module
    handling**.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Browserify**通过检查你指定的入口点，根据你代码中需要的所有文件和模块构建一个依赖树。每个依赖都被封装在一个`closure`代码中，其中包含模块的源代码、模块依赖的映射和一个键。它注入了原生于*node*但不在JavaScript中存在的特性，例如**模块处理**。'
- en: In short, it is able to analyze your source code, find and wrap up all your
    dependencies, and compile them into a single bundle. It's very performant and
    is an excellent start up tool for new projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，它能够分析你的源代码，找到并封装所有你的依赖项，并将它们编译成一个单一的包。它性能非常好，是新建项目的优秀启动工具。
- en: Using it in practice is as simple as writing a set of code and sending it to
    Browserify. Let's write two files that require each other.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中使用它就像编写一组代码并将其发送到Browserify一样简单。让我们编写两个相互需要的文件。
- en: 'Let''s call the first one `helloworld.js` and place the following code into
    it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第一个文件命名为`helloworld.js`，并将以下代码放入其中：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s call the second one `entry.js` and place the following code into it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第二个文件命名为`entry.js`，并将以下代码放入其中：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, pass both the files to Browserify from the command line, like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从命令行将这两个文件传递给Browserify，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result will be an immediately invoked function expression (IIFE for short)
    containing your "`hello world`" code. An IIFE is also referred to as an anonymous
    self-executing function or simply a code block that executes as soon as you load
    it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个立即调用的函数表达式（简称IIFE），其中包含你的"`hello world`"代码。IIFE也被称为匿名自执行函数或简单地指一个在加载时立即执行的代码块。
- en: 'The generated code looks rather incomprehensible, but let''s try to understand
    it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码看起来相当难以理解，但让我们试着理解它：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This entire first block passes the module source and executes it. The first
    argument takes our source code, the second a cache (usually empty), and the third
    a key, mapping it to the module it is required from.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 整个第一个块传递模块源代码并执行它。第一个参数接受我们的源代码，第二个是一个缓存（通常是空的），第三个是一个键，将其映射到所需的模块。
- en: 'The inner function is an internal `cache` function. It''s used at the end of
    the function to either retrieve the function from the cache, or store it so that
    it''s ready the next time it''s requested. Here, a required module is listed,
    along with the entire source code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数是一个内部`cache`函数。它在函数的末尾使用，用于从缓存中检索函数，或者存储它以便下次请求时可用。在这里，列出了一个所需的模块，以及整个源代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is passed in a parenthesis with three arguments, matching the
    IIFE function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是以三个参数的形式传递到括号中，与IIFE函数匹配。
- en: It's not vital that you fully understand how this works. The important thing
    to take away is that Browserify will generate a complete static bundle containing
    all of your code and will also take care of how they relate to each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并非你必须完全理解它是如何工作的。重要的是要记住，Browserify将生成一个包含所有代码的完整静态包，并且还会处理它们之间的关系。
- en: So far, Browserify looks fantastic. However, there is a fly in the ointment.
    If you want to do something more with your code—for instance, minify it or convert
    *JavaScript 2015* to *ECMAScript 5* or the *ReactJS JSX* code to plain JavaScript—you
    would need to pass additional transforms to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Browserify看起来非常出色。然而，美中不足的是，如果你想要对你的代码做更多的事情——例如，压缩它或者将*JavaScript 2015*转换为*ECMAScript
    5*或者将*ReactJS JSX*代码转换为纯JavaScript——你需要向它传递额外的转换。
- en: Browserify has a huge ecosystem of transforms that you can use to transmogrify
    your code. Knowing how to wire it up is the hard part, and the fact that Browserify
    itself is not entirely opinionated on the matter means that you are left on your
    own.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify有一个庞大的转换生态系统，你可以使用它来转换你的代码。知道如何连接起来是难点，而Browserify本身在这个问题上并不完全有意见，这意味着你将不得不自己处理。
- en: 'Let''s add a JavaScript 2015 transform to illustrate how you run Browserify
    with transforms. Change `helloworld.js` to this code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个JavaScript 2015转换来展示如何使用转换运行Browserify。将`helloworld.js`更改为以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the standard `browserify` command now will result in a parse error.
    Let''s try it with the Babel transformer that we''ve been using in our scaffold:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行标准的`browserify`命令将导致解析错误。让我们尝试使用我们在我们的脚手架中使用的Babel转换器：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code will now parse.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在将被解析。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you compare the resulting code, you'll notice that the generated JavaScript
    2015 code from Babel is rather different from the code Browserify generated using
    plain ECMAScript 5\. It's a little bit bigger (in this example, it's approximately
    25 percent larger, but it's a very small sample code set, so the difference won't
    be as dramatic with a more realistic code set).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较生成的代码，你会注意到Babel生成的JavaScript 2015代码与Browserify使用纯ECMAScript 5生成的代码相当不同。它稍微大一点（在这个例子中，它大约大25%，但这是一个非常小的代码集样本，所以与更现实的代码集相比，差异不会那么显著）。
- en: You can run the code in several ways. You can create an HTML file and reference
    it in a script tag, or you can simply open a browser and paste it into the console
    window in Chrome or the Scratchpad in FireFox. The result will be the same in
    any case; the text **Hello world!** will appear in your console log.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式运行代码。你可以创建一个HTML文件并在脚本标签中引用它，或者你只需简单地打开浏览器，将其粘贴到Chrome的控制台窗口或Firefox的Scratchpad中。在任何情况下，结果都是相同的；文本**Hello
    world!**将出现在你的控制台日志中。
- en: How Webpack works
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack的工作原理
- en: Like Browserify, Webpack is a module bundler. It's operationally similar to
    Browserify but is very different under the hood. There are many differences, but
    the key difference is that Webpack can be used dynamically, while Browserify is
    strictly static. We'll take a look at how Webpack works and show how this can
    benefit us greatly while using Webpack to write code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与Browserify类似，Webpack是一个模块打包器。它在操作上与Browserify相似，但在底层却大不相同。有很多差异，但关键的区别在于Webpack可以动态使用，而Browserify则是严格静态的。我们将探讨Webpack的工作原理，并展示如何在使用Webpack编写代码时从中获得巨大益处。
- en: 'As with Browserify, generating code with Webpack is initiated from an `entry`
    file. Let''s use the "`Hello World`" code from the previous example (the ECMAScript
    5 version). Webpack requires you to specify an `output` file, so let''s write
    it to `bundle.js` like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与Browserify一样，使用Webpack生成代码是从一个`entry`文件开始的。让我们使用上一个例子中的"`Hello World`"代码（ECMAScript
    5版本）。Webpack要求你指定一个`output`文件，所以让我们将其写入`bundle.js`，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The generated code is a lot more verbose than Browserify by default and is actually
    quite readable (adding the `-p` parameter will generate a minified version).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的代码比Browserify更冗长，实际上相当易于阅读（添加`-p`参数将生成一个压缩版本）。
- en: 'Running the preceding code will result in the following code being generated:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将生成以下代码：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Like Browserify, Webpack generates an IIFE. The first thing it does is set
    up a module cache and then check whether the module is cached. If not, the module
    is put into the cache, let''s take a look at the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与Browserify一样，Webpack生成一个IIFE。它首先做的事情是设置一个模块缓存，然后检查模块是否已缓存。如果没有，模块将被放入缓存，让我们看看以下代码片段：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, it executes the `module` function, flags it as loaded, and returns the
    exports of the module, let''s take a look at the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它执行 `module` 函数，将其标记为已加载，并返回模块的导出，让我们看一下下面的代码片段：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, it exposes the module''s object, cache, and the public path and then
    returns the entry module, let''s take a look at the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它暴露了模块的对象、缓存以及公共路径，然后返回入口模块，让我们看一下下面的代码片段：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Hello` is now assigned to `__webpack_require__(1)`. The number refers to the
    next module (since it starts counting at `0`). Now refer to the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello` 现在赋值给 `__webpack_require__(1)`。数字指的是下一个模块（因为它从 `0` 开始计数）。现在请参考以下内容：'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both module sources themselves are executed as arguments to the IIFE.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模块源本身都作为 IIFE 的参数执行。
- en: So far, both Webpack and Browserify look very much alike. They both analyze
    your entry file and wrap the sources in a self-executable closure. They also include
    a caching strategy and maintain a relation tree so that it can tell how the module
    requires one another.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Webpack 和 Browserify 看起来非常相似。它们都分析你的入口文件，并将源代码包裹在一个自执行的闭包中。它们还包括缓存策略，并维护一个关系树，以便它可以告诉模块是如何相互依赖的。
- en: In fact, just by looking at the generated code, it's hard to see that there's
    much to separate them, different code styles aside.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，仅通过查看生成的代码，很难看出它们之间有什么不同，除了代码风格不同之外。
- en: There's a very big difference, however, and that is how Webpack has organized
    its ecosystem and configuration strategy. While it's true the configuration is
    convoluted and slightly hard to understand, it's hard to argue against the results
    you can achieve.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个很大的不同，那就是 Webpack 如何组织其生态系统和配置策略。虽然配置确实很复杂，稍微难以理解，但很难否认你可以实现的结果。
- en: You can configure Webpack to do (almost) anything you want, including replacing
    the current code loaded in your browser with the updated code while preserving
    the state of the app. This is called **hot module replacement** or **hmr** for
    short.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以配置 Webpack 来做（几乎）你想要做的任何事情，包括在保留应用状态的同时，用更新的代码替换浏览器中当前加载的代码。这被称为 **热模块替换**
    或简称为 **hmr**。
- en: Webpack is configured by writing a special configuration file, usually called
    `webpack.config.js`. In this file, you specify the entry and output parameters,
    plugins, module loaders, and various other configuration parameters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 通过编写一个特殊的配置文件来配置，通常称为 `webpack.config.js`。在这个文件中，你指定入口和输出参数、插件、模块加载器和各种其他配置参数。
- en: 'A very basic `config` file looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基本的 `config` 文件看起来像这样：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s executed by issuing this command from the command line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过从命令行执行以下命令来执行：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Or simply, without the `config` parameters, Webpack will automatically look
    for the presence of `webpack.config.js`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果没有 `config` 参数，Webpack 将自动查找 `webpack.config.js` 的存在。
- en: 'In order to convert the `source` files before bundling, you use module loaders.
    Adding this section to the Webpack config file will make sure Babel converts JavaScript
    2015 code into ECMAScript 5:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在打包之前转换 `source` 文件，你使用模块加载器。将此部分添加到 Webpack 配置文件中，将确保 Babel 将 JavaScript
    2015 代码转换为 ECMAScript 5：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s review the options in detail:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细回顾一下选项：
- en: The first option (required), `test`, is a regex match that tells Webpack which
    files this loader operates on. The regex tells Webpack to look for files with
    a *period* followed by the letters *js* and then any optional letters `(?)` before
    the end `($)`. This makes sure the loader reads both plain JavaScript files and
    JSX files.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项（必需），`test`，是一个正则表达式匹配，告诉 Webpack 这个加载器操作哪些文件。正则表达式告诉 Webpack 查找以 *点* 开头，后跟字母
    *js*，然后是任意可选字母 `(?)`，直到末尾 `($)` 的文件。这确保加载器可以读取普通的 JavaScript 文件和 JSX 文件。
- en: The second option (required), `loader`, is the name of the package that we'll
    use to convert the code.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个选项（必需），`loader`，是我们将用于转换代码的包的名称。
- en: The third option (optional), `exclude`, is another regex used to explicitly
    ignore a set of folders or files.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个选项（可选），`exclude`，是另一个正则表达式，用于显式忽略一组文件夹或文件。
- en: The final option (optional), `query`, contains special configuration options
    for your loader. In our case, it contains options for the Babel loader. For Babel,
    the recommended way to do it is actually setting them in a special file called
    `.babelrc`. We'll be doing this later in the scaffold that we'll develop.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个选项（可选），`query`，包含为你的加载器设置的特殊配置选项。在我们的例子中，它包含 Babel 加载器的选项。对于 Babel，实际上推荐的方式是将它们设置在一个特殊的文件中，称为
    `.babelrc`。我们将在稍后开发的脚手架中这样做。
- en: A difficult choice – Browserify or Webpack
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个艰难的选择——Browserify 或 Webpack
- en: Browserify gets points for being easy to get started with, but loses out because
    of the increase in complexity when you need to add transforms and because it's,
    in general, more limited than Webpack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify因其易于上手而得分，但由于在需要添加转换时复杂性增加，并且总体上比Webpack更有限，因此它失去了分数。
- en: Webpack is harder to grasp initially, but progressively gets more useful as
    you unravel the complexity. The big upside to using Webpack is its ability to
    replace code in runtime with its ecosystem of hot reload tools, and the powerful,
    opinionated way in which it can be extended to suit every need. It's worth noting
    that there's efforts underway to develop an `hmr` module for Browserify as well.
    You can preview the project at [https://github.com/AgentME/browserify-hmr](https://github.com/AgentME/browserify-hmr).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack一开始比较难以掌握，但随着你解开复杂性，它将变得越来越有用。使用Webpack的一个重大优势是其能够使用其热重载工具生态系统在运行时替换代码，以及它以强大的、有见地的扩展方式来满足每一个需求。值得注意的是，目前正在努力为Browserify开发一个`hmr`模块。您可以在[https://github.com/AgentME/browserify-hmr](https://github.com/AgentME/browserify-hmr)上预览该项目。
- en: They're both terrific tools, and it's worth learning to use both. For some types
    of projects, using Browserify makes the most sense, and for others, Webpack is
    clearly the way to go.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是出色的工具，值得学习使用两者。对于某些类型的项目，使用Browserify最有意义，而对于其他项目，Webpack显然是最佳选择。
- en: Moving on, we'll create a new basic setup, a scaffold, which we'll use when
    developing a login app with Redux later in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的基本设置，一个脚手架，我们将在本章后面开发带有Redux的登录应用时使用它。
- en: This is going to be a lot of fun!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会非常有趣！
- en: Creating a new scaffold with Webpack
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Webpack创建一个新的脚手架
- en: 'Create a new folder and initialize it with `npm init` and then add the following
    dependencies:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并使用`npm init`初始化它，然后添加以下依赖项：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All but one of the dependencies will be saved as `devDependencies`. When you
    perform an `npm install` command later, all modules in both the `dependencies`
    section and the `devDependencies` section will be installed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个依赖项之外，所有依赖项都将保存为`devDependencies`。当您稍后执行`npm install`命令时，`dependencies`部分和`devDependencies`部分中的所有模块都将被安装。
- en: 'You can specify which section to install by providing `npm` with either the
    `dev` or `production` flag. For instance, this will install only the packages
    in the dependencies section:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向`npm`提供`dev`或`production`标志来指定要安装的哪个部分。例如，这将仅安装依赖项部分中的包：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your `package.json` file should now look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`package.json`文件现在应该看起来像这样：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Babel configuration
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babel配置
- en: 'Next, create a new file, name it `.babelrc` (no prefix before the dot), and
    add the following code to it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新文件，命名为`.babelrc`（点号前没有前缀），并将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This `configuration` file will be used by Babel to use the presets we just installed
    (React and ES2015). It will also instruct Babel which transforms we'd like to
    use. Putting the transforms inside the `env:development` file will make sure it
    won't be accidentally enabled in production.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`配置`文件将由Babel使用，以便使用我们刚刚安装的预设（React和ES2015）。它还将指示Babel我们希望使用哪些转换。将转换放在`env:development`文件中可以确保它不会在生产环境中意外启用。
- en: The Webpack configuration
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack配置
- en: 'Next, let''s add the Webpack configuration module. Create a new file called
    `webpack.config.js` and add this code to it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加Webpack配置模块。创建一个名为`webpack.config.js`的新文件，并将此代码添加到其中：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will instruct Webpack to first use the hot module replacement as the initial
    entry point and then our source root. Now refer to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示Webpack首先使用热模块替换作为初始入口点，然后是我们的源根。现在参考以下内容：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We'll set the output path to be the `public` folder, meaning that any content
    that is accessed should reside in this folder. We'll also instruct Webpack to
    use the `bundle.js` filename and specify that it should be accessed from the `assets`
    folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输出路径设置为`public`文件夹，这意味着任何被访问的内容都应该位于这个文件夹中。我们还将指示Webpack使用`bundle.js`文件名，并指定它应该从`assets`文件夹中访问。
- en: In our `index.html` file, we will access the file via a script tag pointing
    to `assets/bundle.js`, but we won't actually put a real `bundle.js` file in the
    `assets` folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`index.html`文件中，我们将通过一个指向`assets/bundle.js`的script标签来访问该文件，但我们实际上不会在`assets`文件夹中放置一个真实的`bundle.js`文件。
- en: The hot middleware client will make sure that when we try to access the bundle,
    the generated bundle will be served instead.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 热中间件客户端将确保当我们尝试访问包时，将提供生成的包。
- en: 'When we''re ready to create the real bundle for production, we''ll generate
    a `bundle.js` file with the production `flag` parameter and store it in `public/assets/bundle.js`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好创建用于生产的真实包时，我们将使用生产 `flag` 参数生成一个 `bundle.js` 文件，并将其存储在 `public/assets/bundle.js`：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll use three plugins. The first one makes sure the modules are loaded in
    order, the second is to prevent unnecessary error reporting in our console log,
    and the third one is to enable the hot module loader, such as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用三个插件。第一个确保模块按顺序加载，第二个是为了防止在我们的控制台日志中报告不必要的错误，第三个是为了启用热模块加载器，如下所示：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll add the Babel loader so that any JavaScript or JSX file gets transpiled
    before being bundled:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加 Babel 加载器，以便在打包之前将任何 JavaScript 或 JSX 文件进行转换：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And finally, we'll tell Webpack to resolve files that we import regardless of
    them having the `.js` or `.jsx` extension. This means that we will not have to
    write `import foo from 'foo.jsx'`, but can write `import foo from 'foo'` instead.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将告诉 Webpack 解析我们导入的文件，无论它们是否有 `.js` 或 `.jsx` 扩展名。这意味着我们不需要写 `import foo
    from 'foo.jsx'`，而是可以写 `import foo from 'foo'`。
- en: Adding assets
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加资产
- en: Next, let's add the `assets` folder and the files we'll reference there. We'll
    create it in the `root` folder rather than create a `public` folder. (We actually
    won't need to do this at all. This folder is not necessary to create while in
    development mode).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加 `assets` 文件夹以及我们将引用的文件。我们将在 `root` 文件夹中创建它，而不是创建一个 `public` 文件夹。（实际上我们根本不需要这样做。在开发模式下，这个文件夹不是必须创建的）。
- en: 'Create the folder and add two files: `app.css` and `favicon.ico`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件夹并添加两个文件：`app.css` 和 `favicon.ico`。
- en: The `favicon.ico` is not strictly necessary, so you may choose to drop it. You
    can probably find one scattered around your computer, or create one by going to
    favicon generator sites such as [http://www.favicon.cc](http://www.favicon.cc).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`favicon.ico` 并非绝对必要，因此你可以选择去掉它。你可能在电脑周围找到它，或者通过访问如 [http://www.favicon.cc](http://www.favicon.cc)
    这样的图标生成网站来创建一个。'
- en: 'The reason it''s included here is this: if it''s not present, you''ll see failed
    requests for the icon in your log every time you reload your site, so it represents
    log noise that''s worth getting rid of.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它被包含在这里的原因是：如果它不存在，每次你重新加载你的网站时，你会在日志中看到对图标失败的请求，所以它代表了值得去除的日志噪音。
- en: 'Open `assets/app.css` and add this code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `assets/app.css` 并添加以下代码：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This simply adds a general padding of `50` pixels around the body.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地给主体周围添加了 `50` 像素的通用填充。
- en: 'Next, we need to add an `index.html` file. Create it in the root of your app
    and add this content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个 `index.html` 文件。在应用程序的根目录中创建它，并添加以下内容：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating an Express server
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Express 服务器
- en: 'We also need to create an Express app to power our development server. Add
    `server.js` to your root folder and then add this code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个 Express 应用程序来为我们的开发服务器提供动力。将 `server.js` 添加到您的根文件夹中，然后添加以下代码：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This module lets us join path strings in a more comfortable and safe manner
    than concatenating strings. For one, it takes away our worry of knowing whether
    the directory path has a trailing slash or not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块让我们以更舒适和安全的方式连接路径字符串，而不是连接字符串。首先，它消除了我们是否知道目录路径是否有尾随斜杠的担忧。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You almost always get this wrong on your first try when you're concatenating
    strings manually.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你手动连接字符串时，你几乎总是会在第一次尝试时出错。
- en: 'We''ll use the Express web server, Webpack, and the Webpack config we just
    created:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Express 网络服务器、Webpack 以及我们刚刚创建的 Webpack 配置：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll preset the port we''re going to use as `8080` unless it''s specified
    as a parameter to the node. To specify parameters, such as the port, start the
    server in a way that it would look like `PORT=8081 node server.js`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将预设我们将要使用的端口号为 `8080`，除非它被指定为节点的参数。要指定参数，例如端口号，以这种方式启动服务器：`PORT=8081 node
    server.js`：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll create a local variable called `app` and point it to a new instance
    of the *Express* web server. We''ll also create another variable called `compiler`
    that will configure *Webpack* to use our `config` file. This is equivalent to
    starting Webpack from the command line with `webpack –config webpack.config.js`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `app` 的局部变量，并将其指向一个新的 *Express* 网络服务器实例。我们还将创建另一个名为 `compiler` 的变量，该变量将配置
    *Webpack* 使用我们的 `config` 文件。这相当于在命令行上使用 `webpack –config webpack.config.js` 启动
    Webpack：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ll define the `assets` folder as a `static` folder in Express. This is
    built-in middleware that configures Express to look for files in the provided
    folders. Middleware is software that serves to glue applications together or provide
    additional functionality. The static middleware lets us reference `app.css` directly
    in the link tag in our `index.html` file rather than referencing the `assets`
    folder:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Express 中将 `assets` 文件夹定义为 `static` 文件夹。这是一个内置的中间件，用于配置 Express 在提供的文件夹中查找文件。中间件是一种软件，用于将应用程序粘合在一起或提供额外的功能。静态中间件允许我们在
    `index.html` 文件中的链接标签中直接引用 `app.css`，而不是引用 `assets` 文件夹：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll tell *Express* to use `webpack-dev-middleware` with the `compiler` variable,
    along with some extra instructions (`noInfo` will prevent the console log from
    showing the Webpack compile information every time it recompiles; `publicPath`
    instructs the middleware to use the path we defined in our `config` file, and
    `quiet` hushes up any other debug that `noInfo` covers):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将告诉 *Express* 使用 `webpack-dev-middleware` 和 `compiler` 变量，以及一些额外的指令（`noInfo`
    将防止控制台日志在每次重新编译时显示 Webpack 编译信息；`publicPath` 指示中间件使用我们在 `config` 文件中定义的路径，而 `quiet`
    则抑制 `noInfo` 覆盖的任何其他调试信息）：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This instructs *Express* to use the `hot` `middleware` package (while the previous
    one told it to use the `dev` middleware). The `dev` middleware is a wrapper for
    Webpack that serves the files emitted from Webpack in memory rather than bundling
    them as files. When we couple this with the `hot middleware` package, we gain
    the ability to have any code changes reloaded and executed in the browser. The
    `heartbeat` parameter tells the middleware how often it should update.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 *Express* 使用 `hot` 中间件包（而前面的一个指示它使用 `dev` 中间件）。`dev` 中间件是 Webpack 的包装器，它将
    Webpack 发射到内存中的文件提供服务，而不是将它们捆绑为文件。当我们与 `hot` 中间件包结合使用时，我们获得了在浏览器中重新加载和执行任何代码更改的能力。`heartbeat`
    参数告诉中间件应该多久更新一次。
- en: 'You can adjust the heartbeat to update more often, but the number chosen works
    rather well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整心跳频率以更频繁地更新，但所选的数字效果相当不错：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This section routes every request to the Express app to our root folder:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分将每个请求路由到 Express 应用程序的根文件夹：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we start the app on the chosen port:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在选择的端口上启动应用程序：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The server is now ready. All you need to complete your setup now is add a ReactJS
    component. We'll use the new ES6 class-based syntax rather than the `createClass`
    syntax we've used until now.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在已准备就绪。你现在需要完成设置的所有步骤就是添加一个 ReactJS 组件。我们将使用新的 ES6 基于类的语法，而不是我们至今使用的 `createClass`
    语法。
- en: Adding ReactJS to the mix
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 ReactJS 添加到混合中
- en: 'Add a new folder called `source` and add a file called `index.jsx`. Then, add
    this code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `source` 的新文件夹，并添加一个名为 `index.jsx` 的文件。然后，添加以下代码：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `render` function looks the same as before.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 函数看起来与之前相同。'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we've also not used commas anymore to separate our functions. They
    aren't necessary within a class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也不再使用逗号来分隔我们的函数。在类内部它们不是必需的。
- en: 'Let''s take a look at the following code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The last function call is made to react-dom `render`, which takes care of populating
    the document container with the `app` ID along with the contents of our source
    file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数调用是调用 react-dom 的 `render` 方法，该方法负责用 `app` ID 和源文件的內容填充文档容器。
- en: Starting the server
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'We''re ready to run our server and be able to see the results for the first
    time. Start the app by executing `node server.js` in your terminal and open `http://localhost:8080`
    in your browser:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行服务器并首次看到结果。在终端中执行 `node server.js` 启动应用程序，并在浏览器中打开 `http://localhost:8080`：
- en: '![Starting the server](img/B04943_06_01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![启动服务器](img/B04943_06_01.jpg)'
- en: You should now be greeted with the intro text you added to `source/index.jsx`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该会看到你添加到 `source/index.jsx` 中的简介文本。
- en: Congratulations! You've completed all the steps necessary to get going with
    Webpack and hot reload.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了所有必要的步骤，可以开始使用 Webpack 和热重载。
- en: Granted, this setup is a bit more complex as compared to the `Browserify` setup,
    but the benefits of increased complexity will be apparent to you as you go ahead
    and make modifications to your source files; you'll be able to see the changes
    being updated in your browser as soon as you hit the **Save** button.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，与 `Browserify` 设置相比，这个设置稍微复杂一些，但随着你对源文件进行修改，你将明显感受到增加的复杂性带来的好处；你会在点击 **保存**
    按钮后立即看到浏览器中更新的更改。
- en: This is superior to the way we did it before because the app is able to keep
    the state of the app intact, even while reloading changes in your code. This means
    that when you're developing a complex app, you don't need to reiterate a lot of
    state changes to reach some code that you changed. This is guaranteed to save
    you a lot of time and frustration in the long run.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们之前的方法更优越，因为应用能够保持其状态完整，即使在重新加载代码更改时也是如此。这意味着当你开发一个复杂的应用时，你不需要重复很多状态更改来达到你更改的代码。这将在长期内为你节省大量时间和挫败感。
- en: Introducing Redux
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 *Redux*
- en: Until now, we've used **Reflux** to handle store and state interaction, but
    moving forward, we'll use a different implementation of the *Flux* architecture.
    It's called **Redux** and is quickly gaining traction as a superior *Flux* implementation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用 **Reflux** 来处理存储和状态交互，但向前看，我们将使用 *Flux* 架构的不同实现。它被称为 **Redux**，并且作为一个更优越的
    *Flux* 实现正在迅速获得认可。
- en: It's also infamous for being hard to understand, throwing both newcomers and
    experienced developers off-kilter with its duality of simplicity and complexity.
    This is partly because it's purely a functional approach to *Flux*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它也因其难以理解而臭名昭著，其简单与复杂性的双重性让新手和经验丰富的开发者都感到困惑。这部分的理由是因为它纯粹是 *Flux* 的函数式方法。
- en: When ReactJS was first introduced to the public in late 2013 / early 2014, you
    would often hear it mentioned together with functional programming.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ReactJS 在 2013 年晚些时候/2014 年初首次向公众介绍时，你经常会听到它与函数编程一起被提及。
- en: However, there's no inherent requirement to write functional code when writing
    React, and JavaScript itself being a multi-paradigm language is neither strictly
    functional nor strictly procedural, imperative, or even object-oriented.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编写 React 时，并没有内在的要求必须编写函数式代码，并且 JavaScript 本身作为一个多范式语言，既不是严格函数式，也不是严格过程式、命令式，甚至不是面向对象的。
- en: 'There are a number of benefits to choosing a functional approach:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 选择函数式方法有许多好处：
- en: No side-effects allowed, that is, the operation is stateless
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许有副作用，也就是说，操作是无状态的
- en: Always returns the same output for a given input
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的输入始终返回相同的输出
- en: Ideal for creating recursive operations
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合创建递归操作
- en: Ideal for parallel execution
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合并行执行
- en: Easy to establish the single source of truth
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易建立单一事实来源
- en: Easy to debug
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易调试
- en: Easy to persist the store state for a faster development cycle
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易持久化存储状态以加快开发周期
- en: Easy to create functionalities, such as undo and redo
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易创建诸如撤销和重做等功能
- en: Easy to inject a store state for server rendering
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易注入用于服务器渲染的存储状态
- en: The concept of stateless operations is possibly the number one benefit, as it
    makes it very easy to reason the state of your application. We already used this
    approach with the *Reflux* example in our first app in [Chapter 2](ch02.html "Chapter 2. Creating
    a Web Shop"), *Creating a Web Shop*, where the store state was only changed in
    the main app and then propagated downward to all the app's children. This is,
    however, not the idiomatic *Reflux* approach, because it's actually designed to
    create many stores and have the children listen to changes separately.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态操作的概念可能是最大的好处，因为它使得推理你应用的状态变得非常容易。我们已经在 [第 2 章](ch02.html "第 2 章。创建一个网络商店")
    的 *Reflux* 示例中使用了这种方法，在第一个应用中，存储状态只在主应用中更改，然后向下传播到所有应用的子组件。然而，这并不是典型的 *Reflux*
    方法，因为它实际上是为了创建许多存储，让子组件分别监听更改而设计的。
- en: The application state is the single hardest part of any application, and every
    single implementation of *Flux* has attempted to solve this problem. *Redux* solves
    it by not actually doing *Flux* at all; it actually uses an amalgamation of the
    ideas of *Flux* and the functional programming language, **Elm**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应用状态是任何应用中最困难的部分，每个 *Flux* 的实现都试图解决这个问题。*Redux* 通过实际上并不做 *Flux* 来解决这个问题；它实际上使用了
    *Flux* 和函数式编程语言 **Elm** 的想法的结合。
- en: 'There are three parts to *Redux*: **actions**, **reducers**, and **the global
    store**.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*Redux* 有三个部分：**actions**、**reducers** 和 **全局存储**。'
- en: The global store
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局存储
- en: In *Redux*, there is only one global store. It is an object that holds the state
    of your entire application. You create a store by passing your `root-reducing`
    function (or reducer for short) to a method called `createStore`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Redux* 中，只有一个全局存储。它是一个对象，持有你整个应用的状态。你通过将你的 `root-reducing` 函数（或简称为 reducer）传递给名为
    `createStore` 的方法来创建存储。
- en: Rather than creating more stores, you use a concept called **reducer composition**
    to split data-handling logic. You will then need to use a function called `combineReducers`
    to create a single root reducer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建更多的存储，你使用一个称为**reducer组合**的概念来分割数据处理逻辑。然后你需要使用一个名为`combineReducers`的函数来创建一个单一的根reducer。
- en: The `createStore` function is derived from Redux and is usually called once
    in the root of your app (or your `store` file). It is then passed on to your app
    and then propagated to the app's children.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`createStore`函数是从Redux派生出来的，通常在应用的根目录（或你的`store`文件）中调用一次。然后它被传递到你的应用中，并传播到应用的孩子。'
- en: The only way to change the state of the store is to dispatch an action to it.
    This is not the same as a Flux dispatcher, because Redux doesn't have one. You
    can also subscribe to changes from the store in order to update your components
    when the store changes state.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 改变存储状态的唯一方式是向其发送一个动作。这不同于Flux dispatcher，因为Redux没有。你也可以订阅存储的变化，以便在存储状态改变时更新你的组件。
- en: Understanding actions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解actions
- en: An action is an object that represents an intention to change the state. It
    must have a type field that indicates what kind of action is being performed.
    They can be defined as constants and imported from other modules.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作是一个表示意图改变状态的对象。它必须有一个类型字段，指示正在执行的动作类型。它们可以定义为常量并从其他模块导入。
- en: Apart from this requirement, designing the structure of an object is entirely
    up to you.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个要求之外，对象的结构设计完全取决于你。
- en: 'A basic action object can look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的动作对象可以看起来像这样：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `payload` property is optional and can work like objects we discussed earlier
    or any other valid JavaScript type, such as a function or primitive.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload`属性是可选的，它可以像我们之前讨论过的对象一样工作，或者任何其他有效的JavaScript类型，例如函数或原始类型。'
- en: Understanding reducers
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解reducers
- en: A **reducer** is a function that accepts an accumulation along with a value
    and returns a new accumulation. In other words, it returns the next state based
    on the previous state and an action.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**reducer**是一个接受累积值和一个值作为参数的函数，并返回一个新的累积值。换句话说，它根据前一个状态和动作返回下一个状态。'
- en: It must be a pure function, free of side effects, and it does not mutate the
    existing state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须是一个纯函数，没有副作用，并且不会修改现有的状态。
- en: For smaller apps, it's okay to start with a single reducer, but as your app
    grows, you split off smaller reducers that manage specific parts of your state
    tree.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的应用，从一个单一的reducer开始是可以的，但随着你的应用增长，你需要将其拆分成管理状态树特定部分的较小的reducers。
- en: This is what's called **reducer composition** and is the fundamental pattern
    of building apps with Redux.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的**reducer组合**，它是使用Redux构建应用的基石模式。
- en: You start with a single reducer, but as your app grows, you need to split it
    off into smaller reducers that manage specific parts of the state tree. Because
    reducers are just functions, you can control the order in which they are called,
    pass additional data, or even make reusable reducers for common tasks such as
    pagination.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个单一的reducer开始，但随着你的应用增长，你需要将其拆分成管理状态树特定部分的较小的reducers。因为reducers只是函数，你可以控制它们被调用的顺序，传递额外的数据，甚至为常见的任务（如分页）创建可重用的reducers。
- en: It's okay to have many reducers. In fact, it's encouraged.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多reducers是可以的。实际上，这是被鼓励的。
- en: Installing Redux
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Redux
- en: 'Let''s add *Redux* to our scaffold and see how it works. You only need two
    packages when getting started with redux: `redux` and `react-redux`. We''ll add
    a few more to our app that will help us debug when we are developing the app.
    First, install these dependencies:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加*Redux*到我们的脚手架中，看看它是如何工作的。当你开始使用redux时，你只需要两个包：`redux`和`react-redux`。我们将在我们的应用中添加一些其他包，以帮助我们在开发应用时进行调试。首先，安装以下依赖项：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When this is done, the `devDepencies` section of your `package.json` file should
    have these packages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成这项操作后，你的`package.json`文件的`devDepencies`部分应该包含以下包：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noting that new versions get released all the time, so it's good
    to make sure you have the same version numbers that were current when these examples
    were written. You can install the exact version numbers when you install packages
    by adding the version number to the `install` command, like we've done in the
    preceding code snippet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，新版本一直在发布，所以确保你安装的版本号与这些示例编写时的版本号相同是很好的。你可以在安装包时通过将版本号添加到`install`命令中来安装确切的版本号，就像我们在前面的代码片段中所做的那样。
- en: Creating a login app
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录应用
- en: Now that we've made a new scaffold based on Webpack and added Redux to the mix,
    let's go ahead and make an app that handles authentication using the new libraries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基于Webpack创建了一个新的脚手架，并添加了Redux，让我们继续创建一个使用新库处理身份验证的app。
- en: Creating an action
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个动作
- en: We're going to start by adding an action. The app we'll be making is a login
    app, where you'll be prompted for a username and password upon entry.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从添加一个动作开始。我们将制作的app是一个登录app，在进入时将提示输入用户名和密码。
- en: 'Let''s start by making a folder structure separating the functionality. Create
    a folder called `actions` within the `source` folder and add a file called `login.js`;
    then, add this code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个文件夹结构来分离功能。在`source`文件夹内创建一个名为`actions`的文件夹，并添加一个名为`login.js`的文件；然后，添加以下代码：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Fetch` is a new interface for fetching resources. It will be recognizable
    if you''ve used `XMLHttpRequest` in the past or **Superagent** with **Promises**,
    as we''ve used in previous chapters. The new API supports Promises out of the
    box, supporting a generic definition of Request and Response objects. It also
    provides a definition for concepts such as **Cross-Origin Resource Sharing** (**CORS**)
    and HTTP Origin header semantics.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fetch`是一个用于获取资源的全新接口。如果你以前使用过`XMLHttpRequest`或者像我们在前面的章节中使用的那样，与**Promises**一起使用**Superagent**，你会认识它。新的API支持开箱即用的Promises，支持通用的请求和响应对象定义。它还提供了诸如**跨源资源共享**（**CORS**）和HTTP源头语义等概念的定义。'
- en: 'We could have used `Fetch` right out of the box with Babel, but this package
    is preferable because it adds `Fetch` as a global function that has a consistent
    API for use in both server and client code. This will be in a later chapter where
    we''ll create an isomorphic app. Consider the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用Babel直接使用`Fetch`，但这个包更可取，因为它将`Fetch`作为一个全局函数添加，它具有一致的API，可以在服务器和客户端代码中使用。这将在后面的章节中介绍，我们将创建一个同构应用。考虑以下代码：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This defines a single action constant that we can use when we want to dispatch
    the action. Now check this out:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个单个动作常量，我们可以在需要分发动作时使用。现在看看这个例子：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this, we create and export a single function called `login` that accepts
    a `userData` object. Now we''ll create a `body` variable that holds the username
    and password:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建并导出一个名为`login`的单个函数，该函数接受一个`userData`对象。现在我们将创建一个名为`body`的变量，它包含用户名和密码：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is not strictly necessary as we can easily pass the `userData` object
    along, but the idea is that by making it explicit, we''re sending a username and
    password and nothing else. This will be easy to understand when you look at the
    next chunk of code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是严格必要的，因为我们可以轻松地传递`userData`对象，但我们的想法是通过明确地这样做，我们只发送用户名和密码，没有其他内容。当你查看下一部分代码时，这将很容易理解：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will send the `POST` request with an `Accept` header and `Content-Type`,
    both specifying that we're working with JSON data. We'll also send an authorization
    header with a bearer token.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有`Accept`头和`Content-Type`的`POST`请求发送，两者都指定我们正在处理JSON数据。我们还将发送一个带有bearer
    token的授权头。
- en: You have seen this bearer token before, in [Chapter 4](ch04.html "Chapter 4. Building
    a Real-Time Search App"), *Building a Real-Time Search App*. The API that we're
    going to reference is very similar to the one we built then. We'll look at the
    API as soon as we're finished with the frontend code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前在[第4章](ch04.html "第4章. 构建实时搜索应用")中见过这个bearer token，*构建实时搜索应用*。我们将引用的API与我们当时构建的非常相似。我们将在完成前端代码后查看API。
- en: 'The body is passed through the `JSON.stringify()` method because we can''t
    send a raw JavaScript object through HTTP. The method converts an object to a
    proper JSON representation, optionally replacing values if a replacer function
    is specified. Check this out:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 主体通过`JSON.stringify()`方法传递，因为我们不能通过HTTP发送原始JavaScript对象。该方法将对象转换为适当的JSON表示形式，如果指定了替换函数，则可选地替换值。看看这个例子：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is the `return` section of our `login` function. It first connects to our
    login API through the `fetch` function, which returns a `Promise`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`login`函数的`return`部分。它首先通过`fetch`函数连接到我们的登录API，该函数返回一个`Promise`。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we're using the new backticks available through JavaScript 2015.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们正在使用JavaScript 2015通过新背引号提供的功能。
- en: 'When the Promise is resolved, we fetch the JSON response from the object through
    the `native json()` method available with the fetch API. Finally, we return the
    JSON data through a dispatch to an internal function called `setLoginDetails`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Promise 解决时，我们通过 fetch API 可用的 `native json()` 方法从对象中获取 JSON 响应。最后，我们通过向一个名为
    `setLoginDetails` 的内部函数派发来返回 JSON 数据：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If `json` contains a valid response, `setLoginDetails` returns an `action` object
    with a type that maps to the `LOGIN_USER` string value and two custom values.
    Remember that an action must always return a `type` and that anything else it
    returns is optional and up to you. If the `json` parameter is empty, the function
    returns `LOGIN_FAIL`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `json` 包含有效的响应，`setLoginDetails` 返回一个包含映射到 `LOGIN_USER` 字符串值的 `action` 对象和两个自定义值。记住，一个动作必须始终返回一个
    `type`，而它返回的其他任何内容都是可选的，取决于你。如果 `json` 参数为空，函数返回 `LOGIN_FAIL`。
- en: Creating a reducer
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 reducer
- en: 'The next file we''re going to add is a `reducer`. We''ll put it in a folder
    of its own. So create a folder called `reducers` within `source` and add a file
    called `login.js` (same as the action), then add this code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要添加的下一个文件是一个 `reducer`。我们将将其放在一个单独的文件夹中。所以，在 `source` 文件夹内创建一个名为 `reducers`
    的文件夹，然后添加一个名为 `login.js` 的文件（与 action 相同），然后添加以下代码：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ll import the file we just created as well as the `combineReducer()` method
    from Redux. We''ll only create one reducer for now, but I like to add it from
    the start since it''s typical to add more reducers as the app grows. It generally
    makes sense to have a `root` file to combine reducers as the number of your reducers
    grow. Next, we''ll declare a function that expects a `state` object and `action`
    as its arguments:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入我们刚刚创建的文件以及来自 Redux 的 `combineReducer()` 方法。目前我们只创建一个 reducer，但我喜欢从一开始就添加它，因为随着应用的扩展，通常会增加更多的
    reducer。当你的 reducer 数量增加时，通常有一个 `root` 文件来组合 reducer 是有意义的。接下来，我们将声明一个函数，该函数期望一个
    `state` 对象和 `action` 作为其参数：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When `action.type` returns a successful state, we return the state and add
    or update the `userData` and `timestamp` parameters:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `action.type` 返回一个成功状态时，我们返回状态并添加或更新 `userData` 和 `timestamp` 参数：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that in order to use the spread operator in our reducer, we need to add
    a new preset to our `.babelrc` configuration. This is not part of EcmaScript 6
    but is proposed as an extension to the language. Open up your terminal and run
    this command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了在我们的 reducer 中使用扩展运算符，我们需要在我们的 `.babelrc` 配置中添加一个新的 preset。这不是 EcmaScript
    6 的一部分，而是作为语言扩展被提出的。打开你的终端并运行以下命令：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, modify the presets section in `.babelrc` so that it looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 `.babelrc` 中的 presets 部分，使其看起来像这样：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''ll also add a *case* in case there is a failure to log the user in:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会添加一个 *case* 以便在登录失败时记录用户：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we''ll add a *default case*. It''s not strictly necessary, but it''s
    generally prudent to handle any unforeseen cases like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个 *default case*。这并不是严格必要的，但通常处理任何未预见的案例，如这种情况，是谨慎的：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Creating a store
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 store
- en: 'The next file we''re going to add is a store. Create a folder called `stores`
    within your `source` folder, add the `store.js` file, and then add this code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要添加的下一个文件是一个 store。在你的 `source` 文件夹内创建一个名为 `stores` 的文件夹，添加 `store.js`
    文件，然后添加以下代码：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ll import the `reducer` we just created:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入我们刚刚创建的 `reducer`：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We'll need a few methods from Redux. The `devtools` package is needed for development
    only and must be removed when going to production.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 Redux 中获取一些方法。`devtools` 包仅用于开发，并且在进入生产时必须删除。
- en: In computer science, `thunk` is an anonymous expression that has no parameters
    of its own wrapped in an argument expression. A `redux-thunk` package lets you
    write action creators that return a function instead of an action. The `thunk`
    package can be used to delay the dispatch of an action, or to dispatch only if
    a certain condition is met. The inner function receives the store methods dispatch
    and `getState()` as parameters.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，`thunk` 是一个没有自己的参数的匿名表达式，它被一个参数表达式包裹。`redux-thunk` 包允许你编写返回函数的动作创建器，而不是动作。`thunk`
    包可以用来延迟动作的派发，或者只在满足某些条件时派发。内部函数接收 store 方法 `dispatch` 和 `getState()` 作为参数。
- en: 'We''ll use this to send an asynchronous dispatch to our login API:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它来向我们的登录 API 发送异步派发：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Adding devtools
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 devtools
- en: Devtools are the primary way you will work with the state in your app. We'll
    install the default log and dock monitors, but you may develop your own if they
    don't suit you.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Devtools 是你在应用中处理状态的主要方式。我们将安装默认的日志和坞栏监视器，但如果你觉得它们不适合你，你可以开发自己的。
- en: 'Add a file called `devtools.js` to your `source` folder and add this code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `source` 文件夹中添加一个名为 `devtools.js` 的文件，并添加以下代码：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`Monitors` are separate packages, and you can make custom ones, let''s take
    a look at the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitors` 是独立的包，你可以创建自定义的，让我们看看以下代码：'
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Monitors** are individually adjustable with props. Take a look at the source
    code for the devtools to learn more about how they''re built. Here, we put `LogMonitor`
    inside a `DockMonitor` class:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**Monitors** 可以通过属性单独调整。查看 devtools 的源代码以了解更多关于它们如何构建的信息。在这里，我们将 `LogMonitor`
    放在 `DockMonitor` 类内部：'
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tying the files together
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合文件
- en: 'It''s time to tie the app together. Open `index.jsx` and replace the existing
    content with this code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将应用整合在一起了。打开 `index.jsx` 并将现有内容替换为以下代码：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This adds all the files we created and the methods we needed from ReactJS.
    Now refer to the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了我们创建的所有文件以及从 ReactJS 中需要的所有方法。现在参考以下代码：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This function dispatches the `login` action we defined in `actions/login.js`
    with the contents of the `username` and `password` input fields defined in the
    `render()` method, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用在 `render()` 方法中定义的 `username` 和 `password` 输入字段的内容，派发我们在 `actions/login.js`
    中定义的 `login` 动作，如下所示：
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is a small piece of JSX code that we use to display either a welcome message
    or an error message after a login attempt. Now check out the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一小段 JSX 代码，我们用它来在登录尝试后显示欢迎信息或错误信息。现在查看以下代码：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: These are the input fields for logging in a user.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于登录用户的输入字段。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we must bind the context ourselves with `.bind(this)`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须自己使用 `.bind(this)` 绑定上下文。
- en: 'With `createClass`, binds were created automatically, but no such magic exists
    when you use JavaScript 2015 classes. The next iteration of JavaScript may bring
    a proposed new syntactic sugar for bind (`::`), which means that we could have
    used `this.handleSelect` without explicitly binding it, but it''s still a way
    off from being implemented:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `createClass` 时，绑定是自动创建的，但当你使用 JavaScript 2015 类时，没有这样的魔法存在。JavaScript 的下一个版本可能会带来一个建议的新语法糖（`::`），这意味着我们可以使用
    `this.handleSelect` 而不必显式绑定它，但这还远未实现：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This `render` block simply presents the visitor with the option to log in. The
    app will attempt to log in when the user clicks on *Enter*, and it will either
    present the visitor with a welcome message or the **invalid login** message.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `render` 块只是向访客提供了一个登录选项。当用户点击 *Enter* 时，应用将尝试登录，并显示欢迎信息或 **无效登录** 信息。
- en: 'This function converts the app state to a set of properties that we can pass
    to the children components:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将应用状态转换为我们可以传递给子组件的一系列属性：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is where we define the app with the Redux `connect()` method, which connects
    a React component to a Redux store. Rather than modifying the component in place,
    it returns a new `component` class that we can render:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用 Redux 的 `connect()` 方法定义应用的地方，它将 React 组件连接到 Redux 存储。而不是就地修改组件，它返回一个新的
    `component` 类，我们可以渲染它：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We create a new component class that wraps the `LoginApp` component inside
    a `Provider` component:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的组件类，它将 `LoginApp` 组件包裹在 `Provider` 组件内部：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Provider` component is special because it is responsible for passing the
    store as a property to the children components. It''s recommended that you create
    a `root` component wrapping the app inside `Provider`, unless you want to manually
    pass the store yourself to all children components. Finally, we pass the `Root`
    component to render it and to ask it to display the contents inside `div` with
    the ID `App` in `index.html`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Provider` 组件是特殊的，因为它负责将存储作为属性传递给子组件。建议你创建一个 `root` 组件，将应用包裹在 `Provider` 中，除非你想手动将存储传递给所有子组件。最后，我们将
    `Root` 组件传递给渲染，并要求它显示 `index.html` 中 ID 为 `App` 的 `div` 中的内容：'
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The result of doing this is illustrated in the following screenshot:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的结果在以下屏幕截图中有说明：
- en: '![Tying the files together](img/B04943_06_02.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![整合文件](img/B04943_06_02.jpg)'
- en: The app itself looks very unassuming, but it's worth looking at the devtools
    to the right of the screen. This is the *Redux dev tools*, and it tells you that
    you have an app state with a user object with two keys. If you click on **user**,
    it will open and show you that it consists of an object with an empty `message`
    string and an empty `userData` object.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 应用本身看起来很不起眼，但值得看看屏幕右侧的 devtools。这是 *Redux dev tools*，它告诉你有一个包含用户对象的 app 状态，该用户对象有两个键。如果你点击
    **user**，它将展开并显示它由一个包含空 `message` 字符串和空 `userData` 对象的对象组成。
- en: This is exactly how we configured it in `source/index.jsx`, so if you see this,
    it's working as expected.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在`source/index.jsx`中配置的方式，所以如果你看到这个，它就是按预期工作的。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Try to log in by typing in a username and password. Hint: the combo *darth/vader*
    or *john/sarah* will let you log in.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过输入用户名和密码来登录。提示：组合*darth/vader*或*john/sarah*可以让你登录。
- en: Notice that you can now instantly navigate through your app state by clicking
    on the action buttons in your developer toolbar.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在你可以通过点击开发者工具栏中的动作按钮立即导航到你的应用状态。
- en: Handling refresh
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理刷新
- en: Your app is ready and you're able to log in, but if you refresh, your login
    information is gone.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用已经准备好了，你可以登录，但如果刷新，你的登录信息就会消失。
- en: While it'd be nice if your users never refreshed your page after login, it's
    not feasible to expect this behavior from your users, and you'd surely be left
    with users either complaining or leaving your site and never coming back.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果用户登录后永远不刷新你的页面会很好，但期望用户有这样的行为并不可行，你肯定会留下一些抱怨或离开你的网站的用户，他们永远不会回来。
- en: What we need to do is find a way to inject the previous state in our stores
    upon initializing. Fortunately, this is not very hard; we just need a secure place
    to store the data that we want to survive a refresh.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是在初始化我们的存储时找到一种方法来注入先前状态。幸运的是，这并不难；我们只需要一个安全的地方来存储我们想要在刷新后存活的数据。
- en: To this end, we'll use `sessionStorage`. It is similar to `localStorage`, the
    only difference being that while data stored in `localStorage` has no expiration
    set, any data stored in `sessionStorage` gets cleared when the page session ends.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们将使用`sessionStorage`。它与`localStorage`类似，唯一的区别是，虽然存储在`localStorage`中的数据没有设置过期时间，但存储在`sessionStorage`中的任何数据在页面会话结束时都会被清除。
- en: A session lasts for as long as the browser window is open and it survives page
    reloads and restores.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 会话持续的时间与浏览器窗口打开的时间一样长，并且它可以在页面重新加载和恢复时存活。
- en: It doesn't support opening the same page in a new tab or a window, which is
    the main difference between this and, for instance, session cookies.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 它不支持在新标签页或窗口中打开相同的页面，这是它与，例如，会话cookie的主要区别。
- en: 'The first thing we''ll do is change `actions/login.js` and modify the function
    `setLoginDetails`. Replace the function with this code (and note that now we will
    export it):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是更改`actions/login.js`并修改`setLoginDetails`函数。用以下代码替换该函数（并注意现在我们将导出它）：
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''ll then enter `index.jsx` and add the function to our imports. Add it to
    the line with imports from `actions/login` like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将进入`index.jsx`并添加函数到我们的导入中。将其添加到从`actions/login`导入的行中，如下所示：
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And then, we''ll add a new function within the `App` class:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`App`类中添加一个新函数：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Before the component mounts, it will check whether there's a stored entry inside
    `sessionStorage` that holds the user info. If there is, it will dispatch an action
    call to `setLoginDetails`, which will simply set the state to logged in and display
    the familiar welcome message.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件挂载之前，它将检查`sessionStorage`中是否有存储的用户信息条目。如果有，它将分派一个调用`setLoginDetails`的动作，这将简单地设置状态为已登录并显示熟悉的欢迎信息。
- en: And that's all you need to do.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要做的全部。
- en: There are other ways to inject a state than by simply dispatching actions. You
    could do it in the `mapStateToProps` function and set an initial state based on
    `sessionStorage`, session cookies, or some other source of data (we'll come back
    to this when making an isomorphic app).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地分派动作之外，还有其他方法可以注入状态。你可以在`mapStateToProps`函数中这样做，并基于`sessionStorage`、会话cookie或其他数据源设置初始状态（我们将在制作同构应用时回到这一点）。
- en: The Login API
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录API
- en: In the app we just created, we logged in to an existing API. You may wonder
    how the API is constructed, so let's take a look at it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的应用中，我们登录到一个现有的API。你可能想知道API是如何构建的，那么让我们来看看。
- en: 'To create the API, start a new project and execute `npm init` to create an
    empty `package.json` file. Then, install the following packages:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建API，开始一个新的项目并执行`npm init`来创建一个空的`package.json`文件。然后，安装以下包：
- en: '[PRE73]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Your `package.json` file should now look like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`package.json`文件现在应该看起来像这样：
- en: '[PRE74]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We'll use **3** to hold our user data as we did in [Chapter 4](ch04.html "Chapter 4. Building
    a Real-Time Search App"), *Building a Real-Time Search App*, and I refer you to
    this chapter to set it up on your system.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**3**来存储我们的用户数据，就像我们在[第4章](ch04.html "第4章. 构建实时搜索应用")中做的那样，*构建实时搜索应用*，并请参考这一章在你的系统上设置它。
- en: 'The entire API is a single Express application. Create a file in the root of
    your app called `index.js` and add this code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 整个API是一个单独的Express应用程序。在您的应用程序根目录中创建一个名为`index.js`的文件，并添加以下代码：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Cross-Origin Resource Sharing (CORS) defines a way in which a browser and server
    can interact to safely determine whether or not to allow a cross-origin request.
    It''s famous for making life hard for API developers, so it''s worth your while
    to install the `cors` package and use it in your Express app to alleviate the
    pain:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 跨源资源共享（CORS）定义了浏览器和服务器如何交互，以安全地确定是否允许跨源请求。它因让API开发者生活变得艰难而闻名，因此安装`cors`包并在您的Express应用程序中使用它以减轻痛苦是值得的：
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We''ll use a free MongoLab instance if it exists in our config file, or a local
    MongoDB database if not. We''ll use the same token as in [Chapter 4](ch04.html
    "Chapter 4. Building a Real-Time Search App"), *Building a Real-Time Search App*,
    but we''ll look at making it more secure in a later chapter:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的配置文件中存在MongoLab实例，我们将使用免费的MongoLab实例，如果没有，则使用本地MongoDB数据库。我们将使用与[第4章](ch04.html
    "第4章。构建实时搜索应用")中相同的令牌，即*构建实时搜索应用*，但在后面的章节中我们将探讨使其更加安全的方法：
- en: '[PRE77]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The database model is very simple, but could be expanded to add user e-mail
    addresses and more information if it''s deemed as worthwhile to fetch. However,
    the more information you ask for, the less likely it is that the user will sign
    up for your service:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模型非常简单，但可以扩展以添加用户电子邮件地址和更多信息，如果认为值得获取的话。然而，您要求的信息越多，用户注册您服务的可能性就越小：
- en: '[PRE78]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We''ll encrypt all passwords stored in the database with AES 256-bit encryption.
    This is a very strong form of security (and is in fact the same as the TLS/SSL
    encryption used for secure communication on the Internet):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用AES 256位加密对所有存储在数据库中的密码进行加密。这是一种非常强大的安全形式（实际上与用于互联网上安全通信的TLS/SSL加密相同）：
- en: '[PRE79]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Refer to the following lines of code:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下代码行：
- en: '[PRE80]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'These are the functions we''ll use to encrypt and decrypt user passwords. We''ll
    accept user password as text, then encrypt it and check whether the encrypted
    version exists in our database. Now check this out:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将用于加密和解密用户密码的函数。我们将接受用户密码作为文本，然后加密它并检查加密版本是否存在于我们的数据库中。现在看看这个：
- en: '[PRE81]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This API needs `POST` data, so we'll display helpful information to anyone trying
    to access this via `GET`, since it isn't possible to fetch any data with the `GET`
    method.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此API需要`POST`数据，因此我们将向尝试通过`GET`方法访问此API的人显示有用的信息，因为使用`GET`方法无法获取任何数据。
- en: 'We''ll look for usernames and passwords and make sure we lowercase them because
    we don''t support variable case strings:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查找用户名和密码，并确保将它们转换为小写，因为我们不支持可变大小写字符串：
- en: '[PRE82]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Moreover, we'll also specify that the password should not be a part of the resulting
    result set by setting the field to `0` or `false`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将指定密码不应是结果集的一部分，通过将字段设置为`0`或`false`来实现。
- en: 'We''ll then search our database for a user that has the requested username
    and the provided password (but we need to make sure to look for the encrypted
    version). This way, we never know what the user''s real password is. The API will
    use `/v1` as the route prefix:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在数据库中搜索具有请求的用户名和提供的密码的用户（但我们需要确保查找加密版本）。这样，我们永远不知道用户的真实密码。API将使用`/v1`作为路由前缀：
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Note that you could alternately use an `accept` header to separate between
    versions of your API:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还可以使用`accept`头来区分API的版本：
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we can start the API. When we try to send a `GET` request, we get
    the anticipated error response, and when we send a valid body with the correct
    username and password, the API delivers the data it has. Let''s take a look at
    the following screenshot:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启动API。当我们尝试发送`GET`请求时，我们得到预期的错误响应，当我们发送带有正确用户名和密码的有效正文时，API提供它拥有的数据。让我们看看下面的截图：
- en: '![The Login API](img/B04943_06_03.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![登录API](img/B04943_06_03.jpg)'
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! With this, you've just completed the advanced ReactJS chapter.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！通过这个，您刚刚完成了高级ReactJS章节。
- en: You've learned the difference between Browserify and Webpack and made a new
    basic setup with Webpack and hot module replacement that provides you with a fantastic
    developer experience.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了Browserify和Webpack之间的区别，并使用Webpack和热模块替换创建了一个新的基本设置，这为您提供了出色的开发者体验。
- en: 'You''ve also learned how to create React components using JavaScript 2016 classes
    and how to add the popular state management library: Redux. Furthermore, you wrote
    another API, this time the one used for logging in users with a username and password.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何使用 JavaScript 2016 类创建 React 组件，以及如何添加流行的状态管理库：Redux。此外，你还编写了另一个 API，这次是用于使用用户名和密码进行用户登录的
    API。
- en: Pat yourself on the back, because this was a very heavy chapter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 给自己点个赞吧，因为这是一章非常重的章节。
- en: Note
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The finished project can be viewed online at [https://reactjsblueprints-chapter6.herokuapp.com](https://reactjsblueprints-chapter6.herokuapp.com).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以在网上查看：[https://reactjsblueprints-chapter6.herokuapp.com](https://reactjsblueprints-chapter6.herokuapp.com)。
- en: In the next chapter, we'll use what we've learned in the last couple of chapters
    to write a web app that relies heavily on web APIs and the Webpack/Redux setup
    from this chapter. Roll up your sleeves because we're going to make a social network
    based around snapping images.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用上一章学到的知识来编写一个高度依赖 Web APIs 和本章中提到的 Webpack/Redux 设置的 Web 应用程序。卷起袖子吧，因为我们将要制作一个围绕拍摄图片的社交网络。
