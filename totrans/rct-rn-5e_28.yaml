- en: '26'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Animations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations can be used to improve the user experience in mobile applications.
    They usually help users to quickly recognize that something has changed, or help
    them focus on what is important. They improve the user experience and user satisfaction.
    Also, animations are simply fun to look at. For example, the heartbeat reaction
    in the Instagram app when you like a post or the Snapchat ghost animation when
    refreshing a page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of different approaches to processing and controlling animations
    in React Native. Firstly, we will take a look at animation tools that we can use,
    discover their pros and cons, and compare them. Then, we will implement several
    examples to get to know APIs better.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Using React Native Reanimated
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating layout components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating component styles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter26).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Using React Native Reanimated
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the React Native world, we have a lot of libraries and approaches to animate
    our components, including the built-in **Animated API**. But in this chapter,
    I would like to opt for a library called **React Native Reanimated** and compare
    it with the Animated API to learn why it is the best choice.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The Animated API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Animated API** is the most common tool used to animate components in React
    Native. It has a set of methods that help you to create an animation object, control
    its state, and process it. The main benefit is that it can be used with any component,
    and not just animated components such as View or Text.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: But, at the same time, this API has been implemented in the old architecture
    of React Native. Asynchronous communications between JavaScript and UI Native
    threads are used with the Animated API, delaying updates by at least one frame
    and lasting approximately 16 ms. Sometimes, the delay may last even longer if
    the JavaScript thread is running React’s diff algorithm and comparing or processing
    network requests simultaneously. The problem of dropped or delayed frames can
    be solved with the React Native Reanimated library, which is based on the new
    architecture and processes all business logic from the JavaScript thread in the
    UI thread.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: React Native Reanimated
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**React Native Reanimated** can be utilized to provide a more exhaustive abstraction
    of the Animated API to use with React Native. It provides an imperative API with
    multistage animations and custom transitions, while at the same time providing
    a declarative API that can be used to describe simple animations and transitions
    in a similar way to how CSS transitions work. It’s built on top of React Native
    Animated and reimplements it on the Native thread. This allows you to use the
    familiar JavaScript language while taking advantage of the most high performance
    and simple API.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, React Native Reanimated defines worklets, which are JavaScript
    functions that can be synchronously executed within the UI thread. This allows
    instant animations without having to wait for a new frame. Let’s take a look at
    what a simple worklet looks like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only thing that is needed for the `simpleWorklet` function to get called
    inside the UI thread is to add the `worklet` directive at the top of the `function`
    block.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'React Native Reanimated provides a variety of hooks and methods that help us
    handle animations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`useSharedValue`: This hook returns a `SharedValue` instance, which is the
    main stateful data object that lives in the UI thread context and has a similar
    concept to `Animated.Value` in the core Animated API. A Reanimated animation is
    triggered when `SharedValue` is changed. The key benefit is that updates to shared
    values can be synchronized across the React Native and UI threads without triggering
    a re-render. This enables complex animations to run smoothly at 60 FPS without
    blocking the JS thread.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useDerivedValue`: This hook creates a new shared value that automatically
    updates whenever the shared values used in its calculation change. It allows you
    to create shared values that depend on other shared values, while keeping them
    all reactive. `useDerivedValue` is used to create a **derived** state in a worklet
    that runs on the UI thread based on updates to the source shared values. This
    derived state can then drive animations or other side effects without triggering
    a re-render on the JS thread.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useAnimatedStyle`: The hook allows you to create a style object with the ability
    to animate its properties based on shared values. It maps shared value updates
    to the corresponding view properties. `useAnimatedStyle` is the main way to connect
    shared values to views and enable smooth animations running on the UI thread.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withTiming`, `withSpring`, `withDecay`: These are animation utility methods
    that update a shared value in a smooth, animated way using various curves and
    physics. They allow you to define animations declaratively by specifying the target
    value and animation configuration.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned what React Native Reanimated is and how it is different from
    the Animated API. Next, let’s try to install it and apply it to our app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Installing the React Native Reanimated library
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the React Native Reanimated library, run this command inside your
    Expo project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the installation is complete, we need to add the **Babel** plugin to
    `babel.config.js`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main purpose of that plugin is to convert our JavaScript worklet functions
    into functions that will work in the UI thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'After you add the Babel plugin, restart your development server and clear the
    bundler cache:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This section has introduced us to the React Native Reanimated library. We have
    found out why it is better than the built-in Animated API. In the next sections,
    we will use it in real examples.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Animating layout components
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common use case is animating the entering and exiting layouts of your components.
    This means that when your component renders for the first time and when you unmount
    your component, it appears animated. React Native Reanimated is an API that lets
    you animate layouts and add animations such as `FadeIn`, `BounceIn`, and `ZoomIn`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'React Native Reanimated also provides a special `Animated` component that is
    the same as the `Animated` component in the Animated API, but with additional
    props:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`entering`: Accepts a predefined animation when the component mounts and renders'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exiting`: Accepts the same animation object, but it will be called when the
    component unmounts'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s create a simple to-do list with a button for creating tasks and a feature
    that allows us to delete tasks when we click on them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: It’s impossible to see animations in screenshots, so I suggest you open the
    code and try to implement the animations to see the results.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let’s take a look at the main screen of our to-do list app and how
    the items are rendering at the moment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 1](img/B19636_26_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26.1: To-do list'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple example with a list of task items and one button for adding
    new tasks. When we quickly press the **Add** button several times, the list items
    come from the left side of the screen with an animation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 2](img/B19636_26_02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26.2: To-do list with animated rendering'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The magic is implemented in the `TodoItem` component. Let’s take a look at
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, there is no complicated logic, and there isn’t too much code.
    We just take the `Animated` component as the root of animation and pass predefined
    animations from the React Native Reanimated library to the `entering` and `exiting`
    props.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the items disappear from the screen, we need to press the to-do
    items so the exiting animation will run. I’ve pressed a few items and tried to
    catch the result in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 3](img/B19636_26_03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26.3: Deleting to-do items from the screen'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the `App` component to see the entire picture:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have created a `todoList` state using the `useState` hook and handler functions
    for adding and deleting tasks. Next, let’s take a look at how the animation will
    be applied to the layout:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we learned a simple way to apply animations to make our app
    look better. However, the React Native Reanimated library is a lot more powerful
    than we imagined. The next example illustrates how we can animate and create our
    own animations by applying them directly to the styles of our components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Animating component styles
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a more complex example, I suggest creating a button with beautiful tappable
    feedback. This button will be built using the `Pressable` component that we learned
    about in *Chapter 23*, *Responding to User Gestures*. This component accepts the
    `onPressIn`, `onLongPress`, and `onPressOut` events. As a result of these events,
    we will be able to see how our touches will be reflected on the button.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining `SharedValue` and `AnimatedStyle`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to animate style properties, we have created a `SharedValue` object
    using the `useSharedValue` hook. It takes default values as an argument. Next,
    we created the style object with the `useAnimatedStyle` hook. The hook accepts
    the callback that should return a style object. The `useAnimatedStyle` hook is
    similar to the `useMemo` hook, but all calculations are performed in the UI thread
    and all `SharedValue` changes will invoke the hook to recalculate the style object.
    The background color of the button was created using `useDerivedValue` by interpolating
    between orange and red to provide a smooth transition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create handler functions that will update the style properties
    in relation to the pressing state of the button:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first handler, `onPressIn`, updates `borderRadius`, `opacity`, and `scale`
    from their default values. We also update these values using `withSpring`, which
    makes updating styles smoother. Like the first handler, other ones will also update
    the style of the button but in different ways. `onLongPress` turns the button
    red and makes it smaller. `onPressOut` resets all values to their default values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve implemented all necessary logic and can now apply it to the layout:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, let’s take a look at the result:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 4](img/B19636_26_04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Figure 26.4: Button with default, pressed, and long-pressed styles'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 26.4*, you can see the three states of the button: default, pressed,
    and long-pressed.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned how to use the React Native Reanimated library
    to add animations to the layout and components. We’ve gone through the basic principles
    of the library and found out how it works under the hood and how it executes code
    inside the UI thread without using Bridge to connect JavaScript and Native layers
    of the app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: We also went through two examples using the React Native Reanimated library.
    In the first example, we learned how to apply a layout animation using predefined
    declarative animations to get our component to appear and disappear beautifully.
    In the second example, we animated the button’s styles with the `useSharedValue`
    and `useAnimatedStyle` hooks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Skills to animate components and layout will help you make your app more beautiful
    and responsive. In the next chapter, we’ll learn about controlling images in our
    apps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 动画组件和布局的技巧将帮助您使您的应用更加美观和响应。在下一章中，我们将学习如何在我们的应用中控制图像。
