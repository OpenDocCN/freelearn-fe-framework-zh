- en: Chapter 7. Rendering on the Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 服务器端渲染
- en: In the last chapter, you learned how to render different sections of our CMS
    without reloading the page. We even created a way to see the public pages of our
    website, using the same routing techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何在页面不重新加载的情况下渲染我们CMS的不同部分。我们甚至创建了一种方法来查看我们网站的公共页面，使用相同的路由技术。
- en: So far, we did everything in the browser. We stored pages in local storage.
    We used the website and CMS as if they were hosted on the Internet, but we're
    the only ones who can see it. If we want to share our creations with others, we
    need some kind of server-side technology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们都在浏览器中做所有事情。我们在本地存储中存储页面。我们像在互联网上托管一样使用网站和CMS，但我们是我们唯一能看到它的人。如果我们想与他人分享我们的创作，我们需要某种服务器端技术。
- en: In this chapter, we will take a brief look at some aspects of server-side JavaScript
    and React programming. We'll see how React works outside of the browser, and how
    we can persist and share data with many people in real-time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要了解服务器端JavaScript和React编程的一些方面。我们将看到React如何在浏览器之外工作，以及我们如何能够实时持久化和与他人共享数据。
- en: Rendering components to strings
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将组件渲染为字符串
- en: One of the beautiful things about React is that it works in many places. It
    is aimed at rendering interfaces efficiently, but those interfaces can extend
    outside of the DOM and the browser.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React的一个美妙之处在于它可以在许多地方工作。它的目标是高效渲染界面，但这些界面可以扩展到DOM和浏览器之外。
- en: You can use React to render native mobile interfaces ([https://facebook.github.io/react-native](https://facebook.github.io/react-native)),
    or even plain HTML strings. This becomes useful when we want to reuse the component
    code in different places.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用React来渲染原生移动界面([https://facebook.github.io/react-native](https://facebook.github.io/react-native))，或者甚至渲染纯HTML字符串。这在我们想要在不同地方重用组件代码时非常有用。
- en: We can, for instance, build an intricate data table component for our CMS. We
    can ship that component to an iPad application or even render it from the web
    server as a way of minimizing page load time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为我们的CMS构建一个复杂的数据表组件。我们可以将这个组件发送到iPad应用程序，或者甚至从Web服务器渲染它，以减少页面加载时间。
- en: 'It''s the latter example that we will try in this chapter. To begin, we need
    to install the source versions of React and React DOM libraries:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章尝试后者示例。首先，我们需要安装React和React DOM库的源版本：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve already seen examples of the React libraries, but these new ones (from
    BabelJS) will give us a way of using ES6 and JSX on the server. They even provide
    an alternative to running our code directly through Node.js. Normally, we would
    run server-side JavaScript code using the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了React库的例子，但这些新的（来自BabelJS）将给我们一种在服务器上使用ES6和JSX的方法。它们甚至提供了通过Node.js直接运行代码的替代方案。通常，我们会使用以下命令来运行服务器端JavaScript代码：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But, we can now use a BabelJS version, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们可以使用BabelJS版本，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to tell BabelJS which code presets to apply to our code. By default,
    it will apply a select few ES6 transformations, but not all of them. It also won''t
    handle JSX, unless we load that preset as well. We do this by creating a file
    called `.babelrc`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉BabelJS应用哪些代码预设到我们的代码中。默认情况下，它将应用一些ES6转换，但不是全部。它也不会处理JSX，除非我们加载那个预设。我们通过创建一个名为`.babelrc`的文件来实现这一点：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're used to seeing ES6 `import` statements, but perhaps not the RequireJS
    `require` statements. These are similar in function, and Node.js uses them as
    a means of importing code from external scripts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于看到ES6的`import`语句，但可能不习惯于RequireJS的`require`语句。它们在功能上相似，Node.js使用它们作为从外部脚本导入代码的一种方式。
- en: 'We also require a file called `hello-world.js`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个名为`hello-world.js`的文件：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There''s something new again! We have loaded a new React library, called `ReactDOMServer`
    and render a string from a `div` component. Usually we would use something like
    `React.render(component, element)` in the browser. But, here we''re only interested
    in the HTML string the component generates. Consider running the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 又有新东西了！我们加载了一个新的React库，名为`ReactDOMServer`，并从`div`组件中渲染一个字符串。通常我们会在浏览器中使用类似`React.render(component,
    element)`这样的方法。但在这里，我们只对组件生成的HTML字符串感兴趣。考虑运行以下代码：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the preceding command, we will see something resembling this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的命令时，我们会看到类似以下的内容：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Perhaps not exactly what we expect, but it looks like valid HTML. We can use
    this!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 也许并不完全符合我们的预期，但它看起来像有效的HTML。我们可以使用它！
- en: Creating a simple server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的服务器
- en: Now that we can render components to HTML strings, it would serve us better
    to have a way to respond to HTTP requests with HTML responses.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将组件渲染为HTML字符串，那么有一种方法可以响应HTTP请求并返回HTML响应将更有用。
- en: 'Fortunately, Node.js also includes a neat little HTTP server library. We can
    use the following code, in the `server.js` file, to respond to HTTP requests:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Node.js还包含了一个小巧的HTTP服务器库。我们可以在`server.js`文件中使用以下代码来响应HTTP请求：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To use the HTTP server library, we need to require/import it. We create a new
    server, and in the callback parameter, respond to individual HTTP requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTTP服务器库，我们需要引入/导入它。我们创建一个新的服务器，并在回调参数中响应单个HTTP请求。
- en: For each request, we set a content type and respond with the HTML value of our
    `hello-world.js` file. The server listens on port `3000`, which means you'll need
    to open `http://127.0.0.1:3000` to see this message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，我们设置内容类型，并使用`hello-world.js`文件的HTML值进行响应。服务器监听端口`3000`，这意味着你需要打开`http://127.0.0.1:3000`来看到这个消息。
- en: 'Before we can do that, we also need to adjust `hello-world.js` slightly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们还需要稍微调整`hello-world.js`：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `module.exports = ...` statement is the RequireJS equivalent of the `export
    default ...` statement that we're used to seeing. The result is that this file
    will return the component HTML string whenever it is required by another.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports = ...`语句是RequireJS中我们习惯看到的`export default ...`语句的等效语句。结果是，当这个文件被其他模块引入时，它将返回组件的HTML字符串。'
- en: 'If we open the URL (`http://127.0.0.1:3000`) in the browser, we should see
    a `hello world` message, and inspecting it will show similar React HTML for the
    component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开URL（`http://127.0.0.1:3000`），我们应该看到一个`hello world`消息，检查它将显示类似React
    HTML的组件：
- en: '![Creating a simple server](img/5268_07_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个简单的服务器](img/5268_07_01.jpg)'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about the Node.js HTTP server at [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)了解更多关于Node.js
    HTTP服务器的信息。
- en: Creating a server backend
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器后端
- en: One of the things our CMS is still missing is public, persistent pages. So far,
    we stored them in local storage, and that's OK while we build up our CMS components.
    But a time will come when we would want to share our data with the world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们CMS仍然缺少的是公开的、持久的页面。到目前为止，我们已经在本地存储中存储了它们，在我们构建CMS组件时这是可以接受的。但总有一天，我们希望与世界分享我们的数据。
- en: For this to work, we need some storage mechanism. Even if that storage is only
    in memory for as long as the server is running. Sure, we could use a relational
    database or an object store to persist our CMS pages. For now, let's keep things
    simple. An in-memory store (pages variable) should do for now.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要某种存储机制。即使这种存储只是服务器运行期间在内存中。当然，我们可以使用关系型数据库或对象存储来持久化我们的CMS页面。现在，让我们保持简单。一个内存存储（pages变量）现在应该足够了。
- en: So, how should we structure this data store? Whatever storage medium we choose,
    the interface will need to reach out to the server to store and retrieve data.
    There are two mainstream options I want to explore...
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该如何构建这个数据存储结构呢？无论我们选择哪种存储介质，接口都需要与服务器交互以存储和检索数据。我想探讨两种主流选项...
- en: Communicating through Ajax requests
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Ajax请求进行通信
- en: Ajax is a loaded word. For the purposes of this chapter, I want you to think
    of it only as a means to fetch data from a server and send data to it using HTTP
    requests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax是一个常用的词。在本章中，我希望你只将其视为一种通过HTTP请求从服务器获取数据并将其发送到服务器的手段。
- en: We've just seen how we can respond to HTTP requests, so we're half-way there!
    At this point, we can inspect requests to determine the URL and method of each
    HTTP request. A browser may be requesting something like `GET http://127.0.0.1:3000/pages`
    to get all the pages. So, if the method matches `POST` and the path matches `/pages`,
    then we can respond with the appropriate pages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何响应HTTP请求，所以我们已经完成了一半！在这个阶段，我们可以检查请求以确定每个HTTP请求的URL和方法。浏览器可能会请求类似`GET
    http://127.0.0.1:3000/pages`的内容来获取所有页面。所以，如果方法匹配`POST`且路径匹配`/pages`，那么我们可以相应地返回适当的页面。
- en: 'Luckily for us, others have been down this path before. Projects such as ExpressJS
    have sprung up to provide some scaffolding for us. Let''s install ExpressJS:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在我们之前已经有其他人走过这条路。例如ExpressJS这样的项目已经出现，为我们提供了一些脚手架。让我们来安装ExpressJS：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can convert our simple HTTP server to be based on ExpressJS:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的简单HTTP服务器转换为基于ExpressJS：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you'll need to restart the `node server.js` command after each
    change to these JavaScript files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次更改这些 JavaScript 文件后，你都需要重新启动 `node server.js` 命令。
- en: 'This should render exactly the same in a browser. However, it''s a lot easier
    to define application endpoints for new things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在浏览器中渲染得完全一样。然而，定义新事物的应用程序端点要容易得多：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `JSON.stringify` statement converts a JavaScript variable to a string representation,
    which is a useful format for communicating over a network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify` 语句将 JavaScript 变量转换为字符串表示形式，这对于通过网络进行通信非常有用。'
- en: We also have access to methods such as `app.post` for handling `POST` requests.
    It's really easy to start designing HTTP endpoints for our backend data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问 `app.post` 这样的方法来处理 `POST` 请求。为我们的后端数据设计 HTTP 端点非常容易。
- en: Then, in the browser, we need a way to make these requests. One common solution
    is to use a library such as jQuery. Sometimes that's a good idea, but usually
    only when you need more than just the Ajax functionality jQuery provides.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器中，我们需要一种方式来发送这些请求。一个常见的解决方案是使用 jQuery 这样的库。有时这确实是个好主意，但通常只有在你需要比 jQuery
    提供的 Ajax 功能更多的时候才这样做。
- en: 'If you''re looking for a lean solution, try something such as SuperAgent ([https://github.com/visionmedia/superagent](https://github.com/visionmedia/superagent))
    or even the new Fetch API ([https://developer.mozilla.org/en/docs/Web/API/Fetch_API](https://developer.mozilla.org/en/docs/Web/API/Fetch_API)):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个轻量级的解决方案，可以尝试 SuperAgent ([https://github.com/visionmedia/superagent](https://github.com/visionmedia/superagent))
    或甚至新的 Fetch API ([https://developer.mozilla.org/en/docs/Web/API/Fetch_API](https://developer.mozilla.org/en/docs/Web/API/Fetch_API))：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using this approach, we can slowly replace the local storage parts of our backend
    with calls to the server. There, we can store page data in an array, a relational
    database, or an object store.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以逐渐用对服务器的调用替换后端中的本地存储部分。在那里，我们可以在数组、关系型数据库或对象存储中存储页面数据。
- en: Ajax is a time-tested approach to communicate between the browser and the server.
    It's a well-supported technique with many kinds of shims for older browsers (from
    iframes to flash).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 是一种经过时间考验的浏览器和服务器之间通信的方法。它是一个得到良好支持的技巧，对于旧浏览器有许多种垫片（从 iframe 到 flash）。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about ExpressJS at [http://expressjs.com](http://expressjs.com).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://expressjs.com](http://expressjs.com) 上了解更多关于 ExpressJS 的信息。
- en: Communicating through web sockets
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 WebSocket 进行通信
- en: Sometimes, it's better to have fast, bi-directional communication between the
    browser and the server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在浏览器和服务器之间进行快速的双向通信会更好。
- en: 'At such a time, you can try web sockets. They''re an upgrade to the traditional
    HTTP communication seen in Ajax. To work with them easily, we need the help of
    Socket.IO:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的时刻，你可以尝试使用 WebSocket。它们是 Ajax 中传统 HTTP 通信的升级。为了轻松地与之交互，我们需要 Socket.IO 的帮助：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can access a new object, which we''ll call `io`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问一个新的对象，我们将称之为 `io`：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `"message"` can be anything. You can send messages of different types simply
    by changing this to something else. If you send a message with `"chat message"`
    or `"page command"`, then you need to add event listeners for the same message
    type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`"message"` 可以是任何内容。你可以通过将其更改为其他内容来发送不同类型的消息。如果你发送一个包含 `"chat message"` 或 `"page
    command"` 的消息，那么你需要为相同类型的消息添加事件监听器。'
- en: We create a new `io` instance with a reference to the HTTP server. Web socket
    connections begin with an HTTP request, so that's a good place to listen for them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个指向 HTTP 服务器的引用来创建一个新的 `io` 实例。WebSocket 连接始于一个 HTTP 请求，因此这是一个监听它们的良好位置。
- en: 'When new web socket connections are made, we can start to listen for messages.
    For now, we can just send the messages back. Socket.IO provides the web socket
    client script, but we do still need to connect and send messages. Let''s update
    `hello-world.js`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立新的 WebSocket 连接时，我们可以开始监听消息。目前，我们只需将消息发送回去。Socket.IO 提供了 WebSocket 客户端脚本，但我们仍然需要连接并发送消息。让我们更新
    `hello-world.js`：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are two important things to note in this block of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有两个重要的事项需要注意：
- en: We can use multiline strings as part of the ES6 syntax. Instead of single or
    double quotes, we can use backticks for strings that we want to span over multiple
    lines.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用多行字符串作为 ES6 语法的一部分。对于想要跨越多行的字符串，我们可以使用反引号而不是单引号或双引号。
- en: We can set the innerHTML (which is something we need to do to get JavaScript
    to render on the browser through this HTTP response) via the `dangerouslySetInnerHTML`
    attribute.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以通过 `dangerouslySetInnerHTML` 属性设置 innerHTML（这是我们需要做的，以便通过这个 HTTP 响应让 JavaScript
    在浏览器中渲染）。 '
- en: Note
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about `dangerouslySetInnerHTML` at [https://facebook.github.io/react/tips/dangerously-set-inner-html.html](https://facebook.github.io/react/tips/dangerously-set-inner-html.html).
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://facebook.github.io/react/tips/dangerously-set-inner-html.html](https://facebook.github.io/react/tips/dangerously-set-inner-html.html)了解更多关于`dangerouslySetInnerHTML`的信息。
- en: 'In our web socket examples, the flow of data resembles the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的WebSocket示例中，数据流类似于以下内容：
- en: An HTTP and web socket server listen on `http://127.0.0.1:3000`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP和WebSocket服务器监听`http://127.0.0.1:3000`。
- en: Requests to `/` return some browser scripts.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`/`的请求返回一些浏览器脚本。
- en: These scripts begin a connection request to the server.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些脚本开始向服务器发起连接请求。
- en: The server picks up these connection requests and adds event listeners for new
    messages after the connections are successfully opened.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收到这些连接请求，并在连接成功打开后添加新消息的事件监听器。
- en: The browser scripts add event listeners for new messages and immediately a send
    message to the server.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器脚本为新消息添加事件监听器，并立即向服务器发送消息。
- en: The server's event listeners are triggered and the messages are re-sent to all
    open sockets.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器的事件监听器被触发，并将消息重新发送到所有打开的套接字。
- en: The browser's event listeners are triggered and the messages are written to
    the console.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器的事件监听器被触发，并将消息写入控制台。
- en: Note
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we broadcast the messages (from the server) to all open sockets.
    You can limit the messages to specific socket connections using something such
    as `socket.emit("message", message)`. Check the Socket.IO documentation for examples.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将消息（来自服务器）广播到所有打开的套接字。你可以使用类似`socket.emit("message", message)`的方式将消息限制在特定的套接字连接上。请查看Socket.IO文档中的示例。
- en: 'You should see the `hello world` message in the console:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台中看到`hello world`消息：
- en: '![Communicating through web sockets](img/5268_07_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![通过WebSocket进行通信](img/5268_07_02.jpg)'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Socket.IO at [http://socket.io](http://socket.io).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://socket.io](http://socket.io)了解更多关于Socket.IO的信息。
- en: Structuring server-side applications
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化服务器端应用程序
- en: When it comes to HTTP and web socket servers, it's usually a good idea to separate
    the endpoint code from the server initialization code. Some folks like to create
    separate routes files, which can then be required by the `server.js` file. Still
    others like to have each endpoint as a separate file and define routes as glue
    between `server.js` and these "handler" files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到HTTP和WebSocket服务器时，通常将端点代码与服务器初始化代码分开是一个好主意。有些人喜欢创建单独的路由文件，这些文件可以被`server.js`文件引入。还有一些人喜欢将每个端点作为一个单独的文件，并将路由定义为`server.js`和这些“处理程序”文件之间的粘合剂。
- en: Perhaps that's enough for the kinds of applications you will build, or perhaps
    you like a more prescriptive structure to your applications, something such as
    AdonisJS ([http://adonisjs.com](http://adonisjs.com)), for example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能已经足够用于你将要构建的应用程序类型，或者你可能喜欢一个更规定的应用程序结构，例如AdonisJS ([http://adonisjs.com](http://adonisjs.com))，例如。
- en: Adonis is a beautifully structured MVC framework for Node.js applications. It
    uses many cool tricks (such as generators) to enable a clean API for defining
    templates, request handlers, and database code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Adonis是一个为Node.js应用程序设计的结构优美的MVC框架。它使用许多酷炫的技巧（如生成器）来提供一个干净的API，用于定义模板、请求处理程序和数据库代码。
- en: 'A typical request can be handled in the following way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的请求可以按以下方式处理：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You would define this class in a file called `app/Http/Controllers/HomeController.js`.
    To have this file rendered, when browsers go to the home page of your website,
    you can define a route in `app/Http/routes.js`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为`app/Http/Controllers/HomeController.js`的文件中定义这个类。为了在浏览器访问你的网站主页时渲染此文件，你可以在`app/Http/routes.js`中定义一个路由：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can couple this with some persistent, relational database storage:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以结合一些持久的关系型数据库存储：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All in all, AdonisJS provides a lot of structure to an otherwise open and interpretive
    landscape. It reminds me a lot of the popular PHP framework—Laravel, which itself
    draws queues from the popular Ruby on Rails framework.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，AdonisJS为原本开放和可解释的领域提供了很多结构。它让我想起了流行的PHP框架Laravel，而Laravel本身又从流行的Ruby on
    Rails框架中汲取了灵感。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about AdonisJS at [http://adonisjs.com](http://adonisjs.com).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://adonisjs.com](http://adonisjs.com)了解更多关于AdonisJS的信息。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to render components on the server. We created
    a simple HTTP server and then upgraded it to allow multiple endpoints and web
    sockets. Finally, we looked briefly at how we can structure our server-side code
    and quickly looked at the AdonisJS MVC framework.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在服务器上渲染组件。我们创建了一个简单的HTTP服务器，并将其升级以允许多个端点和WebSocket。最后，我们简要地探讨了如何结构化我们的服务器端代码，并快速了解了AdonisJS
    MVC框架。
- en: In the next chapter, you will learn about some popular React design patterns
    that you can apply to your components and interfaces.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习一些流行的React设计模式，这些模式可以应用于你的组件和界面。
