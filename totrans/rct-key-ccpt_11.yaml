- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Complex State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage cross-component or even app-wide state (instead of just component-specific
    state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribute data across multiple components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle complex state values and changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State is one of the core concepts you must understand (and work with) to use
    React effectively. Basically, every React app utilizes (many) state values across
    many components to present a dynamic, reactive user interface.
  prefs: []
  type: TYPE_NORMAL
- en: From simple state values that contain a changing counter or values entered by
    users, all the way up to more complex state values such as the combination of
    multiple form inputs or user authentication information, state is everywhere.
    In React apps, it’s typically managed with the help of the `useState()` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: However, once you start building more complex React applications (e.g., online
    shops, admin dashboards, and similar sites), it is likely that you’ll face various
    challenges related to state. State values might be used in component A but changed
    in component B or be made up of multiple dynamic values that may change for a
    broad variety of reasons (e.g., a cart in an online shop, which is a combination
    of products, where every product has a quantity, a price, and possibly other traits
    that may be changed individually).
  prefs: []
  type: TYPE_NORMAL
- en: You can handle all these problems with `useState()` , props, and the other concepts
    covered by this book thus far. But you will notice that solutions based on `useState()`
    alone gain a complexity that can be difficult to understand and maintain. That’s
    why React has more tools to offer—tools created for these kinds of problems, which
    this chapter will highlight and discuss.
  prefs: []
  type: TYPE_NORMAL
- en: A Problem with Cross-Component State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You don’t even need to build a highly sophisticated React app to encounter
    a common problem: state that spans multiple components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might be building a news app where users can bookmark certain
    articles. A simple user interface could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: An example user interface'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, the list of articles is on the left,
    and a summary of the bookmarked articles can be found in the sidebar on the right.
  prefs: []
  type: TYPE_NORMAL
- en: A common solution is to split this user interface into multiple components.
    The list of articles, specifically, would probably be in its own component—just
    like the bookmark summary sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: However, in that scenario, both components would need to access the same shared
    state—that is, the list of bookmarked articles. The article list component would
    require access in order to add (or remove) articles. The bookmark summary sidebar
    component would require it as it needs to display the bookmarked articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component tree and state usage for this kind of app could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Two sibling components share the same state'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, you can see that the state is shared across these two components.
    You also see that the two components have a shared parent component (the `News`
    component, in this example).
  prefs: []
  type: TYPE_NORMAL
- en: Since the state is used by two components, you would not manage it in either
    of those components. Instead, it’s *lifted up* , as described in *Chapter 4* ,
    *Working with Events and State* (in the *Lifting State Up* section). When lifting
    state up, the state values and pointers to the functions that manipulate the state
    values are passed down to the actual components that need access via props.
  prefs: []
  type: TYPE_NORMAL
- en: This works and is a common pattern. You can (and should) keep on using it. But
    what if a component that needs access to some shared state is deeply nested in
    other components? What if the app component tree from the preceding example looked
    like this?
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: A component tree with multiple layers of state-dependent components'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, you can see that the `BookmarkSummary` component is a deeply
    nested component. Between it and the `News` component (which manages the shared
    state), you have two other components: the `InfoSidebar` component and the `BookmarkInformation`
    component. In more complex React apps, having multiple levels of component nesting,
    as in this example, is very common.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, even with those extra components, state values can still be passed
    down via props. You just need to add props to **all** components between the component
    that holds the state and the component that needs the state. For example, you
    must pass the `bookmarkedArticles` state value to the `InfoSidebar` component
    (via props) so that that component can forward it to `BookmarkInformation` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The same procedure is repeated inside of the `BookmarkInformation` component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/01-cross-cmp-state](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/01-cross-cmp-state)
    .
  prefs: []
  type: TYPE_NORMAL
- en: This kind of pattern is called **prop drilling** . Prop drilling means that
    a state value is passed through multiple components via props. And it’s passed
    through components that don’t need the state themselves at all—except for forwarding
    it to a child component (as the `InfoSidebar` and `BookmarkInformation` components
    are doing in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you will typically want to avoid this pattern because prop
    drilling has a few weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Components that are part of prop drilling (such as `InfoSidebar` or `BookmarkInformation`
    ) are not really reusable anymore because any component that wants to use them
    has to provide a value for the forwarded state prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prop drilling also leads to a lot of overhead code that has to be written (the
    code to accept props and forward props).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring components becomes more work because state props have to be added
    or removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, prop drilling is only acceptable if all components involved
    are only used in this specific part of the overall React app, and the probability
    of reusing or refactoring them is low.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since prop drilling should be avoided (in most situations), React offers an
    alternative: the **context** API.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Context to Handle Multi-Component State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React’s context feature is one that allows you to create a value that can easily
    be shared across as many components as needed, without using props.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a website  Description automatically generated](img/B31339_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: React Context is attached to components to expose it to all child
    components—without prop drilling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the context API is a multi-step process, the steps for which are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: You must create a context value that should be shared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The context must be provided in a parent component of the components that need
    access to the context object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Components that need access (for reading or writing) must subscribe to the context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React manages the context value (and its changes) internally and automatically
    distributes it to all components that have subscribed to the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before any component may subscribe, however, the first step is to create a
    context object. This is done via React’s `createContext()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function takes an initial value that should be shared. It can be any kind
    of value (e.g., a string or a number), but typically, it’s an object. This is
    because most shared values are a combination of the actual values and functions
    that should manipulate those values. All these things are then grouped together
    into a single context object.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the initial context value can also be an empty value (e.g., `null`
    , `undefined` , an empty `string` , etc.) if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`createContext()` also returns a value: a context object that should be stored
    in a capitalized variable (or constant) because it’s actually a React component
    (and React components should start with capital characters).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the `createContext()` function can be called to create a context
    object for the example discussed earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the initial value is an object that contains the `bookmarkedArticles`
    property, which holds an (empty) array. You could also store just the array as
    an initial value (i.e., `createContext([])` ) but an object is better since more
    will be added to it later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This code is typically placed in a separate context code file (e.g., `bookmark-context.jsx`
    ) that’s often stored in a folder named `store` (because this context feature
    can be used as a central state store) or `context` . However, this is just a convention
    and is not technically required. You can put this code anywhere in your React
    app.
  prefs: []
  type: TYPE_NORMAL
- en: If the file only contains the above code, it may use `.js` as a file extension
    since it doesn’t contain any JSX code. Later in this chapter, this will change—therefore
    you can already use `.jsx` as an extension.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this initial value is not a replacement for state; it’s a static
    value that never changes. But this was just the first of three steps related to
    context. The next step is to provide the context.
  prefs: []
  type: TYPE_NORMAL
- en: Providing and Managing Context Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use context values in other components, you must first provide the
    value. This is done using the value returned by `createContext()` .
  prefs: []
  type: TYPE_NORMAL
- en: When using React 19 or higher, that function yields a React component that should
    be wrapped around all other components that need access to the context value.
  prefs: []
  type: TYPE_NORMAL
- en: When using an older version of React (i.e., React 18 or older), the value returned
    by `createContext()` instead is an object that contains a nested `Provider` property.
    That property then holds a React component that should be wrapped around all other
    components that need access to the context value.
  prefs: []
  type: TYPE_NORMAL
- en: So, either way, it’s all about wrapping components with a context provider component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, using React 19 or higher, the `BookmarkContext` component
    returned by `createContext()` could be used in the `News` component to wrap it
    around both the `Articles` and `InfoSidebar` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if using React 18 or lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this code does not work because one important thing is missing: the
    component expects a `value` prop, which should contain the current context value
    that should be distributed to interested components. While you do provide an initial
    context value (which could have been empty), you also need to inform React about
    the current context value because, very often, context values change (they are
    often used as a replacement for the cross-component state, after all).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the code could be altered like this when using React 19 or higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if using React 18 or lower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this code, an object with a list of bookmarked articles is distributed
    to interested descendent components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list is still static, though. But that can be changed with a tool you already
    know about: the `useState()` Hook. Inside the `News` component, you can use the
    `useState()` Hook to manage the list of bookmarked articles, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the context changes from static to dynamic. Whenever the `savedArticles`
    state changes, the context value will change.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, that’s the missing piece when it comes to providing the context.
    If the context should be dynamic (and changeable from inside some nested child
    component), the context value should also include a pointer to the function that
    triggers a state update.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the preceding example, the code is therefore adjusted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are two important things changed in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two new functions were added: `addArticle` and `removeArticle` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properties that point at these functions were added to `bookmarkCtxValue` :
    the `bookmarkArticle` and `unbookmarkArticle` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addArticle` function adds a new article (which should be bookmarked) to
    the `savedArticles` state. The function form of updating the state value is used
    since the new state value depends on the previous state value (the bookmarked
    article is added to the list of already bookmarked articles).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `removeArticle` function removes an article from the `savedArticles`
    list by filtering the existing list such that all items, except for the one that
    has a matching `id` value, are kept.
  prefs: []
  type: TYPE_NORMAL
- en: If the `News` component did not use the new context feature, it would be a component
    that uses state, just as you have seen many times before in this book. But now,
    by using React’s context API, those existing capabilities are combined with a
    new feature (the context) to create a dynamic, distributable value.
  prefs: []
  type: TYPE_NORMAL
- en: Any components nested in the `Articles` or `InfoSidebar` components (or their
    descendent components) will be able to access this dynamic context value, and
    the `bookmarkArticle` and `unbookmarkArticle` methods in the context object, without
    any prop drilling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to create dynamic context values. You could also distribute a
    static value to nested components. This is possible but a rare scenario, since
    most React apps typically need dynamic state values that can change across components.
  prefs: []
  type: TYPE_NORMAL
- en: Using Context in Nested Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the context created and provided, it’s ready to be used by components that
    need to access or change the context value.
  prefs: []
  type: TYPE_NORMAL
- en: To make the context value accessible to components nested inside the context
    component ( `BookmarkContext` , in the preceding example), React offers a `use()`
    Hook that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: This Hook, however, is only available when working with React 19 or higher.
    In projects that use older React versions, you would instead use the `useContext()`
    Hook for accessing some context value. That Hook is also still supported in React
    19, hence you can use either of the two Hooks for getting hold of a context value.
  prefs: []
  type: TYPE_NORMAL
- en: The `use()` Hook is a bit more flexible than the `useContext()` Hook since,
    unlike any other Hooks, it may actually also be used from inside `if` statements
    or loops. In addition, the Hook can be used for more than getting access to context
    values—you’ll therefore see `use()` again in *Chapter 17* , *Understanding React
    Suspense & The use() Hook* .
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, when working with React 19, if you’re trying to get access to
    a context value, both `use()` and `useContext()` can be used. Both `use()` and
    `useContext()` require one argument: the context object that was created via `createContext()`
    , i.e., the value returned by that function. As a result, you’ll then get the
    value passed to the context provider component (i.e., the value set for its `value`
    prop). When working with React 19 or higher, since `use()` is a bit more flexible
    and certainly a bit less to type, you can ignore `useContext()` and use the `use()`
    Hook for accessing context values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the preceding example, the context value can be used in the `BookmarkSummary`
    component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `use()` receives the `BookmarkContext` value, which is imported
    from the `store/bookmark-context.jsx` file. It then returns the value stored in
    the context, which is the `bookmarkCtxValue` found in the previous code example.
    As you can see in that snippet, `bookmarkCtxValue` is an object with three properties:
    `bookmarkedArticles` , `bookmarkArticle` (a method), and `unbookmarkArticle` (also
    a method).'
  prefs: []
  type: TYPE_NORMAL
- en: This returned object is stored in a `bookmarkCtx` constant. Whenever the context
    value changes (because the `setSavedArticles` state-updating function in the `News`
    component is executed), this `BookmarkSummary` component will also be executed
    again by React, and thus `bookmarkCtx` will hold the latest state value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `BookmarkSummary` component, the `bookmarkedArticles` property
    is accessed on the `bookmarkCtx` object. This list of articles is then used to
    calculate the number of bookmarked articles, output a short summary, and display
    the list on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `BookmarkContext` can be used via `use()` in the `Articles` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this component, the context is used to determine whether or not a given article
    is currently bookmarked (this information is required in order to change the icon
    and functionality of the button).
  prefs: []
  type: TYPE_NORMAL
- en: That’s how context values (whether static or dynamic) can be read in components.
    Of course, they can also be changed, as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Context from Nested Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React’s context feature is often used to share data across multiple components
    without using props. It’s therefore also quite common that some components must
    manipulate that data. For example, the context value for a shopping cart must
    be adjustable from inside the component that displays product items (because those
    probably have an `"Add to cart"` button).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to change context values from inside a nested component, you cannot
    simply overwrite the stored context value. The following code would not work as
    intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code does not work. Just as you should not try to update state by simply
    assigning a new value, you can’t update context values by assigning a new value.
    That’s why two methods ( `bookmarkArticle` and `unbookmarkArticle` ) were added
    to the context value in the *Providing and Managing Context Values* section. These
    two methods point at functions that trigger state updates (via the state-updating
    function provided by `useState()` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in the `Articles` component, where articles can be bookmarked or
    unbookmarked via button clicks, these methods should be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `bookmarkArticle` and `unbookmarkArticle` methods are called inside of anonymous
    functions that are stored in a `buttonAction` variable. That variable is assigned
    to the `onClick` prop of the `<button>` (see the previous code snippet).
  prefs: []
  type: TYPE_NORMAL
- en: With this code, the context value can be changed successfully. Thanks to the
    steps taken in the previous section ( *Using Context in Nested Components* ),
    whenever the context value is updated, it is then also automatically reflected
    in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The finished example code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/02-cross-cmp-state-with-context](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/02-cross-cmp-state-with-context)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Using the Context API Efficiently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to create, provide, access, and change context is important—ultimately,
    it is these things that allow you to use React’s context API in your applications.
    But as your applications (and therefore probably also your context values) become
    more complex, it’s also important to set up and manage your context efficiently,
    for example, by getting proper IDE support.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Better Code Completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the section *Using Context to Handle Multi-Component State* , a context object
    was created via `createContext()` . That function received an initial context
    value—an object that contains a `bookmarkedArticles` property, in the preceding
    example.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the initial context value isn’t too important. It’s not often
    used because it’s overwritten with a new value inside the `News` component regardless.
    However, depending on which **Integrated Development Environment** **(IDE** )
    you’re using, you can get better code auto-completion when defining an initial
    context value that has the same shape and structure as the final context value
    that will be managed in other React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, since two methods were added to the context value in the section
    *Providing and Managing Context Values* , those methods should also be added to
    the initial context value in `store/bookmark-context.jsx` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The two methods are added as empty functions that do nothing because the actual
    logic is set in the `News` component. The methods are only added to this initial
    context value to provide better IDE auto-completion. This step is therefore optional.
  prefs: []
  type: TYPE_NORMAL
- en: Context or Lifting State Up?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you now have two tools for managing cross-component state:'
  prefs: []
  type: TYPE_NORMAL
- en: You can lift state up, as described earlier in the book (in *Chapter 4* , *Working
    with Events and State* , in the *Lifting State Up* section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can use React’s context API, as explained in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which of the two approaches should you use in each scenario?
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, it is up to you how you manage this, but there are some straightforward
    rules you can follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Lift the state up if you only need to share state across one or two levels of
    component nesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the context API if you have long chains of components (i.e., deep nesting
    of components) with shared state. Once you start to use a lot of prop drilling,
    it’s time to consider React’s context feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also use the context API if you have a relatively flat component tree but want
    to reuse components (i.e., you don’t want to use props for passing state to components).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outsourcing Context Logic into Separate Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the previously explained steps, you have everything you need to manage
    cross-component state via context.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is one pattern you can consider for managing your dynamic context
    value and state: creating a separate component for providing (and managing) the
    context value.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `News` component was used to provide the context
    and manage its (dynamic, state-based) value. While this works, your components
    can get unnecessarily complex if they have to deal with context management. Creating
    a separate, dedicated component for that can therefore lead to code that’s easier
    to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the preceding example, that means that, inside of the `store/bookmark-context.jsx`
    file, you could create a `BookmarkContextProvider` component that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This component contains all the logic related to managing a list of bookmarked
    articles via state. It creates the same context value as before (a value that
    contains the list of articles as well as two methods for updating that list).
  prefs: []
  type: TYPE_NORMAL
- en: The `BookmarkContextProvider` component does one additional thing though. It
    uses the special `children` prop (covered in *Chapter 3* , *Components and Props*
    , in the *The Special “children” Prop* section) to wrap whatever is passed between
    the `BookmarkContextProvider` 's component tags with `BookmarkContext` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows the use of the `BookmarkContextProvider` component in the `News`
    component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Instead of managing the entire context value, the `News` component now simply
    imports the `BookmarkContextProvider` component and wraps that component around
    `Articles` and `InfoSidebar` . The `News` component, therefore, is leaner.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is entirely optional. It’s neither an official best practice nor
    does it yield any performance benefits. It’s just a pattern that can help with
    keeping your component functions lean and concise.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth mentioning that there is a related pattern for consuming context.
    That pattern, however, relies on building a custom React Hook—a concept that will
    be covered in the next chapter. Therefore, the mentioned context consumption pattern
    will be covered in the next chapter, too.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Multiple Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Especially in bigger and more feature-rich React applications, it is possible
    (and quite probable), that you will need to work with multiple context values
    that are likely unrelated to each other. For example, an online shop could use
    one context for managing the shopping cart, another context for the user authentication
    status, and yet another context value for tracking page analytics.
  prefs: []
  type: TYPE_NORMAL
- en: React fully supports use cases like this. You can create, manage, provide, and
    use as many context values as needed. You can manage multiple (related or unrelated)
    values in a single context or use multiple contexts. You can provide multiple
    contexts in the same component or in different components. It is totally up to
    you and your app’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use multiple contexts in the same component (meaning that you can
    call `use()` or `useContext()` multiple times, with different context values).
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of useState( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far in this chapter, the complexity of cross-component state has been explored.
    But state management can also get challenging in scenarios where some state is
    only used inside a single component.
  prefs: []
  type: TYPE_NORMAL
- en: '`useState()` is a great tool for state management in most scenarios (of course,
    right now, it’s also the only tool that’s been covered). Therefore, `useState()`
    should be your default choice for managing state. But `useState()` can reach its
    limits if you need to derive a new state value that’s based on the value of another
    state variable, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This short snippet is taken from a component where an HTTP request is sent
    to fetch some blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/04-complex-usestate](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/examples/04-complex-usestate)
    .
  prefs: []
  type: TYPE_NORMAL
- en: When initiating the request, an `isLoading` state value (responsible for showing
    a loading indicator on the screen) should be set to `true` only if no data was
    fetched before. If data was fetched before (i.e., `fetchedPosts` is not `null`
    ), that data should still be shown on the screen, instead of some loading indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first sight, this code might not look problematic. But it actually violates
    an important rule related to `useState()` : you should not reference the current
    state to set a new state value. If you need to do so, you should instead use the
    function form of the state updating function (see the *Updating State Based on
    Previous State Correctly* section of *Chapter 4* , *Working with Events and State*
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: However, in the preceding example, this solution won’t work. If you switch to
    the functional state-updating form, you only get access to the current value of
    the state you’re trying to update. You don’t get (safe) access to the current
    value of some other state. In the preceding example, another state ( `fetchedPosts`
    instead of `isLoading` ) is referenced. Therefore, you must violate the mentioned
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'This violation also has real consequences (in this example). The following
    code snippet is part of a function called `fetchPosts` , which is wrapped with
    `useCallback()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This function sends an HTTP request and changes multiple state values based
    on the state of the request.
  prefs: []
  type: TYPE_NORMAL
- en: '`useCallback()` is used to avoid an infinite loop related to `useEffect()`
    (see *Chapter 8* , *Handling Side Effects* , to learn more about `useEffect()`
    , infinite loops, and `useCallback()` as a remedy). Normally, `fetchedPosts` should
    be added as a dependency to the `dependencies` array passed as a second argument
    to the `useCallback()` function. However, in this example, this can’t be done
    because `fetchedPosts` is changed inside the function wrapped by `useCallback()`
    , and the state value is therefore not just a dependency but also actively changed.
    This causes an infinite loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, a warning is shown in the terminal and the intended behavior of
    not showing the loading indicator if data was fetched before is not achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: A warning about the missing dependency is output in the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: Problems like the one just described are common if you have multiple related
    state values that depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution would be to move from multiple, individual state slices
    ( `fetchedPosts` , `isLoading` , and `error` ) to a single, combined state value
    (i.e., to an object). That would ensure that all state values are grouped together
    and can thereby be accessed safely when using the functional state-updating form.
    The state-updating code could then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This solution would work. However, ending up with ever more complex (and nested)
    state objects, managed via `useState()` , is not typically desirable as it can
    make state management a bit harder and bloat your component code.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why React offers an alternative to `useState()` : the `useReducer()`
    Hook.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing State with useReducer( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like `useState()` , `useReducer()` is a React Hook. And just like `useState()`
    , it is a Hook that can trigger component function re-evaluations. But, of course,
    it works slightly differently; otherwise, it would be a redundant Hook.
  prefs: []
  type: TYPE_NORMAL
- en: '`useReducer()` is a Hook meant to be used for managing complex state objects.
    You will rarely (probably never) use it to manage simple string or number values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This Hook takes two main arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A reducer function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An initial state value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This brings up an important question: what is a reducer function?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Reducer Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the context of `useReducer()` , a reducer function is a function that receives
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The current state value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action that was dispatched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides receiving arguments, a reducer function must also return a value: the
    new state. It’s called a reducer function because it reduces the old state (combined
    with an action) to a new state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this all a bit easier to grasp and reason through, the following code
    snippet shows how `useReducer()` is used in conjunction with such a reducer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At the bottom of this snippet, you can see that `useReducer()` is called inside
    of the `App` component function. Like all React Hooks, it must be called inside
    of component functions or other Hooks. You can also see the two arguments that
    were mentioned previously (the reducer function and the initial state value) being
    passed to `useReducer()` .
  prefs: []
  type: TYPE_NORMAL
- en: '`httpReducer` is the reducer function. The function takes two arguments ( `state`
    , which is the old state, and `action` , which is the dispatched action) and returns
    different state objects for different action types.'
  prefs: []
  type: TYPE_NORMAL
- en: This reducer function takes care of all possible state updates. The entire state-updating
    logic is therefore outsourced from the component (note that `httpReducer` is defined
    outside of the component function).
  prefs: []
  type: TYPE_NORMAL
- en: But the component function must, of course, be able to trigger the defined state
    updates. That’s where actions become important.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the reducer function is created outside of the component function.
    You could also create it inside the component function, but that is not recommended.
    If you create the reducer function inside the component function, it will technically
    be recreated every time the component function is executed. This impacts performance
    unnecessarily since the reducer function does not need access to any component
    function values (state or props).
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code shown previously is incomplete. When calling `useReducer()` in a component
    function, it does not just take two arguments. Instead, the Hook also returns
    a value—an array with exactly two elements (just like `useState()` , though the
    elements are different).
  prefs: []
  type: TYPE_NORMAL
- en: '`useReducer()` should therefore be used like this (in the `App` component):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, array destructuring is used to store the two elements (and
    it is always exactly two!) in two different constants: `httpState` and `dispatch`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the returned array ( `httpState` , in this case) is the
    state value returned by the reducer function. It’s updated (meaning that the component
    function is called by React) whenever the reducer function is executed again.
    The element is called `httpState` in this example because it contains the state
    value, which is related to an HTTP request in this instance. That said, how you
    name the element in your case is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second element ( `dispatch` , in the example) is a function. It’s a function
    that can be called to trigger a state update (i.e., to execute the reducer function
    again). When executed, the `dispatch` function must receive one argument—that
    is, the action value that will be available inside of the reducer function (via
    the reducer function’s second argument). Here’s how `dispatch` can be used in
    a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The element is called `dispatch` in the example because it’s a function used
    for dispatching actions to the reducer function. Just as before, the name is up
    to you, but `dispatch` is a commonly chosen name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape and structure of that action value are also entirely up to you, but
    it’s often set to an object that contains a `type` property. The `type` property
    is used in the reducer function to perform different actions for different types
    of actions. `type` therefore acts as an action identifier. You can see the `type`
    property being used inside the `httpReducer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add as many properties to the action object as needed. In the preceding
    example, some state updates access `action.payload` to extract some extra data
    from the action object. Inside a component, you would pass data along with the
    action like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, the property name ( `payload` ) is up to you, but passing extra data
    along with the action allows you to perform state updates that rely on data generated
    by the component function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the complete, final code for the entire `App` component function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, you can see how different actions (with different `type`
    and sometimes `payload` properties) are dispatched. You can also see that the
    `httpState` value is used to show different user interface elements based on the
    state (e.g., `<p>Loading…</p>` is shown if `httpState.isLoading` is `true` ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management can have its challenges—especially when dealing with cross-component
    (or app-wide) state or complex state values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-component state can be managed by lifting state up or by using React’s
    context API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The context API is typically preferable if you do a lot of prop drilling (forwarding
    state values via props across multiple component layers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the context API, you use `createContext()` to create a new context
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The created context object is a component that must be wrapped around the part
    of the component tree that should get access to the context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with React 18 or older, the context object itself is not a component
    but an object that offers a nested `Provider` property that is a component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components can access the context value via the `use()` (with React 19 or higher)
    or `useContext()` Hooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For managing complex state values, `useReducer()` can be a good alternative
    to `useState()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useReducer()` utilizes a reducer function that converts the current state
    and a dispatched action to a new state value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useReducer()` returns an array with exactly two elements: the state value
    and a dispatch function, which is used for dispatching actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to manage both simple and complex state values efficiently is important.
    This chapter introduced two crucial tools that help with the task.
  prefs: []
  type: TYPE_NORMAL
- en: With the context API’s `use()` , `useContext()` , and `useReducer()` Hooks,
    three new React Hooks were introduced. Combined with all the other Hooks covered
    thus far in the book, these mark the last of the React Hooks you will need in
    your everyday work as a React developer.
  prefs: []
  type: TYPE_NORMAL
- en: As a React developer, you’re not limited to the built-in Hooks, though. You
    can also build your own Hooks. The next chapter will finally explore how that
    works and why you might want to build custom Hooks in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/11-complex-state/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/11-complex-state/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: Which problem can be solved with React’s context API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which three main steps have to be taken when using the context API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When might `useReducer()` be preferred over `useState()` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When working with `useReducer()` , what’s the role of actions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apply your knowledge about the context API and the `useReducer()` Hook to some
    real problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.1: Migrating an App to the Context API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your task is to improve an existing React project. Currently,
    the app is built without the context API, and so cross-component state is managed
    by lifting the state up. In this project, prop drilling is the consequence in
    some components. Therefore, the goal is to adjust the app such that the context
    API is used for cross-component state management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    in this case) to use the right code snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: The provided project also uses many features covered in earlier chapters. Take
    your time to analyze it and understand the provided code. This is great practice
    and allows you to see many key concepts in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the code and run `npm install` in the project folder
    (to install all required dependencies), you can start the development server via
    `npm run dev` . As a result, upon visiting `localhost:5173` , you should see the
    following user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: The running starting project'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the activity, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new context for the cart items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Provider` component for the context and handle all context-related
    state changes there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the context (with the help of the `Provider` component) and make sure
    all components that need access to the context have access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the old logic (where state was lifted up).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the context in all the components that need access to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user interface should be the same as that shown in *Figure 11.6* once you
    have completed the activity. Make sure that the user interface works exactly as
    it did before you implemented React’s context features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: All code files used for this activity, and the solution, can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.2: Replacing useState() with useReducer()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, your task is to replace the `useState()` Hooks in the `Form`
    component with `useReducer()` . Use only one single reducer function (and thus
    only one `useReducer()` call) and merge all relevant state values into one state
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-2-start`
    in this case) to use the right code snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: The provided project also uses many features covered in earlier chapters. Take
    your time to analyze it and understand the provided code. This is great practice
    and allows you to see many key concepts in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded the code and run `npm install` in the project folder
    (to install all required dependencies), you can start the development server via
    `npm run dev` . As a result, upon visiting `localhost:5173` , you should see the
    following user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: The running starting project'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the provided starting project, users get one of three results upon clicking
    the `Submit` button:'
  prefs: []
  type: TYPE_NORMAL
- en: If one or both input fields didn’t receive any input, an error message tells
    users to fill in the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If users entered values into both input fields, but at least one of the inputs
    holds an invalid value, a different error message is shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If users entered valid values into both input fields, the entered values are
    printed in the developer tools JavaScript console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To complete the activity, the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove (or comment out) the existing logic in the `Form` component that uses
    the `useState()` Hook for state management.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reducer function that handles two actions (email changed and password
    changed) and also returns a default value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the state object based on the dispatched action type (and payload, if
    needed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the reducer function with the `useReducer()` Hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dispatch the appropriate actions (with the appropriate data) in the `Form` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the state value where needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user interface should be the same as that shown in *Figure 11.7* once you’ve
    finished the activity. Make sure that the user interface works exactly as it did
    before you implemented React’s context features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: All code files used for this activity, and the solution, can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/11-complex-state/activities/practice-2)
    .
  prefs: []
  type: TYPE_NORMAL
