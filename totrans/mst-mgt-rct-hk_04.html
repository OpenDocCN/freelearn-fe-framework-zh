<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.1.1">Chapter 2</span></em><span class="koboSpan" id="kobo.2.1">: Using Local and Global States</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">React components form a tree structure. </span><span class="koboSpan" id="kobo.3.2">In the tree structure, creating a state in a whole subtree is straightforward; you would simply create a local state in a higher component in a tree and use the state in the component and its child components. </span><span class="koboSpan" id="kobo.3.3">This is good in terms of locality and reusability and is why it's generally recommended to follow this strategy. </span></p>
			<p><span class="koboSpan" id="kobo.4.1">However, in some scenarios, we have a state in two or more components that are far apart in the tree. </span><span class="koboSpan" id="kobo.4.2">In such cases, this is where global states come in. </span><span class="koboSpan" id="kobo.4.3">Unlike local states, global states do not conceptually belong to a specific component, and so where we store a global state is an important point to consider.</span></p>
			<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will learn about local states, including some lifting-up patterns that may be worth considering. </span><span class="koboSpan" id="kobo.5.2">Lifting up is a technique to put information higher in the component tree. </span><span class="koboSpan" id="kobo.5.3">Then, we will dive into global states and consider when to use them.</span></p>
			<p><span class="koboSpan" id="kobo.6.1">We are going to cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.7.1">Understanding when to use local states</span></li>
				<li><span class="koboSpan" id="kobo.8.1">Effectively using local states</span></li>
				<li><span class="koboSpan" id="kobo.9.1">Using global states</span></li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.10.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.11.1">To run the code snippets in this chapter, you need a React environment—for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.12.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.13.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.14.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.15.1">).</span></p>
			<p><span class="koboSpan" id="kobo.16.1">You are expected to have basic knowledge of React and React hooks, especially the concept around the component tree (</span><a href="https://reactjs.org/docs/components-and-props.html"><span class="koboSpan" id="kobo.17.1">https://reactjs.org/docs/components-and-props.html</span></a><span class="koboSpan" id="kobo.18.1">) and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">useState</span></strong><span class="koboSpan" id="kobo.20.1"> hook (</span><a href="https://reactjs.org/docs/hooks-reference.html#usestate"><span class="koboSpan" id="kobo.21.1">https://reactjs.org/docs/hooks-reference.html#usestate</span></a><span class="koboSpan" id="kobo.22.1">).</span></p>
			<p><span class="koboSpan" id="kobo.23.1">The code in this chapter is available on GitHub at </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_02"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_02</span></a><span class="koboSpan" id="kobo.25.1">.</span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.26.1">Understanding when to use local states</span></h1>
			<p><span class="koboSpan" id="kobo.27.1">Before we consider React, let's see how JavaScript functions work. </span><span class="koboSpan" id="kobo.27.2">JavaScript functions can either </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.28.1">be pure or impure. </span><span class="koboSpan" id="kobo.28.2">A pure function depends only on its arguments and returns the same value </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.29.1">as long as the arguments are the same. </span><span class="koboSpan" id="kobo.29.2">A state holds a value outside arguments, and functions that depend on the state become impure. </span><span class="koboSpan" id="kobo.29.3">React components are also functions and can be pure. </span><span class="koboSpan" id="kobo.29.4">If we use a state in a React component, it will be impure. </span><span class="koboSpan" id="kobo.29.5">However, if the state is local to the component, it doesn't affect other components, and we call this characteristic "contained."</span></p>
			<p><span class="koboSpan" id="kobo.30.1">In this section, we learn JavaScript functions, and how similar React components are to JavaScript functions. </span><span class="koboSpan" id="kobo.30.2">We then discuss how a local state is conceptually implemented.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.31.1">Functions and arguments</span></h2>
			<p><span class="koboSpan" id="kobo.32.1">In JavaScript, a function takes </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.33.1">an argument and returns a value. </span><span class="koboSpan" id="kobo.33.2">For example, here's </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.34.1"> a simple function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.35.1">const addOne = (n) =&gt; n + 1;</span></p>
			<p><span class="koboSpan" id="kobo.36.1">This is a pure function that always returns the same value for the same argument. </span><span class="koboSpan" id="kobo.36.2">It is often the case that pure functions are preferred because their behavior is predictable.</span></p>
			<p><span class="koboSpan" id="kobo.37.1">A function can depend on global variables, such as the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.38.1">let base = 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.39.1">const addBase = (n) =&gt; n + base;</span></p>
			<p><span class="koboSpan" id="kobo.40.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">addBase</span></strong><span class="koboSpan" id="kobo.42.1"> function works exactly the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">addOne</span></strong><span class="koboSpan" id="kobo.44.1">, as long as </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">base</span></strong><span class="koboSpan" id="kobo.46.1"> isn't changed. </span><span class="koboSpan" id="kobo.46.2">However, if at some point we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">base</span></strong><span class="koboSpan" id="kobo.48.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">base=2</span></strong><span class="koboSpan" id="kobo.50.1">, it behaves differently. </span><span class="koboSpan" id="kobo.50.2">This is not a bad thing at all, and it's actually a powerful feature as you can change the function behavior from outside. </span><span class="koboSpan" id="kobo.50.3">The downside is that you can't simply grab the </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">addBase</span></strong><span class="koboSpan" id="kobo.52.1"> function and use it arbitrarily somewhere else without knowing it depends on an outside variable. </span><span class="koboSpan" id="kobo.52.2">As you can tell, it's a trade-off.</span></p>
			<p><span class="koboSpan" id="kobo.53.1">This is not a preferred pattern if </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">base</span></strong><span class="koboSpan" id="kobo.55.1"> is a </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">singleton</span></strong><span class="koboSpan" id="kobo.57.1"> (a single value in memory) because the code </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.58.1">becomes less reusable. </span><span class="koboSpan" id="kobo.58.2">To avoid the singleton and mitigate the </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.59.1">downside a little, a more modular approach would be to create a container object, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.60.1">const createContainer = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.61.1">  let base = 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.62.1">  const addBase = (n) =&gt; n + base;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.63.1">  const changeBase = (b) =&gt; { base = b; };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.64.1">  return { addBase, changeBase };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.65.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.66.1">const { addBase, changeBase } = createContainer();</span></p>
			<p><span class="koboSpan" id="kobo.67.1">This is no longer a singleton, and you can create as many containers as you want. </span><span class="koboSpan" id="kobo.67.2">Unlike having a </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">base</span></strong><span class="koboSpan" id="kobo.69.1"> global variable as a singleton, containers are isolated and are more reusable. </span><span class="koboSpan" id="kobo.69.2">You can use a container in one part of your code without affecting other parts of your code with a different container.</span></p>
			<p><span class="koboSpan" id="kobo.70.1">A small note: although </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">addBase</span></strong><span class="koboSpan" id="kobo.72.1"> in a container is not a mathematically pure function, you can get </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.73.1">the same result by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">addBase</span></strong><span class="koboSpan" id="kobo.75.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">base</span></strong><span class="koboSpan" id="kobo.77.1"> is not changed (this characteristic is sometimes called </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">idempotent</span></strong><span class="koboSpan" id="kobo.79.1">).</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.80.1">React components and props</span></h2>
			<p><span class="koboSpan" id="kobo.81.1">React is conceptually a function that converts a state to a </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">user interface</span></strong><span class="koboSpan" id="kobo.83.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.84.1">UI</span></strong><span class="koboSpan" id="kobo.85.1">). </span><span class="koboSpan" id="kobo.85.2">When you code </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.86.1">with React, the React component is literally a JavaScript </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.87.1">function, and its </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.88.1">arguments are called props.</span></p>
			<p><span class="koboSpan" id="kobo.89.1">A function component that shows a number will look like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.90.1">const Component = ({ number }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.91.1">  return &lt;div&gt;{number}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.92.1">};</span></p>
			<p><span class="koboSpan" id="kobo.93.1">This component takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">number</span></strong><span class="koboSpan" id="kobo.95.1"> argument and returns a </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">JavaScript syntax extension</span></strong><span class="koboSpan" id="kobo.97.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.98.1">JSX</span></strong><span class="koboSpan" id="kobo.99.1">) element </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.100.1">that represents the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">number</span></strong><span class="koboSpan" id="kobo.102.1"> on screen.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.103.1">What Is a JSX Element?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.104.1">JSX is a syntax with angle brackets to produce React elements. </span><span class="koboSpan" id="kobo.104.2">A React element is a data structure to </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.105.1">represent a part of the UI. </span><span class="koboSpan" id="kobo.105.2">We may refer to React elements as JSX elements, especially when React elements are in JSX syntax.</span></p>
			<p><span class="koboSpan" id="kobo.106.1">Now, let's make another component that shows a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">number + 1</span></strong><span class="koboSpan" id="kobo.108.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.109.1">const AddOne = ({ number }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.110.1">  return &lt;div&gt;{number + 1}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.111.1">};</span></p>
			<p><span class="koboSpan" id="kobo.112.1">This component takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">number</span></strong><span class="koboSpan" id="kobo.114.1"> and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">number + 1</span></strong><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">This behaves exactly like </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">addOne</span></strong><span class="koboSpan" id="kobo.118.1"> in the previous section, and this is a pure function. </span><span class="koboSpan" id="kobo.118.2">The only differences are that the argument is a props object and the return value is in JSX format.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.119.1">Understanding useState for local states</span></h2>
			<p><span class="koboSpan" id="kobo.120.1">What if we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">useState</span></strong><span class="koboSpan" id="kobo.122.1"> for a local state? </span><span class="koboSpan" id="kobo.122.2">Let's make </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">base</span></strong><span class="koboSpan" id="kobo.124.1"> a state and display a </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">number</span></strong><span class="koboSpan" id="kobo.126.1"> that </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.127.1">we can add to it, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.128.1">const AddBase = ({ number }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.129.1">  const [base, changeBase] = useState(1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.130.1">  return &lt;div&gt;{number + base}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.131.1">};</span></p>
			<p><span class="koboSpan" id="kobo.132.1">This function </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.133.1">is not technically pure as it depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">base</span></strong><span class="koboSpan" id="kobo.135.1">, which is not in the function arguments.</span></p>
			<p><span class="koboSpan" id="kobo.136.1">What does </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">useState</span></strong><span class="koboSpan" id="kobo.138.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">AddBase</span></strong><span class="koboSpan" id="kobo.140.1"> do? </span><span class="koboSpan" id="kobo.140.2">Let's remind ourselves of </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">createContainer</span></strong><span class="koboSpan" id="kobo.142.1"> in the previous section. </span><span class="koboSpan" id="kobo.142.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">createContainer</span></strong><span class="koboSpan" id="kobo.144.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">base</span></strong><span class="koboSpan" id="kobo.146.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">changeBase</span></strong><span class="koboSpan" id="kobo.148.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">useState</span></strong><span class="koboSpan" id="kobo.150.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">base</span></strong><span class="koboSpan" id="kobo.152.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">changeBase</span></strong><span class="koboSpan" id="kobo.154.1"> in a tuple (meaning a structure of two or more values—in this case, two). </span><span class="koboSpan" id="kobo.154.2">We don't explicitly see how </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">base</span></strong><span class="koboSpan" id="kobo.156.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">changeBase</span></strong><span class="koboSpan" id="kobo.158.1"> are created in this code, but it's conceptually similar. </span></p>
			<p><span class="koboSpan" id="kobo.159.1">If we assume the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">useState</span></strong><span class="koboSpan" id="kobo.161.1"> behavior, meaning it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">base</span></strong><span class="koboSpan" id="kobo.163.1"> unless changed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">AddBase</span></strong><span class="koboSpan" id="kobo.165.1"> function is idempotent, as we saw with </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">createContainer</span></strong><span class="koboSpan" id="kobo.167.1">.</span></p>
			<p><span class="koboSpan" id="kobo.168.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">AddBase</span></strong><span class="koboSpan" id="kobo.170.1"> function with </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">useState</span></strong><span class="koboSpan" id="kobo.172.1"> is contained because </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">changeBase</span></strong><span class="koboSpan" id="kobo.174.1"> is only available within </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.175.1">the scope of the function declaration. </span><span class="koboSpan" id="kobo.175.2">It's impossible to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">base</span></strong><span class="koboSpan" id="kobo.177.1"> outside the function. </span><span class="koboSpan" id="kobo.177.2">This usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">useState</span></strong><span class="koboSpan" id="kobo.179.1"> is a local </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.180.1">state, and because it's contained and doesn't affect anything outside the component, it ensures locality; this usage is preferred whenever appropriate.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.181.1">Limitation of local states</span></h2>
			<p><span class="koboSpan" id="kobo.182.1">When is a local state not appropriate? </span><span class="koboSpan" id="kobo.182.2">It isn't appropriate when we want to break the locality. </span><span class="koboSpan" id="kobo.182.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">AddBase</span></strong><span class="koboSpan" id="kobo.184.1"> component example, it's when we want to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">base</span></strong><span class="koboSpan" id="kobo.186.1"> from a totally different </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.187.1">part of the code. </span><span class="koboSpan" id="kobo.187.2">If you need to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">state</span></strong><span class="koboSpan" id="kobo.189.1"> from outside the function component, that's when a global state comes in.</span></p>
			<p><span class="koboSpan" id="kobo.190.1">The state variable is conceptually a global variable. </span><span class="koboSpan" id="kobo.190.2">A global variable is useful to control a JavaScript function's behavior </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.191.1">from outside the function. </span><span class="koboSpan" id="kobo.191.2">Likewise, a global </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.192.1">state is useful to control React component behavior from outside the component. </span><span class="koboSpan" id="kobo.192.2">However, using a global state makes the component behavior less predictable. </span><span class="koboSpan" id="kobo.192.3">It's a trade-off. </span><span class="koboSpan" id="kobo.192.4">We shouldn't use global states more than we need to. </span><span class="koboSpan" id="kobo.192.5">Consider using local states as a primary means and only use global states for a secondary mean. </span><span class="koboSpan" id="kobo.192.6">In this sense, it's important to learn how many use cases local states can cover.</span></p>
			<p><span class="koboSpan" id="kobo.193.1">In this section, we learned about a local state in React, alongside JavaScript functions. </span><span class="koboSpan" id="kobo.193.2">Coming up, we will learn some patterns to use local states.</span></p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.194.1">Effectively using local states</span></h1>
			<p><span class="koboSpan" id="kobo.195.1">There are some patterns you should know to be able to use a local state effectively. </span><span class="koboSpan" id="kobo.195.2">In this section, we will </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.196.1">learn how to lift states up, which means defining a state higher in the component tree, and lifting content up, which means defining a content higher in the component tree.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.197.1">Lifting state up</span></h2>
			<p><span class="koboSpan" id="kobo.198.1">Let's suppose we </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.199.1">have two counter components, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.200.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.201.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.202.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.203.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.204.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.205.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.206.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.207.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.208.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.209.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.210.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.211.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.212.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.213.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.214.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.215.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.216.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.217.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.218.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.219.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.220.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.221.1">};</span></p>
			<p><span class="koboSpan" id="kobo.222.1">Because there are two separate local states defined in the two components, these two counters work </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.223.1">separately. </span><span class="koboSpan" id="kobo.223.2">In case we want to share the state and make it work for a single shared counter, we can create a parent component and lift the state up.</span></p>
			<p><span class="koboSpan" id="kobo.224.1">Here is an example with a single parent component that contains both </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Component1</span></strong><span class="koboSpan" id="kobo.226.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Component2</span></strong><span class="koboSpan" id="kobo.228.1"> as children and passes props to them:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.229.1">const Component1 = ({ count, setCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.230.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.231.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.232.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.233.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.234.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.235.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.236.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.237.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.238.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.239.1">const Component2 = ({ count, setCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.240.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.241.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.242.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.243.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.244.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.245.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.246.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.247.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.248.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.249.1">const Parent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.250.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.251.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.252.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.253.1">      &lt;Component1 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.254.1">      &lt;Component2 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.255.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.256.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.257.1">};</span></p>
			<p><span class="koboSpan" id="kobo.258.1">Because the count state is defined just once in </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Parent</span></strong><span class="koboSpan" id="kobo.260.1">, the state is shared between </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Component1</span></strong><span class="koboSpan" id="kobo.262.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Component2</span></strong><span class="koboSpan" id="kobo.264.1">. </span><span class="koboSpan" id="kobo.264.2">This is </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.265.1">still a local state in a component; its child components can use the state from the parent component.</span></p>
			<p><span class="koboSpan" id="kobo.266.1">This pattern would work in most use cases with a local state; however, there's a slight concern about performance. </span><span class="koboSpan" id="kobo.266.2">If we lift up the state, </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Parent</span></strong><span class="koboSpan" id="kobo.268.1"> will render as well as the entire subtree, including all its child components. </span><span class="koboSpan" id="kobo.268.2">This may be a performance issue in some use cases.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.269.1">Lift content up</span></h2>
			<p><span class="koboSpan" id="kobo.270.1">With </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.271.1">complex component trees, we may have a component that doesn't depend on the state we are lifting up.</span></p>
			<p><span class="koboSpan" id="kobo.272.1">In the following example, we add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">AdditionalInfo</span></strong><span class="koboSpan" id="kobo.274.1"> component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Component1</span></strong><span class="koboSpan" id="kobo.276.1"> from the previous example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.277.1">const AdditionalInfo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.278.1">  return &lt;p&gt;Some information&lt;/p&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.279.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.280.1">const Component1 = ({ count, setCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.281.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.282.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.283.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.284.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.285.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.286.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.287.1">      &lt;AdditionalInfo /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.288.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.289.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.290.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.291.1">const Parent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.292.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.293.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.294.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">      &lt;Component1 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.296.1">      &lt;Component2 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.297.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.298.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.299.1">};</span></p>
			<p><span class="koboSpan" id="kobo.300.1">If the count is changed, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">Parent</span></strong><span class="koboSpan" id="kobo.302.1"> re-renders, and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Component1</span></strong><span class="koboSpan" id="kobo.304.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Component2</span></strong><span class="koboSpan" id="kobo.306.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">AdditionalInfo</span></strong><span class="koboSpan" id="kobo.308.1"> re-render too. </span><span class="koboSpan" id="kobo.308.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">AdditionalInfo</span></strong><span class="koboSpan" id="kobo.310.1"> doesn't have to re-render in this case because it doesn't depend on </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">count</span></strong><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">This is an extra re-render that should be avoided if it has an impact on performance.</span></p>
			<p><span class="koboSpan" id="kobo.313.1">To avoid extra re-renders, we can lift up content. </span><span class="koboSpan" id="kobo.313.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Parent</span></strong><span class="koboSpan" id="kobo.315.1"> re-renders with </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">count</span></strong><span class="koboSpan" id="kobo.317.1">, hence, we </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.318.1">create </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">GrandParent</span></strong><span class="koboSpan" id="kobo.320.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.321.1">const AdditionalInfo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.322.1">  return &lt;p&gt;Some information&lt;/p&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.323.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.324.1">const Component1 = ({ count, setCount, additionalInfo }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.325.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.326.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.327.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.328.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.329.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.330.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.331.1">      {additionalInfo}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.332.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.333.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.334.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.335.1">const Parent = ({ additionalInfo }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.336.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.337.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.338.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.339.1">      &lt;Component1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.340.1">        count={count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.341.1">        setCount={setCount}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.342.1">        additionalInfo={additionalInfo}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.343.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.344.1">      &lt;Component2 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.345.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.346.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.347.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.348.1">const GrandParent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.349.1">  return &lt;Parent additionalInfo={&lt;AdditionalInfo /&gt;} /&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.350.1">};</span></p>
			<p><span class="koboSpan" id="kobo.351.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">GrandParent</span></strong><span class="koboSpan" id="kobo.353.1"> component has </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">additionalInfo</span></strong><span class="koboSpan" id="kobo.355.1"> (a JSX element), which is passed down to the children. </span><span class="koboSpan" id="kobo.355.2">By doing this, </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">AdditionalInfo</span></strong><span class="koboSpan" id="kobo.357.1"> doesn't re-render when </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">count</span></strong><span class="koboSpan" id="kobo.359.1"> changes. </span><span class="koboSpan" id="kobo.359.2">This is a </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.360.1">technique we should consider not only for performance but also for organizing your component tree structure.</span></p>
			<p><span class="koboSpan" id="kobo.361.1">A variant of this is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">children</span></strong><span class="koboSpan" id="kobo.363.1"> props. </span><span class="koboSpan" id="kobo.363.2">The following example using </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">children</span></strong><span class="koboSpan" id="kobo.365.1"> props is equivalent to the previous example, but with a different coding style:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.366.1">const AdditionalInfo = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.367.1">  return &lt;p&gt;Some information&lt;/p&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.368.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.369.1">const Component1 = ({ count, setCount, children }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.370.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.371.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.372.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.373.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.374.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.375.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.376.1">      {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.377.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.378.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.379.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.380.1">const Parent = ({ children }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.381.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.382.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.383.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.384.1">      &lt;Component1 count={count} setCount={setCount}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.385.1">        {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.386.1">      &lt;/Component1&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.387.1">      &lt;Component2 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.388.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.389.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.390.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.391.1">const GrandParent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.392.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.393.1">    &lt;Parent&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.394.1">      &lt;AdditionalInfo /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.395.1">    &lt;/Parent&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.396.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.397.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">children</span></strong><span class="koboSpan" id="kobo.399.1"> is a special prop name that is represented as nested children elements in JSX format. </span><span class="koboSpan" id="kobo.399.2">If you have </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.400.1">several elements to pass, naming your props would fit better. </span><span class="koboSpan" id="kobo.400.2">It's mostly a stylistic choice, and developers can take whichever approach they prefer.</span></p>
			<p><span class="koboSpan" id="kobo.401.1">In this section, we learned some patterns to effectively use local states. </span><span class="koboSpan" id="kobo.401.2">If we lift up states and content properly, we should be able to solve various use cases with only local states. </span><span class="koboSpan" id="kobo.401.3">Coming up, we will learn how to use global states.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.402.1">Using global states</span></h1>
			<p><span class="koboSpan" id="kobo.403.1">In this section, we will learn what a global state is again and when we should use it.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.404.1">What is a global state?</span></h2>
			<p><span class="koboSpan" id="kobo.405.1">In this book, a global state simply means that it's </span><em class="italic"><span class="koboSpan" id="kobo.406.1">not</span></em><span class="koboSpan" id="kobo.407.1"> a local state. </span><span class="koboSpan" id="kobo.407.2">If a state conceptually belongs to a single </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.408.1">component and is encapsulated by the component, it is a local state. </span><span class="koboSpan" id="kobo.408.2">Hence, if a state doesn't belong to a single component and can be used by multiple components, it is a global state. </span></p>
			<p><span class="koboSpan" id="kobo.409.1">There could be an application-wide local state that all components depend on. </span><span class="koboSpan" id="kobo.409.2">In this case, the application-wide local state can be seen as a global state. </span><span class="koboSpan" id="kobo.409.3">In this sense, we can't clearly divide local states and global states. </span><span class="koboSpan" id="kobo.409.4">In most cases, if you consider where a state conceptually belongs, you can work out whether it's local or global.</span></p>
			<p><span class="koboSpan" id="kobo.410.1">There are two </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.411.1">aspects when people talk about a global state, as outlined here:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.412.1">One is a singleton, meaning that in some contexts, the state has one value.</span></li>
				<li><span class="koboSpan" id="kobo.413.1">The other is a shared state, which means that the state value is shared among different components, but it doesn't have to be the single value in JavaScript memory. </span><span class="koboSpan" id="kobo.413.2">A global state that is not a singleton can have multiple values.</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.414.1">To illustrate how a non-singleton global state works, here is an example to show a non-singleton variable in JavaScript:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.415.1">const createContainer = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.416.1">  let base = 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.417.1">  const addBase = (n) =&gt; n + base;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.418.1">  const changeBase = (b) =&gt; { base = b; };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.419.1">  return { addBase, changeBase };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.420.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.421.1">const container1 = createContainer();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.422.1">const container2 = createContainer();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.423.1">container1.changeBase(10);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.424.1">console.log(container1.addBase(2)); // shows "3"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.425.1">console.log(container2.addBase(2)); // shows "12"</span></p>
			<p><span class="koboSpan" id="kobo.426.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">base</span></strong><span class="koboSpan" id="kobo.428.1"> is a scoped </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.429.1">variable in a container. </span><span class="koboSpan" id="kobo.429.2">As </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">base</span></strong><span class="koboSpan" id="kobo.431.1"> is isolated in each container, changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">base</span></strong><span class="koboSpan" id="kobo.433.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">container1</span></strong><span class="koboSpan" id="kobo.435.1"> doesn't affect </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">base</span></strong><span class="koboSpan" id="kobo.437.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">container2</span></strong><span class="koboSpan" id="kobo.439.1">. </span></p>
			<p><span class="koboSpan" id="kobo.440.1">In React, the concept is similar. </span><span class="koboSpan" id="kobo.440.2">If a global state is a singleton, we have only one value in memory. </span><span class="koboSpan" id="kobo.440.3">If a global state is non-singleton, we may have multiple values for different parts (subtrees) of a component tree.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.441.1">When to use global states</span></h2>
			<p><span class="koboSpan" id="kobo.442.1">There are two guidelines for </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.443.1">when we need a global state in React, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.444.1">When passing a prop is not desirable</span></li>
				<li><span class="koboSpan" id="kobo.445.1">When we already have a state outside of React</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.446.1">Let's discuss each of them.</span></p>
			<h3><span class="koboSpan" id="kobo.447.1">Prop passing is not desirable</span></h3>
			<p><span class="koboSpan" id="kobo.448.1">If you need a state in two components that are far away in the component tree, it would not be desirable </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.449.1">to have a state in the common root component and then pass the state all the way down to the two components.</span></p>
			<p><span class="koboSpan" id="kobo.450.1">For example, if our tree is three levels deep and we need to lift up the state to the top, it would look like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.451.1">const Component1 = ({ count, setCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.452.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.453.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.454.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.455.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.456.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.457.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.459.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.460.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.461.1">const Parent = ({ count, setCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.462.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.463.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.464.1">      &lt;Component1 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.465.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.466.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.467.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.468.1">const GrandParent = ({ count, setCount }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.469.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.470.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.471.1">      &lt;Parent count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.472.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.473.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.474.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.475.1">const Root = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.476.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.477.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.478.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.479.1">      &lt;GrandParent count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.480.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.481.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.482.1">};</span></p>
			<p><span class="koboSpan" id="kobo.483.1">This is totally fine and recommended for locality; however, it could be too tedious to have your intermediate components used to pass props. </span><span class="koboSpan" id="kobo.483.2">Passing props through multi-level intermediate </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.484.1">components might not result in a good developer experience, because it could seem like unnecessary extra work. </span><span class="koboSpan" id="kobo.484.2">Furthermore, the intermediate components re-render when the state is updated, which may impact performance. </span></p>
			<p><span class="koboSpan" id="kobo.485.1">In such cases, having a global state is more appropriate, and no intermediate components need to take care of passing the state. </span></p>
			<p><span class="koboSpan" id="kobo.486.1">Here is some pseudo code showing how a global state would work with the previous example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.487.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.488.1">  // useGlobalCountState is a pseudo hook </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.489.1">  const [count, setCount] = useGlobalCountState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.490.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.491.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.492.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.493.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.494.1">        Increment Count</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.495.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.496.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.497.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.498.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.499.1">const Parent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.500.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.501.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.502.1">      &lt;Component1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.503.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.504.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.505.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.506.1">const GrandParent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.507.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.508.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.509.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.510.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.511.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.512.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.513.1">const Root = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.514.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.515.1">    &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.516.1">      &lt;GrandParent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.517.1">    &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.519.1">};</span></p>
			<p><span class="koboSpan" id="kobo.520.1">In this example, the only component that uses a global state is </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Component1</span></strong><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">Unlike with local states and </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.523.1">prop passing, no intermediate components, </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">Parent</span></strong><span class="koboSpan" id="kobo.525.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">GrandParent</span></strong><span class="koboSpan" id="kobo.527.1">, know about a global state.</span></p>
			<h3><span class="koboSpan" id="kobo.528.1">Already have a state outside of React</span></h3>
			<p><span class="koboSpan" id="kobo.529.1">In some cases, you would already have a global state outside of React, as having a global state outside is more straightforward. </span><span class="koboSpan" id="kobo.529.2">For example, your app might have user-authenticated information that you obtained without React somehow. </span><span class="koboSpan" id="kobo.529.3">In such an example, a global state should exist outside React, and the authentication information could be stored in a global state. </span></p>
			<p><span class="koboSpan" id="kobo.530.1">Here is some pseudo code showing such an example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.531.1">const globalState = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.532.1">  authInfo: { name: 'React' },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.533.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.534.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.535.1">  // useGlobalState is a pseudo hook</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.536.1">  const { authInfo } = useGlobalState();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.537.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.538.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.539.1">      {authInfo.name}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.540.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.541.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.542.1">};</span></p>
			<p><span class="koboSpan" id="kobo.543.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">globalState</span></strong><span class="koboSpan" id="kobo.545.1"> exists and is defined outside React. </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">useGlobalState</span></strong><span class="koboSpan" id="kobo.547.1"> is a hook that would connect to </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">globalState</span></strong><span class="koboSpan" id="kobo.549.1"> and that could provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">authInfo</span></strong><span class="koboSpan" id="kobo.551.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">Component1</span></strong><span class="koboSpan" id="kobo.553.1">.</span></p>
			<p><span class="koboSpan" id="kobo.554.1">In this section, we learned that a global state is a state that can't be a local state. </span><span class="koboSpan" id="kobo.554.2">Global state is mainly used </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.555.1">secondary to local states, and there are two patterns where using a global state works well: one is in a case where prop passing doesn't make sense, and the other is where a global state already exists in an app.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.556.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.557.1">In this chapter, we discussed local states and global states. </span><span class="koboSpan" id="kobo.557.2">Local states are preferable whenever possible, and we learned some techniques to use local states effectively. </span><span class="koboSpan" id="kobo.557.3">However, global states play a role where local states do not, which is why we looked at when you should use global states instead.</span></p>
			<p><span class="koboSpan" id="kobo.558.1">In the next three chapters, we will learn three patterns to implement a global state in React; in the next chapter specifically, we will start with utilizing React context.</span></p>
		</div>
	</body></html>