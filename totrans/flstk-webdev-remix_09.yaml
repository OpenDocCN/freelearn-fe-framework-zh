- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assets and Metadata Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve practiced routing, data loading and mutations, handling errors,
    and managing state and sessions in Remix. However, building for the web also involves
    managing static assets to ensure a smooth and efficient user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to manage static assets and meta tags in
    Remix. This chapter is split into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Using meta tags in Remix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling fonts, images, stylesheets, and other assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing assets with loader functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will use Remix’s `meta` export to create dynamic meta tags based on
    loader data. Next, we will investigate how to expose static assets in Remix. We
    will create a `robots.txt` file, add a custom font, and experiment with nested
    stylesheets. After that, we will discuss managing images in Remix. Finally, we
    will see how we can create assets dynamically in `loader` functions.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will understand how to work with meta tags in
    Remix. You will also know how to expose and access static assets and how to link
    external resources. Finally, you will know how to expose dynamic assets via `loader`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/09-assets-and-meta-data-handling](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/09-assets-and-meta-data-handling).
    You can go ahead and use the end solution from the previous chapter. No additional
    setup steps are required for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Using meta tags in Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Meta tags are used to describe the content of an HTML document. They are important
    for **Search Engine Optimization** (**SEO**) and are used by web crawlers to understand
    the content of your site. Meta tags are also used to configure browser behavior,
    link previews, and the site’s appearance in the bookmark list and search results.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the title, description, and image meta tags are used on link previews
    and search pages, like Google's search results. The title meta tag is also used
    together with the favicon to display the website in the bookmark list.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to add meta tags to your Remix application.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring global meta tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An application usually exposes some global meta tags that must be included
    on every page. Since Remix allows us to manage the full HTML document in React,
    including the head, we can inline global meta tags in the root of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the `Document` component in `root.tsx`. Notice that we export two global
    meta tags to set the `charSet` attribute and `viewport` meta tag of the application.
    As always, you can find more information about browser APIs and the web platform
    in the MDN Web Docs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `viewport` meta tag: [https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `charSet` attribute: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attributes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content-aware meta tags, such as `title` and `description`, must be set dynamically
    for every page. In Remix, we can use the `meta` export to inject meta tags into
    the head of our application. Let’s see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the meta function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every route module in Remix can export a `meta` function. Remix follows the
    route hierarchy to find the closest `meta` export and injects it into the head
    of the HTML document. Let’s jump into the code of our BeeRich application and
    investigate how the `meta` export is used to define meta tags:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app/root.tsx` file and look for the `meta` export:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run BeeRich locally with `npm` `run dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the app in a browser window by navigating to [http://localhost:3000/](http://localhost:3000/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the HTML by using the developer tools of your browser. The head element’s
    content should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a description metadata object to the `meta` function’s return value in
    `root.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inspect the JSX of the `Document` component in `root.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s investigate how Remix manages nested `meta` exports.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting meta exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll add some `meta` exports to nested route modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `_layout.login.tsx` route module and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the login page by navigating to [http://localhost:3000/login](http://localhost:3000/login)
    and inspect the content of the head element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the title and description defined in `root.tsx` are overridden by
    the nested `meta` export.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the meta export in nested route modules to override parent meta tags
  prefs: []
  type: TYPE_NORMAL
- en: The `meta` route module export lets us define meta tags at any level in the
    route hierarchy. Remix uses the closest `meta` function return values and adds
    them to the head of the document by using the `Meta` component. Nested `meta`
    exports replace parent `meta` exports.
  prefs: []
  type: TYPE_NORMAL
- en: Remix initially renders on the server. The rendered document includes all declared
    meta tags and ensures that crawlers can inspect all meta tags without the need
    to execute client-side JavaScript. This is great for SEO.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the content of the meta tags depends on dynamic data. For example, you
    may want to use the title and summary of an article for the title and description
    meta tags. Let’s see how we can access loader data in `meta` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using loader data in meta functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `meta` function runs both on the client and the server. On initial render,
    the `meta` function is called during server-side rendering. For all subsequent
    client-side navigations, the `meta` function is executed on the client after the
    loader data has been fetched from the server. In both cases, Remix passes the
    route’s loader data and a hash map of all parent loader data to the `meta` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will add the current user’s name to the title of the BeeRich
    dashboard and explore how we can take advantage of loader data in `meta` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `dashboard.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `loader` function in `dashboard.tsx` to return the current user's
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following `meta` function export to the route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! Just like that, we can use dynamic data to create metatags. However,
    one question remains: Why do we use the `?` operator to check whether the (loader)
    `data` property is defined before accessing `username`?'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `meta` function is also executed if an error occurs. This ensures
    our meta tags are added even when an error boundary is rendered. If we render
    an error boundary, then the loader data won’t be available. Conclusively, in `meta`,
    we must always check whether the `data` property is defined before accessing its
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Meta functions run on the client, the server, and on error
  prefs: []
  type: TYPE_NORMAL
- en: A `meta` function runs even if the route’s `loader` function throws an error.
    Hence, it is important to check whether the expected loader data exists before
    accessing it. Additionally, we must ensure that our `meta` functions can be safely
    executed on both the client and the server since they run in both environments.
    Any server-side logic must be executed in the `loader` functions (on the server),
    and any required data should be forwarded to the `meta` function via loader data.
  prefs: []
  type: TYPE_NORMAL
- en: Web crawlers use meta tags to understand the content of your page. Remix’s declarative
    approach to managing meta tags in nested route modules ensures the co-location
    of meta tags and the related loader data. However, sometimes, we can avoid refetching
    data if that data has already been fetched in another active `loader`. Let’s see
    what that looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Using matches data in meta functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Remix, `meta` functions are executed after all loaders have run. This means
    we have access to all currently active loader data. In this section, we’ll learn
    about Remix’s `matches` array and how to access the loader data of other routes
    in `meta`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we already fetch the user data in the `root.tsx` `loader` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need to refetch the user object in `dashboard.tsx` . We can optimize
    our code and access the user object from the root loader data. This way, we avoid
    querying the database again in the `dashboard.tsx` route module’s `loader` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the root `loader` function from `root.tsx` as a type import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We import the `loader` function as a type import as we only use it for type
    inference. Note that we must rename the `loader` import to `rootLoader` to avoid
    a naming collision with the `dashboard.tsx` route module’s `loader` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update the meta function in `dashboard.tsx`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we use the `matches` parameter to find the matching route with the `id`
    parameter of `root` and retrieve its (loader) data. The `matches` array contains
    a list of route objects that currently match the URL and are active on the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remix assigns every route module a unique identifier. These identifiers are
    based on the route module filenames, but the easiest way to identify a route module
    identifier is by logging the matches array during development.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we’re using the loader data of another matching route, revert the changes
    to the `dashboard.tsx` route module’s `loader` function. Replace the `getUser`
    function call with `requireUserId`. This avoids a database query and optimizes
    our code. Finally, remove the `username` parameter that we added to the `loader`
    function return object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you learned how to type and work with Remix’s `matches` array
    and how to access the loader data of other routes in the `meta` function. Next,
    let’s learn about handling static assets in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Handling fonts, images, stylesheets, and other assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fonts, images, and stylesheets are examples of static assets that need to be
    efficiently managed when building for the web. To ensure a fast user experience,
    it is necessary to optimize, minimize, and cache these assets. Proper management
    of static assets can significantly improve page load times and enhance the overall
    user experience. In this section, you will learn how to access and manage static
    assets in Remix. Let’s start by reviewing how to access a simple static file in
    Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Working with static assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can host static assets on our web server so that our client application can
    access them. As we learned previously, Remix is not a web server but an HTTP request
    handler. As such, Remix does not offer a built-in way to serve static assets.
    It’s the underlying web server’s responsibility to set up access for public assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Remix’s starter templates follow the common pattern of offering a
    `public` folder to expose static assets over the web and come with the required
    boilerplate code to do so. For instance, BeeRich – which was bootstrapped via
    the `create-remix` CLI tool using the Express.js adapter – contains a bootstrapped
    `server.js` file that sets up Express.js to serve static assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the `public` folder of the BeeRich application contains a `favicon.ico`
    file, which serves as the favicon of our site. Let’s also add a `robots.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `robots.txt` file in the `/public` folder and add this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Web crawlers request the `/robots.txt` file from your web server to find directives
    for which content to crawl on your site.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We specify that web crawlers are allowed to crawl the login, signup, and index
    pages of our application. However, since the dashboard is behind a login page,
    we prevent crawlers from attempting to crawl any of our dashboard pages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, run BeeRich with `npm` `run dev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit [http://localhost:3000/robots.txt](http://localhost:3000/robots.txt) in
    your browser. You should now see the content of the `robots.txt` text file displayed
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the underlying web server to serve the static contents of our Remix app.
    Similarly, we can expose fonts, images, stylesheets, third-party scripts, and
    any other static assets by simply placing them as files in the `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some assets, such as images, should be optimized before you access
    them from the browser. Usually, images and other big assets are better off hosted
    and optimized in dedicated services such as CDNs and static file storage.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party assets, such as third-party stylesheets and fonts, can also be referenced
    by using HTML link tags so that we don’t have to manage them ourselves in the
    `public` folder. Let’s learn about exposing link tags in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Managing links in Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML `link` elements are used to reference third-party resources such as stylesheets
    and fonts. In Remix, links can be declared via the `links` route module export.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix offers a `Links` component to inject all `links` return values into the
    head of the HTML document. You may have already noticed the `Links` component
    previously when inspecting the `Document` component in `root.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we only have one `links` export in BeeRich in the `root.tsx` route
    module to link to our global Tailwind CSS stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a font from Google Fonts to practice working with the `links` export:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit [https://fonts.google.com/specimen/Ubuntu](https://fonts.google.com/specimen/Ubuntu)
    to inspect the `links` function in `root.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the `` `tailwind.config.ts` `` file in the project’s root to make
    **Ubuntu** the default sans serif font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open BeeRich in a browser window. The new font should now be applied to all
    text on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer tools to inspect the application’s network activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refresh the page to reset the displayed activities on the **Network** tab and
    review the displayed results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Screenshot of the Network tab downloading a Google font](img/Figure_9.01_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Screenshot of the Network tab downloading a Google font
  prefs: []
  type: TYPE_NORMAL
- en: As visible in *Figure 9**.1*, the `links` export works as expected. We make
    a request for our global Tailwind CSS stylesheet and a request to [fonts.googleapis.com/css2](http://fonts.googleapis.com/css2).
    The request to [fonts.googleapis](http://fonts.googleapis) then triggers the download
    of the required font assets.
  prefs: []
  type: TYPE_NORMAL
- en: Just like that, the `links` export lets us declare external resources declaratively
    within our nested route hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: In BeeRich, we use one global Tailwind CSS stylesheet for our application. However,
    Remix’s `links` exports also work well when managing route-specific stylesheets.
    Let’s see how we can use the `links` export for modular stylesheets in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Styling in Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix supports any styling solution that exposes a stylesheet. This includes
    popular choices such as PostCSS, Tailwind CSS, and vanilla-extract. Once we have
    a path to a stylesheet, we can reference it with a `link` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In BeeRich, we use Tailwind CSS. Tailwind outputs one global stylesheet, which
    we can reference in a global link tag for our application. Remix also provides
    built-in support for compiling the Tailwind CSS stylesheet. You can read more
    about Remix’s Tailwind CSS integration here: [https://remix.run/docs/en/2/styling/tailwind](https://remix.run/docs/en/2/styling/tailwind).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Remix offers support for working with modular CSS solutions. Let’s
    review how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Route-scoped stylesheets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s experiment with nested `links` exports by creating a scoped CSS stylesheet
    for our login page:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a stylesheet called `login.css` in `app/styles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following content to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use this global CSS rule as an example for some custom styling that we only
    want to apply to the login route. Other routes, such as the signup route, should
    be unaffected by this CSS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the stylesheet in the `_layout.login.tsx` route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `links` export and add the content of the stylesheet import to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Visit the login route in a browser window and open the **Network** tab of the
    developer tools to inspect what’s going on ([http://localhost:3000/login](http://localhost:3000/login)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you log out first before visiting the login route as you will be redirected
    away otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Loading a nested stylesheet for the login route](img/Figure_9.02_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Loading a nested stylesheet for the login route
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the nested stylesheet loads in parallel with our global linked resources.
    Remix merges the return values of all `links` functions together and uses the
    `Links` component to inject the content into the head of the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: Our login page now has the questionable appearance we wanted. But what happens
    if we navigate to another URL?
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Sign up** button in the top-right corner to trigger a client-side
    transition away from the login route.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the beige background color disappears.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For nested `links` exports, Remix unmounts all resources once we leave the associated
    route. This is particularly useful when working with nested stylesheets. Remix
    makes it easy to scope stylesheets to a specific nested route or subset of routes.
  prefs: []
  type: TYPE_NORMAL
- en: Since Remix knows of all `links` exports, it can also prefetch linked resources
    when using the `Link` export’s `prefetch` property, which we will review in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching linked resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s investigate how Remix prefetches linked resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `_layout.tsx` route module in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `prefetch` property to all `NavLink` components rendered in the route’s
    component and set its value to `"intent"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, visit the signup page in your browser window ([http://localhost:3000/signup](http://localhost:3000/signup)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Network** tab and clear any logged entries for better visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, hover over or focus the **Log in** anchor tag in the navigation bar and
    inspect the **Network** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Prefetching linked resources](img/Figure_9.03_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Prefetching linked resources
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Remix prefetches linked resources together with the loader data
    and the login route JavaScript module. Based on the request waterfall, we can
    tell that Remix first fetches the loader data and JavaScript modules before prefetching
    the linked resources.
  prefs: []
  type: TYPE_NORMAL
- en: Remix must first fetch the new route’s loader data and JavaScript bundle to
    know what links to fetch. Once this information has been fetched, Remix prefetches
    all linked resources in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Remix allows us to declare meta tags and links in nested route modules. When
    using the `links` export, Remix enables us to prefetch linked resources together
    with the loader data and route’s JavaScript modules using the `prefetch` property.
  prefs: []
  type: TYPE_NORMAL
- en: Remix also unloads all external resources once the associated route has been
    unmounted during a transition. This ensures that scoped stylesheets and other
    resources do not affect other routes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's go over some tips for working with images in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Working with images in Remix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following best practices to deliver the most performant image to users is no
    simple task. We need to use web-friendly formats like webp, but also provide fallbacks
    for browsers that don't support them. On top of that, we have to offer different
    image sizes for various device screens. That's why using a specialized service
    for handling images is often a better choice than hosting them on your own web
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Remix doesn't have built-in tools or features specifically for handling images,
    unlike some other frameworks. You can put images in the public folder just like
    any other static files. But since images need to be optimized, it's often best
    to use a dedicated service to manage and deliver them.
  prefs: []
  type: TYPE_NORMAL
- en: While image optimization is not the focus of this book, it’s still an important
    consideration. To help you get started with image optimization in Remix, we recommend
    checking out the open source `unpic-img` project. `unpic-img` provides a minimal
    React component that can be set up with several popular CDNs. Check out the project
    on GitHub at [https://github.com/ascorbic/unpic-img](https://github.com/ascorbic/unpic-img)
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to expose static assets in Remix and how to
    work with link elements. You practiced using the `links` function to declare external
    resources. We also experimented with nested stylesheets and discussed the importance
    of image optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Remix also provides a way to serve assets via `loader` functions in resource
    routes. In the next section, we will use our `robots.txt` file as an example of
    how to use resource routes and `loader` functions to expose static assets.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing assets with loader functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we created a `robots.txt` file and exposed it by placing
    it into the `public` folder. However, we can also use `loader` functions in resource
    routes to expose assets. This is particularly useful when we want to dynamically
    create these assets on the fly or manage user access. To get started, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the existing `robots.txt` file from the public folder as it will override
    our API route otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `robots[.txt].tsx` file in the routes folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The square brackets let us escape parts of the route name. Instead of creating
    a `.txt` file, we create a `.tsx` file but ensure that the route matches the `robots.txt`
    path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following content to the newly created resource route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remix lets us return any kind of HTTP response in `loader` functions. Any route
    without a route component becomes a resource route that can receive HTTP GET requests.
    The `loader` function in `robots[.txt].tsx` responds to incoming GET requests
    to `/robots.txt` and returns a text file with the specified text content.
  prefs: []
  type: TYPE_NORMAL
- en: Resource routes and the `Response` API are powerful tools that let us generate
    PDFs, images, text content, or JSON data on the fly. The bracket annotation (for
    example, `[.txt]`) is used to escape parts of the route name.
  prefs: []
  type: TYPE_NORMAL
- en: Using `loader` functions to generate assets allows us to run dynamic computations
    on incoming requests. For example, we can authenticate user sessions or dynamically
    generate the asset. Our `robots.txt` file is currently static and does not require
    additional computations. In this case, it is sufficient to store the file in the
    `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to handle static assets and meta tags in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: First, we introduced you to the `meta` route module export. You learned that
    Remix injects the `meta` function’s return value into the head of the HTML element
    by using the `Meta` component. Remix will always use the closest `meta` function
    export and ignore all other `meta` function exports higher up in the route hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned that Remix runs `meta` functions both on the client and server.
    Remix passes the `meta` function, a `data` property that can be used to access
    the route’s loader data. After following this chapter, you should understand that
    the `data` property of the `meta` function can potentially be undefined if a `loader`
    function throws an error. Hence, it is important to only conditionally access
    loader data in `meta` functions.
  prefs: []
  type: TYPE_NORMAL
- en: You also practiced typing the `matches` parameter and learned how to access
    other matching route data in the `meta` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned about handling static assets. You now understand that static
    assets are served by the underlying web server and not by Remix directly. Remix’s
    starter templates set up a `public` folder and the necessary server code.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about the `links` route module export. You now know that Remix
    prefetches linked resources when using the prefetch property on `Link` and `NavLink`
    components. You also practiced creating route-scoped CSS stylesheets by declaring
    nested `links` exports.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you know the importance of image optimization and
    where you can get started. You understand that images must be optimized before
    being served. You also know that CDNs and other services can be used to handle
    image optimization for us.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned that you can use resource routes to serve static assets.
    We used the square bracket notation to escape sections of a route name (for example,
    `[.txt]`). With that, we created a resource route that matches the `/robots.txt`
    path and implemented a `loader` function that returns a text file response.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add file-uploading capabilities to BeeRich and
    use a resource route to manage user access to user files. This will conclude part
    two of this book and enable us to kick off advanced topics in part three.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about meta tags in the MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Remix’s route module meta export in the Remix documentation:
    [https://remix.run/docs/en/2.0.0/route/meta](https://remix.run/docs/en/2.0.0/route/meta).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about `robots.txt` files in the Google documentation: [https://developers.google.com/search/docs/crawling-indexing/robots/intro](https://developers.google.com/search/docs/crawling-indexing/robots/intro).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the MDN Web Docs if you want to learn more about link tags: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about handling styling in Remix in the Remix
    documentation: [https://remix.run/docs/en/2/styling/css](https://remix.run/docs/en/2/styling/css).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about working with resource routes in the Remix documentation:
    [https://remix.run/docs/en/2/guides/resource-routes](https://remix.run/docs/en/2/guides/resource-routes).'
  prefs: []
  type: TYPE_NORMAL
