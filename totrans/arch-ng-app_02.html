<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">1.21 Gigawatt – Flux Pattern Explained</h1>
                </header>
            
            <article>
                
<p>Let's first off explain our title. What do we mean by 1.21 Gigawatt? I'm going to quote the character Doc Brown from the movie <em>Back to the Future</em> (<a href="http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu">http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu</a>):</p>
<div class="mce-root packt_quote"><span>"Marty, I'm sorry, but the only power source capable of generating 1.21 gigawatts of electricity is a bolt of lightning."</span></div>
<p>Why are we talking about the movie Back to the Future? This is where the name Flux comes from. It's time for another quote from the same movie:</p>
<div class="packt_quote"><span>"Yes! Of course! November 5, 1955! That was the day I invented time-travel. I remember it vividly. I was standing on the edge of my toilet hanging a clock, the porcelain was wet, I slipped, hit my head on the sink, and when I came to I had a revelation! A vision! A picture in my head! A picture of this! This is what makes time travel possible: the <strong>flux</strong> capacitor!"</span></div>
<p>So as you can see, there is an explanation for the name Flux. It obviously allows us to travel in time. At least for Redux, which we will write about later in this book, time travel is possible through something called time-travel debugging. Whether that needs a bolt of lightning is for you to find out dear reader.    </p>
<p>Flux is an architectural pattern created by Facebook. It came about as it was perceived that the MVC pattern simply did not scale. It did not scale for large code bases as they tended to become fragile, generally complicated as more and more features were added, and most of all, unpredictable. Now let's hang on that word for a second, unpredictable.</p>
<p>Large systems were thought to become unpredictable due to their bidrectional data flow between models and views when the number of models and views really grew, as depicted in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-225 image-border" src="assets/100fc94f-7809-4ac9-b96d-d4b6ed0853d0.png" style=""/></div>
<p>Here, we can see that the number of models and views is starting to grow. Everything is somewhat under control as long as one model talks to one view and vice versa. This is, however, seldom the case. In the preceding diagram, we see that suddenly a view can talk to more than one model and vice versa, which means we have a cascading effect on the system and we suddenly lose control. Sure, it doesn't look so bad with just one deviating arrow, but imagine that this one is suddenly ten arrows, then we have a real problem on our hands.</p>
<p>It is the very fact that we allow bidrectional data flows to happen that things get complicated and we lose predictability. The medicine or cure for that is thought to be a simpler type of data flow, a unidirectional flow. Now, there are some key players involved in enabling undirectional data flow, which brings us to what this chapter is meant to teach us.</p>
<p class="mce-root">In this chapter, we will learn:</p>
<ul>
<li>What an action and an action creator are</li>
<li>How the dispatcher plays a central role in your application as a hub for messages</li>
<li>State management with a store</li>
<li>How to put our knowledge of Flux into practice by coding up a Flux application flow</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core concepts overview</h1>
                </header>
            
            <article>
                
<p>At the core of the Flux pattern is a unidirectional data flow. It uses some core concepts to achieve this flow. The main idea is when an event is created on a UI, through the interaction of a user, an action is created. This action consists of an intent and a payload. The intent is what your are trying to achieve. Think of the intent as a verb. Add an item, remove an item, and so on. The payload is the data change that needs to happen to achieve our intent. If we are trying to add an item, then the payload is the newly created item. The action  is then propagated in the flow with the help of a dispatcher. The action and its data eventually end up in a store.</p>
<p>The concepts that make up the Flux pattern are:</p>
<ul>
<li>Action and action creators, where we set up an intention and a payload of data</li>
<li>The dispatcher, our spider in the web that is able to send messages left and right</li>
<li>The store, our central place for state and state management</li>
</ul>
<p>All these together form the Flux pattern and promote unidirectional data flow. Consider the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-226 image-border" src="assets/01e73ee8-9f3d-4376-8718-597c54d94836.png" style=""/></div>
<p>What is depicted here is a undirectional data flow. The data flows from <strong>View</strong> to <strong>Action</strong>, from <strong>Action</strong> to <strong>Dispatcher</strong>, from <strong>Dispatcher</strong> to <strong>Store</strong>. There are two possible ways that the flow is triggered:</p>
<ul>
<li>The application is loaded a first time, in which the data is pulled from the <strong>Store</strong> to populate the view.</li>
<li>A user interaction happens in the view that leads to an intent to change something. The intent is encapsulated in an <strong>Action</strong>, and thereafter sent to the <strong>Store</strong>, via the <strong>Dispatcher</strong>. At the <strong>Store</strong>, it may be persisted in a database, through an <strong>API</strong> or saved as an application state, or both.</li>
</ul>
<p>Let's dive into each concept in more detail, together with highlighting <span>some</span><span> </span><span>code examples, in the upcoming sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A uniform data flow</h1>
                </header>
            
            <article>
                
<p>Let's introduce all parties involved in our uniform data flow by starting from the very top and slowly work our way down, concept by concept. We will build an application consisting of two views. In the first view, the user will select an item from a list. This should result in an action being created. This action will then be dispatched, by the dispatcher. The action and its payload will end up in a store. The other view meanwhile listens to changes from the store. When an item is selected, the second view will be made aware and can therefore indicate in its UI that a specific item has been selected. On a high level, our application and its flow will look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7d4d0bd5-2b05-4d97-b471-d26c97a9f49c.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Action – capture the intent</h1>
                </header>
            
            <article>
                
<p>An action is something as simple as an intent with accompanying data, that is, a message. How does an action come about though? An action comes about when a user interacts with a UI. The user may select a specific item in a list or a press a button with the intention of submitting a form. Submitting the form should, in turn, lead to a product being created.</p>
<p>Let's look at two different actions:</p>
<ul>
<li>Selecting an item in a list, here we are interested in saving the index of our selected item</li>
<li>Saving a todo to a todo list</li>
</ul>
<p>An action is represented by an object. The object has two properties of interest:</p>
<ul>
<li>The type: This is a unique string that tells us the intention of the action, for example, <kbd>SELECT_ITEM</kbd></li>
<li>The data: This is the data we mean to persist, for example, the numerical index of a selected item</li>
</ul>
<p>Given our first example action, a code representation of that action would look like the following:</p>
<pre>{<br/>  type: 'SELECT_ITEM',<br/>  data: 3 // selected index<br/>}</pre>
<p>OK, so we have prepared our action, which we can also think of as a message. We want the message to be sent so that the selected item is highlighted in the UI. As this is a undirectional flow, we need to follow a charted course and pass our message over to the next party, which is the dispatcher.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dispatcher – the spider in the web</h1>
                </header>
            
            <article>
                
<p>Think of the dispatcher as the spider in the web that handles messages being passed to it.  You can also think of the dispatcher as a mailman who promises that your message will reach its target destination. A dispatcher lives, for one thing, to dispatch messages to anyone who will listen. There is usually just one <kbd>dispatcher</kbd> in a Flux architecture and a typical usage looks something like this:</p>
<pre>dispatcher.dispatch(message);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening to the dispatcher</h1>
                </header>
            
            <article>
                
<p>We have established that the dispatcher dispatches a message to anyone who will listen. Now it is time to be that listener. The dispatcher needs a <kbd>register</kbd> or <kbd>subscribe</kbd> method so that you, who listens, have the ability to listen for incoming messages. The setup for that usually looks something like this:</p>
<pre>dispatcher.register(function(message){});</pre>
<p>Now, when you set up a listener this way, it will have the capability to listen to any message type being sent. You want to narrow this down; usually, a listener is specified to only handle a few message types around a certain theme. Your listener most likely looks something like this:</p>
<pre>dispatcher.register((message) =&gt; {<br/>  switch(message.type) {<br/>    case 'SELECT_ITEM':<br/>      // do something<br/>  }<br/>});</pre>
<p>OK, so we are able to filter out only the message types we care about, but before actually filling in some code we need to think about who this listener is. The answer is simple: it is the store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The store – managing state, data retrieval, and callbacks</h1>
                </header>
            
            <article>
                
<p>It's easy to think of the store as the place where our data lives. That is, however, not all it is. What the store's responsibilities are can be expressed by this list:</p>
<ul>
<li>Holder of state</li>
<li>Manages the state, able to update it if need be</li>
<li>Able to handle side effects such as fetching/persisting data through HTTP</li>
<li>Handles callbacks</li>
</ul>
<p>As you can see, that is a bit more than just storing the state. Let's now reconnect to what we were doing when we set up a listener with the <kbd>dispatcher</kbd>. Let's move that code into our store file, <kbd>store.js</kbd>, and let's persist our message content in our store:</p>
<pre>// store.js<br/><br/>let<span> store </span><span>=</span><span> {};<br/></span><br/>function<span> selectIndex(index) {<br/></span>  store[<span>"selectedIndex"</span><span>] </span><span>=</span><span> index;<br/></span>}<br/><br/>dispatcher.register(message <span>=&gt;</span><span> {<br/></span>  switch<span> (message.type) {<br/></span>    case<span> </span><span>"SELECT_INDEX"</span><span>:<br/></span>      selectIndex(message.data);<br/>      break<span>;<br/></span>  }<br/>});</pre>
<p>OK, so now the store is being told about the new index, but an important piece is missing, how do we tell the UI? We need a way to tell the UI that something has changed. A change means that the UI should reread its data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The view</h1>
                </header>
            
            <article>
                
<p>To tell the view that something has happened and act on it, three things need to happen:</p>
<ul>
<li>The view needs to register with the store as a listener</li>
<li>The store needs to send off an event conveying that a change has happened</li>
<li>The view needs to reload its data</li>
</ul>
<p>Starting with the store, we need to build it out so that you can register as a listener to its events. We therefore add the <kbd>addListener()</kbd> method:</p>
<pre>// store-with-pubsub.js<br/><br/>function<span> selectIndex(index) {<br/></span>  store[<span>"selectedIndex"</span><span>] </span><span>=</span><span> index;<br/></span>}<br/><br/>// registering with the dispatcher<br/><strong>dispatcher.register(message =&gt; {<br/>  switch (message.type) {<br/>    case "SELECT_INDEX":<br/>      selectIndex(message.data);<br/>      <br/>      // signals to the listener that a change has happened<br/></strong>      <strong>store.emitChange();</strong><br/><strong>      break;</strong><br/><strong>  }</strong><br/><strong>});</strong><br/><br/>class<span> Store {<br/></span>  constructor<span>() {<br/></span>    this<span>.listeners </span><span>=</span><span> [];<br/></span>  }<br/><br/>  <strong>addListener(listener) {</strong><br/><strong>    if (!this.listeners["change"]) {<br/>      this.listeners["change"] = [];<br/>    }</strong><br/><strong>    this.listeners["change"].push(listener);<br/>  }</strong><br/><br/>  emitChange() {<br/>    if<span> (</span><span>this</span><span>.listeners[</span><span>"change"</span><span>]) {<br/></span>      this<span>.listeners[</span><span>"change"</span><span>].forEach(cb </span><span>=&gt;</span><span> cb());<br/></span>    }<br/>  }<br/><br/>  getSelectedItem() {<br/>    return<span> store[</span><span>"selectedIndex"</span><span>];<br/></span>  }<br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>export<span> </span><span>default</span><span> store;</span></pre>
<p>In the preceding code, we also add the ability to emit an event with the addition of the <kbd>emitChange()</kbd> method. You can easily switch out this implementation to use an <kbd>EventEmitter</kbd> or similar. So now is the time to hook up our view to the store. We do so by calling the <kbd>addListener()</kbd> method like so:</p>
<pre>// view.js<br/><br/>import<span> store </span><span>from</span><span> </span><span>"./store-with-pubsub"</span><span>;<br/></span><br/>class<span> View {<br/></span><span>  </span>constructor<span>(store) {<br/>    </span>this<span>.index </span><span>=</span><span> </span><span>0</span><span>;<br/></span>    store.addListener(<span>this</span><span>.notifyChanged);<br/></span>  }<br/><br/>  // invoked from the store<br/> <strong> notifyChanged() {<br/></strong>    // rereads data from the store<br/><strong>    this.index = store.getSelectedItem();<br/>    <br/>    // reloading the data<br/>    render();<br/>  }</strong><br/>  render() {<br/>    const elem = document.getElementById('view');<br/>    elem.innerHTML = `Your selected index is: ${this.index}`;<br/>  }<br/>}<br/><br/>let<span> </span><span>view</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>View();<br/><br/>// view.html<br/>&lt;html&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="view"&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre>
<p>In the preceding code, we implement the <kbd>notifyChanged()</kbd> method, which when called invokes the <kbd>getSelectedItem()</kbd> method from the store and thereby receives the new value.</p>
<p>At this point, we have described the whole chain: how one view receives a user interaction, turns that into an action, which is then dispatched to a store, which updates the store's state. The store then emits an event that the other view is listening to. When the event is received, in the view the state from the store is reread and the view is then free to render this state, which it just read in, the way it sees fit.</p>
<p>We have described two things here:</p>
<ul>
<li>How to set up the flow</li>
<li>How the information flows in Flux</li>
</ul>
<p>Setting up the flow can be depicted with the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-203 image-border" src="assets/8f71e618-477b-4d27-a8d6-3704673d6609.png" style=""/></div>
<p>As for the second scenario, how the information flows through the system, it can be depicted in the following way:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-204 image-border" src="assets/754e1c56-ddb8-4214-8af8-2d461f20fa18.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Demoing a uniform data flow</h1>
                </header>
            
            <article>
                
<p>Ok, so we have described the parts our application consists of:</p>
<ul>
<li>A view where a user is able to select an index</li>
<li>A dispatcher that allows us to send a message</li>
<li>A store that contains our selected index</li>
<li>A second view where the selected index is read from the store</li>
</ul>
<p>Let's build a real app from all of this. The following code is found in the code repository under <kbd>Chapter2/demo</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a selection view</h1>
                </header>
            
            <article>
                
<p>First off we need our view in which we will perform the selection:</p>
<pre>// demo/selectionView.js<br/><br/>import<span> dispatcher </span><span>from</span><span> </span><span>"./dispatcher"</span><span>;<br/></span><br/>console.log(<span>'selection view loaded'</span><span>);<br/><br/></span>class<span> SelectionView {<br/></span>  <strong>selectIndex(index) {</strong><br/><strong>    console.log('selected index ', index);<br/>    dispatcher.dispatch({</strong><br/><strong>      type: "SELECT_INDEX",<br/>      data: index</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}<br/><br/>const<span> view </span><span>=</span><span> </span><span>new</span><span> SelectionView();<br/></span>export<span> </span><span>default</span><span> view;</span></pre>
<p>We have bolded the   <kbd>selectIndex()</kbd>   method above that we intend to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the dispatcher</h1>
                </header>
            
            <article>
                
<p>Next off we need a dispatcher that is able to take our message, like so:</p>
<pre>// demo/dispatcher.js<br/><br/>class<span> Dispatcher {<br/></span>  constructor<span>() {<br/></span>    this<span>.listeners </span><span>=</span><span> [];<br/></span>  }<br/><br/>  dispatch(message) {<br/>    this<span>.listeners.forEach(listener </span><span>=&gt;</span><span> listener(message));<br/></span>  }<br/><br/>  register(listener) {<br/>    this<span>.listeners.push(listener);<br/></span>  }<br/>}<br/><br/>const<span> dispatcher </span><span>=</span><span> </span><span>new</span><span> Dispatcher();<br/></span>export<span> </span><span>default</span><span> dispatcher;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the store</h1>
                </header>
            
            <article>
                
<p>The store will act as the data source for our state but will also be able tell any listeners when a change to the store happens:</p>
<pre>// demo/store.js<br/><br/><span>import</span><span> dispatcher </span><span>from</span><span> </span><span>'./dispatcher'</span><span>;<br/></span><br/>function<span> selectIndex(index) {<br/></span>  store[<span>"selectedIndex"</span><span>] </span><span>=</span><span> index;<br/></span>}<br/><br/>// 1) store registers with dispatcher<br/>dispatcher<strong>.register</strong>(message =&gt; {<br/>  switch (message.type) {<br/>    // 3) message is sent by dispatcher ( that originated from the first view)<br/>    <strong>case "SELECT_INDEX":</strong><br/>      selectIndex(message.data);<br/>      // 4) listener, a view, is being notified of the change<br/>      store.emitChange();<br/>      break;<br/>    }<br/>});<br/><br/>class<span> Store {<br/></span>  constructor<span>() {<br/></span>    this<span>.listeners </span><span>=</span><span> [];<br/></span>  }<br/><br/>  // 2) listener is added by a view<br/>  <strong>addListener</strong>(listener) {<br/>    if (!this.listeners["change"]) {<br/>      this.listeners["change"] = [];<br/>    }<br/><br/>    this.listeners["change"].push(listener);<br/>  }<br/><br/>  <strong>emitChange()</strong> {<br/>    if<span> (</span><span>this</span><span>.listeners[</span><span>"change"</span><span>]) {<br/></span>      this<span>.listeners[</span><span>"change"</span><span>].forEach(cb </span><span>=&gt;</span><span> cb());<br/></span>    }<br/>  }<br/><br/>  getSelectedItem() {<br/>    return<span> store[</span><span>"selectedIndex"</span><span>];<br/></span>  }<br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>export<span> </span><span>default</span><span> store;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a selected view</h1>
                </header>
            
            <article>
                
<p>This view will register itself with the store and ask for updates to its content. If there are any updates it will be notified and the data from the store will be read and this view will communicate what the store value now is:</p>
<pre>// demo/selectedView.js<br/><br/>import<span> </span><span>store</span><span> </span><span>from</span><span> </span><span>"./store"</span><span>;<br/></span><br/>console.log(<span>'selected view loaded'</span><span>);<br/><br/></span>class<span> </span><span>SelectedView {<br/></span>  constructor<span>() {<br/></span>    this<span>.index</span><span> </span><span>=</span><span> </span><span>0</span><span>;<br/></span>    store.addListener(<span>this</span><span>.notifyChanged.bind(</span><span>this</span><span>));<br/></span>  }<br/><br/>  notifyChanged() {<br/>    this<span>.index</span><span> </span><span>=</span><span> </span><span>store.getSelectedItem();<br/></span>    console.log(<span>'new index is '</span><span>,</span><span> </span><span>this</span><span>.index);<br/></span>  }<br/>}<br/><br/>const<span> </span><span>view</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>SelectedView();<br/></span>export<span> </span><span>default</span><span> </span><span>SelectedView;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the demo</h1>
                </header>
            
            <article>
                
<p>Before we can run our demo we need an application file, <kbd>app.js</kbd>. The <kbd>app.js</kbd> file should require in our views and also carry out the selection:</p>
<pre>// demo/app.js<br/><br/>import<span> selectionView </span><span>from</span><span> </span><span>'./selectionView'</span><span>;<br/></span>import<span> selectedView </span><span>from</span><span> </span><span>'./selectedView'</span><span>;<br/><br/>// carry out the selection<br/></span>selectionView.selectIndex(<span>1</span><span>);</span><span><br/></span></pre>
<p>To run our demo we need to compile it. Above we are using ES2015 modules. To compile those we will use <kbd>webpack</kbd>. We need to install <kbd>webpack</kbd> by typing the following in our terminal:</p>
<pre><strong>npm install webpack webpack-cli --save-dev</strong></pre>
<p>Once we have done so we need to create <kbd>webpack.config.js</kbd> file where we tell Webpack how to compile our files and where to place the resulting bundle. That file looks like the following:</p>
<pre>// webpack.config.js<br/><br/>module.exports <span>=</span><span> {<br/></span>  entry: <span>"./app.js"</span><span>,<br/></span>  output: { <br/>    filename: <span>"bundle.js"<br/></span>  },<br/>  watch: <span>false<br/></span>};</pre>
<p>This tells Webpack that <kbd>app.js</kbd> is the entry point to our application and it should crawl all the dependencies when creating the output file, <kbd>bundle.js</kbd>. Webpack will by default place <kbd>bundle.js</kbd> in the <kbd>dist</kbd> directory.</p>
<p>One more thing, we need an HTML file that we will name <kbd>index.html</kbd>. We will place under the <kbd>dist</kbd> folder. It should look like this:</p>
<pre>// demo/dist/index.html<br/><br/>&lt;<span>html</span><span>&gt;<br/></span>  &lt;<span>body</span><span>&gt;<br/></span>    &lt;<span>script</span><span> </span><span>src</span><span>=</span><span>"bundle.js"</span><span>&gt;</span><span>&lt;</span><span>/</span><span>script</span><span>&gt;<br/></span>  &lt;/<span>body</span><span>&gt;<br/></span>&lt;/<span>html</span><span>&gt;</span><span><br/></span></pre>
<p>Finally, to run our application, we need to compile it with Webpack and start a HTTP server and start up a browser. We will do all that with the following command from the <kbd>demo</kbd> directory:</p>
<pre><strong>webpack &amp;&amp; cd dist &amp;&amp; http-server -p 5000</strong></pre>
<p>Now, start a browser and navigate to <kbd>http://localhost:5000</kbd>. You should see the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e6e36d83-970c-4c21-a65c-331129d78474.png" style=""/></div>
<p>All of this demonstrates how to views can be made to communicate using a dispatcher and a store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding more actions to our flow</h1>
                </header>
            
            <article>
                
<p>Let's do a reality check here. We haven't built the Flux flow as prettily as we could make it. The overall picture is correct but it'd be nice if we can clean it up a bit to make room for more actions so we get a real sense of how the application should grow from here. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleaning up the view</h1>
                </header>
            
            <article>
                
<p>The first order of business is to have a look at our first view and how it reacts to user interactions. It looks like this currently:</p>
<pre>// first.view.js<br/><br/>import dispatcher from "./dispatcher";<br/><br/>class<span> FirstView {</span><span><br/></span>  selectIndex(index) {<br/>    dispatcher.dispatch({<br/>      type: "<span>SELECT_INDEX"</span><span>,<br/>      </span>data: index<br/>    });<br/>  }<br/>}<br/><br/>let<span> </span><span>view</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>FirstView();</span></pre>
<p>Adding a few more actions into the mix means we would extend the view with a few methods like this:</p>
<pre><span>// first.viewII.js<br/><br/></span>import<span> dispatcher </span><span>from</span><span> </span><span>"./dispatcher"</span><span>;<br/></span><br/>class<span> View {<br/></span>  selectIndex(data) {<br/>    dispatcher.dispatch({<br/>      type: <span>"SELECT_INDEX"</span><span>,<br/></span>      data<br/>    });<br/>  }<br/><br/>  createProduct(data) {<br/>    dispatcher.dispatch({<br/>      type: <span>"CREATE_PRODUCT"</span><span>,<br/></span>      data<br/>    });<br/>  }<br/><br/>  removeProduct(data) {<br/>    dispatcher.dispatch({<br/>      type: <span>"REMOVE_PRODUCT"</span><span>,<br/></span>      data<br/>    });<br/>  }<br/>}<br/><br/>let<span> view </span><span>=</span><span> </span><span>new</span><span> View();</span><span> </span></pre>
<p>OK, so now we get how we can add actions. It looks a little ugly though with all these calls to the <kbd>dispatcher</kbd> and magic strings, so we clean this up a bit by creating a file with constants, called <kbd>product.constants.js</kbd>, which consists of the following code:</p>
<pre>// product.constants.js<br/><br/>export const SELECT_INDEX = "SELECT_INDEX",<br/>export const CREATE_PRODUCT = "CREATE_PRODUCT",<br/>export const REMOVE_PRODUCT = "REMOVE_PRODUCT"</pre>
<p>Let's do one more thing. Let's move the <kbd>dispatcher</kbd> into a <kbd>product.actions.js</kbd>; this is generally known as an action creator. This will contain the <kbd>dispatcher</kbd> and refer to our <kbd>product.constants.js</kbd> file. So let's create said file:</p>
<pre>// product.actions.js<br/><br/>import<span> {<br/></span>  SELECT_INDEX,<br/>  CREATE_PRODUCT,<br/>  REMOVE_PRODUCT<br/>} <span>from</span><span> </span><span>"./product-constants"</span><span>;<br/></span>import<span> dispatcher </span><span>from</span><span> </span><span>"./dispatcher"</span><span>;<br/></span>import<span> ProductConstants </span><span>from</span><span> </span><span>"./product.constants"</span><span>;<br/></span><br/>export<span> </span><span>const</span><span> selectIndex </span><span>=</span><span> data </span><span>=&gt;<br/></span>  dispatcher.dispatch({<br/>    type: SELECT_INDEX,<br/>    data<br/>  });<br/><br/>export<span> </span><span>const</span><span> createProduct </span><span>=</span><span> data </span><span>=&gt;<br/></span>  dispatcher.dispatch({<br/>    type: CREATE_PRODUCT,<br/>    data<br/>  });<br/><br/>export<span> </span><span>const</span><span> removeProduct </span><span>=</span><span> data </span><span>=&gt;<br/></span>  dispatcher.dispatch({<br/>    type: REMOVE_PRODUCT,<br/>    data<br/>  });</pre>
<p>With these constructs, we can clean up our view considerably to look like this:</p>
<pre>// first.viewIII.js<br/><br/>import { <br/>  selectIndex, <br/>  createProduct, <br/>  removeProduct <br/>} from 'product.actions';<br/><br/>function View() {<br/>  this.selectIndex = index =&gt; {<br/>    selectIndex(index);<br/>  };<br/><br/>  this.createProduct = product =&gt; {<br/>    createProduct(product);<br/>  };<br/><br/>  this.removeProduct = product =&gt; {<br/>    removeProduct(product)<br/>  };<br/>}<br/><br/>var view = new View();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cleaning up the store</h1>
                </header>
            
            <article>
                
<p>There are improvements we can make to on the store. There is no need to write all the code we do currently. In fact, there are libraries out there that do a better job of handling certain functionality.</p>
<p>Before we apply all those changes we have in mind, let's recap what our store can do and what features still need to be in place after the cleanup work.</p>
<p>Let's remind ourselves, what our store is capable of so far:</p>
<ul>
<li>Handles state changes: It handles the state changes; the store is able to change the state regardless of whether it is creating, updating, listing, or removing state.</li>
<li>Subscribable: It lets you subscribe to it; it's important for the store to have a subscription functionality so a view, for example, can listen to the store's state when it changes. A suitable reaction by the view is, for example, rerendering based on new data.</li>
<li>Can communicate a state change: It can send an event that its state has been changed; this goes together with being able to subscribe to the store, but this is the very act of actually notifying a listener that a state has changed.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding EventEmitter</h1>
                </header>
            
            <article>
                
<p>The two last bullets can really be condensed into one theme, namely eventing, or the ability to register to and fire off events.</p>
<p>So what does a cleanup of the store look like, and why would we need to clean it up? The reason for cleaning it up is it makes for simpler code. There is a standard library that is often used when constructing a store, called <kbd>EventEmitter</kbd>. The library handles just what we mentioned previously, namely it is able to register and fire off events. It is a simple implementation of the pub-sub pattern. Basically, <kbd>EventEmitter</kbd> allows you to subscribe to certain events and also allows you to trigger events. For more information on the pattern itself, have a look at the following link: <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>.<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern"/></p>
<p>You could definitely write your own code for this, but it's nice to be able to use a dedicated library so you can focus on other things that matter, such as solving business problems.</p>
<p>We decided to use the <kbd>EventEmitter</kbd> library and we do so in the following way:</p>
<pre>// store-event-emitter.js<br/><br/>export<span> </span><span>const</span><span> Store </span><span>=</span><span> (() </span><span>=&gt;</span><span> {<br/></span>  const<span> eventEmitter </span><span>=</span><span> </span><span>new</span><span> EventEmitter();<br/></span>  return<span> {<br/></span>    addListener: listener <span>=&gt;</span><span> {<br/></span>      eventEmitter.on(<span>"changed"</span><span>, listener);<br/></span>    },<br/>    emitChange: () <span>=&gt;</span><span> {<br/></span>      eventEmitter.emit(<span>"changed"</span><span>);<br/></span>    },<br/>    getSelectedItem: () <span>=&gt;</span><span> store[</span><span>"selectedItem"</span><span>]<br/></span>  };<br/>})();</pre>
<p>This makes our code a little cleaner because we no longer need to hold an internal list of subscribers. There are more changes we can make though, so let us talk about that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding to and cleaning up the register method</h1>
                </header>
            
            <article>
                
<p>One of the store's jobs has been to handle eventing, especially when the store wants to convey to a view that a change has happened to its state. In the <kbd>store.js</kbd> file, other things were happening as well, things like registering ourselves with the <kbd>dispatcher</kbd> and being able to receive dispatched actions. We used these actions to alter the state of the store. Let's remind ourselves what that looked like:</p>
<pre>// store.js<br/><br/>let<span> store </span><span>=</span><span> {};<br/></span><br/>function<span> selectIndex(index) {<br/></span>  store[<span>"selectedIndex"</span><span>] </span><span>=</span><span> index;<br/></span>}<br/><br/>dispatcher.register(message <span>=&gt;</span><span> {<br/></span>  switch<span> (message.type) {<br/></span>    case<span> </span><span>"SELECT_INDEX"</span><span>:<br/></span>      selectIndex(message.data);<br/>      break;<br/>  }<br/>});</pre>
<p>Here, we are only supporting one action, namely <kbd>SELECT_INDEX</kbd>. There are two things we need to do here:</p>
<ul>
<li>Add the other two actions, <kbd>CREATE_PRODUCT</kbd> and <kbd>REMOVE_PRODUCT</kbd>, and the accompanying functions <kbd>createProduct()</kbd> and <kbd>removeProduct()</kbd></li>
<li>Stop using magic strings and start using our constants file</li>
<li>Use the store we created in the <kbd>store-event-emitter.js</kbd> file</li>
</ul>
<p>Let's implement the suggested changes from our preceding list:</p>
<pre>// store-actions.js<br/><br/>import<span> dispatcher </span><span>from</span><span> </span><span>"./dispatcher"</span><span>;</span><span><br/></span>import<span> {<br/></span>  SELECT_INDEX,<br/>  <strong>CREATE_PRODUCT</strong>,<br/>  <strong>REMOVE_PRODUCT</strong><br/>} <span>from</span><span> </span><span>"./product.constants"</span><span>;<br/></span><br/>let<span> store </span><span>=</span><span> {};<br/><br/></span>function<span> selectIndex(index) {<br/></span>  store[<span>"selectedIndex"</span><span>] </span><span>=</span><span> index;<br/></span>}<br/><br/>export<span> </span><span>const</span><span> Store </span><span>=</span><span> (() </span><span>=&gt;</span><span> {<br/></span>  var<span> eventEmitter </span><span>=</span><span> </span><span>new</span><span> EventEmitter();<br/></span>  return<span> {<br/></span>    addListener: listener <span>=&gt;</span><span> {<br/></span>      eventEmitter.on(<span>"changed"</span><span>, listener);<br/></span>    },<br/>    emitChange: () <span>=&gt;</span><span> {<br/></span>      eventEmitter.emit(<span>"changed"</span><span>);<br/></span>    },<br/>    getSelectedItem: () <span>=&gt;</span><span> store[</span><span>"selectedItem"</span><span>]<br/></span>  };<br/>})();<br/><br/>dispatcher.register(message <span>=&gt;</span><span> {<br/></span>  switch<span> (message.type) {<br/></span>    case<span> </span><span>"SELECT_INDEX"</span><span>:<br/></span>      selectIndex(message.data);<br/>      break<span>;<br/></span>  }<br/>});<br/><br/><strong>const createProduct = product =&gt; {<br/>  if (!store["products"]) {<br/>    store["products"] = [];<br/>  }</strong><br/><strong>  store["products"].push(product);<br/>};</strong><br/><br/><strong>const removeProduct = product =&gt; {<br/>  var index = store["products"].indexOf(product);<br/>  if (index !== -1) {<br/>    store["products"].splice(index, 1);<br/>  }</strong><br/><strong>};</strong><br/><br/>dispatcher.register(({ type, data }) <span>=&gt;</span><span> {<br/></span>  switch<span> (type) {<br/></span>    case <span>SELECT_INDEX:<br/></span>      selectIndex(data);<br/>      break<span>;<br/></span>    <strong>case CREATE_PRODUCT:<br/>      createProduct(data);</strong><br/><strong>      break</strong><span><strong>;</strong><br/></span>    <strong>case REMOVE_PRODUCT:<br/>      removeProduct(data);</strong><br/><strong>  }</strong><br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further improvements</h1>
                </header>
            
            <article>
                
<p>There are definitely more improvements we can make to this code. We did use ES2015 imports to import other files, but most of our code was written in ES5 so why not use most of what ES2015 gives us? Another improvement we can make is introducing immutability and making sure our store is not mutated but transitions from one state to another. </p>
<p>Let's have a look at the store file, primarily because that is where we can add the most ES2015 syntax. Our revealing module pattern looks like this currently:</p>
<pre>// store-event-emitter.js<br/><br/>var Store = (function(){<br/>  const eventEmitter = new EventEmitter();<br/><br/>  return {<br/>    addListener: listener =&gt; {<br/>      eventEmitter.on("changed", listener);<br/>    },<br/>    emitChange: () =&gt; {<br/>      eventEmitter.emit("changed");<br/>    },<br/>    getSelectedItem: () =&gt; store["selectedItem"]<br/>  };<br/>})();</pre>
<p>It can be replaced with a simple class and instead of instantiating an <kbd>EventEmitter</kbd>, we can inherit from it. In all fairness, we could have used ES2015 inheritance or the merge library to not have to create a separate <kbd>EventEmitter</kbd> instance, but this shows how elegant ES2015 can make things:</p>
<pre>// store-es2015.js<br/><br/>import<span> { EventEmitter } </span><span>from</span><span> </span><span>"events"</span><span>;<br/></span>import<span> {<br/></span>SELECT_INDEX,<br/>CREATE_PRODUCT,<br/>REMOVE_PRODUCT<br/>} <span>from</span><span> </span><span>"./product.constants"</span><span>;<br/></span><br/>let<span> store </span><span>=</span><span> {};<br/></span><br/><strong>class Store extends EventEmitter {<br/>  constructor() {}<br/>    addListener(listener) {</strong><br/><strong>    this.on("changed", listener);<br/>  }</strong><br/><br/><strong>  emitChange() {</strong><br/><strong>    this.emit("changed");<br/>  }</strong><br/><br/><strong>  getSelectedItem() {</strong><br/><strong>    return store["selectedItem"];<br/>  }</strong><br/><strong>}</strong><br/><br/>const<span> storeInstance </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span><br/>function<span> createProduct(product) {<br/></span>  if<span> (</span><span>!</span><span>store[</span><span>"products"</span><span>]) {<br/></span>    store[<span>"products"</span><span>] </span><span>=</span><span> [];<br/></span>  }<br/>  store[<span>"products"</span><span>].push(product);<br/></span>}<br/><br/>function<span> removeProduct(product) {<br/></span>  var<span> index </span><span>=</span><span> store[</span><span>"products"</span><span>].indexOf(product);<br/></span>  if<span> (index </span><span>!==</span><span> </span><span>-</span><span>1</span><span>) {<br/></span>    store[<span>"products"</span><span>].splice(index, </span><span>1</span><span>);<br/></span>  }<br/>}<br/><br/>dispatcher.register(({ type, data }) <span>=&gt;</span><span> {<br/></span>  switch<span> (type) {<br/></span>    case<span> SELECT_INDEX:<br/></span>      selectIndex(data);<br/>      storeInstance.emitChange();<br/>      break<span>;<br/></span>    case<span> CREATE_PRODUCT:<br/></span>      createProduct(data);<br/>      storeInstance.emitChange();<br/>      break<span>;<br/></span>    case<span> REMOVE_PRODUCT:<br/></span>      removeProduct(data);<br/>      storeInstance.emitChange();<br/>  }<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding immutability</h1>
                </header>
            
            <article>
                
<p>The other thing we can undertake is adding immutability. The reasons for using immutability in the first place are to make your code more predictable, and some frameworks can use this for simpler change detection and can rely on reference checking over dirty checking. This was the case when AngularJS got its whole change detection mechanism changed when Angular was written. From a practical standpoint, this means that there are functions we can target in our store and apply immutable principles on. The first principle is to not mutate but create an entirely new state, instead of where the new state is <em>the old state + the state change</em>. A simple example of this is the following:</p>
<pre>var oldState = 3;<br/>var newState = oldState + 2</pre>
<p>Here, we are creating a new variable, <kbd>newState</kbd>, rather than mutating our <kbd>oldState</kbd> variable. There are functions that will help us with this, called <kbd>Object.assign</kbd> and the function filter. We can use these for updating scenarios, as well as adding or removing things from a list. Let us use these and rewrite part of our store code. Let's highlight the code we mean to change:</p>
<pre>// excerpt from store-actions.js<br/><br/>const createProduct = product =&gt; {<br/>  if (!store["products"]){ <br/>    store["products"] = [];<br/>  }<br/>  store["products"].push(product);<br/>};<br/><br/>const removeProduct = product =&gt; {<br/>  var index = store["products"].indexOf(product);<br/>  if (index !== -1) {<br/>    store["products"].splice(index, 1);<br/>  }<br/>};</pre>
<p>Let's apply <kbd>Object.assign</kbd> and <kbd>filter()</kbd>, and remember to not mutate things. The end result should look like this:</p>
<pre>// excerpt from our new store-actions-immutable.js<br/><br/>const<span> createProduct </span><span>=</span><span> product </span><span>=&gt;</span><span> {<br/></span>  if<span> (</span><span>!</span><span>store[</span><span>"products"</span><span>]) {<br/></span>    store[<span>"products"</span><span>] </span><span>=</span><span> [];<br/></span>  }<br/>  store.products <span>=</span><span> [</span><span>...</span><span>store.products, Object.assign(product)];<br/></span>};<br/><br/>const<span> removeProduct </span><span>=</span><span> product </span><span>=&gt;</span><span> {<br/></span>  if<span> (</span><span>!</span><span>store[</span><span>"products"</span><span>]) </span><span>return</span><span>;<br/><br/></span>  store[<span>"products"</span><span>] </span><span>=</span><span> products.filter(p </span><span>=&gt;</span><span> p.id </span><span>!==</span><span> product.id);<br/></span>};</pre>
<p>We can see that the <kbd>createProduct()</kbd> method uses an ES2015 construct, namely the spread parameter, <kbd>...</kbd>, which takes a list and turns its members into a comma-separated list of items. <kbd>Object.assign()</kbd> is used to copy over all the values from an object so we store the value of an object rather than its reference. The <kbd>removeProduct()</kbd> method becomes very simple when we use the filter method. We simply create a projection that does not include the product that we should remove; removing has never been this easy or elegant. We haven't mutated anything.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summarizing</h1>
                </header>
            
            <article>
                
<p>Our cleanup started with the view; we wanted to remove a direct connection to the dispatcher and also stop having to use magic strings as this is quite error prone, and it's easy to misspell. Instead, we can rely on constants. To remedy this, we created an action creator class that talked to the dispatcher instead.</p>
<p>We also created a constants module to remove the magic strings. </p>
<p><span>Furthermore, we improved the store by starting to use <kbd>EventEmitter</kbd>. Finally, we further improved the store by adding more actions to it and also started to refer to the constants.</span></p>
<p>At this point, our solution is ready for more actions to be added to it and we should feel pretty clear on what files we need to add to, as we support more and more user interactions.</p>
<p>Lastly, we added improvements around ES2015 and immutability, which made our code look a lot cleaner. With this foundation, we are now ready to go from static data to involve working with side effects and Ajax in the upcoming section.</p>
<p>Let us summarize all our improvements in a diagram showing the constructs added to our flow:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-205 image-border" src="assets/0dbe10b0-0de5-4ebd-b1b0-a23271451d5e.png" style=""/></div>
<p>It is clear that using an action creator isn't strictly necessary but it does clean up the code quite a bit, and the same goes for using an <kbd>EventEmitter</kbd> in the store; it's nice but not necessary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding AJAX calls</h1>
                </header>
            
            <article>
                
<p>So far, we have only been dealing with static data in our Flux flow. The time has now come to add real data connections to the flow and thereby real data. It is time to start talking to APIs through AJAX and HTTP. Fetching data is quite easy nowadays, thanks to the fetch API and libraries such as RxJS. What you need to think about when incorporating it in the flow is:</p>
<ul>
<li>Where to place the HTTP call</li>
<li>How to ensure that the store is updated and interested views are notified</li>
</ul>
<p>We have a point at which we register the store to the <kbd>dispatcher</kbd>, with this piece of code:</p>
<pre>// excerpt from store-actions-immutable.js<br/><br/>const createProduct = (product) =&gt; {<br/>  if<span> (</span><span>!</span><span>store[</span><span>"products"</span><span>]) {<br/></span>    store[<span>"products"</span><span>] </span><span>=</span><span> [];<br/></span>  }<br/><br/>  store.products = [...store.products, Object.assign(product)];<br/>}<br/><br/>dispatcher.register(({ type, data }) =&gt; {<br/>  switch (type) {<br/>    case CREATE_PRODUCT:<br/>      createProduct(data);<br/>      store.emitChange();<br/>      break;<br/>      /* other cases below */<br/>  }<br/>})</pre>
<p>If we do this for real, that is, call an API to persist this product, <kbd>createProduct()</kbd> would be where we would do the API call, like so:</p>
<pre>// example use of fetch()<br/><br/>fetch(<br/>  '/products' ,<br/>  { method : 'POST', body: product })<br/>  .then(response =&gt; {<br/>   // send a message to the dispatcher that the list of products should be reread<br/>}, err =&gt; {  <br/>  // report error<br/>});</pre>
<p>Calling <kbd>fetch()</kbd> returns a <kbd>Promise</kbd>. Let's use async/await however, as it makes the call much more readable. The difference in code can be seen in the following example:</p>
<pre>// contrasting example of 'fetch() with promise' vs 'fetch with async/await'<br/><br/>fetch('url')<br/> .then(data =&gt; console.log(data))<br/> .catch(error =&gt; console.error(error));<br/> <br/> // using async/await<br/> try {<br/>   const data = await fetch('url');<br/>   console.log(data);<br/> } catch (error) {<br/>   console.error(error);<br/> }</pre>
<p>Replacing what happens in <kbd>createProduct()</kbd> with this adds code with a lot of noise so it is a good idea to wrap your HTTP interactions in an API construct like so:</p>
<pre>// api.js <br/><br/>export class Api {<br/>  createProduct(product) {<br/>    return fetch("/products", { method: "POST", body: product });<br/>  }<br/>}</pre>
<p>Now let us replace the <kbd>createProduct()</kbd> method content with the call to our API construct like so:</p>
<pre>// excerpt from store-actions-api.js<br/><br/>import { Api } from "./api";<br/> <br/>const api = new Api();<br/><br/>createProduct() {<br/>  api.createProduct();<br/>}</pre>
<p>That's not really enough though. Because we created a product through an API call, we should dispatch an action that forces the product list to be reread. We don't have such an action or supporting method in a store to handle it, so let's add one:</p>
<pre>// product.constants.js<br/><br/>export const SELECT_INDEX = "SELECT_INDEX";<br/>export const CREATE_PRODUCT = "CREATE_PRODUCT";<br/>export const REMOVE_PRODUCT = "REMOVE_PRODUCT";<br/><strong>export const GET_PRODUCTS = "GET_PRODUCTS";</strong></pre>
<p>Now let's add the required method in the store and the case to handle it:</p>
<pre>// excerpt from store-actions-api.js<br/><br/>import { Api } from "./api";<br/>import {<br/>  // other actions per usual<br/>  <strong>GET_PRODUCTS,</strong><br/>} from "./product.constants";<br/><br/><strong>const setProducts = (products) =&gt; {</strong><br/><strong>  store["products"] = products;</strong><br/><strong>}</strong><br/><br/>const setError = (error) =&gt; {<br/>  store["error"] = error;<br/>}<br/><br/>dispatcher.register( async ({ type, data }) =&gt; {<br/>  switch (type) {<br/>    case CREATE_PRODUCT:<br/>      try {<br/>        await api.createProduct(data);<br/>        <strong>dispatcher.dispatch(getProducts());</strong><br/>      } catch (error) {<br/>        setError(error);<br/>        storeInstance.emitError();<br/>      }<br/>      break;<br/>    <strong>case GET_PRODUCTS:</strong><br/><strong>      try {</strong><br/><strong>        const products = await api.getProducts();</strong><br/><strong>        setProducts(products);</strong><br/><strong>        storeInstance.emitChange();</strong><br/><strong>      }</strong><br/><strong>      catch (error) {</strong><br/><strong>        setError(error);</strong><br/><strong>        storeInstance.emitError();</strong><br/><strong>      }</strong><br/><strong>      break;</strong><br/>  }<br/>});</pre>
<p>We can see that the <kbd>CREATE_PRODUCT</kbd> case will call the <span>corresponding</span><span>  </span>API<span> method</span> <kbd>createProduct()</kbd><span>, which on completion will dispatch the</span> <kbd>GET_PRODUCTS</kbd><span> action. The reason for doing so is that when we successfully manage to create a product, we need to read from the endpoint to get an updated version of the products list.</span><span> We don't see that in detail, but it is being invoked through us calling</span> <kbd>getProducts()</kbd><span>. Again, it is nice to have a wrapper on everything being dispatched, that wrapper being an action creator.</span></p>
<p>The full file looks like this:</p>
<pre>// store-actions-api.js<br/><br/>import<span> dispatcher </span><span>from</span><span> </span><span>"./dispatcher"</span><span>;<br/></span>import<span> { Action } </span><span>from</span><span> </span><span>"./api"</span><span>;<br/></span>import<span> { Api } </span><span>from</span><span> </span><span>"./api"</span><span>;<br/></span>import<span> {<br/></span>  CREATE_PRODUCT,<br/>  GET_PRODUCTS,<br/>  REMOVE_PRODUCT,<br/>  SELECT_INDEX<br/>} <span>from</span><span> </span><span>"./product.constants"</span><span>;<br/></span><br/>let<span> store </span><span>=</span><span> {};<br/></span><br/>class<span> Store </span><span>extends</span><span> EventEmitter {<br/></span>  constructor<span>() {}<br/></span>  addListener(listener) {<br/>    this<span>.on(</span><span>"changed"</span><span>, listener);<br/></span>  }<br/><br/>  emitChange() {<br/>    this<span>.emit(</span><span>"changed"</span><span>);<br/></span>  }<br/><br/>  emitError() {<br/>    this<span>.emit(</span><span>"error"</span><span>);<br/></span>  }<br/><br/>  getSelectedItem() {<br/>    return<span> store[</span><span>"selectedItem"</span><span>];<br/></span>  }<br/>}<br/><br/>const<span> api </span><span>=</span><span> </span><span>new</span><span> Api();<br/></span>const<span> storeInstance </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span><br/>const<span> selectIndex </span><span>=</span><span> index </span><span>=&gt;</span><span> {<br/></span>  store[<span>"selectedIndex"</span><span>] </span><span>=</span><span> index;<br/></span>};<br/><br/>const<span> createProduct </span><span>=</span><span> product </span><span>=&gt;</span><span> {<br/></span>  if<span> (</span><span>!</span><span>store[</span><span>"products"</span><span>]) {<br/></span>    store[<span>"products"</span><span>] </span><span>=</span><span> [];<br/></span>  }<br/>  store.products <span>=</span><span> [</span><span>...</span><span>store.products, Object.assign(product)];</span><span><br/></span>};<br/><br/>const<span> removeProduct </span><span>=</span><span> product </span><span>=&gt;</span><span> {<br/></span>  if<span> (</span><span>!</span><span>store[</span><span>"products"</span><span>]) </span><span>return</span><span>;<br/></span>  store[<span>"products"</span><span>] </span><span>=</span><span> products.filter(p </span><span>=&gt;</span><span> p.id </span><span>!==</span><span> product.id);<br/></span>};<br/><br/>const<span> setProducts </span><span>=</span><span> products </span><span>=&gt;</span><span> {<br/></span>  store[<span>"products"</span><span>] </span><span>=</span><span> products;<br/></span>};<br/><br/>const<span> setError </span><span>=</span><span> error </span><span>=&gt;</span><span> {<br/></span>  store[<span>"error"</span><span>] </span><span>=</span><span> error;<br/></span>};<br/><br/>dispatcher.register(<span>async</span><span> ({ type, data }) </span><span>=&gt;</span><span> {<br/></span>  switch<span> (type) {<br/></span>    case<span> </span><span>"SELECT_INDEX"</span><span>:<br/></span>      selectIndex(message.data);<br/>      storeInstance.emitChange();<br/>      break<span>;<br/></span>    case<span> CREATE_PRODUCT:<br/></span>      try<span> {<br/></span>        await<span> api.createProduct(data);<br/></span>        storeInstance.emitChange();<br/>      } <span>catch</span><span> (error) {<br/></span>        setError(error);<br/>        storeInstance.emitError();<br/>      }<br/>      break<span>;<br/></span>    case<span> GET_PRODUCTS:<br/></span>      try<span> {<br/></span>        const<span> products </span><span>=</span><span> </span><span>await</span><span> api.getProducts();<br/></span>        setProducts(products);<br/>        storeInstance.emitChange();<br/>      } <span>catch</span><span> (error) {<br/></span>        setError(error);<br/>        storeInstance.emitError();<br/>      }<br/>      break<span>;<br/></span>   }<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An even bigger solution</h1>
                </header>
            
            <article>
                
<p>So far, we have been describing a solution that consists of only a product's topic and communication has only taken place from one view to another. In a more realistic application, we would have a lot of topics such as user management, orders, and so on; exactly what they are called is dependent on the domain of your application. As for views, it is quite possible that you will have a ton of views listening to another view, as in this example:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-206 image-border" src="assets/6da86ae3-4750-451a-8e0c-f0118a549cc3.png" style=""/></div>
<p>This describes an application that contains four different view components around their own topic. The <strong>Customers view</strong> contains a list of customers and it allows us to alter which customer we currently want to focus on. The other three supporting views show <strong>Orders</strong>, <strong>Messages</strong>, and <strong>Friends</strong> and their content depends on which customer is currently highlighted. From a Flux standpoint, the <strong>Orders</strong>, <strong>Messages</strong>, and <strong>Friends</strong> views can easily register with the store to know when things gets updated so they can fetch/refetch the data they need. However, imagine that the supporting views themselves want to support CRUD actions; then they would need their own set of constants, action creator, API, and store. So now your application would need to look something like this:</p>
<pre>/customers <br/>  constants.js<br/>  customer-actions.js<br/>  customer-store.js<br/>  customer-api.js<br/>/orders<br/>  constants.js<br/>  orders-actions.js<br/>  orders-store.js<br/>  orders-api.js<br/>/messages<br/>  constants.js<br/>  messages-actions.js<br/>  messages-store.js<br/>  messages-api.js<br/>/friends<br/>  constants.js<br/>  friends-actions.js<br/>  friends-store.js<br/>  friends-api.js<br/>/common<br/>  dispatcher.js</pre>
<p>Two interesting situations exist here:</p>
<ul>
<li>You have a self-contained view; all CRUD actions happen within it</li>
<li>You have a view that needs to listen to other views</li>
</ul>
<p>For the first situation, a good rule of thumb is to create its own set of constants, action creator, API, and store.</p>
<p>For the second situation, ensure your view registers itself with the store of that topic. For example, if the friends view needs to listen to the customer view, then it needs to register itself with the customer store. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We set out trying <span>only </span><span>to explain the Flux architecture pattern. It would have been very easy to start mentioning how it fits with React and how there are nice libraries and tools that support Flux and React. That would, however, have taken</span><span> </span><span>our</span><span> </span><span>focus</span><span> away from explaining the pattern from a more framework-agnostic viewpoint. Therefore, the rest of this chapter set out to explain core concepts such as actions, action creator, dispatcher, store, and uniform data flow. Little by little, we improved the code to start using constants, action creators, and a nice supporting library such as</span> <kbd>EventEmitter</kbd><span>. We explained how HTTP fits into this and,</span><span> </span><span>lastly,</span><span> we discussed how we could build out our application. There is a lot more that can be said about Flux, but we chose to limit the scope to understanding the fundamentals so we can compare its approach as we dive into Redux and NgRx in later chapters, which is the main focus of this book.</span></p>


            </article>

            
        </section>
    </body></html>