- en: '*Chapter 2*: Styling Choices and Creating Reusable Layouts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gatsby sites can be styled in a multitude of ways. In this chapter, we will
    introduce you to a large selection of styling techniques to help you make an informed
    choice about how you would like to style your site. Once you've settled on a styling
    method, we will implement it on the pages we created in [*Chapter 1*](B15983_01_ePub_RK.xhtml#_idTextAnchor013),
    *An Overview of Gatsby.js for the Uninitiated*, before creating the **reusable
    components** that will be used across all our site pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Styling in Gatsby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling with CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling with Sass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling with Tailwind.css
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling with Styled components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reusable layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to navigate this chapter, you will need to have completed the Gatsby
    setup and created the pages in [*Chapter 1*](B15983_01_ePub_RK.xhtml#_idTextAnchor013),
    *An Overview of Gatsby.js for the Uninitiated*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start adding our first reusable components to our pages.
    As these components are not standalone pages, we will need a new place to store
    them. Create a subfolder inside your `src` folder called `components` that we
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: The code present in this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter02](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Styling in Gatsby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about styling your Gatsby site, but what does styling refer
    to? While our React code is defining the structure of our web documents, we will
    use styling to define our documents' look and feel through page layouts, colors,
    and fonts. There is an abundance of tools you can use to style any Gatsby project.
    In this book, I will introduce you to four different approaches – **vanilla CSS**,
    **Sass**, **Tailwind.css**, and **CSS in JS**. Let's explore each of these in
    a little more detail before deciding which to use.
  prefs: []
  type: TYPE_NORMAL
- en: Vanilla CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your browser navigates to a site, it loads the site's HTML. It converts
    this HTML into a **Document Object Model** (**DOM**). After this, the browser
    will begin to fetch resources referenced in the HTML. This includes images, videos,
    and, more importantly right now, CSS. The browser reads through the CSS and sorts
    selectors by element, class, and identifiers. It then goes through the DOM and
    uses the selectors to attach styles to elements as required, creating a render
    tree. The visual page is then shown on the screen by utilizing this render tree.
    CSS has withstood the test of time, as we have been shipping CSS in this way with
    HTML for 25 years. But using vanilla CSS has some pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros for using vanilla CSS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Its age**: Because CSS has been around for 25 years at the time of writing
    this book, there is an abundance of content available on CSS. Due to its age,
    the chances that someone has already worked out how to fix any issue you encounter
    is also very high. Both these reasons make vanilla CSS a great choice for a beginner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understandable syntax**: The syntax that makes up CSS consists of very few
    abbreviations. Reading it as a beginner, it is far easier to learn what any line
    of CSS is doing compared to the other style implementations in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons for using vanilla CSS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long style sheets**: In traditional websites, you often see that they only
    ship with one CSS file. This makes maintaining and organizing styles very difficult,
    as the file can end up incredibly long. This can lead to a pattern where lazy
    developers who can''t find the styles they are looking for might just append them
    to the bottom of the file (also known as an **append-only style sheets**). If
    they do this and the file already exists, then they are just increasing the file
    size for nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class reuse confusion**: Reusing styles can sometimes lead to more trouble
    than it''s worth. Let''s say you have used one specific class in use across various
    elements in your application. You might update this class to make it fit one instance
    of it, only to break all the others. If you fall into this cycle multiple times,
    it can really slow down your development. This can be avoided with a little forward-thinking
    – instead of reusing classes, make components that are reused. Another option
    is to create "utility classes" that are unlikely to change; if you''d rather not
    create these yourself, you should read the section on Tailwind CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance pain points**: By using inheritance, we end up tightly coupling
    our CSS to the structure of our HTML. If you break that structure, your CSS may
    no longer work. While inheritance sometimes is unavoidable, we should try and
    keep it to a minimum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS has withstood the test of time and is still a solid choice today. You might
    be asking why these are cons when I have listed ways to work around/avoid all
    of them. These cons can all be fixed one way or another using one of the other
    implementations in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Sass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sass is a preprocessor scripting language that compiles into CSS. It gives developers
    tools that allow them to create more efficient CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros for using Sass are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large toolset**: Sass contains a bundle of powerful tools that you can''t
    utilize in vanilla CSS. While we won''t be covering these in detail, these include
    tools like mixins, loops, functions, and imports that can be used to create more
    powerful and performant CSS for your application. This is a huge pro for Sass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.scss` files to break down files. You can then import them into one another
    as needed. This drastically helps improve the organization of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Freedom**: Sass enforces a convention of how to write it – you can choose.
    This means that you can choose a style that suits your team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons for using Sass are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Skip foundations**: Freedom can also be a negative for developers new to
    styling. If you haven''t used Sass before, you may create code that works but
    in a way that is overly complicated. This can lead to future developers struggling
    with the code. Concrete CSS guidelines can help avoid this misuse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming conventions**: Naming every class you create for every element you
    style is a tedious process. There are methodologies that can help you create sensible
    class names; however it still takes a long time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two sources of truth**: When you write your HTML, you probably will also
    add class names to your elements to style them. You then jump across to your Sass
    file to add these class names, only to forget what names you had for them. Jumping
    back and forth between your HTML and Sass can be an annoying context switch. You
    might consider abstracting styles away from your markup to be a good thing, but
    when markup and styles are so interconnected, this can be an inconvenience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although Sass is a powerhouse, increased power does also mean increased complexity.
    While the learning curve may be higher for beginners, gaining control of it will
    give you a great deal of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: Tailwind (utility-first CSS framework)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tailwind CSS is a utility-first CSS framework. The "utility-first" approach
    was created to combat the cons we talked about previously with CSS and Sass. In
    this methodology, we use small utility classes to build a component's style instead
    of defining our own class names. It can feel a little like writing inline styling,
    as your elements will have a string of utility classes added to them, but the
    benefit is that you don't have to write a single line of your own CSS if you don't
    want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros for using Tailwind are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One source of truth**: When using CSS or Sass, you must switch between two
    files: your markup and your style sheets. Tailwind does away with this concept
    and instead allows you to embed your styles directly in your markup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming conventions**: Tailwind removes the need for you to create your own
    classes. It has its own classes that are incredibly granular called "utility classes."
    You use these classes to build up your elements'' styles and not worry about creating
    unique classes for each component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smaller CSS**: Tailwind provides you with a complete set of utility classes
    that you rarely need to supplement with your own styles. Your CSS, therefore,
    stops increasing; in fact, it gets smaller. When you''re ready to production-build
    your application, you can use Tailwind''s built-in purge function to remove unused
    classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No side effects**: As we are adding styles in our markup and not manipulating
    the underlying class names, there are never any unintended side effects elsewhere
    in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons for using Tailwind are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Markup legibility**: As your markup contains your style built from utilities,
    the class names of elements can become incredibly long. When you add in the fact
    that these may need to change on hover or at breakpoints, your line length can
    end up very long.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning curve**: Utility-first requires you to learn many class names to
    know what tools you must build your styles with. This learning can take some time
    and slow you down at the beginning, but I believe once you have these under your
    belt, your development speed will become much faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailwind hits a great balance of abstraction and flexibility. It is the newest
    implementation on this list and my personal favorite.
  prefs: []
  type: TYPE_NORMAL
- en: CSS in JS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS in JS gives you the ability to write plain CSS within your components while
    removing the possibility of naming collisions with class names. For the purpose
    of exploring this option, I will be reviewing the pros and cons of the most popular
    solution, Styled Components ([https://styled-components.com](https://styled-components.com)).
    It is, however, worth mentioning that there are many different CSS in JS solutions,
    including Emotion ([https://emotion.sh](https://emotion.sh)) and JSS ([https://cssinjs.org](https://cssinjs.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros for using Styled Components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One source of truth**: Like Tailwind, Styled Components also removes context-switching,
    as your CSS code is housed within the same file as the component making use of
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Styles tied to components**: Styles are created for use by one specific component
    and are located next to the markup that implements them. As such, you know exactly
    what makes use of these styles but, more importantly, you know that editing these
    styles will only affect the markup located with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JS in CSS**: We can make use of JS inside our CSS to determine styling. This
    makes handling conditionals within styles much easier, as we do not have to create
    two different class names and use a ternary operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extending**: It can often be the case that you may want to use a component
    style but subtly modify it for a different use case. Instead of copying the styles
    again and creating a new component from the ground up, we can instead create a
    component that inherits the styling of another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons for using Styled Components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`. Styles used across all your pages are pulled in on every page
    without any way to easily split them. Even caching the styles is difficult, as
    class names are dynamically generated and can, therefore, change between builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you like a single source of truth, Styled Components improves the legibility
    of your markup when you are combining everything into one file. While performance
    is listed as a con, this is something that the community behind Styled Components
    is making an effort to improve.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a styling tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to styling your Gatsby site, there is no right or wrong way of
    styling it. It will totally depend on your existing skill set, how coupled you
    want your styles and JS to be, and your own personal preferences. I thought I
    would end this section by looking at a few common scenarios and what styling implementation
    I would use for each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*My experience with styling is limited*: If you are new to styling applications,
    I would suggest using vanilla CSS. The fundamentals you will learn using this
    implementation are built on in every other implementation. By learning the basics,
    you will be able to pick another implementation more easily in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I don''t want to spend lots of time styling my application*: If you are looking
    for the option with the least setup, then look no further than Tailwind. Using
    utility classes will save you a lot of time, as you do not need to create your
    own classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I don''t like context switching*: In this case, I would lean toward Styled
    Components or Tailwind, as in both implementations your styles are located next
    to your markup – one file and one source of truth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I have used CSS and want to build on that*: Using Sass would be a great option
    for you, as you can write the CSS you know and love but also enhance it with the
    Sass toolset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, you should feel ready to make an informed choice about which
    styling tool is for you. I strongly suggest that you *only implement one of the
    styling choices outlined in this chapter* instead of trying to mix and match.
    If you add multiple styling implementations, you can end up in a position where
    your site styles don't seem to match up. This is because one implementation can
    override another. By sticking to one method, you have the added benefit of keeping
    your site's style consistently uniform, which is important, as it reinforces your
    brand.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have made a decision, let's start looking at implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to implement CSS styling into our Gatsby
    project.
  prefs: []
  type: TYPE_NORMAL
- en: There are two different methods to adding global CSS styling to our Gatsby site
    – creating a wrapper component or using `gatsby-browser.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a wrapper component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind a wrapper component is to wrap our page components in another
    component that brings common styles to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `StyleWrapper.css` in your `components` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we are defining a background color and a font family
    that all children of the HTML tag can inherit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now add some `h1` styles to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding the color, size, and weight of the largest `heading` tag.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, we can also add some styles for the `p` and `a` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding a color to each tag and, in the case of the `a` tags, an
    underline to make them more prominent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `StyleWrapper.js` in your `components` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the name might suggest, we will use this component to wrap our pages to apply
    the styles we are importing on the second line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to use `StyleWrapper.js`, we need to import it into our pages; let''s
    look at `pages/index.js` as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using gatsby-browser.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want the same styles applied to every page, you might feel that importing
    `StyleWrapper` on all page instances doesn''t feel like you''re following **Don''t
    Repeat Yourself** (**DRY**) principles. In cases where you are absolutely sure
    the styles are needed on every page, we can add them to our application using
    the Gatsby browser instead:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `styles` folder inside your `src` directory. As these styles are being
    used globally and are not tied to a specific component, it does not make sense
    to store them in the `component` directory, as we did when implementing `StyleWrapper.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `global.css` file in your `styles` folder and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding the exact same styles that we had in the alternate CSS implementation,
    so I won't explain them again here. The key difference is in this next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to `gatsby-browser.js` and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By importing our CSS in `gatsby-browser.js`, Gatsby will wrap every page with
    this CSS.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verifying our implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regardless of which of the two methods you opted for, if everything has gone
    according to plan, you should be presented with a styled site that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Development of the index page with styles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15983_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Development of the index page with styles
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to pick out your CSS additions on this page.
  prefs: []
  type: TYPE_NORMAL
- en: You have now implemented CSS as a styling tool within your Gatsby site. You
    can disregard the other styling implementations that follow and proceed to the
    *Creating a reusable layout* section.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with Sass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to implement Sass styling in our Gatsby
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Sass, we will need to install it along with a few other dependencies.
    Open a terminal at the `root` folder of your project and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are installing the core Sass dependency as well as the Gatsby plugin
    that integrates it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your `gatsby-config.js` file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are updating our Gatsby configuration to let Gatsby know to make use
    of the `gatsby-plugin-sass` plugin. Now, create a `styles` folder inside your
    `src` directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `global.scss` file in your `styles` folder and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'I rarely add more than HTML styles to the `global.scss` file. Instead, I prefer
    to import other `.scss` files into this one. This keeps styles in order and the
    files small and readable. As an example, let''s create `typography.scss` to store
    some typography styles:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are adding a color to each and, in the case of the `a` tags, adding
    an underline to make them more prominent. We can now import this file into our
    `global.scss` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to your `gatsby-browser.js` file and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tells our Gatsby application to include this style sheet on the client,
    allowing us to make use of it in our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have now implemented Sass as a styling tool within your Gatsby site. You
    can disregard the other styling implementations that follow and proceed to the
    *Creating a reusable layout* section.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with Tailwind.css
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to implement Tailwind styling in our Gatsby
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Tailwind, we will need to install it along with a few other
    dependencies. Open a terminal at the `root` folder of your project and run the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are installing PostCSS, its associated Gatsby plugin, and `tailwindcss`.
    PostCSS is a tool for transforming styles with JS plugins. These plugins can lint
    your CSS, support variables and mixins, transpile future CSS syntax, inline images,
    and more. In the case of Tailwind, there is a specific tailwind plugin for PostCSS
    that we will be implementing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify your `gatsby-config.js` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are updating our Gatsby configuration to let it know to make use of
    the Gatsby PostCSS plugin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to use PostCSS, it requires `postcss.config.js` to be present at the
    root of your project. Go ahead and create this file now and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this file, we are telling PostCSS to make use of our newly installed `tailwindcss`
    package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Much like PostCSS, Tailwind also requires a configuration file. Tailwind has
    a built-in script for creating the default configuration. Open a terminal and
    run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this command is successful, you should notice that a new `tailwind.config.js`
    has been created at the root of your project. The default configuration within
    this file will work just fine, so for now, we don't need to edit it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a `styles` folder inside your `src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `global.css` file inside your `styles` folder and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the `gatsby-browser.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tells our Gatsby application to include this style sheet on the client,
    allowing us to make use of Tailwind classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With these steps concluded, we now have everything in place to start using
    Tailwind within our application. To make use of Tailwind''s utility classes, we
    can use React''s `className` prop within our components; for example, in `pages/index.js`,
    we could add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are modifying the style of the heading with the following
    utility classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text-3xl`: Set the text to the third extra-large size, equivalent to 1.875
    rem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-bold`: Set the text to the bold font-weight.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-blue-600`: Set the color of the text to blue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can alternatively append styles to the `global.css` file that we created
    to have them included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you will see the exact same styles, just defined globally. Both will equate
    to the same styling on the `h1` tag; deciding which variation to use is all about
    frequency. If you intend to use this `h1` style more than once, you should be
    incorporating it into your CSS to save you writing the same styles over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now supplement this with a few more styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are adding a color to each element and, in the case of the `a` tags,
    adding an underline to make them more prominent.
  prefs: []
  type: TYPE_NORMAL
- en: You have now implemented Tailwind as a styling tool within your Gatsby site.
    You can disregard the other styling implementations that follow and proceed to
    the *Creating a reusable layout* section.
  prefs: []
  type: TYPE_NORMAL
- en: Styling with styled-components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to implement Styled Components as a styling
    tool in our Gatsby project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal at the `root` folder of your project and run to install your
    dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These are the details of the dependencies:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`styled-components`: The Styled Components library'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gatsby-plugin-styled-components`: The official Gatsby plugin for Styled Components'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`babel-plugin-styled-components`: Provides consistently hashed class names
    between builds'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update your `gatsby-config.js` with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This instructs Gatsby to use the Styled Components plugin that we just installed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can have all the pieces in place to create styles on a page/component level
    and a global level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To demonstrate utilizing them, navigate to your `pages/index.js` file and add
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Occasionally, you may want to create styles globally; in order to demonstrate
    this, navigate to your `gatsby-browser.js` file and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `styled-components` `createGlobalStyle` helper function to create
    our global styles. This stops Styled Components from being scoped to a local CSS
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By using the `wrapPageElement` method, we tell Gatsby to wrap every page in
    the component. We can make use of this to wrap every page in our global styles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Regardless of your implementation choice, you should now have the basics in
    place to start building a fully styled site. Let's now start creating the reusable
    layout that we will utilize across the site.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most websites feature headers and footers that are present across all their
    pages. With our knowledge of how pages work, you might be tempted to import a
    header component into every page component. But wait – what happens when you suddenly
    need to pass that component a new prop? Situations like these are why it's a good
    idea to reduce any duplication across pages. Instead, it's a much better option
    to create a layout component that contains a header and footer that we can then
    wrap our pages in.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep our `components` folder well structured, it's useful to create
    subfolders to house different parts of the site. Create a `layout` folder in the
    `components` folder to house components that are related to the layout. We will
    use these layout components across all our page files. Now, let's populate this
    folder with a header, footer, and layout component.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: In the code examples in this section, you will notice I am using `Tailwind.css`
    to style my components. In the accompanying GitHub repository ([https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main)),
    you can find implementations of these components using all the styling implementations
    we have covered in this chapter. In future chapters, I will be sticking to Tailwind.
  prefs: []
  type: TYPE_NORMAL
- en: Site header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A header component acts as the anchor of our site. It is common to include your
    site header across all your pages so that visitors are reminded that they are
    on your site.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s create a `Header.js` component in our `components` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating the most basic of header examples. Note
    that we are making use of the HTML `header` tag. As we will learn in [*Chapter
    6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092), *Improving Your Site's Search Engine
    Optimisation*, using the correct tags when creating content is very important,
    as it helps web crawlers and accessibility tools understand your site.
  prefs: []
  type: TYPE_NORMAL
- en: Site footer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a footer to your site can be a powerful tool. I like to think of it as
    a way to keep user engagement after they have finished a page. We can use it to
    give people quick links to our social media so that they can get in touch, we
    can suggest other interesting content that they might enjoy, and we can even tell
    them how many views the current page has had.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started with a basic implementation. Create a `Footer.js` component
    in the `components` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Much like our `Header`, it's important that we use the proper HTML `footer`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Layout component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could directly import our header and footer onto every page we create, but
    if we did that, it would lead to a lot of duplication. One common way to get around
    this is to create a `Layout` component. We wrap every page we build in this component.
    Not only is this an easy way to bring in our header and footer but it also allows
    us to style the main content of every page with minimal effort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see I am importing our newly created `Header` and `Footer` components.
    I am making use of the `children` prop and rendering child content within a `main`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate using the `Layout` component, let''s wrap our index page in
    the component. Modify your `index.js` in pages with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can see that I have wrapped the landing page in our new `Layout` component
    that has been imported on the third line. If you spin up `gatsby develop` at this
    point, you should see your page content with a header before it and a footer after
    it. You can continue to wrap your other pages in your `layout` component at this
    moment. Before proceeding, let's step back for a moment and look at how we can
    organize the components we're creating for our pages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Some of the styling implementations discussed previously make use of style wrappers.
    If your implementation has made use of a style wrapper, import it into your `layout`
    component and wrap content in this component. This way, you only wrap your pages
    in one component instead of both the `layout` and `style wrapper` components.
  prefs: []
  type: TYPE_NORMAL
- en: Organization with atomic design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your site expands, it''s important to try and keep your `components` folder
    structured. One commonly used method is to use **atomic design** principles. Atomic
    design is the process of creating effective interface design systems by breaking
    down your site elements into atoms, molecules, organisms, templates, and pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atoms**: These are the smallest components that might be incorporated into
    our site, such as buttons, typography components, or text inputs. Atoms cannot
    be logically broken down into subcomponents while still keeping them functional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Molecules**: Built from two or more atoms, molecules are small groups of
    elements that work together to provide some functionality. A search box consisting
    of a text input and a button could be considered a molecule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organisms**: Built from a group of molecules and atoms, these form larger
    sections of an interface, such as a site''s hero section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: These wrap organisms in a layout and provide the content structure
    and skeletal structure of a page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pages**: An instance of a template with real-world content in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic design when building components allows you to break your components
    down into smaller self-contained units. These can be tested and developed in isolation
    before importing them into your application, allowing for a more rigorous development
    process but also reducing the reliance on backend logic when conducting frontend
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined our atomic design pattern, we can be far more flexible
    when working with styling. Changing an atom's style will also update the styles
    that any molecules and organisms were making use of.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your styling implementation, it can also be a good idea to abstract
    commonly used tokens, such as brand colors, spacing rules, and font families.
    It's much easier to maintain a project with a single source of truth, rather than
    darting all over your application pasting hex values to modify your brand colors.
  prefs: []
  type: TYPE_NORMAL
- en: Using atomic design to organize your `components` folder can really help as
    things scale, so keep it in mind in future chapters as your application expands.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how you can style a Gatsby site in a multitude
    of ways. This should aid you in making an informed choice about what way you will
    style your application going forward. We have seen how to style your Gatsby site
    using CSS, Sass, Tailwind.css, and Styled Components. You should have decided
    on one of these and implemented them. In future chapters, I will use Tailwind.css
    to style the application, but this is a personal preference. You should use whatever
    you feel is best for your site and your existing knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: We also started creating the first reusable components that will make up the
    backbone of our site. While our `layout` component may seem primitive right now,
    we will be integrating it with content in the next chapter and adding imagery
    to bring it to life even further in [*Chapter 5*](B15983_05_ePub_RK.xhtml#_idTextAnchor080),
    *Working with Images*.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing to the next chapter, I encourage you to spend time building
    on the styles outlined here until you have your existing pages looking how you
    want them to. While I think it's best to define your own styles, you can find
    an example of a completely styled version of the site in Tailwind.css in the code
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin sourcing content from local files, CMSes,
    and APIs. We will be using this data to start programmatically creating pages
    on our Gatsby site.
  prefs: []
  type: TYPE_NORMAL
