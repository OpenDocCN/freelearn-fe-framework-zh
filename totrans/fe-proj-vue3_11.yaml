- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In previous chapters, we saw how to build reasonably complex Vue.js applications.
    This chapter is about testing them to maintain code quality and prevent defects.
    We will look at approaches to unit testing Vue.js applications in order to improve
    the quality and speed of delivery of our applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何构建合理的复杂 Vue.js 应用程序。本章是关于测试它们以维护代码质量和防止缺陷。我们将探讨对 Vue.js 应用程序进行单元测试的方法，以提高我们应用程序的质量和交付速度。
- en: We will also look at using tests to drive development using **Test-Driven Development**
    (**TDD**). As we proceed, we will gain an understanding of why code needs to be
    tested and what kinds of testing can be employed on different parts of a Vue.js
    application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨使用测试来驱动开发，即**测试驱动开发**（**TDD**）。随着我们的进展，我们将了解为什么代码需要测试，以及可以在 Vue.js 应用程序的不同部分采用哪些类型的测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding testing and the need to test code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试和测试代码的必要性
- en: Building your first test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的第一个测试
- en: Testing components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件测试
- en: Testing methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试方法
- en: Testing routing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试路由
- en: Testing state management with Pinia
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pinia 测试状态管理
- en: Snapshot testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'There are no technical requirements for this chapter outside of the `git` CLI,
    which you will have already used by now. You can find this chapter’s source code
    here: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，除了 `git` 命令行界面外，没有其他技术要求，您现在应该已经使用过了。您可以在以下位置找到本章的源代码：[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11)
- en: Understanding testing and the need to test code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试和测试代码的必要性
- en: '**Testing** is a crucial process for ensuring that the code does what it’s
    meant to do. Quality production software is empirically correct. That means that
    for the enumerated cases that developers and testers have found, the application
    behaves as expected.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**是确保代码按预期执行的关键过程。高质量的生产软件是经验上正确的。这意味着对于开发人员和测试人员发现的列举案例，应用程序的行为符合预期。'
- en: This lies in contrast with software that has been proven to be correct, which
    is a very time-consuming endeavor and is usually part of academic research projects.
    We are still at the point where correct software (proven) is still being built
    to show what kinds of systems are possible to build with this constraint of correctness.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这与经过验证的正确的软件形成对比，这是一个非常耗时的工作，通常是学术研究项目的一部分。我们仍然处于这样一个阶段，即正确的软件（经过验证）仍在构建，以展示可以构建哪些类型的系统，同时受到正确性的限制。
- en: Testing prevents the introduction of defects such as bugs and regressions (that
    is, when a feature stops working as expected). In the next section, we will learn
    about the various types of testing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以防止引入缺陷，如错误和回归（即当功能停止按预期工作时）。在下一节中，我们将了解各种测试类型。
- en: Different types of testing
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同类型的测试
- en: The testing spectrum spans from **end-to-end testing** (by manipulating the
    user interface) to **integration tests**, and finally to **unit tests**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试范围从**端到端测试**（通过操作用户界面）到**集成测试**，最后到**单元测试**。
- en: End-to-end testing
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端到端测试
- en: End-to-end tests test everything, including the user interface, the underlying
    HTTP services, and even database interactions; nothing is mocked. If you’ve got
    an e-commerce application, an end-to-end test might actually place a real order
    with a real credit card, or it might place a test order with a test credit card.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试测试一切，包括用户界面、底层 HTTP 服务，甚至数据库交互；没有任何东西被模拟。如果您有一个电子商务应用程序，端到端测试实际上可能会使用真实信用卡下订单，或者可能会使用测试信用卡下测试订单。
- en: End-to-end tests are costly to run and maintain. They require the use of full-blown
    browsers controlled through programmatic drivers such as Selenium, WebdriverIO,
    or Cypress. This type of test platform is costly to run, and small changes in
    the application code can cause end-to-end tests to start failing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的运行和维护成本很高。它们需要使用通过程序性驱动程序（如 Selenium、WebdriverIO 或 Cypress）控制的完整浏览器。这种类型的测试平台运行成本很高，应用程序代码中的微小变化可能导致端到端测试开始失败。
- en: Integration tests
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration or system-level tests ensure that a set of systems is working as
    expected. This will usually involve deciding on a limit as to where the system
    under test lies and allowing it to run, usually against mocked or stubbed upstream
    services and systems (which are therefore not under test).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试或系统级测试确保一组系统按预期工作。这通常涉及决定测试的系统所在的范围，并允许它运行，通常是对模拟或存根的上游服务和系统进行测试（因此这些服务和系统不在测试范围内）。
- en: Since external data access is stubbed, a whole host of issues, such as timeouts
    and flakes, can be reduced (when compared to end-to-end tests). Integration test
    suites are usually fast enough to run as a continuous integration step, but the
    full test suite tends not to be run locally by engineers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于外部数据访问被存根，可以减少许多问题，如超时和故障（与端到端测试相比）。集成测试套件通常足够快，可以作为持续集成步骤运行，但完整的测试套件通常不会由工程师在本地运行。
- en: Unit tests
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are great at providing fast feedback during development. Unit testing
    paired with TDD is part of extreme programming practice. Unit tests are great
    at testing complicated logic or building a system from its expected output. Unit
    tests are usually fast enough to run a developer’s code against before sending
    their code for review and continuous integration tests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在开发过程中提供快速反馈方面非常出色。单元测试与 TDD（测试驱动开发）相结合是极限编程实践的一部分。单元测试非常适合测试复杂的逻辑或从预期的输出构建系统。单元测试通常足够快，可以在将代码提交审查和持续集成测试之前运行开发者的代码。
- en: 'The following diagram is an interpretation of the pyramid of testing. It can
    be interpreted to mean that you should have a high number of cheap and fast unit
    tests, a reasonable number of system tests, and just a few end-to-end UI tests:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是对测试金字塔的解释。它可以理解为你应该有大量的低成本、快速的单元测试，合理数量的系统测试，以及仅仅几个端到端 UI 测试：
- en: '![Figure 11.1 – Pyramid of testing diagram](img/Figure_11.01_B18645.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 测试金字塔图](img/Figure_11.01_B18645.jpg)'
- en: Figure 11.1 – Pyramid of testing diagram
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 测试金字塔图
- en: Now that we’ve looked at why we should be testing applications, let’s start
    writing some tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了为什么我们应该测试应用程序，那么让我们开始编写一些测试。
- en: Building your first test
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个测试
- en: To illustrate how quick and easy it is to get started with automated tests in
    a Vue 3 project, we will start by creating a simple test using Vitest ([https://vitest.dev/](https://vitest.dev/)),
    the officially recommended testing framework for Vue 3 and the simplest to begin
    with as the installation steps of a new application let you select it right away.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在 Vue 3 项目中开始自动化测试有多快、有多简单，我们将首先创建一个简单的测试，使用 Vitest ([https://vitest.dev/](https://vitest.dev/))，这是
    Vue 3 的官方推荐测试框架，也是开始时最简单的，因为新应用程序的安装步骤允许你立即选择它。
- en: 'In the following figure, you can see the prompt for installing Vitest:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到安装 Vitest 的提示：
- en: '![Figure 11.2 – Creating an application and selecting Yes to using Vitest](img/Figure_11.02_B18645.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 创建应用程序并选择是使用 Vitest](img/Figure_11.02_B18645.jpg)'
- en: Figure 11.2 – Creating an application and selecting Yes to using Vitest
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 创建应用程序并选择是使用 Vitest
- en: After the application is scaffolded, you will find it created a `__tests__`
    folder under `components` and created a test already. For now though, delete the
    file (but not the folder) and create a new `__tests__` folder directly under the
    root of you project. Next, create an `App.test.js` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序搭建完成后，你将发现它已经在 `components` 目录下创建了一个 `__tests__` 文件夹，并创建了一个测试文件。不过，现在请删除该文件（但不要删除文件夹），并在项目根目录下直接创建一个新的
    `__tests__` 文件夹。接下来，创建一个 `App.test.js` 文件。
- en: We will use `shallowMount` to render the application and test whether it displays
    `The Vue.js Workshop Blog`. `shallowMount` does a *shallow render*, which means
    that only the top level of a component is rendered; all the child components are
    stubbed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `shallowMount` 来渲染应用程序并测试它是否显示 `The Vue.js Workshop Blog`。`shallowMount`
    进行的是 *浅渲染*，这意味着只有组件的最顶层被渲染；所有子组件都被模拟。
- en: 'This is useful for testing a component in isolation since the child components’
    implementations are not run:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于单独测试组件很有用，因为子组件的实现并未运行：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save this file, and at the Terminal (ensure you’ve already run `npm install`
    to finish creating a new application), run `npm` `run test:unit`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件，然后在终端（确保你已经运行了 `npm install` 以完成新应用程序的创建），运行 `npm run test:unit`。
- en: 'When you indicated in the installation prompt that you wanted to include Vitest,
    it added the following script to the `package.json` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在安装提示中表明你想要包含 Vitest 时，它将以下脚本添加到 `package.json` 文件中：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will get a report on the test run and its immediate failure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得关于测试运行及其立即失败的报告：
- en: '![Figure 11.3 – The unit test running and failing](img/Figure_11.03_B18645.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 单元测试运行失败](img/Figure_11.03_B18645.jpg)'
- en: Figure 11.3 – The unit test running and failing
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 单元测试运行失败
- en: 'To make the test pass, we can edit our `App.vue` file to include the header
    we want (note that we also removed much of the code created by default):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使测试通过，我们可以编辑我们的`App.vue`文件以包含我们想要的标题（注意，我们还删除了默认创建的大部分代码）：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the file and you’ll immediately see the result:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，你会立即看到结果：
- en: '![Figure 11.4 – The test passing!](img/Figure_11.04_B18645.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 测试通过！](img/Figure_11.04_B18645.jpg)'
- en: Figure 11.4 – The test passing!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 测试通过！
- en: You have just completed your first piece of TDD. This process started by writing
    a test that failed. This failure was followed by an update to the code under test
    (in this case the `App.vue` component), which made the failing test pass.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了你的第一个TDD。这个过程从编写一个失败的测试开始。随后是对测试代码（在这种情况下是`App.vue`组件）的更新，这使得失败的测试通过。
- en: The TDD process gives us confidence that our features have been tested properly
    since we can see that tests fail before they pass when we update the code that
    drives our feature.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: TDD过程让我们有信心我们的功能已经被正确测试，因为我们可以看到在我们更新驱动我们功能的代码之前，测试是失败的。
- en: In the next section, we’ll show how to take what we’ve learned and apply it
    to Vue components.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何将我们所学应用到Vue组件中。
- en: Testing components
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: Components are at the core Vue.js applications. Writing unit tests for them
    is straightforward with Vitest. Having tests that exercise the majority of your
    components gives you confidence that they behave as designed. Ideal unit tests
    for components run quickly and are simple.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Vue.js应用程序的核心。使用Vitest编写单元测试非常简单。拥有测试来锻炼大多数组件可以让你有信心它们按设计运行。理想的组件单元测试运行快速且简单。
- en: We’ll carry on building the blog application example. We have now built the
    heading, but a blog usually also needs a list of posts to display.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建博客应用程序示例。我们现在已经构建了标题，但一个博客通常还需要一个帖子列表来显示。
- en: 'We’ll create a `PostList` component. For now, it will just render a `div` wrapper
    and support a `posts` `Array` prop:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`PostList`组件。目前，它将只渲染一个`div`包装器并支持一个`posts`数组属性：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can add some data in the `App` component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`App`组件中添加一些数据：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have some posts, we can pass them as a bound prop to the `PostList`
    component from the `App` component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些帖子，我们可以将它们作为绑定属性从`App`组件传递给`PostList`组件：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `PostList` component will render out each post in a `PostListItem` component,
    which we’ll create as follows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PostList`组件将渲染每个帖子到一个`PostListItem`组件中，我们将按照以下方式创建它。
- en: '`PostListItem` takes two props: `title` (which is a string) and `description`
    (also a string). It renders them in an `h3` tag and a `p` tag, respectively:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostListItem`接受两个属性：`title`（它是一个字符串）和`description`（也是一个字符串）。它分别用`h3`标签和`p`标签渲染它们：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now need to loop through the posts and render out a `PostListItem` component
    with relevant props bound in the `PostList.vue` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要遍历帖子并在`PostList.vue`组件中渲染一个带有相关属性的`PostListItem`组件：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To test the `PostListItem` component, we can do a shallow render with some
    arbitrary title and description props set, and check that they get rendered. Add
    a new file to `src/__tests__` named `PostListItem.test.js`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`PostListItem`组件，我们可以使用一些任意的标题和描述属性进行浅渲染，并检查它们是否被渲染。在`src/__tests__`目录下添加一个名为`PostListItem.test.js`的新文件：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This test can be run individually at the command line by using the `npm run
    test:unit __tests__/PostListItem.test.js` command (as seen in *Figure 11**.5*):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试可以通过在命令行中使用`npm run test:unit __tests__/PostListItem.test.js`命令单独运行（如*图11.5*.5所示）：
- en: '![Figure 11.5 – PostListItem test output](img/Figure_11.05_B18645.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – `PostListItem`测试输出](img/Figure_11.05_B18645.jpg)'
- en: Figure 11.5 – PostListItem test output
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – `PostListItem`测试输出
- en: Next, we’ll see one of the pitfalls of shallow rendering. When testing the `PostList`
    component, all we can do is test the number of `PostListItem` components it’s
    rendering.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到浅渲染的一个陷阱。在测试`PostList`组件时，我们所能做的就是测试它渲染的`PostListItem`组件的数量。
- en: 'Save this test as `__tests__/PostList.test.js`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将此测试保存为`__tests__/PostList.test.js`：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This passes, but we are testing something that the user will not directly interact
    with, the number of `PostListItem` instances rendered in `PostList`, as shown
    in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了，但我们测试的是用户不会直接与之交互的内容，即 `PostList` 中渲染的 `PostListItem` 实例的数量，如下面的屏幕截图所示：
- en: '![Figure 11.6 – PostList test output](img/Figure_11.06_B18645.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – PostList测试输出](img/Figure_11.06_B18645.jpg)'
- en: Figure 11.6 – PostList test output
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – PostList测试输出
- en: A better solution is to use the `mount` function, which renders the full component
    tree, whereas the `shallowMount` function would only render out the children of
    the component being rendered. With `mount`, we can assert that the titles and
    descriptions are rendered to the page.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用 `mount` 函数，它渲染完整的组件树，而 `shallowMount` 函数只会渲染正在渲染的组件的子组件。使用 `mount`，我们可以断言标题和描述被渲染到页面上。
- en: The drawback of this approach is that we’re testing both the `PostList` component
    and the `PostListItem` component since the `PostList` component doesn’t render
    the title or description; it renders a set of `PostListItem` components that in
    turn render the relevant title and description.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们在测试 `PostList` 组件和 `PostListItem` 组件，因为 `PostList` 组件不会渲染标题或描述；它渲染一组
    `PostListItem` 组件，这些组件反过来渲染相关的标题和描述。
- en: 'The code is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The new tests pass as indicated by the following output of the `npm run test:unit`
    `__tests__/PostList.test.js` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下 `npm run test:unit` `__tests__/PostList.test.js` 命令的输出所示，新的测试通过：
- en: '![Figure 11.7 – Test run for PostList with both shallow and mounted tests](img/Figure_11.07_B18645.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 对PostList进行浅渲染和挂载测试的测试运行](img/Figure_11.07_B18645.jpg)'
- en: Figure 11.7 – Test run for PostList with both shallow and mounted tests
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 对PostList进行浅渲染和挂载测试的测试运行
- en: We have now seen how to write unit tests for Vue.js with Vitest and `vue-test-utils`.
    These tests can be run often and the test runs complete within seconds, which
    gives us near-immediate feedback while working on new or existing components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Vitest 和 `vue-test-utils` 为 Vue.js 编写单元测试。这些测试可以经常运行，并且测试运行在几秒内完成，这在我们处理新或现有组件时提供了几乎即时的反馈。
- en: 'Exercise 11.01: Building and unit testing a tag list component'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.01：构建和单元测试标签列表组件
- en: When creating the fixture for `posts`, we populated a tags field with `vue`,
    `angularjs`, and `react` but did not display them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `posts` 的 fixture 时，我们用 `vue`、`angularjs` 和 `react` 填充了标签字段，但没有显示它们。
- en: The complete code for this exercise can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的完整代码可以在[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01)找到
- en: 'To make tags useful, we will display the tags in the post list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使标签有用，我们将在帖子列表中显示标签：
- en: We can start by writing a unit test that will explain what we expect a `PostListItem`
    component to do when passed a set of tags as props. It expects that each tag will
    be rendered with a hashtag prepended to it.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以开始编写一个单元测试，该测试将解释当将一组标签作为属性传递给 `PostListItem` 组件时，我们期望该组件执行的操作。它期望每个标签都将带有前缀的哈希符号渲染出来。
- en: 'For example, the `react` tag will be shown as `#react`. In the `__tests__/PostListItem.test.js`
    file, we can add a new test:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`react` 标签将显示为 `#react`。在 `__tests__/PostListItem.test.js` 文件中，我们可以添加一个新的测试：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This test fails when run with the `npm run test:unit __tests__/PostListItem.test.js`
    command, as shown in *Figure 11**.8*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `npm run test:unit __tests__/PostListItem.test.js` 命令运行时，此测试失败，如图 *图11*.8
    所示：
- en: '![Figure 11.8 – Tag test for PostListItem failing](img/Figure_11.08_B18645.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – PostListItem标签测试失败](img/Figure_11.08_B18645.jpg)'
- en: Figure 11.8 – Tag test for PostListItem failing
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – PostListItem标签测试失败
- en: 'Next, we should implement the tag list rendering in `src/components/PostListItem.vue`.
    We’ll add tags as props of the `Array` type and use `v-for` to render out the
    tags:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该在 `src/components/PostListItem.vue` 中实现标签列表渲染。我们将添加标签作为 `Array` 类型的属性，并使用
    `v-for` 来渲染标签：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the `PostListItem` component implemented, the unit test should now pass:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了 `PostListItem` 组件后，单元测试现在应该通过：
- en: '![Figure 11.9 – PostListItem unit test passing](img/Figure_11.09_B18645.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – PostListItem单元测试通过](img/Figure_11.09_B18645.jpg)'
- en: Figure 11.9 – PostListItem unit test passing
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – PostListItem单元测试通过
- en: 'However, the tags are not displayed in the application:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标签在应用程序中不会显示：
- en: '![Figure 11.10 – PostList displaying without tags despite the correct PostListItem
    implementation](img/Figure_11.10_B18645.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 尽管实现了正确的 PostListItem 实现，但 PostList 仍然没有显示标签](img/Figure_11.10_B18645.jpg)'
- en: Figure 11.10 – PostList displaying without tags despite the correct PostListItem
    implementation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 尽管实现了正确的 PostListItem 实现，但 PostList 仍然没有显示标签
- en: We can write a unit test for `PostList` that would show this behavior. In essence,
    we’ll be passing some tags in our `posts` list and running the same assertions
    as are already present in the `PostListItem.test.js` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以编写一个针对 `PostList` 的单元测试，以展示这种行为。本质上，我们将向我们的 `posts` 列表传递一些标签，并运行 `PostListItem.test.js`
    文件中已经存在的相同断言。
- en: 'We’ll do this in `__tests__/PostList.test.js`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `__tests__/PostList.test.js` 中这样做：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As per our application output shown in *Figure 11**.11*, the test is failing
    when run with the `npm run test:unit` `__tests__/PostList.test.js` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的应用程序输出显示在 *图 11*.11 中，当使用 `npm run test:unit` 命令运行 `__tests__/PostList.test.js`
    时，测试失败：
- en: '![Figure 11.11 – PostList tags test failing](img/Figure_11.11_B18645.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – PostList 标签测试失败](img/Figure_11.11_B18645.jpg)'
- en: Figure 11.11 – PostList tags test failing
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – PostList 标签测试失败
- en: 'In order to fix this test, we can find the issue in `src/components/PostList.vue`,
    where the tags prop for `PostListItem` is not bound. By updating `src/components/PostList.vue`
    to bind the `tags` prop, we can fix the unit test:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复这个测试，我们可以在 `src/components/PostList.vue` 中找到问题，其中 `PostListItem` 的标签属性未绑定。通过将
    `src/components/PostList.vue` 更新为绑定 `tags` 属性，我们可以修复单元测试：
- en: '[PRE40]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The failing unit test now passes, as shown in the following screenshot.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的单元测试现在通过了，如下面的截图所示。
- en: '![Figure 11.12 – PostList tags test passing](img/Figure_11.12_B18645.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – PostList 标签测试通过](img/Figure_11.12_B18645.jpg)'
- en: Figure 11.12 – PostList tags test passing
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – PostList 标签测试通过
- en: 'We have now seen how we can test rendered component output with both the shallow
    rendering and mounting of components. Let’s briefly understand what each of these
    terms means:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用浅渲染和组件挂载来测试渲染组件的输出。让我们简要了解这些术语的含义：
- en: '`1`, meaning that if children are components, they will just be rendered as
    the component tag; their template will not be run'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`，这意味着如果子项是组件，它们将仅作为组件标签渲染；它们的模板将不会运行'
- en: '**Mounting**: This renders the full component tree in a similar fashion as
    would be rendered in the browser'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：以与在浏览器中渲染相似的方式渲染完整的组件树'
- en: Next, we’ll look at how to test component methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何测试组件方法。
- en: Testing component methods
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件方法
- en: In the previous version of Vue, the recommendation would have been to do testing
    on filters and mixins, but typically avoid writing tests for methods as they aren’t
    directly called by users.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 的上一个版本中，建议对过滤器进行测试，对混入进行测试，但通常避免编写方法的测试，因为它们不是由用户直接调用的。
- en: In Vue 3, both filters and mixins are deprecated and replaced with *regular*
    methods and computed properties. That being said, finding the methods appropriate
    for tests may require some thought.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 3 中，过滤器已经弃用，并被 *常规* 方法计算属性所取代。话虽如此，找到适合测试的方法可能需要一些思考。
- en: 'Consider a `computed` property that truncates its input to eight characters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个截断其输入为八个字符的 `computed` 属性：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code sample, `truncated` is defined as a computed property
    based on the `description` value passed as a property. At the end, `defineExpose`
    is used to make the property available for testing. Items that are specified within
    `script setup` are considered *closed* and are not available outside the component
    itself. By using `defineExpose`, we can then write a test against `truncated`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`truncated` 被定义为基于传递给属性的 `description` 值的 `computed` 属性。最后，`defineExpose`
    被用来使属性可用于测试。在 `script setup` 中指定的项被认为是 *封闭的*，并且不在组件本身之外可用。通过使用 `defineExpose`，我们就可以编写针对
    `truncated` 的测试。
- en: We can test the logic of the computed property in two ways. First, longer strings
    should be truncated. Secondly, shorter strings should be returned as is.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式测试 `computed` 属性的逻辑。首先，较长的字符串应该被截断。其次，较短的字符串应按原样返回。
- en: 'Here are the additional tests added to `PostListItem.test.js`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加到 `PostListItem.test.js` 的附加测试：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first new test passes a long value for description and confirms that the
    truncated version is shorter. Note the use of `vm` to access the Vue instance
    of the component and then the `truncated` computed property. The next test confirms
    that if a shorter value is used, truncated will not shorten it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新测试传入一个长的描述值，并确认截断后的版本更短。注意使用`vm`来访问组件的Vue实例，然后是`truncated`计算属性。下一个测试确认如果使用较短的值，截断不会缩短它。
- en: Remember that a user would not actually call `truncated` directly. As an alternative
    to directly testing the computed property, we could confirm that any template
    usage works properly as well. In that case, using `wrapper.text()` would make
    sense to return the rendered result.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，用户实际上不会直接调用`truncated`。作为直接测试计算属性的替代，我们可以确认任何模板使用都正常工作。在这种情况下，使用`wrapper.text()`来返回渲染结果是有意义的。
- en: 'Exercise 11.02: Building and testing an ellipsis method'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：构建和测试省略号方法
- en: We have seen how to test an arbitrary `truncated` computed method; we will now
    implement an `ellipsis` computed method and test it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试任意的`truncated`计算方法；我们现在将实现一个`ellipsis`计算方法并对其进行测试。
- en: The complete code for this exercise can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的完整代码可以在[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02)找到。
- en: We can start by writing a set of tests for the `ellipsis` computed method (which
    will live in `src/components/PostListItem.vue`). One test should check that the
    filter does nothing if the passed value is less than 50 characters; another should
    check whether the passed value is more than 50 characters and if so, truncate
    the value to 50 and appends `…`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从编写一组测试用例开始，用于`ellipsis`计算方法（它将位于`src/components/PostListItem.vue`中）。一个测试应该检查如果传入的值少于50个字符，过滤器不会做任何事情；另一个测试应该检查传入的值是否超过50个字符，如果是，则截断值为50并附加`…`。
- en: 'We will do this in a`__tests__/ellipsis.test.js` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个`__tests__/ellipsis.test.js`文件中完成这项工作：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now implement the logic for `ellipsis` in `src/components/PostListItem.vue`.
    We will add a `computed` object with `ellipsis`, which will use `String#slice`
    if the passed value is longer than 50 characters and do nothing otherwise:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在`src/components/PostListItem.vue`中实现`ellipsis`的逻辑。我们将添加一个带有`ellipsis`的`computed`对象，如果传入的值超过50个字符，它将使用`String#slice`，否则不做任何事情：
- en: '[PRE50]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see, the `ellipsis` computed method works on the description prop
    and handles trimming values longer than 50 characters. The tests now pass as shown
    in *Figure 11**.13*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ellipsis`计算方法作用于`description`属性，并处理超过50个字符的值。测试现在如*图11**.13*所示通过：
- en: '![Figure 11.13 – Ellipsis tests now passing](img/Figure_11.13_B18645.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13 – 省略号测试现在通过](img/Figure_11.13_B18645.jpg)'
- en: Figure 11.13 – Ellipsis tests now passing
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 省略号测试现在通过
- en: We have now seen how to test methods and computed properties of a Vue.js component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试Vue.js组件的方法和计算属性。
- en: Next, we will see how to deal with an application that uses Vue.js routing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何处理使用Vue.js路由的应用程序。
- en: Testing Vue routing
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Vue路由
- en: We have currently got an application that renders our blog home page or feed
    view.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有一个渲染我们的博客主页或视图的应用程序。
- en: Next, we should have post pages. To do this, we will use Vue Router, as covered
    in previous chapters, and ensure that our routing works as designed with unit
    tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该有帖子页面。为此，我们将使用Vue Router，如前几章所述，并确保我们的路由通过单元测试按设计工作。
- en: 'Vue Router is installed using `npm`, specifically, `npm install vue-router@4`,
    and then wiring it up in the `main.js` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router是通过`npm`安装的，具体来说，`npm install vue-router@4`，然后在`main.js`文件中进行连接：
- en: '[PRE70]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we can create a file to define our routes in `src/router/index.js`. This
    will instantiate the router and define our initial paths. We will begin with a
    root path (`/`) to display the `PostList` component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`src/router/index.js`中创建一个文件来定义我们的路由。这将实例化路由并定义我们的初始路径。我们将从一个根路径（`/`）开始，以显示`PostList`组件：
- en: '[PRE71]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now that we’ve got our initial route, we should update the `App.vue` file to
    leverage the component being rendered by the router. We’ll render `render-view`
    instead of directly using `PostList`. The `posts` binding, however, stays the
    same:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了初始路由，我们应该更新 `App.vue` 文件以利用由路由器渲染的组件。我们将渲染 `render-view` 而不是直接使用 `PostList`。然而，`posts`
    绑定保持不变：
- en: '[PRE72]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, our posts in the `App.vue` file are missing a bit of core data to render
    a `SinglePost` component. We need to make sure to have the `slug` and `content`
    properties to render something useful on our `SinglePost` page:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`App.vue` 文件中的帖子缺少一些核心数据来渲染 `SinglePost` 组件。我们需要确保有 `slug` 和 `content` 属性，以便在我们的
    `SinglePost` 页面上渲染有用的内容：
- en: '[PRE73]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can now start working on a `SinglePost` component. For now, we''ll just
    have some placeholders in the template. Also, `SinglePost` will receive posts
    as a prop, so we can fill that in as well:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始工作在 `SinglePost` 组件上。目前，我们只是在模板中添加一些占位符。此外，`SinglePost` 将接收帖子作为 prop，因此我们也可以填写它：
- en: '[PRE74]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we will register `SinglePost` in `router/index.js` with the `/:postId`
    path (which will be available to the component under `this.$route.params.postId`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `router/index.js` 中注册 `SinglePost`，使用 `/:postId` 路径（该路径将在组件的 `this.$route.params.postId`
    下可用）：
- en: '[PRE75]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If we switch back to implementing the `SinglePost` component, we’ve got access
    to `postId`, which will map to the slug in the `posts` array, and we’ve also got
    access to `posts` since it’s being bound onto `render-view` by `App`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换回实现 `SinglePost` 组件，我们将访问 `postId`，它将映射到 `posts` 数组中的 slug，并且我们也访问到 `posts`，因为它被
    `App` 绑定到 `render-view`。
- en: 'Now we can create a computed property, `post`, which finds posts based on `postId`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个计算属性 `post`，它根据 `postId` 查找帖子：
- en: '[PRE76]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'From this computed `post` property, we can extract `title` and `content` if
    `post` exists (we have to watch out for posts that don’t exist). So, still in
    `SinglePost`, we can add the following computed properties:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个计算 `post` 属性中，如果我们有 `post`（我们必须注意不存在的帖子），我们可以提取 `title` 和 `content`。因此，仍然在
    `SinglePost` 中，我们可以添加以下计算属性：
- en: '[PRE77]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can then replace the placeholders in the template with the value of the
    computed properties. So, our template ends up as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用计算属性的值替换模板中的占位符。因此，我们的模板最终如下所示：
- en: '[PRE78]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now let’s update the application so that we can link to individual posts. In
    `PostList.vue`, pass the slug in as a new property:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新应用程序，以便我们可以链接到单个帖子。在 `PostList.vue` 中，将 slug 作为新的属性传递：
- en: '[PRE79]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, in `PostListItem`, we will first add a new `slug` property:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `PostListItem` 中，我们首先添加一个新的 `slug` 属性：
- en: '[PRE80]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then we edit the template to link with the `slug` property:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编辑模板以与 `slug` 属性链接：
- en: '[PRE81]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`router-link` is a Vue Router-specific link, which means that on the `PostList`
    page, upon clicking on a post list item, we are taken to the correct post’s URL,
    as shown in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-link` 是 Vue Router 特定的链接，这意味着在 `PostList` 页面上，点击帖子列表项时，我们将被带到正确的帖子
    URL，如下面的截图所示：'
- en: '![Figure 11.14 – Post list view displayed in the browser](img/Figure_11.14_B18645.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 浏览器中显示的帖子列表视图](img/Figure_11.14_B18645.jpg)'
- en: Figure 11.14 – Post list view displayed in the browser
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 浏览器中显示的帖子列表视图
- en: 'After clicking on a title, the right post is displayed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 点击标题后，显示正确的帖子：
- en: '![Figure 11.15 – Single post view displaying in the browser](img/Figure_11.15_B18645.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 浏览器中显示的单个帖子视图](img/Figure_11.15_B18645.jpg)'
- en: Figure 11.15 – Single post view displaying in the browser
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 在浏览器中显示的单个帖子视图
- en: 'To test `vue-router`, we will need to build our tests to handle the asynchronous
    nature of the router. We’ll begin by testing that clicking on a post properly
    loads just the information for a single post. We can do this by looking for all
    the blog posts on the initial page, and only one particular post when a route
    is clicked:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `vue-router`，我们需要构建我们的测试来处理路由的异步特性。我们将从测试点击一个帖子是否正确加载单个帖子的信息开始。我们可以通过查找初始页面上的所有博客帖子，并在点击路由时只查找一个特定的帖子来实现这一点：
- en: '[PRE82]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: On top, we import both `mount` and a new utility, `flushPromises`, that we’ll
    use later. We also import our router. In the test, we begin by navigating to the
    root path and as stated earlier, due to the asynchronous nature of the router,
    we wait for it to finish.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们导入 `mount` 和一个新工具 `flushPromises`，我们将在稍后使用。我们还导入了我们的路由。在测试中，我们首先导航到根路径，如前所述，由于路由的异步特性，我们等待它完成。
- en: We then check for both blog posts. After that, we trigger a click event on the
    first post, wait for it to finish with `flushPromises`, and then check to see
    that only our first post is rendered.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查两个博客帖子。之后，我们在第一个帖子上触发一个点击事件，等待它完成`flushPromises`，然后检查是否只渲染了我们的第一个帖子。
- en: 'We should check that navigating directly to a valid post URL will yield the
    correct result. In order to this we’ll use `router.replace(''/'')` to clear any
    state that’s set and then use `router.push()` with a post slug. We will then use
    similar assertions to ensure we’re rendering just one post:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查直接导航到有效的帖子URL将产生正确的结果。为了做到这一点，我们将使用`router.replace('/')`清除任何设置的状态，然后使用带有帖子短语的`router.push()`。然后我们将使用类似的断言来确保我们只渲染一个帖子：
- en: '[PRE83]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Those two tests work as expected when run with the `npm run test:unit __tests__/SinglePost.test.js`
    command. The following screenshot displays the desired output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`npm run test:unit __tests__/SinglePost.test.js`命令运行这两个测试时，它们按预期工作。以下截图显示了所需的输出：
- en: '![Figure 11.16 – Routing tests passing for SinglePost](img/Figure_11.16_B18645.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图11.16 – 单个帖子路由测试通过](img/Figure_11.16_B18645.jpg)'
- en: Figure 11.16 – Routing tests passing for SinglePost
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 单个帖子路由测试通过
- en: Now that you’ve seen how to test your routes, let’s practice it with an example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何测试你的路由，让我们用一个例子来练习一下。
- en: 'Exercise 11.03: Building a tag page and testing its routing'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.03：构建标签页面并测试其路由
- en: Much like we built a single-post page, we’ll now build a tag page, which is
    similar to the `PostList` component except only posts with a certain tag are displayed
    and each post is a link to a relevant single-post view.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们构建单个帖子页面一样，我们现在将构建一个标签页面，它类似于`PostList`组件，除了只显示具有特定标签的帖子，每个帖子都是一个链接到相关单个帖子视图。
- en: You can find the complete code at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03)找到完整的代码。
- en: 'We can start by creating a new `TagPage` component in `src/components/TagPage.vue`.
    We know it will receive `posts` as a prop and that we want to render a `PostList`
    component:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从在`src/components/TagPage.vue`中创建一个新的`TagPage`组件开始。我们知道它将接收`posts`作为属性，并且我们想要渲染一个`PostList`组件：
- en: '[PRE84]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we want to wire the `TagPage` component to the router in `src/router.js`.
    We’ll import it and add it as part of `routes` with the `/``tags/:tagName` path:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想在`src/router.js`中将`TagPage`组件连接到路由器。我们将导入它并将其作为`routes`的一部分添加，路径为`/tags/:tagName`：
- en: '[PRE96]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Back in `TagPage.vue`, we can now use the `tagName` param and create a `tagName`
    computed property as well as a `tagPosts` computed property that filters based
    on the tag.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TagPage.vue`中，我们现在可以使用`tagName`参数并创建一个`tagName`计算属性以及一个基于标签的`tagPosts`计算属性。
- en: '[PRE106]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Now that we have access to `tagPosts` and `tagName`, we can replace the placeholders
    in the template. We will render `#{{ tagName }}` and bind `tagPosts` to the `posts`
    prop of `PostList`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了对`tagPosts`和`tagName`的访问权限，我们可以替换模板中的占位符。我们将渲染`#{{ tagName }}`并将`tagPosts`绑定到`PostList`的`posts`属性：
- en: '[PRE122]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, the page displays something like the following if we navigate, for example,
    to `/tags/angularjs`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们导航到例如`/tags/angularjs`，页面将显示如下内容：
- en: '![Figure 11.17 – Tag page for angularjs](img/Figure_11.17_B18645.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17 – angularjs的标签页面](img/Figure_11.17_B18645.jpg)'
- en: Figure 11.17 – Tag page for angularjs
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – angularjs的标签页面
- en: 'The next step is to convert the tag anchors (`a`) in `PostListItem` to `router-link`
    that points to `/tags/${tagName}` (in `src/components/PostListItem.vue`):'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将`PostListItem`中的标签锚点（`a`）转换为指向`/tags/${tagName}`的`router-link`（在`src/components/PostListItem.vue`中）：
- en: '[PRE126]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now it is time to write some tests. We will first check that being on the home
    page and clicking on `angularjs` tag page. We’ll write it as follows in `__tests__/TagPage.test.js`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写一些测试了。我们首先检查在主页上点击`angularjs`标签页面的情况。我们将在`__tests__/TagPage.test.js`中这样编写：
- en: '[PRE130]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'We should also test that going directly to the tag URL works as expected; that
    is, we do not see irrelevant content:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该测试直接访问标签URL是否按预期工作；也就是说，我们看不到不相关的内容：
- en: '[PRE157]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The tests pass since the application is working as expected. Therefore, the
    output will be as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过，因为应用程序按预期工作。因此，输出将如下所示：
- en: '![Figure 11.18 – TagPage routing tests passing on the command line](img/Figure_11.18_B18645.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18 – TagPage路由测试在命令行上通过](img/Figure_11.18_B18645.jpg)'
- en: Figure 11.18 – TagPage routing tests passing on the command line
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – TagPage 路由测试在命令行上通过
- en: 'Before going on, however, let’s run *all* our unit tests. You’ll notice that
    while our tests pass, there are now various warnings:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续之前，让我们运行所有的单元测试。你会注意到，虽然我们的测试通过了，但现在有各种警告：
- en: '![Figure 11.19 – Warnings about router-link and router-view](img/Figure_11.19_B18645.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19 – 关于 router-link 和 router-view 的警告](img/Figure_11.19_B18645.jpg)'
- en: Figure 11.19 – Warnings about router-link and router-view
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – 关于 router-link 和 router-view 的警告
- en: As these warnings don’t fail our tests, we should remove them. We’ve got a few
    options for how to do this.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些警告不会使我们的测试失败，我们应该移除它们。我们有一些处理这个问题的方法。
- en: One way is to simply stub out, or *fake*, the components we don’t need. In this
    case, we want our tests to ignore the router components that we aren’t testing
    at the time. We can address this by using an option supported by both `mount`
    and `shallowMount`, `stubs`. By using the `stubs` option, we tell Vue’s test utilities
    to *stub*, or create an empty component of, a set of tags.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过简单地模拟，或*伪造*，我们不需要的组件。在这种情况下，我们希望我们的测试忽略我们当时没有测试的路由组件。我们可以通过使用 `mount`
    和 `shallowMount` 都支持的一个选项 `stubs` 来解决这个问题。通过使用 `stubs` 选项，我们告诉 Vue 的测试工具*模拟*或创建一组标签的空组件。
- en: 'We add this option in a new global argument to either `mount` or `shallowMount`.
    Here’s an example in `ellipsis.test.js`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新的全局参数中添加此选项，以供 `mount` 或 `shallowMount` 使用。以下是在 `ellipsis.test.js` 中的示例：
- en: '[PRE174]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Once added to both tests in `ellipsis.test.js`, those warnings go away. Next,
    we’ll fix `App.test.js`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 `ellipsis.test.js` 中的两个测试中添加，这些警告就会消失。接下来，我们将修复 `App.test.js`：
- en: '[PRE175]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Notice we stub `router-view` as well. Next, we’ll fix `PostList.test.js` and
    `PostListItem.test.js`. Both of these actually use `router-link` so we can’t stub
    them, but we can provide them as plugins to `mount` and `shallowMount`. In `PostList.test.js`,
    we first import our router:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们还模拟了 `router-view`。接下来，我们将修复 `PostList.test.js` 和 `PostListItem.test.js`。这两个测试实际上使用了
    `router-link`，因此我们无法模拟它们，但我们可以将它们作为插件提供给 `mount` 和 `shallowMount`。在 `PostList.test.js`
    中，我们首先导入我们的路由器：
- en: '[PRE176]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Then in each of the three tests, pass the router as a plugin in the `global`
    object, for example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在三个测试中的每一个中，将路由器作为 `global` 对象中的一个插件传递，例如：
- en: '[PRE177]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Next, we can update `PostListItem.test.js`, but we need to make another change
    here. Previously the test made use of `shallowMount`, but we need to switch to
    `mount` so `router-link` properly renders its output. Here’s the entire test with
    both the plugin change and the switch to `mount`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以更新 `PostListItem.test.js`，但在这里我们需要进行另一个更改。之前这个测试使用了 `shallowMount`，但我们需要切换到
    `mount` 以确保 `router-link` 正确渲染其输出。以下是包含插件更改和切换到 `mount` 的整个测试：
- en: '[PRE178]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: At this point, our warnings have been resolved. We’ve now seen how to implement
    and test an application that includes `vue-router`. In the next section, we will
    learn about testing Pinia in detail.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的警告已经解决。我们已经看到了如何实现和测试一个包含 `vue-router` 的应用程序。在下一节中，我们将详细了解如何测试 Pinia。
- en: Testing state management with Pinia
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pinia 测试状态管理
- en: To show how to test a component that relies on Pinia (Vue’s official global
    state management solution), we’ll implement and test a newsletter subscription
    banner.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何测试一个依赖于 Pinia（Vue 的官方全局状态管理解决方案）的组件，我们将实现并测试一个通讯订阅横幅。
- en: To start with, we should create the banner template. The banner will contain
    a **Subscribe to the newsletter** call to action and a close button.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该创建横幅模板。横幅将包含一个**订阅通讯**的调用操作和一个关闭按钮。
- en: '[PRE179]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'We can display the `NewsletterBanner` component in the `App.vue` file as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `App.vue` 文件中如下显示 `NewsletterBanner` 组件：
- en: '[PRE180]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We’ll then install Pinia with the `npm install –save pinia` command. Once Pinia
    is installed, we can initialize our store in a `store.js` file as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `npm install –save pinia` 命令安装 Pinia。一旦 Pinia 安装完成，我们可以在 `store.js`
    文件中初始化我们的商店，如下所示：
- en: '[PRE181]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Our Pinia store is also registered in the `main.js` file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Pinia 商店也已在 `main.js` 文件中注册：
- en: '[PRE182]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'In order to decide whether the newsletter banner should be displayed or not,
    we need to add an initial state to our store:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定通讯横幅是否应该显示，我们需要在我们的商店中添加一个初始状态：
- en: '[PRE183]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'To close the banner, we need an action that will set `dismissedSubscribeBanner`
    to `true`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭横幅，我们需要一个将 `dismissedSubscribeBanner` 设置为 `true` 的动作：
- en: '[PRE184]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We can now use the store state and the `dismissSubscribeBanner` action to decide
    whether to show the banner (using `v-if`) and whether to close it (binding to
    a click on the close button):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用商店状态和 `dismissSubscribeBanner` 动作来决定是否显示横幅（使用 `v-if`）以及是否关闭它（绑定到关闭按钮的点击）：
- en: '[PRE185]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'At this point, the banner looks like this in a browser:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，横幅在浏览器中的样子如下：
- en: '![Figure 11.20 – Newsletter banner displayed in a browser](img/Figure_11.20_B18645.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20 – 浏览器中显示的新闻通讯横幅](img/Figure_11.20_B18645.jpg)'
- en: Figure 11.20 – Newsletter banner displayed in a browser
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 – 浏览器中显示的新闻通讯横幅
- en: Before we write our unit test, it may be a good idea to see if our *existing*
    tests work. (And as you can probably guess, this is leading to something.) If
    you go ahead and run all the tests, you’ll see a whole new set of issues.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写单元测试之前，查看我们的**现有**测试是否工作可能是个好主意。（而且你可能已经猜到了，这会引出一些东西。）如果你继续运行所有测试，你会看到一系列全新的问题。
- en: 'In the first following figure, note the warnings:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的第一个图中，请注意警告：
- en: '![Figure 11.21 – Test failures related to Pinia](img/Figure_11.21_B18645.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.21 – 与 Pinia 相关的测试失败](img/Figure_11.21_B18645.jpg)'
- en: Figure 11.21 – Test failures related to Pinia
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21 – 与 Pinia 相关的测试失败
- en: 'As you can see, we now have two tests failing due to Pinia. As with the issues
    we saw with Vue Router, we need to do some work to ensure our tests don’t throw
    an error just because we added in Pinia. To begin, we’re going to install some
    Pinia-specific testing utilities via `npm`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在有两个测试因为 Pinia 而失败。正如我们看到的 Vue Router 的问题一样，我们需要做一些工作来确保我们的测试不会仅仅因为添加了
    Pinia 就抛出错误。首先，我们将通过`npm`安装一些特定的 Pinia 测试工具：
- en: '[PRE186]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'This gives us the ability to then import a utility to help test Pinia stores,
    as well as helping with the new errors being thrown. In `SinglePost.test.js`,
    import Pinia’s testing utility:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够导入一个实用工具来帮助测试 Pinia 存储，同时帮助处理新抛出的错误。在`SinglePost.test.js`中，导入 Pinia 的测试工具：
- en: '[PRE187]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Then, much like how we passed Vue Router as a plugin, we’ll also pass a test-specific
    version of Pinia:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像我们通过插件传递 Vue Router 一样，我们也将传递一个针对测试的 Pinia 版本：
- en: '[PRE188]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The `createSpy` parameter is used to stub action calls and uses `vi.fn`. In
    our first line in the unit test, we can modify the imports from `vitest` like
    so:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSpy`参数用于模拟动作调用并使用`vi.fn`。在我们的单元测试的第一行中，我们可以像这样修改从`vitest`的导入：'
- en: '[PRE189]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Update the plugins attribute for all the wrappers in `SinglePost.test.js` and
    repeat the same fixes for `TagPage.test.js`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`SinglePost.test.js`中所有包装器的`plugins`属性，并对`TagPage.test.js`重复相同的修复。
- en: 'The next check should be that if the store has `dismissedSubscriberBanner:
    true`, the banner should not be displayed. This is done by using the `initialState`
    feature of `createTestingPinia`. It lets you define initial state values based
    on the ID value of our store.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个检查应该是，如果商店有`dismissedSubscriberBanner: true`，则横幅不应显示。这是通过使用`createTestingPinia`的`initialState`功能来实现的。它允许你根据我们商店的
    ID 值定义初始状态值。'
- en: '[PRE190]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The final test we’ll write is to make sure that clicking the banner’s **Close**
    button fires an action to the store. We can do this by checking that it is called
    when clicking the **Close** button:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的最后一个测试是为了确保点击横幅的**关闭**按钮会触发对商店的操作。我们可以通过检查在点击**关闭**按钮时是否被调用来实现这一点：
- en: '[PRE191]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The tests will now pass when run with the `npm run test:unit __tests__/NewsletterBanner.test.js`
    command, as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`npm run test:unit __tests__/NewsletterBanner.test.js`命令运行测试时，测试将会通过，如下所示：
- en: '![Figure 11.22 – Unit tests for NewsLetterBanner passing on the command line](img/Figure_11.22_B18645.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.22 – NewsLetterBanner 的单元测试在命令行上通过](img/Figure_11.22_B18645.jpg)'
- en: Figure 11.22 – Unit tests for NewsLetterBanner passing on the command line
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 – NewsLetterBanner 的单元测试在命令行上通过
- en: You’ve now had a chance to work with Pinia state management and testing, let’s
    now work on an exercise to demonstrate what you’ve learned.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有机会使用 Pinia 状态管理和测试了，让我们现在进行一个练习来展示你所学的知识。
- en: 'Exercise 11.04: Building and testing a cookie disclaimer banner'
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.04：构建和测试一个饼干声明横幅
- en: We’ll now look at how to implement a cookie disclaimer banner using Pinia and
    how to test it. We will store whether the cookie banner is being shown in Pinia
    (the default is `true`); when the banner is closed, it will update to `false`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何使用 Pinia 实现一个饼干声明横幅以及如何对其进行测试。我们将在 Pinia 中存储是否显示饼干横幅（默认为`true`）；当横幅关闭时，它将更新为`false`。
- en: You can find the complete code at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04)找到完整的代码。
- en: 'Create a green cookie banner with a `Cookies Disclaimer` title in bold, the
    disclaimer, and an `I agree` button. We will create this in `src/components/CookieBanner.vue`:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有加粗的 `Cookies Disclaimer` 标题的绿色 cookie 横幅，免责声明和 `我同意` 按钮。我们将在 `src/components/CookieBanner.vue`
    中创建这个：
- en: '[PRE192]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Next, we will need to import and render `CookieBanner` below `router-view`
    in `src/App.vue`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `src/App.vue` 中导入并渲染 `CookieBanner` 以下的内容：
- en: '[PRE210]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Add a state value to control whether to display the cookie banner. In our Pinia
    store, we will initialize `acceptedCookie` to `false`:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个状态值来控制是否显示 cookie 横幅。在我们的 Pinia store 中，我们将 `acceptedCookie` 初始化为 `false`：
- en: '[PRE223]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'We will also need an `acceptCookie` action to close the banner:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个 `acceptCookie` 动作来关闭横幅：
- en: '[PRE229]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Next, we will expose the store state as an `accept``edCookie` computed property:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将暴露 store 状态作为 `acceptedCookie` 计算属性：
- en: '[PRE239]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'We will use `v-if` to show the banner when cookies have not been accepted yet.
    The **I agree** button will close the banner when it’s clicked by calling the
    store action:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未接受 cookies，我们将使用 `v-if` 显示横幅。当点击 **我同意** 按钮时，将调用 store 动作关闭横幅：
- en: '[PRE247]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'We now have a cookie banner that is displayed until **I agree** is clicked,
    as shown in the following screenshot:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个在点击 **我同意** 之前显示的 cookie 横幅，如下面的截图所示：
- en: '![Figure 11.23 – Cookie banner displayed in the browser](img/Figure_11.23_B18645.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.23 – 浏览器中显示的 Cookie 横幅](img/Figure_11.23_B18645.jpg)'
- en: Figure 11.23 – Cookie banner displayed in the browser
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – 浏览器中显示的 Cookie 横幅
- en: 'We will now write a test that checks that `CookieBanner` is displayed by default:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将编写一个测试来检查 `CookieBanner` 默认显示：
- en: '[PRE254]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'We will also write a test to check whether `acceptedCookie` is `true` in the
    store, and if so, the cookie banner won’t be displayed:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将编写一个测试来检查 store 中的 `acceptedCookie` 是否为 `true`，如果是，则不会显示 cookie 横幅：
- en: '[PRE272]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Finally, we want to check that when the `acceptCookie` action is triggered:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们想要检查当触发 `acceptCookie` 动作时：
- en: '[PRE288]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'The three tests we wrote pass when run with `npm run test:unit __tests__/CookieBanner.test.js`,
    as follows:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `npm run test:unit __tests__/CookieBanner.test.js` 运行时，我们编写的三个测试都通过了，如下所示：
- en: '![Figure 11.24 – Tests for the cookie banner passing](img/Figure_11.24_B18645.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.24 – Cookie 横幅测试通过](img/Figure_11.24_B18645.jpg)'
- en: Figure 11.24 – Tests for the cookie banner passing
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – Cookie 横幅测试通过
- en: We’ve now seen how to test components that rely on Pinia for state and updates.
    Next, we’ll look at snapshot testing to see how it simplifies the testing of render
    output.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试依赖于 Pinia 进行状态和更新的组件。接下来，我们将探讨快照测试，看看它是如何简化渲染输出的测试的。
- en: Snapshot testing
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照测试
- en: Snapshot tests provide a way to write tests for fast-changing pieces of code
    without keeping the assertion data inline with the test. Changes to a snapshot
    reflect changes to the output, which is quite useful for code reviews.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试提供了一种为快速变化的代码片段编写测试的方法，而不需要将断言数据与测试内联。快照的变化反映了输出的变化，这在代码审查中非常有用。
- en: 'For example, we can add a snapshot test to the `PostList.test.js` file:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在 `PostList.test.js` 文件中添加一个快照测试：
- en: '[PRE300]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'The first time this test is run, a snapshot file will be written to `__tests__/__snapshots__`:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此测试时，将快照文件写入 `__tests__/__snapshots__`：
- en: '[PRE301]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: This makes it easy to quickly see what the changes mean in terms of concrete
    output.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得快速看到更改在具体输出方面的含义变得容易。
- en: We’ve now seen how to use snapshot tests. Next, we’ll put all the tools we've
    learned about in this chapter together to add a new page.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用快照测试。接下来，我们将把本章中我们所学到的所有工具结合起来，添加一个新页面。
- en: 'Activity 11.01: Adding a simple search-by-title page with tests'
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：添加一个简单的按标题搜索页面并包含测试
- en: 'We have already built a post list page, a single-post view page, and a posts-by-tag
    page. A great way to resurface old content on a blog is by implementing good search
    functionality. We will add search functionality to the `PostList` page:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个帖子列表页面、单个帖子视图页面和按标签分类的帖子页面。在博客上重新展示旧内容的一个好方法是通过实现良好的搜索功能。我们将向 `PostList`
    页面添加搜索功能：
- en: Create the search form with an input and a button in a new file at `src/components/SearchForm.vue`.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件 `src/components/SearchForm.vue` 中创建一个带有输入和按钮的搜索表单。
- en: We’ll now get the form to display by importing and rendering it on `src/App.vue`.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过导入并在 `src/App.vue` 上渲染表单来使表单显示：
- en: 'We are now able to search the search form in the application, as follows:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式在应用程序中搜索搜索表单：
- en: '![Figure 11.25 – The post view with a search form](img/Figure_11.25_B18645.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.25 – 带有搜索表单的帖子视图](img/Figure_11.25_B18645.jpg)'
- en: Figure 11.25 – The post view with a search form
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25 – 带有搜索表单的帖子视图
- en: We’re now ready to add a snapshot test for the search form. In `__tests__/SearchForm.test.js`,
    we should add `SearchForm should match` `expected HTML`.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备为搜索表单添加一个快照测试。在 `__tests__/SearchForm.test.js` 中，我们应该添加 `SearchForm should
    match` `expected HTML`。
- en: We want to track the contents of the search form input using `v-model` to two-way
    bind the `searchTerm` instance variable and the contents of the input.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望使用 `v-model` 跟踪搜索表单输入的内容，以双向绑定 `searchTerm` 实例变量和输入内容。
- en: When the search form is submitted, we’ll need to update the URL with the right
    parameter. This can be done with `this.$router.push()`. We will store the search
    in a `q` query parameter.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提交搜索表单时，我们需要更新 URL 以包含正确的参数。这可以通过 `this.$router.push()` 完成。我们将把搜索存储在 `q` 查询参数中。
- en: We will want to reflect the state of the `q` query parameter in the search form
    input. We can do this by reading `q` from `this.$route.query` and setting it as
    the initial value for the `searchTerm` data field in the `SearchForm` component
    state.
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望反映 `q` 查询参数的状态在搜索表单输入中。我们可以通过从 `this.$route.query` 中读取 `q` 并将其设置为 `SearchForm`
    组件状态中 `searchTerm` 数据字段的初始值来实现这一点。
- en: Next, we’ll want to filter the posts passed to `PostList` on the home page.
    We’ll use `route.query.q` in a computed property that filters posts by their title.
    This new computed property will then be used instead of posts in `src/App.vue`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望过滤传递给主页上 `PostList` 的帖子。我们将使用 `route.query.q` 在一个计算属性中过滤帖子标题。这个新的计算属性将替代
    `src/App.vue` 中的帖子。
- en: Next, we should add a test that changes the search query parameter and check
    that the app shows the right result. To do this, we can import `src/App.vue` and
    `@/router.js`, and render the app with the store and the router. We can then update
    the search field contents. Finally, we can submit the form by clicking the element
    where test ID is `Search` (which is the search button).
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该添加一个测试，更改搜索查询参数，并检查应用程序是否显示正确的结果。为此，我们可以导入 `src/App.vue` 和 `@/router.js`，并使用存储和路由渲染应用程序。然后我们可以更新搜索字段的内容。最后，我们可以通过点击测试
    ID 为 `Search` 的元素（这是搜索按钮）来提交表单。
- en: Note
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01)
    找到。
- en: Summary
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we’ve looked at different approaches to testing different
    types of Vue.js applications.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试不同类型 Vue.js 应用程序的不同方法。
- en: Testing in general is useful for empirically showing that the system is working.
    Unit tests are the cheapest to build and maintain and should be the base of testing
    functionality. System tests are the next level up in the testing pyramid and allow
    you to gain confidence that the majority of features are working as expected.
    End-to-end tests show that the main flows of the full system work.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试对于实证地展示系统正在工作是有用的。单元测试是构建和维护成本最低的，应该是测试功能的基础。系统测试是测试金字塔的下一级，可以让你有信心大多数功能按预期工作。端到端测试表明整个系统的主要流程是正常工作的。
- en: We’ve seen how to unit test components and methods, as well as testing through
    layers, and testing component output in a black-box fashion instead of inspecting
    component internals to test functionality. Using the Vitest testing library, we
    tested advanced functionality, such as routing and applications, that leverage
    Pinia.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何对组件和方法进行单元测试，以及通过层进行测试，以及以黑盒方式测试组件输出而不是检查组件内部以测试功能。使用 Vitest 测试库，我们测试了利用
    Pinia 的高级功能，如路由和应用程序。
- en: Finally, we looked at snapshot testing and saw how it can be an effective way
    to write tests for template-heavy chunks of code.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了快照测试，并看到了它如何成为为代码块中模板密集型部分编写测试的有效方法。
- en: In the next chapter, we will look at end-to-end testing techniques that can
    be applied to Vue.js applications.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可以应用于 Vue.js 应用的端到端测试技术。
