- en: Creating Directives and Implementing Change Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建指令和实现变更检测
- en: In this chapter, we will learn and understand all about Angular Directives and
    change detection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和理解关于Angular指令和变更检测的所有内容。
- en: We will learn about different types of directives provided by Angular and also
    create some custom user-defined directives. We will deep dive into learning how
    Angular handles the change detection and how we can utilize change detection in
    our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习Angular提供的不同类型的指令，并创建一些自定义用户定义的指令。我们将深入学习Angular如何处理变更检测以及如何在我们的应用程序中利用变更检测。
- en: 'At the end of this chapter, you will be able to do the following things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够做到以下几点：
- en: Understand Angular Directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular指令
- en: Understand and implement built-in Component Directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并实现内置组件指令
- en: Understand and implement built-in Structural Directives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并实现内置结构指令
- en: Understand and implement built-in Attribute Directives
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并实现内置属性指令
- en: Create custom-defined Attribute Directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义属性指令
- en: Understand how change detection works in Angular
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular中的变更检测工作原理
- en: Angular Directives
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular指令
- en: Directives allows us to extend the behavior of the elements. We can manipulate
    the **Document Object Model** (**DOM**) of a HTML page using the different types
    of directive definitions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指令允许我们扩展元素的行为。我们可以使用不同类型的指令定义来操纵HTML页面的**文档对象模型**（**DOM**）。
- en: Angular uses the `@Directive` metadata to tell the application about the type
    of directives they have and the functional capabilities defined with each directive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用`@Directive`元数据来告诉应用程序它们具有的指令类型以及每个指令定义的功能能力。
- en: 'The following diagram shows the different types of directives:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了不同类型的指令：
- en: '![](assets/b5831068-99f7-4172-bdfb-823dd2570215.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5831068-99f7-4172-bdfb-823dd2570215.png)'
- en: 'There are mainly three types of Angular Directives:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三种类型的Angular指令：
- en: '**Component Directives**: We can define these as user-defined directives, similar
    to custom directives in Angular 1.x'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件指令**：我们可以将其定义为用户定义的指令，类似于Angular 1.x中的自定义指令'
- en: '**Structural Directives**: Directives that alter or transform the DOM elements
    (one or more) on the fly'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构指令**：在运行时改变或转换DOM元素（一个或多个）的指令'
- en: '**Attribute Directives**: Directives that extend the behavior or look and feel
    of an element'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性指令**：扩展元素的行为或外观'
- en: In Angular 1.x, we had the A (Attribute), E (Element), C (Class), M (Matches
    comment) directives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 1.x中，我们有A（属性）、E（元素）、C（类）、M（匹配注释）指令。
- en: Angular comes with a lot of built-in directives, which we will be categorized
    in the preceding mentioned categories.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Angular带有许多内置指令，我们将在前面提到的类别中对其进行分类。
- en: Angular uses directives that use `ng`, hence avoid using `ng` along with custom-defined
    directives; it may lead to unknown issues. For example, `ng-changeColor` is an
    instance of bad styling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用使用`ng`的指令，因此避免在自定义指令中使用`ng`；这可能会导致未知问题。例如，`ng-changeColor`是一个不好的样式实例。
- en: Component Directives
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件指令
- en: Component Directives are user-defined directives to extend the functionality
    and create small reusable functionalities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 组件指令是用户定义的指令，用于扩展功能并创建小型可重用功能。
- en: Think of Component Directives as directives that have a template attached to
    them since Components Directives have their own view or template defined with
    them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件指令视为附加了模板的指令，因为组件指令具有自己的视图或模板定义。
- en: In previous chapters, we have created many components. If you have mastered
    the art of creating components and using them in our layouts, you will already
    know how to create Component Directives.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们创建了许多组件。如果您已经掌握了创建组件并在布局中使用它们的艺术，您将已经知道如何创建组件指令。
- en: 'A quick recap on Angular components: components are small reusable pieces of
    code that we can use in throughout our applications.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Angular组件的快速回顾：组件是可以在整个应用程序中重复使用的小型代码片段。
- en: 'In the following code snippet, we will see the basic syntax of the component.
    Create a file named `my-template.component.ts`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将看到组件的基本语法。创建一个名为`my-template.component.ts`的文件：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Import the newly created component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导入新创建的组件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, call the Component Directive in our `index.html` file*:*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`index.html`文件中调用组件指令*：*
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the simplest and easiest component example you will have seen;
    it''s as simple as this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将看到的最简单和最简单的组件示例；就是这么简单：
- en: '![](assets/31ded739-70f8-4344-b7f2-e25a87f9d902.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/31ded739-70f8-4344-b7f2-e25a87f9d902.png)'
- en: So, whatever components we have created so far are all Component Directives.
    If you want to deep dive into learning more and creating components, refer to
    [Chapter 4](ffd90f48-2aef-462a-9d96-35e182ce3db9.xhtml), Working with Components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止我们创建的所有组件都是组件指令。如果您想深入学习更多并创建组件，请参考[第4章](ffd90f48-2aef-462a-9d96-35e182ce3db9.xhtml)，使用组件。
- en: Structural Directives
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令
- en: As the name mentions, Structural Directives alter the DOM structure by adding,
    appending, or removing DOM elements on the fly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，结构指令通过在运行时添加、附加或删除DOM元素来改变DOM结构。
- en: Angular Structural Directives are displayed with an (`*`) asterisk symbol before
    the directive name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Angular结构指令在指令名称之前显示为（*）星号符号。
- en: 'Some of the commonly used Structural Directives are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的结构指令如下：
- en: '`ngFor`: Repeater directive generally used to loop through and display a list
    of elements.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`：重复器指令通常用于循环并显示元素列表。'
- en: '`ngIf`: Shows or hides DOM elements depending on the result of expression evaluation;
    the result is either true or false.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngIf`：根据表达式评估的结果显示或隐藏DOM元素；结果要么是true，要么是false。'
- en: '`ngSwitch`: Returns if the match expression value matches the value of the
    switch expression. The result returned can be any value; a conditional check is
    done for matching values.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`：如果匹配表达式的值与开关表达式的值匹配，则返回。返回的结果可以是任何值；匹配值进行条件检查。'
- en: Only one Structural Directive is allowed per element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素只允许一个结构指令。
- en: 'Let''s learn about each of these Structural Directives in detail and create
    few examples using them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每个结构指令，并使用它们创建一些示例：
- en: ngFor directive
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngFor指令
- en: The `ngFor` directive will help us iterate the items and append them to the
    list on the fly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令将帮助我们迭代项目并在运行时将它们附加到列表中。'
- en: We need to declare an array in the `StructureDirectiveComponent` class, and
    then use `ngFor` to loop the values and display them in the template.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`StructureDirectiveComponent`类中声明一个数组，然后使用`ngFor`来循环这些值并在模板中显示它们。
- en: The list `<li>` elements get appended on the fly to the `<ul>` element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`<li>`元素会在运行时附加到`<ul>`元素上。
- en: 'The following is the component snippet for the `ngFor` directive usage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ngFor`指令用法的组件片段：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding component is shown as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述组件的输出如下所示：
- en: '![](assets/5aaf455e-5a7e-4fd1-bf51-2cb0ddbe07dd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5aaf455e-5a7e-4fd1-bf51-2cb0ddbe07dd.png)'
- en: ngIf directive
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngIf指令
- en: The `ngIf` directive help us to evaluate the expression based on a condition
    very similar to the `if` statements in any programming language.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf`指令帮助我们根据条件评估表达式，非常类似于任何编程语言中的`if`语句。'
- en: 'The general syntax is shown in the following code snippet :'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语法如下代码片段所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet has a `*ngIf` condition; if `isLoggedIn` is `true`,
    the directive will render the statement inside; otherwise, it will skip and continue.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段有一个`*ngIf`条件；如果`isLoggedIn`为`true`，指令将渲染内部的语句；否则，它将跳过并继续。
- en: 'Let''s create an example using both the `*ngFor` and `*ngIf` statements as
    shown in the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例，同时使用`*ngFor`和`*ngIf`语句，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We used `*ngFor` and `*ngIf` in the `view` template.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`view`模板中使用了`*ngFor`和`*ngIf`。
- en: In the component class, we define a `isLoggedIn` variable with Boolean values.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件类中，我们使用布尔值定义了一个`isLoggedIn`变量。
- en: We create an array of teams having team names in the list, which we will iterate
    and display in the view.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个团队名称列表的数组，我们将迭代并在视图中显示。
- en: 'Run the app, and we should see output as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们应该看到如下截图所示的输出：
- en: '![](assets/89017779-cdb5-4ff2-884a-f4f9018faedb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89017779-cdb5-4ff2-884a-f4f9018faedb.png)'
- en: ngSwitch directive
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngSwitch指令
- en: 'When we have to evaluate the expression based on multiple values, we make use
    of `ngSwitch`. An example of `ngSwitch` is shown in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要根据多个值来评估表达式时，我们使用`ngSwitch`。`ngSwitch`的示例如下代码片段所示：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Based on the value of `taxRate`, our application will decide which element to
    display. Let's update our example and add an `*ngSwitch` statement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`taxRate`的值，我们的应用程序将决定显示哪个元素。让我们更新我们的示例并添加一个`*ngSwitch`语句。
- en: 'The updated example code is given as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的示例代码如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding code example is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码示例的输出如下：
- en: '![](assets/d2dafbae-53df-4af5-84a7-ec492220de4e.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2dafbae-53df-4af5-84a7-ec492220de4e.png)'
- en: Attribute Directives
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性指令
- en: Attribute Directives extend the behavior or the look and feel of a given element.
    Attribute Directives are very similar to HTML attributes defined along with the
    element.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令扩展了给定元素的行为或外观。属性指令与HTML属性非常相似，与元素一起定义。
- en: 'Attribute Directives can be of two types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令可以分为两种类型：
- en: Built-in Attribute Directive
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置属性指令
- en: Custom or user-defined Attributes Directive
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义或用户定义的属性指令
- en: Let's now look at them in detail in the following sections.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在以下章节中详细查看它们。
- en: Built-in Attribute Directives
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置属性指令
- en: As mentioned before, attributes are properties of the elements in the page.
    Some of the examples of the attributes for HTML elements are class, style, and
    so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，属性是页面中元素的属性。HTML元素的属性示例包括class、style等。
- en: Similarly Angular provides several built-in Attribute Directives. The directives
    include `ngModel`, `ngClass`, `ngStyle`, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Angular提供了几个内置的属性指令。这些指令包括`ngModel`、`ngClass`、`ngStyle`等等。
- en: 'Let''s learn about each of these Attribute Directives by creating few examples
    that are shown as follows for your reference:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一些示例来了解每个属性指令，如下所示：
- en: '`ngModel`: Using `ngModel`, we can implement a Two-way Data Binding. For learning
    more about Data Binding and Template Syntax, please refer to [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`：使用`ngModel`，我们可以实现双向数据绑定。要了解更多关于数据绑定和模板语法的内容，请参考[第8章](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml)，*模板和数据绑定语法*。'
- en: The `ngModel` directive is written inside a square with the parentheses of event
    binding `[()]`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`指令写在带有事件绑定`[()]`的括号内。'
- en: Remember to import the forms Module from Angular forms or else you will get
    error messages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从Angular表单中导入表单模块，否则你会收到错误消息。
- en: 'An example of the `ngModel` Attribute Directive is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`属性指令的一个示例如下：'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`ngClass`: When we want to add or remove any CSS class to a DOM element, it''s
    preferred that we use the `ngClass` Attribute Directive. We can assign class names
    in different ways to `ngClass`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngClass`：当我们想要向DOM元素添加或移除任何CSS类时，最好使用`ngClass`属性指令。我们可以以不同的方式为`ngClass`分配类名。'
- en: We can assign class names using a `string`, or an `object` or a component `method`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`string`、`object`或组件`method`来分配类名
- en: 'An example of the `ngClass` Attribute Directive is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`属性指令的一个示例如下：'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember to wrap the name of CSS class in a single quote; otherwise, you won't
    see the styling.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将CSS类名用单引号括起来；否则，你将看不到样式。
- en: Remember to include the style sheet either in `index.html` or in your respective
    component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`index.html`或你的相应组件中包含样式表。
- en: '`ngStyle`: When we want to manipulate a few style properties of any DOM element,
    we can use `ngStyle`. You can relate this to inline styling in the CSS world.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngStyle`：当我们想要操纵任何DOM元素的一些样式属性时，我们可以使用`ngStyle`。你可以将其与CSS世界中的内联样式相关联。'
- en: 'An example of an `ngStyle` Attribute Directive is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`属性指令的一个示例如下：'
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alright, now that we learned about our built-in Attribute Directives, let's
    put them all together in an example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经了解了内置属性指令，让我们在一个示例中将它们全部放在一起。
- en: 'The following is a code example using `ngModel`, `ngClass`, and `ngStyle`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`ngModel`、`ngClass`和`ngStyle`的代码示例：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Take a look at the following screenshot with the output of the preceding code
    example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图，显示了前面代码示例的输出：
- en: '![](assets/ac668668-085d-4228-930b-d3c696a4a2ff.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ac668668-085d-4228-930b-d3c696a4a2ff.png)'
- en: Creating custom directives - Structural and Attribute Directives
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义指令-结构和属性指令
- en: So far in previous sections, we have learned about and implemented built-in
    directives provided by Angular.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在之前的章节中，我们已经学习并实现了Angular提供的内置指令。
- en: By creating custom user-defined directives, Angular allows us to define and
    extend the behavior and functionality of the elements in the page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建自定义用户定义的指令，Angular允许我们定义和扩展页面中元素的行为和功能。
- en: To create custom directives, we have to use the `@Directive` decorator and implement
    the logic in the class definition.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义指令，我们必须使用`@Directive`装饰器并在类定义中实现逻辑。
- en: We can create custom Component, Structural, and Attribute Directives.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自定义组件、结构和属性指令。
- en: Any user-defined HTML tag is a component attribute (for example, `<my-app>`).
    We have been creating custom components all along, throughout each chapter of
    the book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户定义的HTML标记都是组件属性（例如，`<my-app>`）。在本书的每一章中，我们一直在创建自定义组件。
- en: Angular CLI - generating the directives
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI-生成指令
- en: We will use the Angular CLI tool to generate directives for our examples.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Angular CLI工具为我们的示例生成指令。
- en: 'Navigate to the project directory and run the following `ng` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到项目目录并运行以下`ng`命令：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should see the output as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下屏幕截图中显示的输出：
- en: '![](assets/e9f368e1-a5ad-4770-a4bf-252859cb8b9a.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9f368e1-a5ad-4770-a4bf-252859cb8b9a.png)'
- en: As you can see in the preceding screenshot, the newly generated directive `highlightDirective`
    is created and the `app.module.ts` file is updated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的屏幕截图中看到的，新生成的指令`highlightDirective`已经创建，并且`app.module.ts`文件已经更新。
- en: 'Before we go ahead with implementing our directives, here''s a quick recap
    of the Structural and Attribute Directives:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实现我们的指令之前，让我们快速回顾一下结构和属性指令：
- en: '**Structural Directive**: As the name suggests, the structural attribute affects
    the structure of the HTML layout since it shapes or reshapes the DOM structure.
    It can affect one or more elements in the page.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构指令：顾名思义，结构属性影响HTML布局的结构，因为它塑造或重塑了DOM结构。它可以影响页面中的一个或多个元素。
- en: '**Attribute Directive**: Defines and extends the appearance or behavior of
    an element in the page.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令：定义并扩展页面中元素的外观或行为。
- en: We learned to generate custom directives using Angular CLI and now we clearly
    know what and how Structural and Attribute Directives work.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了使用Angular CLI生成自定义指令，现在我们清楚地知道结构指令和属性指令是如何工作的。
- en: It's time to create our own custom directives. Read on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们自己的自定义指令了。继续阅读。
- en: Creating custom Attribute Directives
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义属性指令
- en: We will start by creating custom Attribute Directives. We will continue with
    the example `highlightDirective` we created in the preceding section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建自定义属性指令开始。我们将继续使用前一节中创建的示例`highlightDirective`。
- en: As the name suggests, we will use this directive to highlight the changed text
    color of elements attached to this attribute.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，我们将使用这个指令来突出显示附加到这个属性的元素的更改文本颜色。
- en: It's time to define the functionality and behavior of our directive, `highlightDirective`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候定义我们的指令`highlightDirective`的功能和行为了。
- en: 'In the `highlight-directive.ts` file, add the following lines of the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`highlight-directive.ts`文件中，添加以下代码行：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s analyze the preceding code snippet in detail:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码片段：
- en: We need to import the required utilities provided by Angular for working with
    directives.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入Angular提供的必要工具来处理指令。
- en: We will import `Directive`, `ElementRef`, and `AfterViewInit` from `@angular/core`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`@angular/core`中导入`Directive`，`ElementRef`和`AfterViewInit`。
- en: As mentioned earlier, we define a directive using the `@Directive` decorator
    and passing the name `appHighlightDirective` in the metadata selector.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们使用`@Directive`装饰器定义指令，并在元数据选择器中传递名称`appHighlightDirective`。
- en: We are exporting the `appHighlightDirective` class.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在导出`appHighlightDirective`类。
- en: As mentioned earlier, the Attribute Directive is specific to an element and
    hence we need to create an instance of the `ElementRef` variable, `elRef`, which
    we will use to target and update the element attached to our custom directive.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，属性指令特定于一个元素，因此我们需要创建`ElementRef`变量`elRef`的实例，我们将使用它来定位和更新附加到我们自定义指令的元素。
- en: In the `constructor` we are targeting the specific element by using the `nativeElement`
    method and updating the `style` property `color` with a value, `orange`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`constructor`中，我们使用`nativeElement`方法来定位特定的元素，并使用一个值`orange`更新`style`属性`color`。
- en: 'Now that we have created our directive, we need to apply it to the element
    in the app component template `app.component.html` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的指令，我们需要将其应用到应用程序组件模板`app.component.html`文件中的元素上：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now run the application and we should see the output as shown in the following
    screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，我们应该看到如下截图所示的输出：
- en: '![](assets/f4e1909f-6687-4223-84f4-05c8e09a3c6e.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4e1909f-6687-4223-84f4-05c8e09a3c6e.png)'
- en: See how easy and simple it is to create a custom Attribute Directive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看看创建自定义属性指令是多么简单和容易。
- en: If you notice carefully, it's a very basic attribute which changes the color
    of the text. Now what if we want to pass the value of the color dynamically instead
    of a statically?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，它是一个非常基本的属性，可以改变文本的颜色。现在，如果我们想要动态地传递颜色的值而不是静态地传递呢？
- en: We have to enable our attribute to pass values as well. Let's see what changes
    we need to make our directive a more suitable candidate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使我们的属性能够传递值。让我们看看我们需要对我们的指令进行哪些更改，使其成为更合适的候选者。
- en: 'Let''s first edit in our component `app.component.html` template where we want
    to use the attribute:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在我们的组件`app.component.html`模板中进行编辑，我们想要使用该属性的地方：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will see, we are now passing a value `green` through the `highlightColor`
    variable for our attribute `appHighlightDirective`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到，我们现在通过`highlightColor`变量为我们的属性`appHighlightDirective`传递了一个值`green`。
- en: 'Now update our `highlight-directive.ts` file and add the following lines of
    code to it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新我们的`highlight-directive.ts`文件，并向其中添加以下代码行：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see the changes we have done in the `highlight-directive.ts` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在`highlight-directive.ts`文件中所做的更改：
- en: We have additionally imported `Input` and `AfterViewInit` modules from the `@angular/core`
    library.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还从`@angular/core`库中导入了`Input`和`AfterViewInit`模块。
- en: We are using the `@Input` decorator to tell Angular that we want the value to
    be passed dynamically through the variable defined as `highlightColor`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`@Input`装饰器告诉Angular我们希望通过定义为`highlightColor`的变量动态传递值。
- en: In the `ngAfterViewInit` method we are creating an object instance of the element
    using the `ElementRef` instance, `elRef`, and using the `nativeElement` method
    to update the `style` property `color` of the element.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngAfterViewInit`方法中，我们使用`ElementRef`实例`elRef`创建了元素的对象实例，并使用`nativeElement`方法来更新元素的`style`属性`color`。
- en: The `color` of the text changes to the value passed through the element's `appHighlightDirective`
    attribute's value passed through `highlightColor`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本的`color`将更改为通过元素的`appHighlightDirective`属性的值传递的`highlightColor`。
- en: 'Run the application and we should see the output as shown in the following
    screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们应该看到以下截图中显示的输出：
- en: '![](assets/97851e61-16e0-47c9-b1ec-71eb2c6234a6.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/97851e61-16e0-47c9-b1ec-71eb2c6234a6.png)'
- en: Alright, so far so good. Our attribute is rather shaping up really well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止还不错。我们的属性正在变得非常完善。
- en: 'Let''s see the progress you have made so far in implementing our custom directive:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您在实现我们的自定义指令方面取得的进展：
- en: We have created a custom Attribute Directive, `highlightDirective`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义属性指令`highlightDirective`。
- en: We learned to pass values to the custom Attribute Directive using the `highlightColor`
    variable
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了使用`highlightColor`变量将值传递给自定义属性指令
- en: This is good stuff. But what if we want to bind `Javascript` events such as
    `mouseover`, `mouseout`, `click`, or so on, to our attribute?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很好的东西。但是，如果我们想要将`Javascript`事件（如`mouseover`，`mouseout`，`click`等）绑定到我们的属性呢？
- en: Let's make the necessary changes needed to implement events attached to our
    attribute. For this we will need a beautiful image and we will attach a few events
    along with custom Attribute Directive.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行必要的更改，以实现与我们的属性附加的事件。为此，我们将需要一张漂亮的图片，并将附加一些事件以及自定义属性指令。
- en: 'Let''s add an image to the component `app.component.html` file template:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在组件`app.component.html`文件模板中添加一张图片：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Important notes on the preceding code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码片段的重要说明：
- en: We have added our custom attribute component, `appHighlightDirective`, to the
    element.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已将我们的自定义属性组件`appHighlightDirective`添加到元素中。
- en: Additionally, we have added two attributes, `showOpacity` and `hideOpacity`,
    which will have the style property of opacity to the element.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们添加了两个属性，`showOpacity`和`hideOpacity`，它们将具有元素的不透明度样式属性。
- en: We will attach `onmouseover` and `onmouseout` events to these attributes and
    will change the opacity of the image dynamically.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为这些属性附加`onmouseover`和`onmouseout`事件，并动态更改图像的不透明度。
- en: 'Now that we have added an image to the component view template, the updated
    output looks like the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将图像添加到组件视图模板中，更新后的输出如下截图所示：
- en: '![](assets/f5b79ad5-80cd-4d95-9af4-e71d7c152651.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f5b79ad5-80cd-4d95-9af4-e71d7c152651.png)'
- en: 'Let''s move over to the custom directive `highlight-directive.directive.ts`
    file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到自定义指令`highlight-directive.directive.ts`文件：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze the updates we have done to the file in the preceding code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析我们在前面的代码中所做的更新：
- en: We are importing the required modules `Directive`, `ElementRef`, `Input`, `HostListener`,
    and `AfterViewInit` from `@angular/core`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`@angular/core`中导入了所需的模块`Directive`、`ElementRef`、`Input`、`HostListener`和`AfterViewInit`。
- en: Note that for binding and implementing events to elements, we especially need
    to import `HostListener`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，为了将事件绑定和实现到元素上，我们特别需要导入`HostListener`。
- en: Using the `@HostListener` decorator, we are binding the `mouseover` and `mouseout`
    events to the element we are attaching the custom attribute.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`@HostListener`装饰器，我们将`mouseover`和`mouseout`事件绑定到我们附加自定义属性的元素上。
- en: Note that when we use `this.elRef.nativeElement`, we are referring to the element
    which has the custom attribute attached to it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，当我们使用`this.elRef.nativeElement`时，我们是在引用附加了自定义属性的元素。
- en: We are assigning the value of the `this.hideOpacity` variable when the user
    takes the mouse over the element.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户将鼠标悬停在元素上时，我们为`this.hideOpacity`变量赋值。
- en: We are assigning the value of the `this.showOpacity` variable when the user
    takes the mouse out of the element.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户将鼠标移出元素时，我们为`this.showOpacity`变量赋值。
- en: 'Now run the application and you should see the output as shown in the following
    screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，您应该看到以下截图中显示的输出：
- en: '![](assets/32301da1-f670-419a-8c74-abf66825e318.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32301da1-f670-419a-8c74-abf66825e318.png)'
- en: 'Awesome. Now let''s see the progress you have made so far in implementing our
    custom directive:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。现在让我们看看您在实现我们的自定义指令方面取得的进展：
- en: We have created a custom Attribute Directive, `highlightDirective`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经创建了一个自定义属性指令`highlightDirective`
- en: We learned to pass values to the custom Attribute Directive using the `highlightColor`
    variable
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了使用`highlightColor`变量向自定义属性指令传递值
- en: We have learned to attach events such `mouseover` and `mouseout` to our custom
    attribute, `highlightDirective`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了将诸如`mouseover`和`mouseout`这样的事件附加到我们的自定义属性`highlightDirective`上。
- en: In this section, you have learned to create and use a custom Attribute Directive
    having attributes and methods attached to the directive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学会了创建和使用具有属性和方法的自定义属性指令。
- en: In next section, you will learn to create custom Structural Directives.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习创建自定义结构型指令。
- en: Creating custom Structural Directives
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义结构型指令
- en: So far you have learned and implemented built-in directives--Component, Structural,
    and Attribute Directives.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习并实现了内置指令--组件、结构型和属性指令。
- en: We also learned to generate custom directives using Angular CLI in the section
    *Angular CLI - generating the directives*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了在*Angular CLI - 生成指令*部分使用Angular CLI生成自定义指令。
- en: In previous section, we learned and implemented custom Attribute Directives.
    In this section, we will learn to create Structural Directives.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习并实现了自定义属性指令。在本节中，我们将学习创建结构型指令。
- en: 'Let''s create a new directive using Angular CLI:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI创建一个新的指令：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the output of the preceding command as shown in the following
    screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到前面命令的输出，如下截图所示：
- en: '![](assets/486c19c6-3e4f-4d92-b6c2-63183bf002a6.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/486c19c6-3e4f-4d92-b6c2-63183bf002a6.png)'
- en: Run the preceding `ng` command and we should see the directive created and the
    `app.module.ts` is updated with the newly created directive.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的`ng`命令，我们应该看到指令已创建，并且`app.module.ts`已更新为新创建的指令。
- en: 'Alright, time to create and implement our custom Structural Directive. Here''s
    the use case we will build using our custom Structural Directive:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候创建和实现我们的自定义结构型指令了。以下是我们将使用自定义结构型指令构建的用例：
- en: We will use our Structural Directive to loop through a list of products.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们的结构指令来循环遍历产品列表。
- en: The directive should display elements only which have `isAvailable` set to `true`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该指令应该只显示`isAvailable`设置为`true`的元素。
- en: 'First let''s define our products JSON in the `app.component.ts` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们在`app.component.ts`文件中定义我们的产品JSON：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We just created a JSON list of products with the keys `productName` and `isAvailable`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个产品的JSON列表，其中包含`productName`和`isAvailable`两个键。
- en: Nothing super-heroic, not just yet!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还没有超级英雄般的事情，还不是时候！
- en: 'It''s time to use the `*ngFor` loop and display the list of products in `app.component.html`
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用`*ngFor`循环并在`app.component.html`文件中显示产品列表了：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's quickly analyze the preceding code
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速分析前面的代码
- en: We are using a built-in Structural Directive, `*ngFor`, for looping through
    the product list and displaying the name using the key `product.productName`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用内置的结构指令`*ngFor`来循环遍历产品列表，并使用键`product.productName`显示名称。
- en: We are defining our custom Structural Directive, `appCustomStructural`, and
    passing the `product` object for analysis.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在定义我们自定义的结构指令`appCustomStructural`，并传递`product`对象进行分析。
- en: Since we are passing the entire product object to our attribute, we can now
    define our custom logic in `appCustomStructural` and do transformations based
    on our application needs.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将整个产品对象传递给我们的属性，我们现在可以在`appCustomStructural`中定义我们的自定义逻辑，并根据我们的应用程序需求进行转换。
- en: 'Time for some super-heroic work in our directive `custom-structural.directive.ts`
    file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的指令`custom-structural.directive.ts`文件中进行一些超级英雄般的工作：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s analyze in detail the preceding code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码：
- en: We are importing the required modules `Directive`, `Input`, `TemplateRef`, `ViewContainerRef`,
    and `AfterViewInit` from `@angular/core`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`@angular/core`中导入所需的模块`Directive`、`Input`、`TemplateRef`、`ViewContainerRef`和`AfterViewInit`。
- en: We are defining the CSS `selector` for our custom Structural Directive, `appCustomStructural`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在为我们的自定义结构指令`appCustomStructural`定义CSS `selector`。
- en: By using the `@Input` decorator, we are explicitly telling Angular that our
    custom directive will get input through `appCustomStructural`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`@Input`装饰器，我们明确告诉Angular我们的自定义指令将通过`appCustomStructural`获得输入。
- en: In the constructor, we are injecting the instances of `TemplateRef<any>` and
    `ViewContainerRef`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们注入了`TemplateRef<any>`和`ViewContainerRef`的实例。
- en: Using `TemplateRef<any>`, we are mentioning that it's an embedded template that
    can be used to instantiate embedded views.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TemplateRef<any>`，我们指定这是一个嵌入式模板，可以用于实例化嵌入式视图。
- en: Since Structural Directives involve the shaping or reshaping of the DOM structure
    in the page, we are injecting `ViewContainerRef`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于结构指令涉及在页面中塑造或重塑DOM结构，我们正在注入`ViewContainerRef`。
- en: We are checking if the value of `product.isAvailable` is equal to `true`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在检查`product.isAvailable`的值是否等于`true`。
- en: If the value of `product.isAvailable` is true using the instance of `ViewContainerRef`--a
    container where one or more views can be attached, by using the method `createEmbeddedView`--we
    are appending the element to the view.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`product.isAvailable`的值为true，则使用`ViewContainerRef`的实例--一个可以附加一个或多个视图的容器，通过使用`createEmbeddedView`方法--我们将元素附加到视图中。
- en: 'Run the application and we should see the output as shown in the following
    screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，我们应该看到如下截图所示的输出：
- en: '![](assets/00f90d26-7cc6-4a29-a867-5628af7de144.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00f90d26-7cc6-4a29-a867-5628af7de144.png)'
- en: We see only Shoes and Belts being displayed since only those products have the
    `isAvailable` key set to true. Try changing the values of other products too and
    see the output display.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只看到鞋子和腰带被显示，因为只有这些产品的`isAvailable`键设置为true。尝试改变其他产品的值并查看输出显示。
- en: In this section, we have learned about the custom Structural Directive. We learned
    about important utilities provided by Angular--`createEmbeddedView`, `ViewContainerRef`,
    and `TemplateRef`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了自定义结构指令。我们学习了 Angular 提供的重要工具--`createEmbeddedView`、`ViewContainerRef`
    和 `TemplateRef`。
- en: A quick summary of things we have learned and implemented so far for our custom
    directives follows.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经学习和实现了自定义指令的一些要点。
- en: We have created a custom Attribute Directive, `highlightDirective`. We learned
    to pass values to the custom Attribute Directive using the `highlightColor` variable.
    We have learned to attach events such as `mouseover` and `mouseout` to our custom
    attribute `highlightDirective`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义属性指令 `highlightDirective`。我们学会了使用 `highlightColor` 变量向自定义属性指令传递值。我们学会了将事件（如
    `mouseover` 和 `mouseout`）附加到我们的自定义属性 `highlightDirective`。
- en: We have learned to create a custom Structural Directive `appCustomStructural`.
    We have learned to use `createEmbeddedView`, `ViewContainerRef`, and `TemplateRef`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了创建一个自定义结构指令 `appCustomStructural`。我们已经学会了使用 `createEmbeddedView`、`ViewContainerRef`
    和 `TemplateRef`。
- en: In the next section, we will learn about change detection, an important aspect
    of how Angular framework works internally, and also learn to use it for our applications
    as well.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习变化检测，这是 Angular 框架内部工作的一个重要方面，我们还将学习如何在我们的应用程序中使用它。
- en: Implementing change detection in Angular
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中实现变化检测
- en: Change detection is the process of detecting any internal state changes in a
    model or component class and then reflect them back to the view, mainly by manipulating
    DOM.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 变化检测是检测模型或组件类中的任何内部状态变化，然后将其反映到视图中的过程，主要是通过操作 DOM。
- en: Change detection is one of the most important changes from Angular 1.x to 2.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 变化检测是从 Angular 1.x 到 2.x 中最重要的变化之一。
- en: 'The application state changes happen either from model to view or vice versa.
    To understand better, take a look at the following diagram:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序状态的变化发生在模型到视图或视图到模型之间。为了更好地理解，看一下下面的图表：
- en: '![](assets/5976ebb9-6ba5-40b2-9d0e-5f09c1b09a8b.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5976ebb9-6ba5-40b2-9d0e-5f09c1b09a8b.png)'
- en: 'Application state changes can happen in two ways:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序状态的变化可以以两种方式发生：
- en: From Model to View Template (DOM)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模型到视图模板（DOM）
- en: From View (DOM) to Model (Component Class)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从视图（DOM）到模型（组件类）
- en: Now that we know that state changes happen either in a model or in DOM, let's
    analyze what triggers change detection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道状态变化发生在模型或 DOM 中，让我们分析一下是什么触发了变化检测。
- en: 'Change detection is triggered by the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 变化检测是由以下触发的：
- en: JavaScript events (`click`, `mouseover`, `keyup`, and so on)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 事件（`click`、`mouseover`、`keyup` 等）
- en: '`setTimeout()` and `setInterval()`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTimeout()` 和 `setInterval()`'
- en: Asynchronous requests
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步请求
- en: Note that all the preceding three listed ways are async processes. So it's safe
    to say that in Angular, change detection happens whenever we have async methods/requests
    in place.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面列出的三种方式都是异步过程。因此可以说，在 Angular 中，每当我们有异步方法/请求时，变化检测就会发生。
- en: Before we jump into understanding more on change detection--how it works, how
    it's handled, and so on--let's quickly create an example to understand what triggers
    change detection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解变化检测的更多内容之前--它是如何工作的，如何处理的等等--让我们快速创建一个示例来理解是什么触发了变化检测。
- en: 'Take a look at the following code snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码片段：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以解释如下：
- en: We created a button with a click event calling the `toggleUser` method.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个按钮，点击事件调用了 `toggleUser` 方法。
- en: On the click event on `toggleUser`, the variable `isLoggedIn` value is set either
    to `true` or `false`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `toggleUser` 的点击事件中，变量 `isLoggedIn` 的值被设置为 `true` 或 `false`。
- en: Based on the variable, the value of `isLoggedIn` in the view is updated. If
    the value is `true`, Hello Packt Author is displayed, and if the value is false,
    `Hello Guest user` is displayed.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据变量，在视图中`isLoggedIn`的值会更新。如果值为`true`，则显示“Hello Packt Author”，如果值为false，则显示“Hello
    Guest user”。
- en: In the next section, we will learn about how Angular handles change detection
    internally and the utilities provided by Angular to help us implement better change
    detection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习Angular如何在内部处理变化检测以及Angular提供的工具来帮助我们实现更好的变化检测。
- en: Change detection - Angular and ZoneJS
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化检测 - Angular和ZoneJS
- en: 'The official site of ZoneJS describes the library as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ZoneJS的官方网站描述了该库如下：
- en: A Zone is an execution context that persists across async tasks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Zone是一个跨异步任务持续存在的执行上下文。
- en: Angular uses ZoneJS for detecting changes and then calls the listener methods
    of those events.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用ZoneJS来检测变化，然后调用这些事件的监听方法。
- en: Angular takes advantage of zones to handle all the internal state changes and
    change detection. Zones understand the context of the asynchronous actions and
    state changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Angular利用zone来处理所有内部状态变化和变化检测。Zone理解异步操作和状态变化的上下文。
- en: Angular has a built-in `ngZone`, which tracks all the completed asynchronous
    actions and notifies them with a `onTurnDone` event. Every component gets a change
    detector, which keeps track of all the bindings attached to the component in a
    tree structure.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Angular内置了`ngZone`，用于跟踪所有已完成的异步操作，并通过`onTurnDone`事件通知它们。每个组件都有一个变化检测器，它在树形结构中跟踪组件上附加的所有绑定。
- en: We don't have `$scope.apply` or `$digest` like in the previous version of Angular.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再有像在以前版本的Angular中的`$scope.apply`或`$digest`。
- en: By default, Angular change detection will always check whether the values have
    changed. Change detection is always performed the same from the top root component
    to the inner components in a tree structure.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular变化检测总是会检查值是否发生了变化。变化检测总是从根组件顶部到树形结构中的内部组件执行相同的操作。
- en: This is done for all components through change detector objects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过变化检测器对象为所有组件执行的操作。
- en: Using `ngZones`, the performance of the Angular applications has increased drastically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngZones`，Angular应用的性能大大提高了。
- en: Change detection strategy
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化检测策略
- en: By default, Angular defines a change detection strategy for every component
    in our application--which means every time there is any change in our template,
    it traverses down to the last component in a tree structure check for any changes
    and makes the necessary updates.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular为我们应用中的每个组件定义了一个变化检测策略--这意味着每当模板发生任何变化时，它会遍历到树形结构中的最后一个组件，检查是否有任何变化，并进行必要的更新。
- en: This takes a performance hit!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这会带来性能损耗！
- en: Hence, Angular provides us with options to define explicitly which change detection
    strategy we want to implement for our components.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular为我们提供了明确定义我们想要为组件实现的变化检测策略的选项。
- en: Angular provides a `ChangeDetectionStrategy` module by which we can define the
    change detection strategy we want to use.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一个`ChangeDetectionStrategy`模块，通过它我们可以定义我们想要使用的变化检测策略。
- en: 'There are two different values `ChangeDetectionStrategy` takes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeDetectionStrategy`有两个不同的值：'
- en: '`Default`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default`'
- en: '`OnPush`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnPush`'
- en: Let's analyze each of these options in detail to understand how each of these
    work.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析每个选项，以了解它们的工作原理。
- en: ChangeDetectionStrategy - Default
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChangeDetectionStrategy - 默认
- en: This is the default mechanism that Angular implements--changes are triggered
    by events and the propagation of changes goes from the view template to the model.
    Based on the logic implemented, the DOM structure is updated.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Angular实现的默认机制--变化由事件触发，变化的传播从视图模板到模型。根据实现的逻辑，DOM结构会更新。
- en: An important thing to note here is that using this strategy, every time Angular
    will traverse through all the components starting from the root component to the
    last component for checking if the properties have to be updated throughout.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，使用这种策略时，每次Angular都会遍历所有组件，从根组件到最后一个组件，以检查是否需要更新所有属性。
- en: Refer the example we created in preceding section, *Implementing change detection
    in Angular*. We are updating the properties and Angular by default uses the `ChangeDetectionStrategy`
    with the `Default` value.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们在前面部分创建的示例，*在Angular中实现变更检测*。我们正在更新属性，Angular默认使用`Default`值的`ChangeDetectionStrategy`。
- en: ChangeDetectionStrategy - OnPush
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChangeDetectionStrategy - OnPush
- en: We use `OnPush` to improve the performance of our Angular applications. We have
    to explicitly mention that we want to use the `OnPush` value for `ChangeDetectionStrategy`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`OnPush`来提高我们的Angular应用程序的性能。我们必须明确指出我们要使用`ChangeDetectionStrategy`的`OnPush`值。
- en: Changes are triggered by events and the propagation of changes goes for the
    entire object that is rendered in the `view` template and not for each property.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 更改由事件触发，更改的传播适用于在`view`模板中呈现的整个对象，而不是每个属性。
- en: When we use the `OnPush` value, we are forcing Angular to depend only on the
    inputs. We pass the objects through the `@Input` decorator and only the complete
    object and it's properties will be affected and not any individual property changed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`OnPush`值时，我们强制Angular仅依赖于输入。我们通过`@Input`装饰器传递对象，只有完整的对象及其属性会受到影响，而不会影响任何单个属性的更改。
- en: Advantages of ChangeDetectionStrategy - OnPush
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChangeDetectionStrategy - OnPush的优势
- en: In previous section you have learned about ChangeDetectionStrategy using both
    `default` and `OnPush` options.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您已经学习了使用`default`和`OnPush`选项的ChangeDetectionStrategy。
- en: 'Some of the advantages of using `OnPush` option over `default` are given:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OnPush`选项而不是`default`的一些优势包括：
- en: It helps in increasing the performance of our Angular applications.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有助于提高我们的Angular应用程序的性能。
- en: Angular doesn't have to traverse the entire component tree structure for detecting
    individual changes on properties.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular不必遍历整个组件树结构以检测属性的单个更改。
- en: Angular internally can skip the nested tree structures when inputted properties
    don't change.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入属性不发生变化时，Angular内部可以跳过嵌套的树结构。
- en: To understand it better, let's create a use case. For that first we need to
    create a new component named `change-detect` using Angular CLI `ng` command.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它，让我们创建一个用例。首先，我们需要使用Angular CLI `ng`命令创建一个名为`change-detect`的新组件。
- en: 'Once the component is created, you should see the output as shown in the following
    screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 组件创建后，您应该看到如下截图所示的输出：
- en: '![](assets/f0155047-2a5f-472b-8666-670957f012c5.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0155047-2a5f-472b-8666-670957f012c5.png)'
- en: 'Let''s create a `class` user and with properties `userName` and `userId` in
    the `user.ts` file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`user.ts`文件中创建一个`class`用户，并具有`userName`和`userId`属性：
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s edit the `Component` class we generated and add the following lines
    of code snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编辑我们生成的`Component`类，并添加以下代码片段：
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s analyze the preceding code in detail:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析前面的代码：
- en: We are importing the required modules from `Input`, `Component`, and `ChangeDetectionStrategy`
    from the `@angular/core` library.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`@angular/core`库中导入了`Input`、`Component`和`ChangeDetectionStrategy`所需的模块。
- en: We are importing the newly created `User` class into the component class.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将新创建的`User`类导入到组件类中。
- en: We are explicitly mentioning the value for `changeDetection` as `ChangeDetectionStrategy.OnPush`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们明确指定`changeDetection`的值为`ChangeDetectionStrategy.OnPush`。
- en: We are using the CSS `selector`; `app-change-detect` where we will display the
    output of the component.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用CSS的`selector` `app-change-detect`，在那里我们将显示组件的输出。
- en: Since we are telling Angular to use the `OnPush` option, we need to use `@Input`
    and pass object that is in our case `User`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们告诉Angular使用`OnPush`选项，我们需要使用`@Input`并传递在我们的情况下是`User`的对象。
- en: As per the template part, we are binding the user properties, `userName` and
    `userId`, in the `view` template.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据模板部分，我们在`view`模板中绑定了用户属性`userName`和`userId`。
- en: Great. So far we have created our component and have explicitly mentioned that
    whenever a change is detected, the entire object that is the `user` object should
    be updated and not just an individual property.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。到目前为止，我们已经创建了我们的组件，并明确指出，每当检测到变化时，应更新整个对象，即`user`对象，而不仅仅是单个属性。
- en: 'Now it''s time to create methods to test our logic. So an in the `AppComponent`
    class, add the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建方法来测试我们的逻辑了。因此，在`AppComponent`类中，添加以下代码：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For our component, we have mentioned the `selector` to be used as `app-change-detect`.
    We need to use the component inside the template `app.component.html` file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的组件，我们已经指定了要使用的`selector`为`app-change-detect`。我们需要在模板`app.component.html`文件中使用该组件。
- en: We have also mentioned that the component takes the input as `user`; hence we
    are passing the user object to the component.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了该组件将以`user`作为输入，因此我们将用户对象传递给该组件。
- en: Add the following lines of code to the `app.component.html` template file with
    the component `app-change-detect`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`app.component.html`模板文件中的`app-change-detect`组件中。
- en: '[PRE27]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alright, we are all set. Run the app and you should see the output as shown
    in the following screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，一切都准备就绪。运行应用程序，您应该看到如下屏幕截图中显示的输出：
- en: '![](assets/e9cc998d-b059-4abc-bfd5-bdeda22aca63.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9cc998d-b059-4abc-bfd5-bdeda22aca63.png)'
- en: 'The application functionality can be summarized as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序功能可以总结如下：
- en: The `app-change-detect` component is loaded into `AppComponent` template.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app-change-detect`组件加载到`AppComponent`模板中。'
- en: The default values passed for the object are displayed in the `view` template.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认值传递给对象在`view`模板中显示。
- en: 'Click on the `Change Detection: OnPush` button and we see the updated user
    loaded in the view.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '单击“Change Detection: OnPush”按钮，我们会看到更新后的用户加载到视图中。'
- en: 'When we click on `Change Detection: Default`, unlike the previous examples
    we have created, we don''t see any changes happening to the properties. It''s
    because we have explicitly mentioned that any change detection should be passed
    through objects and not properties using the `OnPush` option of `ChangeDetectionStrategy`.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当我们点击“Change Detection: Default”时，与我们之前创建的示例不同，我们不会看到任何属性发生变化。这是因为我们明确指出，任何变化检测都应通过对象而不是属性传递，使用`ChangeDetectionStrategy`的`OnPush`选项。'
- en: In this section, we have learned about change detection strategies provided
    by Angular. We have explored how we can improve the performance of our applications
    by using the `OnPush` option by forcing Angular to only check for objects passed
    as inputs and not individual properties.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了Angular提供的变化检测策略。我们已经探讨了如何通过使用`OnPush`选项来改善应用程序的性能，强制Angular仅检查作为输入传递的对象而不是单个属性。
- en: Updating properties will tell Angular to traverse through the entire application
    component tree structure and it takes a hit on performance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 更新属性将告诉Angular遍历整个应用程序组件树结构，并对性能造成影响。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about directives and also about different types
    of directives, namely Component Directives, Structural Directives, and Attribute
    Directives.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了指令，以及不同类型的指令，即组件指令、结构指令和属性指令。
- en: We implemented custom user-defined directives to understand how we can extend
    directives and use them more effectively.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了自定义用户指令，以了解如何扩展指令并更有效地使用它们。
- en: We learned briefly about ZoneJS, and how zones can help us to handle the `async`
    tasks in modern applications frameworks.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要了解了ZoneJS，以及区域如何帮助我们处理现代应用程序框架中的“异步”任务。
- en: Finally, we learned how Angular handles changes detection and how we can use
    change detection methods to improve the overall application performance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了Angular如何处理变化检测，以及如何使用变化检测方法来提高整体应用程序性能。
- en: In the next chapter, we will learn about asynchronous programming using Observables.
    In this chapter, we will learn how to take advantage of asynchronous programming
    with Angular by using Observable and Promises.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用Observables进行异步编程。在本章中，我们将学习如何利用Observable和Promises在Angular中利用异步编程。
- en: In addition, we will learn how to built a basic, yet extensible asynchronous
    JSON API for querying the Marvel Cinematic Universe.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将学习如何构建一个基本但可扩展的异步JSON API，用于查询漫威电影宇宙。
