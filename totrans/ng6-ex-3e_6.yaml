- en: Angular Directives in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Directives** are everywhere. They are the fundamental building blocks of
    Angular. Each extension to the application has resulted in us creating new **component
    directives**. These component directives have further consumed **attribute directives**
    (such as `NgClass` and `NgStyle`) and **structural directives** (such as `NgIf`
    and `NgFor`) to extend their behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: While we have built a number of component directives and a lone attribute directive,
    there are still some concepts of directive building that are worth exploring.
    This is especially true for attribute and structural directives, which we are
    yet to cover in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building directives**: We build multiple directives and learn where directives
    are useful, how they differ from components, and how directives communicate with
    each other and/or their host component. We explore all directive types, including
    *component directives*, *attribute directives*, and *structural directives*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous validation**: Angular makes it easy to validate rules that require
    server interaction and hence are async in nature. We will build our first async
    validator in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using renderer for view manipulation**: Renderer allows view manipulation
    in a platform-agnostic way. We will utilize renderer for the busy indicator directive
    and learn about its API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host binding**: Host binding allows directives to communicate with their
    *host element*. This chapter covers how to utilize such bindings for directives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directive injection**: The Angular DI framework allows directive injection
    based on where in the HTML hierarchy the directives are declared. We will cover
    multiple scenarios pertaining to such injections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with view children and content children**: Components have the capability
    to include external view templates into their own view. How to work with the injected
    content is something we will cover here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding the NgIf platform directive**: We will look under the hood
    of the `NgIf` platform directive and try to comprehend the working of *structural
    directives* such as `NgIf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View encapsulation of Angular components**: We will learn how Angular uses
    concepts derived from *web components* to support view and style encapsulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start the chapter by reiterating the basic classification of directives.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular directives integrate the HTML view with the application state. Directives
    help us manipulate views as application state changes and respond to view updates
    with little or no manual interaction with the actual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Depending upon how they affect the view, these directives are further classified
    into three types.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Component directives** or **components** are directives with an encapsulated
    view. In Angular, when we build UI widgets, we are building components. We have
    already built a lot of them, such as `WorkoutRunnerComponent`, `WorkoutAudioComponent`,
    `VideoPlayerComponent`, and many more!'
  prefs: []
  type: TYPE_NORMAL
- en: An important point to realize here is that the view is bound to the component
    implementation and it can only work with properties and events defined on the
    backing component.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Attribute directives**, on the other hand, extend an existing component or
    HTML element. Consider them as behavioral extensions to these components/elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Since directives are behavioral extensions for predefined elements, every directive
    building exercise involves manipulating the state of the components/elements on
    which these directives are applied. The `MyAudioDirective` built in Chapter 3,
    *More Angular 2 – SPA, Routing, and Data Flows in Depth*, does the same. The directive
    wraps the HTML5 *audio* element (`HTMLAudioElement`) for easy usage. Platform
    directives such as `ngStyle` and `ngClass` also function in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Structural directives**, such as attribute directives, do not define their
    own view. Instead, they work on the *view template* (HTML fragment) provided to
    them as part of their usage. More often than not, the purpose of a structural
    directive is to show/hide or clone the template view provided to it. Platform
    directives such as `NgFor`, `NgIf`, and `NgSwitch` are the prime examples in this
    category.'
  prefs: []
  type: TYPE_NORMAL
- en: I hope this quick refresher on directives is enough to get us started. We'll
    begin our pursuit by extending the workout builder validations and build an async
    validator directive.
  prefs: []
  type: TYPE_NORMAL
- en: We are starting from where we left off in Chapter 5, *Supporting Server Data
    Persistence*. The Git branch `checkpoint5.4` can serve as the base for this chapter.
    The code is also available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint5.4` (a ZIP file) from
    the GitHub location [http://bit.ly/ng6be-checkpoint-5-4](http://bit.ly/ng6be-checkpoint-5-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Also, remember to update the API key in `services/workout-service.ts` with
    your own API key.
  prefs: []
  type: TYPE_NORMAL
- en: Building a remote validator directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We ended Chapter 5, *Supporting Server Data Persistence*, with *Workout Runner* capable of
    managing workouts in the MongoDB store. Since each workout should have a unique
    name, we need to enforce the uniqueness constraint. Therefore, while creating/editing
    a workout, every time the user changes the workout name, we can query MongoDB
    to verify that the name already exists.
  prefs: []
  type: TYPE_NORMAL
- en: As is the case with any remote invocation, this check too is asynchronous, and
    hence it requires a *remote validator*. We are going to build this remote validator
    using Angular's *async validator support*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Async validators** are similar to standard custom validators, except that
    instead of returning a key-value object map or null, the return value of a validation
    check is a **promise**. This promise is eventually resolved with the validation
    state being set (if there is an error), or null otherwise (on validation success).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a validation directive that does workout name checks.
    There are two possible implementation approaches for such a directive:'
  prefs: []
  type: TYPE_NORMAL
- en: We can create a directive specifically for unique name validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a generic directive that can perform any remote validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation directives
  prefs: []
  type: TYPE_NORMAL
- en: While we are building a validation directive here, we could have built a standard
    custom validator class. The advantage of creating a directive is that it allows
    us to incorporate the directive in a template-driven form approach, where the
    directive can be embedded in the view HTML. Or, if the form has been generated
    using a model (reactive approach), we can directly use the validator class while
    creating the `Control` objects.
  prefs: []
  type: TYPE_NORMAL
- en: At first, the requirement of checking duplicate names against a data source
    (the *mLab* database) seems to be too a specific requirement and cannot be handled
    by a generic validator. But with some sensible assumptions and design choices,
    we can still implement a validator that can handle all types of remote validation,
    including workout name validation.
  prefs: []
  type: TYPE_NORMAL
- en: The plan is to create a validator that externalizes the actual validation logic.
    The directive will take the validation function as input. This implies that the
    actual validation logic is not a part of the validator, but a part of the component
    that actually needs to validate input data. The job of the directive is just to
    call the function and return the appropriate error keys based on the function's
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put this theory into practice and build our remote validation directive,
    aptly named `RemoteValidatorDirective`.
  prefs: []
  type: TYPE_NORMAL
- en: The companion code base for the following section is Git branch `checkpoint6.1`.
    You can work along with us or check out the implementation available in the aforementioned
    folder. Or if you are not using Git, download the snapshot of `checkpoint6.1`
    (a ZIP file) from GitHub location [http://bit.ly/ng2be-checkpoint6-1](http://bit.ly/ng2be-checkpoint6-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Validating workout names using async validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like custom validators, async validators inherit from the same `Validator` class
    too; but this time, instead of returning an object map, async validators return
    a `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the definition of the validator. Copy the definition of the
    validator from the GitHub ([http://bit.ly/ng6be-6-1-remote-validator-directive-ts](http://bit.ly/ng6be-6-1-remote-validator-directive-ts))
    folder and add it to the `shared` module folder. The validator definition looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Do remember to export this directive from the shared module, allowing us to
    use it in the workout builder module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are registering the validator as a directive instead of registering
    using a `FormControl` instance (generally used when building forms with a *reactive
    approach*), we need the extra provider configuration setting (added in the preceding
    `@Directive` metadata) by using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This statement registers the validator with the existing async validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strange directive selector, `` selector: `[abeRemoteValidator][ngModel]`
    ``, used in the preceding code will be covered in the next section, where we will
    build a busy indicator directive.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into the validator implementation, let's add it to the workout
    name input. This will help us correlate the behavior of the validator with its
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the workout name input (`workout.component.html`) with the validator
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Prefixing the directive selector
  prefs: []
  type: TYPE_NORMAL
- en: Always prefix your directives with an identifier (`abe` as you just saw) that
    distinguishes them from framework directives and other third-party directives.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: If the `ngModelOptions`, `updateOn` is set to `submit,` change it
    to `blur`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive implementation takes two inputs: the *validation key* through
    directive property `abeRemoveValidator,` used to set the *error key*, and the
    *validation function* (`validateFunction`), called to validate the value of the
    control. Both inputs are annotated with the `@Input` decorator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input parameter `@Input("validateFunction") validateFunction: (value: string)
    => Promise<boolean>;`, binds to a function, not a standard component property.
    We are allowed to treat the function as a property due to the nature of the underlying
    language, TypeScript (as well as JavaScript).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the async validation fires (on a change of `input`), Angular invokes the
    function, passing in the underlying `control`. As the first step, we pull the
    current input value and then invoke the `validateFunction` function with this
    input. The `validateFunction` returns a promise, which should eventually resolve
    to `true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: If the promise resolves to `true`, the validation is successful, the promise
    callback function returns `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is `false`, the validation has failed, and an error key-value map is returned.
    The *key* here is the string literal that we set when using the validator (`a2beRemoteValidator="workoutname"`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This *key* comes in handy when there are multiple validators declared on the
    input, allowing us to identify validations that have failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the workout component next add a validation message for this failure too.
    Add this label declaration after the existing validation `label` for *workout
    name*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And then wrap these two labels inside a `div`, as we do for *workout title*
    error labels.
  prefs: []
  type: TYPE_NORMAL
- en: The `hasError` function checks whether the `'workoutname'` validation key is
    present.
  prefs: []
  type: TYPE_NORMAL
- en: The last missing piece of this implementation is the actual validation function
    we assigned when applying the directive (`[validateFunction]="**validateWorkoutName**"`),
    but never implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `validateWorkoutName` function to `workout.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we explore what the preceding function does, we need to do some more
    fixes on the `WorkoutComponent` class. The `validateWorkoutName` function is dependent
    on `WorkoutService` to get a workout with a specific name. Let''s inject the service
    in the constructor and add the necessary import in the imports section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then declare variables `workoutName` and `queryParamsSub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And add this statement to `ngOnInit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement set the current workout name by watching (subscribing)
    over the observable `route.params` service. `workoutName` is used to skip workout
    name validation for an existing workout if the original workout name is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscription created previously needs to be clear to avoid memory leak,
    hence add this line to the `ngDestroy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The reason for defining the `validateWorkoutName` function as an *instance function*
    (the use of the *arrow operator*) instead of defining it as a standard function
    (which declares the function on the *prototype*) is the `'this'` scoping issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the validator function invocation inside `RemoteValidatorDirective`
    (declared using `@Input("validateFunction") validateFunction;`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the function (named `validateFunction`) is invoked, the `this` reference
    is bound to `RemoteValidatorDirective` instead of the `WorkoutComponent`. Since
    `execute` is referencing the `validateWorkoutName` function in the preceding setup,
    any access to `this` inside `validateWorkoutName` is problematic.
  prefs: []
  type: TYPE_NORMAL
- en: This causes the `if (this.workoutName === name)` statement inside `validateWorkoutName`
    to fail, as `RemoteValiatorDirective` does not have a `workoutName` instance member.
    By defining `validateWorkoutName` as an instance function, the *TypeScript* compiler
    *creates a closure* around the value of `this` when the function is defined.
  prefs: []
  type: TYPE_NORMAL
- en: With the new declaration, `this` inside `validateWorkoutName` always points
    to the `WorkoutComponent` irrespective of how the function gets invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also look at the compiled JavaScript for `WorkoutComponent` to know
    how the closure works with respect to `validateWorkoutName`. The parts of the
    generated code that interest us are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the validation function implementation, we see that it involves
    querying *mLab* for a specific workout name. The `validateWorkoutName` function
    returns `true` when a workout with the same name is not found and `false` when
    a workout with the same name is found (actually a *promise* is returned).
  prefs: []
  type: TYPE_NORMAL
- en: The `getWorkout` function on `WorkoutService` returns an *observable,* but we
    convert it into a *promise* by calling the `toPromise` function on the observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation directive can now be tested. Create a new workout and enter
    an existing workout name such as `7minworkout`. See how the validation error message
    shows up eventually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Excellent! It looks great, but there is still something missing. The user is
    not informed that we are validating the workout name. We can improve this experience.
  prefs: []
  type: TYPE_NORMAL
- en: Building a busy indicator directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the workout name is being validated remotely, we want the user to be aware
    of the activity in the background. A visual clue around the input box while the
    remote validation happens should serve the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Think carefully; there is an input box with an asynchronous validator (which
    does remote validation) and we want to adorn the input box with a visual clue
    during validation. Seems like a common pattern to solve? Indeed it is, so let's
    create another directive!
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we start the implementation, it is imperative to understand that
    we are not in it alone. The busy indicator directive requires the help of another
    directive, `NgModel`. We have already used the `NgModel` directive on `input`
    elements in Chapter 4, *Building Personal Trainer*. `NgModel` helps us track the
    input element state. The following example is taken from Chapter 4, *Building
    Personal Trainer*, and it highlights how `NgModel` helps us validate inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even the unique workout name validation done in the previous section employs
    the same technique of using `NgModel` to check the validation state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with defining the outline of the directive. Create a `busy-indicator.directive.ts`
    file using the CLI generator in the `src/app/shared` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Also, export it by adding the directive to the `exports` array in the shared
    module file `shared.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update the directive''s constructor with `NgModel` injection and import
    the `NgModel` reference from `@angular/forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This instructs Angular to inject the `NgModel` instance of the element on which
    the directive is declared. Remember that the `NgModel` directive is already present
    on `input` (`workoutname`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is enough to integrate our new directive in the workout view, so let's
    do it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout.component.html` from `workout-builder` and add the busy indicator
    directive to the workout name `input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create a new workout or open an existing one to see whether the `BusyIndicatorDirective`
    is loaded and the `NgModel` injection worked fine. This can be easily verified
    by putting a breakpoint inside the `BusyIndicatorDirective` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Angular injects the same `NgModel` instance into `BusyIndicatorDirective` that
    it created when it encountered `ngModel` on the input HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering what happens if we apply this directive on an input element
    that does not have the `ngModel` attribute, or as a matter of fact on any HTML
    element/component, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Will the injection work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course not! We can try it in the create workout view. Open `workout.component.html`
    and add the following `input` above the workout name `input`. Refresh the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular throws an exception, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to avoid this? Well, Angular's DI can rescue us here as it allows us to
    declare an optional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `input` control that you just added before proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting optional dependencies with the @Optional decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular has an `@Optional` decorator, which when applied to a constructor argument
    instructs the Angular *injector* to inject `null` if the dependency is not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the busy indicator constructor can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Problem solved? Not really; as stated previously, we require the `NgModel` directive
    for `BusyIndicatorDirective` to work. So, while we have learned something new,
    it is not very useful in the current scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding further, remember to revert the `workoutname``input` to its
    original state, with `abeBusyIndicator` applied.
  prefs: []
  type: TYPE_NORMAL
- en: '`BusyIndicatorDirective` should only be applied if there is an `NgModel` directive
    already present on the element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selector` directive is going to save our day this time. Update the `BusyIndicatorDirective`
    selector to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This selector creates the `BusyIndicatorDirective` only if the combination of
    `a2beBusyIndicator` with the `ngModel` attribute is present on the element. Problem
    solved!
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to add the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation one – using renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For `BusyIndicatorDirective` to work, it needs to know when the async validation
    on the `input` fires and when it is over. This information is only available with
    the `NgModel` directive. `NgModel` has a property, `control`, which is an instance
    of the `Control` class. It is this `Control` class that tracks the current state
    of the input, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Currently assigned validators (sync and async)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input element state, such as `pristine`, `dirty`, and `touched`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input validation state, which could be any one of `valid`, `invalid`, or
    `pending` in the case of validation being performed asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events that track when the value changes or the validation state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Control` seems to be a useful class, and it''s the `pending` state that interests
    us!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our first implement for the `BusyIndicatorDirective` class. Update
    the class with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Two new dependencies need to be added to the constructor, as we use them in
    the `ngAfterViewInit` function. Update the `BusyIndicatorDirective` constructor
    to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And also add imports for `ElementRef` and `Renderer` in `'@angular/core'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ElementRef` is a wrapper object over the underlying HTML element (`input`
    in this case). The `MyAudioDirective` directive built in Chapter 3, *More Angular
    2 – SPA, Routing, and Data Flows in Depth*, used `ElementRef` to get hold of the
    underlying `Audio` element.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Renderer` injection deserves a bit of attention. Calling `setElementStyle`
    is a dead giveaway that `Renderer` is responsible for managing the DOM. But before
    we delve more deeply into the role of `Renderer`, let's try to understand what
    the preceding code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the `control` property on the model (the `NgModel` instance)
    defines an event (an `Observable`), `statusChanges`, which we can subscribe to
    in order to know when the control validation state changes. The available validation
    states are `valid`, `invalid`, and `pending`.
  prefs: []
  type: TYPE_NORMAL
- en: The subscription checks whether the control state is `pending` or not, and accordingly
    adorns the underlying element using the `Renderer` API function, `setElementStyle`.
    We set the `border-width` and `border-color` of the input.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation is added to the `ngAfterViewInit` directive lifecycle
    hook, which is called after the view has initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it out. Open the create workout page or the existing *7 Minute Workout*.
    As soon as we leave workout name input, the `input` style changes and reverts
    once the remote validation of the workout name is complete. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before moving forward, also add the un-subscription code to the `BusyIndicatorDirective`
    to avoid a memory leak. Add this function (life  cycle hook) to `BusyIndicatorDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Always unsubscribe from observables
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to unsubscribe from any `Observable`/`EventEmitter` subscription
    done in the code to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation looks good. The `Renderer` is doing its job. But there are
    some unanswered questions.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just get hold of the underlying DOM object and use the standard DOM
    API to manipulate the input styles? Why do we need the *renderer*?
  prefs: []
  type: TYPE_NORMAL
- en: Angular renderer, the translation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary design goals of Angular 2 was to make it run across environments,
    frameworks, and devices. Angular enabled this by dividing the core framework implementation
    into an **application layer** and a **rendering layer**. The application layer
    has the API we interact with, whereas the rendering layer provides an abstraction
    that the application layer can use without worrying about how and where the actual
    view is being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'By separating the rendering layer, Angular can theoretically run in various
    setups. These include (but are not limited to):'
  prefs: []
  type: TYPE_NORMAL
- en: Browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser main thread and web worker thread, for obvious performance reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native app frameworks; efforts are underway to integrate Angular with `NativeScript`
    with `ReactNative`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing, allowing us to test the app UI outside the web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Renderer` implementation that Angular uses inside our browser is `DOMRenderer`.
    It is responsible for translating our API calls into browser DOM updates. In fact,
    we can verify the renderer type by adding a breakpoint in the `BusyIndicatorDirective`'s
    constructor and seeing the value of `renderer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this precise reason, we avoid direct manipulation of DOM elements inside
    `BusyIndicatorDirective`. You never know where the code will end up running. We
    could have easily done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Instead, we used the `Renderer` to do the same in a platform-agnostic way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `Renderer` API function, `setElementStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It takes the element on which the style has to be set, the style property to
    update, and the value to set. The `element` references the `input` element injected
    into `BusyIndicatorDirective`.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting styles
  prefs: []
  type: TYPE_NORMAL
- en: Styles set by calling `setElementStyle` can be reset by passing a `null` value
    in the third argument. Check out the `else` condition in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The `Renderer` API has a number of other methods that can be used to set attributes,
    set properties, listen to events, and even create new views. Whenever you build
    a new directive, remember to evaluate the `Renderer` API for DOM manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more detailed explanation of `Renderer` and its application is available
    as part of Angular''s design documents here: [http://bit.ly/ng2-render](http://bit.ly/ng2-render)'
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet! With Angular's awesomeness, we can improve the implementation.
    Angular allows us to do *host binding* in directive implementation, helping us
    avoid a lot of boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Host binding in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Angular realm, the component/element that a directive gets attached to
    is termed the **host element**:a container that hosts our directive/component.
    For the `BusyIndicatorDirective`, the `input` element is the *host*.
  prefs: []
  type: TYPE_NORMAL
- en: While we can use the `Renderer` to manipulate the host (and we did too), the
    Angular data binding infrastructure can reduce the code further. It provides a
    declarative way to manage directive-host interaction. Using the host binding concepts,
    we can manipulate an element's *properties* and *attributes* and subscribe to
    its *events*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand each of the host binding capabilities, and at the end, we will
    fix our `BusyIndicatorDirective` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Property binding using @HostBinding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use **host property binding** to bind a *directive property* to a *host element
    property*. Any changes to the directive property will be synced with the linked
    host property during the change detection phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to use the `@HostBinding` decorator on the directive property
    that we want to sync with. For example, consider this binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When applied to `input`, it will set the `input``readOnly` property to `true`
    when the `isbusy` directive property is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `readonly` is also an *attribute* on `input`. What we are referring
    to here is the input *property* `readOnly`.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Attribute binding** binds a directive property to a host component attribute.
    For example, consider a directive with binding like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If applied to input, it will add the `disabled` attribute on `input` when the
    `isAdmin` flag is `false`, and clear it otherwise. We follow the same attribute
    binding notation used in the HTML template here too. The attribute name is prefixed
    with string literal `attr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do something similar with *class* and *style binding* too. Consider
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sets up a class binding, and the following line creates a style binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Event binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, **event binding** is used to subscribe to the events raised by the
    host component/element. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This sets up a listener on the host event `click`. Angular will instantiate
    the preceding directive for every *button*, *div*, *span*, and *input* on the
    view and set up the host binding with the `onClick` function. The `$event` variable
    contains the event data for the event raised, and `target` refers to the element/component
    that was clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event bindings work for components too. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this directive, we track the `workoutStarted` event defined on the `WorkoutRunner`
    component. The `onWorkoutStarted` function is called when the workout starts,
    with the details of the started workout.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how these bindings work, we can improve our `BusyIndicatorDirective`
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation two - BusyIndicatorDirective with host bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have already guessed it! We will use *host property binding* instead
    of `Renderer` to set styles. Want to give it a try? Go ahead! Clear the existing
    implementation and try to set up a host binding for the `borderWidth` and `borderColor`
    style attributes without looking at the following implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the directive will look after the host binding implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have moved the `pending` state check into a directive property called `validating`
    and then used the `controlBorderWidth` and `controlBorderColor` properties for
    style binding. This is definitely more succinct than our earlier approach! Go
    test it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we tell you that this can be done without the need for a custom directive,
    don''t be surprised! This is how we do it, just by using style bindings on the
    workout name `input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We get the same effect!
  prefs: []
  type: TYPE_NORMAL
- en: No, our effort did not go to waste. We did learn about **renderer** and **host
    binding**. These concepts will come in handy while building directives that provide
    complex behavior extension instead of just setting element styles.
  prefs: []
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the Git branch `checkpoint6.1`
    for a working version of what we have done thus far. Or if you are not using Git,
    download the snapshot of `checkpoint6.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-6-1](http://bit.ly/ng6be-checkpoint-6-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic that we are going to take up is, *directive injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Directive injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go back a few pages and look at the `BusyIndicatorDirective` implementation
    that uses the *renderer,* specifically the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Angular automatically locates the `NgModel` directive created for the directive
    element and injects it into `BusyIndicatorDirective`. This is possible because
    both directives are declared on the same *host element*.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that we can influence this behavior. Directives created on
    a parent HTML tree or child tree can also be injected. The next few sections talk
    about how to inject directives across the component tree, a very handy feature
    that allows cross-directive communication for directives that have a *common lineage*
    (in a view).
  prefs: []
  type: TYPE_NORMAL
- en: We will use StackBlitz ([https://stackblitz.com/edit/angular-pzljm3](https://stackblitz.com/edit/angular-pzljm3))
    to demonstrate these concepts. SlackBlitz is an online IDE to run Angular applications!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, look at the file `app.component.ts`. It has three directives: `Relation`,`Acquaintance`,
    and `Consumer` and this view hierarchy is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the next few sections, we will describe the various ways in which we can
    inject the different `relation` and `Acquaintance` directives into the `consumer`
    directive. Check out the browser console for the injected dependencies that we
    log during the `ngAfterViewInit` life cycle hook.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting directives defined on the same element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Constructor injection by default supports injecting directives defined on the
    same element. The constructor function just needs to declare the directive type
    variable that we want to inject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `NgModel` injection that we did in `BusyIndicatorDirective` falls under
    this category. If the directive is not found on the current element, the Angular
    DI will throw an error, unless we mark the dependency as `@Optional`.
  prefs: []
  type: TYPE_NORMAL
- en: Optional dependency
  prefs: []
  type: TYPE_NORMAL
- en: The `@Optional` decorator is not limited to directive injection. It's there
    to mark any type of dependency optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the plunk example, the first injection (in `Consumer` directive implementation)
    injects the `Relation` directive with the `me` attribute (`relation="me"`) into
    the consumer directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Injecting directive dependency from the parent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prefixing a constructor argument with the `@Host` decorator instructs Angular
    to search for the dependency on the *current element*, *its parent*, or its *parents*
    until it reaches the component boundaries (a component with the directive present
    somewhere in its view hierarchy). Check the second `consumer` injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This statement injects the `Acquaintance` directive instance declared two levels
    up the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `@Option` decorator described previously, the usage of `@Host()` is
    not limited to directives too. Angular service injection also follows the same
    pattern. If a service is marked with `@Host`, the search stops at the host component.
    It does not continue further up the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Skipself` decorator can be used to skip the current element for a directive
    search.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the StackBlitz example, this injection injects the `Relation` directive
    with the `relation` attribute value `parent` (`relation="parent"`) into `consumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Injecting a child directive (or directives)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there is a need to inject directive(s) defined on nested HTML into a parent
    directive/component, there are four decorators that can help us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ViewChild`/`@ViewChildren`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ContentChild`/`@ContentChildren`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As these naming conventions suggest, there are decorators to inject a single
    child directive or multiple children directives:'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the significance of `@ViewChild/@ViewChildren` versus `@ContentChild/@ContentChildren`,
    we need to look at what view and content children are, a topic that we will take
    up soon. But for now, it's enough to understand that view children are part of
    a component's own view and content children are external HTML injected into the
    component's view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look how, in the StackBlitz example, the `ContentChildren` decorator is used
    to inject the child `Relation` directive into `Consumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, the data type of the variable `children` is not an array, but
    a custom class-`QueryList`. The `QueryList` class is not a typical array, but
    a collection that is kept up to date by Angular whenever dependencies are added
    or removed. This can happen if the DOM tree is created/destroyed when using structural
    directives such as `NgIf` or `NgFor`. We will also talk more about `QueryList`
    in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: You may have observed that the preceding injection is not a constructor injection
    as were the earlier two examples. This is for a reason. The injected directive(s)
    will not be available until the underlying component/element's content has initialized.
    For this precise reason, we have the `console.log` statements inside the `ngAfterViewInit`
    life cycle hook. We should only access the content children post this life cycle
    hook execution.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sample code injects in all three child `relation` objects into
    the `consumer` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting descendant directive(s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard `@ContentChildren` decorator (or as a matter of fact `@ViewChildren`
    too) only injects the immediate children of a directive/component and not its
    descendants. To include all its descendants, we need to provide an argument to
    `Query`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing the `descendants: true` parameter will instruct Angular to search for
    all descendants.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the console log, the preceding statement injects in all four
    descendants.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI, while it seems simple to use, packs a lot of functionality.
    It manages our services, components, and directives and provides us with the right
    stuff in the right place at the right time. Directive injection in components
    and other directives provides a mechanism for directives to communicate with each
    other. Such injections allow one directive to access the public API (public functions/properties)
    of another directive.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to explore something new. We are going to build an Ajax button
    component that allows us to inject an external view into the component, a process
    also known as **content ****transclusion**.
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ajax button component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we save/update an exercise or workout, there is always the possibility
    of duplicate submission (or duplicate `POST` requests). The current implementation
    does not provide any feedback as to when the save/update operation started and
    when it is  completed. The user of an app can knowingly or unknowingly click on
    the Save button multiple times due to the lack of visual clues.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to solve this problem by creating a specialized button—an *Ajax button*
    that gives some visual clues when clicked on and also stops duplicate Ajax submissions.
  prefs: []
  type: TYPE_NORMAL
- en: The button component will work on these lines. It takes a function as input.
    This input function (input parameter) should return a promise pertaining to the
    remote request. On clicking on the button, the button internally makes the remote
    call (using the input function), tracks the underlying promise, waits for it to
    complete, and shows some busy clues during this activity. Also, the button remains
    disabled until the remote invocation completes to avoid duplicate submission.
  prefs: []
  type: TYPE_NORMAL
- en: The companion code base for the following section is Git branch `checkpoint6.2`.
    You can work along with us, or check out the implementation available in the branch.
    Or if you are not using Git, download the snapshot of `checkpoint6.2` (a ZIP file)
    from the GitHub location [http://bit.ly/ng6be-checkpoint-6-2](http://bit.ly/ng6be-checkpoint-6-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the component outline to make things clearer. Use the following
    command to create an `ajax-button` component under the application''s shared module
    (`src/app/shared`) and **then export the component** from the `SharedModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the component definition too and import them from `@angular/core`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the following HTML template to `ajax-button.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The component (`AjaxButtonComponent`) takes two property bindings, `execute`
    and `parameter`. The `execute` property points to the function that is invoked
    on the Ajax button click. The `parameter` is the data that can be passed to this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the usage of the `busy` flag in the view. We disable the button and
    show the spinner when the `busy` flag is set. Let''s add the implementation that
    makes everything work. Add this code to the `AjaxButtonComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We set up a *host event binding* to the click event on `AjaxButtonComponent`.
    Anytime the `AjaxButtonComponent` component is clicked on, the `onClick` function
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `HostListener` import needs to be added to the `'@angular/core'` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` implementation calls the input function with a lone parameter
    as `parameter`. The result of the invocation is stored in the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition checks whether the `result` is a `Promise` object. If yes,
    the `busy` indicator is set to `true`. The button then waits for the promise to
    get resolved, using the `then` function. Irrespective of whether the promise is
    resolved with *success* or *error*, the busy flag is set to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason the busy flag is set to `null` and not `false` is due to this attribute
    binding `[attr.disabled]="busy"`. The `disabled` attribute will not be removed
    unless `busy` is `null`. Remember that in HTML, `disabled="false"` does not enable
    the button. The attribute needs to be removed before the button becomes clickable
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are confused about this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to look at how the component is used. Open `workout.component.html`
    and replace the `Save` button HTML with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `Workout.save` function binds to `execute`, and `parameter` takes the `FormControl`
    object `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the `save` function in the `Workout` class to return a promise
    for `AjaxButtonComponent` to work. Change the `save` function implementation to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `save` function now returns a *promise* that we build by calling the `toPromise`
    function on the *observable* returned from the call to `workoutBuilderService.save()`.
  prefs: []
  type: TYPE_NORMAL
- en: Make note of how we define the `save` function as an *instance function* (with
    the use of the arrow operator) to create a closure over *this*. It's something
    we did earlier while building the *remote validator directive*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to test our implementation! Refresh the application and open the create/edit
    workout view. Click on the Save button and see the Ajax button in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.gif)'
  prefs: []
  type: TYPE_IMG
- en: The preceding animation may be short-lived as we navigate back to the workout
    list page post save. We can temporarily disable the navigation to see the new
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: We started this section with the aim of highlighting how external elements/components
    can be transcluded into a component. Let's do it now!
  prefs: []
  type: TYPE_NORMAL
- en: Transcluding external components/elements into a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the very start, we need to understand what **transclusion** means. And
    the best way to understand this concept would be to look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: No component that we have built thus far has borrowed content from outside.
    Not sure what this means?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the preceding `AjaxButtonComponent` example in `workout.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: What if we change the `ajax-button` usage to the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Will the `Save Me!` text show up on the button? It will not try it!
  prefs: []
  type: TYPE_NORMAL
- en: The `AjaxButtonComponent` component already has a template, and it rejects the
    content we provide in the preceding declaration. What if we can somehow make the
    content (`Save Me!` in the preceding example) load inside the `AjaxButtonComponent`?
    This act of injecting an external view fragment into the component's view is what
    we call **transclusion**, and the framework provides the necessary constructs
    to enable transclusions.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to introduce two new concepts, *content children* and *view children*.
  prefs: []
  type: TYPE_NORMAL
- en: Content children and view children
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define it succinctly, the HTML structure that a component defines internally
    (using `template or templateUrl`) is the **view children** of the component. However, the
    HTML view provided as part of the component usage added to the host element (such
    as `<ajax-button>**Save Me!**</ajax-button>`), defines the **content children**
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Angular does not allow *content children* to be embedded as we
    saw before. The `Save Me!` text was never emitted. We need to explicitly tell
    Angular where to emit the *content children* inside the *component view template*.
    To understand this concept, let''s fix the `AjaxButtonComponent` view. Open `ajax-button.component.ts`
    and update the view template definition to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The two `ng-content` elements in the preceding view define the *content injection
    locations*, where the content children can be injected/transcluded. The `selector`
    property defines the *CSS selector* that should be used to locate the content
    children when injected into the main host.
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts to make more sense as soon as we fix the `AjaxButtonComponent` usage
    in `workout.component.html`. Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `span` with `data-animator` is injected into the `ng-content` with the `select=[data-animator]`
    property and the other `span` (with the `data-content` attribute) is injected
    into the second `ng-content` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the application again and try to save a workout. While the end result
    is the same, the resultant view is a combination of multiple view fragments: one
    part for component definition (*view children*) and another part for component
    usage (*content children*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram highlights this difference for the rendered `AjaxButtonComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `ng-content` can be declared without the `selector` attribute. In such a
    scenario, the complete content defined inside the component tag is injected.
  prefs: []
  type: TYPE_NORMAL
- en: '*Content injection* into an existing component view is a very powerful concept.
    It allows the component developer to provide extension points that the component
    consumer can readily consume and customize the behavior of the component, that
    too in a controlled manner.'
  prefs: []
  type: TYPE_NORMAL
- en: The content injections that we defined for the `AjaxButtonComponent` allow the
    consumer to change the busy indicator animation and the button content, keeping
    the behavior of the button intact.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's advantages do not end here. It has the capability to inject *content
    children* and *view children* into the *component code/implementation*. This allows
    the component to interact with its content/view children and control their behavior
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting view children using @ViewChild and @ViewChildren
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 3, *More Angular 2 – SPA, Routing, and Data Flows in Depth*, we made use
    of something similar, *view children injection*. To recall what we did, let's
    look at the relevant parts of the `WorkoutAudioComponent` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view definition looked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And the injection looked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The directive (`MyAudioDirective`) associated with the `audio` tag was injected
    into the `WorkoutAudio` implementation using the `@ViewChild` decorator. The parameters
    passed to `@ViewChild` are the *template variable* names (such as `tick`) used
    to locate the element in the view definition. The `WorkoutAudio` component then
    used these audio directives to control the audio playback for *7 Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the preceding implementation injects `MyAudioDirective`, even child components
    can be injected. For example, instead of using `MyAudioDirective`, suppose we
    build a `MyAudioComponent`, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it instead of the `audio` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The injection would still work.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if there is more than one directive/component of the same type
    defined on the component view? Use the `@ViewChildren` decorator. It allows you
    to query injections of one type. The syntax for the use of `@ViewChildren` is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This injects all the view children of type `directiveType`. For the `WorkoutAudio`
    component example stated previously, we can use the following statement to get
    hold of all `MyAudioDirective`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ViewChildren` decorator can also take a list of comma-separated selectors
    (*template variable names*) instead of type. For example, to select multiple `MyAudioDirective `instances in
    the `WorkoutAudio` component, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `QueryList` class is a special class provided by Angular. We introduced
    `QueryList` in the *Injecting descendant directive(s)* section earlier in the
    chapter. Let's explore `QueryList` further.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking injected dependencies with QueryList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For components that require multiple components/directives to be injected (using
    either `@ViewChildren` or `@ContentChildren`), the dependency injected is a `QueryList`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `QueryList` class is a *read-only **collection* of injected components/directives.
    Angular keeps this collection in sync based on the current state of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the `WorkoutAudio` directive view. It has five instances
    of `MyAudioDirective`. Hence, for the following collection, we will have five
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding example does not highlight the syncing part, Angular can
    track components/directives being added or removed from the view. This happens
    when we use content generation directives such as `ngFor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this hypothetical template for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The number of `MyAudioDirective` directives injected here equals the size of
    the `allAudios` array. During the program's execution, if elements are added to
    or removed from the `allAudios` array, the directive collection is also kept in
    sync by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: While the `QueryList` class is not an array, it can be iterated over (as it
    implements the **ES6 iterable interface**) using the `for (var item in queryListObject)`
    syntax. It also has some other useful properties, such as `length`, `first`, and
    `last`, which can come in handy. Check out the framework documentation ([http://bit.ly/ng2-querylist-class](http://bit.ly/ng2-querylist-class))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding discussion, we can conclude that `QueryList` saves the component
    developer a lot of boilerplate code that would be required if tracking had to
    be done manually.
  prefs: []
  type: TYPE_NORMAL
- en: View children access timing
  prefs: []
  type: TYPE_NORMAL
- en: View children injections are not available when the component/directive initializes.
    Angular makes sure that the view children injections are available to the component
    no later than the `ngAfterViewInit` life cycle event. Make sure you access the
    injected components/directives only when (or after) the `ngAfterViewInit` event
    has fired.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at content children injection, which is almost similar, except
    for a few minor differences.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting content children using @ContentChild and @ContentChildren
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular allows us to inject *content children* too, using a parallel set of
    attributes: `@ContentChild` to inject a specific content child and `@ContentChildren`
    to inject content children of a specific type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the usage of `AjaxButtonComponent`, its content children
    spans can be injected into `AjaxButtonComponent` implementation by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And adding template variables onto the corresponding spans in `workout.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'While the preceding injection is `ElementRef`, it could have been a component
    too. Had we defined a component for spinner, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have injected it too using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The same holds true for directives too. Any directive declared on `AjaxButtonComponent`
    can be injected into the `AjaxButtonComponent` implementation. For the preceding
    case, since the transcluded elements are standard HTML elements, we injected `ElementRef`,
    a wrapper that Angular creates for any HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: Like *view children*, Angular makes sure that the content children references
    are bound to the variables injected before the `ngAfterContentInit` life cycle
    event.
  prefs: []
  type: TYPE_NORMAL
- en: While we are on the subject of injecting dependencies, let's talk about some
    variations around *injecting services into **components*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection using viewProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are already familiar with the mechanism of DI registration in Angular, where
    we register a dependency at the global level by adding it to any module declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can do it at a component level using the `providers` property on the
    `@Component` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Just to avoid confusion, we are now talking about injecting dependencies other
    than directive/component objects. Directives/components are registered in the
    `declarations` array of a module before they can be injected using decorator hints
    such as `@Query`, `@ViewChild`, `@ViewChildren`, and a few others.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies registered at the component level are available for its *view children*
    and *content children* and their descendants.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, we hope that the distinction between *view* and *content **children*
    is crystal clear to everyone. If in doubt, refer to the *Content children and
    view children* section again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example from Chapter 4, *Building Personal Trainer*. The `WorkoutBuilderService`
    service was registered at the app level in the workout builder module (`WorkoutBuilderModule`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to inject `WorkoutBuilderService` across the app in order to build
    workouts and while running workouts. Instead, we could have registered the service
    at the `WorkoutBuilderComponent` level since it is the parent of all workout/exercise
    creation components, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This change would disallow injecting `WorkoutBuilderService` in `WorkoutRunner`
    or any component related to workout execution.
  prefs: []
  type: TYPE_NORMAL
- en: What if the `WorkoutBuilderService` service is registered at the app level as
    well as at the component level (as shown in the preceding example)? How does the
    injection happen? From our experience, we know that Angular will inject a different
    instance of the `WorkoutBuilderService` service into `WorkoutBuilderComponent`
    (and its descendants), while other parts of the application (*Workout runner*)
    will get the global dependency. Remember **hierarchical injectors**!
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not stop here. It provides some further scoping of dependencies
    using the `viewProviders` property. The `viewProviders` property, available on
    the `@Component` decorator, allows the registering of dependencies that can be
    injected only in the view children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `AjaxButtonComponent` example again, and a simple directive
    implementation called `MyDirective`, to elaborate on our discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `MyDirective` class depends upon a service, `MyService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this directive to the *button element* in the `AjaxButtonComponent`
    template, we need to register the `MyService` dependency too (assuming that `MyService`
    has not been registered globally):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `MyService` is registered with `AjaxButtonComponent`, `MyDirective` can
    be added to its content children too. Hence the `myDirective` application on *spinner
    HTML* will also work (the code in `workout.component.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'But changing the `providers` property to `viewProviders`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Will fail the `MyService` injection for the `AjaxButtonComponent`'s content
    children (the `div` in the preceding code), with a DI error in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies registered with `viewProviders` are invisible to its content children.
  prefs: []
  type: TYPE_NORMAL
- en: This dependency scoping for *the view* and *content children* may not seem useful
    at first sight, but it does have its benefits. Imagine we are building a reusable
    component that we want to package and deliver to developers for consumption. If
    the component has a service dependency that it prepackages too, we need to be
    extra cautious. If such a component allows *content injection* (content children),
    the dependent service is widely exposed if *provider-based* registration is used
    on the component. Any content children can get hold of the service dependency
    and use it, leading to undesirable consequences. By registering the dependency
    using `viewProvider`, only the component implementation and its child views have
    access to the dependency, providing the necessary layer of encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Yet again, we are amazed by the flexibility and level of customization that
    the DI framework provides. While it may be intimidating for starters, once we
    start building more and more components/directives with Angular, we will always
    find areas where these concepts make our implementation simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Let's shift our focus to the third classification of directives: *structural
    directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we will often be using structural directives, such as `NgIf` and `NgFor`,
    there is seldom a need to creating a structural directive. Think carefully. If
    we need a new view, we create a *component*. If we need to extend an existing
    element/component, we use a *directive*. Whereas the most common use of structural
    directives is to clone a piece of a view (also called a *template view*) and then,
    based on some conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Either inject/destroy these templates (`NgIf` and `NgSwitch`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or duplicate these templates (`NgFor`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any behavior implemented using structure directives will inadvertently fall
    into either of these two categories.
  prefs: []
  type: TYPE_NORMAL
- en: Given this fact, instead of building our own structural directive, let's look
    at the source code of the `NgIf` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt from the `NgIf` directive that is of interest to
    us. We have ignored the `ngIfElse` parts from the excerpt intentionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: No magic here, just a simple structural directive that checks a Boolean condition
    (`this._context.$implicit`) to create/destroy the view!
  prefs: []
  type: TYPE_NORMAL
- en: The first if condition above check, if the condition `this._context.$implicit`
    is `true.` The next condition makes sure that the view is already not rendered
    by checking the variable `_thenViewRef`. We only want to flip the view if `this._context.$implicit`
    translates from `false` to `true`. If both if's conditions are true the existing
    view is cleared (`this._viewContainer.clear()`) and the reference to the else
    view is cleared. The innermost if condition makes sure that the if's template
    reference is available. Finally, the code calls `_viewContainer.createEmbeddedView`
    to render (or re-render) the view.
  prefs: []
  type: TYPE_NORMAL
- en: It's not difficult to understand how the directive works. What needs to be detailed
    are the two new injections, `ViewContainerRef (_viewContainer)` and `TemplateRef
    (_templateRef)`.
  prefs: []
  type: TYPE_NORMAL
- en: TemplateRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TemplateRef` class (`_templateRef`) stores the reference to the template
    that the structural directive is referring to. Remember the discussion on structural
    directives from Chapter 2, *Building Our First App - 7 Minute Workout*? All structural
    directives take a template HTML that they work on. When we use a directive such
    as `NgIf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular internally translates this declaration to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is the template that structural directives work with, and `_templateRef`
    points to this template.
  prefs: []
  type: TYPE_NORMAL
- en: The other injection is `ViewContainerRef`.
  prefs: []
  type: TYPE_NORMAL
- en: ViewContainerRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ViewContainerRef` class points to the container where templates are rendered.
    This class has a number of handy methods for managing views. The two functions
    that `NgIf` implementation uses, `createEmbeddedView` and `clear`, are there to
    add and remove the template HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The `createEmbeddedView` function takes the template reference (again injected
    into the directive) and renders the view.
  prefs: []
  type: TYPE_NORMAL
- en: The `clear` function destroys the element/component already injected and clears
    the view container. Since every component and its children referenced inside the
    template (`TemplateRef`) are destroyed, all the associated bindings also cease
    to exist.
  prefs: []
  type: TYPE_NORMAL
- en: Structural directives have a very specific area of application. Still, we can
    do a lot of nifty tricks using the `TemplateRef` and `ViewContainerRef` classes.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement a structural directive that, depending on the user role, shows/hides
    the view template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example of a hypothetical structural directive, `forRoles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `forRoles` directive will not render the button if the user does not belong
    to the *admin* role. The core logic would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The directive implementation will need some sort of service that returns the
    logged-in user's details. We will leave the implementation for such a directive
    to the readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the `forRoles` directive does can also be done using `NgIf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: But the `forRoles` directive just adds to the template's readability with clear
    intentions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fun application of structural directives may involve creating a directive
    that just duplicates the template passed to it. It would be quite easy to build
    one; we just need to call `createEmbeddedView` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Another fun exercise!
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewContainerRef` class also has some other functions that allow us to
    inject *components*, get the number of embedded views, reorder the view, and so
    on and so forth. Look at the framework documentation for `ViewContainerRef` ([http://bit.ly/view-container-ref](http://bit.ly/view-container-ref))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on structural directives and it's time to start
    something new!
  prefs: []
  type: TYPE_NORMAL
- en: The components that we have built thus far derive their styles (CSS) from the
    common *bootstrap style sheet* and some custom styles defined in `app.css`. Angular
    has much more to offer in this area. A truly reusable component should be completely
    self-contained, in terms of both behavior and user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Component styling and view encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A longstanding problem with web app development is the lack of encapsulation
    when it comes to DOM element behavior and styles. We cannot segregate one part
    of the application HTML from another through any mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we have too much power at our disposal. With libraries such as jQuery
    and powerful *CSS selectors*, we can get hold of any DOM element and change its
    behavior. There is no distinction between our code and any external library code
    in terms of what it can access. Every single piece of code can manipulate any
    part of the rendered DOM. Hence, the encapsulation layer is broken. A badly written
    library can cause some nasty issues that are hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: The same holds true for CSS styling too. Any UI library implementation can override
    global styles if the library implementation wants to do so.
  prefs: []
  type: TYPE_NORMAL
- en: These are genuine challenges that any library developer faces when building
    reusable libraries. Some emerging web standards have tried to address this issue
    by coming up with concepts such as **web components**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web components**, in simple terms, are reusable user interface widgets that
    encapsulate their *state*, *style*, *user interface*, and *behavior*. Functionality
    is exposed through well-defined APIs, and the user interface parts are encapsulated
    too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *web component* concept is enabled by four standards:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this discussion, the technology standard we are interested in is **Shadow
    DOM.**
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Shadow DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Shadow DOM** is like a parallel DOM tree hosted inside a component (*an HTML
    element, **not to be confused with Angular components*), hidden away from the
    main DOM tree. No part of the application has access to this shadow DOM other
    than the component itself.'
  prefs: []
  type: TYPE_NORMAL
- en: It is the implementation of the Shadow DOM standard that allows view, style,
    and behavior encapsulation. The best way to understand Shadow DOM is to look at
    HTML5 `video` and `audio` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever wondered how this `audio` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Produces the following?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'It is the browser that generates the underlying Shadow DOM to render the audio
    player. Surprisingly, we can even look at the generated DOM! Here is how we do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the preceding HTML, create a dummy HTML page, and open it in Chrome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then open the Developer tools window (*F12*). Click on the Setting icon on the
    upper-left corner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the General settings, click on the checkbox, as highlighted in the following
    screenshot, to enable the inspection of Shadow DOM:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Refresh the page, and if we now inspect the generated `audio` HTML, the Shadow
    DOM shows up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Under `shadow-root`, there is a whole new world that the other part of the page
    and script do not have access to.
  prefs: []
  type: TYPE_NORMAL
- en: In the Shadow DOM realm, **shadow-root** (`#shadow-root` in the preceding code)
    is the root node for the generated DOM, hosted inside a **shadow host** (in this
    case the `audio` tag). When the browser renders this element/component, what gets
    rendered is the content from the *shadow root* and not the *shadow host*.
  prefs: []
  type: TYPE_NORMAL
- en: From this discussion, we can conclude that Shadow DOM is a parallel DOM created
    by the browser that encapsulates the *markup*, *style*, and *behavior* (DOM manipulation)
    of an HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'This was a gentle introduction to Shadow DOM. To learn more about how Shadow
    DOM works, we recommend this series by Rob Dodson: [http://bit.ly/shadow-dom-intro](http://bit.ly/shadow-dom-intro)'
  prefs: []
  type: TYPE_NORMAL
- en: But what has all this got to do with Angular? As it turns out, Angular components
    support some sort of view encapsulation too! This allows us to isolate styles
    for Angular components too.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM and Angular components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how Angular employs the concept of Shadow DOM, we will first have
    to learn about styling Angular components.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to styling the apps built as part of this book, we have taken
    a conservative approach. Be it *Workout Builder* or the *Workout Runner* (*7 Minute
    Workout*) app, all the components that we built derive their style from *bootstrap
    CSS* and from custom styles defined in `app.css`. No component has defined its
    own style.
  prefs: []
  type: TYPE_NORMAL
- en: While this adheres to the standard practices of web app development, sometimes
    we do need to deviate. This is especially true when we are building self-contained,
    packaged, and reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: Angular allows us to define styles specific to a component by using the `style`
    (for inline style) and `styleUrl` (external style sheet) properties on the `@Component`
    decorator. Let's play around with the `style` property and see what Angular does.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `AjaxButtonComponent` implementation as our playground for
    the next exercise. But before doing that, let''s look at the `AjaxButtonComponent`
    HTML as it stands now. The HTML tree for `AjaxButtonComponent` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s override some styles using the `styles` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding *CSS selector* sets the `background` property to `green` for
    all HTML buttons. Save the preceding style and refresh the work builder page.
    The button style has been updated. No surprises here? Not true, there are some!
    Look at the generated HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are some new attributes added to a number of HTML elements. And where
    have the recently defined styles landed? At the very top, inside the `head` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The style defined in the `head` section has an extra scope with the `_ngcontent-c1`
    attribute (the attribute name may differ in your case). This scoping allows us
    to style `AjaxButtonComponent` independently and it cannot override any global
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular does the same even if we use the `styleUrls` property. Suppose we had
    embedded the same CSS in an external CSS file and used this: `styleUrls:[''static/css/ajax-button.css'']`
    Angular would have still in-lined the styles into the `head` section, by fetching
    the CSS, parsing it, and then injecting it.'
  prefs: []
  type: TYPE_NORMAL
- en: The styles that by definition, should have affected the appearance of all the
    buttons in the application, have had no effect. Angular has scoped these styles.
  prefs: []
  type: TYPE_NORMAL
- en: This scoping makes sure that the component styles do not mess with the already
    defined style, but the reverse is not true. Global styles will still affect the
    component unless overridden in the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: This scoped style is the result of Angular trying to emulate the Shadow DOM
    paradigm. The styles defined on the component never leak into the global styles.
    All this awesomeness without any effort!
  prefs: []
  type: TYPE_NORMAL
- en: If you are building components that define their own styles and want a degree
    of isolation, use the component's `style`/`styleUrl` property instead of using
    the old-school approach of having a common CSS file for all styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can further control this behavior by using a `@Component` decorator property
    called **encapsulation**. The API documentation for this property mentions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**encapsulation:** `ViewEncapsulation` Specify how the template and the styles
    should be encapsulated. The default is `ViewEncapsulation.Emulated` if the view
    has styles, otherwise `ViewEncapsulation.None`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, as soon as we set the style on the component, the encapsulation
    effect is `Emulated`. Otherwise, it is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: If we explicitly set `encapsulation` to `ViewEncapsulation.None`, the scoping
    attributes are removed and the styles are embedded in the head section as normal
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then there is a third option, `ViewEncapsulation.Native`, in which Angular
    actually creates Shadow DOM for the components view. Set the `encapsulation` property
    on the `AjaxButtonComponent` implementation to `ViewEncapsulation.Native`, and
    now look at the rendered DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`AjaxButtonComponent` now has a shadow DOM! This also implies that the complete
    styling of the button is lost (style derived from bootstrap CSS) and the button
    needs to now define its own style.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular goes to great lengths to make sure that the components we develop can
    work independently and are reusable. Each component already has its own template
    and behavior. In addition to that, we can also encapsulate component styles, allowing
    us to create robust, standalone components.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the chapter, and it's time to wrap up the chapter
    with what we've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude this chapter, we now have a better understanding of how directives
    work and how to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by building a `RemoteValidatorDirective`, and learned
    a lot about Angular's support for *asynchronous validations*.
  prefs: []
  type: TYPE_NORMAL
- en: Next in line was `BusyIndicatorDirective`, again an excellent learning ground.
    We explored the **renderer** service, which allows component view manipulation
    in a platform-agnostic way. We also learned about **host bindings**, which let
    us bind to a host element's *events*, *attributes*, and *properties*.
  prefs: []
  type: TYPE_NORMAL
- en: Angular allows directives declared across the view lineage to be injected into
    the lineage. We dedicated a few sections to understanding this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The third directive (component) that we created was `AjaxButtonComponent`. It
    helped us understand the critical difference between *content children* and *view
    children* for a component.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched upon structural directives, where we explored the `NgIf` platform
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at Angular's capabilities in terms of view encapsulation.
    We explored the basics of Shadow DOM and learned how the framework employs the
    Shadow DOM paradigm to provide view plus style encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about testing Angular apps, a critical piece in the
    complete framework offering. The Angular framework was built with testability
    in mind. The framework constructs and the tooling support make automated testing
    in Angular easy. More about this in the next chapter....
  prefs: []
  type: TYPE_NORMAL
