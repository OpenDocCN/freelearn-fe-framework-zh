- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Reactivity with RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a web application, one of the most challenging tasks is dealing with the
    asynchronous nature of the web. An application cannot predict when events such
    as requests to the backend, changing routes, and simple user interactions will
    happen. Imperative programming in these cases is more complex and susceptible
    to errors.
  prefs: []
  type: TYPE_NORMAL
- en: The RxJS library that makes up the Angular ecosystem aims to make controlling
    asynchronous flows simpler using declarative and reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data – transformation operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another way to subscribe – the async pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting information flows – high-order operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing data consumption – filter operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose the correct operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to create better experiences for
    your users by integrating their actions with backend requests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at .
  prefs: []
  type: TYPE_NORMAL
- en: During this chapter, remember to run the backend of the application found in
    the `gym-diary-backend` folder with the `npm` `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Observables and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we’ve used observables as a way to capture the data that
    came from the backend API using the `subscribe` method, but let’s take a step
    back and ask what an observable is and why we don’t just use JavaScript promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a table to organize our explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Single** | **Multiple** |'
  prefs: []
  type: TYPE_TB
- en: '| Synchronous | Function | Iterator |'
  prefs: []
  type: TYPE_TB
- en: '| Asynchronous | Promise | Observable |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – Types of objects by requirement
  prefs: []
  type: TYPE_NORMAL
- en: When we need to perform synchronous processing and expect a return value, we
    use a function. If we need a collection of synchronous values, we use an object
    of the `Iterator` type. We use promises when we need the return value of a function,
    but its processing is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: But what can we use for asynchronous processing that does not return a value
    but a collection of values that can be distributed over time as events? The answer
    to that need is **an observable**! With this data structure, we can capture a
    series of events in time and declaratively make our application react to these
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the use of promises for HTTP requests, we can use them, but tasks
    that are verbose and complex to perform when using promises can be done using
    observables and RxJS instead. We can say that everything a promise can do, an
    observable is also capable of doing, but vice versa, this becomes complex.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, most asynchronous events are mapped and controlled by observables.
    In addition to HTTP requests, user typing, the exchange of routes by the application,
    and even the life cycle of components are controlled by observables as they are
    events that occur over time.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of these events as flows of information, and RxJS and the concept
    of observables can manipulate these flows and make our application react to them.
    The main resources for manipulating this flow are the RxJS operators, which are
    functions that receive and return data to this flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll start with the operator that will transform the stream
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Handling data – transformation operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our `DiaryComponent` application component, which renders a list of diary
    entries, we can notice that our component needs to know the details of the return
    value taken from the API, in which case the detail is returned in an attribute
    called `item`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor the service to return just what the component needs already formatted,
    abstracting the structure of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ExerciseSetsService` service, we will refactor the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the `getInitialList` and `refreshList` methods of the service, we are calling
    the `pipe` method of the `Observable` object. This method is fundamental to understanding
    RxJS since, through it, we can define which operators will act in the flow of
    information that the observable is enveloping.
  prefs: []
  type: TYPE_NORMAL
- en: The `pipe` method also returns an observable, and when the component calls the
    `subscribe` method, its result will go through all the operators and deliver the
    result. For our needs, we are using the `map` operator, which receives the data
    that the observable is processing and returns the other data that will be used
    by the `next` operator or, at the end, by the component that made the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the operator receives an object of the `ExerciseSetListAPI` type
    and we will return the item element that is contained in it to the component,
    which is of the `ExerciseSetList` type. With this change, VS Code, together with
    Angular’s Language Server (for more details on how to configure this, read [*Chapter
    1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right Way*), will
    point out errors in the `diary.resolver.ts` file. We will correct it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As the service now returns journal entries and no longer the entire structure
    of the API return, we change the type that the function returns. Note that RxJS
    uses TypeScript to improve the developer’s experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DiaryRoutingModule` module, let’s refactor the use of the resolver
    that we fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to name your project variables as clearly as possible; in this
    case, we have changed the `route` attribute to `exerciseList`. What we need to
    do to finish this task is to refactor the `DiaryComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the use of the `map` operator in the service, now, in the component, we
    only pass the list of exercises, so the component does not need to know the implementation
    and the details of the API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see another way to subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to subscribe – the async pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the versatility of RxJS in an Angular application, we will perform
    the task of adding a search for exercises in our backend to the diary entry inclusion
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the good practices of an Angular application, we will create an interface
    that will represent the exercises. From the command line of the operating system,
    we will use the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file generated by the Angular CLI, we define the structure of the API
    return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using interfaces to define the return of the API and a type to define
    a list of exercises. The next step is to create the service that will fetch this
    information, again using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the structure of the service created by the Angular CLI, we will complete
    the logic of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the service, we are using the `HttpClient` Angular service because we are
    going to query an API, and we are adding the `X-LOADING` header with `false` to
    the request because, here, we don’t want the loading screen to search for exercises.
  prefs: []
  type: TYPE_NORMAL
- en: If the component passes a filter, we will add the `get` URL. Finally, we are
    using the `map` operator that we saw in the previous section because we don’t
    want the component to worry about knowing the structure of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the service created, we can change the `NewEntryFormReactiveComponent`
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we are first injecting the service we created and creating an attribute
    to control when to show the exercises list or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `exercises$` attribute will contain the observable that the service will
    return. One detail that you may have noticed is the `$` symbol here. Using this
    postfix for variables and attributes that are observables is a community convention.
    It is not an obligation, but you will often see this symbol in code bases that
    use RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also created two methods that will be triggered when the user selects an
    exercise from the list. Let’s change the form template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `exercise` field, we are adding a list with the `ul` HTML element, and
    this list will be presented by the `showSuggestions` attribute. The focus event
    of the field will trigger this variable and clicking on the element will call
    the `selectExercise` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attention in this code will be on the following directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the `*ngFor` directive, we want to iterate over a list, but here, we don’t
    have a list but an observable. How is that possible?
  prefs: []
  type: TYPE_NORMAL
- en: This is the responsibility of the async pipe! What this pipe does in the template
    is perform a subscription in the observable, take the result of it, which is a
    list of exercises, and offer the `*ngFor` directive to the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we only got such concise code because, in the service, we are using
    the `map` operator to prepare the return of the observable for exactly what the
    component needs. Another advantage that the async pipe provides is that the framework
    controls the life cycle of the observable; that is, when the component is destroyed,
    Angular automatically triggers the `unsubscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t done this treatment so far in the book because the observable generated
    by an HTTP request is not open after the request is completed, but here we will
    use observables for other cases that may leave the flow with the observable still
    open.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to control the life cycle of the observables that we use;
    otherwise, we can generate bugs and performance degradation caused by memory leaks.
    Using the async pipe, this subscription management is done by Angular itself!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will connect different streams using RxJS and the async
    pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting information flows – high-order operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw at the beginning of the chapter, there are many uses of observables
    besides an HTTP request. In our task, we will exemplify this use. In a reactive
    form, a user typing into a field is treated as an observable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, let’s change the `NewEntryFormReactiveComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Running our application, we can see in the browser’s console that typing into
    any form field triggers an event captured by the `subscribe` method.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that we can react to user typing events, how do we connect this event
    to the search for exercise information in the API? We use an operator!
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our component, we will refactor the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We remove the subscription of the `ngOnInit` method from the component and put
    in the assignment of the `exercises$` observable. However, if we do this, TypeScript
    and Angular type validation show an error because the template is waiting for
    a list to perform the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the `switchMap` operator. We exchange the first flow of events for typing
    the form with the exercise request flow, passing the `exercise` field of the form
    model as a filter for the `exerciseService` service.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is that the `exercises$` observable continues to receive
    a list of exercises. Executing our project, we notice that we have a list with
    a typeahead search making the request as we fill in the field, as shown in the
    following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Selection of exercises](img/B19562_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Selection of exercises
  prefs: []
  type: TYPE_NORMAL
- en: The `switchMap` operator is a higher-order observable because it takes an observable
    as input and returns an observable as output. This is in contrast to the `map`
    operator, which takes an observable as input and returns a value as output.
  prefs: []
  type: TYPE_NORMAL
- en: With a command, we have our `search` field, but if we look at our browser’s
    **Network** tab, we can see that a request is triggered for every letter we type.
    We can improve our application’s data consumption without harming our user experience,
    which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing data consumption – filter operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our task of creating a typeahead type `search` field is complete, but we can
    make this functionality more efficient from the point of view of consuming HTTP
    requests. Here, in our case, if the user types just one letter, we have already
    started the search for information, but just one letter still results in a very
    open list.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be more interesting for our application to start looking for exercises
    from the third letter that the user types onward, and we can make the following
    modification for this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start using one of the most versatile features of RxJS, which is chaining
    operators for a certain action. We always need to keep in mind that the order
    of operators is very important, and the output of an operator is the input of
    the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `map` operator that we already know to extract only the `exercise`
    field from the `form` model and treat the data as if the field value is undefined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `filter` operator works similarly to the method of the same name for the
    `Array` object in JavaScript. It receives the `exercise` string and we validate
    that its length must be greater than or equal to three to go to the next operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we run the `switchMap` high-order operator to switch the form typing
    observable to the service’s HTTP request observable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also, with another operator, add a waiting time for starting the flow
    of the observable, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We added the `debounceTime` operator to create a delay time for the beginning
    of the flow, defining the time in milliseconds and with the good practice of using
    a constant to make the code clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add one last optimization to our code with a new operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `distinctUntilChanged` operator checks whether the stream’s data, here `exercise`,
    has changed from one iteration to another and triggers the next operator only
    if the value is different, saving even more unnecessary calls to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned about a few operators, but the library has over 80\. In the next
    section, we’ll learn how to navigate the library’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose the correct operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RxJS library has an extensive number of operators that can help simplify
    your code and handle corner cases of asynchrony and even performance.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to memorize all the operators and the ones we’ve seen so far
    will help you with the most common cases.
  prefs: []
  type: TYPE_NORMAL
- en: The library documentation has a **Decision Tree** page, and we’ll learn how
    to navigate that.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the site ([https://rxjs.dev/operator-decision-tree](https://rxjs.dev/operator-decision-tree))
    and, here, we will navigate to an operator that we have already studied to exemplify
    the use of this tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Operator Decision Tree](img/B19562_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Operator Decision Tree
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back to our form example. We need to fetch the exercise information
    from what the user’s typing – let’s assume that we don’t know which operator to
    choose.
  prefs: []
  type: TYPE_NORMAL
- en: We already have an observable, which is the `valueChanges` event in the Angular
    form, so on the first screen, we will choose the `I have one existing` `Observable,`
    `and` option.
  prefs: []
  type: TYPE_NORMAL
- en: The request to our API is represented by an observable, so on the next screen,
    we will choose the **I want to start a new Observable for each** **value** option.
  prefs: []
  type: TYPE_NORMAL
- en: As we want to make a new request for each letter the user types, we want to
    change one stream for another, so on the next screen, we’ll choose **and cancel
    the previous nested Observable when a new** **value arrives**.
  prefs: []
  type: TYPE_NORMAL
- en: The exercise search depends on the value that is in the Angular form, so on
    the final page, we will choose **where the nested Observable is calculated for**
    **each value**.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming the selection, the decision tree indicates that the correct operator
    for this situation is the `switchMap` operator that we are using!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we need to understand in the RxJS documentation is the marble
    graph. For this, let’s take as an example another operator that we studied in
    the chapter, the `map` operator here: https://rxjs.dev/api/index/function/map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the textual explanation, we have the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Map operator marble graph (source: https://rxjs.dev/api/index/function/map,
    MIT license)](img/B19562_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3 – Map operator marble graph (source: https://rxjs.dev/api/index/function/map,
    MIT license)'
  prefs: []
  type: TYPE_NORMAL
- en: As we learned at the beginning of this chapter, RxJS works on information flows,
    where operators have the function of handling information.
  prefs: []
  type: TYPE_NORMAL
- en: The graph that illustrates this flow uses arrows to represent the passage of
    time and marbles to represent values.
  prefs: []
  type: TYPE_NORMAL
- en: In the documentation here, then, we see that the `map` operator takes each value
    emitted and, based on a function, results in a flow with the values transformed
    by it.
  prefs: []
  type: TYPE_NORMAL
- en: These values are exchanged one by one as soon as they are issued so, in the
    graph, we can see that the positions of the marbles are same.
  prefs: []
  type: TYPE_NORMAL
- en: This understanding is fundamental to understanding other more complex operators
    in the library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the RxJS library and its basic elements, observables.
  prefs: []
  type: TYPE_NORMAL
- en: We learned what an observable is and how it differs from a promise or a function.
    With that knowledge, we refactored our project to handle data with the `map` operator,
    abstracting the implementation details of the component that will consume the
    service. We also learned about Angular’s async pipe and how it simplifies the
    management of subscription to an observable, leaving this task to the framework
    itself to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created a typeahead search field using RxJS to search for exercises
    based on the user’s typing event, using operators in order to optimize HTTP calls
    from our frontend. In the next chapter, we will explore the possibilities of the
    automated tests that we can do in our Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Architecture and Deployment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn how to build the architecture of your Angular project
    to meet the challenges and demands of your users. We will explore the best practices
    for automated testing using the libraries that the framework uses and we will
    install Cypress for end-to-end testing. We will understand the micro frontend
    architecture and how to implement it with Angular. We will use the Azure cloud
    service to perform the build and deploy our example application and finally understand
    how to update an Angular application and use features from version 17 onwards
    such as Angular Signals
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19562_10.xhtml#_idTextAnchor264)*, Design for Tests: Best Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19562_11.xhtml#_idTextAnchor285)*, Micro Frontend with Angular
    Elements*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19562_12.xhtml#_idTextAnchor311)*, Packaging Everything: Best
    Practices for Deployment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19562_13.xhtml#_idTextAnchor328)*, The Angular Renaissance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
