- en: Putting Things to the Test
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests is crucial for the maintainability of your code. It's a known
    fact that having a good range of tests, covering most of your functionality, is
    as important as the functionality itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that comes to mind when thinking about tests is probably code
    quality assurance. You test the code that you write, so this is definitely ensuring
    the quality of your code. However, there are many other important aspects of writing
    tests:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Resistance to unexpected changes**: Your tests define what your code is supposed
    to do. They test whether your code conforms to your specifications. This has several
    benefits, the most obvious of which is probably a resistance to unexpected changes
    in the future. If you modify the code in the future, you''ll be less likely to
    break your existing code, because your tests will validate whether the existing
    functionality still works as specified.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Your tests define what your code should do. At the same
    time, they display the API calls that are required to use the concerned functionality.
    This is the perfect documentation for any developer. Whenever I want to understand
    how a library really works, the tests are the first thing I look at.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoiding unnecessary code**: The practice of writing tests forces you to
    limit your code to fulfill the requirements of your specification, and nothing
    more. Any code in your application that is not reached in your automated tests
    can be considered dead code. If you stick to a merciless refactoring approach,
    you''ll remove such unused code as soon as possible.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we haven't considered testing in our book at all, and, given its importance,
    you may wonder why I am approaching this now, in the very last chapter of the
    book. In a real project, we'd definitely create tests much earlier, if not at
    first. However, I hope you understand that in this book, we postponed this rather
    important topic until the end for a reason. I really love testing, but, as we're
    mainly focused on the component architecture of Angular, placing this chapter
    at the end seemed more logical.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look into how to perform proper unit testing on your
    components. We'll focus on unit testing; automated, end-to-end testing is beyond
    the scope of this book. We'll look into how to test user interaction with components,
    but not at the level it would be done in end-to-end testing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the Jasmine testing framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing simple tests for components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Jasmine spies and observing component output properties
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Angular testing utilities, such as `inject`, `async`, `TestBed`,
    `ComponentFixture`, `DebugElement`, and more
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking components
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking existing services
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests for our `Efforts` UI component
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests for our `TaskListContainer` component
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Jasmine and Karma
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jasmine is a very simple testing framework that comes with an API; it allows
    you to write **Behavior-Driven Development** (**BDD**) style tests. BDD is an
    agile software development process for defining specifications in a written format.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个非常简单的测试框架，它附带了一个API；它允许你编写**行为驱动开发**（**BDD**）风格的测试。BDD是一种敏捷软件开发过程，用于以书面格式定义规范。
- en: 'In BDD, we define that an agile user story consists of multiple scenarios.
    These scenarios closely relate to, or even replace, the acceptance criteria of
    a story. They define requirements on a higher level, and they are mostly written
    narratives. Each scenario consists of three parts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在BDD中，我们定义敏捷用户故事由多个场景组成。这些场景与故事的可接受标准密切相关，甚至可以替代它们。它们在更高层次上定义了需求，并且主要是叙事性的。每个场景由三个部分组成：
- en: '**Given**: This part is used to describe the initial state of the scenario.
    The test code is where we perform all of the setup that is needed to execute the
    test scenario.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定**：这部分用于描述场景的初始状态。测试代码是我们执行测试场景所需的所有设置的执行地方。'
- en: '**When**: This part reflects the changes that we perform on the system being
    tested. Usually, this part consists of some API calls and actions that reflect
    the behavior of a user of the system.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**：这部分反映了我们对正在测试的系统所做的更改。通常，这部分包括一些API调用和反映系统用户行为的操作。'
- en: '**Then**: This part specifies what the system should look like after the given
    state and the changes applied in the *when* part. In our code, this is the part
    that is usually at the end of our test function, where we use assertion libraries
    to verify the state of the system.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**然后**：这部分指定了在给定状态和*当*部分应用的变化之后，系统应该看起来是什么样子。在我们的代码中，这部分通常是测试函数的末尾，我们在这里使用断言库来验证系统的状态。'
- en: 'Jasmine comes with an API that makes it very easy to write tests that are structured
    according to the BDD style. Let''s look at a very simple example of how we can
    use Jasmine to write a test for a shopping cart system:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine附带了一个API，使得根据BDD风格编写测试变得非常容易。让我们看看一个非常简单的例子，看看我们如何使用Jasmine为购物车系统编写测试：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Jasmine provides us with a `describe` function, which allows us to group certain
    scenarios on the same subject. In this example, we used the `describe` function
    to register a new test suite for tests concerning buying items in a shop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine为我们提供了一个`describe`函数，它允许我们将同一主题的某些场景分组。在这个例子中，我们使用`describe`函数为关于在商店购买物品的测试注册了一个新的测试套件。
- en: Using the `it` function, we can register individual scenarios that we'd like
    to get tested. Within the `describe` callback function, we can register as many
    scenarios as we like. It's also possible to nest `describe` calls, in order to
    further group our scenarios.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`it`函数，我们可以注册我们希望进行测试的个别场景。在`describe`回调函数内部，我们可以注册任意数量的场景。我们还可以嵌套`describe`调用，以便进一步分组我们的场景。
- en: Inside the callback function of the Jasmine `it` function, we can start writing
    our test. We can use BDD style comments to structure the code inside our test.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jasmine `it`函数的回调函数内部，我们可以开始编写我们的测试。我们可以在测试内部使用BDD风格注释来结构化代码。
- en: 'You don''t necessarily need to run Jasmine in the browser, but if you do so,
    you''ll get a nice summary report of all of the tests and their states:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定要在浏览器中运行Jasmine，但如果你这样做，你将得到所有测试及其状态的简洁总结报告：
- en: '![](img/dabfdf5e-c33c-4165-8eb2-4f787146e654.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dabfdf5e-c33c-4165-8eb2-4f787146e654.png)'
- en: Jasmine provides a nice visual report of all of your test specifications, which
    also allows you to rerun individual tests and provides you with more options
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine提供了一个很好的视觉报告，显示了所有的测试规范，还允许你重新运行单个测试，并提供更多选项
- en: 'Jasmine comes with three parts that are relevant to us:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine附带与我们相关的三个部分：
- en: '**Jasmine core**: This contains the test definition APIs, the assertion library,
    and all of the other core parts of the testing framework'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine核心**：这包含测试定义API、断言库以及测试框架的所有其他核心部分'
- en: '**Jasmine HTML**: This is the HTML reporter, which will write all test results
    to the browser document, and will even provide options to rerun individual tests'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine HTML**：这是HTML报告器，它将所有测试结果写入浏览器文档，并提供重新运行单个测试的选项'
- en: '**Jasmine boot**: This is the file that bootstraps the Jasmine framework for
    the browser and performs any setup that is needed with the HTML reporter'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine启动**：这是启动浏览器中的Jasmine框架并执行与HTML报告器相关的任何设置的文件'
- en: Karma and integration to Angular CLI
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karma和Angular CLI的集成
- en: Jasmine is the default test framework that ships with the Angular CLI tool.
    The CLI tool installs Jasmine, along with the popular test runner Karma, which
    allows you to run your tests in the browser of your choice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 是与 Angular CLI 工具一起打包的默认测试框架。CLI 工具会安装 Jasmine，以及流行的测试运行器 Karma，这允许你在你选择的浏览器中运行你的测试。
- en: By using Karma, we don't need to take care of installing and configuring Jasmine
    within our project. Karma takes care of that, and it also provides a lot of extras.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Karma，我们不需要在我们的项目中安装和配置 Jasmine。Karma 会处理这些，并且还提供很多额外功能。
- en: 'A project generated with the Angular CLI comes with two files relevant for
    running tests with Karma and Jasmine:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 生成的项目包含两个与使用 Karma 和 Jasmine 运行测试相关的文件：
- en: '`/karma.conf.js`: This file contains the configuration for the Karma test runner.
    It''s already created for running Angular tests within the browser. By default,
    it''s configured to run tests within a real Chrome browser. However, you can change
    that to a headless version of Chrome, to a different browser, or even to PhantomJS,
    which is a really fast and lightweight headless browser.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/karma.conf.js`：此文件包含 Karma 测试运行器的配置。它已经创建好了，用于在浏览器中运行 Angular 测试。默认情况下，它配置为在真实的
    Chrome 浏览器中运行测试。但是，你可以将其更改为 Chrome 的无头版本、不同的浏览器，甚至 PhantomJS，这是一个非常快速且轻量级的无头浏览器。'
- en: '`/src/test.ts`: This file is the main entry file for running your tests. It''s
    automatically generated for you when you create a new project using the CLI. This
    file contains all of the necessary preparations to run Angular tests within your
    browser using Karma. It also uses dynamic imports, in order to discover any test
    files (filenames ending with `.spec.ts`) within your project, and passes them
    to Karma for execution.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/src/test.ts`：此文件是运行你的测试的主要入口文件。当你使用 CLI 创建新项目时，它会自动为你生成。此文件包含运行 Angular 测试所需的全部准备工作，以便在你的浏览器中使用
    Karma 运行。它还使用动态导入，以发现项目中的任何测试文件（文件名以 `.spec.ts` 结尾），并将它们传递给 Karma 以执行。'
- en: The Angular CLI comes with a set of predefined commands, in order to execute
    the tests within your project. It supports running all tests once, in order to
    verify your current state. However, sometimes, it's very useful to keep your tests
    running when working on your application. This supports you in test-driven development
    approaches, where you'll want to have a constant feedback loop from your tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 带有一组预定义的命令，用于在项目中执行测试。它支持一次性运行所有测试，以验证你的当前状态。然而，有时在开发应用程序时保持测试运行是非常有用的。这支持你进行测试驱动开发方法，其中你将希望从测试中获得持续的反馈循环。
- en: 'Let''s start testing by running two different commands using the Angular CLI
    tool. Make sure that you''re within your project folder, and execute the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Angular CLI 工具运行两个不同的命令来开始测试。确保你处于你的项目文件夹中，并执行以下命令：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code will start a single test run within your project. Since
    we have not added any tests yet, you should see an output similar to this one:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在你的项目中启动单次测试运行。由于我们还没有添加任何测试，你应该看到类似于以下输出的结果：
- en: '![](img/9c84a848-64d0-440e-82f9-4d71f0358a2c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c84a848-64d0-440e-82f9-4d71f0358a2c.png)'
- en: A single execution (single run) using the Angular CLI, with no tests present
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular CLI 进行单次执行（单次运行），没有测试存在
- en: A single run of your tests is nice when you're about to pull a new release,
    or if you want to verify the quality of a certain state of your code. Within this
    chapter, we're going to add a few tests to our existing components, and it will
    be nice to see our tests evaluated when we're performing our changes. For this
    purpose, we're starting Karma using its file watch functionality. By running the
    following Angular CLI command, you can start Karma in watch mode. This will keep
    your Terminal busy with testing, similar to the `serve` command within the Angular
    CLI.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你即将发布新版本或想要验证代码的某个状态的质量时，单次运行你的测试是很有用的。在本章中，我们将向现有的组件添加一些测试，并在我们进行更改时看到测试的评估结果将非常令人满意。为此，我们开始使用
    Karma 的文件监视功能。通过运行以下 Angular CLI 命令，你可以以监视模式启动 Karma。这将使你的终端忙于测试，类似于 Angular CLI
    中的 `serve` 命令。
- en: 'Let''s start the Angular CLI in test watch mode by running the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来以测试监视模式启动 Angular CLI：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we're fully omitting the `watch` command-line parameter this
    time. By default, the Angular CLI will run Karma in watch mode when you execute
    the `test` command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们这次完全省略了 `watch` 命令行参数。默认情况下，当你执行 `test` 命令时，Angular CLI 将以监视模式运行 Karma。
- en: If you like to benefit from constant feedback when running your tests, you should
    always start two Terminal sessions, one executing the Angular CLI server (`ng
    serve`) and another one running Karma in watch mode (`ng test`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在运行测试时获得持续的反馈，您应该始终启动两个终端会话，一个执行Angular CLI服务器（`ng serve`），另一个以监视模式运行Karma（`ng
    test`）。
- en: Writing our first test
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个测试
- en: Now that we are all set with the testing setup, we can start writing our first
    test. In this section, we will create a first test for the efforts component that
    we created in [Chapter 8](43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml), *Time Will
    Tell*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了测试环境，我们可以开始编写我们的第一个测试。在本节中，我们将为我们在第8章中创建的努力组件创建第一个测试，*时间会证明一切*。
- en: As Angular components are just classes, we can already test a lot of their functionality
    by instantiating the component class and testing its methods. Tests that can be
    performed like this should always be considered first. Tests that don't involve
    the rendering logic of your components can run without Angular compiling and bootstrap
    the component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular组件只是类，我们可以通过实例化组件类并测试其方法来测试它们的大部分功能。可以通过这种方式进行的测试应该首先考虑。不涉及您组件渲染逻辑的测试可以在Angular编译和引导组件之前运行。
- en: The efforts component uses a method to add a certain amount of hours to the
    effective time worked on a task. Within the template of the efforts component,
    we're providing three buttons, to add some common amounts of hours. Let's create
    our first test for the method, `addEffectiveHours`, in our efforts component.
    For this test, we'd like to start simple and create the component class instance
    manually. This allows us to test its basic functionality without the need to start
    the Angular template compiler, change detection and other
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 努力组件使用一个方法向任务上实际工作的小时数添加一定量的小时。在努力组件的模板中，我们提供了三个按钮，用于添加一些常见的小时数。让我们为我们的努力组件中的
    `addEffectiveHours` 方法创建我们的第一个测试。为此测试，我们想从简单开始，手动创建组件类实例。这允许我们在不需要启动Angular模板编译器、变更检测和其他
- en: When creating a new component with the Angular CLI, a corresponding `spect.ts`
    file, containing some basic tests, will be created for you. However, we've always
    created new components using the flag `--spec false`, which prevents this step.
    Let's create our first spec file manually, by creating a new file on the path
    `src/app/efforts/efforts/efforts.component.spec.ts`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Angular CLI创建新组件时，将为您创建一个相应的 `spect.ts` 文件，其中包含一些基本测试。然而，我们始终使用标志 `--spec
    false` 创建新组件，这防止了这一步骤。让我们手动创建我们的第一个规范文件，通过在路径 `src/app/efforts/efforts/efforts.component.spec.ts`
    上创建一个新文件。
- en: 'Open the created file and add the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开创建的文件，并添加以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Karma loads our spec files, and it already loaded Jasmine prior to executing
    our test. We can therefore safely rely on the global `describe`, `it`, and `expect`
    functions that are exposed by Jasmine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Karma加载我们的规范文件，并在执行我们的测试之前已经加载了Jasmine。因此，我们可以安全地依赖Jasmine暴露的全局 `describe`、`it`
    和 `expect` 函数。
- en: As you can see, we don't really need to bootstrap Angular in order to test some
    of our components' functionality. Simply by testing the component class instance,
    we can already execute some of our specifications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们实际上不需要引导Angular来测试一些组件的功能。只需测试组件类实例，我们就可以执行一些我们的规范。
- en: To illustrate how we structure our test in a BDD way, we've added some comments,
    indicating the "given", "when" and "then" sections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们如何以BDD方式构建测试，我们添加了一些注释，指出了“给定”、“当”和“然后”部分。
- en: Within the given section, we create a new efforts component instance. We then
    set the efforts input property of our component to a new efforts object, containing
    an estimated and effective duration of zero. In the when section, we call the
    method `addEffectiveHours`, with a parameter of 8 hours.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定部分，我们创建一个新的努力组件实例。然后，我们将组件的努力输入属性设置为一个新的努力对象，其中包含零的估计和实际持续时间。在当部分，我们调用 `addEffectiveHours`
    方法，参数为8小时。
- en: Now, we'd like to test whether our method call is performing as we expected.
    Our efforts component is a pure UI component that does not store any of its state.
    Instead, it delegates any state changes using output properties. In the context
    of our test, the `outEffortsChange` output is triggered after a call to the method
    `addEffectiveHours`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想测试我们的方法调用是否按预期执行。我们的努力组件是一个纯UI组件，它不存储任何状态。相反，它使用输出属性委托任何状态变化。在我们的测试上下文中，`outEffortsChange`
    输出在调用 `addEffectiveHours` 方法后触发。
- en: Since event emitters present on component output properties are just observables,
    we can simply subscribe to the output in order to validate our test. We use the
    Jasmine helper function, `expect`, in order to assert whether the updated effective
    efforts property is what we expect it to be after our test.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件发射器在组件输出属性上呈现的只是可观察的，我们可以简单地订阅输出以验证我们的测试。我们使用 Jasmine 辅助函数 `expect` 来断言更新后的有效努力属性是否是我们测试后期望的。
- en: 'If you had the Angular CLI test command still running when writing this first
    test, you should now see a successful test execution on your Terminal output.
    Otherwise, just start the test runner again, using the command `ng test` on your
    Terminal:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写这个第一个测试时 Angular CLI 测试命令仍在运行，你现在应该在终端输出中看到成功的测试执行。否则，只需再次启动测试运行器，使用终端上的
    `ng test` 命令：
- en: '![](img/f418e02a-dcdb-40a2-aa85-b1dd8348f413.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f418e02a-dcdb-40a2-aa85-b1dd8348f413.png)'
- en: Terminal and Angular CLI ng test command, showing our first test running successfully
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 终端和 Angular CLI ng test 命令，显示我们的第一个测试成功运行
- en: Spying on component output
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视组件输出
- en: In testing, a common practice is to spy on function calls during the execution
    of tests, and then evaluate these calls, checking whether all functions were called
    correctly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，一个常见的做法是在测试执行期间监视函数调用，然后评估这些调用，检查是否所有函数都被正确调用。
- en: Jasmine provides us with some nice helpers, in order to use `spy` function calls.
    We can use the `spyOn` function of Jasmine to replace the original function with
    a `spy` function. The `spy` function will record any calls, and we can evaluate
    how many times they were called, and with what parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 为我们提供了一些有用的辅助函数，以便使用 `spy` 函数调用。我们可以使用 Jasmine 的 `spyOn` 函数用 `spy` 函数替换原始函数。`spy`
    函数将记录任何调用，我们可以评估它们被调用的次数以及调用时的参数。
- en: 'Let''s look at a simple example of how to use the `spyOn` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `spyOn` 函数的一个简单例子：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will test a simple calculator class that has two methods. The `multiply`
    method simply multiplies two numbers and returns the result. The `pythagorean`
    method calculates the hypotenuse of a right-angled triangle with two sides, `a`
    and `b`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试一个简单的计算器类，它有两个方法。`multiply` 方法简单地乘以两个数字并返回结果。`pythagorean` 方法计算直角三角形的斜边，该三角形有两个边长
    `a` 和 `b`。
- en: 'You might remember the formula for the Pythagorean theorem from your early
    school days:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从小学时代起就学过的勾股定理公式：
- en: '![](img/d2d7af3c-2cd4-475b-8b49-1f3696cd3402.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2d7af3c-2cd4-475b-8b49-1f3696cd3402.png)'
- en: We will use this formula to produce `c` from `a` and `b`, by getting the square
    root of the result of `a*a + b*b`. For the multiplication, we'll use our `multiply`
    method, instead of using arithmetic operators directly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个公式通过计算 `a*a + b*b` 的平方根来从 `a` 和 `b` 产生 `c`。对于乘法，我们将使用我们的 `multiply` 方法，而不是直接使用算术运算符。
- en: 'Now, we want to test our calculator `pythagorean` method, and, as it uses the
    `multiply` method to multiply `a` and `b`, we can spy on the method to verify
    our test result in depth:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要测试我们的计算器 `pythagorean` 方法，因为它使用 `multiply` 方法来乘以 `a` 和 `b`，我们可以监视该方法以深入验证我们的测试结果：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `spyOn` function of Jasmine takes an object as the first parameter and the
    function name of the object on which we'd like to spy as a second parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 的 `spyOn` 函数接受一个对象作为第一个参数，以及我们想要监视的对象上的函数名作为第二个参数。
- en: This will effectively replace the original `multiply` function in our class
    instance with a new `spy` function of Jasmine. By default, `spy` functions will
    only record function calls, and they won't delegate the call to the original function.
    We can use the `.and.callThrough()` function to specify that we'd like Jasmine
    to call the original function. This way, our spy function will act as a proxy,
    and will record any calls at the same time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效地用 Jasmine 的新 `spy` 函数替换我们类实例中的原始 `multiply` 函数。默认情况下，`spy` 函数只会记录函数调用，并且不会将调用委托给原始函数。我们可以使用
    `.and.callThrough()` 函数来指定我们希望 Jasmine 调用原始函数。这样，我们的 spy 函数将充当代理，同时记录任何调用。
- en: In the then section of our test, we can inspect the `spy` function. Using the
    `toHaveBeenCalled` matcher, we can check whether the spy function was called after
    all.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的 `then` 部分，我们可以检查 `spy` 函数。使用 `toHaveBeenCalled` 匹配器，我们可以检查 spy 函数是否被调用过。
- en: Using the `calls` property of the `spy` function, we can inspect in more detail
    and verify the call count, as well as the arguments that individual calls received.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `spy` 函数的 `calls` 属性，我们可以更详细地检查并验证调用次数，以及各个调用接收到的参数。
- en: We can apply the knowledge that we gained about Jasmine spies to our component
    tests. As we know that all output properties of components contain an event emitter,
    we can actually spy on them to check whether our component sends output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们对Jasmine间谍的知识应用到我们的组件测试中。因为我们知道所有组件的输出属性都包含一个事件发射器，我们实际上可以监视它们以检查我们的组件是否发送输出。
- en: Inside components, we call the `emit` method on event emitters, in order to
    send output to parent component bindings. As this is an asynchronous operation,
    and we'd also like to test our components without needing to involve parent components,
    we can simply spy on the `emit` method of our output properties.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，我们调用事件发射器的`emit`方法，以便向父组件绑定发送输出。由于这是一个异步操作，而且我们还想在不涉及父组件的情况下测试我们的组件，我们可以简单地监视输出属性的`emit`方法。
- en: It's generally a good practice to avoid asynchronous operations in unit tests,
    if possible. By using Jasmine spies, we can mock certain function calls that would
    result in asynchronous operations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果可能的话，避免在单元测试中进行异步操作是一个好的实践。通过使用Jasmine间谍，我们可以模拟会导致异步操作的某些函数调用。
- en: 'Let''s change our first test of the efforts component to use Jasmine spies,
    rather than relying on observable subscriptions. Open the file `src/app/efforts/efforts/efforts.component.spec.ts`,
    and perform the following changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将努力组件的第一个测试改为使用Jasmine间谍，而不是依赖于可观察的订阅。打开文件`src/app/efforts/efforts/efforts.component.spec.ts`，并进行以下更改：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've created a Jasmine spy that spies on the `outEffortsChange` output property.
    More precisely, we're spying on any calls to the `emit` method of the underlying
    event emitter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个监视`outEffortsChange`输出属性的Jasmine间谍。更确切地说，我们正在监视对底层事件发射器的`emit`方法的任何调用。
- en: Since we're no longer relying on a callback registered with the `subscribe`
    method on our event emitter output, we now have a much cleaner testing code. The
    testing code is perfectly structured into the given, when, and then sections of
    our BDD style test, and no subscription with a callback function needs to be used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再依赖于在事件发射器输出上注册的`subscribe`方法的回调，我们现在有了更干净的测试代码。测试代码被完美地组织成我们的BDD风格测试的给定、当和然后部分，并且不需要使用带有回调函数的订阅。
- en: Using the `toHaveBeenCalledWith` assertion helper in Jasmine allows us to carefully
    evaluate the `spy` function and check whether the recorded calls match what we
    expected them to be.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jasmine的`toHaveBeenCalledWith`断言辅助器，我们可以仔细评估`spy`函数，并检查记录的调用是否与我们的预期相符。
- en: Utilities to test components
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件测试的实用工具
- en: So far, we have tested our components with plain vanilla JavaScript. The fact
    that components are in regular classes makes this possible. However, this can
    only be done for very simple use cases. As soon as we want to test components
    for things that involve template compilation, user interaction on components,
    change detection, or dependency injection, we'll need to get a little help from
    Angular to perform our tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用纯JavaScript测试了我们的组件。由于组件在常规类中，这使得这一点成为可能。然而，这只适用于非常简单的用例。一旦我们想要测试涉及模板编译、组件上的用户交互、变更检测或依赖注入的组件，我们就需要从Angular那里得到一点帮助来执行我们的测试。
- en: Angular comes with a whole bunch of testing tools that can help us out here.
    In fact, the platform-agnostic way that Angular is built allows us to exchange
    the regular view adapter with a debug view adapter. This enables us to render
    components in such a way that we can inspect them in greater detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自带一整套测试工具，可以帮助我们在这里解决问题。实际上，Angular构建的平台无关性允许我们用调试视图适配器替换常规视图适配器。这使得我们能够以这种方式渲染组件，以便我们可以更详细地检查它们。
- en: 'The Angular CLI has already enabled this for us, and if you check the content
    of the file `src/test.ts`, you can see that there''s a special preparation step
    that enables our testing Angular platform. The following core excerpt shows the
    relevant content of our default test entry point, which was generated by the Angular
    CLI tool when we created our project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI已经为我们启用了这个功能，如果你检查`src/test.ts`文件的内容，你可以看到有一个特殊的准备步骤，它启用了我们的测试Angular平台。以下核心摘录显示了我们的默认测试入口点的相关内容，这是我们在创建项目时由Angular
    CLI工具生成的：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the `initTestEnvironment` function of the `@angular/core/testing` module,
    we can actually initialize a test platform injector, which will then be used in
    the context of our Angular testing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@angular/core/testing`模块中的`initTestEnvironment`函数，我们实际上可以初始化一个测试平台注入器，它将在我们的Angular测试上下文中使用。
- en: From the `@angular/platform-browser-dynamic/testing` module, we can import a
    special testing platform factory function, as well as the Angular browser testing
    module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `@angular/platform-browser-dynamic/testing` 模块，我们可以导入一个特殊的测试平台工厂函数，以及 Angular
    浏览器测试模块。
- en: This code helps us to set up a testing environment that relies on a special
    platform for testing within a browser. Additional debug information will be present
    in the runtime when we're using this platform.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码帮助我们设置一个依赖于特殊平台进行浏览器内测试的测试环境。当我们使用这个平台时，运行时将包含额外的调试信息。
- en: Injecting in tests
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试中的注入
- en: Injecting Angular dependencies in tests is made easy by two helper functions.
    The `inject` and `async` functions are available through the `@angular/core/testing`
    package, and they help us inject dependencies into our tests.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两个辅助函数，将 Angular 依赖注入到测试中变得简单。`inject` 和 `async` 函数通过 `@angular/core/testing`
    包提供，并帮助我们向测试中注入依赖。
- en: 'Let''s look at this simple example, where we inject the `document` element
    using the `inject` wrapper function. This test is irrelevant for our application,
    but it illustrates how we can make use of injection in our tests:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的例子，其中我们使用 `inject` 包装函数注入 `document` 元素。这个测试对我们应用程序来说并不重要，但它说明了我们如何在测试中使用注入：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can simply use `inject` to wrap our test function. The `inject` function
    accepts an array as the first parameter, which should include a list of injectable
    types. The second parameter is our actual test function, which will now receive
    the injected document.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `inject` 函数来包装我们的测试函数。`inject` 函数接受一个数组作为第一个参数，该数组应包含一个可注入类型的列表。第二个参数是我们实际的测试函数，它现在将接收注入的文档。
- en: 'The `async` function, on the other hand, helps us with a different concern.
    What if our tests actually involve asynchronous operations? Well, a standard asynchronous
    Jasmine test would look as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`async` 函数帮助我们处理不同的关注点。如果我们的测试实际上涉及异步操作怎么办？嗯，一个标准的异步 Jasmine 测试看起来如下：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Jasmine provides us with a nice way to specify asynchronous tests. We can simply
    use the first parameter of our test functions, which resolves to a callback function
    and is called `done`, by convention. By calling this callback function, we can
    tell Jasmine that our asynchronous operations are done, and we would like to finish
    the test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 提供了一种很好的方式来指定异步测试。我们可以简单地使用测试函数的第一个参数，它解析为一个名为 `done` 的回调函数，这是一个惯例。通过调用这个回调函数，我们可以告诉
    Jasmine 我们的异步操作已完成，我们希望完成测试。
- en: Using callbacks to indicate whether our asynchronous test is finished is a valid
    option. However, this can make our test quite complicated, if many asynchronous
    operations are involved. It's sometimes even impossible to monitor all of the
    asynchronous operations that are happening under the hood, which also makes it
    impossible for us to determine the end of our test.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调来指示我们的异步测试是否完成是一个有效的选项。然而，如果涉及许多异步操作，这可能会使我们的测试相当复杂。有时甚至无法监控底下的所有异步操作，这也使得我们无法确定测试的结束。
- en: This is where the `async` helper function comes into play. Angular uses a library
    called Zone.js to monitor any asynchronous operations in the browser. Simply put,
    Zone.js hooks into any asynchronous operations and monitors when they are initiated,
    as well as when they are finished. With this information, Angular knows exactly
    how many pending asynchronous operations there are.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `async` 辅助函数发挥作用的地方。Angular 使用一个名为 Zone.js 的库来监控浏览器中的任何异步操作。简单来说，Zone.js
    钩入任何异步操作，并监控它们何时启动以及何时完成。有了这些信息，Angular 可以确切地知道有多少挂起的异步操作。
- en: If we're using the `async` helper, we can tell Angular to automatically finish
    our test when all of the asynchronous operations in our test are done. The helper
    uses Zone.js to create a new zone, and also to determine whether all microtasks
    executed within this zone are finished.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `async` 辅助函数，我们可以告诉 Angular 当测试中的所有异步操作都完成后自动完成我们的测试。这个辅助函数使用 Zone.js
    创建一个新的区域，并确定该区域内执行的所有微任务是否已完成。
- en: 'Let''s look at how we can combine injection with an asynchronous operation
    in our test:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在测试中将注入与异步操作结合起来：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By combining `inject` with `async` (wrapping), we can now test asynchronous
    operations in our test, without any hassle. The `async` helper will make our test
    wait until all asynchronous operations have completed. We don't need to rely on
    a callback, and we have the guarantee that even internal asynchronous operations
    will complete before our test finishes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`inject`与`async`（包装）结合使用，我们现在可以在测试中测试异步操作，而无需任何麻烦。`async`辅助函数将使我们的测试等待直到所有异步操作完成。我们不需要依赖回调，并且我们有保证，即使在测试完成之前，内部异步操作也会完成。
- en: Zone.js is designed to work with all asynchronous operations in the browser.
    It patches all core DOM APIs, and makes sure that every operation goes through
    a zone. Angular also relies on Zone.js to initiate change detection. It waits
    for zones (any asynchronous operations within the browser) to terminate, in order
    to execute change detection. This is pretty smart, since the only possible moment
    for your application state to change is right after asynchronous operations are
    terminated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Zone.js旨在与浏览器中的所有异步操作一起工作。它修补所有核心DOM API，并确保每个操作都通过一个区域。Angular还依赖于Zone.js来启动变更检测。它等待区域（浏览器内的任何异步操作）终止，以便执行变更检测。这非常聪明，因为应用程序状态可能发生变化的唯一可能时刻是在异步操作终止之后。
- en: Using TestBed for running Angular tests
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TestBed运行Angular测试
- en: 'Angular comes with another very important testing utility. So far, we have
    only tested the component class of our components. However, as soon as we need
    to test components and their behaviors in our application, a few more things will
    be involved:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Angular附带另一个非常重要的测试工具。到目前为止，我们只测试了组件的组件类。然而，一旦我们需要在我们的应用程序中测试组件及其行为，就会涉及更多的事情：
- en: '**Testing the view of components**: It''s sometimes required that we test the
    rendered view of components. With all of the bindings in our view, dynamic instantiation
    using template directives and content projection, it can be hard to write deterministic
    tests.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试组件视图**：有时需要测试组件的渲染视图。由于我们的视图中包含所有绑定，使用模板指令和内容投影进行动态实例化，编写确定性测试可能很困难。'
- en: '**Testing change detection**: As soon as we update our model in our component
    class, we will want to test the updates that are performed via change detection.
    This involves the whole change detection behavior of our components.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试变更检测**：一旦我们在组件类中更新我们的模型，我们就会想要测试通过变更检测执行更新的操作。这涉及到我们组件的整个变更检测行为。'
- en: '**User interaction**: Our component templates probably contain a set of event
    bindings, which trigger some behaviors in user interaction. We''ll need a way
    to test the state after user interactions.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户交互**：我们的组件模板可能包含一组事件绑定，这些绑定在用户交互中触发某些行为。我们需要一种方法来测试用户交互后的状态。'
- en: '**Overriding and mocking**: In a testing scenario, it''s sometimes required
    to mock certain areas in our components, in order to create a proper isolation
    for our test. In unit testing, we should only be concerned with the specific behavior
    that we want to test.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖和模拟**：在测试场景中，有时需要模拟组件中的某些区域，以便为测试创建适当的隔离。在单元测试中，我们只应关注我们想要测试的具体行为。'
- en: The `TestBed` class, which is available through the `@angular/core/testing`
    package, helps us with the previously listed concerns. It's our main tool for
    testing components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@angular/core/testing`包提供的`TestBed`类帮助我们解决了之前列出的问题。它是我们测试组件的主要工具。
- en: 'Let''s look at a very simple example of how we can use the `TestBed` class
    to test the view rendering of a simple dummy component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`TestBed`类来测试一个简单模拟组件的视图渲染的一个非常简单的例子：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `beforeEach` function is a Jasmine helper that allows us to execute something
    before each and every test within a given test suite. Within the `beforeEach`
    callback, we're using the `TestBed` class imported from `@angular/core/testing`,
    in order to prepare our testing environment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`函数是一个Jasmine辅助函数，它允许我们在给定测试套件中的每个测试之前执行某些操作。在`beforeEach`回调中，我们使用从`@angular/core/testing`导入的`TestBed`类来准备我们的测试环境。'
- en: The `configureTestingModule` method on the `Testbed` class allows us to configure
    a dynamic Angular module that defines the whole context for our test. The configuration
    object that we're passing to the method is exactly the same as the one that we
    pass to the `@NgModule` decorator factory, when defining Angular modules. It supports
    `import`, `providers`, `declarations`, and all other properties of Angular modules.
    This allows us to create a very specific and isolated testing environment, where
    we can test only the things we really need to.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we're using the Angular `async` helper to wrap our `beforeEach`
    callback function. This is necessary, since the `compileComponents` method call
    is an asynchronous operation that compiles all components present within our dynamic
    testing module. This will ensure that when we enter our test methods, the compilation
    performed within the `beforeEach` callback is finished, and we can start our testing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: When testing components, you need to make sure that you're including all of
    the necessary dependencies within the dynamic module created by the `configureTestingModule`
    call. This includes any sub-components present within the component, under tests,
    pipes, services, and any other dependencies of your component.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Component fixture
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our test, we use the `createComponent` method of the `Testbed` class to create
    a new component instance of our dummy component. As a result of that method call,
    we'll receive a component fixture object that will help us to further perform
    testing on our component.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The component fixture is a wrapper around our component being tested, which
    allows us to further inspect and manipulate our test case. We can now use the
    `nativeElement` property of the fixture to access the root DOM element of the
    created component, and to assert on the text content of that element, to verify
    whether the component has rendered correctly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `ComponentFixture` type, and the available properties and
    methods, in more detail:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `detectChanges()` | This executes change detection on the root component
    that was created in the context of the fixture. The template bindings will not
    automatically be evaluated after creating a component using the `Testbed` class.
    It''s our own responsibility to trigger change detection. Even after we change
    the state of our components, we need to trigger change detection again. This manual
    change detection may sound cumbersome, but it''s important to have full control
    of any operation performed during a test. We always want a test to be fully deterministic.
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `destroy()` | This method destroys the underlying component and performs
    any cleanup that is required. This can be used to test the `OnDestroy` component''s
    life cycle. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `componentInstance` | This property points to the component class instance,
    and it is our main interaction point if we want to interact with the component.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `nativeElement` | This is a reference to the native DOM element at the root
    of the created component. This property can be used to directly inspect the rendered
    DOM of our component. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `elementRef` | This is the `ElementRef` wrapper around the root element of
    the created component. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `debugElement` | This property points to an instance of `DebugElement` that
    was created in the component view rendering pipeline when using the testing browser
    platform. The debug element provides us with some nice utilities to inspect the
    rendered element tree and test user interaction. We''ll take a closer look at
    this later, in another section. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: Mocking child components
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now looked at a very simple dummy component, and how to test it using
    the Angular `TestBed`, in conjunction with the `inject` and `async` helper functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but it doesn't really reflect the complexity that we face when
    we need to test real components. Real components have a lot more dependencies
    than our dummy component. We rely on child directives, and probably injected services,
    to obtain data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the Angular `TestBed` also provides us with the tools that we need
    to test more complex components, while keeping the necessary isolation in a unit
    test.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at an example, where we''d like to test a parent component
    that uses a child component to render a list of numbers. In this test, we''d only
    like to test the parent component, and we''re not interested in how the child
    component renders the list. We want to remove the behavior of the child component
    from our test by providing a mock component for the child component during the
    test, allowing us to easily verify that the data is received by the child component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is our starting point. We have two components, and we'll only be interested
    in testing the parent component. However, the child component is required by the
    parent component, and it implies a very specific way to render the numbers that
    are passed by the parent. We would only like to test whether our numbers were
    passed successfully to the child component. We don't want to involve the rendering
    logic of the child component in our test. This is very important, because changing
    only the child component could break our parent component test, which is what
    we want to avoid.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to create a mock of our child component, in the context of our
    test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our mock child component, it's important that we use the same selector property
    as the real component. Otherwise, the mocking will not work. In the template,
    we use a very simple output of the numbers input, which enables an easy inspection.
    The `toString` method on an array will just render all elements, separated by
    commas.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: It's also important that we provide the same input properties as the original
    component. Otherwise, we won't imitate the real component correctly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can go ahead and prepare for our test. By simply adding our mock child
    component to the declarations of our dynamic test module, we can make sure that
    our parent component uses our mock component, instead of the real child component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a result, we decouple the parent component from the child component, in the
    context of our test. We need this level of separation in order to create a proper
    isolation of our unit test. As our mock child component simply renders the string
    representation of the passed array, we can easily test the text content of our
    fixture.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a unit test is to test a single unit and isolate the unit
    from any dependencies. If we want to stick to this paradigm, we need to create
    a mock for every dependent component. This can easily get us into a situation
    where we need to maintain more complexity, for the sake of our tests. The key
    lies in finding the right balance. You should mock dependencies that have a great
    impact on the subject, and ignore dependencies that have a low impact on the functionality
    that you'd like to test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Mocking services
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a different use case, where we have a component that injects a
    service in order to obtain data. As we only want to test our component, and not
    the service it relies on, we somehow need to sneak in a mock service instead of
    the real service. Since we can define our dynamic test module for our needs, we
    can simply use the `providers` property on our module definition to introduce
    mock services.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should declare our base component and a service that it relies on.
    In this example, the numbers component injects a numbers service, where it obtains
    an array with numbers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to create a mock service that provides the data required in our
    test and isolates our component from the original service:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this simplified example, we just provide a different set of numbers. However,
    in a real mocking case, we could exclude a lot of steps that are unnecessary and
    could potentially create side effects. Using a mock service also ensures that
    our test, which is focused on the numbers component, will not break because of
    a change in the real numbers service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the test case and see how we can use `TestBed` to provide
    our mock service, instead of the real one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `providers` property in the dynamic test module definition, we can
    provide dependencies to the component under test. This allows us to substitute
    dependencies that are used in the component. We can simply create a provider that
    provides our substitute mock numbers service when the numbers service is requested
    within the dependency injection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we don''t have full control of our dependencies; for example, when
    we''re obtaining a predefined set of providers by an imported module. The `TestBed`
    helps us in such situations by providing additional override methods. Let''s look
    at the preceding example again; this time, we''re using an override mechanism
    to sneak in our mock service:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the `overrideProvider` method allows us to override the previously specified
    real service with our mock service. This is an important tool when you're testing
    large applications that rely on imported Angular modules, which won't be under
    your full control.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `Testbed` class of Angular allows us to perform tests in a very simple,
    isolated, and flexible fashion. It plays a major role when writing unit tests
    for components. If you'd like to read more about the available methods in the
    `Testbed` class, you can visit the official documentation website at [https://angular.io/api/core/testing/TestBed](https://angular.io/api/core/testing/TestBed).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to use our new knowledge about the `Testbed` utility class and
    start to test our application components in action!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Testing components in action
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous topic, we learned about the `Testbed` utility class, and how
    to use it to test components in an isolated testing environment. We learned about
    the `inject` and `async` helpers, as well as how to mock components and services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use this knowledge to work on our tests for the efforts component.
    If you take a look at the template of our efforts component, you''ll remember
    that we rely on two child components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration**: The two duration components within the template are used to enter
    both the duration values for estimated as well as effective efforts spent on tasks.
    It''s a good idea to mock out that component when you want to perform tests on
    the efforts component. The duration component itself relies on the rather complex
    editor component.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efforts Timeline**: As it is a purely graphical component to represent our
    task efforts, we don''t really want it to participate in our test of the efforts
    component. However, since this component does not really interfere with our efforts
    behavior, we don''t necessarily need to mock it. Let''s use the real component
    in this specific instance.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alright; let's continue writing tests for our efforts component. So far, we've
    only tested the component class methods of our efforts component. We would now
    like to continue by mocking the duration component and using the Angular `TestBed`
    to create a new component instance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have it running already, it would be a good time to start the test
    framework using the Angular CLI tool. Use the command `ng test` in your command
    line while inside of the project folder.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the test file, located on the path `src/app/efforts/efforts/efforts.component.spec.ts`,
    and perform the following changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our newly introduced mock duration component might look a bit tenuous, but this
    is actually all that we need for our current tests of the efforts component. The
    duration component should just accept a `duration` input and expose an `ourDurationChange`
    output. This is the interface that is expected within the template of our efforts
    component. Since we don't want to rely on any of the duration component internals,
    including the use of the editor component, the template of our mock duration component
    simply renders the duration input. This way, we can easily verify whether the
    correct duration is rendered within our mock component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our first test, using the component instance and fixture
    created with the `Testbed`. Apply the following changes to the effort test file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our tests, we'd like to test whether the effort component initializes the
    duration child components (respectively, our mock duration component) with the
    right content.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Using the component fixture that is provided by the `Testbed` utility class,
    we can start to interact with the created component. Using the `componentInstance`
    member of the component fixture, we can set the required input properties of our
    efforts component.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: As we're responsible for handling change detection in our tests manually, we
    use the `detectChanges` method on our fixture to update the component view. This
    will initiate the change detection life cycle on our component and perform the
    necessary view updates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: After the view updates of both duration components, we can run our assertions
    to validate the updated DOM by getting the text content of the `nativeElement`
    property on our fixture.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Using the text content property of our whole component fixture might be good,
    in some circumstances. However, sometimes, this does not provide the necessary
    granularity for a good assertion. In some scenarios, when we have more DOM elements
    involved, it won't be sufficient to directly assert on the root component's `textContent`
    property. It would probably include a lot of noise, which we're not interested
    in for our assertion. We should always try to narrow our assertion to the fewest
    details possible.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Within our newly created test, we need to assert with the string `Estimated:1Effective:2+1h+4h+1d`,
    in order to validate the correct rendering of our components. However, this also
    includes the labels of our add buttons, which is not exactly what we want to test
    here. Remember, we always want to narrow our test down to exactly one single unit
    and avoid any dependencies on things outside of our specific test case.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to enhance our test and assert on more specific parts of our component
    view. As we have access to the native DOM element on our fixture, we can simply
    use the DOM API to select child elements, in order to narrow our assertion:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This would successfully select the DOM element of our first mock duration component,
    and we can only check the text content inside the duration component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Although this would be a feasible approach, Angular provides us with a much
    better approach to solve this problem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Provided by the component fixture, we have access to the debug element tree
    that is created by the test browser platform, in the context of our test. Debug
    elements allow us to do an advanced inspection of the element tree that was created
    by Angular while rendering our components. It also contains an advanced querying
    API, which allows us to search for certain elements in the component tree.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our test to use the advanced capabilities provided by the debug
    element, and assert on both the estimated and effective duration components views
    individually:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `query` and `queryAll` methods that are available on every debug element
    object allow us to query the Angular view tree like we would query a DOM tree,
    using `querySelector` and `querySelectorAll`. The difference here is that we can
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: use a predicate helper to query for matching elements. Using the `By` helper
    class, we can create these predicates, which will then be used to query the debug
    element tree.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently three different predicates available, using the `By` helper:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `By.all()` | This is the predicate that will result in querying for all of
    the child `DebugElement` objects of the current `DebugElement` object. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `By.css(selector)` | This is the predicate that will result in querying for
    `DebugElement` using the specified CSS selector. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `By.directive(type)` | This is the predicate that will result in querying
    for the `DebugElement` that contains the specified directive. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: Going back to our test, we can now use the query method on the fixture debug
    element, in order to query for our duration components. As we've exchanged the
    real duration component with our mock duration component, we need to query for
    the latter. We use a predicate, `By.directive(MockDurationComponent)`, which will
    successfully query for the debug element object that represents the host elements
    of our two mock duration components.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The `query` method of the debug element object will always return a new debug
    element object of the first found element, if there was a match. It will return
    `null` if the queried element was not found.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The `queryAll` method of a debug element will return an array of many debug
    elements, which will contain all elements that match the predicate. If there are
    no matching elements, this method will return an empty array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Testing component interaction
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although UI interaction testing is probably part of end-to-end testing, we'll
    look at how to test basic user interaction with your components. In this topic,
    we'll test the efforts component when the user clicks on one of the buttons to
    add effective effort hours.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new test to our existing efforts component test file, located
    on the path `src/app/efforts/efforts/efforts.component.spec.ts`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We want to set a Jasmine spy up on the `outEffortsChange.emit` function for
    our test. This way, we can later check whether our efforts component successfully
    emits the event when we click on the button to add a day of effective efforts.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the given section, we're preparing everything for our test. We initialize
    the `efforts` input of our component with a new object. We also query for the
    debug element of the button within the efforts component view that adds one day
    to the effective effort. We use the `queryAll` method to get a list of all three
    buttons, and select the third by accessing the array element with the index `2`.
    The `css` predicate factory allows us to pass a CSS selector to query for debug
    elements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: In the when section of our test, we can simulate a `click` event on the `addDayButton`
    debug element by using the method `tiggerEventHandler`. Using this method, you
    can trigger an event that you'd like to be emitted on the underlying element.
    Angular event listeners that listen for that event will be triggered synchronously.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Within the then section of our BDD style test, we can simply evaluate the Jasmine
    spy that we've created on the `outEffortsChange` output property of our component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Testing user interaction on components is made very easy by using the debug
    element. We can also decouple our tests from the underlying DOM event architecture
    by using the `triggerEventHandler` helper method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The `triggerEventHandler` method operates on the virtual element tree of Angular,
    rather than the actual DOM tree. Due to this, we can also use this method to trigger
    event handlers that are attached to component output properties.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter of the book, we learned how to write concise unit tests
    for our components. We followed a BDD style approach of writing tests, and we
    also covered the basics of the JavaScript testing framework, Jasmine.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the debugging tools that are available in Angular, and how
    to set up an environment for testing. Using the Angular `Testbed` utility class,
    we were able to perform tests in a very flexible but precise way. We also learned
    about the debug view tree and the component fixture. These allowed us to perform
    clever inspections and apply practical queries to the rendered views, in order
    to assert expected results.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We used the `inject` and `async` helpers to inject dependencies, and to run
    asynchronous tests at the same time. We built mock components, in order to isolate
    our tests from the rest of our application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
