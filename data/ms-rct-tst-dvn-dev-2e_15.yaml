- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Adding Animation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动画
- en: Animation lends itself to test-driven development just as much as any other
    feature. In this chapter, we’ll animate the Logo turtle movement as the user inputs
    commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动画与其他任何功能一样，也适合测试驱动开发。在本章中，我们将根据用户输入的命令动画化Logo乌龟的移动。
- en: 'There are two types of animation in Spec Logo:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Spec Logo中有两种类型的动画：
- en: First, when the turtle moves forward. For example, when the user enters `forward
    100` as an instruction, the turtle should move 100 units along, at a fixed speed.
    As it moves, it will draw a line behind it.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当乌龟向前移动时。例如，当用户输入`forward 100`作为指令时，乌龟应该以固定速度沿100个单位移动。在移动过程中，它将在后面画一条线。
- en: Second, when the turtle rotates. For example, if the user types `rotate 90`,
    then the turtle should rotate slowly until it has made a quarter turn.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，当乌龟旋转时。例如，如果用户输入`rotate 90`，那么乌龟应该缓慢旋转，直到它完成四分之一转弯。
- en: Much of this chapter is about test-driving the `window.requestAnimationFrame`
    function. This is the browser API that allows us to animate visual elements on
    the screen, such as the position of the turtle or the length of a line. The mechanics
    of this function are explained in the third section of this chapter, *Animating
    with requestAnimationFrame*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容是关于测试驱动`window.requestAnimationFrame`函数。这是浏览器API，允许我们在屏幕上动画化视觉元素，例如乌龟的位置或线的长度。这个函数的机制在本章的第三部分*使用requestAnimationFrame进行动画*中解释。
- en: The importance of manual testing
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试的重要性
- en: When writing animation code, it’s natural to want to visually check what we’re
    building. Automated tests aren’t enough. Manually testing is also important because
    animation is not something that most programmers do every day. When something
    is new, it’s often better to do lots of manual tests to verify behavior in addition
    to your automated tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写动画代码时，自然想要直观地检查我们正在构建的内容。自动测试是不够的。手动测试也很重要，因为动画不是大多数程序员每天都会做的事情。当某事是新的时，通常最好进行大量的手动测试来验证行为，除了你的自动测试之外。
- en: In fact, while preparing for this chapter, I did a *lot* of manual testing.
    The walk-through presented here experiments with several different approaches.
    There were many, many times that I opened my browser to type `forward 100` or
    `right 90` to visually verify what was happening.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在准备本章时，我进行了大量的手动测试。这里展示的试验了几种不同的方法。有很多次我打开浏览器输入`forward 100`或`right 90`来直观地验证发生了什么。
- en: 'This chapter covers the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Designing animation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计动画
- en: Building an animated line component
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建动画线条组件
- en: Animating with `requestAnimationFrame`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`requestAnimationFrame`进行动画
- en: Canceling animations with `cancelAnimationFrame`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cancelAnimationFrame`取消动画
- en: Varying animation behavior
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变化动画行为
- en: The code we’ll write is relatively complicated compared to the code in the rest
    of the book, so we need to do some upfront design first.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的代码与本书中其他部分的代码相比相对复杂，因此我们需要先做一些前期设计。
- en: By the end of the chapter, you’ll have gained a deep understanding of how to
    test-drive one of the more complicated browser APIs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解如何测试驱动更复杂的浏览器API之一。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在这里找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter15)'
- en: Designing animation
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计动画
- en: As you read through this section, you may wish to open `src/Drawing.js` and
    read the existing code to understand what it’s doing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本节时，你可能希望打开`src/Drawing.js`并阅读现有代码，以了解它在做什么。
- en: The current `Drawing` component shows a static snapshot of how the drawing looks
    at this point. It renders a set of **Scalable Vector Graphics** (**SVG**) lines
    to represent the path the turtle has taken to this point, and a triangle to represent
    the turtle.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的`Drawing`组件显示了在此点绘图的外观的静态快照。它渲染一组**可缩放矢量图形**（**SVG**）线条来表示乌龟到达此点的路径，以及一个三角形来表示乌龟。
- en: 'The component makes use of two child components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用了两个子组件：
- en: The `Turtle` component is displayed once and draws an SVG triangle at the given
    location
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Turtle`组件只显示一次，并在指定位置绘制一个SVG三角形'
- en: The `StaticLines` component is a set of SVG lines that are drawn onscreen to
    represent the drawn commands
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StaticLines` 组件是一组在屏幕上绘制的 SVG 线条，用于表示绘制的命令'
- en: We will add a new `AnimatedLine` component that represents the current line
    being animated. As lines complete their animation, they will move into the `StaticLines`
    collection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个新的 `AnimatedLine` 组件，表示正在动画化的当前线条。当线条完成动画后，它们将移动到 `StaticLines` 集合中。
- en: We’ll need to do some work to convert this from a static view to an animated
    representation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些工作来将这个静态视图转换为动画表示。
- en: As it stands, the component takes a `turtle` prop and a `drawCommands` prop.
    The `turtle` prop is the current position of the turtle, given that all the draw
    commands have already been drawn.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，该组件接受一个 `turtle` 属性和一个 `drawCommands` 属性。`turtle` 属性是乌龟的当前位置，前提是所有绘图命令都已经绘制完成。
- en: In our new animated drawing, we will still treat `drawCommands` as a list of
    commands to execute. But rather than relying on a `turtle` prop to tell us where
    the turtle is, we’ll store the *current* position of the turtle as a component
    state. We will work our way through the `drawCommands` array, one instruction
    at a time, and update the turtle component state as it animates. Once all instructions
    are completed, the turtle component state will match what would have originally
    been set for the `turtle` prop.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新的动画绘图中，我们仍然将 `drawCommands` 视为一组要执行的命令。但不是依赖于 `turtle` 属性来告诉我们乌龟的位置，我们将乌龟的
    *当前* 位置存储为组件状态。我们将逐条指令通过 `drawCommands` 数组，每次一个指令，并在动画过程中更新乌龟组件状态。一旦所有指令都完成，乌龟组件状态将匹配最初为
    `turtle` 属性设置的值。
- en: The turtle always starts at the `0,0` coordinate with an angle of `0`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 乌龟始终从 `0,0` 坐标以 `0` 角度开始。
- en: We will need to keep track of which commands have already been animated. We’ll
    create another component state variable, `animatingCommandIndex`, to denote the
    index of the array item that is currently being animated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪哪些命令已经被动画化。我们将创建另一个组件状态变量 `animatingCommandIndex`，以表示当前正在动画化的数组项的索引。
- en: We start animating at the `0` index. Once that command has been animated, we
    increment the index by `1`, moving along to the next command, and animate that.
    The process is repeated until we reach the end of the array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从索引 `0` 开始动画。一旦该命令被动画化，我们就将索引增加 `1`，移动到下一个命令，并对其动画化。这个过程会重复进行，直到我们达到数组的末尾。
- en: This design means that the user can enter new `drawCommands` at the prompt even
    if animations are currently running. The component will take care to redraw with
    animations at the same point it left off at.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计意味着用户可以在动画运行时在提示符中输入新的 `drawCommands`。组件将确保在离开的点重新绘制带有动画的图形。
- en: 'Finally, are two types of draw commands: `drawLine` and `rotate`. Here are
    a couple of examples of commands that will appear in the `drawCommands` array:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两种类型的绘图命令：`drawLine` 和 `rotate`。以下是一些将在 `drawCommands` 数组中出现的命令示例：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each type of animation will need to be handled differently. So, for example,
    the `AnimatedLine` component will be hidden when the turtle is rotating.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的动画都需要不同的处理方式。例如，当乌龟旋转时，`AnimatedLine` 组件将被隐藏。
- en: 'That about covers it. We’ll follow this approach:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。我们将遵循以下方法：
- en: Start with building the `AnimatedLine` component
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从构建 `AnimatedLine` 组件开始
- en: Create a `useEffect` hook in `Drawing` that calls the `window.requestAnimationFrame`
    function to animate `drawLine` commands
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Drawing` 中创建一个 `useEffect` 钩子，调用 `window.requestAnimationFrame` 函数来动画化 `drawLine`
    命令
- en: Cancel the animation of `drawLine` commands when new instructions are added
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当添加新指令时取消 `drawLine` 命令的动画
- en: Add the animation of turtle rotations
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加乌龟旋转的动画
- en: Let’s get started with the `AnimatedLine` component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `AnimatedLine` 组件开始。
- en: Building an animated line component
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个动画线条组件
- en: In this section, we’ll create a new `AnimatedLine` component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的 `AnimatedLine` 组件。
- en: 'This component contains no animation logic itself but, instead, draws a line
    from the start of the line being animated to the current turtle position. Therefore,
    it needs two props: `commandToAnimate`, which would be one of the `drawLine` command
    structures shown previously, and the `turtle` prop, containing the position.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件本身不包含动画逻辑，而是从动画线条的起点绘制到当前乌龟位置的一条线。因此，它需要两个属性：`commandToAnimate`，这将是之前显示的
    `drawLine` 命令结构之一，以及包含位置的 `turtle` 属性。
- en: 'Let’s begin:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: 'Create a new file, `test/AnimatedLine.test.js`, and prime it with the following
    imports and `describe` block setup. Notice the inclusion of the sample instruction
    definition for `horizontalLine`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`test/AnimatedLine.test.js`，并使用以下导入和 `describe` 块设置初始化它。注意包括 `horizontalLine`
    的样本指令定义：
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now add the first test, which checks the starting position of the line:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加第一个测试，用于检查线的起始位置：
- en: '[PRE2]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new file, `src/AnimatedLine.js`, and make your test pass by using
    the following implementation:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，`src/AnimatedLine.js`，并通过以下实现使测试通过：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On to the next test. In this one, we explicitly set the turtle values so that
    it’s clear to see where the expected values come from:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是下一个测试。在这个测试中，我们明确设置海龟值，以便清楚地看到预期值来自何处：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To make that pass, we just need to set the `x2` and `y2` props on the line
    element, pulling that in from the turtle:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，我们只需要在线元素上设置 `x2` 和 `y2` 属性，从海龟那里拉取这些值：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we need two tests to set the `strokeWidth` and `stroke` props:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要两个测试来设置 `strokeWidth` 和 `stroke` 属性：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finish off the component by adding in those two props:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加这两个属性来完成组件：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That completes the `AnimatedLine` component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `AnimatedLine` 组件。
- en: Next, it’s time to add it into `Drawing`, by setting the `commandToAnimate`
    prop to the current line that’s animating and using `requestAnimationFrame` to
    vary the position of the `turtle` prop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候将其添加到 `Drawing` 中了，通过将 `commandToAnimate` 属性设置为当前正在动画化的线条，并使用 `requestAnimationFrame`
    来改变 `turtle` 属性的位置。
- en: Animating with requestAnimationFrame
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 requestAnimationFrame 进行动画
- en: In this section, you will use the `useEffect` hook in combination with `window.requestAnimationFrame`
    to adjust the positioning of `AnimatedLine` and `Turtle`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将结合使用 `useEffect` 钩子和 `window.requestAnimationFrame` 来调整 `AnimatedLine`
    和 `Turtle` 的位置。
- en: The `window.requestAnimationFrame` function is used to animate visual properties.
    For example, you can use it to increase the length of a line from 0 units to 200
    units over a given time period, such as 2 seconds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.requestAnimationFrame` 函数用于动画视觉属性。例如，你可以用它在一个给定的时间段内，比如2秒内，将一条线的长度从0单位增加到200单位。'
- en: 'To make this work, you provide it with a callback that will be run at the next
    repaint interval. This callback is provided with the current animation time when
    it’s called:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这工作，你提供一个回调，该回调将在下一个重绘间隔运行。当调用时，该回调提供了当前的动画时间：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you know the start time of your animation, you can work out the elapsed animation
    time and use that to calculate the current value of your animated property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已知动画的开始时间，你可以计算出已过的动画时间，并使用这个时间来计算动画属性的当前值。
- en: The browser can invoke your callback at a very high refresh rate, such as 60
    times per second. Because of these very small intervals of time, your changes
    appear as a smooth animation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器可以以非常高的刷新率调用你的回调，例如每秒60次。因为这些非常小的时间间隔，你的更改看起来像是一个平滑的动画。
- en: 'Note that the browser only invokes your callback once for every requested frame.
    That means it’s your responsibility to repeatedly call the `requestAnimationFrame`
    function until the animation time reaches your defined end time, as in the following
    example. The browser takes care of only invoking your callback when the screen
    is due to be repainted:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，浏览器只为每个请求的帧调用一次你的回调。这意味着你有责任重复调用 `requestAnimationFrame` 函数，直到动画时间达到你定义的结束时间，如下例所示。浏览器负责仅在屏幕需要重绘时调用你的回调：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we progress through this section, you’ll see how you can use this to modify
    the component state (such as the position of `AnimatedLine`), which then causes
    your component to rerender.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入本节，你会看到如何使用这个来修改组件状态（例如 `AnimatedLine` 的位置），这会导致你的组件重新渲染。
- en: 'Let’s begin by getting rid of the existing turtle value from the Redux store—we’re
    no longer going to use this, and instead, rely on the calculated turtle position
    from the `drawCommands` array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Redux存储中移除现有的海龟值开始——我们不再使用这个值，而是依赖于从 `drawCommands` 数组中计算出的海龟位置：
- en: 'Open `test/Drawing.test.js` and find the test with the name `passes the turtle
    x, y and angle as props to Turtle`. Replace it with the following:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `test/Drawing.test.js` 并找到名为 `passes the turtle x, y and angle as props to
    Turtle` 的测试。用以下内容替换它：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, in `src/Drawing.js`, you can remove the turtle value that was extracted
    from the Redux store, by replacing the `useSelector` call with this one:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `src/Drawing.js` 文件中，你可以通过替换 `useSelector` 调用，移除从 Redux 存储中提取的海龟值：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ll replace the existing turtle value with a new state variable. This will
    come in useful later when we start moving the position of the turtle. Start by
    importing `useState` into `src/Drawing.js`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用一个新的状态变量替换现有的乌龟值。当我们开始移动乌龟的位置时，这将非常有用。首先，将`useState`导入到`src/Drawing.js`中：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, just below the call to `useSelector`, add another call to `useState`.
    After this change, your test should be passing:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`useSelector`调用下方添加另一个`useState`调用。在此更改之后，你的测试应该可以通过：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Back in `test/Drawing.test.js`, stub out the `requestAnimationFrame` function
    in the `describe` block’s `beforeEach`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/Drawing.test.js`中，在`describe`块的`beforeEach`中模拟`requestAnimationFrame`函数：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following new `describe` block and test to the bottom of the existing
    `describe` block, inside the existing `describe` block (so it’s nested). It defines
    an initial state of `horizontalLineDrawn` that has a single line—this line is
    defined in the `sampleInstructions` file. The test states that we expect `requestAnimationFrame`
    to be invoked when the component mounts:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下新的`describe`块和测试添加到现有`describe`块的底部，在现有`describe`块内部（因此它是嵌套的）。它定义了一个初始状态`horizontalLineDrawn`，它只有一条线——这条线在`sampleInstructions`文件中定义。测试表明我们期望在组件挂载时调用`requestAnimationFrame`：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To make this pass, open `src/Drawing.js` and start by importing the `useEffect`
    hook:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，打开`src/Drawing.js`并首先导入`useEffect`钩子：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add the new `useEffect` hook into the `Drawing` component. Add the following
    three lines, just above the `return` statement JSX:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将新的`useEffect`钩子添加到`Drawing`组件中。在`return`语句JSX上方添加以下三行：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we’re now in the realms of `useEffect`, any actions that cause updates
    to the component state must occur within an `act` block. That includes any triggered
    animation frames, and we’re about to trigger some. So, back in `test/Drawing.test.js`,
    add the `act` import now:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在处于`useEffect`的领域，任何导致组件状态更新的操作都必须在`act`块内发生。这包括任何触发的动画帧，我们即将触发一些。因此，回到`test/Drawing.test.js`，现在添加`act`导入：
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need an import for `AnimatedLine` because, in the next test, we’ll
    assert that we render it. Add the following import, together with its spy setup,
    as shown:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要导入`AnimatedLine`，因为在下一个测试中，我们将断言我们渲染了它。添加以下导入，以及其间谍设置，如下所示：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The call to `requestAnimationFrame` requires a `handler` function as an argument.
    The browser will then call this function during the next animation frame. For
    the next test, we’ll check that the turtle is at the start of the first line when
    the timer first fires. We need to define a new helper to do this, which is `triggerRequestAnimationFrame`.
    In a browser environment, this call would happen automatically, but in our test,
    we play the role of the browser and trigger it in code. It’s this call that must
    be wrapped in an `act` function call since our handler will cause the component
    state to change:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame`的调用需要一个`handler`函数作为参数。然后浏览器将在下一个动画帧期间调用此函数。对于下一个测试，我们将检查当计时器第一次触发时，乌龟是否位于第一条线的起点。我们需要定义一个新的辅助函数来完成这个任务，即`triggerRequestAnimationFrame`。在浏览器环境中，这个调用会自动发生，但在我们的测试中，我们扮演浏览器的角色，并在代码中触发它。正是这个调用必须被`act`函数调用包裹，因为我们的处理程序将导致组件状态改变：'
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we’re ready to write tests for the animation cycle. The first one is a
    simple one: at time zero, the turtle position is placed at the *start* of the
    line. If you check the definition in `test/sampleInstructions.js`, you’ll see
    that `horizontalLine` starts at position `100,100`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好编写动画周期的测试了。第一个是一个简单的测试：在时间零时，乌龟位置被放置在线的**起点**。如果你检查`test/sampleInstructions.js`中的定义，你会看到`horizontalLine`从位置`100,100`开始：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the turtle position for animation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用乌龟位置进行动画
- en: Remember that the `AnimatedLine` component draws a line from the start position
    of the `drawLine` instruction to the current turtle position. That turtle position
    is then animated, which has the effect of the `AnimatedLine` instance growing
    in length until it finds the end position of the `drawLine` instruction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`AnimatedLine`组件从`drawLine`指令的起始位置绘制到当前乌龟位置。然后，这个乌龟位置被动画化，这产生了`AnimatedLine`实例长度增长直到找到`drawLine`指令的终点位置的效果：
- en: 'Making this test pass will be a bit of a *big bang*. To start, extend `useEffect`
    as shown. We define two variables, `commandToAnimate` and `isDrawingLine`, which
    we use to determine whether we should animate at all. The `isDrawingLine` test
    is necessary because some of the existing tests send no draw commands at all to
    the component, in which case `commandToAnimate` will be `null`. Yet another test
    passes a command of an unknown type into the component, which would also blow
    up if we tried to pull out `x1` and `y1` from it. That explains the call to `isDrawLineCommand`—a
    function that is defined already at the top of the file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使这个测试通过将是一个小小的“大爆炸”。首先，按照所示扩展 `useEffect`。我们定义了两个变量，`commandToAnimate` 和 `isDrawingLine`，我们使用它们来确定是否应该进行动画。`isDrawingLine`
    测试是必要的，因为一些现有的测试根本不会向组件发送任何绘图命令，在这种情况下 `commandToAnimate` 将是 `null`。另一个测试将一个未知类型的命令传递到组件中，如果我们尝试从中提取
    `x1` 和 `y1`，它也会崩溃。这就是为什么需要调用 `isDrawLineCommand` 的原因——这是一个已经在文件顶部定义好的函数：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using the functional update setter
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式更新设置器
- en: This code uses the *functional update* variant of `setTurtle` that takes a function
    rather than a value. This is used when the new state value depends on the old
    value. Using this form of setter means that the turtle doesn’t need to be in the
    dependency list of `useEffect` and won’t cause the `useEffect` hook to reset itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 `setTurtle` 的 *函数式更新* 变体，它接受一个函数而不是一个值。当新的状态值依赖于旧值时，会使用这种形式的设置器。使用这种形式的设置器意味着乌龟不需要在
    `useEffect` 的依赖列表中，并且不会导致 `useEffect` 钩子重置自己。
- en: 'At this point, we still aren’t rendering `AnimatedLine`, which is what our
    test expects. Let’s fix that now. Start by adding the import:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有渲染 `AnimatedLine`，这正是我们的测试所期望的。现在让我们修复这个问题。首先，添加导入：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Insert this just below the JSX for `StaticLines`. At this point, your test
    should be passing:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StaticLines` 的 JSX 下方插入此代码。此时，你的测试应该可以通过：
- en: '[PRE24]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need a further test to check that we don’t render `AnimatedLine` if no lines
    are being animated. Add the next test as shown, but don’t add it in the `movement
    animation` block; instead, place it into the parent context:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要进一步的测试来确保在没有动画线条时不会渲染 `AnimatedLine`。按照所示添加下一个测试，但不要将其添加到 `movement animation`
    块中；相反，将其放入父上下文中：
- en: '[PRE25]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make that pass by wrapping the `AnimatedLine` component with a ternary. We
    simply return `null` if `isDrawingLine` is false:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `AnimatedLine` 组件用三元运算符包裹来实现这个过渡。如果 `isDrawingLine` 为假，我们简单地返回 `null`：
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We’ve handled what the *first* animation frame should do; now let’s code up
    the *next* animation frame. In the following test, there are *two* calls to `triggerRequestAnimationFrame`.
    The first one is used to signify that animation is started; the second one allows
    us to move. We need the first call (with a time index of `0`) to be able to mark
    the time at which the animation started:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经处理了 *第一个* 动画帧应该做什么；现在让我们编写 *下一个* 动画帧的代码。在下面的测试中，有 *两个* 调用 `triggerRequestAnimationFrame`。第一个用于表示动画已经开始；第二个允许我们移动。我们需要第一个调用（时间索引为
    `0`）来标记动画开始的时间：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using animation duration to calculate the distance moved
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动画持续时间来计算移动的距离
- en: The `handleDrawLineFrame` function, when called by the browser, will be passed
    a time parameter. This is the current duration of the animation. The turtle travels
    at a constant velocity, so knowing the duration allows us to calculate where the
    turtle is.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器调用 `handleDrawLineFrame` 函数时，会传递一个时间参数。这是动画的当前持续时间。乌龟以恒定的速度移动，因此知道持续时间可以让我们计算出乌龟的位置。
- en: 'To make this pass, first, we need to define a couple of functions. Scroll up
    `src/Drawing.js` until you see the definition for `isDrawLineCommand` and add
    these two new definitions there. The `distance` and `movementSpeed` functions
    are used to calculate the duration of the animation:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这个过渡，首先，我们需要定义几个函数。滚动到 `src/Drawing.js` 的顶部，直到你看到 `isDrawLineCommand` 的定义，然后在那里添加这两个新的定义。`distance`
    和 `movementSpeed` 函数用于计算动画的持续时间：
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can calculate the duration of the animation; modify `useEffect` as shown:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以计算动画的持续时间；按照所示修改 `useEffect`：
- en: '[PRE29]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By declaring `duration` as the very first line in the `useEffect` block, the
    variable is in scope for the `requestAnimationFrame` handler to read it to calculate
    distance. To do that, we take the elapsed time and divide it by the total duration:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `duration` 声明为 `useEffect` 块中的第一行，该变量在 `requestAnimationFrame` 处理程序的作用域内，以便读取它来计算距离。为此，我们取经过的时间并将其除以总持续时间：
- en: '[PRE30]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’re making great progress! In the previous test, we assumed that the starting
    time is `0`, but actually, the browser could give us any time as the start time
    (the time it gives us is known as the **time origin**). So, let’s make sure our
    calculations work for a non-zero start time. Add the following test:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们取得了很大的进展！在之前的测试中，我们假设起始时间是`0`，但实际上，浏览器可以给我们任何时间作为起始时间（它给出的时间被称为**时间原点**）。因此，让我们确保我们的计算对于非零起始时间也是有效的。添加以下测试：
- en: '[PRE31]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make that pass by introducing the `start` and `elapsed` times, as shown:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过引入`start`和`elapsed`时间，实现这个过渡，如下所示：
- en: '[PRE32]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our components need to call `requestAnimationFrame` repeatedly until the duration
    is reached. At that point, the line should have been fully drawn. In this test,
    we trigger three animation frames, and we expect `requestAnimationFrame` to have
    been called three times:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保我们的组件在达到持续时间之前重复调用`requestAnimationFrame`。到那时，线条应该已经完全绘制。在这个测试中，我们触发了三个动画帧，并期望`requestAnimationFrame`被调用了三次：
- en: '[PRE33]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To make that pass, we need to ensure that `handleDrawLineFrame` triggers another
    `requestAnimationFrame` when it’s run. However, we should only do that until the
    time that the duration has been reached. Make that pass happen by wrapping the
    `setTurtle` and `requestAnimationFrame` calls with the following conditional:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这个过渡，我们需要确保`handleDrawLineFrame`在运行时触发另一个`requestAnimationFrame`。然而，我们只应该在持续时间到达之前这样做。通过以下条件将`setTurtle`和`requestAnimationFrame`调用包装起来，以实现这个过渡：
- en: '[PRE34]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For the next test, we will check that when a line has “finished” being drawn,
    we move on to the next one, if there is one (otherwise, we stop). Add a new `describe`
    block below the `describe` block we’ve just implemented, with the following test.
    The second time stamp, `500`, is after the duration that is required for `horizontalLine`
    to be drawn and therefore, `AnimatedLine` should show `verticalLine` instead:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个测试，我们将检查当一条线“完成”绘制后，如果还有下一条线，我们将继续绘制下一条（如果没有，则停止）。在刚刚实现的`describe`块下方添加一个新的`describe`块，并添加以下测试。第二个时间戳`500`是在`horizontalLine`绘制所需的时间之后，因此`AnimatedLine`应该显示`verticalLine`：
- en: '[PRE35]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make that pass, we need to introduce a pointer to the command that is currently
    being animated. This will start at the `0` index, and we’ll increment it each
    time the animation finishes. Add the following new state variable at the top of
    the component:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这个过渡，我们需要引入一个指向当前正在动画化的命令的指针。这个指针将从`0`索引开始，每次动画完成后都会递增。在组件顶部添加以下新的状态变量：
- en: '[PRE36]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Update the `commandToAnimate` constant to use this new variable:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`commandToAnimate`常量更新为使用这个新变量：
- en: '[PRE37]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add an `else` clause to the conditional in `handleDrawLineFrame` that increments
    the value:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`handleDrawLineFrame`中的条件语句中添加一个`else`子句来增加值：
- en: '[PRE38]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the final test, we want to make sure that only previously animated commands
    are sent to `StaticLines`. The currently animating line will be rendered by `AnimatedLine`,
    and lines that haven’t been animated yet shouldn’t be rendered at all:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后的测试，我们想要确保只有之前已经动画化的命令被发送到`StaticLines`。当前正在动画化的线条将由`AnimatedLine`渲染，而尚未动画化的线条根本不应被渲染：
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To make that pass, update `lineCommands` to take only the portion of `drawCommands`
    up until the current `animatingCommandIndex` value:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这个过渡，将`lineCommands`更新为只包含`drawCommands`中直到当前`animatingCommandIndex`值的部分：
- en: '[PRE40]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Although the latest test will now pass, the existing test, `sends only line
    commands to StaticLines`, will now break. Since our latest test covers essentially
    the same functionality, you can safely delete that test now.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然最新的测试现在会通过，但现有的测试`sends only line commands to StaticLines`现在会失败。由于我们最新的测试覆盖了基本相同的功能，你现在可以安全地删除那个测试了。
- en: If you run the app, you’ll now be able to see lines being animated as they are
    placed on the screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你现在将能够看到线条在屏幕上被动画化。
- en: In the next section, we’ll ensure the animations behave nicely when multiple
    commands are entered by the user at the same time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将确保当用户同时输入多个命令时，动画表现良好。
- en: Canceling animations with cancelAnimationFrame
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`cancelAnimationFrame`取消动画
- en: The `useEffect` hook we’ve written has `commandToAnimate` and `isDrawingLine`
    in its dependency list. That means that when either of these values updates, the
    `useEffect` hook is torn down and will be restarted. But there are other occasions
    when we want to cancel the animation. One time this happens is when the user resets
    their screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 `useEffect` 钩子在其依赖列表中有 `commandToAnimate` 和 `isDrawingLine`。这意味着当这两个值中的任何一个更新时，`useEffect`
    钩子将被销毁并重新启动。但还有其他情况下我们想要取消动画。其中一种情况是当用户重置他们的屏幕时。
- en: If a command is currently animating when the user clicks the **Reset** button,
    we don’t want the current animation frame to continue. We want to clean that up.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击 **重置** 按钮时，命令正在动画化，我们不想让当前的动画帧继续。我们想要清理它。
- en: 'Let’s add a test for that now:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这个功能添加一个测试：
- en: 'Add the following test at the bottom of `test/Drawing.test.js`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/Drawing.test.js` 的底部添加以下测试：
- en: '[PRE41]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You’ll also need to change the `beforeEach` block, making the `requestAnimationFrame`
    stub return a dummy cancel token, and adding in a new stub for the `cancelAnimationFrame`
    function:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要更改 `beforeEach` 块，使 `requestAnimationFrame` 模拟返回一个虚拟的取消令牌，并为 `cancelAnimationFrame`
    函数添加一个新的模拟：
- en: '[PRE42]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To make the test pass, update the `useEffect` hook to store the `cancelToken`
    value that the `requestAnimationFrame` function returns when it’s called. Then
    return a cleanup function from the `useEffect` hook, which uses that token to
    cancel the next requested frame. This function will be called by React when it
    tears down the hook:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，更新 `useEffect` 钩子以存储 `requestAnimationFrame` 函数在调用时返回的 `cancelToken`
    值。然后从 `useEffect` 钩子返回一个清理函数，该函数使用该令牌取消下一个请求的帧。这个函数将在 React 销毁钩子时被调用：
- en: '[PRE43]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we don’t want to run this cleanup if `cancelToken` hasn’t been set.
    The token won’t have been set if we aren’t currently rendering a line. We can
    prove that with the following test, which you should add now:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们不想在没有设置 `cancelToken` 的情况下运行这个清理。如果当前没有绘制线条，则不会设置令牌。我们可以通过以下测试来证明这一点，你应该现在添加它：
- en: '[PRE44]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unmounting a component
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载组件
- en: This test shows how you can mimic an *unmount* of a component in React, which
    is simply by rendering `<React.Fragment />` in place of the component under test.
    React will unmount your component when this occurs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试展示了如何在 React 中模拟组件的卸载，这仅仅是通过在测试组件的位置渲染 `<React.Fragment />` 来实现的。当发生这种情况时，React
    将卸载你的组件。
- en: 'To make that pass, simply wrap the returned cleanup function in a conditional:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，只需将返回的清理函数包裹在一个条件语句中：
- en: '[PRE45]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That’s all we need to do for animating the `drawLine` commands. Next up is rotating
    the turtle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们为动画化 `drawLine` 命令需要做的所有事情。接下来是旋转海龟。
- en: Varying animation behavior
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化动画行为
- en: 'Our lines and turtle are now animating nicely. However, we still need to handle
    the second type of draw command: rotations. The turtle will move at a constant
    speed when rotating to a new angle. A full rotation should take 1 second to complete,
    and we can use this to calculate the duration of the rotation. For example, a
    quarter rotation will take 0.25 seconds to complete.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到线条和海龟正在很好地动画化。然而，我们仍然需要处理第二种类型的绘制命令：旋转。当海龟旋转到新的角度时，它将以恒定的速度移动。一个完整的旋转应该需要
    1 秒来完成，我们可以用这个来计算旋转的持续时间。例如，四分之一旋转将需要 0.25 秒来完成。
- en: In the last section, we started with a test to check that we were calling `requestAnimationFrame`.
    This time, that test isn’t essential because we’ve already proved the same design
    with drawing lines. We can jump right into the more complex tests, using the same
    `triggerRequestAnimationFrame` helper as before.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们从一个测试开始，检查我们是否调用了 `requestAnimationFrame`。这次，这个测试不是必需的，因为我们已经通过绘制线条证明了相同的设计。我们可以直接进入更复杂的测试，使用之前相同的
    `triggerRequestAnimationFrame` 辅助函数。
- en: 'Let’s update `Drawing` to animate the turtle’s coordinates:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `Drawing` 以使海龟坐标动画化：
- en: 'Add the following test to the bottom of the `Drawing` `describe` block. Create
    it in another nested `describe` block, just below the last test you wrote. The
    test follows the same principle as our tests for drawing lines: we trigger two
    animation frames, one at time `0` ms and one at time `500` ms, and then expect
    the rotation to have occurred. Both the *x* and *y* coordinates are tested in
    addition to the *angle*; that’s to make sure we continue to pass those through:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Drawing` 的 `describe` 块底部添加以下测试。在另一个嵌套的 `describe` 块中创建它，位于你刚刚编写的最后一个测试下面。这个测试遵循我们绘制线条测试的相同原则：我们触发两个动画帧，一个在
    `0` 毫秒，一个在 `500` 毫秒，然后期望旋转发生。除了 *角度* 之外，还测试了 *x* 和 *y* 坐标；这是为了确保我们继续传递这些值：
- en: '[PRE46]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Moving to `src/Drawing.js`, start by adding a definition of `isRotateCommand`,
    just below the definition of `isDrawLineCommand`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动到`src/Drawing.js`，首先在`isDrawLineCommand`定义下方添加`isRotateCommand`的定义：
- en: '[PRE47]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `Drawing` component, add a new constant, `isRotating`, just below the
    definition of `isDrawingLine`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Drawing`组件中，在`isDrawingLine`定义下方添加一个新的常量，`isRotating`：
- en: '[PRE48]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `useEffect` hook, define a new handler for rotations, `handleRotationFrame`,
    just below the definition of `handleDrawLineFrame`. For the purposes of this test,
    it doesn’t need to do much other than set the angle to the new value:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`useEffect`钩子中，在`handleDrawLineFrame`定义下方定义一个新的旋转处理器，`handleRotationFrame`。为了这个测试的目的，它不需要做太多，只需将角度设置为新的值：
- en: '[PRE49]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can make use of that to call `requestAnimationFrame` when a rotation command
    is being animated. Modify the last section of the `useEffect` hook to look as
    follows, ensuring that you add `isRotating` to the dependency list. The test should
    pass after this change:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以利用这个来在旋转命令动画时调用`requestAnimationFrame`。修改`useEffect`钩子的最后部分，使其看起来如下，确保你将`isRotating`添加到依赖列表中。更改后测试应该通过：
- en: '[PRE50]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s add a test to get the duration in and use it within our calculation.
    This is essentially the same as the last test, but with a different duration and,
    therefore, a different expected rotation:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个测试来获取持续时间并在我们的计算中使用它。这基本上与上一个测试相同，但具有不同的持续时间，因此预期的旋转也不同：
- en: '[PRE51]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To make this pass, first, we need to define `rotateSpeed`. You can add this
    definition just below the definition for `movementSpeed`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，首先，我们需要定义`rotateSpeed`。你可以在`movementSpeed`定义下方添加这个定义：
- en: '[PRE52]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, update the conditional at the bottom of the `useEffect` handler to calculate
    the duration for the `rotate` command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`useEffect`处理器底部的条件，以计算`rotate`命令的持续时间：
- en: '[PRE53]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Update `handleRotationFrame` to use the duration to calculate a proportionate
    angle to move by:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`handleRotationFrame`以使用持续时间来计算一个成比例的角度来移动：
- en: '[PRE54]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Just as with `handleDrawLineFrame`, we need to ensure that we can handle start
    times other than `0`. Add the following test:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`handleDrawLineFrame`一样，我们需要确保我们可以处理除`0`之外的其他起始时间。添加以下测试：
- en: '[PRE55]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Make that pass by adding the `start` and `elapsed` variables. After this, the
    test should be passing. You’ll notice the similarity between `handleDrawLineFrame`
    and `handleRotationFrame`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加`start`和`elapsed`变量来使那个通过。之后，测试应该通过。你会注意到`handleDrawLineFrame`和`handleRotationFrame`之间的相似性：
- en: '[PRE56]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a test to make sure we’re calling `requestAnimationFrame` repeatedly. This
    is the same test that we used for the `drawLine` handler, except now we’re passing
    in the `rotate90` command. Remember to make sure the test belongs in the nested
    context, so you can be sure that there’s no name clash:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试以确保我们反复调用`requestAnimationFrame`。这个测试与用于`drawLine`处理器的测试相同，但现在我们传递的是`rotate90`命令。请确保测试属于嵌套上下文，这样你可以确保没有名称冲突：
- en: '[PRE57]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To make this pass, we need to do a couple of things. First, we need to modify
    `handleRotationFrame` in the same way we did with `handleDrawLineFrame`, by adding
    a conditional that stops animating after the duration has been reached. Second,
    we also need to fill in the second part of the conditional to set the turtle location
    when the animation is finished:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，我们需要做几件事情。首先，我们需要像修改`handleDrawLineFrame`一样修改`handleRotationFrame`，通过添加一个条件，在持续时间到达后停止动画。其次，我们还需要填写条件的第二部分，以设置动画完成后乌龟的位置：
- en: '[PRE58]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Handling the end animation state
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 处理结束动画状态
- en: 'This `else` clause wasn’t necessary with the `drawLine` handler because, as
    soon as a line finishes animating, it will be passed to `StaticLines`, which renders
    all lines with their full length. This isn’t the case with the rotation angle:
    it remains fixed until the next rotation. Therefore, we need to ensure it’s at
    its correct final value.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`else`子句在`drawLine`处理器中不是必要的，因为一旦线条动画完成，它将被传递到`StaticLines`，渲染所有线条的全长。但这与旋转角度不同：它保持固定，直到下一次旋转。因此，我们需要确保它处于正确的最终值。
- en: 'We’ve got one final test. We need to increment the current animation command
    once the animation is done. As with the same test in the previous section, this
    test should live *outside* the `describe` block we’ve just used since it has a
    different test setup:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有一个最后的测试。一旦动画完成，我们需要增加当前动画命令。与上一节中的相同测试一样，这个测试应该位于我们刚刚使用的`describe`块之外，因为它有不同的测试设置：
- en: '[PRE59]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To make that pass, add the call to `setNextCommandToAnimate` into the `else`
    condition:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使那个通过，将`setNextCommandToAnimate`的调用添加到`else`条件中：
- en: '[PRE60]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: That’s it! If you haven’t done so already, it’s worth running the app to try
    it out.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你还没有这样做，运行应用尝试一下是值得的。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve explored how to test the `requestAnimationFrame` browser
    API. It’s not a straightforward process, and there are multiple tests that need
    to be written if you wish to be fully covered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何测试`requestAnimationFrame`浏览器API。这不是一个简单的过程，如果你希望完全覆盖，需要编写多个测试。
- en: Nevertheless, you’ve seen that it is entirely possible to write automated tests
    for onscreen animation. The benefit of doing so is that the complex production
    code is fully documented via the tests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你已经看到为屏幕上的动画编写自动化测试是完全可能的。这样做的好处是，复杂的生产代码通过测试得到了完全的文档记录。
- en: In the next chapter, we’ll look at adding WebSocket communication into Spec
    Logo.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将WebSocket通信添加到Spec Logo中。
- en: Exercises
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Update `Drawing` so that it resets the turtle position when the user clears
    the screen with the **Reset** button.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Drawing`，以便当用户使用**重置**按钮清除屏幕时，重置海龟位置。
- en: Our tests have a lot of duplication due to the repeated calls to `triggerRequestAnimationFrame`.
    Simplify how this is called by creating a wrapper function called `triggerAnimationSequence`
    that takes an array of frame times and calls `triggerRequestAnimationFrame` for
    each of those times.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的测试有很多重复，因为重复调用`triggerRequestAnimationFrame`。通过创建一个名为`triggerAnimationSequence`的包装函数来简化调用方式，该函数接受一个帧时间数组，并为这些时间中的每一个调用`triggerRequestAnimationFrame`。
- en: Loading an existing script (for example, on startup) will take a long time to
    animate all instructions, and so will pasting in code snippets. Add a **Skip animation**
    button that can be used to skip all the queued animations.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载现有脚本（例如，在启动时）将花费很长时间来动画化所有指令，粘贴代码片段也是如此。添加一个**跳过动画**按钮，可以用来跳过所有排队的动画。
- en: Ensure that the **Undo** button works correctly when animations are in progress.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在动画进行时**撤销**按钮能正确工作。
