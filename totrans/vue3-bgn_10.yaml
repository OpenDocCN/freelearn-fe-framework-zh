- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Routing with Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single-page applications** (**SPAs**), such as the one offered by Vue.js,
    provide an architecture built upon a single page. This methodology prevents the
    page from fully reloading and offers an improved user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: As your application grows, you will find the need to create different views
    in your application. Even if the term *SPA* can lead to the understanding that
    your application will be built on a single page, the truth is far from it.
  prefs: []
  type: TYPE_NORMAL
- en: Most frameworks, including Vue.js, offer packages aimed at recreating the routing
    system available in other frameworks such as PHP, .NET, and more. The routing
    functionality offered by SPA frameworks provides the best of both worlds. It offers
    developers a complete routing toolkit, while still providing the same user experience
    expected by SPA frameworks. The router package used in Vue.js is called vue-router.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use routing in your Vue.js application.
    At the end of the chapter, you will have a good understanding of vue-router and
    its configuration, and how routes are defined and used. You will be able to create
    basic, dynamic, and nested routes and navigate to them using different methodologies.
    Lastly, you will learn how to improve your user experience with the use of `redirect`
    and aliases.
  prefs: []
  type: TYPE_NORMAL
- en: We are first going to learn about vue-router by covering its configuration.
    We will then learn how to implement our first route and route navigation by creating
    a couple of static pages. Next, we will introduce dynamic routes by defining a
    user profile page. Then, we will add another level of navigation by splitting
    the user view into a user profile and user posts using nested routes. Finally,
    we will complete the chapter by familiarizing ourselves with `redirect` and `alias`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is going to be broken down into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vue-router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating between routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic route matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing routes with `alias` and `redirect`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the branch is called `CH10`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:
    `git``switch CH10`.'
  prefs: []
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vue-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: vue-router is the official router package built and maintained by the Vue.js
    core team and community members. Just like other packages that we have introduced
    so far in the Companion App, also vue-router was automatically set up for us when
    we initialized our application using Vite.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the file structure and configuration required
    for vue-router and introduce some of the syntax used when working with routes.
  prefs: []
  type: TYPE_NORMAL
- en: vue-router offers a standard set of functionalities that are expected from a
    router. So, if you have previously worked with routers in other languages, most
    of what we will cover will sound familiar, but it is still worth a read as the
    syntax may be different.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about vue-router configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s first start by learning how to best configure the router in an application.
    In fact, even if vue-router is usually preset by tools such as **createVue** and
    **Vite**, it is important to understand how it is set behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration required for the plugin to work is stored in a file commonly
    named `router.js`. or an `index.js` file within a folder called `router`.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the file is stored within the `router` folder.
  prefs: []
  type: TYPE_NORMAL
- en: All plugins need to be registered in main.js
  prefs: []
  type: TYPE_NORMAL
- en: All plugins must be registered in `main.js` before they can work. So, if you
    ever want to find the configuration file or information for a plugin that is currently
    loaded in your application, you can open the `main.js` file and search for the
    `app.use(pluginName)` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the syntax you might find in this `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go over the important points of the preceding configuration. First, we
    can talk about the `createRouter` method. This method provided by the vue-router
    package creates an instance of the router that can be attached to a Vue application.
    This method expects an object including the router configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it is time to look at the first entry of the configuration object, `history`.
    The `history` property defines how your application will navigate between the
    different pages. In standard apps, this is usually achieved by changing the website
    URL to the desired page – for example, by appending `/team` to the URL to visit
    the Team page. Let’s look at a couple of different configurations that can be
    used to set our `history` property.
  prefs: []
  type: TYPE_NORMAL
- en: Hash mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method is achieved by using `createWebHashHistory`. This method is provided
    by the vue-router package, and it is the easiest one to implement as it will not
    require any server-side configuration. When using hash mode, an actual hash (`#`)
    is going to be added between the base URL and our routes. With this configuration,
    accessing the Team page can be done by visiting `www.mywebsite.com#team`.
  prefs: []
  type: TYPE_NORMAL
- en: This method can impact your SEO negatively, so if your application is accessed
    publicly, you should invest time and set up the next available method, web history
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5/web history mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML5 mode can be configured by using the `createWebHistory` method. With this
    history mode, our website will act as a standard site with its route being served
    directly after the website URL (e.g., `www.mywebsite.com/team`).
  prefs: []
  type: TYPE_NORMAL
- en: Because SPA websites are built on a single page (hence the name), they can just
    serve the application from one single endpoint (the website base URL). So, deploying
    our site and trying to access the Team page directly would result in a `404` page
    (not found).
  prefs: []
  type: TYPE_NORMAL
- en: Solving this issue is a trivial task in today’s hosting site, as all that is
    needed is a catch-all rule that ensures site navigation is funneled to the SPA
    entry point. If you wish to use this method, a little googling will help you find
    the instructions you need to properly set this in your hosting provider.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are using web history. This is my default history setting, not
    only because it improves SEO but also because it has been the normal way to navigate
    our sites for years and I like to keep things consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it is time to cover the last entry of our configuration: routes.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have reached the most important part of our router configuration, the actual
    routes. The word *route* defines the ability of our application to direct a user
    to a specific page. So, when declaring routes, we define the pages a user can
    visit on our site.
  prefs: []
  type: TYPE_NORMAL
- en: To declare a route, we require two pieces of information, `path` and `component`,
    but I usually prefer to always include a third one called `name`.
  prefs: []
  type: TYPE_NORMAL
- en: The `path` attribute is used to define the URL that needs to be accessed for
    this route to be loaded. So, a path of `/` will be delivered if the user navigates
    to the base of your site, while a path of `/team` would be accessible on `www.mysite.com/team`.
  prefs: []
  type: TYPE_NORMAL
- en: The `component` attribute is the Vue component expected to be loaded when this
    route is accessed. Lastly, we have `name`. Adding this parameter to all our routes
    is good practice as `name` is used to navigate a route programmatically. We will
    cover this in more detail later as we will learn how to navigate within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know all the different aspects of a route, let’s try to decode what
    route was declared in the previously shared code snippet. The snippets show a
    route directing the user to the base path of our site (`path` is `/`), with the
    `name` value of `home`, which will load a `HomeView.vue` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have learned how to configure a Vue instance, but there is one
    more step needed before our routes can function properly: adding `RouterView`
    to our application.'
  prefs: []
  type: TYPE_NORMAL
- en: We have defined which component to load for a given URL, but we have yet to
    tell our Vue application where to load this component.
  prefs: []
  type: TYPE_NORMAL
- en: The way the router works is by replacing the content of our application every
    time a user navigates to a different page. So, in very simple terms, a router
    can be defined as a huge `if/else` statement that renders the component depending
    on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the router to work correctly, we are going to add a component called
    `<RouterView>` to the main entry point of our application, the `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From this stage onward, vue-router is going to take ownership of what is displayed
    on the screen using the route definition we defined in our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try to add a new router navigation for a static page called **Privacy**.
    This is just going to include some dummy text for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new page, we need two steps: a route defined in our `routes` array
    and a component that will be loaded when that route is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: Components that are used as routes are stored in a folder called `views`. If
    we access this folder, we see that we currently have two views set, `Home` and
    `About`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Folder tree showing the content of the views folder](img/B21130_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Folder tree showing the content of the views folder'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add a new file to our folder called `PrivacyView.vue`. It is
    common to match the filename with the route’s name. Because this file will be
    static, we will re-use the layout defined in [*Chapter 9*](B21130_09.xhtml#_idTextAnchor120)
    when we learned about slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout used for the static page defined as `StaticTemplate.vue` accepts
    three different named slots: a heading, a footer, and a default template used
    for its main content. Our `PrivacyView.Vue` file content should be defined like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the file content just defines two slots (`heading`
    and `default`) and is missing the footer. This has been done on purpose as the
    footer has a default value that we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before our new component can be visited and displayed we need to add it to
    our route. Let’s do this by going back to `index.js` within the `router` folder
    and adding the route for our Privacy page within the `routes` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our new page views are first imported at the top of the page as a normal Vue
    component and then assigned to the new route. Just as we mentioned before, routes
    require three values. First, we set the `path` value as `/privacy`, then we defined
    a `name` value of `privacy` for future programmatic navigation, and lastly, we
    assigned the imported `PrivacyView` component to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes, we should be able to see our page by accessing `http://localhost:5173/privacy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Screenshot of the Privacy page](img/B21130_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Screenshot of the Privacy page'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to configure vue-router, introduced routes
    and defined how they are used by the application to render pages, and finally,
    talked about `<RouterView>` and how vue-router uses it to display the correct
    page to our visitors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to navigate between different
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating between routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have learned how to create our routes and how to navigate through
    them by loading the URL directly in the browser. In this section, we will learn
    how to navigate between different routes directly in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that we could define our navigation using a simple `<a>` tag, but
    that will force the app to fully reload on any navigation and so will go against
    the whole architecture of a SPA, which offers a “reload-free” experience.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, vue-router offers components and methods that will handle
    navigations without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: While using vue-router, navigation can be achieved in two different ways. One
    uses a component called `<router-link>` while the other is triggered programmatically
    using `router.push()`. Let’s see both methods in action and learn when to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Using the <router-link> component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `<router-link>` component to navigate within your application is a
    simple task, as it uses the same syntax offered by the native HTML `<a>` element.
    Behind the scenes, `<router-link>` is just an anchor tag with added functionality
    that prevents the app from fully reloading while navigating.
  prefs: []
  type: TYPE_NORMAL
- en: Our Companion App has three different pages, but there is nowhere to access
    them unless we enter the URL directly. Let’s go and fix this now by adding two
    links in our sidebar, one for each static page we have created so far.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the main page is `HomePage.vue`, but the actual sidebar is just
    a child component of this page and can be found in the `organisms` folder under
    the name `SideBar.vue`. Now that we have located the file, it is time to add our
    router links.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the component from vue-router in the `script` section of the
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the links in our sidebar, directly after the `Update` `Time` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `router-link` component accepts a property called `to`. This property can
    accept the URL that the browser needs to navigate to or a `route` object, which
    we will cover later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have specified the value of the `to` property to be equal
    to `privacy` for the link directing to the `about` for the page navigating to
    the **About** page.
  prefs: []
  type: TYPE_NORMAL
- en: After these two changes, the application will have two new links in the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Companion app sidebar with the router links](img/B21130_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Companion app sidebar with the router links'
  prefs: []
  type: TYPE_NORMAL
- en: Because router links are just simple `<a>` elements, they inherit the style
    of the anchor that was defined by the project template.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most cases, navigating using the router link component is all you need,
    but there are some situations in which you may find it beneficial to navigate
    through the app directly in the code.
  prefs: []
  type: TYPE_NORMAL
- en: There is no real difference in navigating using the `router-link` component
    or programmatically, and both methods are offered to ensure that your code can
    be clean and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic navigation is useful when attached to a piece of logic. Being able
    to trigger the navigation manually helps you take control of the flow of the data,
    ensuring that your code is well written and that the user receives the best experience.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to navigate to a different page, we can use a method offered by the
    `router` object called `push`. This method, just like `<router-link>`, can accept
    the URL or a `route` object.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add another link, but this time, a simple anchor element, and
    trigger the navigation using the `onclick` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to add an import from the vue-router package called `useRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use this method to access the `router` instance. This just needs to
    be done once per file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create a method that will handle the `click` event of
    our anchor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Triggering navigation programmatically allows us to trigger side effects that
    would not be possible if using a `<router-link>` component, – for example, conditionally
    navigate a user to different pages depending on a value returned from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are going to create a new anchor in the HTML section of our component.
    This element is going to use the `navigateToPrivacy` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have now completed the first part of this chapter. At this stage, you have
    learned the basics of vue-router and gained an understanding of how to define
    routes, how they work, and how to navigate between the different pages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will learn about more advanced topics such as nested
    routes and dynamic route matching.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic route matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are tasked to build a simple portfolio site, basic routes are going to
    be just fine. However, as you start to work on more complex sites such as blogs,
    you will need more complex routing. In this section, we are going to learn about
    dynamic route matching. Dynamic route matching is used to define routes that require
    one or more parameters to be dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: All the routes that we have defined until now were static and did not change.
    So, we had the `/about` endpoint that would render the `/` path that would welcome
    the home page of our site. What would happen if we wanted to develop a blog post
    with our current knowledge? After our first blog post, we would write a route,
    `/blog/1`, then after the second, we would have to create another route, `/blog/2`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Defining routes statically like this is not an ideal solution, and this is where
    dynamic route matching comes into place. Dynamic route matching allows us to create
    a pattern, for example, `blog/:blogId`, and then let the application render a
    specific page that uses the defined argument to render another specific page.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about this great feature, we are going to enhance our Companion App
    by adding a new feature that will allow us to open a specific user profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for this task are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the ability for the user to open a user profile page from
    the main view of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to create a new route that will display a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to create a new component that will display the user with all its
    information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to develop this backward, starting by creating the user-specific
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user profile page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first task requires us to create a new page that will later be used by our
    route as the content of our user page. Just like all other pages, this will also
    live in a folder called `views` and will be called `UserView.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: In this component, we are going to first load a specific user profile and then
    display its information on the screen. To ease development, we are going to hardcode
    `userId` so that we can see the correct information on screen for now, and then
    remove this later after our dynamic route is fully set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like a simple component, we will need to define three different parts:
    the HTML, the logic required to fetch the correct information, and the styles.'
  prefs: []
  type: TYPE_NORMAL
- en: To help you prepare for the real world, you could go a step further than this
    book and learn what information we would need from the API to develop the page.
    When developing from an external source, such as an API or a Content Management
    System (`user` object, but what will that include? Would it have a name? Would
    it have a date of birth, and if so, what would the format be?
  prefs: []
  type: TYPE_NORMAL
- en: 'All these questions are usually answered by the `user` object, which is usually
    available directly from API and CMS documentation. In our case, since we are using
    [dummyapi.com](http://dummyapi.com), the information about the API models can
    be found here: [https://dummyapi.io/docs/models](https://dummyapi.io/docs/models).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the model, we can find our specific one, called **User Full**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Model information for User Full](img/B21130_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Model information for User Full'
  prefs: []
  type: TYPE_NORMAL
- en: Model information such as that shown in *Figure 10**.4* can help us develop
    a well-structured code base and make the correct choices ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a good understanding of the object that the API will return,
    it is time to build our component. Let’s start by defining the HTML section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The HTML markup makes use of the `v-for` directive to loop through a preselected
    list of properties that we want to display from the user object received from
    the API. We are then using `v-if` to add some further validation to ensure that
    our application will not break in case the API changes its returned object. The
    HTML will generate a simple design that will render a pair of labels/input for
    each property, but further development could be made to improve the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to create the logic required to fetch and assign our user
    information. As previously mentioned, we are going to hardcode an ID of `657a3106698992f50c0a5885`,
    which will later be changed to be dynamic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The API logic is very similar to other requests that we have already made in
    this book. The only differences are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `url` variable is not a static value but dynamic as it makes use of `userId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are switching the full value of `user`, we had to use `Object.assign`.
    This is required when changing the entire value of a `reactive` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `valuesToDisplay` has been set to be a simple array and it is not
    using either `ref` or `reactive`. This has been done on purpose as this array
    is not expected to be modified and it is therefore not required to be reactive.
    At the start of your Vue.js development, it is probably best to always define
    a variable as `ref`/`reactive` as something that you expect to be static could
    easily turn into dynamic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user profile component is now complete, but it is still not accessible from
    the UI as there is no component or view that loads it. We can fix this in the
    next section where we will introduce dynamic routes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user profile route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The creation of a dynamic route follows the same flow as a normal route. All
    routes are defined by adding an entry into the `route` array within the route
    configuration file in `router/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like before, we added three different properties to our `route` object:
    `name` (which will provide us with a friendly name to associate with the route),
    `component` (which will show us which component to load – in our case, our newly
    created `UserView` component), and finally, `path`.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the `path` value has a different syntax compared to
    the previous routes and this is what makes this path a dynamic route. In fact,
    in previous cases, the URL created by the route was unique and static, while in
    this case, we have added a dynamic part to the URL called `:`) preceding the word
    `userId`. So, this path does not translate into `website.com/user/:userId`, but
    it defines a URL that expects a value to replace `:userId`. In our example, the
    path would probably look like `website.com/user/1234` or `website.com/user/my-user-id`.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, the value that replaced the parameter is then going
    to be available within the Vue component and can be used to render a unique page.
    In our case, the ID provided will be used to load the information of a specific
    user, so accessing URLs with different IDs will render pages with different user
    information.
  prefs: []
  type: TYPE_NORMAL
- en: You can have multiple parameters in a route
  prefs: []
  type: TYPE_NORMAL
- en: Did you know you can have multiple dynamic parameters in a single route? Each
    is going to be defined using the same syntax. For example, you could have a URL
    defined as `/account/:accountId/user/:userId`. The component that will load this
    route will have access to two dynamic parameters, one containing the account ID
    and the other the user ID.
  prefs: []
  type: TYPE_NORMAL
- en: Adding navigation using the route name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the user route is defined, it is time to make some changes to our design
    to ensure that the users can navigate to it.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we could easily achieve this task by using the navigation we learned
    in the previous section, we are going to take this opportunity to introduce a
    new syntax that navigates using the route name.
  prefs: []
  type: TYPE_NORMAL
- en: When defining a new route, we provided both a `path` and `name` value for each
    route item. Navigating using a path is simple for a basic URL, but as things get
    complicated, it may be cleaner to use the route name to define the navigation
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a name for every route is a best practice highly adopted in routing
    systems, as it allows for more readable and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open `SocialPost.vue` and add the navigation logic to the user avatar.
    To accomplish this task, we are first going to add a `click` event to the `<``img>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We attached a method called `navigateToUser` to the `click` event. This method
    does not have any argument as we will be able to access everything we need directly
    from the `component` scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to create the `navigateToUser` method in the `<script>`
    block of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To add our programmatic navigation, we first imported the `useRoute` method,
    then we initiated the route with `const router = useRouter();`, and finally, we
    defined our method.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating using the name utilizes the same method used with the path navigation,
    `router.push`. The difference lies in the value passed to it. While, in previous
    examples, we just passed a single string, we are now passing an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This object includes the route name and a list of parameters, which, in our
    case, is equivalent to `userId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Both the name and the parameters need to match the information defined in the
    `route` array. This information is case-sensitive, so take extra care when applying
    it to your navigation object.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application and clicking on the user avatars will redirect to a
    URL such as `http://localhost:5173/user/60d21b4667d0d8992e610c85`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can celebrate our work as completed, we need to do one more step,
    which will require us to read the value from the route and use it to load the
    correct user. The ID used to load the user from the API has been hardcoded, and
    clicking on different avatars will result in the same user being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Reading route parameters in a route component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a task requires you to create a dynamic route, chances are that you will
    need one or multiple dynamic parameters to render the page correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a blog page, the dynamic parameters will be the blog ID;
    if you are loading a book library, the parameters could be the category or the
    author to filter by. No matter the reason, using a dynamic URL will require you
    to read and use that value within your component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading route parameters can be achieved using the `params` object available
    within the `route` package. Let’s go back to `UserView.vue` and modify the code
    to load `userId` dynamically from the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To load our parameters from the route, we made three changes to our view. First,
    we imported `useRoute` from the vue-router package. Then, we created an instance
    of the route using `const route = useRoute()`, and finally, we removed the hardcoded
    `userId` and replaced it with the route parameters using `route.params.userId`.
  prefs: []
  type: TYPE_NORMAL
- en: UseRouter versus UseRoute
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that, in previous components, we used `useRouter`, while
    in the current one, we used `useRoute`. These names are very similar, and their
    differences can easily be missed. `useRouter` is used when we need to have access
    to the router object – for example, to add routes, push navigation, and trigger
    before and after route actions – while `useRoute` is used to gain information
    on the current route, such as the parameters, path, or URL query information.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the dynamic route will be fully functional, and clicking a user
    avatar will load information for that specific user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: User view page displaying user information](img/B21130_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: User view page displaying user information'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about all the different aspects of dynamic
    routes. We have learned why they are needed and the problem that they try to solve,
    and we introduced their syntax by adding a dynamic route for the users within
    our `route` array. While doing so, we took the opportunity to learn about programmatic
    navigation using the `name` and `params` values of a route, and finally, we learned
    how to access route information, such as `params`, using the route object offered
    by the vue-router package to make our user view dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: While completing the section, we have also gone over previously learned topics
    such as components, directives, events, and so much more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go one step deeper and learn about nested routes.
    This will follow a similar flow to the current section and hopefully feel familiar
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPAs are very powerful but the addition of a well-structured router, such as
    vue-router, can help take SPAs to another level. The strength of a SPA relies
    on its ability to swap components on the fly without the need to refresh the page,
    but what if I told you that vue-router can go even deeper than a page layout?
    This is where nested routes come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes provide you with the ability to define routes within routes, multiple
    levels deep, to create a very complex layout. The concept of nested routes may
    sound complicated, but their use makes the application easier to develop and they
    are recommended for most applications.
  prefs: []
  type: TYPE_NORMAL
- en: When we created the main routes, we said that the page would be swapped entirely
    when on navigation; with nested routes, the concept is the same, but instead of
    swapping the full page, we just swap an internal part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Example of nested routes](img/B21130_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Example of nested routes'
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how nested routes work, let’s discuss the little example
    shown in *Figure 10**.6*. Imagine you have created a dashboard. While developing
    different parts of the dashboard, such as a `settings` view and an `analytics`
    view, you realize that there is a part of the layout that is shared. This may
    be the navbar, the sidebar, and even some features such as *print screen* or chat.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid duplicating these functionalities, we can use nested routes. In our
    example, we would have a parent route called `dashboard`, which will have a set
    of children – in our example, these will be a `settings` nested route and an `analytics`
    nested route.
  prefs: []
  type: TYPE_NORMAL
- en: The main `dashboard` route is going to include all the reusable components we
    mentioned previously, plus the addition of a `<RouterView>` component. This component,
    just as we did in the `app.vue` file at the start of this chapter, will be used
    by the router to render the appropriate route.
  prefs: []
  type: TYPE_NORMAL
- en: After this theoretical introduction of nested routes, it is time to apply this
    knowledge to our Companion App and learn how to use this new feature of vue-router.
  prefs: []
  type: TYPE_NORMAL
- en: Applying nested routes to the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going back to the user page to enable nested routes
    by adding the ability to toggle between the user profile and the user posts view.
  prefs: []
  type: TYPE_NORMAL
- en: The example we are going to develop is a very good use case and something that
    you may encounter in real-life development.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of nested routes is that the views have something in common. This may
    either be just the layout or some specific route parameters. A very common example
    of nested routes is an application that has tabs or offers a multi-step form.
  prefs: []
  type: TYPE_NORMAL
- en: Completing this task takes a couple of steps. First, we will create a file that
    is going to load a list of posts for the user. Next, we will rename the `userView`
    file to align with the new route, and finally, we will modify the `route` array
    to define the new nested view.
  prefs: []
  type: TYPE_NORMAL
- en: For the first step, I am going to provide you with just some guidance on how
    to complete the task, because I want to give you a chance to try and figure it
    out by yourself. If you get stuck, you can check the `CH10-end` branch, which
    includes the completed file.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements are to create a file that will load the user posts. This file
    is going to be called `userPostsView.vue` and will be located within the `views`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The logic of this file is going to be very similar to the `SocialPost.vue` file.
    In fact, the responses returned by both endpoints are the same, so this allows
    us to reuse most of the logic and the UI. For the scope of this book, we can copy
    the content of the `SocialPost.vue` file into our newly created file, but in a
    real example, we would have refactored the component so that we could have reused
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The only modification the file needs is to load `userId` from the `route` object,
    just like we did in `userView.vue`, and then change the URL used to load the information
    to be `{baseUrl}/user/${userId}/post?limit=10`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and developing a new component
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, “*How can you develop a component if you are not able
    to test it in the browser?*”. It is common practice when developing new components
    to create dummy routes that can be used to test new components. In this case,
    our route would need to have access to the user ID from the path, so a simple
    way to test it out is to swap it in the `route` array so that the new component
    is returned when accessing the existing `user` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to rename the `userView.vue` file to align with the route
    changes that we are going to make. The new name is going to be `userProfileView.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to learn the syntax required to create a nested route.
    So, let’s open the `index.js` file within the `router` folder and see the changes
    required to split the `user` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The syntax required for nested routes is quite intuitive and it uses the knowledge
    that we gained in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes are defined within our existing `user` route and denoted by the
    `children` property. This property accepts an array of routes that is defined
    with the same structure that we used before with `name`, `path`, and `component`.
    The only thing that you need to consider here is that when defining nested routes,
    we are not at the root of the project anymore, so the value assigned to `path`
    is added to the existing one. So, in this case, the full path of the `userProfile`
    route will be `mysite.com/user/:userId/profile`.
  prefs: []
  type: TYPE_NORMAL
- en: The user profile and the user posts views are ready to be visited by navigating
    to `http://localhost:5173/user/:userId/profile` and `http://localhost:5173/user/:userId/posts`,
    respectively (where `userId` is replaced with an actual user ID).
  prefs: []
  type: TYPE_NORMAL
- en: A nested path does not mean a nested layout
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that, with the example in *Figure 10**.6*, we mentioned
    that nested routes can share a layout and be used to update just part of the page
    such as an inner tab, but in our case, this has not been the case as we are using
    our nested routes to update the page fully. What we did is not uncommon. In fact,
    the use of nested routes is not just achieved to share a layout but also to share
    specific data. In our case, the use of nested routes was used to allow both routes
    to share the `path` parameters named `userId`. If you want to practice further,
    you could create a component for the user path and use it as a layout for the
    user profile and posts route. Just remember to add a `<RouterView>` component
    in your HTML to define where vue-router should append the routes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned what nested routes are. We then updated our Companion
    app to use a nested route to load two different user views. We also created a
    new view to display user posts. Next, we learned and applied the syntax required
    to implement nested routes. The final product is the ability for us to navigate
    to two different pages, one that displays the user profile information and one
    that displays the user posts.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have moved the `user` route to one of its children.
    Because of this, if we access the `user` route (e.g., `http://localhost:5173/user/60d21b4667d0d8992e610c85`),
    we will be greeted with an empty page. This is not a bug but is expected because
    we have not actually declared any route that satisfies that specific endpoint.
    We are going to fix this now by creating an alias.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing routes with alias and redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to create new routes, but there is another skill
    required to master vue-router: **alias** and **redirect**.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `alias` and `redirect` allow you to reuse existing routes by navigating
    the user from one route to another and are very useful when you want to create
    SEO-friendly URLs. The only distinction between the two features is the result
    that the user sees within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Using our previous example, we have found ourselves in a situation in which
    a route is currently unusable because it has no component or view attached to
    it. This is a common scenario when working with `children` routes and can easily
    be solved with an alias or redirect.
  prefs: []
  type: TYPE_NORMAL
- en: To solve our empty route problem, we are going to use `redirect` to navigate
    all users that land on the `user/:userId` path to its `children` path, `user/:userId/profile.`
  prefs: []
  type: TYPE_NORMAL
- en: Creating an alias or redirect is just the same as a simple route, with the only
    added property of `redirect` or `alias` used to specify what view should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change our user view to include a `redirect` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the simple addition of the highlighted code, the user is now going to be
    redirected from one path to another. If you try to access the path `http://localhost:5173/user/60d21bf967d0d8992e610e9b`,
    you will see the URL change to `http://localhost:5173/user/60d21bf967d0d8992e610e9b/profile`
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `redirect` could either be an object including a name, as in our
    example, a simple path, or even be a complex object with `name`, `params`, and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to introduce `alias`. Previously, we saw that we can use `redirect`
    to transport the user from one route to another. But what if you just want to
    ensure that the users are able to access a given route using multiple URLs? A
    good example could be the need for us to create a “friendly URL,” which is a URL
    that is simple for a user to type or remember. It is very common for websites,
    such as e-commerce websites, to define a specific URL when you are navigating
    through the website, while also offering a friendly URL that is usually what is
    indexed and used by Google.
  prefs: []
  type: TYPE_NORMAL
- en: Just to give an example, you may want to render the same route if the user accesses
    [mywebsite.com/p/123](http://mywebsite.com/p/123) and [mywebsite.com/product/123](http://mywebsite.com/product/123).
    To achieve this, we can use aliases.
  prefs: []
  type: TYPE_NORMAL
- en: When using aliases, we can define one or more URLs that can be matched with
    the same route. Aliases accept a string or an array of strings that match the
    different URLs for a given route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pretend, for example, that we would like our static `/privacy` page to
    also render if the user accesses `/privacy-policy`. To achieve this, we would
    write the following rule in the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After adding the alias in our route declaration, our Companion app will render
    the Privacy page for both `localhost:5173/privacy` and `localhost:5173/privacy-policy`.
  prefs: []
  type: TYPE_NORMAL
- en: In this small section, we have introduced the methods of `alias` and `redirect`.
    We have defined the use case that these two methods solve and their differences.
    Lastly, we have implemented the method in our own route definition to prevent
    our user from seeing a blank page when accessing the `user` endpoint and provided
    a simple example to showcase aliases by defining two endpoints for one route.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about vue-router, the first external package
    that is part of the Vue core set of libraries to be covered in the book. The chapter
    introduced us to the package by covering its configuration and settings such as
    history mode. We then learned about the usage of routes, how to define them, and
    how to navigate to them.
  prefs: []
  type: TYPE_NORMAL
- en: After learning the basics of vue-router, we moved on to more advanced topics
    such as dynamic routes and nested routes.,
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned about `alias` and `redirect` to complete our basic understanding
    of the router and how to use it to build both simple and complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to learn about another core package of the
    Vue ecosystem: **Pinia**. This package is used to define and share state across
    our application.'
  prefs: []
  type: TYPE_NORMAL
