- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Flow Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we have focused on understanding the Vue 3 framework
    and providing a context to create web applications. In this chapter, we will focus
    on the way our components communicate with each other and share information to
    make our application happen. We have touched on this topic briefly previously,
    but now we will dive deep into some patterns by implementing them alongside each
    other. Applying an appropriate information workflow is an important skill that
    can make or break an application. In particular, we will see the following approaches
    and code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent-child-sibling communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a message bus using the **Singleton** and **Observer** patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a basic reactive state with composable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a centralized data repository with the powerful Pinia reactive
    store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing browser-provided alternatives to share and store information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting with reactivity, composables, and proxy patterns in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have done previously, we will be building one concept at a time, incrementing
    in complexity. By the end of this chapter, you will have seen clear examples of
    implementation so that you can decide when to apply each one based on the needs
    of your application. Some of these are more suitable for small applications, and
    others for large, complex ones. You will be better prepared to control the workflow
    of information for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will approach concepts and apply patterns to control the communication
    and flow of information between components. You should be able to follow through
    with the code presented in this text, but for a better understanding and context
    experience, you would benefit from inspecting the full application code for this
    chapter, available in the repository for this book: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are starting a new project, just follow the instructions for scaffolding
    one, as seen in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting Up a*
    *Working Project*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://packt.link/ZKTBJ](https://packt.link/ZKTBJ)'
  prefs: []
  type: TYPE_NORMAL
- en: Components’ basic communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen previously that a parent component and its children have a rather
    simple and straightforward way to communicate. Parents pass data as `props` to
    their children, and these raise events (`emits`) to capture the attention of the
    parent. Much like the comparability of parameters and arguments in functions,
    `props` receive simple data by copy, and complex types (objects, arrays, and so
    on) by reference. We could pass, then, a plain object with member functions from
    the parent to the child, and have the child run the functions to access the parent’s
    data. Even though this “works”, it is sort of a dark pattern or anti-pattern,
    as it hides the relationship and makes it difficult to understand the data flow.
    The proper way to pass data upward in the component tree is through events (`emits`).
    Having said this, we must point out that child components are “ignorant” of each
    other, meaning that they do not have a direct way to communicate among themselves.
    We could pass a reactive variable and have each component involved access it,
    and this is certainly a working alternative, if not a clean one. In some cases,
    this would provide a simple solution, but again, it can lead to hidden side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage in a clean way the workflow of data, we have several alternatives
    that follow good practices and design patterns. As a general rule and principle,
    the component that declares the variable is the owner of it, and it should be
    the one that manipulates it. With this in mind, in the most basic communication,
    the information needs to be maintained and manipulated by the parent component
    and shared among the children. We can leverage Vue’s reactive system to spread
    the information. The key here is that only the parent component will manipulate
    it. Let’s see how this works in practice with an example, implementing a small
    trivial application, as shown in *Figure 7**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Direct basic communication and reactivity](img/Figure_7.01_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Direct basic communication and reactivity
  prefs: []
  type: TYPE_NORMAL
- en: 'In this application, the parent component has three direct children and shares
    with them a reactive counter. All the components display a label with the value
    of the counter and have a button to trigger an increment... but only the father
    component performs the actual manipulation of the data. Vue handles the reactivity,
    meaning that when the parent modifies the value, the child components also receive
    them. Simple enough—let’s see the important parts of how this is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: /basic/ParentBasic.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this component, we declare a `_counter` reactive variable (line `//1`) and
    an `incrementCounter()` function to manipulate its value (line `//2`). We trigger
    this function in the parent button, on the click event, as seen in line `//3`.
    Now, to see this pattern implemented, we just pass our reactive `_counter` variable
    as a prop to each child component, and we link our `incrementCounter()` function
    to each child’s increment event (line `//4`). Simple enough—let’s see how each
    child implements its part:'
  prefs: []
  type: TYPE_NORMAL
- en: /basic/Child.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our child implementation is simple as well. We start by defining the props to
    receive the counter variable in line `//1`, and also our `increment` custom event
    so that we can notify the parent. In order to do that, we create a function in
    line `//2`. In our template, we display our prop in line `//3` and trigger our
    increment function in line `//4`. Notice that our child component does not modify
    the counter. That is the responsibility of the father component, so we respect
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is one that we will use quite often, but it does have some limitations.
    For example, what happens when the data needs to reach a parent, sibling, or grandchild?
    Do we pass data up and down the tree, even though components don’t use it? We
    could, but again, that is messy, verbose, and not the best way. We have better
    tools for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface Composition
    with Components*, we saw that a parent can pass data and functionality to any
    of their children down the tree, by using `provide` and `inject`. Since the example
    presented there was quite comprehensive, we will not repeat it here. I encourage
    you to review how the provision was created and injected. Instead of repeating
    ourselves, let’s move ahead with the next item in our agenda to share information
    anywhere in the component tree: implement a **message bus** (also called an **event
    bus**).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an event bus with the Singleton and Observer patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A message bus is an implementation of the *Observer pattern* that we saw in
    [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040), *Software Design Principles and
    Patterns*. As a short refreshment of the main concept, we seek to create an object
    or structure that receives and emits events that our components can subscribe
    and react to. This pattern runs independently of the component tree structure,
    so any *component and service* can make use of it. Visually, we can represent
    the resulting relationship as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A simplified view of a message bus relationship with components](img/Figure_7.02_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A simplified view of a message bus relationship with components
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, we can immediately see that each component is treated
    equally by the message bus. Each component subscribes one or more of its methods
    to a specific event, and at the same time has the same possibility to publish
    an event. This makes it very flexible, as events can also transport data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s bring down to code these concepts with an implementation example. We start
    by creating a service, using the Singleton pattern, that provides us with a message
    bus. In our case, we will just wrap the `mitt` package, which gives us this functionality
    (see https://github.com/developit/mitt#usage).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mitt` package can be installed in our application with the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our service then looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /services/MessageBus.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a singleton for an event emitter and dispatcher, meaning
    our message bus. In our example, we will dispatch text messages through it, and
    each receiving component will display it. Our components will then look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /bus/Child.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we start in line `//1` by importing our `messageBus` object
    (check the right path in your implementation) and declare a `message` reactive
    variable initialized to an empty string. Notice how we also import and use the
    `onMounted()` and `onBeforeUnmount()` methods from the component’s life cycle
    to subscribe and unsubscribe to the `message` event starting in line `//3`. The
    function that we register is in line `//4`, and it receives from the event a value
    that we pass to our internal variable to display in the template. We also need
    a function to publish the event to notify others, and that can be found in line
    `//5`. In this case, we publish the title of the component. This function is triggered
    by a button, as shown in line `//6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application example with some additional minimal styling, this
    code will result in something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A simple implementation of data sharing through the Observer
    pattern](img/Figure_7.03_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – A simple implementation of data sharing through the Observer pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach to handling the workflow of data is quite effective in what it
    does, but also has limitations. Events are a good way to notify multiple components
    simultaneously to trigger actions, independently of their place in the organization
    tree. When an application has multiple sub-systems that need to react to an application
    state change, this is a good pattern to apply. However, when dealing mainly with
    application data, this pattern has an important drawback: each component keeps
    an internal copy of the information. This makes the handling of memory quite inefficient,
    as the propagation of data means copying into different parts of our application.
    There are cases when this is necessary or desired, but certainly not for every
    case. If we have 50, 100, or 1,000 components subscribed to the same event, will
    all of them have the same copy of the data? If each component needs to handle
    and possibly modify the data independently of the others, this works fine... but
    if we want to make better use of Vue’s reactivity and improve our memory handling,
    we need to use a different approach. This is what we will see next with a basic
    reactive application state.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a basic reactive state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, a drawback of using a message bus to share data is the
    multiplicity of copies of the same data, including the overhead for the handling
    of the events. Instead, we can leverage Vue’s reactivity engine and, in particular,
    the `reactive()` helper constructor to create a single entity to hold our application
    state. Just like before, we can wrap this reactive object in a Singleton pattern
    to share it among components and plain JavaScript functions, objects, and classes.
    It's worth mentioning that this is one of the great advantages of Vue 3 and the
    new Composition API.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the example code, we will end with a basic example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A shared reactive object for state management](img/Figure_7.04_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A shared reactive object for state management
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous screenshot, the state in this case is shared
    (or accessed) by all the components of this example. Any of the child components
    can modify any of its values, and the change is reflected immediately across the
    application. In contrast with the previous examples, the implementation of this
    pattern is both simple and straightforward. Let’s dive into it by first creating
    a service with our reactive state:'
  prefs: []
  type: TYPE_NORMAL
- en: /service/SimpleState.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If this code seems simple, it is because indeed it is. We create a JavaScript
    file and import the `reactive` constructor from Vue (line `//1`). Then, we declare
    a reactive constant with an initial object (line `//2`). This will be the application
    state that we return through a `useState()` function, named following the model
    of composable components (line `//3`). This function is our module exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making use of this centralized state is also very simple, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: /simple/ChildSimple.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start our component by importing the `useState` factory function, and we
    declare a reactive constant using it (line `//1`). We use this reactive variable
    in our template just like any other (line `//2`), and in the same way, we can
    access directly the member fields of the object to modify them as with any other
    object, as you can see in line `//3`. Having done this, as one would expect, once
    a component modifies any value, the change gets propagated across the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple approach is very useful and fit for small to even medium-sized
    applications. It has many benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to implement and understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leverages Vue’s reactivity system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is flexible, as we can add new reactive members after initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It establishes a single source of truth meaning that our state is the centralized
    repository of the application data. There's no need to keep internal or private
    variables synchronized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you consider the options we have seen until now, this is a giant leap forward.
    However, there are some situations when these falls short:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when a function modifies its value in an asynchronous manner if
    other components made changes before it was resolved?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach does not allow us to handle computed data that needs to be implemented
    in each component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging could be hard as there is no specific support for developer tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned, this approach is suitable for simple needs. For a more robust
    approach, we will dig into the official central state management solution by the
    Vue project: **Pinia**.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a powerful reactive store with Pinia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Central state management is not a concept private only to Vue, and the same
    pattern can be found in other libraries and frameworks. Just as in our basic reactive
    example, **Pinia** is a central state management tool that provides us with a
    single source of truth, meaning that a change in one of its values will propagate
    reactively to the entire application wherever is used. This state is shared among
    components in the application and gives us access to the full range of reactive
    tools Vue provides through a well-defined interface. It is easier to understand
    Pinia if first we build an example to show the results of using it. Running the
    code example will give us something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Central state management with Pinia](img/Figure_7.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Central state management with Pinia
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we build a store that not only exposes a reactive state but
    also implements computed values. As an officially supported project, Pinia also
    exposes implementations of the Options and Composition APIs. To use Pinia, we
    need to first include it in our project with the following command in the project’s
    root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation, we should create a store and then attach it to our
    application so that it can be used by all the components. A store is like our
    reactive singleton from the previous section, meaning an object that will have
    reactive fields to be shared in our application, but also the related business
    logic. So, each store will have the following items: `data`, computed properties
    known as `getters`, and methods known as `actions`. We define each store in its
    own file as a module, defining each item. Using the Options API, a store would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Options API basic store
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this store, we start by importing the `defineStore` constructor from the
    `Pinia` package (line `//1`) and use it to create a store in line `//2`. This
    constructor receives two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the store, as a string. This has to be unique among the stores,
    as it is used internally as an ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An object with the store definition with the following members:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` (line `//3`): This is a function that returns an object. Notice that
    we do not declare it to be reactive. Pinia will take care of that.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getters` (line `//4`): This is an object whose members will become computed
    properties. Each member receives as the first argument the state of the store,
    as a reactive object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actions` (line `//5`): This is, again, an object whose members are functions
    that can access and modify the state but must do so by accessing it through the
    `this` keyword.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the Options API to define the store is a good way to understand the parts
    that make it up. However, the change of syntax between `getters` and `actions`
    could be confusing and lead to involuntary mistakes, as one accesses the state
    through an argument and the other by using the `this` reference. However, if we
    take a moment to look at the constructor, we can see that `getters` and `actions`
    are analogous to *computed properties and component methods* (functions). With
    that in mind, let’s see how to rewrite this store using the Composition API, and
    this is the one we will use in our example code:'
  prefs: []
  type: TYPE_NORMAL
- en: /stores/counter.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the Composition API makes the store look more like the rest of our application,
    as we apply the same approach. We start by importing from Vue the constructors
    we need in line `//1`, as with components using the same API. This time, when
    we use the `defineStore` constructor, instead of passing an object we pass a function
    (or arrow function) that will return the reactive properties and methods that
    make up the store. You can see this in line `//2`, and then the `return` object
    in line `//6`. As you can expect, inside that function we declare our reactive
    properties (line `//3`) and computed properties (line `//4`), and methods (line
    `//5`). Reactive properties will become, well, reactive properties. Computed properties
    will become our getters, and the functions will become the actions. This far,
    this syntax does not have the syntactic sugar we are used to using the `<script
    setup>` tag, but the body of the function is the same approach (state of mind)
    that we use with components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a store (and we could have many), before we can actually use
    it, we need to implement Pinia in our application. For that, in our `main.js`
    file, include the following highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: ./main.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This step is necessary to enable the Pinia engine for the entire application.
    What is left now is to import the store we want to use in our components that
    need it. For example, if you look into the example repository, you will find this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: /pinia/ChildPinia.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We import the store constructor in line `//1`, and we create our reactive object
    in line `//2`. To use their values or execute their methods, we use them directly
    as if they were regular objects using the dot (`.`) notation. Notice in line `//3`
    how we access the value of `in_range`, and later, in line `//4`, we execute the
    `increment()` function. As we would expect, any modification of the store values
    will be synchronized automatically across our application.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike previous methods, Pinia stores and states are traceable and show up on
    the developer tools. For applications of medium size and above, using Pinia is
    almost a requirement when a central state is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pinia is Vue 3’s official solution for central state management, replacing
    Vuex from the Vue 2 branch. In practice, they accomplish the same functionality,
    but the former has some advantages that made the Vue team select it and sponsor
    it. A deep review is not a topic for our purposes, but here is a short list of
    changes or advantages of Pinia:'
  prefs: []
  type: TYPE_NORMAL
- en: Different approach to stores. In Pinia, each store is its own module, and they
    are all dynamic. Vuex instead had one single store, with partitions in modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax and API for Pinia are simpler and less verbose than Vuex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better support for TypeScript and discoverability for the IDE’s autocomplete
    features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for both Options and Composition APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better internal use of Vue’s new reactive models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer tools support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A plugin architecture to extend Pinia.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The change from Vuex to Pinia makes it difficult to make a one-step replacement
    upgrade for projects that were using it. However, the Pinia team has published
    a nice migration guide on the official website that you can find here: [https://pinia.vuejs.org/cookbook/migration-vuex.html](
    https://pinia.vuejs.org/cookbook/migration-vuex.html). For a complete reference
    of all the options available with Pinia, I recommend reading the official documentation
    at [https://pinia.vuejs.org](https://pinia.vuejs.org).'
  prefs: []
  type: TYPE_NORMAL
- en: With Pinia, we have seen now the most common and relevant patterns to control
    the flow of data between components (and services!), but these are not the only
    ones available to us. We will see next the stores provided by default in modern
    web browsers, and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Browser data stores – session, local, and IndexedDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browsers provide other features to store data locally, which can be read not
    only by any other component but also by any script running on the same page. We
    will not talk about cookies, but the new methods provided as key-value stores:
    `SessionStore` and `LocalStore`. But these are not the only options, as browsers
    also provide a database called `IndexedDB` that offers much more storage space
    and can be accessed also outside the scope of our application’s window in a different
    thread. We will see how in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*, in more detail, while here, we will focus first on understanding
    the basic concept and limitations of each one.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SessionStorage` is a read-only object created for each page origin. It stores
    only string data that can be accessed and retrieved using a simple interface.
    This data exists only through the duration of the *browser tab* and persists during
    refreshes. A clear example of this use is to persist form data. The object is
    attached to the `window` object (`window.sessionStorage`) and can be accessed
    by any script on the page.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalStorage` is similar to `SessionStorage` in capabilities and data storage.
    It has the same interface and is restricted also to the same origin of the page.
    The main difference is that it persists beyond the life of the page and is shared
    among all the open pages of the same origin. Websites and applications can use
    it to store data and retrieve it throughout multiple sessions on the same browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SessionStorage` and `LocalStorage` share the same interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.setItem(item_name, item_data)`: Here, `item_name` is a string that uniquely
    identifies `item_data`, which is also a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.getItem(item_name)`: Retrieves the string data stored under `item-_name`,
    or null if not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.removeItem(item_name)`: Deletes the data by `item_name` from the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.clear()`: Removes all data from the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding methods represent the totality of API endpoints for both storages.
    Simple enough—we can serialize data to record it in these stores. For example,
    to store a JSON object, we would use the following (we can omit the `window` object
    reference, as it is considered a global object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, to retrieve it, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Both stores have some limitations and a few caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no standard limit set among browsers for how many characters each store
    can hold. Strings are stored in UTF-16, so each character can take from 2 bytes
    or more (see [https://en.wikipedia.org/wiki/UTF-16](https://en.wikipedia.org/wiki/UTF-16)),
    which makes calculation hard. The specifications recommend at least 5 MB for each
    storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When these storages run out of space, some browsers crash the page, while others
    prompt the user for consent to expand the storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to store and retrieve data is sequential, possibly blocking the render
    process and making the page/application look irresponsive... But this only happens
    in long operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `sessionStorage`, duplicating tabs will also duplicate the storage. Instead,
    for `localStorage`, both tabs will access the same information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither localStorage nor sessionStorage is reactive or provides listeners to
    watch when a value changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding limitations are in no way a threat or a suggestion not to use
    them. Instead, they are the boundaries and limits to using them, since all data
    is stored locally on the user’s browser, and nothing is sent back to the server
    (as cookies do).
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to these web storage objects, `IndexedDB` is a different system
    altogether. It is a full implementation of a transactional database that stores
    JavaScript objects under a unique key. We can open multiple databases, create
    connections to them, and define schemas, and all operations are asynchronous,
    so there is no application blocking. The size limit has also been extended, with
    a soft limit of 50 MB. If a database grows more than that, the user is prompted
    to consent to expand it, and more space is given. In theory, depending on the
    implementation in each browser, it could occupy as much space as available. In
    practice, each browser has its own way to negotiate available space with the local
    operating system, so no hard number can be given about its limits that would hold
    true in every case.
  prefs: []
  type: TYPE_NORMAL
- en: Curiosity
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome engine provides a flag to build the engine without limits to `IndexedDB`,
    save for the available disk space. This flag can also be activated in hybrid frameworks
    such as NW.js or when building the browser from source.
  prefs: []
  type: TYPE_NORMAL
- en: There is a major issue with `IndexedDB`, which is that its API is complicated
    and cumbersome, so it is very rare that an application would access it directly.
    Instead, since `IndexedDB` is so flexible and fast, there is a fair number of
    libraries that create their own database implementation on top of it or facilitate
    a simpler interface (using the Façade pattern, for example). A curated list of
    these libraries and frameworks can be found in the **Mozilla Developer Network**
    documentation (https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API#see_also).
    In our implementation examples for [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with Web Workers*, we will use one of these libraries. For the
    purposes of this chapter, just keep in mind that each browser provides you with
    a powerful database for your application, and you can access it through a variety
    of patterns and approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Experimenting with reactivity and Proxies patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is time to put into practice what we have learned in this chapter under the
    light of patterns we saw in [*Chapter 2*](B18602_02.xhtml#_idTextAnchor040), *Software
    Design Principles and Patterns*, with a small experimental project. We want to
    create an option to make `sessionStorage` data behave like a reactive central
    state manager so that we can use it in our components. Possible uses for this
    approach could be to persist user-entered data during refreshes, alert components
    of data changes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `SessionStorage` does not provide an API we can listen to, our approach
    will be to create a Proxy handler using the Decorator pattern, to match and keep
    synchronized the values in the store with an internal and private reactive property.
    We will wrap this in a *singleton* and use the *Central State* manager approach
    to share it in our application. Let’s start by creating our core service:'
  prefs: []
  type: TYPE_NORMAL
- en: /services/sessionStorage.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `service` module, we will use the native JavaScript implementation
    of a `Proxy` object to capture specific calls to the API of the `window.sessionStorage`
    object. The use of Proxy objects is rather advanced in JavaScript, so I recommend
    that you look at the documentation on MDN here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).
    We start by importing the `reactive()` constructor from Vue and then creating
    a plain object named `handler` (line `//1`), that will act as our proxy/decorator.
    This object will be placed to intercept the calls to the original `sessionStorage`.
    Inside it, we declare a `prop` property as reactive (line `//2)`), initializing
    it with an empty object. This object will be synchronized with the storage. Then,
    we create two traps (or interceptors): one for get or read operations (line `//3`),
    and another for set or write operations (line `//4`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `get()` function receives three arguments, of which we will use only two.
    The target refers to `sessionStorage`, and `prop` is the name of the method or
    attribute requested. Because `prop` can be either one, we test if it is a function
    with an `if` statement, and if so, we return a function that takes in all the
    arguments and returns the original function call with them. If it is not a function,
    then we retrieve the item from the store, test if it is part of our internal reactive
    property, and finally, return the value. This makes sure that our internal `props`
    object is in sync with values created before the decorator was implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set()` function is simpler, as we just take the value passed and store
    it in both places: our internal props and the store.'
  prefs: []
  type: TYPE_NORMAL
- en: With our handler ready, in line `//5`, we create a `Decorator` proxy object
    using a native JavaScript constructor and provide a `useSessionStorage()` function
    in line `//6` so that we can export it as a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our Decorator created, now we can use it in our components, with the same
    approach as is standard in Vue 3:'
  prefs: []
  type: TYPE_NORMAL
- en: /session_storage/ChildSession.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that now we can use this object as a Pinia store or a simple reactive
    object, and the value of `sessionStorage` will always be synchronized and persist
    even if we refresh the page. To view the full example, please check the implementation
    of the code example in the GitHub repository. When you run it, you will see a
    section like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Example of our reactive $sessionStorage object](img/Figure_7.06_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Example of our reactive $sessionStorage object
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we also implemented a parent component with an input element.
    When you modify the value, it is automatically synchronized and reflected in the
    children component, but also in `sessionStorage`. If you open the browser’s developer
    tools and navigate to the **Web Storage** section, you will see this reflected.
    Here is a screenshot of how this looks in Chrome, on an Ubuntu system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Session Storage showing the item from the example](img/Figure_7.07_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Session Storage showing the item from the example
  prefs: []
  type: TYPE_NORMAL
- en: In the same way we implemented this pattern for the session storage, we could
    also, with a few changes, apply it to local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen in detail the different approaches and methods
    to control the flow of data between our components, services, and persistent storage
    provided by modern browsers. We also took time to integrate our knowledge by experimenting
    with session storage and the Decorator pattern to create a reactive/persistent
    central state. We took time to differentiate between approaches, and we have seen
    code for the implementation of each method. All these new skills are used daily
    in the development of Vue 3 applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will investigate improving the performance of our application
    by using advanced JavaScript tools: web workers.'
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use these questions to review what you have learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which methods do we have available to share data between sibling components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a message/event bus, and when is it most useful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a central state management approach, and how can we implement it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between session and local storage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we see what information is stored in session or local storage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
