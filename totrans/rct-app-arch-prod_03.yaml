- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building and Documenting Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和记录组件
- en: In React, everything is a component. This paradigm allows us to split user interfaces
    into smaller parts, thus making it easier to develop applications. It also enables
    component reusability since we can reuse the same components in multiple places.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，一切都是组件。这种范式允许我们将用户界面分割成更小的部分，从而使开发应用程序更容易。它还使组件可重用，因为我们可以在多个地方重用相同的组件。
- en: In this chapter, we will build some components that we will use as the application’s
    user interface base. This will make the application UI more consistent and easier
    to understand and maintain. We will also learn how to document the components
    with Storybook, a great tool that can serve as a catalog of common application
    components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一些组件，我们将使用这些组件作为应用程序用户界面的基础。这将使应用程序的UI更加一致，更容易理解和维护。我们还将学习如何使用Storybook（一个优秀的工具，可以作为常见应用程序组件的目录）来记录组件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Chakra UI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chakra UI
- en: Building components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建组件
- en: Storybook
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storybook
- en: Documenting components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件文档
- en: By the end of this chapter, we will learn how to create and document reusable
    components that we can use for the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将学习如何创建和记录可重用的组件，我们可以使用这些组件来构建应用程序。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we get started, we need to set up the project. To be able to develop
    the project, you will need the following things installed on your computer:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要设置项目。为了能够开发项目，您需要在您的计算机上安装以下内容：
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**版本16或更高版本以及**npm**版本8或更高版本。'
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node.js和npm有多种方法。这里有一篇很好的文章，详细介绍了更多内容：
- en: '[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)'
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and you can extend its features via extensions. It can be downloaded from here:
    [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode**（可选）是目前最流行的JavaScript/TypeScript编辑器/IDE，因此我们将使用它。它是开源的，与TypeScript有很好的集成，并且您可以通过扩展来扩展其功能。您可以从这里下载：[https://code.visualstudio.com/](https://code.visualstudio.com/).'
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).
- en: 'The repository can be cloned locally with the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在本地克隆存储库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the repository is cloned, we need to install the application’s dependencies:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦克隆了存储库，我们需要安装应用程序的依赖项：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to provide the environment variables:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供环境变量：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了依赖项之后，我们需要选择与本章匹配的代码库的正确阶段。我们可以通过执行以下命令来完成：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will prompt us with a list of stages for each chapter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为我们显示每个章节的阶段列表：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the third chapter, so you can select `chapter-03-start` if you want
    to follow along or `chapter-03` to see the final results of the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三章，所以如果您想跟随，可以选择`chapter-03-start`，或者选择`chapter-03`来查看章节的最终结果。
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了章节，所有必要的文件将显示出来以跟随章节。
- en: To follow along with this chapter, you don’t need to make any changes to the
    code. You can use it as a reference to help get a better overview of the code
    base.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，您不需要对代码进行任何更改。您可以使用它作为参考，以帮助更好地了解代码库。
- en: For more information about the setup details, check out the `README.md` file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置细节的更多信息，请查看`README.md`文件。
- en: Chakra UI
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chakra UI
- en: Whenever we build a UI for an application, we must decide what to use for styling
    our components. In addition, we must also consider whether we want to make all
    components from scratch or use a component library with pre-made components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们为应用程序构建 UI 时，我们必须决定使用什么来为我们的组件进行样式设计。此外，我们还必须考虑我们是否希望从头开始构建所有组件或使用带有预制组件的组件库。
- en: The advantage of using a component library is that it gives us a productivity
    boost as we don’t have to implement components that have already been implemented,
    such as buttons, dialogs, and tabs. Also, some libraries come with great accessibility
    defaults out of the box, so we don’t have to think about it as much as we would
    if we built everything from scratch. These libraries can come with costs, such
    as difficult customizability or a significant impact on the final bundle size.
    On the other hand, they save us a lot of development time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件库的优势在于，它为我们提供了生产力提升，因为我们不需要实现已经实现过的组件，例如按钮、对话框和标签页。此外，一些库默认提供了出色的可访问性，因此我们不必像从头开始构建那样过多地考虑它。这些库可能存在一些成本，例如难以定制或对最终包大小有重大影响。另一方面，它们为我们节省了大量开发时间。
- en: For our application, we will use **Chakra UI**, a component library built on
    top of a combination of **emotion** and **styled-system**, which will allow us
    to write CSS in JavaScript in a consistent way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用 **Chakra UI**，这是一个基于 **emotion** 和 **styled-system** 组合构建的组件库，它将允许我们以一致的方式在
    JavaScript 中编写 CSS。
- en: Chakra UI setup
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chakra UI 设置
- en: We already have the Chakra UI library installed, and now we need to configure
    it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了 Chakra UI 库，现在我们需要对其进行配置。
- en: 'To use Chakra UI, first, we need to configure its theme provider to enable
    styles for its components. Since all our providers and wrappers are defined in
    `src/providers/app.tsx`, we can add `ChakraProvider` there:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Chakra UI，首先，我们需要配置其主题提供者以启用其组件的样式。由于我们所有的提供者和包装器都在 `src/providers/app.tsx`
    中定义，我们可以在那里添加 `ChakraProvider`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are wrapping the entire application with the provider to apply theming
    and styles to all Chakra UI components. We are also rendering the `GlobalStyles`
    component, which will take any global styles from our theme and apply it to the
    application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将整个应用程序包裹在提供者中，以应用主题和样式到所有 Chakra UI 组件。我们还渲染了 `GlobalStyles` 组件，它将接受来自我们的主题的任何全局样式并将其应用到应用程序中。
- en: 'Chakra UI settings and components are very customizable and can be configured
    in a custom theme, which we can pass to the provider. It will override the default
    theme configuration. Let’s configure the theme in `src/config/theme.ts` by adding
    the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Chakra UI 设置和组件非常可定制，可以在自定义主题中配置，我们可以将其传递给提供者。它将覆盖默认的主题配置。让我们在 `src/config/theme.ts`
    中配置主题，添加以下内容：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are defining some global styles that will be injected via the `GlobalStyles`
    component, which we have already added in `AppProvider`. We also define the theme
    colors we want to have available in the components. Then, we combine these configurations
    with the default theme values by using the `extendTheme` utility, which will merge
    all configurations and give us the complete theme object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一些将通过 `GlobalStyles` 组件注入的全局样式，我们已经在 `AppProvider` 中添加了它。我们还定义了希望在组件中可用的主题颜色。然后，我们通过使用
    `extendTheme` 工具将这些配置与默认主题值结合，该工具将合并所有配置并给我们完整的主题对象。
- en: It is useful to centralize theme configuration since it is easy to use and change
    if the branding of the application changes. For example, we can easily change
    the primary color value in one place and apply it to the entire application without
    any additional changes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将主题配置集中化是有用的，因为如果应用程序的品牌发生变化，它很容易使用和更改。例如，我们可以轻松地在单个位置更改主颜色值，并将其应用到整个应用程序，而无需进行任何额外的更改。
- en: Building components
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建组件
- en: 'Now that the Chakra UI setup is in place, we can build the components. In the
    starting files for this chapter, we already have some default components exported.
    For now, we can render them on the landing page defined in `src/pages/index.tsx`
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Chakra UI 的设置已经就绪，我们可以构建组件。在本章的起始文件中，我们已经导出了一些默认组件。目前，我们可以在 `src/pages/index.tsx`
    中定义的着陆页上渲染它们，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To start the application development server, we need to run the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动应用程序开发服务器，我们需要运行以下命令：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will make the newly created page available at `http://localhost:3000`.
    The development server will listen to any changes we make and auto-refresh the
    page with the latest changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使新创建的页面在`http://localhost:3000`上可用。开发服务器将监听我们做出的任何更改，并使用最新的更改自动刷新页面。
- en: 'The landing page will display the components. If we open `http://localhost:3000`,
    we should see the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首页将显示组件。如果我们打开`http://localhost:3000`，我们应该看到以下内容：
- en: '![Figure 3.1 – Preview of the initial components on the landing page ](img/B17297_03_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 首页上初始组件的预览](img/B17297_03_01.jpg)'
- en: Figure 3.1 – Preview of the initial components on the landing page
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 首页上初始组件的预览
- en: The components aren’t doing much right now, so we need to work on their implementation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 目前组件并没有做太多，所以我们需要专注于它们的实现。
- en: Button
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮
- en: Let’s start by implementing the `Button` component, one of the most common components
    in every application. The component is already created in `src/components/button/button.tsx`,
    but we need to modify it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现`Button`组件开始，这是每个应用程序中最常见的组件之一。该组件已经在`src/components/button/button.tsx`中创建，但我们需要对其进行修改。
- en: 'Let’s start by importing its dependencies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入其依赖项：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can create the `variants` object, which will hold all styling properties
    of our button and they will be applied accordingly to the default Chakra UI `Button`
    component:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`variants`对象，它将包含我们按钮的所有样式属性，并将相应地应用于默认的Chakra UI `Button`组件：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can type the props for the `Button` component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为`Button`组件键入属性：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Typing the component’s props is a great way to describe its API, which is very
    useful as it documents how it should be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 键入组件的属性是一种很好的方式来描述其API，这对于记录其使用方式非常有用。
- en: 'And now, we can create the `Button` component, which is just a wrapper around
    the default `Button` component provided by Chakra UI:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`Button`组件，它只是Chakra UI提供的默认`Button`组件的包装器：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can update the `Button` component usage in `src/pages/index.tsx` as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式更新`src/pages/index.tsx`中的`Button`组件的使用：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: InputField
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入字段
- en: The input field component is an input component that we want to use when building
    our forms. Let’s change `src/components/form/input-field.tsx`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字段组件是我们构建表单时想要使用的输入组件。让我们更改`src/components/form/input-field.tsx`。
- en: 'First, we need to import all dependencies:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入所有依赖项：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we define types for the component’s props:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为组件的属性定义类型：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we implement the component itself:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现组件本身：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we are building an input field component that we can use with
    the `react-hook-form` library to create forms, and we will learn how to do that
    in the upcoming chapters. Notice how we are wrapping the component with `forwardRef`.
    This will allow us to pass references to the component if necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在构建一个输入字段组件，我们可以使用`react-hook-form`库来创建表单，我们将在接下来的章节中学习如何做到这一点。注意我们是如何使用`forwardRef`包装组件的。这将允许我们在必要时传递对组件的引用。
- en: 'Let’s update its usage in `src/pages/index.tsx`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新其在`src/pages/index.tsx`中的使用：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Link
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接
- en: 'For the links, we will use the `Link` component provided by Next.js. However,
    we want to centralize the configuration and styling and use it everywhere. Let’s
    modify `src/components/link/link.tsx`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链接，我们将使用Next.js提供的`Link`组件。然而，我们希望集中配置和样式，并在所有地方使用它。让我们修改`src/components/link/link.tsx`：
- en: 'First, let’s import all dependencies:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入所有依赖项：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to what we did with the `Button` component, we want to allow the link
    to accept some variants, which will apply additional styling props to the component:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对`Button`组件所做的方式类似，我们希望允许链接接受一些变体，这将向组件应用额外的样式属性：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we define the type of the component’s props:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义组件属性的类型：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here is the implementation of the `Link` component. Notice how we are using
    the `Link` component from Next.js, which we use to wrap the `Button` component
    from Chakra UI:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Link`组件的实现。注意我们是如何使用Next.js中的`Link`组件来包装Chakra UI中的`Button`组件的：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Why are we using the `Button` component instead of `Link` from Chakra UI? We
    could have used `Link`, but we want most of our links to look and feel like buttons,
    so the reason is just the style preference. Notice how we are passing `as="a"`
    to `Button`. This will make the element an anchor, which is correct from the accessibility
    standpoint, and the component will be rendered as a link element in the DOM.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们使用 `Button` 组件而不是 Chakra UI 的 `Link`？我们本可以使用 `Link`，但我们希望大多数链接看起来和按钮一样，所以原因只是风格偏好。注意我们是如何将
    `as="a"` 传递给 `Button` 的。这将使元素成为一个锚点，这在可访问性方面是正确的，并且该组件将在 DOM 中作为链接元素渲染。
- en: 'Let’s update its usage in `src/pages/index.tsx`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `src/pages/index.tsx` 中更新其使用情况：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we can’t predict and build all shared components upfront. Sometimes
    we realize that something needs to be abstracted while we are developing it. It
    is also challenging to anticipate all edge cases of a component, so abstracting
    it too early might complicate things in the long run.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法提前预测和构建所有共享组件。有时在我们开发过程中，我们会意识到某些东西需要被抽象化。预测组件的所有边缘情况也很具有挑战性，因此过早地抽象化可能会在长期内使事情变得复杂。
- en: For now, we have abstracted the most generic components we will surely use as
    they are.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经抽象化了我们将肯定使用的最通用的组件，保持它们原样。
- en: Remember, the implementation details of each component don’t matter. If you
    don’t understand everything they are doing and how they work, it’s okay. The key
    takeaway is that we want to abstract the most common components so we can reuse
    them when needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个组件的实现细节并不重要。如果你不理解它们所做的一切以及它们是如何工作的，那没关系。关键是要点是我们希望抽象出最常见的组件，以便在需要时可以重用它们。
- en: Since most component libraries are very generic, with many options to fit everyone’s
    needs, it is a good idea to make our wrappers around their default components
    to reduce the default API surface and adapt them to the application’s needs. This
    will reduce the overhead of components with too many configuration options and
    props we will never use. Also, it will bring consistency since developers are
    constrained to using fewer options.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数组件库都非常通用，提供了许多选项以满足每个人的需求，因此创建我们围绕其默认组件的包装器是一个好主意，以减少默认 API 表面和适应应用程序的需求。这将减少具有太多配置选项和我们将永远不会使用的属性组件的冗余。此外，它将带来一致性，因为开发者被限制在更少的选择范围内。
- en: 'Let’s look at our index page where the components are rendered:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的索引页面，其中渲染了组件：
- en: '![Figure 3.2 – Preview of the components on the landing page ](img/B17297_03_02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 登录页面组件预览](img/B17297_03_02.jpg)'
- en: Figure 3.2 – Preview of the components on the landing page
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 登录页面组件预览
- en: Great! Now go ahead and try to play around with different props and see how
    the components behave.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在你可以尝试使用不同的属性，看看组件的表现如何。
- en: 'Our components are working correctly and are ready to be used in the application.
    However, there are a couple of issues:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件工作正常，并准备好在应用程序中使用。然而，有几个问题：
- en: We are occupying the index route. What happens when we want to use it for something
    meaningful, such as the landing page? We will not be able to use that page for
    previewing our components. Sure, we can create and use another page that will
    never be used, but that is not a very good option either.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在占用索引路由。当我们想用它来执行一些有意义的事情，比如登录页面时，会发生什么？我们将无法使用该页面来预览我们的组件。当然，我们可以创建并使用另一个永远不会被使用的页面，但这也不是一个好的选择。
- en: We don’t want to display all components together as it is messy, and it would
    be better to try them out in isolation.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不想一起显示所有组件，因为这会很混乱，最好是在隔离状态下尝试它们。
- en: We want to play around with the component props, which is impossible with the
    current approach since we would have to modify the code.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想尝试组件的属性，但当前的方法无法做到，因为我们必须修改代码。
- en: Let’s see in the next section how we can solve these issues and develop and
    try components in isolation without changing our application’s code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看如何解决这些问题，并在不更改应用程序代码的情况下隔离开发和尝试组件。
- en: Storybook
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Storybook
- en: '**Storybook** is a tool that allows us to develop and test UI components in
    isolation. We can think of it as a tool for making catalogs of all the components
    we have. It is great for documenting components. A couple of benefits of using
    Storybook include the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**Storybook** 是一个允许我们在隔离状态下开发和测试 UI 组件的工具。我们可以将其视为制作所有组件目录的工具。它非常适合文档化组件。使用
    Storybook 的几个好处包括以下内容：'
- en: Storybook allows developing components in isolation without the need to reproduce
    the exact state of the application, allowing developers to focus on the things
    they are building
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storybook 允许在无需复制应用确切状态的情况下独立开发组件，使开发者能够专注于他们正在构建的事物
- en: Storybook serves as a catalog of UI components allowing all stakeholders to
    try out the components without using them in the application
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storybook 作为 UI 组件的目录，允许所有利益相关者尝试组件而无需在应用程序中使用它们
- en: 'Storybook is configured by using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 的配置可以通过以下命令完成：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command will install all required dependencies and set up the configuration
    that resides in the `.storybook` folder at the root of the project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将安装所有必需的依赖项，并设置位于项目根目录 `.storybook` 文件夹中的配置。
- en: Storybook configuration
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Storybook 配置
- en: We already have Storybook installed, so let’s look at the configuration, which
    has two files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了 Storybook，现在让我们看看配置，它包含两个文件。
- en: 'The first file contains the main configuration, which controls how the Storybook
    server behaves and how it processes our stories. It lives in `.storybook/main.js`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件包含主要配置，它控制 Storybook 服务器的行为以及如何处理我们的故事。它位于 `.storybook/main.js`：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The main configuration contains the following properties:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 主要配置包含以下属性：
- en: '`stories`: An array of globs that indicates the locations of our stories.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stories`：一个表示我们的故事位置的 glob 数组。'
- en: '`addons`: A list of add-ons used to enhance the default behavior of Storybook.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addons`：用于增强 Storybook 默认行为的插件列表。'
- en: '`features`: Enables Storybook’s additional features.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`features`：启用 Storybook 的附加功能。'
- en: '`framework`: Framework-specific configurations.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`framework`：框架特定的配置。'
- en: '`core`: Internal feature configuration.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`：内部功能配置。'
- en: '`webpackFinal`: Configuration for extending default webpack configuration.
    We are enabling absolute imports by telling Storybook to use paths from the `tsconfig.json`
    file.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpackFinal`：扩展默认 webpack 配置的配置。我们通过告诉 Storybook 使用 `tsconfig.json` 文件中的路径来启用绝对导入。'
- en: 'The second configuration file controls how the stories are rendered in the
    UI. This configuration lives in `.storybook/preview.js`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个配置文件控制故事在 UI 中的渲染方式。此配置位于 `.storybook/preview.js`：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how we are passing the theme to the `chakra` property in `parameters`.
    This will enable Chakra theming to be applied to our components in Storybook.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何在 `parameters` 中的 `chakra` 属性中传递主题的。这将使 Chakra 主题能够应用于 Storybook 中的组件。
- en: We can optionally export decorators, which will wrap all the stories. It is
    useful if the components rely on some providers that we want to have available
    in all stories.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择导出装饰器，这将包装所有故事。如果组件依赖于我们希望在所有故事中可用的某些提供者，这很有用。
- en: Storybook scripts
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Storybook 脚本
- en: 'Our Storybook setup has two npm scripts:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的故事书设置有两个 npm 脚本：
- en: Running Storybook in development
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发中运行 Storybook
- en: 'To start the development server, we can execute the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动开发服务器，我们可以执行以下命令：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The command will open Storybook at `http://localhost:6006/`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `http://localhost:6006/` 打开 Storybook。
- en: Building Storybook for production
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为生产构建 Storybook
- en: 'We can also generate and deploy the stories to be visible without running the
    development server. To build the stories, we can execute the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以生成并部署故事，以便在不运行开发服务器的情况下可见。要构建故事，我们可以执行以下命令：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Generated files can then be found in the `storybook-static` folder, and they
    can be deployed anywhere.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件可以在 `storybook-static` 文件夹中找到，并且可以部署到任何地方。
- en: Now that we have familiarized ourselves with the setup, it’s time to write the
    stories for the components.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了设置，是时候为组件编写故事了。
- en: Documenting components
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件文档化
- en: 'If we recall from the previous section, the configuration in `.storybook/main.js`
    has the `stories` property as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从上一节回忆起来，`.storybook/main.js` 中的配置具有以下 `stories` 属性：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means that any file in the `src` folder that ends with `.stories.tsx`
    should be picked by Storybook and treated as a story. With that said, we will
    co-locate stories next to the components, so the structure for every component
    will look something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `src` 文件夹中以 `.stories.tsx` 结尾的任何文件都应由 Storybook 选择并作为故事处理。换句话说，我们将将与组件并列放置故事，因此每个组件的结构将类似于以下内容：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will create our stories based on **Component Story Format** (**CSF**), an
    open standard for writing component examples.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据 **组件故事格式**（**CSF**），一个编写组件示例的开放标准，创建我们的故事。
- en: But first, what is a story? According to the CSF standard, a story should represent
    a single source of truth for a component. We can think of a story as a user story
    where a component is presented in the corresponding state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，什么是故事？根据 CSF 标准，一个故事应该代表一个组件的单个真相来源。我们可以将故事视为一个用户故事，其中组件以相应的状态呈现。
- en: 'CSF requires the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CSF 需要以下内容：
- en: Default exports should define metadata about a component, including the component
    itself, the component’s name, decorators, and parameters
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认导出应该定义关于组件的元数据，包括组件本身、组件的名称、装饰器和参数
- en: Named exports should define all stories
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导出应定义所有故事
- en: Let’s now create the stories for the components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为组件创建故事。
- en: Button stories
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮故事
- en: To create stories for the `Button` component, we need to create an `src/components/button/button.stories.tsx`
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `Button` 组件创建故事，我们需要创建一个 `src/components/button/button.stories.tsx` 文件。
- en: 'Then, we can start by adding the required imports:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始添加所需的导入：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we create the meta configuration object:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建元配置对象：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we are exporting it as a default export. This is what Storybook
    requires, according to CSF.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将其作为默认导出。根据 CSF，这是 Storybook 所要求的。
- en: 'Since we can have multiple stories, we must create a story template:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以有多个故事，我们必须创建一个故事模板：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And then we can export the first story:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导出第一个故事：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can pass any props we need to the `args` object attached to the story, which
    will be reflected in our stories in Storybook.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所需的任何属性传递给附加到故事的 `args` 对象，这将反映在 Storybook 的故事中。
- en: 'We can do the same thing for another story where we want to have a version
    of `Button` that has an icon:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为另一个故事做同样的事情，其中我们想要有一个带有图标的 `Button` 版本：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To see the story, let’s execute the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看故事，请执行以下命令：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s visit `http://localhost:6006/`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们访问 `http://localhost:6006/`：
- en: '![Figure 3.3 – Button component story ](img/B17297_03_03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 按钮组件故事](img/B17297_03_03.jpg)'
- en: Figure 3.3 – Button component story
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 按钮组件故事
- en: And there, we have the `Button` component previewed in isolation. Notice the
    control panel at the bottom. This gives us a friendly interface to play with the
    component’s props without touching the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们单独预览了 `Button` 组件。注意底部的控制面板。这为我们提供了一个友好的界面来操作组件的属性，而无需接触代码。
- en: Isn’t this much nicer than what we had first with rendering components on the
    index page? We can deploy stories anywhere and allow non-technical people to experiment
    with the components without coding knowledge.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是比我们在首页上渲染组件时更好吗？我们可以将故事部署到任何地方，并允许非技术人员在没有编码知识的情况下实验组件。
- en: Exercises
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'To solidify your understanding of Storybook, let’s have a go at some exercises.
    Go ahead and create stories for the following components:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固你对 Storybook 的理解，让我们尝试一些练习。继续创建以下组件的故事：
- en: '`InputField`:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输入字段`：'
- en: Default story
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认故事
- en: With error story
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有错误故事
- en: '`Link`:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`链接`：'
- en: Default story
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认故事
- en: With icon story
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带图标的故事
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, our focus was on building base components that we will reuse
    in our application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的重点是构建我们将重用在我们的应用程序中的基础组件。
- en: We started by configuring the Chakra UI provider and theming. Then we displayed
    the components on the landing page for testing purposes. They were not doing much,
    so we implemented them. The point of defining shared components is that we can
    reuse them anywhere, which makes development easier in the long run. What the
    components are doing here is not very important. The important thing is to think
    about creating shared components as a base for the application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先配置了 Chakra UI 提供者和主题。然后，为了测试目的，我们在首页上显示组件。它们没有做什么，所以我们实现了它们。定义共享组件的目的在于我们可以将它们在任何地方重用，这从长远来看使开发更容易。组件在这里所做的事情并不重要。重要的是要考虑将创建共享组件作为应用程序的基础。
- en: We then needed to preview the components somewhere and since doing that on a
    page is not a very elegant solution, we chose Storybook. We covered its configuration,
    and then we defined a couple of stories for the `Button` component. The stories
    are written in **Component Story Format** (**CSF**), which is a standard for how
    to write component examples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后需要在某处预览组件，由于在页面上这样做不是一个非常优雅的解决方案，我们选择了 Storybook。我们介绍了其配置，然后为 `Button` 组件定义了几个故事。这些故事是用
    **组件故事格式** （**CSF**） 编写的，这是一种编写组件示例的标准。
- en: As an exercise at the end of this chapter, there were further stories to implement,
    which should solidify all learnings so far.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章结束时的练习，还有更多的故事需要实现，这应该能够巩固到目前为止的所有学习成果。
- en: In the next chapter, we will use these components when we start creating our
    pages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们开始创建我们的页面时，我们将使用这些组件。
