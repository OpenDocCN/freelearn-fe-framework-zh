- en: Some Practical Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With seven chapters under our belt, you should feel pretty good. What you have
    learned thus far is a direct consequence of the apps we have built in the last
    few chapters. We believe you should now have an adequate understanding of the
    framework, how it works, and what it supports. Armed with this knowledge, as soon
    as we start to build some decent-sized apps, there are some common problems/patterns
    that invariably surface, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we authenticate the user and control his/her access (authorize)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we make sure that the app is performing well enough?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My app requires localized content. What do I do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What tools can I use to expedite app development?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have an AngularJS app. How do I migrate it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And some more!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will try to address such common scenarios and provide some
    working solutions and/or prescriptive guidance to handle such use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular seed projects**: You will learn how some seed projects in Angular
    can help us when starting a new engagement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authenticating Angular applications**: This is a common requirement. We look
    at how to support cookie- and token-based authentication in Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular performance**: A customary performance section is a must as we try
    to detail what makes Angular performant and things you can do to make your apps
    faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migrating AngularJS apps to Angular**: AngularJS and Angular are altogether
    different beasts. In this chapter, you will learn how to gradually migrate an
    AngularJS app to Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start at the beginning!
  prefs: []
  type: TYPE_NORMAL
- en: Building a new app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine a scenario here: we are building a new application and given the super
    awesomeness of the Angular framework, we have unanimously decided to use Angular.
    Great! What next? Next is the mundane process of setting up the project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although a mundane activity, it''s still a critical part of any engagement.
    Setting up a new project typically involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a standard folder structure. This is at times influenced by the server
    framework (such as *RoR*, *ASP.Net*, *Node.js*, and others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding standard assets to specific folders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up the build, which in the case that, we are developing an Angular-based
    web application, includes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling/transpiling content if using TypeScript
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the Module loader
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management in terms of framework and third-party components
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit/E2E testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring builds for different environments such as dev, test, and production.
    Again, this is influenced by the server technology involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code bundling and minification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of stuff to do.
  prefs: []
  type: TYPE_NORMAL
- en: What if we can short-circuit the overall setup process? This is indeed possible;
    we just need a **seed project** or a **starter site**.
  prefs: []
  type: TYPE_NORMAL
- en: Seed projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular CLI as a built and scaffolding tool is awesome! But, it is not the only
    option out there. There are a number of *seed projects/starter sites* that can
    get us up and running in no time. Some seed projects integrate the framework with
    a specific backend and some only dictate/provide Angular-specific content. Some
    come preconfigured with vendor-specific libraries/frameworks (such as *LESS*,
    *SASS*, *Bootstrap*, and others), whereas others just provide a plain vanilla
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the notable seed projects worth exploring are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular Starter** ([http://bit.ly/ng-starter](http://bit.ly/ng-starter)):
    This seed repo serves as an Angular starter for anyone looking to get up and running
    with Angular and TypeScript fast. It uses Webpack (module bundler) to build our
    files and assist with boilerplate. It''s a complete build system with a substantial
    number of integrations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Seed** ([http://bit.ly/ng-starter-seed](http://bit.ly/ng-starter-seed)):
    Another seed project similar to Angular Starter. This seed project uses gulp for
    build automation, and the module bundler system is not as advanced as Webpack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These projects along with Angular CLI provide a head start when building with
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the app is tied to a specific backend stack, we have two choices, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use one of these seed projects and integrate it with the backend manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a seed project/implementation that does it for us. There is a good chance
    you will find such seed projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular has been designed with performance in mind. Every part of the framework,
    starting from the framework footprint, initial load time, memory utilization,
    change detection plus data binding, and DOM rendering, has been tweaked or is
    being tweaked for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections are dedicated to understanding how performant Angular
    is and the tricks it uses to achieve some impressive performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: Byte size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Byte size* of the framework is a good starting point for performance optimization.
    While the world is moving towards high-speed internet, a sizable population among
    us is on a slow connection and are using their mobile to connect to the web. We
    may not think too much about a few KB here or there, but it does matter!'
  prefs: []
  type: TYPE_NORMAL
- en: While the byte size of Angular out of the box is bigger than AngularJS, there
    are techniques that can drastically reduce the size of an Angular bundle.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, the standard techniques of *minification* and *gzipping* can
    reduce this gap substantially. And with Angular, we can do some nifty tricks with
    *module bundler/loaders* to reduce the Angular bundle size even more.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tree shaking** may be a quirky name for a process, but it literally does
    what it says! As we build apps using TypeScript (or ES2015), containing *modules*
    and *exports*, a module bundler such as *Rollup* ([http://rollupjs.org](http://rollupjs.org))
    can perform static code analysis on such code, determine what parts of the code
    are never used, and remove them before bundling the release bits. Such module
    bundlers, when added to the app''s build process, can analyze the framework bit,
    any third-party library, and the app code to remove any dead code before creating
    bundles. *Tree shaking can result in enormous size reduction as you don''t bundle
    framework bits that you don''t use.*'
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest framework pieces that can be removed from the framework bundle
    is the *compiler*. Yes, you read right, it's the compiler!
  prefs: []
  type: TYPE_NORMAL
- en: For curious readers, the compiler is the single biggest framework piece, contributing
    roughly 50% in size to the Angular bundle (In Angular *v2.0.0*).
  prefs: []
  type: TYPE_NORMAL
- en: Using tree shaking together with **Ahead-of-Time** (**AoT**) compilation, we
    can just get rid of the Angular compiler (in the browser) altogether.
  prefs: []
  type: TYPE_NORMAL
- en: With AoT compilation, the view templates (HTML) are compiled beforehand on the
    server side. This compilation again is done as part of the app's build process
    where a server version of the Angular compiler (a node package) compiles every
    view in the application.
  prefs: []
  type: TYPE_NORMAL
- en: With all the templates compiled, there is no need to send the Angular compiler
    bits to the client side at all. Tree shaking can now just get rid of the compiler
    and create a far slimmer framework package. Angular CLI supports AoT compilation
    and can be used for production builds.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about AoT in the framework documentation available at [http://bit.ly/ngx-aot](http://bit.ly/ngx-aot).
  prefs: []
  type: TYPE_NORMAL
- en: Initial load time and memory utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial load time for any web app with a full-fledged JavaScript framework
    is typically slow. This effect is more pronounced on mobile devices, where the
    JavaScript engine may not be as powerful as a desktop client. For a better user
    experience, it becomes imperative that the framework initial load time is optimized,
    especially for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, **Angular 2 was five times faster than AngularJS** when it came
    to initial load time and re-rendering the view. These numbers are getting better
    as the Angular team evolves the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Further, AoT compilation too can improve the initial load time of the application
    as a time-consuming activity (view compilation) is not required.
  prefs: []
  type: TYPE_NORMAL
- en: The same holds true for memory utilization. Angular fares better here too, and
    things will get even better with future releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are planning to switch to Angular, this is something that you should
    look forward to: a performant framework built for the future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three performance improvements that we are going to talk about have
    been made possible because of a single architectural decision: *the creation of
    a separate renderer layer*.'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular rendering engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest disadvantage of AngularJS was that the framework was tied to the
    browser DOM. The directives, the binding, and the interpolations all worked against
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Angular, the biggest architectural change that came in was a separate
    rendering layer. Now, an Angular app has two layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application layer**: This is the layer our code resides in. It uses an abstraction
    build over the renderer layer to interact with it. The Renderer class we saw in
    Chapter 6, *Angular Directives in Depth*, is the interface that we use to interact
    with the rendering layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering layer**: This layer is responsible for translating requests from
    the application layer into rendered components, and reacting to user input and
    view updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default renderer implementation for the renderer is `DomRenderer`, which
    runs inside the browser. But there are other rendering abstractions too and we
    will discuss them in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pre-rendering** on the server side is yet another technique for improving
    the initial load time of an Angular app. This technique is really helpful on mobile
    devices, as it improves the perceived load time considerably.'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering takes care of the initial page load before client-side
    rendering kicks in (and handles view rendering henceforth).
  prefs: []
  type: TYPE_NORMAL
- en: In such a scenario, when the user requests for a view/page, a piece of software
    on the server generates a fully materialized HTML page with data pre-bound to
    the view and sends it to the client along with a small script. The app view is
    therefore immediately rendered, ready for interaction. While the framework loads
    in the background, the small script that was sent along the first time captures
    all user inputs and makes them available to the framework, allowing it to replay
    the interactions once it is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular Universal**, as it is touted, allows rendering and sharing of the
    view both on the server and the client side.'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering is only made possible because of separation of the rendering
    layer described previously. The initial view is generated by a renderer implementation
    on the server, named `ServerDomRenderer`. There is a Node.js plugin ([http://bit.ly/ng-universal-node](http://bit.ly/ng-universal-node))
    that can be used in a number of node web frameworks such as *Express*, *Hapi*,
    *Sail*, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the Angular design docs for Angular Universal ([http://bit.ly/ng-universal-design](http://bit.ly/ng-universal-design))
    and the embedded YouTube videos at the top of the design doc to learn more about
    server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is not the only benefit with server-side rendering. As it turns
    out, search indexers too like pre-rendered HTML content. Server-side rendering
    is really useful in areas such as **search engine optimization (SEO)** and deep
    linking, which allows easy content sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Offloading work to a web worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Offloading work to a **web worker** is a neat idea, again made possible due
    to the separation of the rendering layer from the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: '*Web workers* provide a mechanism for running scripts in background threads.
    These threads can execute work that does not involve the browser DOM. Be it a
    CPU-intensive task or a remote XHR invocation, all can be delegated to web workers.'
  prefs: []
  type: TYPE_NORMAL
- en: In today's world, CPUs with multiple cores are the norm, but JavaScript execution
    is still single-threaded. There is a need for a standard/mechanism to utilize
    these idle cores for our apps. Web workers fit the bill perfectly, and since most
    modern browsers support them, we all should be writing code that utilizes web
    workers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, that''s not happening. Web workers are still not mainstream, and there
    are good reasons for that. Web workers impose a good number of restrictions on
    what is allowed and what is not. These limitations include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No direct access to DOM**: Web workers cannot directly manipulate the DOM.
    In fact, web workers do not have access to multiple globals such as *window* and
    *document*, and others are not available on the web worker thread. This severely
    limits the number of use cases where a web worker can be utilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser support**: Web workers are only available for modern/evergreen browsers
    (IE 10+).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-process communication**: Web workers do not share the memory with your
    main browser process, and hence need to communicate with the main thread (UI thread)
    only through *message passing* (serialized data). Adding to that, the message
    passing mechanism is asynchronous in nature, adding another layer of complexity
    to the communication model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, web workers are hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: Angular tries to alleviate these limitations by integrating the web worker usage
    into the framework itself. It does that by running the complete application in
    the web worker thread, except the rendering part.
  prefs: []
  type: TYPE_NORMAL
- en: The framework takes care of the communication between the application code running
    inside the web worker and the renderer running inside the main UI thread. From
    a developer's perspective, there are no visible differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is again made possible due to the separation of the renderer layer in
    Angular. The following diagram shows the layers that run on the app main thread
    and what runs inside the web worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go through this talk ([http://bit.ly/yt-ng-web-worker](http://bit.ly/yt-ng-web-worker))
    from Jason Teplitz to learn about what web workers have to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Performant mobile experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular's rendering abstraction again opens up a host of integration avenues,
    especially on the mobile platform. Rather than running an app on a mobile browser,
    Angular renderers can be created that can tap the device's native UI capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two notable projects in this domain are renderers for platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ReactNative** ([http://bit.ly/rnative](http://bit.ly/rnative)): A renderer
    for ReactNative ([http://bit.ly/ng-rnative](http://bit.ly/ng-rnative)). It allows
    the writing of Angular apps using ReactNative''s rendering capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NativeScript** ([https://www.nativescript.org/](https://www.nativescript.org/)):
    Angular and NativeScript teams have collaborated to create a renderer for NativeScript
    ([http://bit.ly/ng-native-script](http://bit.ly/ng-native-script)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App platforms such as *ReactNative* and *NativeScript* already do a superb job
    of providing JavaScript-based APIs for the native mobile platforms (iOS and Android),
    allowing us to utilize a single code base with a familiar language. Angular renderers
    take things a step further. With Angular integration, a good amount of code can
    be shared across browsers and mobile devices. Things may only differ in terms
    of view templates and view-related services such as dialogs, popups, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the documentation for the respective renderers to understand how they
    work and the features they support.
  prefs: []
  type: TYPE_NORMAL
- en: Next up on the line, we have framework improvements in terms of *change detection*.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major performance improvements in Angular over AngularJS is in how
    *change detection* works in Angular. Out of the box, Angular change detection
    is insanely fast, and it can be tweaked even further for better results.
  prefs: []
  type: TYPE_NORMAL
- en: The next few sections talk about Angular change detection in depth. It's an
    important topic to understand when building anything at scale. It also helps us
    debug scenarios where it may seem that change detection is not working as advertised.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the discussion by understanding what change detection is and why
    it is important.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular's *data binding engine* does a great job of binding the view with the
    model data (component data). These are live bindings where Angular keeps the view
    in sync with model changes. Any time the model changes, the binding engine re-renders
    parts of the view that are dependent on the model. To manage this view-model synchronization,
    Angular needs to know when the model changed and what changed exactly. This is
    what **change detection** is all about. During app execution, Angular frequently
    does what we call **change detection runs** to determine what changed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are from AngularJS, a *change detection run* is roughly equivalent to
    **digest cycles**, except that in Angular there are **no cycles**.
  prefs: []
  type: TYPE_NORMAL
- en: While this problem of keeping the model and view in sync may sound simple, it's
    a tough nut to crack. Unlike the component tree, the interconnection between multiple
    models can be complex. Changes in one component model can trigger changes in multiple
    component models. Furthermore, these interconnections may have cycles. A single
    model property could be bound to multiple views. All these complex scenarios need
    to be managed using a robust change detection infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we explore how the Angular change detection infrastructure
    works, when change detection triggers, and how can we influence change detection
    behavior in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It all starts with Angular setting up change detectors for every component
    rendered on the view. Since every Angular app is a hierarchy of components, these
    change detectors are also set up in the same hierarchy. The following diagram
    highlights the **change detector hierarchy** of the *Workout Builder* app at a
    point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A *change detector* attached to a component has the responsibility of detecting
    changes in the component. It does that by parsing the binding on the component's
    template HTML and setting up the necessary change detection watches.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the detector only sets up watches on model properties used in the
    template, not on all component properties.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point worth highlighting here is that *change detection is
    set up one way, from model to view*. Angular does not have the concept of two-way
    data binding and hence the preceding figure is a directed tree without cycles.
    This also makes change detection more predictable. Interleaving model and view
    updates are disallowed.
  prefs: []
  type: TYPE_NORMAL
- en: When does change detection kick in?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does Angular constantly check for changes in the model data? Considering the
    fact that the component properties we bind the view to do not inherit from any
    special class, Angular has no way of knowing which property changed. The only
    way out for Angular is to constantly query each data-bound property to know its
    current value and compare it against its old value for changes. Highly inefficient
    to say the least!
  prefs: []
  type: TYPE_NORMAL
- en: Angular does better than that, as change detection runs get executed only at
    specific times during app execution. Think carefully about any web application;
    what causes a view to update?
  prefs: []
  type: TYPE_NORMAL
- en: 'A view can get updated due to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User input/browser events**: We click on a button, enter some text, or scroll
    the content. Each of these actions can update the view (and the underlying model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setTimeout and setInterval timers**: As it turns out, we can use `setTimeout`
    and `setInterval` to execute some code asynchronously and at specific intervals.
    Such code can also update the model. For example, a `setInterval` timer may check
    for stock quotes at regular intervals and update the stock price on the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For obvious reasons, Angular change detection too kicks in only when any of
    these conditions occur.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part here is not when Angular's change detection kicks in but
    how Angular is able to intercept all *browser events*, *XHR requests*, and `setTimeout`
    and `setInterval` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feat in Angular is performed by a library called `zone.js`. As the documentation
    describes:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Zone is an execution context that persists across async tasks."'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the basic abilities of this library is that it can hook into a piece
    of code and trigger callbacks when code execution starts and when it ends. The
    code being monitored could be a sequence of calls that are both synchronous and
    asynchronous in nature. Consider this example, which highlights the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We wrap a piece of code inside a call to the `zone.run` call. This code calls
    the `doWork` function synchronously twice, interleaved with a `setTimeout` call
    that invokes the same function after a lapse of 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'By wrapping this sequence inside `zone.run`, we can know when the call execution
    is complete. In zone terminology, these are **turns**. The code before `zone.run`
    sets up a subscriber that gets called when execution is complete, using the `zone.onMicrotaskEmpty`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding code, the logs look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `onMicrotaskEmpty` subscription is executed twice, once after the sequential
    execution completes (defined inside `run` callback) and one after the asynchronous
    `setTimeout` execution is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Angular change detection uses the same technique to execute our code within
    zones. This code could be an *event handler*, which internally makes more synchronous
    and asynchronous calls before completing, or it could be a `setTimeout`/`setInterval`
    operation that may again require a UI update.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular change detection framework subscribes to the `onMicrotaskEmpty`
    observable for the executing zone, and kicks in change detection whenever a turn
    is complete. The following diagram highlights what happens when code similar to
    the one just described is run on a button click:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: During the execution of the code block, if the zone library determines that
    the call is asynchronous in nature, it spawns a new micro task that has its own
    life cycle. It is the completion of these micro tasks that also triggers `onMicrotaskEmpty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know how the change detection trigger looks inside Angular,
    here is an excerpt from the Angular source code (simplified further):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ApplicationRef` class tracks all the change detectors attached throughout
    the app and triggers a change detection cycle when the application-level zone
    object fires the `onMicrotaskEmpty` event. We will shortly touch upon what happens
    during this change detection.
  prefs: []
  type: TYPE_NORMAL
- en: '*Zone.js* gets the ability to track execution context across any asynchronous
    call because it overrides the default browser API. The override, also termed **monkey
    patching**, overrides the *event subscription*, *XHR requests*, and `setTimeout`/`setInterval`
    API. In the example highlighted previously, the `setTimeout` we invoke is a monkey-patched
    version of the original browser API.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how change detectors are set up and when this activity kicks
    in, we can look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How does change detection work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the change detectors are set up and the browser API is monkey-patched to
    trigger change detection, the real change detection kicks in. This is quite a
    simple process.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as any of the asynchronous event callbacks are triggered (the execution
    of an event handler is also an async activity), Angular first executes the application
    code we attached to the callback. This code execution may result in some model
    updates. After the execution of the callback, Angular needs to respond to the
    changes by triggering a *change detection run*.
  prefs: []
  type: TYPE_NORMAL
- en: In a change detection run, starting from the top of the component tree, every
    change detector evaluates its respective component's template bindings to see
    if the value of the binding expression has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some things that we need to highlight regarding this execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular does a strict equality check (using `===`) to detect changes. Since
    it's not a deep comparison, for a binding that refers to an object, Angular will
    only update the view when the object reference changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change detection flow is unidirectional (starting from root), from parent
    to child in a top-down fashion. The detectors on the parent component run before
    the child detectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the change detection algorithm navigates the complete tree, irrespective
    of where the change was triggered in the tree. This implies all binding is evaluated
    on every change detection run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A binding evaluation on every run may seem inefficient, but it is not. Angular
    employs some advance optimizations to make this check super fast. Still, if we
    want to tweak this behavior, we do have some switches that can reduce the number
    of checks performed. We will touch upon this topic soon.
  prefs: []
  type: TYPE_NORMAL
- en: Change detectors only track properties that are part of template bindings, not
    the complete object/component properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To detect changes in the bound value, the change detectors need to track the
    previous value of the expression evaluated during the last change detection run.
    Clearly, some amount of bookkeeping is required for every template binding we
    use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The obvious next question would be what happens when a change is detected (by
    a change detector)?
  prefs: []
  type: TYPE_NORMAL
- en: Since all the hard work of setting up change detection and identifying changes
    has already been done, this step just involves updating the component state and
    synchronizing the component DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more observations worth highlighting here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, Angular separates the model update step from the DOM update.
    Consider this code snippet, which is invoked when someone clicks on a button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that both `firstName` and `lastName` are bound to the component view,
    a change to `firstName` does not update the DOM binding immediately. Instead,
    Angular waits for the `doWork` function to complete before triggering a change
    detection run and DOM update.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, a change detection run does not (and should not) update the model
    state. This avoids any cycles and cascading updates. A change detection run is
    only responsible for evaluating the bindings and updating the view. This also
    means that we should not update the model state during change detection. If we
    update the model during change detection, Angular throws an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example of this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `start.component.html` from the 7 Minute Workout app and update the last
    `div` to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And, add a `changeDetectionDone` function to the component implementation (`start.component.ts`),
    which looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app, load the start page, and then look at the browser console. Angular
    has logged a number of errors that look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are changing the state of the component when calling the `changeDetectionDone`
    function (inside an interpolation), and Angular throws an error because it does
    not expect the component state to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change detection behavior is enabled only when **production mode** in
    Angular is disabled. *Production mode* can be enabled by calling the `enableProdMode()`
     function before bootstrapping the application (in `bootstrap.ts`). When enabled,
    Angular behaves a bit differently. It turns off assertions and other checks within
    the framework. Production mode also affects the change detection behavior. In
    non-production mode, Angular traverses the component tree twice to detect changes.
    If on the second pass any binding expression has changed, it throws an error.
    In contrast, when in production mode, change detection tree traversal is done
    only once. The change detection error that we saw on the console will not show
    up if we enable production mode. This can lead to an inconsistency between the
    model and view state. Something we should be aware of! The bottom line is that
    we cannot alter the state of a component when change detection is in progress.
    A direct corollary: if we are using a function inside the binding expression,
    function executions should be stateless, without any side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, this change detection traversal from root to leaf node executes only
    once during the change detection run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pleasant surprise for folks with an AngularJS background! *The digest cycle
    count in Angular is 1*. Angular developers will never face "the digest iterations
    exceeded exception!" A far more performant change detection system!
  prefs: []
  type: TYPE_NORMAL
- en: Change detection performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about change detection performance. If you think checking the complete
    component tree every time for change is inefficient, you will be surprised to
    know how fast it is. Due to some optimization around how expressions are evaluated
    and compared, Angular can perform thousands of checks in a couple of milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, for every expression involved in the view binding, Angular generates
    a change detection function that specifically targets a particular binding. While
    it may seem counter intuitive at first, Angular does not have a common function
    for determining whether an expression has changed. Instead, it's like writing
    our own change detection function for every property that we bind to. This allows
    the JavaScript VM to optimize the code, resulting in improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to learn more about it? Check out this video by Victor Savkin: [https://youtu.be/jvKGQSFQf10](https://youtu.be/jvKGQSFQf10).'
  prefs: []
  type: TYPE_NORMAL
- en: In spite of all this optimization, there may still be cases where traversing
    the complete component tree may not be performant enough. This is especially true
    when we have to render a large dataset on the view, keeping the bindings intact.
    The good news is that the Angular change detection mechanism can be tweaked.
  prefs: []
  type: TYPE_NORMAL
- en: The reason Angular needs to do the complete tree walk is that model changes
    in one place may trigger model changes at other places. In other words, a model
    change may have a cascading effect, where interconnected model objects are also
    updated. Since Angular has no way to know what exactly changed, it checks the
    complete component tree and associated model.
  prefs: []
  type: TYPE_NORMAL
- en: If we can help Angular determine what parts of the application state are updated,
    Angular can be pretty smart about what part of the component tree it traverses
    to detect changes. We do this by storing the app data in some special data structures
    that help Angular decide what components need to be checked for changes.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways in which we can make Angular change detection smarter.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Immutable objects/collections** are objects that cannot be changed once created.
    Any property change results in a new object being created. This is what `immutable.js`,
    a popular library for immutable data structures, has to say:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data cannot be changed once created, leading to much simpler application
    development, no defensive copying, and enabling advanced memoization and change
    detection techniques with simple logic.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand how immutable data structures help in the Angular context
    with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we are building a set of components to collect employee information
    for a **Human Resource** (**HR**) software. The employee component view looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It has sections for taking personal, professional, and address information.
    The `summary` components provide a read-only view of the employee data being entered.
    Each of the components has a property called `model`, highlighting what part of
    employee data these components manipulate. Each of these components'' summary,
    professional, personal, and address internally may have other child components.
    This is how the component tree looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What happens when we update an employee's personal information? With standard
    objects (mutable), Angular cannot make any assumption about the shape of data
    and what has changed; hence, it does the complete tree walk.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does immutability help here? When using an immutable data structure, any
    change to an object''s properties results in a new object being created. For example,
    if we create an immutable object using a popular library, `Immutable.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes to either the `name` or `age` property of `personalInfo` create a new
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This immutability comes in handy if each of the employee model properties (`personal`,
    `professional`, `home`, and `work`) is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, the `PersonalInfo` component definition that binds to personal
    info data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the only thing `PersonalInfo` depends upon is the `model` property, and
    the `model` property binds to an immutable object, Angular only needs to do a
    check for changes if the `model` reference changes. Otherwise, the complete `PersonalInfo`
    component subtree can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the `PersonalInfo` component property `changeDetection` to `ChangeDetectionStrategy.OnPush`,
    we instruct Angular to trigger change detection only when the component's inputs
    change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the change detection strategy to `OnPush` for each of the Employee
    component children and update the employee''s personal info, only the `PersonalInfo`
    component subtree is checked for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For a large component tree, such an optimization will improve the app/view performance
    many times over.
  prefs: []
  type: TYPE_NORMAL
- en: When set to `OnPush`, Angular triggers change detection only when the component's
    input property changes or there is an event raised inside the component or its
    children.
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications using immutable data structures departs from the standard
    development paradigm where the application state is totally mutable. What we have
    highlighted in this section is how Angular takes advantage of immutable data structures
    to optimize the change detection process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Observables* are another kind of data structure that can help us optimize
    Angular change detection.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Observables** are data structures that trigger events when their internal
    state changes. The Angular *eventing infrastructure* extensively uses *Observables*
    to communicate the components'' internal state to the outside world.'
  prefs: []
  type: TYPE_NORMAL
- en: While we have used Observable output properties (the `EventEmitter` class) to
    raise events, *input **properties* too can take Observables. Such observable inputs
    can help Angular optimize change detection.
  prefs: []
  type: TYPE_NORMAL
- en: When using observables, the change detection switch still remains `ChangeDetectionStrategy.OnPush`.
    But this time, only if a component input triggers an event (as they are observables)
    will Angular perform the dirty check. When the input triggers an event, the complete
    component tree path, starting from the affected component to the root, is marked
    for verification.
  prefs: []
  type: TYPE_NORMAL
- en: When performing the view update, Angular will only sync the affected path and
    ignore the rest of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Manual change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can actually disable change detection on a component completely and trigger
    manual change detection when required. To disable change detection, we just need
    to inject the component-specific change detector (the `ChangeDetectorRef` class
    instance) into the component and call the `detach` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, the onus is on us to inform Angular when the component should be checked
    for changes.
  prefs: []
  type: TYPE_NORMAL
- en: We can reattach the component to the change detection tree by using the `reattach`
    function on `ChangeDetectorRef.`
  prefs: []
  type: TYPE_NORMAL
- en: We seldom need to disable the standard change detector setup, unless there are
    situations where standard change detection becomes an expensive affair.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, a public chatroom app, which is receiving messages from thousands
    of people connected to it. If we constantly keep pulling the messages and refreshing
    the DOM, the app may become unresponsive. In such a scenario, we can disable change
    detection on parts of the chat app component tree and manually trigger change
    detection to update the UI at specific intervals.
  prefs: []
  type: TYPE_NORMAL
- en: While we have seen three ways to tweak change detection behavior, the good thing
    is that these are not exclusive. Parts of the component tree can use immutable
    data structures, parts can use Observables, parts can employ manual change detection,
    and the rest can still use the default change detection. And Angular will happily
    oblige!
  prefs: []
  type: TYPE_NORMAL
- en: Enough on change detection for now. We may never need it unless we are building
    some large views with a chatty UI. Such scenarios require us to squeeze every
    bit of performance out of the change detection system, and the system is ready
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will have a look at another common requirement that most apps invariably
    have: authenticating their users.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most, if not all, apps have a requirement to authenticate/authorize their users.
    We may argue that authentication and authorization are more of a server concern
    than a client one, and that is correct. Still, the client side needs to adapt
    and integrate with the authentication and authorization requirement imposed by
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical app execution workflow, the app first loads some partial views
    then makes calls to pull data from the server, and finally binds data to its view.
    Clearly, *the views* and *the remote data API* are two assets that need to be
    secured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To guard these resources, we need to understand how a typical application is
    secured on the server. There are primarily two broad approaches to securing any
    web applications: *cookie-based authentication* and *token-based authentication*.
    Each of them requires different handling on the client part. The next two sections
    describe how we can integrate with either of these approaches.'
  prefs: []
  type: TYPE_NORMAL
- en: Cookie-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This authentication mechanism is the easiest to implement if the server stack
    supports it. It''s non-intrusive and may require bare minimum changes to the Angular
    application. **Cookie-based authentication** involves setting the browser cookie
    to track the user authentication session. The following sequence diagram explains
    a typical cookie-based authentication workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is how a typical authentication workflow works:'
  prefs: []
  type: TYPE_NORMAL
- en: When trying to access a secured resource from the browser, if the user is not
    authenticated, the server sends an HTTP 401 Unauthorized status code. A user request
    is an unauthorized request if there is no cookie attached to the request or the
    cookie is expired/invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This unauthorized response is intercepted by the server or, at times, by the
    client framework (Angular in our case) and it typically results in a 302 redirect
    (if intercepted by the server). The redirect location is the URL to the login
    page (the login page allows anonymous access).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user then enters the username and password on the login page and does a
    POST to the login endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server validates the credentials, sets a browser cookie, and redirects the
    user to the originally requested resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Henceforth, the authentication cookie is a part of every request (added by the
    browser automatically), and the server uses this cookie to confirm his identity
    and whether the user is authenticated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, with this approach, the Angular infrastructure is not involved,
    or the involvement is minimal. Even the login page can be a standard HTML page
    that just sends data to the login endpoint for authentication. If the user lands
    on the Angular app, it implicitly means that the user has been authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The cookie-based authentication flow may vary depending on the server framework,
    but the general pattern of setting a cookie and attaching a cookie with every
    subsequent request remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: In a cookie-based application authentication, if the application wants to get
    the user context, a server endpoint (such as `/user/details`) is exposed that
    returns the logged in user's specific data. The client application can then implement
    a service such as `UserService` that loads and caches the user profile data.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario described here assumes that the API server (the server that returns
    data) and the site where the application is hosted are in a single domain. That
    may not always be the case. Even for *Personal Trainer*, the data resides on the
    *MongoLab* servers and the application resides on a different server (even if
    it is local). And we already know that this is a cross-domain access and it comes
    with its own set of challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In such a setup, even if the API server is able to authenticate the request
    and send a cookie back to the client, the client application still does not send
    the authentication cookie on a subsequent request.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to set a variable, `withCredentials`, to `true` on each
    XHR request. This can be enabled at the global level by overriding `BaseRequestOptions`
    (the `withCredentials` property). The framework uses the `BaseRequestOptions`
    class to set the default values for every HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can also be enabled on a per-request level by passing in the `withCredentials:true`
    flag in each HTTP request method as the last parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The last parameter to every HTTP function, including `get`, `post`, and `put`,
    is an options object. This allows us to override the options for the request being
    made.
  prefs: []
  type: TYPE_NORMAL
- en: Once this flag is enabled, the client browser will start attaching the authentication
    cookie for the cross-domain requests.
  prefs: []
  type: TYPE_NORMAL
- en: The server too needs to have **cross-origin resource sharing** (**CORS**) enabled
    and needs to respond in a specific manner for the request to succeed. It should
    set the **access-control-allow-credentials** header to true and the **access-control-allow-origin**
    header to the host site making the request.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the MDN documentation ([http://bit.ly/http-cors](http://bit.ly/http-cors))
    to learn about this scenario in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookie-based authentication is definitely less work on the client side, but
    there are times when you have to revert to token-based access. This could be because:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies and cross-domain requests do not play nicely across browsers. Specifically,
    IE8 and IE9 do not support them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server may not support generating cookies, or the server only exposes token-based
    authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Token-based solutions are easy to integrate with a native mobile application
    and desktop clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens are not susceptible to cross-site request forgery (CSRF) attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To know more about CSRF, look at the CRSF Prevention cheat sheet at [http://bit.ly/csrf-cs](http://bit.ly/csrf-cs).
  prefs: []
  type: TYPE_NORMAL
- en: The next section talks about supporting token-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Token-based access** is all about sending a token (typically in HTTP headers)
    with each request instead of a cookie. A simplified token-based workflow looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Many public APIs (such as *Facebook* and *Twitter*) use token-based authentication.
    The format of the token, where it goes, and how it is generated depends on the
    protocol used and the server implementation. Popular services that use token-based
    authentication implement the **OAuth 2.0** protocol for token generation and exchange.
  prefs: []
  type: TYPE_NORMAL
- en: In a typical token-based authentication setup, the views are available publicly
    but the API is secured. If the application tries to pull data through API calls
    without attaching the appropriate token to the outgoing request, the server returns
    an *HTTP 401 Unauthorized* status code.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling token authentication is a good amount of work in Angular. It involves
    setting up a login page/component, guard conditions, authentication service, and
    authentication context shared across the application.  If you embark on this journey,
    make sure to look for Angular libraries/module that makes this integration easier.
    The `ngx-auth` library ([http://bit.ly/ngx-auth](http://bit.ly/ngx-auth)) can
    be a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: That's all about authentication, but what about authorization? Once the user
    context is established, we still need to make sure that the user is only able
    to access parts that he/she is allowed to. *Authorization* is still missing.
  prefs: []
  type: TYPE_NORMAL
- en: Handling authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like authentication, authorization support too needs to be implemented on both
    the server and client side, more so on the server than the client. Remember, anyone
    can hack into the JavaScript code and circumvent the complete authentication/authorization
    setup. So, always tighten your server infrastructure irrespective of whether the
    client has the necessary checks in place or not.
  prefs: []
  type: TYPE_NORMAL
- en: This still does not mean that we do not do any authorization checks on the client.
    For standard users, this is the first line of defense against unwarranted access.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working on an authorization requirement for any application, there are
    three essential elements that are part of the setup:'
  prefs: []
  type: TYPE_NORMAL
- en: The resources that need to be secured/authorized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of roles and users that are part of these roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mapping between the resources and the roles that define who can access what
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From an Angular app perspective, the resources are the pages and, sometimes,
    sections of pages that need to be restricted to specific roles. If the user is
    in a specific role, depending upon the role-resource mapping, they get access
    to some pages; otherwise, they are denied access.
  prefs: []
  type: TYPE_NORMAL
- en: While authorization in an Angular application can be implemented in a number
    of ways, we will outline a generic implementation that can be further customized
    to suit your needs in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authorization support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enable authorization, the first thing that we need to do is expose the logged
    in user data, including his/her roles, throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing user authentication context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'User context can be shared using an Angular service, which can then be injected
    into components that require the authorization context. Look at this service interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SessionContext` service tracks the user login session and provides details
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The logged in user (`currentUser`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the user is authenticated (`isAuthenticated`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isUserInRole` function, which returns `true` or `false` based on whether
    the user is part of any of the roles passed into the `roles` parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With such a service in place, we can add authorization for routes, thereby restricting
    access to some routes to specific roles only.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like authentication, the `canActivate` guard check can also be used for authorization.
    Implement a class with the `CanActivate` interface and inject the `SessionContext`
    service into the constructor; then, check whether the user belongs to a specific
    role in the `canActivate` function using the `SessionContext` service. Check out
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Only users with roles of *Contributor* and *Admin* now have access to routes
    that have this guard condition.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when a page has view elements that are rendered based on the
    user's role?
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally rendering content based on roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditionally rendering content is easy to implement. We just need to show/hide
    HTML elements based on the user role. We can build a *structural directive* such
    as `ng-if` that can verify that the user belongs to a role before rendering the
    content. The directive''s usage looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code checks whether the user is in an admin role before rendering
    a Site Setting hyperlink.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive implementation mimics how `ng-if` works, except that our show/hide
    logic depends upon the `SessionContext` service. Here is a sample implementation
    for the `a2beRolesAllowed` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a trivial implementation that uses `SessionContext` and the roles passed
    as input (`a2beRolesAllowed`) to show/hide a fragment.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of authentication and authorization implementation.
    The reference implementation walkthrough should help us build authentication and
    authorization into our apps. With this basic understanding in place, any setup
    can be tweaked to handle other custom authentication/authorization scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to address the elephant in the room: migrating from *AngularJS*
    to *Angular*. If you are starting afresh on Angular, you can very well skip the
    next section.'
  prefs: []
  type: TYPE_NORMAL
- en: From the Angular's migration guide *"Angular is the name for the Angular of
    today and tomorrow. AngularJS is the name for all v1.x versions of Angular.*"
  prefs: []
  type: TYPE_NORMAL
- en: Migrating AngularJS apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been working extensively on AngularJS, Angular poses some pertinent
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Should I migrate my old AngularJS apps to the latest Angular version?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When should the migration happen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the migration one-shot or can it be done in an incremental fashion?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the effort involved?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I do something today that helps with the migration in the future?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I am starting a new AngularJS app today. What should I do to make the migration
    seamless in the future?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every such query needs to be addressed to make sure the transition is as smooth
    as possible. No one likes surprises later in the game! In the coming sections,
    we will try to answer a number of such questions. As part of the learning, we
    will also walk you through migrating the AngularJS version of the *Trainer* app
    (developed for the first version of this book) to Angular. This will help everyone
    make some informed decisions on when and how to migrate to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: '"Should I migrate or not" is something that we will address first.'
  prefs: []
  type: TYPE_NORMAL
- en: Should I migrate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just because Angular is here doesn't mean AngularJS is gone. AngularJS is still
    being developed, albeit not at the same pace as Angular. Google is still committed
    to supporting AngularJS for a good amount of time. The AngularJS team is working
    on version 1.7 currently and plan to release it before June 2018\. After that,
    1.7 will enter the **Long Term Support** (**LTS**) period, where the focus will
    only be on bug fixes.  We can learn more about it from their blog post at [http://bit.ly/ng1-lte-support](http://bit.ly/ng1-lte-support).
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, AngularJS will continue to be supported and hence should not be a major
    concern for migration. The move to Angular can be decided based on what Angular
    has to offer over its predecessor.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is designed for the future and overcomes a number of shortcomings in
    its predecessor. In this section, we emphasize what makes Angular a better framework
    than AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things you should be aware of while making a decision to move to Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better behavioral encapsulation**: Admittedly, while AngularJS *scopes* seem
    to be god sent when we started learning AngularJS, we have now realized how difficult
    it is to manage the hierarchical nature of scopes. Component-based development
    in Angular provides a better encapsulation in terms of the state of the application.
    A component manages its own state, takes input, and raises events; a clear demarcation
    of responsibilities that are easy to reason with!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less of the framework in app code**: You don''t need special objects such
    as a *scope.* DI works with annotation (in TypeScript). You don''t set up watches.
    All in all, when reading a component code, you will not find framework-level constructs
    in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smaller framework API to explore**: AngularJS had a host of directives that
    one had to be aware of. With Angular template syntax, directives related to browser
    events are gone. This reduces the number of directives that one needs to be aware
    of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Angular is faster compared to its predecessor. A complete
    section of this book was dedicated to understanding what makes Angular a high-performance
    framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile-friendly**: Angular tries to optimize the user''s mobile experience
    by utilizing technologies such as server-side rendering and web workers. Angular
    applications on mobile are more performant that those of its predecessor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-platform**: Angular targets running on most devices and across platforms.
    You can use Angular to build applications for web and mobile. As we learned earlier,
    the separation of the rendering layer has open up a great number of possibilities
    in terms of where Angular can be utilized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a true sense, Angular supersedes its predecessor, and in a perfect world,
    everyone should be working on a better framework/technology. But migration is
    never easy, especially in this case, where the two frameworks differ a lot.
  prefs: []
  type: TYPE_NORMAL
- en: What we recommend is even if you do not plan to migrate to Angular today, build
    your AngularJS apps in ways that allow easy migration to Angular in future.
  prefs: []
  type: TYPE_NORMAL
- en: The next section talks about the principles and practices to follow for AngularJS
    today, allowing easy migration in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Developing AngularJS apps today for easy migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new Angular is a paradigm shift and the way we develop components in Angular
    is quite different from AngularJS. For easy migration, Angular too should embrace
    component-based development. This can be achieved if we follow some guidelines/principles
    while building AngularJS apps. The next few sections detail these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: The advice listed here is highly recommended even if you do not plan to migrate
    to Angular. These recommendation bits will make AngularJS code more modular, organized,
    and testable.
  prefs: []
  type: TYPE_NORMAL
- en: One component per file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This can be anything: an AngularJS *controller*, *directive*, *filter*, or
    *service*. One component per file allows better organization of code and easy
    migration, allowing us to clearly identify how much progress has been made.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding inline anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use named functions instead to declare controllers, directives, filters, and
    services. A declaration such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Should be converted to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The advantages of using named functions are ease of debugging and ease of migration
    to TypeScript. Using named functions also requires that the dependencies be registered
    using the `$inject` function property.
  prefs: []
  type: TYPE_NORMAL
- en: '`$inject`-based dependency declaration safeguards against minification and
    adds to the readability of the functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid exposing global name functions with this approach, it is advisable
    to wrap the function in an **Immediately Invoked Function Expression** (**IIFE**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding $scope!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, you read it right; avoid the `$scope`/`$rootScope` object or using scopes
    directly!
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with AngularJS scopes is their hierarchical nature. Accessing
    the parent scope from the child scope gives us tremendous flexibility, but it
    comes at a cost. This can unknowingly create unwarranted dependencies that make
    the app really hard to debug and, of course, migrate. In contrast, in Angular,
    a view is bound to its component implementation and cannot access data outside
    its boundary implicitly. Therefore, if you plan to migrate to Angular, *avoid
    scopes at all costs*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of techniques that can be used to remove the `$scope` object
    dependency. The next few subsections elaborate on some techniques that can help
    us avoid AngularJS scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Using controller as (controller aliasing) syntax everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS 1.3+ has the *controller as* syntax for *controllers*, *directives*,
    and *routes*. *controller as* syntax allows AngularJS data binding expressions
    to work against a controller's instance properties instead of the current *scope*'s
    object properties. With the controller as paradigm in place, we never need to
    interact with the scope directly, and hence future migration becomes easy.
  prefs: []
  type: TYPE_NORMAL
- en: While controller aliasing gets rid of scope access, scopes are still there in
    AngularJS. The complete AngularJS data binding infrastructure depends upon scopes.
    Controller aliasing just puts an indirection between our code and scope access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following syntax for *controller as* in views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And the corresponding controller implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutListController` as `workoutList` creates an alias `workoutList` for
    `WorkoutListController` on the current scope, hence allowing us to bind to the
    `workouts` property defined on the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Route definition too allows controller aliasing using the `controllerAs` property
    in a *route definition object*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, directives too can use `controllerAs`, and together with the `bindToController`
    property on the *directive definition object*, we can get rid of any direct scope
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the Angular documentation on controllers, routes, and directives to
    get a basic understanding of the controller as syntax. Also, look at the following
    posts for some more detailed samples on this topic: [http://bit.ly/ng1-controller-as](http://bit.ly/ng1-controller-as) and [http://bit.ly/ng1-bind-to](http://bit.ly/ng1-bind-to).'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding ng-controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If scopes can be avoided, so can controllers!
  prefs: []
  type: TYPE_NORMAL
- en: This may again seem counterintuitive, but the approach has real benefits. What
    we ideally want to do is emulate component behavior in AngularJS. Since the closest
    thing to components in AngularJS is *element directives* (with `restrict='E'`),
    we should utilize *element directives* everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: An AngularJS element directive with its own template and isolated scope can
    very well behave like an Angular component and only be dependent on its internal
    state for its view binding. We just don't need `ng-controller`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the use of `ng-controller` for audio tracking from the AngularJS version
    of the *Personal Trainer* app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `WorkoutAudioController`, an element directive can encapsulate
    the workout audio''s view and behavior. Such a directive can then replace the
    complete `ng-controller` declaration and its view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When replacing `ng-controller` with an element directive, the scope variables
    that the controller depends upon should be passed to the directive using the `bindToController`
    property on the *directive definition object—*something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This topic has been extensively covered in these two blogs posts by Tero: [http://bit.ly/ng2-no-controllers](http://bit.ly/ng2-no-controllers)
    and [http://bit.ly/ng2-refactor-to-component](http://bit.ly/ng2-refactor-to-component).
    Must-read posts with a wealth of information!'
  prefs: []
  type: TYPE_NORMAL
- en: Building using the AngularJS 1.5+ component API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularJS 1.5+ has a **component API** that allows us to create directives that
    can be easily migrated to Angular. The component API is preconfigured with sensible
    defaults, hence incorporating the best practices when it comes to building truly
    isolated and reusable directives.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the component API at [http://bit.ly/ng1-dev-guide-components](http://bit.ly/ng1-dev-guide-components) and
    this informative post by Tod Motto at [http://bit.ly/1MahwNs](http://bit.ly/1MahwNs) to
    learn about the component API.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate what has been emphasized earlier, these steps are not just targeted
    towards easy Angular migration but also towards making AngularJS code better.
    Component-based UI development is a better paradigm than what we are used to with
    AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: We highly recommend that you go through the AngularJS style guide ([http://bit.ly/ng1-style-guide](http://bit.ly/ng1-style-guide)).
    This guide contains a wealth of tips/patterns that allow us to build better AngularJS
    apps, and is in sync with the guidelines provided previously for easy Angular
    migration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we have decided to migrate, it's time to decide what to migrate.
  prefs: []
  type: TYPE_NORMAL
- en: What to migrate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an app in maintenance mode, where most of the development activity revolves
    around bug fixes and some enhancements, it would be prudent to stick to AngularJS.
    Remember the old saying *if it ain't broke, don't fix it*.
  prefs: []
  type: TYPE_NORMAL
- en: If the app is being actively developed and has a clear long-term roadmap, migrating
    to Angular is worth considering. As we dig deeper into the intricacies of migration,
    we will realize the time and effort involved in the process. While the Angular
    team has worked really hard to make this migration smooth, by no stretch of the
    imagination is this a trivial job. It is going to take a good amount of time and
    effort to perform the actual migration.
  prefs: []
  type: TYPE_NORMAL
- en: The silver lining here is that we do not need to migrate everything at once.
    We can work slowly towards migrating parts of the AngularJS code base to Angular.
    Both the frameworks can coexist and can depend on each other too. This also allows
    us to develop new parts of applications in Angular. How cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: But again, this flexibility comes at a cost—the cost of bytes. As both frameworks
    are downloaded, the page bytes do increase, something that we should be aware
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Also, while the coexistence of both the frameworks allows us to migrate without
    much disruption, we cannot make it a perpetual activity. Eventually, AngularJS
    has to go, and the sooner it does the better.
  prefs: []
  type: TYPE_NORMAL
- en: During migration, the best thing that can be done is to carve out new SPAs within
    the existing application. For example, we can build the Admin area of an app entirely
    using Angular, with a separate host page, but still share the common infrastructure
    of style sheets, images, and even AngularJS services if we refactor the code a
    bit. As we will learn later, migrating services to Angular is the easiest.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking an application into multiple smaller ones introduces full-page refreshes,
    but this is a cleaner approach when it comes to migration.
  prefs: []
  type: TYPE_NORMAL
- en: Taking all of this into consideration, if we have decided to migrate and identified
    areas of migration, you need to do the prep work for migration.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for Angular migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the big brave world of Angular migration! A successful migration
    strategy involves making sure that we do the groundwork beforehand, avoiding any
    late surprises.
  prefs: []
  type: TYPE_NORMAL
- en: As prep work, the first step is to analyze the application from a third-party
    library dependency perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying third-party dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any third-party library that an AngularJS app uses needs a migration strategy
    too. These could be either jQuery-based libraries or AngularJS libraries.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jQuery libraries in AngularJS were consumed by creating a directive wrapper
    over them. We will have to migrate such directives to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migrating AngularJS libraries is a bit of a tricky affair. AngularJS has a massive
    ecosystem, and Angular too has been around for some time and now has a healthy
    community. When migrating, each AngularJS library needs to be substituted with
    an Angular alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not find a perfect upgrade path for a specific library, we can either:'
  prefs: []
  type: TYPE_NORMAL
- en: Customize a similar component/library available out there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the more radical approach of building our own library from the ground up
    in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these choices has trade-offs in terms of time and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Another choice that needs to be made is the development language. Should we
    use TypeScript, ES2015, or plain old JavaScript (ES5)?
  prefs: []
  type: TYPE_NORMAL
- en: Choice of language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We would definitely recommend TypeScript. It's a super awesome language that
    integrates very well with Angular and vastly reduces the verbosity of Angular
    declarations. Also, given that it can coexist with JavaScript, it makes our lives
    easier. Even without Angular, TypeScript is one language that we should embrace
    for the web platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we will migrate the AngularJS *Personal Trainer* app
    to Angular. The app is currently available on *GitHub* at [http://bit.ly/a1begit](http://bit.ly/a1begit).
    This app was part of the first version of this book, *AngularJS by Example*, and
    was built using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We are again going to follow the checkpoint-based approach for this migration.
    The checkpoints that we highlight during the migration have been implemented as
    GitHub branches. Since we will be interacting with a *Git* repository for v1 code
    and using *Node.js* tools for the build, please set up Git and Node.js on your
    development box before proceeding further.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating AngularJS's Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we even begin the migration process, we need to set up the v1 *Personal
    Trainer* locally.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the migrated app can be downloaded from the GitHub site at [https://github.com/chandermani/angularjsbyexample](https://github.com/chandermani/angularjsbyexample).
    Since we migrate in chunks, we have created multiple checkpoints that map to **GitHub
    branches** dedicated to migration. Branches such as `ng6-checkpoint8.1`, `ng6-checkpoint8.2`,
    and so on highlight this progression. During the narration, we will highlight
    the branch for reference. These branches will contain the work done on the app
    up to that point in time.
  prefs: []
  type: TYPE_NORMAL
- en: The *7 Minute Workout* code is available inside the repository folder named
    `trainer`.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up AngularJS's Personal Trainer locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps and you will be up and running in no time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line, clone the v1 GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the new Git repo and check out the `ng6-base` branch to get started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since the app loads its workout data from **MongoDB** hosted in **mLab **([https://mlab.com/](https://mlab.com/)),
    you need an mLab account to host workout-related data. Set up an mLab account
    by signing up with them. Once you have an mLab account, you need to retrieve your
    API key from mLab's management portal. Follow the instructions provided in the
    API documentation ([http://bit.ly/mlab-docs](http://bit.ly/mlab-docs)) to get
    your API key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the API key, update this line in `app/js/config.js` with your
    API key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And add some seed workout data into your mLab instance. The instructions to
    add the seed data into mLab are available in the source code file, `app/js/seed.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, install the necessary *npm packages* required for v1 *Personal Trainer*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `http-server`; it will act as a development server for our v1 app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the setup is complete by starting the `http-server` from the `app`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: And open the browser location `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: The v1 *Personal Trainer* start page should show up. Play around with the app
    to verify that the app is working fine. Now, the migration can begin.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step before we begin migrating v1 *Personal Trainer* is to identify
    the external libraries that we are using in the AngularJS version of Personal
    Trainer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external libraries that we are using in v1 are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`angular-media-player`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-local-storage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-translate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angular-ui-bootstrap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owl. carousel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries such as `angular-media-player` and `angular-local-storage` are easy
    to migrate/replace. We have already done this in earlier chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The `angular-translate` library can be replaced with `ngx-translate`, and as
    we will see in the coming sections, it is not a very challenging task.
  prefs: []
  type: TYPE_NORMAL
- en: We use `angular-ui-bootstrap` for **modal dialogs** in *Personal Trainer v1*.
    We replace it with `ngx-modialog` ([http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog))
    as the only control we were using from `angular-ui-bootstrap` was the dialog control.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have sorted out the external dependencies, let's decide the language
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: While the existing code base is JavaScript, we love TypeScript. Its type safety,
    its terse syntax, and how well it plays with Angular makes it our language of
    choice. Hence, it's going to be TypeScript all the way.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that tilts the decision in favor of TypeScript is that we do not
    need to migrate the existing code base to TypeScript. Anything we migrate/build
    new, we build it in TypeScript. Legacy code still remains in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start. As a first migration task, we need to set up a module loader for
    our v1 Personal Trainer.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the module loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to create a number of new Angular components spread across
    numerous small files, adding direct script reference is going to be tedious and
    error-prone. Angular CLI also is not of much help here as it cannot manage the
    existing codebase implemented in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a **module loader**. A module loader (*ES6 modules* and not Angular)
    can help us with:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating isolated/reusable modules based on some common module formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the script loading order based on dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing bundling/packaging of a module and on-demand loading for dev/production
    deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the **SystemJS** module loader for this migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install SystemJS from the command line using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: All the commands need to be executed from the `trainer/app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: We open `index.html` and remove all the script references of our app scripts.
    All script references with the source as `src='js/*.*'` should be removed, except
    `angular-media-player.js` and `angular-local-storage.js`, as they are external
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We are not removing script references for third-party libraries, but
    only app files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add SystemJS configurations after all third-party script references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `ng-app` attribute on the `body` tag, keeping the `ng-controller`
    declaration intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `ng-app` way of bootstrapping has to go as we switch to the `angular.bootstrap`
    function for manual bootstrapping. Manual bootstrapping helps when we bring Angular
    into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `SystemJS.import` call loads the application by loading the first
    app module (JavaScript) defined in `js/app.js`. We are going to define this JavaScript
    module shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `app.module.js` in the same folder as `app.js` and
    copy the complete contents of `app.js` into `app.module.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to get rid of the `use strict` statement. The TypeScript compiler does
    not like it.
  prefs: []
  type: TYPE_NORMAL
- en: All the app module definitions are now in `app.module.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, clear `app.js` and add the following imports and bootstrap code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have added *ES6 import statements* to `app.js`. These are the same scripts
    that were earlier referenced in `index.html`. SystemJS now loads these script
    files when loading `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving all of the AngularJS module declarations into a new file, `app.module.js`,
    and importing it first into `app.js` makes sure that the AngularJS modules are
    defined before any of the `import` statements are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse *ES6 modules* and *AngularJS modules* defined/accessed using
    `angular.module('name')`. These two are altogether different concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The last few lines bootstrap the AngularJS application using the `angular.bootstrap`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Module loading is enabled now; let's enable TypeScript too.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable TypeScript, install the TypeScript compiler using *npm*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `package.json` and add these lines inside the script configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The new script's properties that we just added provide a shortcut for commonly
    executed commands.
  prefs: []
  type: TYPE_NORMAL
- en: To enable IDE IntelliSense for JavaScript libraries, we need to install their
    type definitions. **Type definitions** or **typings** are files that define the
    public interface for a TypeScript/JavaScript library. These type definitions help
    IDEs provide IntelliSense around the library functions. Typings are available
    for most of the popular JavaScript libraries and for frameworks/libraries written
    in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install typings for the libraries we use. From the command line, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, copy `overrides.d.ts` from `checkpoint8.1` to the local `app` folder.
    This helps TypeScript compiler to handle the global `angular` object used in `app.js` and
    other places.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to set up some configurations for the TypeScript compiler. Create
    a file called `tsconfig.json` (in the `trainer/app` folder) and copy the configuration
    from the `ng6-checkpoint8.1` repo branch (also available remotely at [http://bit.ly/ng6be-8-1-tsconfig](http://bit.ly/ng2be-8-1-tsconfig)).
    Run the compiler using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This should start the TypeScript compiler, and there should be no errors reported.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this command running in a separate console window at all times during development.
    The compiler will continuously watch for changes to the TypeScript file and rebuild
    the code if changes are detected.
  prefs: []
  type: TYPE_NORMAL
- en: Change the extension of the `app.js` and `app.module.js` files to `app.ts` and
    `app.module.ts`. The TypeScript compiler detects these changes and compiles the
    TypeScript files. After compilation, the compiler produces two files for each
    TypeScript file. One is the compiled JavaScript file (such as `app.js`) and the
    other is a map file (`app.js.map`) for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We have not set up an elaborate build for this exercise as our primary focus
    is on migration. For your own apps, the initial setup steps may vary depending
    upon how the build is already set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we test our new changes, `config.js` needs to be fixed because we have
    enabled strict DI check-in AngularJS through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `config.js` content with updated content available in `ng6-checkpoint8.1`
    or at [http://bit.ly/ng6be-8-1-configjs](http://bit.ly/ng2be-8-1-configjs) (and
    remember to set the API key again). The update fixes the `config` function and
    makes it minification-friendly. Time to test the app!
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the TypeScript compiler is running in one console; run `http-server
    -c-1` in a new console window.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `http://localhost:8080` the app start page should load.
  prefs: []
  type: TYPE_NORMAL
- en: Commit/save your local changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If things work fine, you can even commit your local changes to your git repo.
    This will help you track what has changed over time as we migrate the app piece
    by piece. The implementation till this point is available in the `ng6-checkpoint8.1`
    GitHub branch. If you are facing problems, compare the `ng6-base` and `ng6-checkpoint8.1`
    branches to understand the changes made. Since the code is hosted in GitHub, we
    can use the *GitHub compare* interface to compare commits in a single branch.
    See the documentation on how to do it here: [http://bit.ly/github-compare](http://bit.ly/github-compare).
    The link at [http://bit.ly/ng6be-compare-base-8-1](http://bit.ly/ng6be-compare-base-8-1) shows
    a comparison between `ng6-base` and `ng6-checkpoint8.1`. You can ignore the diff
    view for `app.js` and `app.module.js`, generated as part of the TypeScript compilation.'
  prefs: []
  type: TYPE_NORMAL
- en: Time to introduce Angular!
  prefs: []
  type: TYPE_NORMAL
- en: Adding Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by installing Angular and dependent *npm modules* for our app. We will
    update the `package.json` file with the necessary packages first.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the updated package file from [http://bit.ly/ng6be-8-2-package-json](http://bit.ly/ng6be-8-2-package-json)
    into your local installation.
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json` now references some new packages related to Angular. Install
    the referenced packages by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you are having trouble with installing packages with `npm install`, delete
    the `node_modules` folder and run `npm install` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add a few library references that Angular is dependent upon (and are
    not loaded using SystemJS) in `index.html` before the `system.src.js` script reference
    (two in total):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As it stands now, the SystemJS configuration has been set up in the `index.html`
    file itself. Since Angular requires some decent amount of configuration, we are
    going to create a separate *SystemJS configuration file* instead, and reference
    that in `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this script reference after the `system.src.js` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, clear the `script` section containing the call to the `System.config`
    function and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `systemjs.config.js` from [http://bit.ly/ng6be-8-2-system-js-config](http://bit.ly/ng6be-8-2-system-js-config) and
    place it in the same folder as `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, update `tsconfig.json` and add a new property called `moduleResolution`
    to `compilerOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This instructs TypeScript to look for type definitions in the `node_modules`
    folder. Remember, Angular typings are bundled as part of the Angular library itself,
    and hence a separate type definition import is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Angular-specific references have been added, we need to modify
    the existing bootstrap process to also load Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The ngUpgrade Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support gradual migration from AngularJS to Angular, the Angular team has
    released a library, `ngUpgrade`. The library contains a set of services that allow
    AngularJS and Angular to be loaded in tandem and play well together. This library
    has services that can help:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap an app with both the AngularJS and Angular frameworks loaded. This
    is the first thing we are going to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate an Angular component in an AngularJS view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporate an AngularJS component in an Angular view, albeit with some limitations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share dependencies across the frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The primary tool in this library is* `UpgradeModule`. As the platform documentation
    summarizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '"This is a module that contains utilities for bootstrapping and managing hybrid
    applications that support both Angular and AngularJS code."'
  prefs: []
  type: TYPE_NORMAL
- en: As we make progress with our migration efforts, the role of `UpgradeModule`
    becomes clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to bootstrap the hybrid AngularJS and Angular app using `UpgradeModule`.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the hybrid app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bootstrap a hybrid application, we must bootstrap both the Angular and AngularJS
    parts of the application. The sequence involves the process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap the Angular app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, using`UpgradeModule`, bootstrap the AngularJS app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Angular has just been added, we need to define the root app module for
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `app-ng1.module.js`, and copy the complete content of `app.module.ts`
    to the new file. We will use the `app.module.ts` file to define an Angular module
    and hence the existing AngularJS module has been shifted to a new file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, remember to update the `import` statement in `app.ts` in line with the
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add the Angular root module definition to `app.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the content of `app.module.ts` with the Angular module definition. Copy
    the new definition from `ng6-checkpoint8.2` (GitHub location: [http://bit.ly/ng6be-8-2-app-module-ts](http://bit.ly/ng6be-8-2-app-module-ts)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppModule` implementation defines a function, `ngDoBootstrap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The Angular framework invokes this function as part of the application bootstrap.
    This function internally uses the `bootstrap` function of `UpgradeModule` to bootstrap
    the AngularJS app. This function takes the same argument as the `angular.bootstrap`
    function takes.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have defined the root module for Angular, we still have not defined
    the entry point for the Angular application. Create a new file, `main.ts`, in
    the app folder and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This code, when executed, instructs the Angular framework to bootstrap the application
    with `AppModule`. The statement `import './app'` helps in loading all the script
    references in `app.ts`. Before proceeding, do remember to remove the AngularJS
    application bootstrapping code from `app.ts` (the complete `angular.element` block).
  prefs: []
  type: TYPE_NORMAL
- en: Refresh your app and make sure it works as before. Do watch out for errors in
    the TypeScript compiler console window or browser console log.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We now have a hybrid app up and running. Both frameworks are
    now working in tandem.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `ng6-checkpoint8.2` branch if you are facing issues upgrading to
    Angular. Again, you can also compare the git branches `ng6-checkpoint8.1` and
    `ng6- checkpoint8.2` to understand what has changed ([http://bit.ly/ng6be-compare-8-1-8-2](http://bit.ly/ng6be-compare-8-1-8-2)).
  prefs: []
  type: TYPE_NORMAL
- en: The migration process can start now. We can start by migrating a part of an
    AngularJS view/directive to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Angular components into AngularJS views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common migration pattern involves migrating lower-level AngularJS directives/views
    to Angular components. If we visualize the AngularJS HTML view structure as a
    tree of directives, we start at the leaf. We migrate parts of a directive/view
    to an Angular component and then embed the component inside the AngularJS view
    template. This Angular component is injected into the AngularJS view as an *element
    directive*.
  prefs: []
  type: TYPE_NORMAL
- en: The closest thing to **Angular components** that AngularJS has is **element
    directives**. During migration, we are either migrating element directives or
    controller-view pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a bottom-up approach to migrating view/directives to Angular components.
    The following diagram highlights how the AngularJS view hierarchy gradually transforms
    into an Angular component tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's migrate something small and get a feel for how things work. `ExerciseNavController`
    and its corresponding view fit the bill.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating our first view to Angular component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ExerciseNavController` is part of *Workout Builder* and is located inside
    `trainer/app/js/WorkoutBuilder/exercise.js`. The corresponding view is served
    from `trainer/app/partials/workoutbuilder/left-nav-exercises.html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary purpose of this controller-view pair is to show the list of available
    exercises when building a workout (available user path `http://localhost:8080/#/builder/workouts/new`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on any of these exercise names adds the exercise to the workout being
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with creating a component for the preceding view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting on the new component, add a new *Workout Builder* module (`WorkoutBuilderModule`)
    to the application. Copy the module definition from `ng6-checkpoint8.3` in the
    `WorkoutBuilder` folder (GitHub location: [http://bit.ly/ng6be-8-3-workout-builder-module-ts](http://bit.ly/ng6be-8-3-workout-builder-module-ts)).
    Also, import the newly created module in `app.module.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inlining the complete code here, we suggest copying the `exercise-nav.component.ts`
    file from GitHub branch `ng6-checkpoint8.3` ([http://bit.ly/ng6be-8-3-exercise-nav-component-ts](http://bit.ly/ng6be-8-3-exercise-nav-component-ts))
    and adding it to the `WorkoutBuilder` folder locally. The file has already been
    referenced in `WorkoutBuilderModule`. We also add `ExerciseNavComponent` to `entryComponents`
    array as the component will be used from AngularJS module directly.
  prefs: []
  type: TYPE_NORMAL
- en: From an implementation standpoint, let's look at some relevant parts.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting template syntaxThe Angular team has published an excellent reference
    ([http://bit.ly/ng2-a1-a2-quickref](http://bit.ly/ng2-a1-a2-quickref)) that details
    the common view syntaxes in AngularJS and their equivalents in Angular. Highly
    recommended when migrating an AngularJS app!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, if you look at the `exercise-nav.component.ts` file, the component
    template is similar to `left-nav-exercises.html` used in AngularJS, except there
    is no `ng-controller` and the template bindings are Angular-based:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we focus on the component implementation (`ExercisesNavComponent`), the
    first striking thing is the component''s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutService` and `WorkoutBuilderService` are AngularJS services injected
    into Angular components.'
  prefs: []
  type: TYPE_NORMAL
- en: Nice! If that is your initial reaction, we can't blame you. The ease with which
    we can inject AngularJS service into Angular is pretty cool! But the story is
    still incomplete. There is no magic happening here. Angular cannot access AngularJS
    services unless it is told where to look. To help Angular, we need to create *factory
    provider* wrappers for the AngularJS service.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting AngularJS dependencies into Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we allow an AngularJS service to be used in Angular, we are *upgrading*
    the service. The way it is done is by creating a **factory provider wrapper**
    over the existing AngularJS service and registering the wrapper with an Angular
    module or component.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create wrappers for the two AngularJS services, `WorkoutService` and `WorkoutBuilderService`,
    that we have used in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A factory provider for an AngularJS service can be created using Angular''s
    dependency injection API. Here is an example of a factory provider for `WorkoutService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `$injector` is the AngularJS *injector service* and we are referencing
    the injector in the Angular execution context. The call to  `injector.get('WorkoutService');`
    in the previous factory function retrieves the service from AngularJS realm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider created can then be registered with the app module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The shortcoming of this approach is that we have to define the factory function
    (`workoutServiceFactory`) and provider (`workoutServiceProvider`) for each service.
    That is too much code!
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can create a generic factory provider and factory function implementation,
    which can take any AngularJS service and register it with the same name (*string
    token*) in Angular. We have already done the hard work and created a new class, `UpgradeHelperService.`
    Download it from the codebase for `ng6-checkpoint8.3` ([http://bit.ly/ng6be-upgrade-helper-service-ts](http://bit.ly/ng6be-upgrade-helper-service-ts)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation exposes a function, `upgradeService`, which takes one argument,
    the name of the AngularJS service, and returns a factory provider instance. The
    factory provider implementation internally uses a *string token* to register the
    dependency. To create a factory provider for an AngularJS service, we just need
    to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Service dependencies at times have other dependencies, and hence it''s better
    if we bring in all the service dependencies from AngularJS in one go. Register
    all the existing AngularJS dependencies as factory providers in `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Back to component integration! As the new  `ExercisesNavComponent` is rendered
    inside an AngularJS view, it needs to be registered as an *AngularJS directive*.
  prefs: []
  type: TYPE_NORMAL
- en: Registering Angular components as directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ExercisesNavComponent` can be converted into an AngularJS directive using
    `ngUpgrade` library function `downgradeComponent.` As the function name suggests,
    we are downgrading an Angular component into an AngularJS element directive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app.ts` and add the highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `downgradeComponent` function returns a *factory function* containing the
    *directive definition object*. We register the component as an AngularJS directive,
    `exerciseNav`.
  prefs: []
  type: TYPE_NORMAL
- en: Every Angular component is registered as an *element directive* when used in
    AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: The component implementation is complete. We now need to clean up the old code
    and inject the new directive into the view.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the definition of `ExercisesNavController` from `exercise.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the content of `left-nav-exercises.html` (located in the `partials`
    folder) with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do not get rid of `left-nav-exercises.html` as AngularJS still
    loads `left-nav-exercises.html` as part of the route transition, but the view
    inside is an Angular component.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try out the new implementation. Create a new workout and try to
    add exercises from the left nav. The functionality should work as before.
  prefs: []
  type: TYPE_NORMAL
- en: Look at `ng6-checkpoint8.3` in case you are facing issues upgrading to Angular.
    You can compare the git branches `ng6-checkpoint8.2` and `ng6-checkpoint8.3` to
    understand what has changed ([http://bit.ly/ng6be-compare-8-2-8-3](http://bit.ly/ng6be-compare-8-2-8-3)).
  prefs: []
  type: TYPE_NORMAL
- en: While we have only migrated a trivial component, this exercise highlights how
    easy it is to convert/downgrade an Angular component to the AngularJS directive
    and use it in an AngularJS view. The overall encapsulation of an Angular component
    makes this chore easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This downgraded component can even take an input from the parent scope using
    the familiar Angular property binding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add to that, the event raised by the component can be subscribed by the AngularJS
    container scope too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We now have an Angular component running inside AngularJS using services initially
    designed for AngularJS. A promising start to our migration journey!
  prefs: []
  type: TYPE_NORMAL
- en: Before we move any further, it's time to highlight how this collaboration works
    and the rules of engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Rules of engagement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The migration story from AngularJS to Angular is only possible because these
    frameworks can coexist, and possibly share data. There are some touch points where
    the boundaries can be crossed. To have a better sense of how a hybrid application
    works and what is achievable in such a setup, we need to understand the areas
    of collaboration between the two frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three areas that need discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: Template interleaving in the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Angular components and AngularJS directives can coexist in a DOM, the
    question we need to answer is who owns what parts of the DOM?
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS directives and Angular components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to ownership of a DOM element, the golden rule is:'
  prefs: []
  type: TYPE_NORMAL
- en: Every DOM element is owned/managed by exactly one of the Angular frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Take our previous migration example. The view that is part of `ExercisesNavComponent`
    is managed by Angular, whereas the container view (`left-nav-exercises.html`)
    is managed by AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get a bit tricky at the boundaries of these directives and components.
    Consider the declaration inside `left-nav-exercises.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Who owns this? The short answer is AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is an Angular component, the host element is owned by AngularJS.
    This means all AngularJS template syntax works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As these components and directives coexist in the same view, they often need
    to communicate. There are two ways to manage this communication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the templating capabilities of AngularJS and Angular:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Angular component embedded inside an AngularJS view can take inputs from
    the parent scope using event and property binding
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a similar fashion, if a directive is injected into an Angular component view,
    it too can get inputs from the parent component and call the parent component
    function (through its isolated scope)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared services; we saw an example of this previously as we injected the
    `WorkoutService` and `WorkoutBuilderService` AngularJS services into `ExercisesNavComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting AngularJS directives into Angular is a bit tricky. To be able to inject
    an AngularJS directive into an Angular template, the directive needs to abide
    by some rules. We will talk about these rules in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing functionality using services is far more flexible compared to sharing
    through view templates. Injecting services across framework boundaries requires
    us to register the service across both frameworks and let Angular take care of
    the rest. Let's learn how dependency injection works across boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Resource sharing and dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How dependencies are registered in a hybrid app is driven by how DI works in
    these two frameworks. For AngularJS, there is only one global injector, whereas
    Angular has a concept of hierarchical injectors. In a hybrid environment, the
    least common denominator is the global injector that both the frameworks support.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing an AngularJS service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the factory provider example earlier, AngularJS services can be
    registered with Angular by creating a wrapper factory provider.
  prefs: []
  type: TYPE_NORMAL
- en: Since dependency injection in AngularJS is string token-based, the corresponding
    providers too use string tokens to locate dependencies in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at the example of dependency registration share earlier, the dependency
    was registered with a help of a helper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And it was injected using the `Inject` decorator (with a string token):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Sharing an Angular service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Services from Angular too can be injected into AngularJS. Since AngularJS only
    has a global injector, the dependency is registered at the global level. The `ngUpgrade`
    library has a `downgradeInjectable` function for this. The `downgradeInjectable` function
    creates a factory function than can be consumed by the AngularJS module''s `factory`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`MyService` can now be injected across the AngularJS app, like any other service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following diagram; it summarizes what we have discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One last topic of this discussion is change detection.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a hybrid application, change detection is managed by Angular. If we are used
    to calling `$scope.$apply()` in our code, we don't need to do it in a hybrid application.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed how Angular change detection works. The Angular framework
    takes care of triggering AngularJS change detection by internally calling `$rootScope.$apply()`
    on standard triggering points.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the rules of engagement, it is easier to comprehend how
    things work, what's feasible, and what's not.
  prefs: []
  type: TYPE_NORMAL
- en: Let's set some bigger/meatier targets and migrate the start and finish pages
    of the v1 app.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the start and finish pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finish page migration is easy to do, and I suggest you do it yourself. Create
    a folder called `finish` inside the `js` folder, and create two files, `finish.component.ts`
    and  `finish.component.html`. Implement the component by looking at the existing
    implementation (or copy it from `ng6-checkpoint8.4`).
  prefs: []
  type: TYPE_NORMAL
- en: Add the component to the `declarations` and `entryComponents` array on  `AppModule`
    (`app.module.ts`). And then, fix the route for the finish to load the finish component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to also downgrade `FinishComponent` using the `downgradeComponent`
    function (check `app.ts`) and to fix the AngularJS *finish route* to use the new
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, remember to delete the finish HTML template from the `partials/workout`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you are stuck in migrating the finish page, compare the `ng6-checkpoint8.3`
    and `ng6-checkpoint8.4` git branches to understand what has changed in the `8.4`
    branch ([http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng2be-compare-8-3-8-4)).
  prefs: []
  type: TYPE_NORMAL
- en: The finish page was easy, the start page is not! While the start page seems
    to be an easy target, there are some challenges that require some head-scratching.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the start page template (`partials/workout/start.html`); the biggest
    issue with the start page is that it uses a third-party library, *angular-translate*,
    to localize the content of the page. Since we are migrating the complete page/view
    to Angular, we need a mechanism to handle these AngularJS library dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '*angular-translate* comes with a *filter* (*pipe* in the Angular world) and
    a directive, both named `translate`. Their job is to translate string tokens into
    localized string literals.'
  prefs: []
  type: TYPE_NORMAL
- en: If the *start* page becomes an Angular component, we need to convert the filter
    into an Angular pipe and, in some way, make the `translate` directive work in
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have at least these two choices to handle this migration scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new filter, also upgrade the v1 `translate` directive using `UpgradeModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a suitable replacement for *angular-translate* in the Angular world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the first choice seems to be the easiest, it has some serious limitations.
    Angular imposes some stringent requirements around how a directive can be upgraded
    to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading an AngularJS directive does not mean the directive has been migrated.
    Angular instead allows us to use an AngularJS element directive as is inside Angular
    component views.
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS directive upgrade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, the parts of an application may be migrated in a top-down fashion;
    a higher-order view is converted into a component. In such a case, instead of
    migrating all the custom directives that are part of the AngularJS view, we just
    upgrade them to Angular components using some interfaces and functions defined
    in the  `UpgradeModule`. The following diagram illustrates this migration path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Angular framework puts some restrictions on what can be upgraded to an Angular
    component. Here is an excerpt from the Angular migration guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be Angular compatible, an AngularJS component directive should configure
    these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`restrict: ''E''`. Components are usually used as elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scope: {}` - an isolate scope. In Angular, components are always isolated
    from their surroundings, and you should do this in AngularJS too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindToController: {}`. Component inputs and outputs should be bound to the
    controller instead of using the `$scope`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controller and controllerAs`. Components have their own controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template or templateUrl`. Components have their own templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Component directives may also use the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transclude: true/{}`, if the component needs to transclude content from elsewhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require`, if the component needs to communicate with some parent component''s
    controller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Component directives should not use the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`. This will not be supported in Angular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`: True. Angular never replaces a component element with the component
    template. This attribute is also deprecated in AngularJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority` and `terminal`. While AngularJS components may use these, they are
    not used in Angular and it is better not to write code that relies on them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only AngularJS directives that can be upgraded to Angular are element directives,
    given that all other conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: With this sizeable laundry list, upgrading an AngularJS directive to Angular
    is difficult when compared to an Angular component downgrade. More often than
    not, we have to do an actual code migration of an AngularJS directive if the parent
    view has been migrated to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `angular-translate` source code, we realize it uses the `$compile`
    service; therefore, the upgrade option is ruled out. We need to find an alternative
    library.
  prefs: []
  type: TYPE_NORMAL
- en: We do have an internationalization library for Angular, `ngx-translate` ([http://www.ngx-translate.com/](http://www.ngx-translate.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Replacing angular-translate with ngx-translate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*ngx-translate* is an internationalization library that targets Angular. This
    library can replace v1 *angular-translate*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the npm package for `ngx-translate` and `ngx-translate/http-loader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The *http-loader* loads the localization files from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `systemjs.config.js` to include the `*ngx-translate*` library. Add entries
    to the `map` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As described in the `ngx-translate` documentation, we need to configure the
    translate module and HTTP loader. Open `app.module.ts` and add the highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The preceding provider declaration sets up a loader that loads the translation
    files (`.json`) from the `i18n` folder. The `HttpClientModule` import is required
    for the translate library to load translations from the server. Remember to copy
    the translation files (`*.json`) from git branch `ng6-checkpoint8.4` ([http://bit.ly/ng6be-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these import statements to `app.module.ts` to keep the TypeScript compiler
    happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `ngx-translate` library is now ready to be used. The first thing that we
    are going to do is set the default translation language as soon as the application
    bootstraps.
  prefs: []
  type: TYPE_NORMAL
- en: Using ngDoBootstrap for initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Angular, luckily the `AppModule` already defines a function, `ngDoBootstrap`,
    that the framework calls when bootstrapping an AngularJS application—a perfect
    place to do `ngx-translate` initialization. Update the `ngDoBootstrap` function
    in `app.module.ts` with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The code tries to determine the current browser language and sets the current
    language for translations accordingly. Make note of how we get hold of `TranslateService`.
    The `UpgradeModule` object holds the reference to Angular's *root injector*, which
    in turn loads `TranslateService` from `ngx-translate`.
  prefs: []
  type: TYPE_NORMAL
- en: With the background work done for the start component, copy the start page implementation
    from the `ng6-checkpoint8.4` branch ([http://bit.ly/ng6be-8-4-start](http://bit.ly/ng6be-8-4-start))
    into a new folder `app/js/start`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, add the start component declaration to `app.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other components registered as an AngularJS directive before use, add
    this statement to `app.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The start template file now uses the `translate` pipe (the name of the pipe
    is the same as the AngularJS filter `translate`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The start page also has three pipes, `search`, `orderBy`, and `secondsToTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Copy the implementation for these pipes together with the definition of the
    shared module (`shared.module.ts`) from `ng6-checkpoint8.4` ([http://bit.ly/ng6be-8-4-shared](http://bit.ly/ng6be-8-4-shared))
    and add it to the `js/shared` folder locally. Also, remember to import the shared
    module (`shared.module.ts`) into the app module (`app.module.ts`). We will not
    dwell on any of the pipe implementation here, as we have done that already in
    earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Start and finish component implementation is complete. Let's integrate them
    into the app.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the start and finish pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start/finish views are loaded as part of route change, so we need to fix the
    route definition in `config.js`. Update the start and finish route definitions
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The route template HTML is a part of the AngularJS view. Since we have registered
    both `StartComponent` and `FinishComponent` as AngularJS directives, the route
    loads the correct components.
  prefs: []
  type: TYPE_NORMAL
- en: If you have already migrated the finish page, you do not need to redo the route
    setup for finish as described.
  prefs: []
  type: TYPE_NORMAL
- en: A few more fixes are pending before we can test the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to copy the translation files `de.json` and `en.json` from the `ng6-checkpoint8.4`
    folder `i18n` ([http://bit.ly/ng6-8-4-i18n](http://bit.ly/ng6be-8-4-i18n)). Now,
    we are ready to test what we have developed.
  prefs: []
  type: TYPE_NORMAL
- en: If not started, start the TypeScript compiler and HTTP-server, and then launch
    the browser. The start and finish pages should load just fine. But the translations
    do not work! Clicking on the language translation links on the top nav has no
    effect. Content always renders in English.
  prefs: []
  type: TYPE_NORMAL
- en: We now are at checkpoint `ng6-checkpoint8.4`. If you are stuck, compare the
    git branches `ng6-checkpoint8.3` and `ng6-checkpoint8.4` to understand what changed
    ([http://bit.ly/ng6be-compare-8-3-8-4](http://bit.ly/ng6be-compare-8-3-8-4)).
  prefs: []
  type: TYPE_NORMAL
- en: The translations still do not work because the top nav code (`root.js`) that
    enables translation is still using the older library. We need to get rid of angular-translate
    (the v1 library) altogether. Having two libraries doing the same work is not something
    we want, but removing it is also not that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of angular-translate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get rid of the angular-translate (v1) library, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the angular-translate's directive/filter references from all AngularJS
    views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of any code that uses this library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting rid of the v1 directive/filter altogether is a difficult task. No can
    we use the v2 `ngx-translate` pipe in the AngularJS view. Also, migrating every
    view using the v1 translate directive/filter to Angular at one shot is feasible.
    There has to be a better solution out there? And there is!
  prefs: []
  type: TYPE_NORMAL
- en: Why not write a new AngularJS filter that uses ngx-translate's translation service
    (`TranslateService`) for translations and then use the new filter everywhere?
    Problems solved!
  prefs: []
  type: TYPE_NORMAL
- en: Let's call this filter `ngxTranslate`. We replace all references to the `translate`
    filter in the v1 view with `ngxTranslate`. All v1 `translate` directive references
    too are replaced with an `ngxTranslate` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the filter implementation looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `ngx-translate.filter.ts` in the `shared` folder and add
    the preceding implementation. The filter uses `TranslateService` to localized
    content. To make the service discoverable in AngularJS, it needs to be downgraded
    using the `ngUpgrade` module method `downgradeInjectable`. Open  `app.ts` and
    add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This code registers `TranslateService` using a string token, `'TranslateService'`,
    in AngularJS. The first import statement also loads the new filter at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To test this implementation, there are a few more steps needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, replace all references to `translate` (directive and filter)
    across the AngularJS view with `ngxTranslate`. There are references in these files:
    `description-panel.html`, `video-panel.html`, `workout.html` (in the folder `partials/workout`),
    and `index.html`. Replacing the filter in the interpolation is a simple exercise.
    For the `translate` directive, replace it with interpolation. For example, in
    `partials/workout/description-panel.html`, the line of code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It then becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Remember to quote the string token (`'RUNNER.STEPS'`) inside the interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, copy the updated `root.js` from [http://bit.ly/ng6be-8-5-root-js](http://bit.ly/ng6be-8-5-root-js).
    We have replaced all references to the `$translate` service with `TranslateService` and
    refactored the code to use the new service. `root.js` contains the implementation
    for the v1 `RootController`.
  prefs: []
  type: TYPE_NORMAL
- en: We are good to go now. Try out the new implementation; the app should load translation
    using the *ngx-translate* library.
  prefs: []
  type: TYPE_NORMAL
- en: We can now delete all references to *angular-translate*. There are references
    in `index.html`, `app-ng1.module.ts`, and `config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The migration of the start and finish pages is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Compare the branches `ng6-checkpoint8.4` and `ng6-checkpoint8.5` to understand
    the new changes in `ng6-checkpoint8.5` ([http://bit.ly/ng6be-compare-8-4-8-5](http://bit.ly/ng2be-compare-8-4-8-5)).
  prefs: []
  type: TYPE_NORMAL
- en: We will stop here and direct you to the other GitHub branches pertaining to
    migration. All branches starting with `ng6-checkpoint*` are the migration branches.
    Try to migrate the pending views and compare them with the GitHub branch changes.
    Remember, a working version of the app has already been developed in Angular,
    and hence there is a good reference point. Look at the `README.md` file for each
    branch to know what part of the application was migrated to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, let's summarize our learnings from the migration that we did.
  prefs: []
  type: TYPE_NORMAL
- en: Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We hope this migration exercise has provided enough insight into the process.
    You can now gauge the complexity, the time, and the effort required to migrate
    elements from AngularJS to Angular. Let''s highlight what we have learned as part
    of this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Migration is time-consuming**: Migration is by no stretch of the imagination
    a trivial exercise. Each page/view presents its own challenges that we need to
    overcome. Some elements are easy to migrate and some are not. The best thing you
    can do today if you are developing in AngularJS would be to follow the advice
    from the *Developing AngularJS apps today for easy migration* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migrate third-party libraries first**: Migrating third-party libraries can
    be quite challenging. The reasons are manifold:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such libraries are used across pages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They may not be upgradable to Angular (using `UpgradeAdapter`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating each view that uses such a library may not be feasible when the library
    is extensively used
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It's better to identify all third-party dependencies in your app and find a
    suitable alternative for them in the Angular world. If possible, develop some
    **proof of concept** (**POC**) with the new library to understand how different
    the new library is from the existing implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Libraries with overlap may exist**: While migrating, there could be scenarios
    where both AngularJS and Angular versions of a library coexist. Minimize this
    time period and migrate to the newer version as soon as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is easier to integrate Angular components into AngularJS than the other
    way round**: While migrating, migrate the complete view to Angular. Due to the
    restriction imposed by Angular, it becomes very difficult to have a parent Angular
    component with embedded AngularJS element directives. With such limitations, a
    bottom-up approach to migrating works better than a top-down approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anything non-UI-related is easy to migrate**: For *Personal Trainer*, we
    migrate the services last as they can be easily migrated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature parity better AngularJS and Angular**: Angular may not have every
    feature that AngularJS supports. In such a case, we need workarounds to achieve
    the desired behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That completes our migration story. With this, it's time to conclude the chapter
    and summarize our lessons from it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained some useful insight into a number of practical issues
    surrounding Angular development. These tips/guidelines can be extremely handy
    when building real-life applications using the framework.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the concept of *seed projects* and how these
    projects can get us up and running in no time. We looked at some popular seed
    projects that can serve as a base for any new Angular app development.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of being a server-side concern, authentication and authorization do
    affect the client implementation. The section on authentication/authorization
    covered how to handle authentication in both cookie- and token-based setups.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the ever-so-important topic of performance, where you learned ways
    to optimize an Angular app's performance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we migrated the v1 *Personal Trainer* to Angular. The gradual migration
    process taught us the intricacies of migration, the challenges faced, and the
    workaround done.
  prefs: []
  type: TYPE_NORMAL
- en: The book is coming to a close, but for everyone reading it, the journey has
    just begun. It's time to put theories into practice, hone our newly acquired skills,
    build something useful with Angular, and share it with the world. The more you
    invest in Angular, the more rewarding the framework is. Let's get started!
  prefs: []
  type: TYPE_NORMAL
