<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-14"><em class="italic"><a id="_idTextAnchor013"/>Chapter 1</em>: An Overview of Gatsby.js for the Uninitiated</h1>
			<p>In this book, we will take your existing React knowledge and supplement it with Gatsby.js (which we will refer to as Gatsby from now on) to create performant and accessible static sites. I hope to give you the tools you need to create better websites using Gatsby and get you to join the static site revolution. So, <em class="italic">happy hacking!</em></p>
			<p>This chapter starts with a brief historical look at the static web and why Gatsby was created. Then, we'll think about what Gatsby is and how it builds on React. Next, we'll go through some of the use cases of Gatsby and identify Gatsby's competitors. Finally, we'll set up a basic Gatsby project, having created our first few pages. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>A brief history of the static web</li>
				<li>What is Gatsby?</li>
				<li>Gatsby use cases</li>
				<li>Gatsby's competitors</li>
				<li>Setting up a project</li>
			</ul>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Technical requirements</h1>
			<p>The code present in this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter01">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter01</a>.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>A brief history of the static web</h1>
			<p>Static sites have been around nearly as long as the internet<a id="_idIndexMarker000"/> itself. They are the original<a id="_idIndexMarker001"/> blueprint for any website – <strong class="bold">HyperText Markup Language </strong>(<strong class="bold">HTML</strong>), <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), and <strong class="bold">JavaScript</strong> (<strong class="bold">JS</strong>). In the 1990s, HTML was the only publishing mechanism<a id="_idIndexMarker002"/> for the web. To get content on the internet, you would have to create a static HTML<a id="_idIndexMarker003"/> file and expose it to the internet via a server. If you wanted to modify one of your web pages, you would need to change its corresponding HTML file directly. </p>
			<p>While learning HTML is part of primary education these days, back in the 1990s, it was a novel skill to understand and write the language. Creating or editing content was costly, as you would require someone with this skill<a id="_idIndexMarker004"/> set for every modification. Luckily, <strong class="bold">Content Management Systems</strong> (<strong class="bold">CMSes</strong>) (WordPress, Drupal, and so on) soon swooped in to allow non-technical users to control a webpage's design and content. It also gave users the ability to store and manage files via a user interface. CMSs continue to be utilized today with increasing popularity. The number of websites using a CMS has risen from 23.6% to 63% in the last decade. Over 75 million sites use WordPress today – that's 30% of the web! </p>
			<p>At an almost identical pace, frontend frameworks and libraries have gained notoriety. Building single-page applications became commonplace. Today, the most dominant UI library in the JS world is Facebook's React.js, which is a small<a id="_idIndexMarker005"/> library with a handful of functions but some big ideas – a virtual DOM, <strong class="bold">JavaScript Syntax Extension</strong> (<strong class="bold">JSX</strong>), and componentization. There is no denying how much impact React has had on web development. In 2020, 80% of JS developers had used it, and 70% of JS developers said they would use it again.</p>
			<p>Frontend frameworks have entirely changed how developers approach web development, giving them the flexibility to focus on functionality over content and drastically speeding up their workflows. But you're only as fast as your slowest team member. The clunky nature of CMS platforms was revealed when developers started to employ these frameworks and integrate them with CMSs. Traditional CMS workflows made use of databases and environments that frontend frameworks had removed from the equation. Combining this with CMS security and bottleneck issues led to the rebirth of static sites. </p>
			<p>Kyle Mathews, the founder of Gatsby, was a catalyst for this trend. He noticed that the expectations on website accessibility and performance increased dramatically. He observed apps investing millions of dollars in user experience. There is no denying that the disparity between a 2005 and 2015 website was significant. In a competitive environment such as the web, you have to have a product that can stand out. Mathews took a step back, identified gaps<a id="_idIndexMarker006"/> in existing tooling, and asked what the ideal product might be. This research is what led him to create Gatsby.</p>
			<p>It's almost poetic that we have gone full circle and returned to static content because there is no beating it when it comes to speed and performance. </p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>What is Gatsby?</h1>
			<p>Gatsby is a free, open source static<a id="_idIndexMarker007"/> site generator that harnesses React. Static site generators are software applications that create static pages from a template or component and supplement them with content from a source. Static site generators are an alternative to a more traditional database-driven CMS, such as WordPress. In these conventional systems, content is managed and stored in a database. When the server receives a particular URL request, the server retrieves data from the database, mixes it with a template file, and generates an HTML page as its response. Generating HTML on demand can be a time-consuming process and can leave the user twiddling their thumbs or, worse, leaving your site. Bounce rates (the percentage of visitors to a particular website who navigate away from the site after viewing only one page) hover below 10% for websites that take less than 3 seconds to load, but the number jumps to 24% for a 4-second load time and 38% for a 5-second load time.</p>
			<p>Static site generators like Gatsby, on the other hand, generate pages during a build process. During this process, Gatsby brings in data to its GraphQL layer, where it can be queried in pages and templates. The requested data is then stored in JSON and accessed by the built pages, which are composed of HTML, JS, and CSS files. A user can deploy these generated pages to a server. When it receives a request, the server responds with predetermined, static, rendered HTML. As these static pages are generated at build time, they eliminate the latency that databases would introduce. You can even do away with web servers altogether and have your site served via a CDN pointing<a id="_idIndexMarker008"/> to a storage medium, such as an AWS <strong class="bold">Simple Storage Service</strong> (<strong class="bold">S3</strong>) bucket. The difference is striking; web experiences built with Gatsby are lightning fast, as nothing can be faster than sending static content. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">A static site<a id="_idIndexMarker009"/> can contain dynamic and exciting experiences! It is a common misconception that "static" means the site is stationary. This could not be further from the truth. The word "static" only refers to the manner in which files are retrieved by a client.   </p>
			<p>While Gatsby<a id="_idIndexMarker010"/> is known for static site generation, recent versions also include server-side<a id="_idIndexMarker011"/> and deferred static generation, rendering functionality for when static generation is not enough.</p>
			<p>Aside from creating a blazing-fast user experience, Gatsby also has a focus on developer experience. As we learn and build, I'm sure you will start to recognize how easy it is to use. The way it achieves this can be broken down into four steps.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Community</h2>
			<p>Gatsby has an incredibly supportive community<a id="_idIndexMarker012"/> backing. At the time of writing, over 3,600 people have contributed to the Gatsby repository. This is further amplified by the plugin ecosystem surrounding Gatsby; the community has created more than 2,000+ plugins that abstract complex functionality that other developers may wish to use in their own projects. These plugins are distributed as packages<a id="_idIndexMarker013"/> stored on a JS repository, such as <strong class="bold">NPM</strong>, that can be added to your project in a few lines. They can extend your site by sourcing content, transforming data, creating pages, or theming your application.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Sourcing content from anywhere</h2>
			<p>Every day, the amount of data<a id="_idIndexMarker014"/> we need to combine to create experiences is rising. In traditional React applications, managing multiple sources of data could become a nightmare. Storing, massaging, merging, and querying data all require complex solutions that struggle to scale.  </p>
			<p>Gatsby does this differently. Whether you are sourcing data<a id="_idIndexMarker015"/> from a CMS, real-time database, or even a custom <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>), you can merge all of this data into a unified data layer. The Gatsby community is constantly contributing source plugins to allow you to ingest data from your favorite sources with ease. Nine times out of ten, you won't need to write a single line of code to source your data, but for the times when you do, we will be covering plugin creation in <a href="B15983_10_ePub_RK.xhtml#_idTextAnchor141"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating Gatsby Plugins</em>.</p>
			<p>Once ingested into this data layer, we can explore and query all our sources of data in one place using a uniform data layer. Using the power of GraphQL, we can query our data in the same way when rendering pages regardless of their source. The GraphQL layer is transitory<a id="_idIndexMarker016"/> and doesn't exist after the application has been built, so doesn't affect the size of your production site. If GraphQL is something new to you, don't worry – I will be explaining how it works in <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data (from Anywhere!)</em>.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Building tooling you already know</h2>
			<p>Often when we approach new technologies, we are faced with a steep learning curve as we understand new syntax and ways of thinking. In Gatsby, we build on your existing knowledge of React<a id="_idIndexMarker017"/> instead of starting from scratch. Underpinning all of our code is the same React component model many of you already know. You should feel pretty confident from the beginning, as the code should look familiar, and if you're not, Gatsby can also help you learn React from a more "content-driven" approach.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Supercharging web performance</h2>
			<p>As web developers, we can spend considerable time tinkering with websites to squeeze every ounce out of their performance. Sometimes, this can take as long, if not longer, than building the design. Also, performance<a id="_idIndexMarker018"/> gains can sometimes be undone instantly by a change to the site design outside of your control. It's because of this that some large organizations have dedicated teams to improve site performance. But it doesn't have to be this way! As we start to build together, you will see that load times go from seconds to milliseconds, and your site will feel far more responsive than a conventional React app. Gatsby has plenty of tricks up its sleeve that improve performance, some of which we will touch on at the end<a id="_idIndexMarker019"/> of this chapter. It also turns your site into a <strong class="bold">Progressive Web App</strong> (<strong class="bold">PWA</strong>) with just a few lines of code – if that's not cool, I don't know what is!</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">An essential<a id="_idIndexMarker020"/> distinction between Gatsby and React is that Gatsby is a "framework," not a "library." When using a library, you control your application flow; you call<a id="_idIndexMarker021"/> it when you need it. When using a framework, however, there is an inversion of control. Frameworks command that you adhere to a particular flow<a id="_idIndexMarker022"/> and layout defined by them. Working within a framework can often be seen as a benefit, as any developer familiar with the framework will know where to find relevant files and code.</p>
			<p>I hope you are beginning to see some of the great reasons why Gatsby is such a powerful tool. Let's now see it in action.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Gatsby use cases</h1>
			<p>You might be starting to realize that Gatsby could have applications across many different kinds of websites. Since Gatsby's v1 launch in 2017, the framework has been used in a multitude of different ways by companies both big and small. Here, I want to highlight some examples of use cases<a id="_idIndexMarker023"/> where Gatsby excels and suggest why companies may have chosen Gatsby for these sites.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While reading about these example sites here is great, I highly encourage you to visit them via your own device. One of Gatsby's best features is the speed of the sites it creates, and it is essential to experience this for yourself to understand the benefit.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Documentation sites</h2>
			<p>Documentation sites<a id="_idIndexMarker024"/> are a perfect use case for Gatsby as their content<a id="_idIndexMarker025"/> is primarily, if not entirely, static. Their content does not shift often either, with pages needing infrequent updates. Their static nature means that we can generate all page routes during the build process and load them onto a CDN, meaning that when a page is requested, the request is near-instant. It is for this reason that you see sites such as the<a id="_idIndexMarker026"/> official React documentation (<a href="https://reactjs.org">https://reactjs.org</a>) being made with Gatsby:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B15983_01_01.jpg" alt="Figure 1.1 – The React documentation website &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The React documentation website </p>
			<p>Due to the infrequent nature of updates to documentation pages, you can automate the build and deployment<a id="_idIndexMarker027"/> of your site as and when changes to documentation<a id="_idIndexMarker028"/> are made. With GitHub integrations or webhooks, you can get your documentation site to redeploy each change to a master branch or on a daily basis, for example. We will be exploring how to create these kinds of processes in <a href="B15983_09_ePub_RK.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Hosting</em>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Online courses</h2>
			<p>Online courses often<a id="_idIndexMarker029"/> have a unique structure – the majority of their content<a id="_idIndexMarker030"/> is in static learning modules, but they also require a small quantity of authenticated routes for logged-in user experiences. </p>
			<p>Websites such as <em class="italic">DesignCode.io</em> (<a href="https://designcode.io/courses">https://designcode.io/courses</a>) utilize Gatsby for their static content, meaning<a id="_idIndexMarker031"/> their static pages are incredibly performant, and they then render authenticated routes on the client. While this does increase bundle size, as they need to ship more JS, the benefit of the fast static pages far outweighs the cost of heavier authenticated pages:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B15983_01_02.jpg" alt="Figure 1.2 – The DesignCode.io website &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – The DesignCode.io website </p>
			<p>One of the most popular sources of data for Gatsby is MDX. MDX is a powerful format that allows you to write JSX within Markdown. Why is it awesome? Because you can include React components alongside documentation with no hassle at all. React components can be far more interactive and dynamic than text, and as a result, it is a powerful format to create online<a id="_idIndexMarker032"/> courses on, as you can create content that is more enticing<a id="_idIndexMarker033"/> for the user. Perhaps a more interactive course is a more memorable one? We will be diving into MDX in detail in <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data (from Anywhere!)</em>.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>SaaS products</h2>
			<p>When selling <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) online, your website's performance can be considered a reflection<a id="_idIndexMarker034"/> of your product's performance. As a result, having<a id="_idIndexMarker035"/> a clunky website can be the difference between your product being a success or not. As mentioned previously, this is an example where you could go down a rabbit hole to improve your site's performance. Companies<a id="_idIndexMarker036"/> such as <em class="italic">Skupos </em>(<a href="https://www.skupos.com/">https://www.skupos.com/</a>) use Gatsby to get more performance benefits for free. Gatsby also works wonders for <strong class="bold">Search Engine Optimization</strong> (<strong class="bold">SEO</strong>). As pages are<a id="_idIndexMarker037"/> prerendered, all your page content is available to web crawlers such as Googlebot <a id="_idIndexMarker038"/>to navigate to your site. The speed and SEO improvements help their product's website stand out and give the user confidence that they know what they are doing when it comes to technology:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B15983_01_03.jpg" alt="Figure 1.3 – The Skupos website&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – The Skupos website</p>
			<p><em class="italic">Skupos</em> also supplement<a id="_idIndexMarker039"/> their site pages with metadata and alt-text, which further aids web crawlers in understanding<a id="_idIndexMarker040"/> site content. The more web crawlers understand your site's content, the better your search engine ranking will be. </p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Design agencies and photo-heavy sites</h2>
			<p>In cases where your work is more visual, your site often needs to make use of large quantities of high-resolution<a id="_idIndexMarker041"/> images. We've all visited a website and felt like we were transported back to the dial-up days as we've waited for large image files to load. This common<a id="_idIndexMarker042"/> mistake is often amplified further by a large amount of cumulative layout shift that happens when loading images. Gracefully handling the image's loading state to avoid this can be a headache. </p>
			<p>Gatsby performs magic for images within its application. It utilizes the <strong class="source-inline">sharp</strong> library (<a href="https://github.com/lovell/sharp">https://github.com/lovell/sharp</a>) under the hood to convert your large images into smaller web-friendly sizes. When your website loads, it will first load in a smaller resolution version before blurring up to the maximum resolution required. This results in no layout shift and a far less "jumpy" experience for your site visitor. A great example of this is on the <em class="italic">Call Bruno Creative Agency</em> (<a href="https://www.callbruno.com/en/reelevant">https://www.callbruno.com/en/reelevant</a>) website developed with Gatsby:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B15983_01_04.jpg" alt="Figure 1.4 – The Call Bruno Creative Agency website&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – The Call Bruno Creative Agency website</p>
			<p>They use lots of imagery<a id="_idIndexMarker043"/> across their project pages, but the image load<a id="_idIndexMarker044"/> does not take you out of the experience. We will get into detail on handling images in <a href="B15983_05_ePub_RK.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>,<em class="italic"> Working with Images</em>.</p>
			<p>By exploring these sites, we can see examples across industries where Gatsby is helping companies get ahead of their competition. </p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Gatsby's competitors</h1>
			<p>While this book focuses<a id="_idIndexMarker045"/> on Gatsby, it is crucial to understand that it is not the only React static site generator on the market. The competitor most often uttered in the same breath is Next.js.</p>
			<p>Until recently, the key difference between Next.js and Gatsby was server-side rendering. Like Gatsby, a Next.js application can be hosted statically, but it also used to be able to server render pages where Gatsby could not. Instead of deploying a static build, a server is deployed to handle requests. When a page is requested, the server builds that page and caches it before sending it to the user. This means that subsequent requests to the resource are faster than the first call. As of version 4, Gatsby can have all of its pages prebuilt statically or it can create a hybrid build – a mixture of static and server-side rendered content. We will discuss this more in <a href="B15983_09_ePub_RK.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Hosting</em>.</p>
			<p>One major drawback to Next.js is its data security. When building Gatsby sites as static builds, data is only taken from the source at build time, and as the content is static, it is secure. Next.js keeps data stored on the server and, as such, it is easier to exploit. Next.js commonly requires more initialization if you wish to set it up via a server or using databases. This also means that there is more maintenance required in Next.js applications. Both Next.js and Gatsby have additional utilities to help with the handling of images. Gatsby, however, can make images more performant on statically rendered pages, while Next cannot.</p>
			<p>The good news is that all static site generators follow a similar process. <em class="italic">The skills and mentality you learn in this book are easily transferable to a different generator in the future should you decide you want to make the switch.</em></p>
			<p>Now that we understand where Gatsby excels, let's start creating our first Gatsby project.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Setting up a project</h1>
			<p>In order to help you put<a id="_idIndexMarker046"/> into practice what you're learning, we will be building a project together. Throughout this book, we will be working to build a personal portfolio, something that every developer needs and therefore something I think will be relevant for most readers. The portfolio will contain blog pages to aid your learning in public, project pages to demonstrate your work, a stats page showcasing interesting metrics on your site, as well as many more features that will help your portfolio stand out from the crowd.</p>
			<p>Throughout this book, you will be faced with options. We will discuss different implementations for styling your site, as well as data sources you may want to implement. This should give you the flexibility to align it with your current knowledge. Alternatively, you can<a id="_idIndexMarker047"/> throw yourself in the deep end – the choice is up to you. Everywhere there is a choice, I will also provide my personal recommendation for what might be best if you can't decide.</p>
			<p>To see a finished version of the portfolio we will be building, visit this link:</p>
			<p><a href="https://elevating-react-with-gatsby.sld.codes/">https://elevating-react-with-gatsby.sld.codes/</a></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Refer to the code repository (<a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4</a>) that accompanies this book if you're struggling at any point. It includes a copy of the project as it should appear after every chapter. </p>
			<p>To start using Gatsby, we need to ensure we have a few prerequisite tools set up on our machines. Most of these prerequisites are most likely already on your device if you are a React developer, although I would still encourage you to read through this list, as some of your tools may need an update.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Node.js version 14.15.0+ </h2>
			<p>As of version 4.0, Gatsby supports all Node.js versions greater than 14.15.0. You can quickly check if you have Node.js installed<a id="_idIndexMarker048"/> by opening up a terminal window and typing the following: </p>
			<p class="source-code"> node -v</p>
			<p>If you have Node.js installed, this should print a version number. However, if you receive an error, you can download Node.js<a id="_idIndexMarker049"/> by navigating to the Node.js website (<a href="https://nodejs.org">https://nodejs.org</a>). Node.js comes bundled with <strong class="source-inline">npm</strong>, a package repository, package manager, and command-line tool that we will be using to install Gatsby. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You're most likely already using Node.js, and some of your pre-existing projects may require a different version than the requirements specified here. If you need to manage multiple versions of Node.js on the same<a id="_idIndexMarker050"/> device, you should check out the <strong class="bold">Node.js Version Manager</strong> (<strong class="bold">NVM</strong>)(<a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a>). It gives you access to valuable commands, including installing new versions and switching between minor and major versions of Node.js.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Gatsby command-line interface</h2>
			<p>The Gatsby <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>) is a tool built by the core Gatsby team; it allows you to perform standard<a id="_idIndexMarker051"/> functions, such as creating new Gatsby<a id="_idIndexMarker052"/> projects, setting up local development servers, and building your production site. Although you can use it on a per-project basis, it is far more common to install the CLI globally so that you can use its features across multiple Gatsby projects without having to install it as a package in each project – got to save that hard-drive space!</p>
			<p>To install the CLI globally, <strong class="source-inline">npm install</strong> it with the global flag:</p>
			<p class="source-code">npm i -g gatsby-cli</p>
			<p>To verify its installation, open up a terminal window and type the following:</p>
			<p class="source-code">gatsby --help</p>
			<p>If running this provides a list of commands and does not error out, then you're good to go.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Throughout this book, I use <strong class="source-inline">npm</strong> as my package manager. If you prefer Yarn, you can use the Yarn equivalent commands.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Directory and package setup</h2>
			<p>Here, we will begin to create<a id="_idIndexMarker053"/> the files and folders we need to start our project, as well<a id="_idIndexMarker054"/> as install necessary dependencies such as React and Gatsby. </p>
			<p>First, create a folder to house our project. You can call it whatever you like. Throughout this book, I will refer to this folder as the <strong class="source-inline">root</strong> folder of the application. Open a terminal and navigate to your <strong class="source-inline">root</strong> folder. Initialize a new package in this folder by running the following: </p>
			<p class="source-code">npm init -y</p>
			<p>With the package now initialized, let's install React and Gatsby:</p>
			<p class="source-code">npm i gatsby react react-dom</p>
			<p>Open your <strong class="source-inline">root</strong> folder in your favorite <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>). You should notice that it now<a id="_idIndexMarker055"/> contains three new items, <strong class="source-inline">package.json</strong>, <strong class="source-inline">package-lock.json</strong>, and a <strong class="source-inline">node-modules</strong> folder. Opening<a id="_idIndexMarker056"/> your <strong class="source-inline">package.json</strong>, you should<a id="_idIndexMarker057"/> see the following:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "gatsby-site",</p>
			<p class="source-code">  "version": "1.0.0",</p>
			<p class="source-code">  "description": "",</p>
			<p class="source-code">  "main": "index.js",</p>
			<p class="source-code">  "scripts": {</p>
			<p class="source-code">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "keywords": [],</p>
			<p class="source-code">  "author": "",</p>
			<p class="source-code">  "license": "ISC",</p>
			<p class="source-code">  "dependencies": {</p>
			<p class="source-code">    <strong class="bold">"gatsby": "^4.4.0",</strong></p>
			<p class="source-code"><strong class="bold">    "react": "^17.0.2",</strong></p>
			<p class="source-code"><strong class="bold">    "react-dom": "^17.0.2"</strong></p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding example, you can see that this file now contains references to the dependencies we have just installed. </p>
			<h3>Development scripts</h3>
			<p>Let's start by modifying <strong class="source-inline">package.json</strong> so that it contains<a id="_idIndexMarker058"/> some useful scripts that will speed up our development process:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "gatsby-site",</p>
			<p class="source-code">  "version": "1.0.0",</p>
			<p class="source-code">  "description": "",</p>
			<p class="source-code">  "main": "index.js",</p>
			<p class="source-code"><strong class="bold">  "scripts": {</strong></p>
			<p class="source-code"><strong class="bold">    "build": "gatsby build",</strong></p>
			<p class="source-code"><strong class="bold">    "develop": "gatsby develop",</strong></p>
			<p class="source-code"><strong class="bold">    "start": "npm run develop",</strong></p>
			<p class="source-code"><strong class="bold">    "serve": "gatsby serve",</strong></p>
			<p class="source-code"><strong class="bold">    "clean": "gatsby clean"</strong></p>
			<p class="source-code"><strong class="bold">  },</strong></p>
			<p class="source-code">  "keywords": [],</p>
			<p class="source-code">  "author": "",</p>
			<p class="source-code">  "license": "ISC",</p>
			<p class="source-code">  "dependencies": {</p>
			<p class="source-code">    "gatsby": "^4.4.0",</p>
			<p class="source-code">    "react": "^17.0.2",</p>
			<p class="source-code">    "react-dom": "^17.0.2"</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Let's break down these scripts:</p>
			<ul>
				<li><strong class="source-inline">build</strong>: Runs the Gatsby CLI's <strong class="source-inline">build</strong> command. This creates a compiled, production-ready build of our site. We will learn more about this in <a href="B15983_09_ePub_RK.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Hosting</em>.</li>
				<li><strong class="source-inline">develop</strong>: Runs the Gatsby CLI's <strong class="source-inline">develop</strong> command. We will review it in detail in the next section, <em class="italic">Creating your first few pages</em>.</li>
				<li><strong class="source-inline">start</strong>: The <strong class="source-inline">start</strong> script redirects to the <strong class="source-inline">develop</strong> script. This is in place as it is common to start packages with a <strong class="source-inline">start</strong> script. </li>
				<li><strong class="source-inline">serve</strong>: Runs the Gatsby CLI's <strong class="source-inline">serve</strong> command to serve up a Gatsby <strong class="source-inline">build</strong> folder. This is a useful way to review a production build.</li>
				<li><strong class="source-inline">clean</strong>: The <strong class="source-inline">clean</strong> script utilizes the Gatsby CLI's <strong class="source-inline">clean</strong> command. This deletes the local Gatsby cache and any build data. It will be rebuilt with the next <strong class="source-inline">develop</strong> or <strong class="source-inline">build</strong> command.</li>
			</ul>
			<p>All of these scripts<a id="_idIndexMarker059"/> can be run from the <strong class="source-inline">root</strong> folder with the following command:</p>
			<p class="source-code">npm run script-name</p>
			<p>Simply replace <strong class="source-inline">script-name</strong> with the name of the script you would like to run.</p>
			<p>You'll notice the absence of a test script. Don't worry – we will get into how to test a Gatsby application in <a href="B15983_07_ePub_RK.xhtml#_idTextAnchor105"><em class="italic">Chapter 7</em></a>, <em class="italic">Testing and Auditing Your Site</em>. </p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Framework files and folders</h2>
			<p>As mentioned, Gatsby is a framework. Frameworks<a id="_idIndexMarker060"/> require certain files to exist in order<a id="_idIndexMarker061"/> to work. Let's set up our project with the files and folders<a id="_idIndexMarker062"/> where Gatsby expects to find them. </p>
			<p>Create a <strong class="source-inline">gatsby-config.js</strong> file in your <strong class="source-inline">root</strong> directory and add the following:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  plugins: [],</p>
			<p class="source-code">};</p>
			<p>As the name might suggest, the <strong class="source-inline">gatsby-config.js</strong> file is the core configuration file for Gatsby. We will be coming back to this file frequently as we build out our project. By the time we are done with it, it will be full of plugins, metadata, styl<a id="_idTextAnchor032"/><a id="_idTextAnchor033"/>ing, and even offline support.</p>
			<p>Create <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatsby-node.js</strong> files in your <strong class="source-inline">root</strong> directory. Both of these files can be left blank for now. The <strong class="source-inline">gatsby-browser.js</strong> file contains any code we would like to run on the client's browser. In the next chapter, we will be using this file to add styles to our website. The <strong class="source-inline">gatsby-node.js</strong> file contains code we would like to run during the process of building our site.</p>
			<p>Finally, create an <strong class="source-inline">src</strong> folder in your <strong class="source-inline">root</strong> directory. This folder will contain the majority of our development work, much like in a traditional React application. Pages we create and components we define will all be contained within this folder. </p>
			<p>Before we go any further, let's make sure we have our version control tracking the right files.</p>
			<h3>Using version control</h3>
			<p>I suspect many of you would<a id="_idIndexMarker063"/> like to use version control while you build out your Gatsby site. To ensure Git tracks only the files that matter, create a <strong class="source-inline">.gitignore</strong> file and add the following:</p>
			<p class="source-code">node_modules/</p>
			<p class="source-code">.cache/</p>
			<p class="source-code">public</p>
			<p>These lines stop<a id="_idIndexMarker064"/> our dependencies, Gatsby builds, and cache folders from being tracked. </p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>Creating your first few pages</h2>
			<p>We now have all the underlying code we need set up to allow us to start<a id="_idIndexMarker065"/> creating pages. In this section, we will create a three-page website using Gatsby. It's important<a id="_idIndexMarker066"/> to note that this is a basic example purely designed to solidify your understanding of how Gatsby works before we worry about styling and additional functionality. </p>
			<p>Navigate to your <strong class="source-inline">src</strong> directory and create a new folder called <strong class="source-inline">pages</strong>. Any JS files we create within the <strong class="source-inline">pages</strong> folder will be treated as a route by Gatsby. This also applies to subfolders within the <strong class="source-inline">pages</strong> folder. There is, however, one exception – files called <strong class="source-inline">index.js</strong> are treated as the root of their directory. Let's make sense of this with a few examples:</p>
			<ul>
				<li><strong class="source-inline">src/pages/index.js</strong> will map to <a href="https://yourwebsite.com">yourwebsite.com</a>.</li>
				<li><strong class="source-inline">src/pages/about.js</strong> will map to <a href="https://yourwebsite.com/about">yourwebsite.com/about</a>.</li>
				<li><strong class="source-inline">src/pages/blog/my-first-post.js</strong> will map to <a href="https://yourwebsite.com/docs/my-first-post">yourwebsite.com/docs/my-first-post</a>. While we won't be setting up a page at this URL now, we will start using routes such as this one in <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data (from Anywhere!)</em>. </li>
				<li><strong class="source-inline">src/pages/404.js</strong> will map to any page that does not resolve on <a href="https://yourwebsite.com"><span class="hidden">yourwebsite.com</span></a>.<p class="callout-heading">Important Note</p><p class="callout">Any React components you place in the <strong class="source-inline">pages</strong> folder will become navigable routes on your site. As such, it is best to separate your components from your pages. A common pattern is to create a <strong class="source-inline">components</strong> folder that sits next to your <strong class="source-inline">pages</strong> folder in the <strong class="source-inline">src</strong> directory and import components you want to use in your pages.</p></li>
			</ul>
			<h3>The index page</h3>
			<p>Create an <strong class="source-inline">index.js</strong> file in your <strong class="source-inline">pages</strong> folder. As the index<a id="_idIndexMarker067"/> of the <strong class="source-inline">pages</strong> folder, this will become the landing<a id="_idIndexMarker068"/> of your website. We can now populate this file with the following code:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code">const Index = () =&gt; {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;h1&gt;My Landing Page&lt;/h1&gt;</p>
			<p class="source-code">            &lt;p&gt;This is my landing page.&lt;/p&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Index</p>
			<p>The contents of this file should look familiar; it's just a simple stateless ReactJS component. </p>
			<p>We could have also defined it as:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code">export default function Index(){</p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;h1&gt;My Landing Page&lt;/h1&gt;</p>
			<p class="source-code">            &lt;p&gt;This is my landing page.&lt;/p&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>Both examples<a id="_idIndexMarker069"/> will output the exact<a id="_idIndexMarker070"/> same result, so it's just personal preference.</p>
			<h3>The about page</h3>
			<p>In a similar fashion, we can<a id="_idIndexMarker071"/> create an <strong class="source-inline">about</strong> page. Here, you have a choice – you can either create this page at <strong class="source-inline">src/pages/about.js</strong> or at <strong class="source-inline">src/pages/about/index.js</strong>. The question I always ask myself when deciding which option to go with is whether the page will have sub-pages. In the case of an <strong class="source-inline">about</strong> page, I think it's unlikely<a id="_idIndexMarker072"/> to contain any sub-pages, so I will opt for <strong class="source-inline">src/pages/about.js</strong>:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code">export default function About(){</p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;h1&gt;My About Page&lt;/h1&gt;</p>
			<p class="source-code">            &lt;p&gt;This is a sentence about me.&lt;/p&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>Here, we have defined another simple React component containing a heading and paragraph to create our <strong class="source-inline">about</strong> page.</p>
			<h3>The 404 page</h3>
			<p>Gatsby expects to find a <strong class="source-inline">404.js</strong> file in your <strong class="source-inline">pages</strong> directory. This page is special. It contains the page<a id="_idIndexMarker073"/> that will be shown<a id="_idIndexMarker074"/> when Gatsby cannot find a page that was requested. I am sure you have come across "Page not found" pages before. Without this page, on requesting a non-existent route, the browser will not find any resource and show a browser error to the user. While the <strong class="source-inline">404</strong> page is another form of displaying the same error, by creating this page, we can manage the error ourselves. We can link to working<a id="_idIndexMarker075"/> pages on our site or even suggest the page they might have been trying to visit (more on this in <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data (from Anywhere!)</em>).</p>
			<p>Let's create our <strong class="source-inline">404</strong> page<a id="_idIndexMarker076"/> now in <strong class="source-inline">src/pages/404.js</strong>:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code">export default function NotFound(){</p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;h1&gt;Oh no!&lt;/h1&gt;</p>
			<p class="source-code">            &lt;p&gt;The page you were looking for does not</p>
			<p class="source-code">               exist.&lt;/p&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>You should be starting to see a pattern. Creating pages is as simple as defining React components – something you should be familiar with already.</p>
			<h4>Trying the develop command</h4>
			<p>At this point, you've actually<a id="_idIndexMarker077"/> already created a fully working website. Congratulations! To test it out, open a terminal at your <strong class="source-inline">root</strong> directory and run the following:</p>
			<p class="source-code">npm run start</p>
			<p>As you will recall from our <strong class="source-inline">package.json</strong>, this will run the <strong class="source-inline">gatsby develop</strong> command. This will take a few seconds to run, but you should then see some terminal output that looks like this:</p>
			<p class="source-code">You can now view gatsby-site in the browser.</p>
			<p class="source-code">  http://localhost:8000/</p>
			<p>You can now open a browser of your choice and navigate to <strong class="source-inline">http://localhost:8000/</strong>, and you should be greeted with something like this:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B15983_01_05.jpg" alt="Figure 1.5 – The landing page preview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – The landing page preview</p>
			<p>This is the rendered version of our <strong class="source-inline">index.js</strong> page component. You can modify the URL in your browser to <strong class="source-inline">http://localhost:8000/about</strong> to see your <strong class="source-inline">about</strong> page and <strong class="source-inline">http://localhost:8000/404</strong> to see your <strong class="source-inline">404</strong> page. You can also see your <strong class="source-inline">404</strong> page in development by navigating<a id="_idIndexMarker078"/> to any invalid route and pressing the <strong class="bold">Preview custom 404 page</strong> button.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you don't want to manually navigate to the browser and type in the URL, you can modify our scripts by appending the <strong class="source-inline">gatsby develop</strong> command with the <strong class="source-inline">-o</strong> option. This instructs Gatsby to open your default browser and navigate to the site automatically when you run the <strong class="source-inline">develop</strong> command. </p>
			<h4>gatsby develop in detail</h4>
			<p>Running <strong class="source-inline">gatsby develop</strong> starts the Gatsby development server. This might be a little confusing, as we have previously mentioned how a Gatsby site is delivered as static content, but it's actually<a id="_idIndexMarker079"/> there to speed up your development process. </p>
			<p>Imagine your site contains 10,000 pages; building the entirety of your site every time you make a small change to one page would take a long time. To get around this in development, Gatsby uses a Node.js server to build only what you need as and when it's requested. Due to it building on demand, it can negatively affect the performance of a page and <em class="italic">you should never test performance on a page in development for this reason</em>.</p>
			<p>Once the server is up, you can continue to edit your code without rerunning the command. The development server supports hot reloading, a concept that should be familiar to you. </p>
			<p>The <strong class="source-inline">develop</strong> command has a number of built-in options<a id="_idIndexMarker080"/> that allow you to customize it:</p>
			<ul>
				<li><strong class="source-inline">-H, --host</strong>: Allows you to modify the host</li>
				<li><strong class="source-inline">-p, --port</strong>: Allows you to modify the port Gatsby runs on</li>
				<li><strong class="source-inline">-o, --open</strong>: Opens your project in the browser</li>
				<li><strong class="source-inline">-S, --https</strong>: Turns on HTTPS</li>
			</ul>
			<p>You can view your site on any device connected to the same network by using the host option. This can be useful when you want to compare how your site behaves on mobile browsers with that of a desktop experience. To achieve this, run the following command:</p>
			<p class="source-code">gatsby develop -H 0.0.0.0</p>
			<p>If the command is successful, you will see a subtle difference in the output:</p>
			<p class="source-code">You can now view gatsby-site in the browser.</p>
			<p class="source-code">  Local:            http://localhost:8000/</p>
			<p class="source-code">  On Your Network:  http://192.168.1.14:8000/</p>
			<p>The <strong class="source-inline">develop</strong> command has added a URL for testing on your network. Typing this into a browser on any device connected to the same network will render your site.</p>
			<h3>Connecting your pages</h3>
			<p>Now that you have multiple pages, you may want to navigate between them. There are two different<a id="_idIndexMarker081"/> ways of achieving this – with the Gatsby Link component<a id="_idIndexMarker082"/> or via programmatic navigation. To some of you, these components and functions<a id="_idIndexMarker083"/> may sound familiar; this is because Gatsby wraps the <strong class="source-inline">reach-router</strong> (<a href="https://reach.tech/router">https://reach.tech/router</a>) library for navigation. For those who haven't used <strong class="source-inline">reach-router</strong> before, the library comes with support for server-side rendering and routing accessibility functionality built in. Gatsby has built on and enhanced this functionality to meet its high standards for user accessibility, ensuring a great website experience regardless of who you are. </p>
			<h4>The Gatsby Link component</h4>
			<p>It's important to use the Gatsby <strong class="source-inline">&lt;Link/&gt;</strong> component as a replacement for the <strong class="source-inline">&lt;a/&gt;</strong> tag whenever you are linking to a page that is internal. The <strong class="source-inline">&lt;Link/&gt;</strong> component works just like an <strong class="source-inline">&lt;a/&gt;</strong> tag, with one important<a id="_idIndexMarker084"/> distinction – it enables prefetching. Prefetching is the act of loading a resource before it is required. This means that when the resource is requested, the time waiting for that resource is decreased. By prefetching the links on your page, your next click navigates to content that is already loaded and is therefore practically instant. This is particularly noticeable on mobile devices in areas with reduced network conditions that would normally have a delay when loading pages.</p>
			<p>The first place you could add a <strong class="source-inline">Link</strong> component is to your <strong class="source-inline">404</strong> page. It's common for these pages to have a button that says something like "Take me home" that, when clicked, navigates to the landing page:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code"><strong class="bold">import {Link} from "gatsby"</strong></p>
			<p class="source-code">export default function NotFound(){</p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;h1&gt;Oh no!&lt;/h1&gt;</p>
			<p class="source-code">            &lt;p&gt;The page you were looking for does not</p>
			<p class="source-code">               exist.&lt;/p&gt;</p>
			<p class="source-code">            <strong class="bold">&lt;Link to="/"&gt;Take me home&lt;/Link&gt;</strong></p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>As you can see in the preceding code block, the <strong class="source-inline">Link</strong> component has a prop called <strong class="source-inline">to</strong>; this needs to be passed<a id="_idIndexMarker085"/> to the page that you want to navigate to relative to the root of your website. By passing the <strong class="source-inline">"/"</strong> prop, Gatsby will navigate to the root of your website.</p>
			<p>You can also add a link to the <strong class="source-inline">about</strong> page from the <strong class="source-inline">index</strong> page:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code"><strong class="bold">import {Link} from "gatsby"</strong></p>
			<p class="source-code">export default function Index() =&gt; {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;h1&gt;My Landing Page&lt;/h1&gt;</p>
			<p class="source-code">            &lt;p&gt;This is my landing page.&lt;/p&gt;</p>
			<p class="source-code">            <strong class="bold">&lt;Link to="/about"&gt;About Me&lt;/Link&gt;</strong></p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>You can see here that we instead pass <strong class="source-inline">"/about"</strong> to the <strong class="source-inline">to</strong> prop in the <strong class="source-inline">&lt;Link/&gt;</strong> component; this will navigate<a id="_idIndexMarker086"/> to our previously created <strong class="source-inline">about</strong> page. </p>
			<h4>Programmatic navigation</h4>
			<p>Occasionally, you may need to trigger navigation with something other than a click. Perhaps you need to navigate as a result of a <strong class="source-inline">fetch</strong> request, or when a user submits a form. You can achieve<a id="_idIndexMarker087"/> this behavior by making use of the Gatsby <strong class="source-inline">navigate</strong> function:</p>
			<p class="source-code">import React from "react"</p>
			<p class="source-code">import {navigate} from "gatsby"</p>
			<p class="source-code">export default function SomePage() =&gt; {</p>
			<p class="source-code"><strong class="bold">    const triggerNavigation = () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">        navigate('/about')</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    return (</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">            &lt;p&gt;Triggering page navigation via onClick.&lt;/p&gt;</p>
			<p class="source-code">            &lt;button <strong class="bold">onClick={()=&gt; triggerNavigation()}</strong>&gt;</p>
			<p class="source-code">                About Me</p>
			<p class="source-code">            &lt;/button&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">    )</p>
			<p class="source-code">}</p>
			<p>Like the <strong class="source-inline">&lt;Link/&gt;</strong> component, the <strong class="source-inline">navigate</strong> function<a id="_idIndexMarker088"/> will only work for navigating to internal pages. </p>
			<p>We now have a basic Gatsby site set up with the ability to navigate between pages.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Summary</h1>
			<p>I appreciate that most of the content in this chapter has been theoretical, but it's important to understand the "why" as well as the "how." In this chapter, we have cemented the baseline knowledge of what Gatsby is and grasped the guiding principles we will be using in further chapters to build our website. We've seen examples of where Gatsby is being used and the benefits it can bring. We discussed what dependencies you need and how to initialize Gatsby projects. We have also set up a complete basic Gatsby project and created the first few pages of our website. We then used the built-in Gatsby components and functions to link our pages together.</p>
			<p>We will be referencing the theory we've outlined in this chapter throughout this book, but for now, let's turn our focus to styling our web application. In the next chapter, we will identify various different styling methodologies and make an informed choice about which one you should use for your project. </p>
		</div>
	</body></html>