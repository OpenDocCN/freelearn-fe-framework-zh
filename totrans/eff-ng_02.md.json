["```js\n@Component({\n  standalone: true,\n  imports: [RouterModule], ………\n})\n```", "```js\nplatformBrowserDynamic().bootstrapModule(AppModule).catch()\n```", "```js\nbootstrapApplication(AppComponent, appConfig).catch(……);\n```", "```js\nconstructor(private userService: UserService) {}\n```", "```js\nprivate userService = inject(UserService);\n```", "```js\n@Component({ ……… , template: `\n    <div>Count: {{count()}}</div>\n    <div>Double: {{double()}}</div>`\n})\nexport class AppComponent {\n  count = signal(10);\n  double = computed(() => this.count() * 2);\n}\n```", "```js\n@if (a > b) {\n  {{a}} is greater than {{b}}\n} @else if (b > a) {\n  {{a}} is less than {{b}}\n} @else {\n  {{a}} is equal to {{b}}\n}\n```", "```js\n@for (item of items; track item.id) {\n  <li> {{ item.name }}</li>\n} @empty {\n  <li> There are no items.</li>\n}\n```", "```js\n@switch (condition) {\n  @case (caseA) { Case A. }\n  @case (caseB) { Case B. }\n  @default { Default case. }\n}\n```", "```js\n@defer (on viewport) {\n  <calendar-cmp />\n} @placeholder { <div>Calendar placeholder</div> }\n```", "```js\nnx serve finance-expenses-registration\n```", "```js\nprovideRouter(appRoutes, withEnabledBlockingInitialNavigation())\n```", "```js\nexport const appRoutes: Route[] = [{ path: 'expenses-overview', component: ExpensesOverviewPageComponent },\n{ path: 'expenses-approval', component: ExpensesApprovalPageComponent }];\n```", "```js\nthis.router.navigate(['expenses-overview']); //Option 1\nthis.router.navigateByUrl('/expenses-overview'); //Option 2\n```", "```js\n<a [routerLink]=\"['path', { outlets: { sidebar: 'path'} }]\">Click to navigate</a>\n```", "```js\n{ path: '', component: ExpensesApprovalPageComponent, title: 'Expenses Approval Page' }\n```", "```js\nexport const titleResolver: ResolveFn<string> =\n  (route: ActivatedRouteSnapshot) =>\n    route.routeConfig?.path?.replace('-', ' ') ?? '';\n```", "```js\n{ path: '', component: SomeComponent, title: titleResolver}\n```", "```js\nexport default class ExpensesApprovalPageComponent {}\n```", "```js\n{ path: '……', loadComponent: () => import('@pages/expenses-approval-page/expenses-approval-page.component') }\n```", "```js\n{ path: 'list', component: SomeComponet, component property with the loadComponent property and import the component.\nRoutes with the `outlet` property defined can only be loaded by a router outlet with the same name specified on it. You can define named router outlets by adding a name attribute on the router outlet HTML tag like this:\n\n```", "```js\n\n With the named router outlet in your template and a route configuration with the `outlet` property defined, you have everything set up. Your main router outlet will work as expected and navigate to the expenses overview page when you add `/expenses-overview` after your root URL. The named router outlets work differently. The routes that are used by your named router outlets are called *auxiliary routes* and can be seen as sub-routes that operate independently from your main route. These auxiliary routes form a special kind of URL that looks like this: `http://localhost:4200/expenses-overview(sidebar:list)`.\nAs you can see, round brackets are added to your URL to represent your auxiliary routes. There is only one auxiliary route in our example, but there could be more, and they would all be inside the round brackets separated by a double forward slash. Your auxiliary routes are isolated inside these round brackets so that you can activate different auxiliary routes for the same main route.\nRouting to auxiliary routes inside your TypeScript files can be done like this:\n\n```", "```js\n\n When using `routerLink` in your HTML templates, you must add the following syntax to your HTML tag:\n\n```", "```js\n\n Now that you know about named router outlets, let’s learn about route guards.\nRoute guards\nThe `canActivate`, `canMatch`, `canActivateChild`, and `canDeactivate` properties declare **route guards** in your route configurations. Route guards help you to secure routes and prevent users from accessing a route they are not intended to access. All four properties define a type of route guard that prevents the user from performing a specific routing task, such as activating or deactivating a route.\nThe implementations with the rules when these guards should allow or block a user are created by yourself and can contain any logic you need. Each route can configure multiple guard types, and you can add various implementations for each type. You can configure these guard types and the implementations for them in your route configurations, like this:\n\n```", "```js\n\n In [*Chapter 9*](B21625_09.xhtml#_idTextAnchor170), we will create route guards and look at their implementations; for now, you just need to know that you can protect routes with route guards.\nNow that you know about route guards, let’s move on and start learning about child routes.\nDefining child routes\nRoute configurations can also define **child routes**, which helps organize your routes better and easily create an initiative URL structure. Child routes are defined like this:\n\n```", "```js\n\n The preceding example would load `SummaryComponent` on the `/dashboard/summary` route. You can configure the same route without using child routes, but using child routes offers some advantages. The most apparent benefit is that you can better organize your routes. Another advantage of child routes is that you can share route resolvers and guards. When you use a route guard on a parent route, the guard will automatically be applied to all child routes. You can also use child routes to omit the round brackets in the URLs of your auxiliary routes from the named router outlets. However, there are some drawbacks to this compared to regular auxiliary routes. When using child routes to omit the round brackets, you can’t load different auxiliary routes on the same main URL; instead, you need to add a new configuration for each route and auxiliary route combination.\nFallback routes and redirecting\nYou can configure **fallback routes** by using a double asterisk for the path. Your fallback route will be triggered when no route to the current browser URL is found. Most of the time, the fallback route is used to display a **404 Page Not Found** error. You can configure fallback routes like this:\n\n```", "```js\n\n When working with child routes and named router outlets, you can configure multiple fallback routes, but in most scenarios, one fallback that redirects to a `/expenses-overview` route when they load the root route. You can add this redirect to your `appRoutes` array like so:\n\n```", "```js\n\n Now that you know about fallback routes, let’s dive into route resolvers.\nRoute resolvers\n**Route resolvers** can resolve data before a route is activated and provide that data to your component. That might sound nice, but your route won’t be activated until the data is fetched and can be passed to the route. As a result, when you fetch asynchronous data and the API isn’t responding, the route will not be activated, and the user will be staring at a white screen. Resolvers should only be used if you have some edge case where a component cannot work without having specific data before the component renders. A simple implementation of a route resolver function looks like this:\n\n```", "```js\n\n You can declare the route resolver on your route configurations like this:\n\n```", "```js\n\n You can access the resolved data inside your components using the data property of the route snapshot:\n\n```", "```js\n\n Don’t use route resolvers unless you don’t have any other option. Such scenarios don’t arise often, if at all; however, I wanted to mention resolvers and make you aware of them and their drawbacks. When working on Angular applications, you will find route resolvers quite often in the code base.\nNow that you’ve created components, set up routes, and learned about the Angular router, we will learn about component communication.\nComponent communication\nThis section will dive deep into **component communication**, starting with input and output decorators. Before we begin, let’s create a new component with the Nx generator so that we have something to work with.\nName your new component `navbar` and add it to the `shared-ui-common-components` library. Don’t forget to check the `standalone` checkbox and select `OnPush` for `changeDetection`. When the component has been created, add it to the `index.ts` area of your library:\n\n```", "```js\n\n After that, add the `navbar` component to the `app.component.html` file of your `expenses-registration` application. It’s important to note that you need to add the `NavBarComponent` class to the `imports` array of your `app` component decorator. This is because we are using standalone components, and a standalone component needs to import everything it uses. Once you’ve added the `navbar` component to the template of your app component, you can get the code for the HTML and SCSS of the navbar from this book’s GitHub repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).\nBecause `navbar` is also a standalone component, you need to add `RouterLink` and `CommonModule` to the `imports` array of the component decorator. These two imports are necessary because we use the `routerLink` and `*ngFor` directives in the template of the `navbar` component.\nNow that you’ve created and added the `navbar` component to the `app` component template, we can look into parent-child component communication.\nReceiving values with the @input() decorator\nAs we explained in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014), when we develop Angular applications, we divide our components into smart and dumb components. Dumb components are presentational components that are used in the templates of smart components. These dumb components should only receive data through `@Input()` decorators (alternatively, you can use the new `input()` Signal that was introduced in Angular 17; we will dive deeper into Signals in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129), so for now, we will use the decorator); dumb components do not inject services for data as that is the responsibility of smart components.\n`@Input()` decorators are only defined on child components; the parent components pass data to the input. A component can be considered a child component when it’s declared inside another component’s HTML template. On the other hand, the component that declares a component in its HTML template is regarded as the parent component. Dumb components are always meant to be child components, whereas smart components can be both. Still, smart components are generally used as parent components and seldom declare input and output decorators.\nOur newly created `navbar` component is a dumb component that’s used as a building block for our pages. Since it’s a dumb component, it must rely on input decorators to receive its data. A `navbar` component needs `navbar` items, so let’s define an interface and input. First, define the interface in a new file or underneath your `navbar` component’s class:\n\n```", "```js\n\n Here, we defined the interface. Now, let’s add the input to the `navbar` component, like this:\n\n```", "```js\n@Input() navbarItemsnavbar component in the app component template from our *expenses-registration application*, making navbar a child component of the app component. To pass our new input property data, let’s declare a NavbarItem array inside the app component class, like this:\n\n```", "```js\n<bt-libs-navbar [navbarItems]=\"navItems\" />\n```", "```js\nngOnChanges(changes: SimpleChanges) {console.log(changes)};\n```", "```js\nprivate _navItems: NavbarItem[] = [];\n```", "```js\n@Input()\nset navbarItems(value: NavbarItem[]) {\n  this._navItems = [{label: 'home', route: '/'}, ...value];\n}\nnavbarItems property inside the navbar component or template, it will use the getter, which returns the private property, including the extra home page item. After you change the input property, you can remove the object for the home navbar item from the navItems array declared in your app component.\nSince Angular 16.1, you can achieve the same with the `@Input` decorator instead of creating a getter and setter. Using the `transform` property requires a lot less code and looks much cleaner. Let’s convert our getter and setter into the `transform` property. First, remove the private `_navItems` property and the getter and setter we just added and replace them with this:\n\n```", "```js\nfunction addHome(items: NavbarItem[]) {\n  return [{ label: 'home', route: '/' }, ...items];\n}\n```", "```js\n@Input({ transform: addHome, @Output() decorator.\nEmitting values with the @Output() decorator\nChild components also need a way to send events and data to the parent component. For example, if you have a table component in which you can display and update data, the table component shouldn’t inject services to receive and update the data. This would result in a tight coupling of the table component and the data it displays. Each time you use the table with different data, it needs to add extra services and new logic to persist the data updates, and this is not a desirable situation.\nInstead, the table component should be a dumb component that receives data as inputs and emits an event with the updated data as output. By doing so, your table component remains reusable and doesn’t create unnecessary dependencies. The parent components are smart components that are used for specific business use cases or pages, so each can implement whatever logic is needed to handle the data updates for its specific page or business use case without creating unwanted dependencies.\nTo emit an event to a parent component, we need to create something that can emit our events. We can do this with the following syntax:\n\n```", "```js\n<bt-lib-table (click; in our example, we named the event dataChanged. On the right-hand side, you call a function you’ve created in the component class of the parent component. So, $event will contain whatever values you emit from the child component.\nLastly, we must *emit* events from the child component using the `dataChanged` property. Inside the `table` component, whenever the data changes and you want to emit an event to the parent, you can use the following syntax:\n\n```", "```js\n<select [selected]= \"selectedValue\" (selectionChanged)=\"this.selectedValue = $event\" />\n```", "```js\n<select selectedValue property of the parent component as an input to the selected input property of the child component. When the child component emits the selectedChanged event, the selectedValue property will automatically be updated in the parent component. Take a look at the following syntax:\n\n```", "```js\n\n This is the same as using the following:\n\n```", "```js\n\n As you can see, the banana-in-a-box syntax combined with the square and round brackets is much cleaner and more compact. Alternatively, you can use the new `model()` Signal that was introduced as a developer preview in Angular 17.2, but we will cover this scenario in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129).\nNow that you know how to input, output, and two-way bind properties with the input and output properties, let’s look for another way to communicate data between components and routes.\nOther component communication methods\nThere are a few other means of communication for Angular components. You can access public properties and methods of child components with the `@ViewChild` decorator, communicate with child, parent, sibling, and unconnected components with *services*, and pass data in various manners to components with the *router*. Let’s start with the `@``ViewChild` decorator.\nUsing the @ViewChild decorator to access child components\nThe `@ViewChild` decorator is used to access template elements inside the component class. As in alternative to the decorator, you can also use the new `viewChild()` Signal that was introduced in Angular 17.2; we will cover this in more detail in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129). Using the `@ViewChild` decorator to access or update child properties and methods is straightforward but has some drawbacks. When using `@ViewChild` to communicate with your components, you can mutate values within your child component, which can lead to unexpected behavior and bugs that are hard to debug. Besides that, it makes your component hard to test. If you have a scenario where you need to update properties from the child in the parent, here’s the syntax:\n\n```", "```js\n\n Here, you declare the decorator; inside the function brackets of the decorator, you enter the child component’s class name, then give it a variable name and type it with the component’s class name. After the view of the parent component has been initialized, you can access the child component and its public properties and methods like this:\n\n```", "```js\n\n As mentioned previously, I’m not a fan of this decorator, and it’s recommended not to use it unless you need to achieve something that can’t be done in another way.\nNow that you know how to use the `@ViewChild` decorator to access properties and methods in child components, let’s explore communication through the Angular router.\nComponent communication with the Angular router\nThe *router* is meant to navigate between routes but can also send data to a component that’s been loaded on a route. The most common examples are route parameters and additional query parameters in the route, but you can also add data to the route using the `data` property in the route configuration or with route resolvers.\nLet’s say we have the following route configuration:\n\n```", "```js\n\n We also have this URL in our browser: [https://some-url.com/dashboard/123?queryParam=paramValue](https://some-url.com/dashboard/123?queryParam=paramValue).\nWhen we reach this route, the `dashboard` component will be loaded. In that component, we can access the dashboard ID, the caption we added to the `data` property, the resolved permission data, and the value of the `query` parameter. To do so, you need to inject `ActivatedRoute` into the constructor or use the `inject` function:\n\n```", "```js\n\n After that, you can access the properties in the route snapshot like this:\n\n```", "```js\n\n You can also access the properties more reactively by subscribing – just remove the `snapshot` property and then add your subscription logic instead of accessing the properties through the `get` method:\n\n```", "```js\n\n You can subscribe to the router’s `paramMap`, `queryParamMap`, and `data` objects. Since Angular 16, you can also directly bind the route values to your component’s `@Input()` decorators. To achieve this, you need to add `withComponentInputBinding` to your app config where you provide your routes:\n\n```", "```js\n@Input() caption?: string;\n@Input() id?: string;\n@Input() queryParam?: string;\n@Input() permissions?: string;\n```", "```js\n@Input('caption') captionFromRouteData?: string;\n```", "```js\n@Injectable()\nclass SampleService {}\n```", "```js\n@Component({……… , providers: [SampleService] })\nclass ListComponent {}\n```", "```js\n@NgModule({ declarations: [ListComponent],\n  providers: [SampleService]})\nclass AppModule {}\n```", "```js\nexport const appConfig: ApplicationConfig = {\n  providers: [SampleService],\n};\n```", "```js\n@Injectable(@Injectable() decorator, let’s learn how to provide classes and other values such as strings, Booleans, and functions using provider objects.\nProviding dependencies with provider objects\nWhen you provide dependencies with a `providers` array. You can use two properties to declare a dependency with a provider object:\n\n*   `provide` property holds the `Injector` instance.\n*   `Injector` how to create the dependency, and it can be defined with four values:\n    *   `useClass`: This tells Angular to provide the given class when the corresponding provider token is used\n    *   `useExisting`: This aliases another provider token and accesses the same dependency with two different tokens\n    *   `useFactory`: This defines a factory function to construct the dependencies based on some logic\n    *   `useValue`: This provides a static value such as a string or date as a dependency\n\nNow, let’s explore the four provider definitions in more detail.\nDeclaring provider objects with useClass\nHere’s an example of a provider object using the `useClass` provider definition:\n\n```", "```js\n\n The preceding syntax is the same as using the following syntax:\n\n```", "```js\n\n In the scenario where you only supply a class name, the provider object is automatically created behind the scenes. The provider object uses the class for the provider token and definition, so when would you use the provider object instead of only using the class?\nCommonly, `useClass` is used when you want to overwrite a dependency injection class with a new implementation. In the preceding example, we provided a `Logger` class; let’s say you create a new `BetterLogger` class extending the original `Logger` class. If you have a large application and the `Logger` service is used throughout your application, it’s a lot of work to change the service everywhere it’s declared. Instead of updating all dependency injection consumers, you can create a provider object and return the `BetterLogger` class for the `Logger` token:\n\n```", "```js\n\n If you provide the `Logger` service inside the `providers` array as well, you must make sure that you declare the new provider object with the `BetterLogger` class below your previous provider object, or simply remove the old object. If the `Logger` service is provided using the `providedIn` property inside the injectable decorator, the overwrite with `BetterLogger` will just work without any gotchas.\nNow that you know how to create provider objects with the `useClass` provider definition, let’s examine the `useExisting` provider definition.\nDeclaring provider objects with useExisting\nThe `useExisting` property allows you to map one provider token to another provider token, making sure two tokens will return the same dependency:\n\n```", "```js\nproviders: [ BetterLogger,\n  { provide: Logger, Logger and BetterLogger that each return an instance of the BetterLogger class instead of the same instance.\nNow that you know about `useExisting`, let’s explore `useFactory`.\nDeclaring provider objects with useFactory\nThe `useFactory` provider definition allows you to define a function as a dependency. This can be just a regular function you want to inject into multiple places of your application or a factory function that constructs a service class. Let’s say you have `AdminDashboardService` and a regular `DashboardService` you want to inject using the `DashboardService` tokens, depending on the active user role. You can achieve this with `useFactory`. First, create your factory function:\n\n```", "```js\n\n Next, declare the provider object inside your `providers` array, like this:\n\n```", "```js\n{ provide: BASE_URL, InjectionToken object.\nUsing InjectionToken as a provider token\nWhen you declare a provider object, you supply the `provide` property with a provider token. The provider token is used to inject the dependency into the consumers of the dependency. You can use three values for the provider token, but only two should be used. You can use a class name, `InjectionToken`, or a string. Only the class name and `InjectionToken` should be used. When providing a class-based dependency, you should use the class name as the provider token; when using a non-class-based dependency, you should use an `InjectionToken` object. You can create an `InjectionToken` object like this:\n\n```", "```js\n{ provide: BASE_URL, useValue: 'www.someurl.com/'}\n```", "```js\n{ provide: InjectionToken instead of a string:\n\n*   `InjectionToken` objects are type-safe and allow TypeScript to perform type-checking on your injected value. When you use a simple string, the compiler will not know what type your dependency is.\n*   When using a string, you can run into name collisions, meaning you can assign two dependencies with the same string, which can result in wrongly injected values, errors, and bugs. This doesn’t have to be because you define two dependencies with the same string; it can also happen when a dependency you use from a third-party library uses the same string as a provider token. The `InjectionToken` object ensures a unique value is used for your provider token.\n*   When you minify your code during the production build, string values can be renamed. This can result in problems with your dependency injection system.\n\nNow that you know how to provide dependencies and what `InjectionToken` objects are, let’s learn how to inject and consume dependencies.\nInjecting dependencies\nThere are two ways to inject dependencies: `inject` function, you can improve some architectural patterns and inject values in places where you don’t have a constructor. You can inject services everywhere within your Angular applications – in component classes, services, other classes, and even in functions you export. Let’s examine how to inject class-based dependencies using constructor injection and the `inject` function, starting with constructor injection:\n\n```", "```js\n\n Doing the same thing with the `inject` function looks like this:\n\n```", "```js\nconstructor(InjectionToken-based dependencies with the inject function can be done like this:\n\n```", "```js\n\n As you can see, you don’t need the `@Inject()` decorator for the `inject` function; you can simply use `InjectionToken` inside the function brackets of the `inject` function, and the rest is done for you. After injecting a dependency, you can use it like any other value:\n\n```", "```js\nexport class AppComponent {\n  private url = inject(BASE_URL); // Is injection context\n  constructor() { // Is injection context }\n  someMethod() { // No injection context }\n}\n```", "```js\nexport const fetchDashboards = (): Observable<Dashboard[]> => inject(HttpClient).get<Dashboard[]>('api/dashboards');\n```", "```js\nexport const fetchDashboards = (): Observable<Dashboard[]> => inject function to inject the Angular HttpClient as a dependency to fetch the dashboards. You can use this fetchDashboards function inside the injection context of your components and services. For example, you can assign the function to a component property and subscribe to it in your template using the async pipe:\n\n```", "```js\n\n Now, inside the template of this component, you can do something like this:\n\n```", "```js\n\n When using the `fetchDashboards` function outside the injection context, such as in a method, you get an error telling you that the `inject` function can’t be used outside the injection context. But there is a solution to this: you can use JavaScript closure to use the `fetchDashboards` function anywhere, even outside the injection context. To use closure, adjust the `fetchDashboards` function so that it returns a function:\n\n```", "```js\nprotected _fetchDashboards = fetchDashboards();\n```", "```js\nexport default class AppComponent {\n  private _fetchDashboards = fetchDashboards();\n  loadDashboards() { this._fetchDashboards().subscribe(…) }\n}\n```", "```js\nexport class baseService {\n  constructor(private router: Router) { }\n}\nexport class DashboardService extends baseService {\n  constructor(private logger: Logger, router: Router) {\n    super(router);\n  }}\n```", "```js\nexport class baseService {private router = inject(Router);}\nexport class DashboardService extends baseService {\n  private logger = inject(Logger);\n}\n```", "```js\nexport const navigateFn = () => (url: string) => inject(Router).navigate([url]);\nexport class baseService {\n  protected _navigateFn = navigateFn();\n}\n```", "```js\nthis._navigateFn('some/url');\n```", "```js\nconstructor(inject function, you can use the following syntax:\n\n```", "```js\n\n Now that you know everything you need to know about Angular dependency injection, let’s create a simple service before we move on to the next chapter.\nTo create this service, we are going to use the Nx generator again. First, create a new library called `expenses` under the `finance` domain with its type set to `data-access`. Next, open your Nx console again and click `service` and select **@schematics/angular -** **service**.\nFollow these steps to generate the service:\n\n1.  In the `services/expenses`.\n2.  In the `finance-data-access-expenses`.\n3.  In the top-right corner, click **Generate**.\n4.  Go to the `index.ts` file of your *expenses library* and add the following code:\n\n    ```", "```js\n\nThat’s all for now! With that, you’ve created a service and know everything you need to know about Angular dependency injection.\nSummary\nIn this chapter, we explored some of the most fundamental features in the Angular framework and learned what Angular added in their latest major releases. You learned about Signals, the new control flow syntax, and `@defer` blocks. We covered how to communicate between components using input and output decorators, as well as less conventional methods for component communication using router data and the `viewChild` decorator. You also learned about the Angular router and how to configure route objects for more advanced scenarios and auxiliary routes. Finally, you learned about dependency injection in great detail. You now know what the difference is between constructor injection and dependency injection when using the new `inject` function. We also created some `provides` arrays and demonstrated how to declare the injection value and token. Lastly, you learned about the injector hierarchy and how you can control the provider that should be used by applying resolution modifiers.\nIn the next chapter, we will learn about Angular directives, pipes, and animations.\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```"]