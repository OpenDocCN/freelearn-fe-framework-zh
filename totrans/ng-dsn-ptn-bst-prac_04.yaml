- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components and Pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main building blocks of an Angular application are the **components**. It
    is by using them that we assemble our user interfaces and define the flow of the
    experience. In Angular architecture, components organize an application into reusable
    parts, making it easy to maintain and scale.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the communication between components and thus
    assemble our pages using component composition, avoiding the anti-pattern of creating
    monolithic interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between components – inputs and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practice – using the `TrackBy` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating responsibilities – smart and presentation components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication from the child component – using `@Output`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create reusable and easy-to-maintain
    components and pages, streamlining the development of your project and increasing
    your productivity and that of your team.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4).
  prefs: []
  type: TYPE_NORMAL
- en: Creating components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every interface created with Angular is a component in the architecture of the
    framework; therefore, theoretically, we could have our entire application in a
    single component.
  prefs: []
  type: TYPE_NORMAL
- en: As we studied in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081), *Organizing
    Your Application*, it is best to separate your application into modules, and with
    components, we use the same reasoning by separating our interfaces into and composing
    them with different components, maximizing reuse and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will illustrate this with a gym diary application, as shown
    in the following figure – to focus on Angular, we will not use Angular Material,
    only HTML, CSS (in this case, Tailwind CSS), and TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Gym diary application UI](img/B19562_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Gym diary application UI
  prefs: []
  type: TYPE_NORMAL
- en: 'In this initial example, we created a component with just the HTML template
    and the CSS and TypeScript files are as they were created by Angular CLI. Here’s
    the top of the page first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using good HTML semantic practices, let’s create a `main` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see that in the preceding example, the interface is designed and stylized,
    but it is not functional because the diary entries are fixed in HTML, and in our
    application, the user should be able to add as many entries as they want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify here that this part of the diary entry could be a component
    for the page to use, so let’s create a component called `entry`. As we learned
    in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right
    Way*, we are going to use the Angular CLI to create this new component in the
    module we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this command, the Angular CLI will create a folder with the following four
    files in addition to updating the `diary` module with the new component.
  prefs: []
  type: TYPE_NORMAL
- en: '`entry-item.component.css`: This file will contain the component’s style sheet.
    Angular manages to solve a big pain point of a web application, which is the CSS
    scope of each component. With this feature, we can specify the component’s styling
    without having to worry about whether it will affect an application’s CSS even
    using the same property or selector name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry-item.component.html`: This file contains the component’s HTML template
    and, although the extension seems to indicate that we can only use HTML tags,
    in the template file, we can use Angular directives, as we will study in this
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry-item.component.spec.ts`: This file contains the unit test for the component,
    which we will detail in [*Chapter 10*](B19562_10.xhtml#_idTextAnchor264), *Design
    for Tests:* *Best Practices*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry-item.component.ts`: This is the TypeScript file that represents the
    component itself. All other files are optional, making it possible for you to
    create a component with just this file, although this is not a practice widely
    applied in Angular projects and is only recommended for very small components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `entry-item.component.ts` file, the Angular CLI created the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we reinforce the definition that a component is a TypeScript
    class, and by using the `@Component` decorator, we indicate to Angular where the
    parts to assemble it are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selector`: This is an optional property that defines what the component’s
    selector will be if it is used in the template of another component. Components
    that represent a page do not need to have a selector defined as they are instantiated
    from a route. The Angular CLI suggests the selector based on your application’s
    prefix defined in the `prefix` property of the `angular.json` file, along with
    the name you defined in the `ng` `g` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateUrl`: This defines the path of the HTML file that contains the component’s
    template. Alternatively, we can use the `template` property to define a string
    with all the component’s HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleUrls`: This defines the path of the CSS files that contain the component’s
    styling. A detail of this property is that it is an array, so it is possible to
    have more than one CSS file linked to the component. Alternatively, we can use
    the `style` property to define a string containing the component’s CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `entry-item.component.html` file, we will place the snippet that represents
    an item in a list of exercises in our gym diary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the representation of an item, with the difference being that
    we are using the `<div>` element instead of `<li>` because we want our component
    to be as reusable as possible here – it may not necessarily be used within a list
    and within an `<``ul>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put our component to use. In the `diary.component` component, let’s refactor
    the `diary.component.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the `app-entry-item` selector, we are consuming our new component on the
    page. From version 15 of Angular, we can use self-closing tags for components,
    so we have used `<app-entry-item />` here, but if you prefer the previous way,
    `<app-entry-item>` `</app-entry- item>` also still works.
  prefs: []
  type: TYPE_NORMAL
- en: Running our project, we can see that it continues to work. However, the data
    is the same in both items. We now need a way to pass information between components,
    and we’ll see how to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between components – inputs and outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our gym diary application, we now need the workout list page component, `DiaryComponent`,
    to communicate with the list item component, `EntryItemComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to accomplish this communication is with Angular’s Property
    Binding concept. Despite the complicated name, in practice, we annotate a component
    object’s property with the `@Input` annotation, so Angular creates a custom HTML
    attribute on the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this concept in practice; first, let’s create an interface that will
    represent an item in our diary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, we create the file and, as an organized practice,
    we create a folder to store the module’s interfaces. In the generated file, we
    will define the object we want to communicate with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We create an interface defining the object and a type to define a list of exercises,
    improving the future readability of our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `entry-item.component.ts` file, let’s add the new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a property called `exerciseSet` of type `ExerciseSet` that we
    just defined. We use the `!` symbol in the type definition because we are going
    to define its value at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Input` annotation receives the `exercise-set` string as a parameter. With
    this, we define the name of the custom HTML attribute to be used in the template.
    This parameter is optional; if it's not used, the name of the attribute will be
    the name of the property. Here, it would be `exerciseSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now change our template to use this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To use the component’s properties inside the template, we use the `{{ }}` syntax.
    Here, we can see an advantage of using VS Code with the Angular Language Service
    extension enabled because we have type-checking in the HTML template, avoiding
    typos, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Something to highlight in this example is the `Date` attribute. Here, we are
    using an Angular feature called `pipe`, which allows the formatting of a template
    element. In this case, we are formatting a date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now configure a list of exercises in the `diary.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we create a property called `exerciseListExample` and fill
    it with objects from the `ExerciseSet` interface. Now, let’s change the list template
    in the `diary.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the template, we are using the `ngFor` directive, which has the function
    of iterating over a list and rendering the element we want to define in the template.
    For each list item, we are going to create a new `app-entry-item` component and
    now we want to assign an item to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we use the `[exercise-set]` attribute to pass the item provided
    by `ngFor`. When we run our project, we have the list, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Gym diary application UI after refactoring](img/B19562_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Gym diary application UI after refactoring
  prefs: []
  type: TYPE_NORMAL
- en: With this, we understand how to pass information from one component to another,
    but we can improve this project by introducing a good performance practice, the
    `TrackBy` property.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice – using the TrackBy property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the `*ngIf` directive, the `ngFor` directive will probably be the directive
    that you will use the most in your Angular projects. Although simple, this directive
    can hide a performance and perception problem in the frontend that will occur
    for your user.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, let’s add a new list button, simulating a list update coming
    from the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `diary.component.ts` file, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method replaces the array with this new array, which contains the same
    elements but with one more item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the button to the list template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we click on the **Server Sync** button, the entire item list is rendered,
    even though the new list is identical to the original except for the addition
    of a new item.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Chrome DevTools](img/B19562_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Chrome DevTools
  prefs: []
  type: TYPE_NORMAL
- en: For a few items, this may not necessarily be a problem, but for a larger list,
    this unnecessary rendering may offend the performance perception our user will
    have of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve this kind of case, the `ngFor` directive has the `TrackBy` option.
    Let’s refactor our code to demonstrate this option; first, let’s create a method
    for the exercise list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method tells Angular how to identify the single element in a collection
    that it will iterate through the `*ngFor` directive. Think of it as the *primary
    key* of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the component’s template, let’s change the `ngFor` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are telling `ngFor` to render based on the `id` property of the object.
    Running it again in the browser with Chrome DevTools, we see that now only the
    item with the `id` attribute is rendered on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TrackBy` attribute, in addition to avoiding unnecessary rendering, has
    the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Enables animations when removing and adding items from the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retains any DOM-specific UI state, such as focus and text selection, when the
    collection changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve learned about the use of this `ngFor` property, let’s study how
    we can architect the composition of our components and pages.
  prefs: []
  type: TYPE_NORMAL
- en: Separating responsibilities – Smart and Presentation components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The information flow of a **single-page application** (**SPA**) can be quite
    complex and, if you don’t think about this flow from the beginning of your design,
    it can affect the productivity and quality of your project over time.
  prefs: []
  type: TYPE_NORMAL
- en: The simpler the better; therefore, a very common design pattern not only in
    Angular applications but also in SPAs in general is the composition of interfaces
    using Smart and Presentation components. In literature and in the community, you
    will also find this pattern under the name of **Smart** and **Dumb** components
    or **Container** and **Presentation** components.
  prefs: []
  type: TYPE_NORMAL
- en: A Smart component has the UI business rule; it is where we will have injected
    the services that will communicate with the backend and where the interface with
    the Presentation components will be composed.
  prefs: []
  type: TYPE_NORMAL
- en: A Presentation component is a component that has the sole purpose of showing
    the data passed by the Smart component, normally via input. A Presentation component
    in turn can contain one or more components of the Presentation type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this pattern, we will use the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Smart and Presentation components](img/B19562_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Smart and Presentation components
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have a source of truth, which is the Smart component, and the
    communication occurs in only one direction, this is what we call a Unidirectional
    Data Flow. The purpose of this pattern is to isolate all states within a component
    and thereby simplify state management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor our project to fit this design pattern. Let’s create a new presentation
    component using the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this new component, we are going to move the part that renders the list
    of diary entries into your template. In the `list-entries.component.html` file,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The list that will be displayed will come ready from the `DiaryComponent` component,
    so in the `list-entries.component.ts` file, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we move the `itemTrackBy` function into the component, as it will be its
    function to display the list, and we include the `exerciseList` attribute with
    the `@Input` decorator. In this example, we didn’t specify any parameters, so
    the name of the template’s attribute will be the same as the attribute of the
    `exerciseList` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the `Diary` template in the `diary.component.html` file to use
    the new presentation component we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `DiaryComponent` Smart component just passes the list to the `ListEntriesComponent`
    Presentation component, which iterates over the list by calling the `EntryItemComponent`
    Presentation component. With this structure, only the `DiaryComponent` component
    needs to worry about the list of exercises, respecting SOLID’s Single Responsibility
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve studied how to structure our pages and components, but how do child components
    communicate with their parents? Let’s learn about the output attributes of Angular
    components next.
  prefs: []
  type: TYPE_NORMAL
- en: "Communication from the child component – using \L@Output"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We studied how parent components, which can be either smart or presentational,
    can communicate with their child components by using attributes marked with the
    `@``Input` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we need the opposite, the child component passes some information
    to the parent. As we saw in the previous section, business rule processing should
    ideally happen in the Smart component. For this type of communication, we mark
    attributes with the `@``Output` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a button for adding an item to our diary. We’ll see the use of
    forms in [*Chapter 6*](B19562_06.xhtml#_idTextAnchor186), *Handling User Input:
    Forms*, but here we want to focus on the interaction between components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Angular CLI, we will create the new component using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new component’s template, let’s move the diary button template into
    the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `new-item-button.component.ts` file, we will add the new attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first create the `newExerciseEvent` attribute and add the `@Output`
    decorator to define that it will be an attribute present in the component’s template.
  prefs: []
  type: TYPE_NORMAL
- en: Here, there is a difference from the `@Input` attribute; in this case, we are
    already assigning an object of the `EventEmitter` class to the variable. This
    Angular class aims to emit events when a certain action takes place.
  prefs: []
  type: TYPE_NORMAL
- en: This is necessary because, unlike `@Input`, the value of which is assigned when
    the component is structured and rendered, `@Output` communication can occur at
    any time, depending on the user’s action.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventEmitter` class uses TypeScript’s type-checking capability, making
    it possible for us to determine what type of object we are going to emit to the
    parent component.
  prefs: []
  type: TYPE_NORMAL
- en: In the `addNewExercise` method, we create an object of type `ExerciseSet`, and
    using the `emit` method of the `EventEmitter` class, we pass this object to the
    parent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the template – let’s add the method call to the button’s `click` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s refactor `DiaryComponent` to consume the new button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the template, we are using the `app-new-item-button` component to pass the
    `addExercise` function to the `newExerciseEvent` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can highlight that the binding of an `@Output` attribute must be done
    with parentheses – `( )` – and this `$event` parameter represents the object that
    the child component will emit. If you highlight this parameter in VS Code, we
    can verify that it is of type `ExerciseSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s create the `addExercise` method in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our method receives the emitted value and adds it to the `exercises` array.
    Running our project, we can see that the items are successfully added.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can see in practice the whole flow of the design pattern
    of the Smart and presentation components. When clicking on the `Diary` Smart component
    receives the new exercise from the `NewItemButtonComponent` presentation component.
  prefs: []
  type: TYPE_NORMAL
- en: By updating the list, the list is automatically passed to the `ListEntriesComponent`
    component, which renders the list on the screen. Now we are going to implement
    actions for the items of the list of exercises – we will see how to emit events
    of these items and how to identify these elements.
  prefs: []
  type: TYPE_NORMAL
- en: Propagating events from nested components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add the options to delete an item from the list and increase the number
    of repetitions to our diary. First, let’s add the buttons to the list item template.
    In the `entry-item.component.html` file, we will edit the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The challenge here is to ensure that the action that will happen on each item
    in the list if correctly identified to be applied correctly – that is, the `Diary`
    Smart component that handles the list will find the corresponding item and change
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will apply the Angular output feature to the item component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We create two outputs, each one for a different event that we want to emit,
    and we type them because we need different actions.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the `delete` method, which will emit the `id` value of the item
    we want to delete, and the `newRep` method, with which we will add repetitions
    to the item of the exercise that will be performed and emit that item.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will return to the template to associate the methods with the buttons created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s change the `list-entries.component` presentation component for creating
    the output, which here, for simplicity, will have the same name as the item’s
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To propagate the item’s events, we will change the list template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we only emit the item’s event using the `emit` method of the
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will refactor the `DiaryComponent` Smart component to react to
    the item’s event. First, let’s see the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, we used parentheses to associate it with a method,
    which will handle the event and receive the element emitted by the parameter of
    that method using the `$``event` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now refactor the component by creating two new methods – one to delete
    a journal entry and one to create a new repetition for an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are using the TypeScript array methods to simulate deleting and changing
    the array of items. We can see that the method already receives the deletion item
    or id automatically due to Angular’s event emission mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: We are taking advantage of the smart and presentation component pattern here
    to leverage its usage with a slightly more complex requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the elements responsible for rendering the interface
    of our project, the components. We saw how to create and organize the components
    in a granular way, resulting in our project being more maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: We also studied how to communicate between components using the `@Input` and
    `@Output` attributes, using the capabilities of Angular that facilitate this communication.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the good practice of using `TrackBy` to iterate lists in templates using
    the `ngFor` directive, improving performance specifically for lists with many
    items.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we study the design pattern of the Smart and Presentation components,
    a way of organizing components and their interactions in order to simplify this
    orchestration with a unidirectional information flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study the Angular elements responsible for the
    business rules and interaction with the backend – the services.
  prefs: []
  type: TYPE_NORMAL
