- en: Implementing Flux Architecture with Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vuex 实现Flux 架构
- en: With the Flux concepts clear in our minds, we will now explore the Vuex framework,
    understand how it works, and, with the help of some examples, see how you can
    use Vuex inside your Vue applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们心中明确了 Flux 概念之后，我们现在将探索 Vuex 框架，了解它是如何工作的，并通过一些示例，看看您如何在 Vue 应用程序中使用 Vuex。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Vuex at a glance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vuex 快速浏览
- en: The boilerplate code that will be used to run the examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用于运行示例的样板代码
- en: The Vue.js reactivity system explained
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue.js 反应性系统解释
- en: Understanding the core concepts of Vuex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Vuex 的核心概念
- en: Enabling strict mode while developing to prevent accidental direct state modifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发时启用严格模式以防止意外直接修改状态
- en: Restrictions in form handling when using Vuex
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vuex 处理表单时的限制
- en: 'Simple counter: all the Vuex concepts in a very simple example'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单计数器：一个非常简单的示例中包含的所有 Vuex 概念
- en: The first section introduces you to Vuex, focusing on the concepts behind the
    framework.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分向您介绍了 Vuex，重点介绍了框架背后的概念。
- en: In the second section, you will be presented with a minimal HTML code to run
    the examples in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，您将看到一个最小的 HTML 代码，用于运行本章的示例。
- en: In the third section, the Vue reactivity system is examined in detail. This
    is useful because Vuex exploits this reactivity system to plug itself seemlessly
    into the Vue application's architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分，Vue 反应性系统被详细审查。这很有用，因为 Vuex 利用这个反应性系统无缝地将其本身插入到 Vue 应用程序的架构中。
- en: In the fourth section, all Vuex core concepts are thoroughly examined, and,
    with the help of code snippets, you will see that Vuex is both powerful and simple
    to use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四部分，所有 Vuex 核心概念都得到了彻底的审查，通过代码片段的帮助，您将看到 Vuex 既有强大的功能又易于使用。
- en: The fifth and sixth sections will explain some concepts to keep in mind when
    using Vuex inside your applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第五和第六部分将解释在使用 Vuex 在您的应用程序中时需要记住的一些概念。
- en: Finally, in the last part of this chapter, a simple example will show you most
    of the Vuex concepts put together in a single HTML file, helping you to understand
    the whole picture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章的最后部分，一个简单的示例将向您展示如何将 Vuex 的大多数概念组合在一个单独的 HTML 文件中，帮助您理解整体情况。
- en: Once you have read this chapter, you will have a clear understanding of the
    Vuex framework, and you will be ready to start using it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您阅读了本章，您将对 Vuex 框架有一个清晰的理解，并且您将准备好开始使用它。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在系统上安装 Node.js。最后，为了使用本书的 Git 仓库，用户需要安装 Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[https://goo.gl/2zXEav](https://goo.gl/2zXEav)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/2zXEav](https://goo.gl/2zXEav)'
- en: Vuex at a glance
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuex 快速浏览
- en: In [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml), *Rethinking User
    Interfaces with Flux, Vue and Vuex*, we defined Vuex as *a state management pattern
    + library for Vue.js applications. It serves as a centralized store for all the
    components in an application, with rules ensuring that the state can only be mutated
    in a predictable fashion*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml)《用 Flux、Vue 和 Vuex 重新思考用户界面》中，我们将
    Vuex 定义为 *一个用于 Vue.js 应用的状态管理模式 + 库。它作为应用程序中所有组件的集中式存储，有规则确保状态只能以可预测的方式变异*。
- en: 'Although I think that, having read [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml),
    *Rethinking User Interfaces with Flux, Vue and* definition should sound clear
    enough to you, it is still a bit obscure. Let''s list down the three concepts
    contained in the preceding sentences:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我认为，在阅读了[第 1 章](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml)《用 Flux、Vue 和 Vuex
    重新思考用户界面》之后，*Rethinking User Interfaces with Flux, Vue and* 的定义应该对您来说已经足够清晰，但它仍然有点模糊。让我们列出前述句子中包含的三个概念：
- en: The centralized store
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式存储
- en: The fact that the state can only be mutated in a predictable way
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态只能以可预测的方式进行变异的事实
- en: The Vue reactivity system
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue 反应性系统
- en: If you look back to *Figure 1.6* in *Flux architecture summarized* section in
    [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml), *Rethinking User Interfaces
    with Flux, Vue and Vuex*, you will see that the Flux architecture has one dispatcher
    that dispatches actions to every store. Having only one store means that the dispatcher
    can be inside the store and you can dispatch actions using the centralized store.
    In Vuex, we have a single store and its state is called **single state tree**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾一下[第1章](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml)中“Flux架构总结”部分的*图1.6*，在*用Flux、Vue和Vuex重新思考用户界面*，您会看到Flux架构有一个分发器，它会将动作分发到每个存储中。只有一个存储意味着分发器可以在存储内部，并且您可以使用集中式存储来分发动作。在Vuex中，我们有一个单一存储，其状态被称为**单一状态树**。
- en: One fundamental rule in Flux and Vuex is that the state can be mutated only
    because of an action. No component, class, or piece of code should modify the
    state. Only the code that is linked to an action can actually change the state
    values. this by using mutations that can only be executed by actions. In this,
    Vuex differs from Flux. In Flux, actions are just data objects containing the
    information about the action to be performed. In Vuex, actions can execute code
    that will eventually end by committing one or more mutations that will change
    the state. You will read about mutations and actions later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux和Vuex中的一个基本规则是，状态只能因为动作而更改。没有任何组件、类或代码应该修改状态。只有与动作相关联的代码实际上可以更改状态值。Vuex通过只能由动作执行的突变来实现这一点。在这方面，Vuex与Flux不同。在Flux中，动作只是包含要执行的动作信息的简单数据对象。在Vuex中，动作可以执行最终提交一个或多个将更改状态的突变的代码。您将在本章后面阅读有关突变和动作的内容。
- en: Finally, after an action has been dispatched and the state has been updated,
    it must notify the views of the application of the fact that has changed. This
    is done by taking advantage of the Vue reactivity system, which is the topic of
    the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在动作已分发并且状态已更新后，必须通知应用程序的视图哪些内容已更改。这是通过利用Vue响应性系统来完成的，这是下一节的主题。
- en: Boilerplate code for the examples
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例的样板代码
- en: 'In the next few pages, you will be provided with some examples. In order to
    execute these examples, you need to create an HTML file as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，您将获得一些示例。为了执行这些示例，您需要创建一个如下所示的HTML文件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By copying the example code inside the `<script>` tag, you can run it and see
    the results. Almost every example code can be found in the Git repository of this
    book, under the `/chapter-2/` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制`<script>`标签内的示例代码，您可以运行它并查看结果。几乎每个示例代码都可以在本书的Git仓库中找到，位于`/chapter-2/`文件夹下。
- en: Vue.js reactivity system explained
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js响应性系统解释
- en: One of the powerful features of Vue is its reactivity system. It is an unobtrusive
    way to detect changes to the components model. A component model is just a plain
    JavaScript object. When it changes, Vue detects the changes and updates the corresponding
    views. In Vuex, the single state tree is reactive, like the `data` part of a Vue
    component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vue的一个强大功能是其响应性系统。它是一种不侵入的方式来检测组件模型的变化。组件模型只是一个普通的JavaScript对象。当它发生变化时，Vue会检测这些变化并更新相应的视图。在Vuex中，单一的状态树是响应的，就像Vue组件的`data`部分一样。
- en: It is important to understand how the reactivity system works to avoid some
    common mistakes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解响应性系统的工作原理对于避免一些常见的错误非常重要。
- en: 'There are two ways to detect whether a value inside a JavaScript object has
    changed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以检测JavaScript对象内部的一个值是否已更改：
- en: By using the `Proxy` feature, which is defined in ECMAScript 2015 (6th Edition,
    ECMA-262)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用在ECMAScript 2015（第6版，ECMA-262）中定义的`Proxy`功能
- en: By using `Object.defineProperty`, which is defined in ECMAScript 2011 (5.1 Edition,
    ECMA-262)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用在ECMAScript 2011（第5.1版，ECMA-262）中定义的`Object.defineProperty`
- en: For compatibility reasons, Vue decided to use `Object.defineProperty`, which
    means that there are some limitations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性原因，Vue决定使用`Object.defineProperty`，这意味着存在一些限制。
- en: 'When you create a component, Vue will walk through all the properties of the
    `data` part and use `Object.defineProperty` to convert them into `getter`/`setter`
    methods. For this reason, Vue can only detect changes to properties that have
    been defined in the `data` part of a component. Let''s see an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个组件时，Vue会遍历`data`部分的所有属性，并使用`Object.defineProperty`将它们转换为`getter`/`setter`方法。因此，Vue只能检测到在组件的`data`部分中定义的属性的变化。让我们看一个例子：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the `counter` property is not declared in the `data` section
    of the component. This prevents Vue from detecting that `counter` has been changed,
    and so, when a user clicks on the button Begin!, they will not see the counter
    increasing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`counter`属性没有在组件的`data`部分中声明。这阻止Vue检测到`counter`已被更改，因此，当用户点击按钮“开始！”时，他们将看不到计数器的增加。
- en: 'This can be easily fixed by adding `counter` to the `data` section and removing
    it from the `created()` method. Look at the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在`data`部分添加`counter`并从`created()`方法中移除它来轻松修复。看看以下代码：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find the code for the preceding example in the Git repository of this
    book, inside the file `chapter-2/counterTo3/counter.html`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的Git仓库中找到前述示例的代码，位于`chapter-2/counterTo3/counter.html`文件中。
- en: 'When using `Arrays`, Vue cannot detect the following changes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`数组`时，Vue无法检测以下更改：
- en: Setting a value directly using the index—for example, `this.items[indexOfItem]
    = newItem`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用索引设置值——例如，`this.items[indexOfItem] = newItem`
- en: Changing the array length—for example, `this.items.length = newLength`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变数组长度——例如，`this.items.length = newLength`
- en: 'To avoid these problems, you could either create a new array and assign it
    to the corresponding data property, or use array methods, such as `push()` or
    `splice()`. The following are different ways to update an array observed by Vue:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，你可以创建一个新的数组并将其分配给相应的数据属性，或者使用数组方法，例如`push()`或`splice()`。以下是一些更新Vue观察到的数组的不同方法：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now understood that every time we properly change something inside a component
    model or inside the single state tree, Vue detects it and updates the corresponding
    views accordingly. But what about performance? Isn''t it bad to update the views
    on each modification? In fact, Vue exploits how the JavaScript event loop works
    to queue all the updates to the views. To understand this concept, let''s focus
    on the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，每次我们正确地更改组件模型或单个状态树内部的某个东西时，Vue都会检测到并相应地更新视图。但性能如何？每次修改都更新视图不是不好吗？实际上，Vue利用JavaScript事件循环的工作原理来排队所有视图的更新。为了理解这个概念，让我们关注以下示例：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The expected output (which may vary on different browsers) is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出（可能因不同浏览器而异）如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the JavaScript virtual machine executes the synchronous code that prints
    `start` and `end`, then it executes all the jobs queued during the execution,
    printing `promise` and `timeout`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，JavaScript虚拟机执行打印`start`和`end`的同步代码，然后执行执行期间排队的所有任务，打印`promise`和`timeout`。
- en: Vue uses `Promise` if it is available on the user browser; otherwise, it tries
    to find the best scheduling function, with a fallback to `setTimeout` in case
    no other supported scheduling function has been found. Today, `Promise` is supported
    in almost every browser, mobile, and desktop.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户浏览器上有`Promise`，Vue将使用`Promise`；否则，它会尝试找到最佳调度函数，如果没有找到其他支持的调度函数，则回退到`setTimeout`。今天，`Promise`几乎在所有浏览器、移动设备和桌面设备上都得到了支持。
- en: Understanding the core concepts of Vuex
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vuex的核心概念
- en: 'It is now time to introduce the Vuex architecture, which consists of five core
    concepts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍Vuex架构了，它由五个核心概念组成：
- en: Single state tree
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一状态树
- en: Getters
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器
- en: Mutations
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更
- en: Actions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Modules
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Each concept will be discussed in detail, with some pieces of code that will
    help to make it clear. Once you have read the following pages, you will have a
    clear understanding of Vuex architecture.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个概念都将进行详细讨论，并提供一些代码片段以帮助使其清晰。一旦你阅读了以下页面，你将对Vuex架构有一个清晰的理解。
- en: Understanding the Vuex store
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vuex存储
- en: Vuex implements Flux stores using a single state tree. In this, it differs from
    Flux because in Flux there could be more than one store. You may think that a
    single store/state is not good for modularity. Later, we will see how to split
    the single state tree into modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex使用单一状态树实现Flux存储。在这方面，它与Flux不同，因为在Flux中可能有多个存储。你可能认为单个存储/状态对模块化来说不是很好。稍后我们将看到如何将单一状态树拆分为模块。
- en: 'Having only one store has some benefits:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个存储有一些好处：
- en: It is available in every component
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在所有组件中可用
- en: It is easier to debug since all the application state is there
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有应用程序状态都在那里，因此更容易调试
- en: You can write unobstructive plugins that watch the state and perform an action,
    such as persisting the state for later retrieval
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以编写无干扰的插件来监视状态并执行操作，例如持久化状态以供以后检索
- en: The single state tree contains all the application-level data—it represents
    the application domain model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单一状态树包含所有应用级别的数据——它代表了应用领域模型。
- en: Accessing the single state tree inside components
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件内部访问单一状态树
- en: 'Let''s now see how to use this single state tree inside a `Vue` component using
    an example. Say that we want to show the number of unread messages in a chat session.
    Somewhere in the application, this number gets updated and the `NumUnreadMessages`
    component shows this number. The following is an example of how the component
    could be coded:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过一个示例来看看如何在 `Vue` 组件中使用这个单一状态树。假设我们想在聊天会话中显示未读消息的数量。在应用的某个地方，这个数字会被更新，而
    `NumUnreadMessages` 组件会显示这个数字。以下是一个组件可能被编码的示例：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it is straightforward—you just need to use `this.$store.state`
    to access the application state. In order to have `this.$store` available inside
    Vue `components`, you need to add the store to the `Vue` application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这很简单——你只需要使用 `this.$store.state` 来访问应用状态。为了在 Vue `components` 中使用 `this.$store`，你需要将存储添加到
    `Vue` 应用中：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can find the code for this example in the Git repository of this book, inside
    the file `chapter-2/unread-messages/unread.html`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 Git 仓库中找到这个示例的代码，在文件 `chapter-2/unread-messages/unread.html` 中。
- en: The mapState helper
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`mapState` 辅助函数'
- en: Creating a computed property every time we want to access the state could be
    tedious and verbose, especially if a component needs more than one state property.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每次想要访问状态时创建一个计算属性可能会很繁琐且冗长，尤其是如果组件需要多个状态属性。
- en: 'Fortunately, Vuex provides a handy tool called `mapState`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vuex 提供了一个方便的工具，称为 `mapState`：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, the computed property `unreadCounter` is mapped to `this.$store.state.unreadCounter`.
    Since `mapState` is not well documented, I am going to explain all the ways that
    you can use it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，计算属性 `unreadCounter` 被映射到 `this.$store.state.unreadCounter`。由于 `mapState`
    没有很好地记录，我将解释你可以使用它的所有方法。
- en: 'You can use functions, as shown in the following code:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用函数，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`unreadCounter` is an arrow function, whereas `unreadCounterAlias` is a normal
    function. If you want to access the local state of the component, you must use
    a function and not an arrow function; otherwise, you cannot use the `this` keyword
    inside the arrow function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`unreadCounter` 是一个箭头函数，而 `unreadCounterAlias` 是一个普通函数。如果你想访问组件的局部状态，你必须使用一个函数而不是箭头函数；否则，你无法在箭头函数内部使用
    `this` 关键字。'
- en: 'You can use `strings`, as shown in the following code snippet:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `strings`，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, there is a much more concise way that can be used if the name of the
    `state` property and the name of the `computed` property are the same:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果 `state` 属性的名称和 `computed` 属性的名称相同，有一个更简洁的方法可以使用：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, you just need to pass an array of strings to `mapState`, where
    each string is the name of the `state` property you want to map.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你只需要将一个字符串数组传递给 `mapState`，其中每个字符串都是你想要映射的 `state` 属性的名称。
- en: 'You may wonder how you can mix local computed properties with the ones coming
    from `mapState.` Here is an example using the ECMAScript 6 object spread operator:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何将本地计算属性与来自 `mapState` 的属性混合。以下是一个使用 ECMAScript 6 对象扩展运算符的示例：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The use of the ES6 object spread operator `...` is not yet commonly known among
    programmers, especially when used with objects. See the following example if this
    operator sounds new to you:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 对象扩展运算符 `...` 的使用在程序员中还不是特别普遍，尤其是在与对象一起使用时。如果你对这个运算符感到陌生，请看以下示例：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Components' local state
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件的局部状态
- en: Even if there is a global single state tree, it doesn't mean that components
    cannot have a local state. What is in the global state is application-wide and
    should not be polluted with the component's private state. For example, text parts
    of a component are likely to be used only inside the component, and for this reason,
    they should not be put into the application state.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使存在全局单一状态树，这并不意味着组件不能有局部状态。全局状态是应用级别的，不应该被组件的私有状态所污染。例如，组件的文本部分可能只会在组件内部使用，因此它们不应该被放入应用状态中。
- en: Computing a derived state with getters
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 getters 计算派生状态
- en: Sometimes two or more components need a derived state based on the values inside
    the state. You could compute the derived state inside every component, but this
    means duplicating code, which is not acceptable. To avoid this, you could create
    an external function or utility class to compute the derived state, which is better
    than duplicating the code. However, Vuex provides getter functions so that we
    can write derived state code inside the application store, avoiding all these
    unnecessary steps.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时两个或多个组件需要基于状态内部的值派生状态。你可以在每个组件内部计算派生状态，但这意味着代码的重复，这是不可接受的。为了避免这种情况，你可以创建一个外部函数或实用类来计算派生状态，这比重复代码要好。然而，Vuex提供了getter函数，这样我们就可以在应用程序存储中编写派生状态代码，避免所有这些不必要的步骤。
- en: 'For example, say that the app state contains a list of messages, and, when
    a new message is added to that list, it gets marked as `unread`. We could then
    write a `getter` function that returns all the unread messages:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设应用状态包含一个消息列表，并且当新消息添加到该列表时，它会被标记为`未读`。然后我们可以编写一个`getter`函数，返回所有未读消息：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A `getter` function also receives all the `getters` as the second argument:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`getter`函数也接收所有`getters`作为第二个参数：'
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now update the unread messages example using `getter` functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`getter`函数更新未读消息的示例：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will find the code for the following example in the Git repository of this
    book, inside the file named `chapter-2/unread-messages/unread-with-getters.html`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的Git仓库中找到以下示例的代码，位于名为`chapter-2/unread-messages/unread-with-getters.html`的文件中。
- en: '`Getter` functions can also receive parameters, making them useful when executing
    queries regarding the state. To receive parameters, the `getter` functions must
    return a function that receives the parameters. Look at the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Getter`函数也可以接收参数，这使得它们在执行有关状态的查询时非常有用。为了接收参数，`getter`函数必须返回一个接收参数的函数。看看以下示例：'
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As for the state, there is a `mapState` helper. For getters, there is a `mapGetters`
    helper.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 至于状态，有一个`mapState`辅助函数。对于`getters`，有一个`mapGetters`辅助函数。
- en: The mapGetters helper
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`mapGetters`辅助函数'
- en: 'The `mapGetters` helper simply maps store `getters` to local computed properties.
    :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapGetters`辅助函数简单地将存储`getters`映射到本地计算属性：'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As for `mapState`, we can use an array to list all the `getters` properties
    we want to map to a corresponding computed property.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`mapState`，我们可以使用一个数组来列出所有我们想要映射到相应计算属性的`getters`属性。
- en: 'If the name of the computed property is different from the `getter` name, you
    can use an object instead of an array:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算属性的名称与`getter`名称不同，你可以使用一个对象而不是一个数组：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will find the code for this updated example of unread messages in the Git
    repository of this book, inside the file named `chapter-2/unread-messages/unread-with-getters-and-mapgetters.html`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的Git仓库中找到这个更新示例的代码，位于名为`chapter-2/unread-messages/unread-with-getters-and-mapgetters.html`的文件中。
- en: Changing the application state with mutations
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变更更改应用程序状态
- en: Until now, we have only seen how the app state can be retrieved. It is time
    to introduce mutations. Using mutations is the only way you can change the state.
    If you remember, Flux only allows actions to mutate the state. In Vuex, actions
    are split into actions and mutations. We will introduce actions later—here, we
    will focus on mutations and how we can change the state using Vuex.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了如何检索应用状态。现在是时候介绍变更了。使用变更是你唯一可以更改状态的方法。如果你还记得，Flux只允许动作变更状态。在Vuex中，动作被分为动作和变更。我们将在稍后介绍动作——在这里，我们将专注于变更以及我们如何使用Vuex来更改状态。
- en: 'In order to change the state, you need to commit a mutation. A mutation is
    similar to an event: you declare the mutation, which is a kind of event type,
    and link the mutation to a piece of code, which is like an event handler. From
    this point of view, Vuex can be seen as an evolution of the `EventBus` pattern,
    which was discussed in [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml),
    *Rethinking User Interfaces with Flux, Vue and Vuex*, as a possible solution to
    let MVC components communicate with each other.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改状态，你需要提交一个变更。变更类似于事件：你声明变更，这是一种事件类型，并将变更链接到一段代码，这就像事件处理器。从这个角度来看，Vuex可以被视为`EventBus`模式的演变，该模式在[第1章](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml)中讨论，*用Flux、Vue和Vuex重新思考用户界面*，作为MVC组件之间通信的可能解决方案。
- en: 'Mutations are declared in the `mutations` section of the `config` object provided
    to the `Vuex.Store(...)` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 变更（Mutations）是在提供给`Vuex.Store(...)`函数的`config`对象的`mutations`部分声明的：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Commiting a mutation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交一个变更
- en: 'You cannot call a mutation handler directly. Instead, you can commit the mutation
    using `store.commit(mutationName, payload)`. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接调用突变处理函数。相反，你可以使用`store.commit(mutationName, payload)`提交突变。例如：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will add a message to the `messages` array of the application state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用程序状态中的`messages`数组中添加一条消息。
- en: The `payload` parameter can be a primitive type or an object with all the properties
    that the mutation needs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`payload`参数可以是原始类型或具有突变所需所有属性的对象。'
- en: 'You can also use an object-style commit, as shown in the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用对象风格的提交，如下例所示：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since with a mutation you change the state that is reactive, it is recommended
    that you follow some best practices:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于突变会改变响应式状态，因此建议遵循以下最佳实践：
- en: Initialize all the properties of the state so that they represent the initial
    state of the application
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化状态的所有属性，以便它们代表应用程序的初始状态
- en: Ensure that when you modify or add a new property to the state, `Vue` will detect
    the modification, as discussed in the reactivity section of this chapter
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保当你修改或添加新属性到状态时，`Vue`将检测到修改，如本章反应性部分所述。
- en: 'The following is a complete example where a user can add a message and see
    the message list:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整的示例，其中用户可以添加消息并查看消息列表：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Enumerating mutation types using constant strings
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常量字符串枚举突变类型
- en: 'Every time you want to commit a mutation, you need to write the type of mutation
    you want to perform. Scattering strings among the code is considered bad practice
    and has the following drawbacks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想提交突变时，都需要编写你想要执行突变类型的类型。在代码中分散字符串被认为是不良实践，并具有以下缺点：
- en: 'It is error-prone: typos or wrong casing could occur when typing the mutation
    type'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是有风险的：在输入突变类型时可能会出现拼写错误或错误的字母大小写。
- en: It is hard to rename a type, since you have to search for all the occurrences
    of that string in the code
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名类型很困难，因为你必须搜索代码中该字符串的所有出现
- en: It is not clear which module that mutation comes from
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不清楚突变来自哪个模块
- en: For these reasons, it is better to use constant strings to define all the mutation
    types. Using uppercase will prevent wrong casing, and using constants variables
    will allow most editors to highlight occurrences. In addition, editors usually
    provide a way to rename variables, such as string constants, making it easy to
    rename a mutation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，最好使用常量字符串来定义所有突变类型。使用大写字母可以防止错误的字母大小写，而使用常量变量可以让大多数编辑器突出显示出现。此外，编辑器通常提供一种重命名变量的方式，例如字符串常量，这使得重命名突变变得容易。
- en: Mutation types should be defined inside a file with all the possible mutations
    of the application, or of the module if the application is split into modules.
    In this way, it is easier to understand all the changes the application state
    can be subjected to. In fact, if you remember, Vuex promises that the state will
    be changed in a predictable fashion. Say that a new programmer participates in
    your project. You could sit next to them and start explaining what the application
    does. You will soon find out that they can understand what happens when a user
    performs an action without your help. In fact, they just need to follow the flow
    from the action fired inside a `Vue` component to the corresponding state mutation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 突变类型应该在包含应用程序所有可能突变（或如果应用程序分为模块，则为模块的所有可能突变）的文件中定义。这样，更容易理解应用程序状态可能受到的所有变化。实际上，如果你记得，Vuex承诺状态将以可预测的方式改变。假设一个新程序员参与你的项目。你可以坐在他们旁边，开始解释应用程序的功能。你很快会发现，他们可以在没有你的帮助下理解用户执行操作时发生的事情。实际上，他们只需要跟随从在`Vue`组件内部触发的动作到相应的状态突变的流程。
- en: 'The following is an example illustrating how to use constant mutation types:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个说明如何使用常量突变类型的示例：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Mutations must be synchronous
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突变必须是同步的
- en: One important rule when using Vuex is that *mutation handler functions must
    be synchronous*. Unfortunately, this cannot be enforced through JavaScript language,
    so Vuex cannot ensure that you follow this rule. This means that this rule is
    a best practice that must be followed when coding your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vuex时的重要规则是*突变处理函数必须是同步的*。不幸的是，这不能通过JavaScript语言强制执行，因此Vuex不能确保你遵循此规则。这意味着这是一项最佳实践，在编写应用程序代码时必须遵循。
- en: 'The following is an example that shows this rule being violated:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个违反此规则的示例：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, first `state.currentBook` is set with some partial data from
    the book, then, when the server provides the requested book details, the `state.currentBook`
    state gets updated with all the book details.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先使用书籍的一些部分数据设置`state.currentBook`，然后，当服务器提供请求的书籍详细信息时，`state.currentBook`状态会使用所有书籍的详细信息进行更新。
- en: Showing book data as soon as possible is a good idea. We don't want the user
    to see a blank page until the server provides all the requested information. But
    asynchronicity must be dealt with somewhere else—more precisely, inside an `action`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽快显示书籍数据是一个好主意。我们不希望用户在服务器提供所有请求的信息之前看到空白页面。但是异步性必须在其他地方处理——更确切地说，在`action`内部。
- en: But what could happen in the preceding example? In the best case scenario, the
    book's partial data is displayed and a few moments later, all the book details
    are shown. But `api.getBookDetailsById(...)` could take longer than expected,
    or it can even fail. In these last cases, the result will be an incoherent application
    state. What if `state.currentBook` gets modified by the user before the server
    provides the book details?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但在前面的例子中可能会发生什么？在最佳情况下，书籍的部分数据会被显示，然后几秒钟后，所有书籍的详细信息都会显示出来。但是`api.getBookDetailsById(...)`可能需要比预期更长的时间，甚至可能失败。在这些最后的情况下，结果将是一个不一致的应用程序状态。如果`state.currentBook`在服务器提供书籍详细信息之前被用户修改了怎么办？
- en: To avoid these problems, when a mutation is committed, the application state
    must move from a well-defined state to another well-defined state in a synchronous
    manner.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，当提交突变时，应用程序状态必须以同步方式从一个定义良好的状态移动到另一个定义良好的状态。
- en: The mapMutations helper
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mapMutations辅助函数
- en: As for the state and getters, there is a helper to save us some keystrokes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于状态和获取器，有一个辅助函数可以节省我们一些按键。
- en: 'The example, where a user can add a message, can be refactored using the `mapMutations`
    helper, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`mapMutations`辅助函数重构用户可以添加消息的示例，如下所示：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, `mapMutations(...)` creates an `addNewMessage` method that calls
    `this.$store.commit(ADD_NEW_MESSAGE, payload)` when executed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`mapMutations(...)`创建了一个`addNewMessage`方法，当执行时，它会调用`this.$store.commit(ADD_NEW_MESSAGE,
    payload)`。
- en: You will find the code for the preceding example with and without `mapMutations`
    inside the `chapter-2/add-message` folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`chapter-2/add-message`文件夹中找到前面例子的代码，包括和不包括`mapMutations`。
- en: Committing mutations within actions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在动作中提交突变
- en: As introduced earlier, Vuex splits Flux actions into mutations and actions.
    Mutations must be synchronous, so actions are where asynchronous code can be written.
    The idea is that mutations are well-defined state modifications and actions commit
    mutations to change the application state. For example, an action could request
    some data from the server, and when the server responds, commit a mutation using
    the data it just obtained.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Vuex将Flux动作分为突变和动作。突变必须是同步的，因此动作是编写异步代码的地方。想法是突变是定义良好的状态修改，动作提交突变以更改应用程序状态。例如，一个动作可以请求从服务器获取一些数据，当服务器响应时，使用它刚刚获得的数据提交一个突变。
- en: In short, actions can change the state by committing mutations and can perform
    asynchronous operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，动作可以通过提交突变来改变状态，并且可以执行异步操作。
- en: Action declaration
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作声明
- en: 'Let''s see how actions are declared inside a `Vuex` store:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在`Vuex`存储中声明动作：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In a similar way as that used for mutations, to declare an action, you write
    the action method inside the `actions` section of the `config` object provided
    to the `Vuex` store.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于突变的类似方式，要声明一个动作，你需要在提供给`Vuex`存储的`config`对象的`actions`部分中编写动作方法。
- en: The action receives a `context` object and the action payload. The `context`
    object contains a `commit(...)` method and the `state` property, which is the
    application state.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 动作接收一个`context`对象和动作有效负载。`context`对象包含一个`commit(...)`方法和`state`属性，它是应用程序状态。
- en: In the preceding example, the `addMessage(...)` action sends the message text
    to a hypothetical server and, after the server response, it commits the corresponding
    mutation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`addMessage(...)`动作将消息文本发送到一个假设的服务器，并在服务器响应后，提交相应的突变。
- en: Dispatching an action
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发一个动作
- en: 'If you remember, Flux has a single dispatcher that dispatches actions to every
    store. It is the same in Vuex, except that there is only a single store, which
    is also a dispatcher. This means that actions can be dispatched using the store,
    as shown in the code below:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，Flux有一个单一的分发器，将动作分发到每个存储。Vuex也是这样，只是有一个单一的存储，它也是一个分发器。这意味着可以使用存储来分发动作，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following code, I updated the `add message` example to use the `addMessage`
    action instead of directly using the `addNewMessage` mutation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我将 `添加消息` 示例更新为使用 `addMessage` 动作而不是直接使用 `addNewMessage` 变异：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You are probably now thinking that there must be some helper to dispatch actions...
    in fact, there is!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能正在想，肯定有一些辅助函数可以派发动作...事实上，确实有！
- en: The mapActions helper
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mapActions 辅助函数
- en: 'Similar to the other helpers, the `mapActions` helper can be used inside the
    `methods` section of a `Vue` component. The syntax is the same as that of the
    other helpers:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他辅助函数类似，`mapActions` 辅助函数可以在 `Vue` 组件的 `methods` 部分中使用。语法与其他辅助函数相同：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using modules for better scalability
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块实现更好的可扩展性
- en: Vuex's single state tree can be divided into modules. This is useful when the
    application grows larger and you want to split the app into groups of features.
    Doing so also lets you only load core features when the page loads, and allows
    you to load the other functionalities later. This way, you can reduce loading
    times drastically, especially if the connection is slow or the application is
    run inside a low-end mobile phone. It takes time for the JavaScript virtual machine
    to parse all the JavaScript code, thus providing only a single huge file with
    all the application code will take seconds to be parsed, giving a mobile user
    the impression that the application is slow and heavy.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 的单一状态树可以被分割成模块。当应用程序变得更大，并且您想要将应用程序分割成功能组时，这很有用。这样做还可以让您在页面加载时只加载核心功能，并允许您稍后加载其他功能。这样，您可以大大减少加载时间，尤其是在连接速度慢或应用程序在低端手机上运行时。JavaScript
    虚拟机解析所有 JavaScript 代码需要时间，因此提供一个包含所有应用程序代码的单个大型文件将需要几秒钟来解析，给移动用户留下应用程序运行缓慢且沉重的印象。
- en: A good tool to use in combination with Vue/Vuex is webpack, which lets you split
    your application into bundles. A webpack bundle can contain one or more Vuex modules,
    and a module can be loaded after another module. You can find more information
    about webpack at [https://webpack.js.org/](https://webpack.js.org/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue/Vuex 中结合使用的一个好工具是 webpack，它允许您将应用程序分割成包。一个 webpack 包可以包含一个或多个 Vuex 模块，一个模块可以在另一个模块之后加载。您可以在
    [https://webpack.js.org/](https://webpack.js.org/) 找到更多关于 webpack 的信息。
- en: 'The application state tree can be split into modules, and each module into
    submodules. Let''s see how this can be coded:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序状态树可以被分割成模块，每个模块又可以分割成子模块。让我们看看如何编码实现这一点：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the object passed to `new Vuex.store({})` is just the root module
    of your app, and inside the root module, or any other module, you can declare
    other modules.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，传递给 `new Vuex.store({})` 的对象只是您应用的根模块，在根模块或任何其他模块内部，您可以声明其他模块。
- en: Module local state
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块本地状态
- en: The state object passed to `mutations`, `actions`, and `getters` is the local
    module state. In this way, a submodule doesn't need to know it is inside another
    module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `mutations`、`actions` 和 `getters` 的状态对象是本地模块状态。这样，子模块不需要知道它位于另一个模块内部。
- en: 'But what if a submodule wants to access a parent module? The `rootState` is
    provided inside `actions` and `getters` so that you can navigate down to the desired
    module from the `rootState`. Let''s see how:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果一个子模块想要访问父模块呢？`rootState` 是在 `actions` 和 `getters` 中提供的，这样你就可以从 `rootState`
    导航到所需的模块。让我们看看怎么做：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is important to note that inside an action, the `rootState` is a property
    of the parameter `context` that is passed to the action, whereas inside a `getter`,
    the `rootState` is passed as the third parameter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在动作内部，`rootState` 是传递给动作的参数 `context` 的一个属性，而在获取器内部，`rootState` 作为第三个参数传递。
- en: Module with namespace
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有命名空间的模块
- en: 'There may be collisions between the names among different modules. To avoid
    this, and to create `reusable` modules, you can set the module''s `namespaced`
    property to `true`. The following is an example of a `namespaced` module:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不同模块之间可能存在名称冲突。为了避免这种情况，并创建可重用的模块，你可以将模块的 `namespaced` 属性设置为 `true`。以下是一个 `namespaced`
    模块的示例：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code inside a module doesn''t change when the `namespaced` property is
    set to `true`. What changes is the code that wants to use another `namespace`
    module. Look at the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `namespaced` 属性设置为 `true` 时，模块内部的代码不会改变。改变的是想要使用另一个 `namespace` 模块的代码。看看以下示例：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To commit a mutation or dispatch an action of another module, you need to add
    `{ root: true }` as the third parameter. There is also a `rootGetters` parameter
    that is provided to the `actions` handlers or `getters` functions.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '要提交另一个模块的突变或分发动作，你需要将 `{ root: true }` 作为第三个参数添加。还有一个 `rootGetters` 参数，它被提供给
    `actions` 处理器或 `getters` 函数。'
- en: 'Finally, when using Vuex helpers, you need to specify the namespace as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用 Vuex 辅助函数时，你需要按照以下方式指定命名空间：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or you can create namespaced helpers using the function `createNamespacedHelpers(nameSpace)`
    which returns all the helpers inside an object. These helpers are bound to the
    namespace you provided as the first argument. The following is an example of how
    to use `createNamespacedHelpers`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `createNamespacedHelpers(nameSpace)` 函数创建命名空间辅助函数，该函数返回一个对象中的所有辅助函数。这些辅助函数绑定为你提供的第一个参数的命名空间。以下是如何使用
    `createNamespacedHelpers` 的示例：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At the end of this chapter, you will find an example of two modules with the
    `namespace` parameter set to `true`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，你将找到一个将 `namespace` 参数设置为 `true` 的两个模块的示例。
- en: Dynamic module registration
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态模块注册
- en: 'It is possible to register a module after a Vuex store has been created using
    the `store.registerModule(...)` method. The following is an example of how a module
    can be registered:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `store.registerModule(...)` 方法在 Vuex store 创建后注册模块是可能的。以下是如何注册模块的示例：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is particularly useful when modules are loaded asynchronously:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这在模块异步加载时特别有用。
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Following is `loaded-later-moudle.js` file code, which gets loaded inside `index.js`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `loaded-later-moudle.js` 文件代码，该文件在 `index.js` 中加载：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding example, the root module defines a `currentView` property that
    points to the `initial` component. With the dynamic import syntax, we import the
    `loaded-later-moudle.js` file, and after it has been loaded we execute the module
    code that replaces the `currentView` value, causing the `later` component to be
    displayed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，根模块定义了一个 `currentView` 属性，该属性指向 `initial` 组件。使用动态导入语法，我们导入 `loaded-later-moudle.js`
    文件，并在它加载后执行替换 `currentView` 值的模块代码，导致显示 `later` 组件。
- en: The preceding example works inside a browser that supports dynamic import syntax,
    or you can use webpack to build it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在支持动态导入语法的浏览器中有效，或者你可以使用 webpack 来构建它。
- en: You can also unregister a dynamic loaded module by using `store.unregisterModule(moduleName)`
    . Static loaded modules cannot be unregistered.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `store.unregisterModule(moduleName)` 方法注销动态加载的模块。静态加载的模块不能被注销。
- en: Module reuse
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块重用
- en: 'As with Vue `components`, in order to reuse a module, the state declaration
    needs to be a function returning the state instead of a plain object. Otherwise,
    the state object is shared among all the module users. There are two cases where
    this may happen:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Vue `组件` 类似，为了重用模块，状态声明需要是一个返回状态的函数，而不是一个普通对象。否则，状态对象将在所有模块用户之间共享。这种情况可能发生在以下两种情况中：
- en: Where multiple stores are using the same module
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个 store 使用同一模块的情况下
- en: Where the same module has been registered more than once in the same store
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一 store 中同一模块被注册超过一次
- en: The first case is unlikely to happen because Vuex uses a single store. Besides,
    you can always create more than one store, even though you can register only one
    store per Vue instance.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况不太可能发生，因为 Vuex 使用单个 store。此外，尽管每个 Vue 实例只能注册一个 store，但你总是可以创建多个 store。
- en: The second case is likely to happen if the module is general purpose and depends
    on some parameters. In the same way that classes can have constructor parameters,
    a module could be created using a factory method with parameters. For example,
    say that you have two similar RESTful APIs and you created a generic API module
    so that the module can be used for both the APIs. In this case, you will use two
    instances of the same module, one for each API.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块是通用模块并且依赖于某些参数，第二种情况很可能会发生。与类可以有构造函数参数一样，可以使用带有参数的工厂方法创建模块。例如，假设你有两个相似的
    RESTful API，并且创建了一个通用 API 模块，以便该模块可以用于这两个 API。在这种情况下，你将使用该模块的两个实例，每个 API 一个实例。
- en: 'The following is an example of how to create a `reusable` module:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建一个 `可重用` 模块的示例：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Enabling strict mode while developing
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发时启用严格模式
- en: 'When `Vuex` is in strict mode, it will throw an error if the single state tree
    is mutated outside mutation handlers. This is useful when developing to prevent
    accidental modifications to the state. To enable strict mode, you just need to
    add `strict: true` to the store configuration object:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '当 `Vuex` 处于严格模式时，如果单状态树在变异处理器外部被变异，它将抛出错误。这在开发时很有用，可以防止意外修改状态。要启用严格模式，只需将 `strict:
    true` 添加到存储配置对象中：'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Strict mode should not be used in production*. Strict mode runs a synchronous
    deep watcher on the state tree for detecting inappropriate mutations, and this
    can slow down the application. To avoid changing strict to `false` each time you
    want to create a production bundle, you should use a build tool that makes the
    strict value `false` when creating the production bundle. For example, you could
    use the following snippet in conjunction with webpack:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*在生产环境中不应使用严格模式*。严格模式在状态树上运行同步的深度观察者以检测不适当的变异，这可能会减慢应用程序的速度。为了避免每次创建生产包时都更改严格模式为
    `false`，您应该使用在创建生产包时将严格值设置为 `false` 的构建工具。例如，您可以使用以下片段与 webpack 一起使用：'
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In [Chapter 3](bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml), *Implementing Notes
    App Using* *Vuex State Management,* you will be shown how to use webpack to enable/disable
    strict mode.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml)，*使用 Vuex 状态管理实现笔记应用*中，您将了解到如何使用
    webpack 启用/禁用严格模式。
- en: Form handling restrictions when using Vuex
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vuex 时的表单处理限制
- en: Using Vue's `v-model` feature with the Vuex state results in a direct modification
    of the state, which is forbidden.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue 的 `v-model` 功能与 Vuex 状态直接修改状态，这是被禁止的。
- en: 'Take a look at the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, `$store.state` is mutated directly by `v-model`, and if strict
    mode is enabled, it will result in an error being thrown.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`$store.state` 通过 `v-model` 直接变异，如果启用了严格模式，将导致抛出错误。
- en: 'There is more than one way to solve this problem, and I will show you the one
    that, in my opinion, is better: You can use a mutable computed property that accesses
    the `state` property when read and commits a mutation when set:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题不止一种方法，我将向您展示我认为更好的方法：您可以使用一个可变的计算属性，当读取时访问 `state` 属性，并在设置时提交一个变异：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using a mutable computed property also allows you to add some validation before
    committing the corresponding mutation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可变的计算属性还允许您在提交相应的变异之前添加一些验证。
- en: 'The following is a possible code for the mutation that gets committed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个提交变异的可能代码：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A simple counter example
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单计数器示例
- en: 'The following is a very simple example of a counter that summarizes the core
    concepts of Vuex in a self-contained HTML file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个非常简单的计数器示例，它在一个自包含的 HTML 文件中总结了 Vuex 的核心概念：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding example shows two counters. The first one just increments or
    decrements the current value. The second one, FizzBuzz, shows *Fizz* if the counter
    is divisible by `3`, *Buzz* if it is divisible by `5`, and FizzBuzz when it is
    both divisible by `3` and `5`, as shown in the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显示了两个计数器。第一个只是增加或减少当前值。第二个，FizzBuzz，当计数器能被 `3` 整除时显示 *Fizz*，当能被 `5` 整除时显示
    *Buzz*，当能同时被 `3` 和 `5` 整除时显示 FizzBuzz，如下面的截图所示：
- en: '![](img/962ea5a9-c923-46f3-8733-630cb1944b91.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/962ea5a9-c923-46f3-8733-630cb1944b91.png)'
- en: 'Figure 2.2: FizzBuzz counter'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：FizzBuzz 计数器
- en: 'In this example, I created two modules and two components that use these modules:
    one for the `sequential` counter and the other for the `fizzBuzz` counter.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了两个模块和两个组件，这些组件使用这些模块：一个用于 `sequential` 计数器，另一个用于 `fizzBuzz` 计数器。
- en: After that, I created a new instance of `Vue` and added the two modules and
    components to it. The aim of this example is to show you how to use `namespaced`
    modules, as well as to serve as a full but simple example of Vue and Vuex combined
    together.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我创建了一个新的 `Vue` 实例，并将两个模块和组件添加到其中。这个示例的目的是向您展示如何使用 `namespaced` 模块，同时也作为一个完整但简单的
    Vue 和 Vuex 结合的示例。
- en: You can find the example source code inside the GitHub repository of this book
    in the `chapter-2/fizzbuzz-counter` folder .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中的 `chapter-2/fizzbuzz-counter` 文件夹内找到示例源代码。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we studied the Vuex framework. We went through its core concepts
    and saw how Vuex can be integrated into a Vue application. At the end, a simple
    counter example helped us to get the whole picture.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Vuex 框架。我们了解了其核心概念，并看到了 Vuex 如何集成到 Vue 应用程序中。最后，一个简单的计数器示例帮助我们全面了解。
- en: It is now time to move from a simple example to real application development
    using Vuex. That is the topic of [Chapter 3](bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml),
    *Implementing the Notes App Using Vuex State Management*, developing an application
    that takes notes in a similar way to Google Keep or Evernote.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候从简单的示例过渡到使用 Vuex 进行实际的应用程序开发。这就是[第 3 章](bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml)的主题，*使用
    Vuex 状态管理实现笔记应用*，开发一个类似于 Google Keep 或 Evernote 的记笔记应用程序。
