<html><head></head><body>
<div id="_idContainer066">
<h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor264"/><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.2.1">Design for Tests: Best Practices</span></h1>
<p><span class="koboSpan" id="kobo.3.1">One of the best practices in a software project, be it a frontend or backend project, is testing. </span><span class="koboSpan" id="kobo.3.2">After all, if you and your team don’t rigorously test your system, the people who will inevitably test the system and find possible bugs are the users, and we don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">want that.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">For this reason, it is no wonder that the Angular team has, since the first versions of the framework, been concerned with creating and integrating automated </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">testing tools.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We can notice this with the fact that, by default, the Angular CLI always generates, together with the component, its test files as if saying, “</span><em class="italic"><span class="koboSpan" id="kobo.8.1">Hey, buddy, don’t forget the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.9.1">unit test!</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">”</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will explore this topic by covering </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">to test</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Service tests</span></span></li>
<li><a id="_idTextAnchor267"/><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Understanding </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">TestBed</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Component testing</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">E2E tests </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with Cypress</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">At the end of the chapter, you will be able to create tests for your components and service, improving the quality of your delivery and </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">your team.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.32.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.33.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">During the study of this chapter, remember to run the backend of the application found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.40.1"> folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1"> command.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.44.1">What to test</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Within a software project, we can do several types of tests to ensure the quality of the product. </span><span class="koboSpan" id="kobo.45.2">In this discipline, it is very common to categorize tests using </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">a pyramid.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.47.1"><img alt="Figure 10.1 – Test pyramid" src="image/B19562_10_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.48.1">Figure 10.1 – Test pyramid</span></p>
<p><span class="koboSpan" id="kobo.49.1">At the base of the </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.50.1">pyramid, we have unit tests</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.51.1">, whose objective is to verify the quality of the smallest elements within a software project, such as functions or methods of a class. </span><span class="koboSpan" id="kobo.51.2">Due to their narrow scope and atomic nature, they are quickly executed by tools and should ideally make up the majority of an </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">application’s tests.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">In the middle layer, we have integration tests, which</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.54.1"> are focused on verifying how the project components interact with each other, being able, for example, to test an API through an HTTP request. </span><span class="koboSpan" id="kobo.54.2">Because these tests use more elements and need certain environmental requirements, they are less performant and have a higher execution cost, which is why we see them in smaller quantities compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">At the top of the pyramid, we</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.57.1"> have </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">end-to-end tests</span></strong><span class="koboSpan" id="kobo.59.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.60.1">E2E tests</span></strong><span class="koboSpan" id="kobo.61.1">), which validate the system from the user’s point of view, emulating their actions and behaviors. </span><span class="koboSpan" id="kobo.61.2">These tests require an almost complete environment, including a database and servers. </span><span class="koboSpan" id="kobo.61.3">In addition, they are slower and therefore there are fewer of them compared to the </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">previous ones.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Finally, we have manual</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.64.1"> and exploratory tests</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.65.1">, which are tests performed by quality analysts. </span><span class="koboSpan" id="kobo.65.2">Ideally, these tests will serve as a basis for the creation of E2E tests, mainly on new features. </span><span class="koboSpan" id="kobo.65.3">As they are run by humans, they are the most expensive, but they are the best for discovering new bugs in </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">new features.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">It is important to highlight that no test is better or more important than another. </span><span class="koboSpan" id="kobo.67.2">Here, we have the classification by volume of test executions in a period of time. </span><span class="koboSpan" id="kobo.67.3">You and your team must identify which tests to prioritize based on the capacity and resources available for your project. </span><span class="koboSpan" id="kobo.67.4">These types of tests can be applied to any type of software project, but you must be wondering how we fit this concept into an </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">Angular project.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">The concept of manual testing can be applied without tools because what we need is a quality analyst and an application with a complete environment, that is, the backend services responding to </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">E2E tests</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.72.1"> are performed by specific tools that simulate user behavior. </span><span class="koboSpan" id="kobo.72.2">Up to version 14, Angular already had a built-in tool called </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">Protractor</span></strong><span class="koboSpan" id="kobo.74.1">, but</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.75.1"> the Angular team no longer recommends it because there are more modern, faster alternatives. </span><span class="koboSpan" id="kobo.75.2">In this chapter, we are going to use </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Cypress</span></strong><span class="koboSpan" id="kobo.77.1"> for </span><a id="_idIndexMarker435"/><span class="No-Break"><span class="koboSpan" id="kobo.78.1">this purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Finally, unit tests</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.80.1"> are performed on the methods of our services and components, verifying </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">their behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">In the Angular toolbox, we have</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.83.1"> two tools for creating and running these tests: Jasmine and Karma. </span><span class="koboSpan" id="kobo.83.2">These </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.84.1">tools are installed by default when we start a </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">new project.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Jasmine</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.87.1"> is a testing framework that has several checking functions, in addition to providing the ability to change the functionality of a method or class at runtime with an element</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.88.1"> called a </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">spy</span></strong><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">For the execution of unit tests, the Karma tool is used, which has the characteristic of running tests in a browser, giving the team the ability to analyze the behavior of the application in different types of environments. </span><span class="koboSpan" id="kobo.90.3">Although rare nowadays, we may have some bugs depending on the browser it </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">runs on.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">To use these two tools, we</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.93.1"> don’t need any configuration of our project; we just need to </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.94.1">execute the following command in the command line of our </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">operating system:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.96.1">
ng test</span></pre> <p><span class="koboSpan" id="kobo.97.1">Once we execute the preceding command, we get a compilation error. </span><span class="koboSpan" id="kobo.97.2">This happens because, until then, Angular only compiled the files of our components and ignored the test files because they will not be deployed to users in the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">final version.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Running the test, we notice that we have an error in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">diary.resolver.spec.ts</span></strong><span class="koboSpan" id="kobo.101.1"> test file, so let’s make </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">a correction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
describe('diaryResolver', () =&gt; {
  const executeResolver: ResolveFn&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.104.1">ExerciseSetList</span></strong><span class="koboSpan" id="kobo.105.1">&gt; = (...resolverParameters) =&gt;
     TestBed.runInInjectionContext(() =&gt; diaryResolver(...resolverParameters));
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({});
  });
  it('should be created', () =&gt; {
    expect(executeResolver).toBeTruthy();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.106.1">The test generated by the Angular CLI contains all of Jasmine’s boilerplate. </span><span class="koboSpan" id="kobo.106.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">describe</span></strong><span class="koboSpan" id="kobo.108.1"> function, we define our test case, which is a test group that we </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">will create.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">This function has, in the first parameter, a string that represents the name of the test case and will even identify it </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">in reports.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">In the second</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.113.1"> parameter, we have the function where we will have the preparation and the</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.114.1"> tests. </span><span class="koboSpan" id="kobo.114.2">Here, we made a correction because the resolver we want to test returns an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">ExerciseSetList</span></strong><span class="koboSpan" id="kobo.116.1"> and not a Boolean as it </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">was before.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">On the next line, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">TestBed</span></strong><span class="koboSpan" id="kobo.120.1"> class, which is the most fundamental element of </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">Angular tests.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">This framework class has the function of preparing the Angular execution environment for the tests to run. </span><span class="koboSpan" id="kobo.122.2">We will see in the following sections its use in </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">different situations.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">beforeEach</span></strong><span class="koboSpan" id="kobo.126.1"> function has the objective of performing some common action before executing </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the tests.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">it</span></strong><span class="koboSpan" id="kobo.130.1"> function is where we will create the tests. </span><span class="koboSpan" id="kobo.130.2">Inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">describe</span></strong><span class="koboSpan" id="kobo.132.1"> function, we can have numerous functions of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">it type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">If we run Karma again, the browser will open, and we can follow the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">the tests:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.137.1"><img alt="Figure 10.2 – Execution of tests by Karma" src="image/B19562_10_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.138.1">Figure 10.2 – Execution of tests by Karma</span></p>
<p><span class="koboSpan" id="kobo.139.1">As this project</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.140.1"> already had the tests when we created the elements of our </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.141.1">application, we have some broken tests that we will correct in the next sections, but the important thing now is for us to understand how to run the unit tests of </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">In the next section, we’ll learn how to create tests for our </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">p</span><a id="_idTextAnchor270"/><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.145.1">roject’s services.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.146.1">Service tests</span></h1>
<p><span class="koboSpan" id="kobo.147.1">As we</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.148.1"> studied in detail in </span><a href="B19562_05.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.149.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.150.1">, </span><em class="italic"><span class="koboSpan" id="kobo.151.1">Angular Services and the Singleton Pattern</span></em><span class="koboSpan" id="kobo.152.1">, the service that works as a repository of business rules in an Angular application. </span><span class="koboSpan" id="kobo.152.2">Consequently, it is crucial for us to develop unit tests for these services. </span><span class="koboSpan" id="kobo.152.3">In this section, we will focus on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.154.1"> service to illustrate the Angular unit testing techniques in our project. </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Let’s begin.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">exercise-sets.service.spec.ts</span></strong><span class="koboSpan" id="kobo.158.1"> test file, let’s start by fixing the tests automatically created by the Angular CLI that are not </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">running correctly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.160.1">
import { TestBed } from '@angular/core/testing';
import { ExerciseSetsService } from './exercise-sets.service';
import { HttpClientTestingModule } from '@angular/common/http/testing';
  fdescribe('ExerciseSetsService', () =&gt; {
    let service: ExerciseSetsService;
    let httpMock: HttpTestingController;
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({ imports: [HttpClientTestingModule] });
    service = TestBed.inject(ExerciseSetsService);
    httpMock = TestBed.inject(HttpTestingController);
  });
  it('should be created', () =&gt; {
    expect(service).toBeTruthy();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.161.1">As we want to</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.162.1"> work on service testing, at this time, we replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">describe</span></strong><span class="koboSpan" id="kobo.164.1"> function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">fdescribe</span></strong><span class="koboSpan" id="kobo.166.1"> function, so the Karma test runner will only execute this test case. </span><span class="koboSpan" id="kobo.166.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">fdescribe</span></strong><span class="koboSpan" id="kobo.168.1"> feature is also available for isolating a specific test, in this case replacing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">it</span></strong><span class="koboSpan" id="kobo.170.1"> function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">fit</span></strong><span class="koboSpan" id="kobo.172.1"> function. </span><span class="koboSpan" id="kobo.172.2">To fix the error identified by the Angular compiler, we import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">'HttpClientTestingModule'</span></strong><span class="koboSpan" id="kobo.174.1"> module in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">TestBed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">We need to understand how Karma, Jasmine, and Angular work together to run tests. </span><span class="koboSpan" id="kobo.177.2">Before each test case is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">it</span></strong><span class="koboSpan" id="kobo.179.1"> functions, Angular sets up an isolated environment for the tests. </span><span class="koboSpan" id="kobo.179.2">This environment has virtually no module configuration at first, as your real application has, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">TestBed</span></strong><span class="koboSpan" id="kobo.181.1"> component comes into play, where we configure the minimum necessary dependencies for your test </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">to run.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">In this service, as it depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">HttpClient</span></strong><span class="koboSpan" id="kobo.185.1"> to perform HTTP requests, we need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">HttpClientModule</span></strong><span class="koboSpan" id="kobo.187.1"> module to have this dependency. </span><span class="koboSpan" id="kobo.187.2">You might be wondering, “But here you are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">Is this correct?” </span><span class="koboSpan" id="kobo.189.3">As we will see in the following code, not only will we want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">HttpClient</span></strong><span class="koboSpan" id="kobo.191.1"> but we will also need to simulate HTTP calls, and to make this task easier, the Angular team has prepared a specific </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.192.1">module for this type </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">of testing.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">With our basic “should be created” test case in place, let’s test the methods of </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
it('should use the method getInitialList to return the list of entries', fakeAsync(() =&gt; {
  const fakeBody: ExerciseSetListAPI = {
    hasNext: false,
    items: [
      {
        id: '1',
        date: new Date(),
        exercise: 'Deadlift',
        reps: 15,
        sets: 4,
      },
    ],
  };
  service.getInitialList().subscribe((response) =&gt; {
    expect(response).toEqual(fakeBody.items);
  });
  const request = httpMock.expectOne((req) =&gt; {
    return req.method === 'GET';
  });
  request.flush(fakeBody);
  tick();
}));</span></pre> <p><span class="koboSpan" id="kobo.197.1">As you can see from the </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.198.1">preceding code, this service is designed to handle requests related to gym diary entries. </span><span class="koboSpan" id="kobo.198.2">In the initial method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">getInitialList</span></strong><span class="koboSpan" id="kobo.200.1">, our objective is to verify whether the service accurately initiates an HTTP request to the backend using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">GET</span></strong><span class="koboSpan" id="kobo.202.1"> method. </span><span class="koboSpan" id="kobo.202.2">By creating a new case with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">it</span></strong><span class="koboSpan" id="kobo.204.1"> function in the first parameter, we place a description of the test case that will be important for viewing during test execution. </span><span class="koboSpan" id="kobo.204.2">The test function, unlike the “should be created” test case, is contained within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">fakeAsync</span></strong><span class="koboSpan" id="kobo.206.1"> function created by the Angular team to facilitate the testing of asynchronous methods, such as an HTTP request. </span><span class="koboSpan" id="kobo.206.2">Inside the function, we begin to assemble our test. </span><span class="koboSpan" id="kobo.206.3">Here, we need to define what the structure of a unit test </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">looks like.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">A unit test consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">three parts:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.210.1">The test setup, where we prepare all the elements for the tests to </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">take place</span></span></li>
<li><span class="koboSpan" id="kobo.212.1">The execution of the method to </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">be executed</span></span></li>
<li><span class="koboSpan" id="kobo.214.1">The test assertion, where we compare the execution result with the </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">expected return</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.216.1">In this test case, part of the setup was done in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">beforeEach</span></strong><span class="koboSpan" id="kobo.218.1"> function, but note that, instead, we must put the setup common to all test cases that will be executed to avoid slowdowns in the test cases. </span><span class="koboSpan" id="kobo.218.2">In the test in question, we defined a fake return from our server, since the unit tests must be executed independently of the backend service. </span><span class="koboSpan" id="kobo.218.3">In the execution phase, we call the service with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">getInitialList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">We call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">subscribe</span></strong><span class="koboSpan" id="kobo.223.1"> method of the observable that the service returns, and inside it, we make the assertion that we expect the return to be equal to the item element of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">fakeBody</span></strong><span class="koboSpan" id="kobo.225.1"> object. </span><span class="koboSpan" id="kobo.225.2">Here, the assertion phase can be tricky because, to check the return of this observable, we need to simulate the backend processing of </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Enter the Angular </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">HttpTestingController</span></strong><span class="koboSpan" id="kobo.229.1"> service, with which we can emulate a response from our backend service. </span><span class="koboSpan" id="kobo.229.2">Here, we also create an assertion to ensure that our method is calling the API with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">GET</span></strong><span class="koboSpan" id="kobo.231.1"> HTTP verb. </span><span class="koboSpan" id="kobo.231.2">In order to simulate the HTTP request , we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">flush</span></strong><span class="koboSpan" id="kobo.233.1"> method of the service and what we want to send – in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">fakebody</span></strong><span class="koboSpan" id="kobo.235.1"> object. </span><span class="koboSpan" id="kobo.235.2">But we need to remember that an HTTP operation is asynchronous so we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">tick</span></strong><span class="koboSpan" id="kobo.237.1"> function, available within the context of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">fakeAsync</span></strong><span class="koboSpan" id="kobo.239.1"> function, to simulate the time that would pass for an </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">asynchronous execution.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">We will create a test for the </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.242.1">same service to simulate the creation of a </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">new entry:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
it('should use the method addNewItem to add a new Entry', fakeAsync(() =&gt; {
  const fakeBody: ExerciseSet = {
    id: '1',
    date: new Date(),
    exercise: 'Deadlift',
    reps: 15,
    sets: 4,
  };
  service.addNewItem(fakeBody).subscribe((response) =&gt; {
    expect(response).toEqual(fakeBody);
  });
  const request = httpMock.expectOne((req) =&gt; {
    return req.method === 'POST';
  });
  request.flush(fakeBody);
  tick();
}));</span></pre> <p><span class="koboSpan" id="kobo.245.1">We start with the definition of the new test that will appear in Karma and then we create the test function, again within the context of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">fakeAsync</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">In the test setup, we define </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.249.1">an object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">fakeBody</span></strong><span class="koboSpan" id="kobo.251.1"> with the payload we want to send and make the assertion. </span><span class="koboSpan" id="kobo.251.2">In the execution phase of the method we want to test, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">addNewItem</span></strong><span class="koboSpan" id="kobo.253.1"> method and place the assertion inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">subscribe</span></strong><span class="koboSpan" id="kobo.255.1"> function. </span><span class="koboSpan" id="kobo.255.2">We perform the assertion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">POST verb</span></strong><span class="koboSpan" id="kobo.257.1">, and finally, we simulate the request using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">flush</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">tick</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1"> functions.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">To end this session, let’s switch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">fdescribe</span></strong><span class="koboSpan" id="kobo.264.1"> function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">describe</span></strong><span class="koboSpan" id="kobo.266.1"> function. </span><span class="koboSpan" id="kobo.266.2">In the test file of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">ExercisesService</span></strong><span class="koboSpan" id="kobo.268.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">AuthInterceptor</span></strong><span class="koboSpan" id="kobo.270.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">AuthService</span></strong><span class="koboSpan" id="kobo.272.1"> services, let’s make the </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">following change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
beforeEach(() =&gt; {
  TestBed.configureTestingModule({ imports: [HttpClientTestingModule] });
  . </span><span class="koboSpan" id="kobo.274.2">. </span><span class="koboSpan" id="kobo.274.3">.
</span><span class="koboSpan" id="kobo.274.4">});</span></pre> <p><span class="koboSpan" id="kobo.275.1">As we saw in this section, we need to inform Angular of the test’s dependency, that is, declaring </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.277.1"> in the configuration of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">TestBed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">We still have to</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.281.1"> correct the test of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">NotificationInterceptor</span></strong><span class="koboSpan" id="kobo.283.1"> service, which uses an external library as a dependency. </span><span class="koboSpan" id="kobo.283.2">We will refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">notification.interceptor.spec.ts</span></strong><span class="koboSpan" id="kobo.285.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
describe('NotificationInterceptor', () =&gt; {
  beforeEach(() =&gt;
    TestBed.configureTestingModule({
      providers: [
        NotificationInterceptor,
        {
          provide: ToastrService,
          useValue: jasmine.createSpyObj('ToastrService', ['success']),
        },
      ],
    })
  );
. </span><span class="koboSpan" id="kobo.287.2">. </span><span class="koboSpan" id="kobo.287.3">.
</span><span class="koboSpan" id="kobo.287.4">});</span></pre> <p><span class="koboSpan" id="kobo.288.1">In the case of general dependencies that we need to simulate in our tests, we can define the service in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">providers</span></strong><span class="koboSpan" id="kobo.290.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">TestBed</span></strong><span class="koboSpan" id="kobo.292.1"> class definition. </span><span class="koboSpan" id="kobo.292.2">But instead of offering the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">ToastrService</span></strong><span class="koboSpan" id="kobo.294.1"> class, we declare an object and, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">useValue</span></strong><span class="koboSpan" id="kobo.296.1"> property, it tells Angular which class to provide for </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">the test.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">Here, we could</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.299.1"> create a class that has the same original methods, but better than that, we are using a feature of the Jasmine test framework, which is the spy objects. </span><span class="koboSpan" id="kobo.299.2">With them, we can mock entire classes for our tests, thus managing to simulate unit </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">test dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">In the next section, we’ll fix all the tests and understand how Angular’</span><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.302.1">s </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">TestBed</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.304.1">component works.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.305.1">Fixing the tests and understanding TestBed</span></h1>
<p><span class="koboSpan" id="kobo.306.1">To better </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.307.1">understand the </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.308.1">use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">TestBed</span></strong><span class="koboSpan" id="kobo.310.1">, we’ll fix the rest of our project’s tests by adding dependencies to the test files. </span><span class="koboSpan" id="kobo.310.2">We’ll start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.312.1"> file and make the fixes </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
describe('AppComponent', () =&gt; {
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
     declarations: [AppComponent],
     imports: [RouterTestingModule],
   }).compileComponents();
  });
  it('should create the app', () =&gt; {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.315.1">In this test, we cleaned up the test cases that had already been created by the Angular CLI when we started the project. </span><span class="koboSpan" id="kobo.315.2">It has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">router-outlet</span></strong><span class="koboSpan" id="kobo.317.1"> component so we need to mock Angular’s route services. </span><span class="koboSpan" id="kobo.317.2">Like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">HttpClient</span></strong><span class="koboSpan" id="kobo.319.1"> service, the Angular team has also prepared a specific module for testing, and so we are importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">RouterTestingModule</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.321.1">module here.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">We’ll change</span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.323.1"> the test</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.324.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">login.component.spec.ts</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.326.1">file next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [LoginComponent],
    imports: [ReactiveFormsModule],
    providers: [
      AuthService,
      {
        provide: AuthService,
        useValue: jasmine.createSpyObj('AuthService', ['login']),
      },
    ],
  });
  fixture = TestBed.createComponent(LoginComponent);
  component = fixture.componentInstance;
  fixture.detectChanges();
});</span></pre> <p><span class="koboSpan" id="kobo.328.1">Since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Login</span></strong><span class="koboSpan" id="kobo.330.1"> component relies on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.332.1"> module, we also need to import it into our test. </span><span class="koboSpan" id="kobo.332.2">Furthermore, the component utilizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">AuthService</span></strong><span class="koboSpan" id="kobo.334.1"> service, and for our mocking purposes, we employ the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">useValue</span></strong><span class="koboSpan" id="kobo.336.1"> property, as demonstrated earlier. </span><span class="koboSpan" id="kobo.336.2">In unit testing, it’s crucial to concentrate on the component itself, and we achieve this by isolating it through the mocking of </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">The next test</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.339.1"> to tune will be </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.340.1">for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">home.component.spec.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.342.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [HomeComponent],
    imports: [RouterTestingModule],
    providers: [
      AuthService,
      {
        provide: AuthService,
        useValue: jasmine.createSpyObj('AuthService', ['logout']),
      },
    ],
  });
  fixture = TestBed.createComponent(HomeComponent);
  component = fixture.componentInstance;
  fixture.detectChanges();
});</span></pre> <p><span class="koboSpan" id="kobo.344.1">When testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Home</span></strong><span class="koboSpan" id="kobo.346.1"> component, we need to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">'RouterTestingModule'</span></strong><span class="koboSpan" id="kobo.348.1"> dependency because we are using route services and we are mocking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">'AuthService'</span></strong><span class="koboSpan" id="kobo.350.1"> service due to the application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">logout action.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Next, let’s fix the test</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.353.1"> for </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.354.1">the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">new-entry-form-template.component.spec.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [NewEntryFormTemplateComponent],
    imports: [FormsModule],
    providers: [
      ExerciseSetsService,
      {
        provide: ExerciseSetsService,
        useValue: jasmine.createSpyObj('ExerciseSetsService', ['addNewItem']),
      },
    ],
  });
  fixture = TestBed.createComponent(NewEntryFormTemplateComponent);
  component = fixture.componentInstance;
  fixture.detectChanges();
});</span></pre> <p><span class="koboSpan" id="kobo.358.1">This page employs template-driven</span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.359.1"> form techniques, so for the test run, we include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">'FormsModule'</span></strong><span class="koboSpan" id="kobo.361.1"> module by importing it. </span><span class="koboSpan" id="kobo.361.2">As it only uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">'ExerciseSetsService'</span></strong><span class="koboSpan" id="kobo.363.1"> service, we</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.364.1"> mocked it with the help of the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">Jasmine framework.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">We’ll work on testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">new-entry-form-reactive.component.spec</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.368.1">page next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.369.1">
beforeEach(() =&gt; {
  TestBed.configureTestingModule({
    declarations: [NewEntryFormReactiveComponent],
    imports: [ReactiveFormsModule, RouterTestingModule],
    providers: [
      ExerciseSetsService,
      {
        provide: ExerciseSetsService,
        useValue: jasmine.createSpyObj('ExerciseSetsService', [
          'addNewItem',
          'updateItem',
        ]),
      },
      ExercisesService,
      {
        provide: ExercisesService,
        useValue: jasmine.createSpyObj('ExercisesService', ['getExercises']),
      },
    ],
  });
  fixture = TestBed.createComponent(NewEntryFormReactiveComponent);
  component = fixture.componentInstance;
  fixture.detectChanges();
});</span></pre> <p><span class="koboSpan" id="kobo.370.1">In </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.371.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.372.1">, </span><em class="italic"><span class="koboSpan" id="kobo.373.1">Exploring Reactivity with RxJS</span></em><span class="koboSpan" id="kobo.374.1">, we incorporated the search exercise into the form, so in this</span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.375.1"> test case, we </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.376.1">need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">'ReactiveFormsModule'</span></strong><span class="koboSpan" id="kobo.378.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">'RouterTestingModule'</span></strong><span class="koboSpan" id="kobo.380.1"> modules. </span><span class="koboSpan" id="kobo.380.2">In addition, we need to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">'ExerciseSetsService'</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">'</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">ExercisesService'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1"> services.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">With this test </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.387.1">set, let’s go to </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.388.1">the last </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">component, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">diary.component.spec.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
describe('DiaryComponent', () =&gt; {
. </span><span class="koboSpan" id="kobo.392.2">. </span><span class="koboSpan" id="kobo.392.3">.
</span><span class="koboSpan" id="kobo.392.4">  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [
        DiaryComponent,
        ListEntriesComponent,
        NewItemButtonComponent,
      ],
      imports: [RouterTestingModule],
      providers: [
        ExerciseSetsService,
        {
          provide: ExerciseSetsService,
          useValue: jasmine.createSpyObj('ExerciseSetsService', [
            'deleteItem'
          ]),
        },
      ],
    }).compileComponents();
    fixture = TestBed.createComponent(DiaryComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });
});</span></pre> <p><span class="koboSpan" id="kobo.393.1">This component, as it is a </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.394.1">smart component in our suggested architecture, needs to declare the </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.395.1">components that compose it in your test. </span><span class="koboSpan" id="kobo.395.2">Here, they are </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.397.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">ListEntriesComponent</span></strong><span class="koboSpan" id="kobo.399.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">NewItemButtonComponent</span></strong><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">Finally, we imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">RouterTestingModule</span></strong><span class="koboSpan" id="kobo.403.1"> module into the test setup and mocked up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.405.1"> service, thus correcting all the tests in </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">our project.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">To understand how </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">TestBed</span></strong><span class="koboSpan" id="kobo.409.1"> works,</span><a id="_idTextAnchor275"/> <a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.410.1">l</span><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.411.1">et’s create a test case for </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">our component.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.413.1">Component testing</span></h1>
<p><span class="koboSpan" id="kobo.414.1">Angular</span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.415.1"> component unit tests not only examine logic but also assess the values that will be presented on </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">If your application follows the component architecture recommended by the Angular team (more details in </span><a href="B19562_04.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.418.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.419.1">, </span><em class="italic"><span class="koboSpan" id="kobo.420.1">Components and Pages</span></em><span class="koboSpan" id="kobo.421.1">), you probably won’t have much business logic in your components, delegating it </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">to services.</span></span></p>
<p><span class="koboSpan" id="kobo.423.1">To exemplify, in this section, we will create tests for some methods of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">DiaryComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1"> We will create the test case for the gym diary entry deletion operation and check whether the service’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">delete</span></strong><span class="koboSpan" id="kobo.428.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">is called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
describe('DiaryComponent', () =&gt; {
  . </span><span class="koboSpan" id="kobo.430.2">. </span><span class="koboSpan" id="kobo.430.3">.
</span><span class="koboSpan" id="kobo.430.4">  let exerciseSetsService: ExerciseSetsService;
  beforeEach(async () =&gt; {
  await TestBed.configureTestingModule({
   . </span><span class="koboSpan" id="kobo.430.5">. </span><span class="koboSpan" id="kobo.430.6">.
</span><span class="koboSpan" id="kobo.430.7">  }).compileComponents();
   . </span><span class="koboSpan" id="kobo.430.8">. </span><span class="koboSpan" id="kobo.430.9">.
</span><span class="koboSpan" id="kobo.430.10">    exerciseSetsService = TestBed.inject(ExerciseSetsService);
  });
  it('should call delete method when the button delete is clicked', fakeAsync(() =&gt; {
    exerciseSetsService.deleteItem = jasmine.createSpy().and.returnValue(of());
    component.deleteItem('1');
    tick();
    expect(exerciseSetsService.deleteItem).toHaveBeenCalledOnceWith('1');
  }));
});</span></pre> <p><span class="koboSpan" id="kobo.431.1">In the preceding code </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.432.1">block, we are testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.434.1"> component, so we mock the service it depends on with </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">TestBed</span></strong><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">But for this test, we need a reference to this service, and for that, we declare a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">exerciseSetsService</span></strong><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">TestBed.inject</span></strong><span class="koboSpan" id="kobo.440.1"> method, we assign the value to </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">this variable.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">In the test setup, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">createSpy</span></strong><span class="koboSpan" id="kobo.444.1"> function to assign the service’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">deleteItem</span></strong><span class="koboSpan" id="kobo.446.1"> method because the mock generated by the Jasmine framework does not have the full implementation of the service and therefore does not return the observable that the component </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">is expecting.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">In the execution phase, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">deleteItem</span></strong><span class="koboSpan" id="kobo.450.1"> method of </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">As this operation is asynchronous, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">tick</span></strong><span class="koboSpan" id="kobo.454.1"> function to simulate the passage </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">In the assertion </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.457.1">phase, we check that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">exerciseSetsService</span></strong><span class="koboSpan" id="kobo.459.1"> service method was called once and with the </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">expected parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Let’s test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">editEntry</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.463.1">method next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
import { Location } from '@angular/common';
describe('DiaryComponent', () =&gt; {
  let location: Location;
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
. </span><span class="koboSpan" id="kobo.464.2">. </span><span class="koboSpan" id="kobo.464.3">.
</span><span class="koboSpan" id="kobo.464.4">      imports: [
        RouterTestingModule.withRoutes([
          {
            path: 'home/diary/entry/:id',
            component: NewEntryFormReactiveComponent, },
        ]),
      ]
     }).compileComponents();
    location = TestBed.inject(Location);
  });
  it('should direct to diary entry edit route', fakeAsync(() =&gt; {
    const set: ExerciseSet = { date: new Date(), exercise: 'test', reps: 6, sets: 6, id: '1' };
    component.editEntry(set);
    tick();
    expect(location.path()).toBe('/home/diary/entry/1');
  }));
});</span></pre> <p><span class="koboSpan" id="kobo.465.1">To perform the assertion of the route, we are going to use an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Location</span></strong><span class="koboSpan" id="kobo.467.1"> – that’s why we declare it at the beginning of the test and assign it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">TestBed</span></strong><span class="koboSpan" id="kobo.469.1"> component. </span><span class="koboSpan" id="kobo.469.2">Note that we want the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">@angular/common</span></strong><span class="koboSpan" id="kobo.471.1"> library object and not the browser’s default </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">Location</span></strong><span class="koboSpan" id="kobo.473.1"> object. </span><span class="koboSpan" id="kobo.473.2">Also, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">TestBed</span></strong><span class="koboSpan" id="kobo.475.1">, we need to declare a route, because as we are in the context of unit testing, Angular does not know the routes available </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">for use.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">In the test case, we</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.478.1"> first create a dummy </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">ExerciseSet </span></strong><span class="koboSpan" id="kobo.480.1">object and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">editEntry </span></strong><span class="koboSpan" id="kobo.482.1">method. </span><span class="koboSpan" id="kobo.482.2">Again, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">tick</span></strong><span class="koboSpan" id="kobo.484.1"> function to simulate the passage of time. </span><span class="koboSpan" id="kobo.484.2">Finally, in the assertion, we verify that the path is correct. </span><span class="koboSpan" id="kobo.484.3">Note that, here, we don’t need to create any mock for the router as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">RouterTestingModule</span></strong><span class="koboSpan" id="kobo.486.1"> module creates it </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">In the next section, we will e</span><a id="_idTextAnchor279"/><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.489.1">xplore E2E testing with the </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">Cypress framework.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.491.1">E2E tests with Cypress</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.492.1">E2E</span></strong><span class="koboSpan" id="kobo.493.1"> tests aim to </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.494.1">evaluate the system from the user’s </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.495.1">point of view, simulating operations such as typing in a field, clicking on a button, carrying out the assertion, and evaluating the messages on the screen, just as a user would evaluate whether the action was successful </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">In the Angular ecosystem, in the past, there was a tool</span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.498.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">Protractor</span></strong><span class="koboSpan" id="kobo.500.1"> to help with this type of testing, but it was discontinued by the Angular team in favor of other, more focused open </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">source tools.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">Among these new tools, we are going to use one of the most popular ones, </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">called Cypress.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">The Cypress framework is a tool that aims to help developers create and run all types of tests in the test pyramid, from unitary </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">to E2E.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">Let’s see it in action in our project. </span><span class="koboSpan" id="kobo.506.2">For that, we need to install and configure it. </span><span class="koboSpan" id="kobo.506.3">Follow these steps to install </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.507.1">and</span><a id="_idIndexMarker479"/> <span class="No-Break"><span class="koboSpan" id="kobo.508.1">configure Cypress:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.509.1">We will use the Angular CLI to install and configure Cypress. </span><span class="koboSpan" id="kobo.509.2">In the command line of your operating system, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.511.1">ng add @cypress/schematic</span></strong></pre></li> <li><span class="koboSpan" id="kobo.512.1">Following the prompt’s instructions, we have created the Cypress files, in addition to adapting </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">angular.json</span></strong><span class="koboSpan" id="kobo.514.1"> with the settings </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">it needs.</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">To run the tool, run the following command at the operating </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">system prompt:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.518.1">ng e2e</span></strong></pre></li> <li><span class="koboSpan" id="kobo.519.1">The preceding command will run our application as we would with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">ng serve</span></strong><span class="koboSpan" id="kobo.521.1"> command and open the </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">tool’s interface.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.523.1"><img alt="Figure 10.3 – Execution of tests by Cypress" src="image/B19562_10_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.524.1">Figure 10.3 – Execution of tests by Cypress</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.525.1">Select the desired browser and click on </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">Start E2E Testing</span></strong><span class="koboSpan" id="kobo.527.1"> and we will have the test </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">execution interface.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.529.1">Notice that we</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.530.1"> already have a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">spec.cy.ts</span></strong><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">It was</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.533.1"> generated by Cypress to exemplify the creation of the test script. </span><span class="koboSpan" id="kobo.533.2">Let’s go back to Visual Studio Code and check </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">this file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
describe('My First Test', () =&gt; {
  it('Visits the initial project page', () =&gt; {
    cy.visit('/')
    cy.contains('app is running!')
  })
})</span></pre> <p><span class="koboSpan" id="kobo.536.1">Unlike Angular, Cypress uses </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.537.1">Mocha (</span><a href="https://mochajs.org/"><span class="koboSpan" id="kobo.538.1">https://mochajs.org/</span></a><span class="koboSpan" id="kobo.539.1">) as a testing framework. </span><span class="koboSpan" id="kobo.539.2">However, in practice, as we can see in the preceding example, it is very similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">Jasmine framework.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">We have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">describe</span></strong><span class="koboSpan" id="kobo.543.1"> function to create the test suite and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">it</span></strong><span class="koboSpan" id="kobo.545.1"> function to create the test cases. </span><span class="koboSpan" id="kobo.545.2">The difference here is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">cy</span></strong><span class="koboSpan" id="kobo.547.1"> object, which represents the browser’s interface, and with this object, we can perform actions and evaluate the state of the page, from the user’s point of view. </span><span class="koboSpan" id="kobo.547.2">Here, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">visit</span></strong><span class="koboSpan" id="kobo.549.1"> method to go to the initial endpoint and we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">contains</span></strong><span class="koboSpan" id="kobo.551.1"> method to evaluate whether the text app is running appears on the page. </span><span class="koboSpan" id="kobo.551.2">We are going to delete this file because we are going to create the scripts for </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">In the same folder as where the previous file was, we will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">login.cy.ts</span></strong><span class="koboSpan" id="kobo.555.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
describe('Login Page:', () =&gt; {
  it('should login to the diary with the correct credentials.', () =&gt; {
    cy.visit('/');
    cy.get('#username').type('mario');
    cy.get('#password').type('1234');
    cy.get(':nth-child(3) &gt; .w-full').click();
    cy.contains('Workout diary');
  });
});</span></pre> <p><span class="koboSpan" id="kobo.558.1">In this test, we used </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.559.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">get</span></strong><span class="koboSpan" id="kobo.561.1"> method to obtain the page element </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.562.1">through CSS queries so that we could act on them. </span><span class="koboSpan" id="kobo.562.2">First, we take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">username</span></strong><span class="koboSpan" id="kobo.564.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">password</span></strong><span class="koboSpan" id="kobo.566.1"> fields and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">type</span></strong><span class="koboSpan" id="kobo.568.1"> method to simulate the user typing in these fields. </span><span class="koboSpan" id="kobo.568.2">Then we locate the </span><strong class="bold"><span class="koboSpan" id="kobo.569.1">Confirm</span></strong><span class="koboSpan" id="kobo.570.1"> button and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">click</span></strong><span class="koboSpan" id="kobo.572.1"> method to simulate the mouse </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">click action.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">To assert the test, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">contains</span></strong><span class="koboSpan" id="kobo.576.1"> method to assess whether the diary screen </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">was displayed.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">The tricky part of creating this script is the CSS queries needed to get the elements we need. </span><span class="koboSpan" id="kobo.578.2">But at this point, Cypress helps us </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">a lot.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">By running the test, we can see that there is a target icon at the top of the screen. </span><span class="koboSpan" id="kobo.580.2">By clicking on it and selecting the element we want, Cypress will generate the necessary command ready to copy and paste into </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">our script.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.582.1"><img alt="Figure 10.4 – Cypress helping with﻿ the CSS query" src="image/B19562_10_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.583.1">Figure 10.4 – Cypress helping with the CSS query</span></p>
<p><span class="koboSpan" id="kobo.584.1">In this script, however, there </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.585.1">is a problem in selecting the button, in </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.586.1">addition to the query not being clear to another person reading the test script. </span><span class="koboSpan" id="kobo.586.2">If the team needs to change the layout, the test could </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">break unduly.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">To avoid this error, let’s change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">login</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.590.1">component template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
&lt;button
  type="submit"
  class="w-full rounded bg-blue-500 px-4 py-2 text-white"
  [disabled]="loginForm.invalid"
  [class.opacity-50]="loginForm.invalid"
  </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">data-cy="submit"</span></strong><span class="koboSpan" id="kobo.593.1">
&gt;
  Login
&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.594.1">With this custom HTML </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.595.1">element, we can use the element marked</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.596.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">data-cy</span></strong><span class="koboSpan" id="kobo.598.1"> attribute for </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">our test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
describe('Login Page:', () =&gt; {
  it('should login to the diary with the correct credentials.', () =&gt; {
    cy.visit('/');
    cy.get('#username').type('mario');
    cy.get('#password').type('1234');
    </span><strong class="bold"><span class="koboSpan" id="kobo.601.1">cy.get('[data-cy="submit"]').click();</span></strong><span class="koboSpan" id="kobo.602.1">
    cy.contains('Workout diary');
  });
});</span></pre> <p><span class="koboSpan" id="kobo.603.1">We replaced the previous CSS query with a simpler one that does not depend on layout elements. </span><span class="koboSpan" id="kobo.603.2">Use this good practice in your project templates to facilitate E2E testing and make the test less likely </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">to break.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">We’ll create an E2E test for the new journal entry form, but first, let’s apply the best practice to the templates we’ll be using in this test. </span><span class="koboSpan" id="kobo.605.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Home</span></strong><span class="koboSpan" id="kobo.607.1"> component template, we will refactor </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
&lt;li&gt;
  &lt;a
    routerLink="./diary"
    class="flex items-center space-x-2 text-white"
    </span><strong class="bold"><span class="koboSpan" id="kobo.610.1">data-cy="home-menu"</span></strong><span class="koboSpan" id="kobo.611.1">
  &gt;
    &lt;span&gt;Diary&lt;/span&gt;
  &lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a
    routerLink="./diary/entry"
    class="flex items-center space-x-2 text-white"
    </span><strong class="bold"><span class="koboSpan" id="kobo.612.1">data-cy="new-entry-menu"</span></strong><span class="koboSpan" id="kobo.613.1">
  &gt;
    &lt;span&gt;New Entry&lt;/span&gt;
  &lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
  &lt;a
    (click)="logout()"
    class="flex items-center space-x-2 text-white"
    </span><strong class="bold"><span class="koboSpan" id="kobo.614.1">data-cy="logout-menu"</span></strong><span class="koboSpan" id="kobo.615.1">
  &gt;
    &lt;span&gt;Logout&lt;/span&gt;
  &lt;/a&gt;
&lt;/li&gt;</span></pre> <p><span class="koboSpan" id="kobo.616.1">In the template, we </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.617.1">add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">data-cy</span></strong><span class="koboSpan" id="kobo.619.1"> HTML element to the items</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.620.1"> of the menu. </span><span class="koboSpan" id="kobo.620.2">Note that as the test is from the user’s point of view, we need to simulate how they get to </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">the form.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">new-entry-form-reactive.component.html</span></strong><span class="koboSpan" id="kobo.624.1"> template, we will change the submit button </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
&lt;button
  type="submit"
  [disabled]="entryForm.invalid"
  [class.opacity-50]="entryForm.invalid"
  class="rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700"
  </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">data-cy="submit"</span></strong><span class="koboSpan" id="kobo.628.1">
&gt;
  Confirm
&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.629.1">As with the login screen, we</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.630.1"> mark the button with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">data-cy</span></strong><span class="koboSpan" id="kobo.632.1"> element </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.633.1">to facilitate the development of the </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">E2E test.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">With our application better adapted for testing, we will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">new-entry-form.cy.ts</span></strong><span class="koboSpan" id="kobo.637.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">cypress/e2e</span></strong><span class="koboSpan" id="kobo.639.1"> folder of our workspace and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
describe('New Entry Form:', () =&gt; {
  beforeEach(() =&gt; {
    cy.visit('/');
    cy.get('#username').type('mario');
    cy.get('#password').type('1234');
    cy.get('[data-cy="submit"]').click();
  });
  it('Should register a new entry in the workout diary', () =&gt; {
    cy.get('[data-cy="new-entry-menu"]').click();
    cy.contains('Date');
    cy.get('#date').type('2023-08-08');
    cy.get('#exercise').type('Front Squat');
    cy.get('#sets').type('4');
    cy.get('#reps').type('6');
    cy.get('[data-cy="submit"]').click();
    cy.contains('Item Created!');
  });
});</span></pre> <p><span class="koboSpan" id="kobo.642.1">Like Jasmine, the </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.643.1">Mocha.js framework also has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">beforeEach</span></strong><span class="koboSpan" id="kobo.645.1"> function, but here, instead of setting up the environment with </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">TestBed</span></strong><span class="koboSpan" id="kobo.647.1">, we use the function</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.648.1"> to perform the login, since each test where we are simulating the user is necessary for </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">this action.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">In the test case of the form, since we are already logged in, we click on the menu of the input form and check whether there is a </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">Date</span></strong><span class="koboSpan" id="kobo.652.1"> label. </span><span class="koboSpan" id="kobo.652.2">From then on, we fill in the form fields with data and click on the button. </span><span class="koboSpan" id="kobo.652.3">In the assertion phase, we check whether the </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Item created</span></strong><span class="koboSpan" id="kobo.654.1"> message appears on </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">One thing to note is that at no point do we tell the script how long to wait for the backend response, which can vary. </span><span class="koboSpan" id="kobo.656.2">This happens because the Cypress framework does this work for us and makes this waiting process transparent to </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">our development.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">We will create a test case to evaluate the </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">form validations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">
it('should validate field information and show the validation message', () =&gt; {
    cy.get('[data-cy="new-entry-menu"]').click();
    cy.contains('Date');
    cy.get('#date').type('2023-08-08');
    cy.get('#exercise').type('Front Squat');
    cy.get('#sets').type('3');
    cy.get('#reps').type('6');
    cy.contains('Sets is required and must be a positive number.');
    cy.contains('sets is required and must be multiple of 2.');
  });</span></pre> <p><span class="koboSpan" id="kobo.661.1">In this test case, we </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.662.1">don’t need to worry about the login</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.663.1"> because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">beforeEach</span></strong><span class="koboSpan" id="kobo.665.1"> function performs this function and we work directly on the form. </span><span class="koboSpan" id="kobo.665.2">We fill in the fields, but this time, with information that is not valid. </span><span class="koboSpan" id="kobo.665.3">In the assertion phase, we check whether the validation messages appear correctly with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">contains</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">With that, you’ve learned about Cypress and E2E testing in an Angula</span><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.669.1">r </span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.670.1">application, so let’s summarize what we looked at in </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">the chapter.</span></span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.672.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.673.1">In this chapter, we learned how to perform tests in an Angular project. </span><span class="koboSpan" id="kobo.673.2">We studied what types of tests there are, their importance, and how to apply them in our daily lives. </span><span class="koboSpan" id="kobo.673.3">We worked on our project by first creating tests for the services and looking at how to isolate the dependencies for a unit test. </span><span class="koboSpan" id="kobo.673.4">Furthermore, we explored testing HTTP requests using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">HttpClientTestingModule</span></strong><span class="koboSpan" id="kobo.675.1"> module. </span><span class="koboSpan" id="kobo.675.2">We learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">TestBed</span></strong><span class="koboSpan" id="kobo.677.1"> component and its important task of setting up the environment for each unit test to run. </span><span class="koboSpan" id="kobo.677.2">We also looked at component testing and how to assert components that use routes. </span><span class="koboSpan" id="kobo.677.3">Finally, we explored E2E tests with the Cypress tool, which simplifies the creation of scripts that simulate the behavior of our application from the client’s point </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">of view.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">In the next chapter, we will explore the concept of the micro frontend using the </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">Angular framework.</span></span></p>
</div>
</body></html>