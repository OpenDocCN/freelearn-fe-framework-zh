<html><head></head><body>
<div id="_idContainer043">
<h1 class="chapter-number" id="_idParaDest-95"><a id="_idTextAnchor186"/><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-96"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.2.1">Handling User Inputs: Forms</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Since the early days of web applications, before the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Single Page Applications</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SPAs</span></strong><span class="koboSpan" id="kobo.7.1">), in HTML 2, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.9.1"> tag has been used to create, organize, and send forms to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In common applications, such as banking systems and health applications, we use forms to organize the inputs that our users need to perform in our systems. </span><span class="koboSpan" id="kobo.11.2">With such a common element in web applications, it is natural that Angular, a framework whose philosophy is </span><em class="italic"><span class="koboSpan" id="kobo.12.1">batteries included</span></em><span class="koboSpan" id="kobo.13.1">, offers this feature to </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">its developers.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will delve into the following forms features </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">in Angular:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Template-driven forms</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Reactive forms</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Data validation</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Custom validations</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Typed </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">reactive forms</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">By the end of this chapter, you will be able to create maintainable and fluid forms for your user, in addition to improving your productivity with this type </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">of task.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.28.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch6"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch6</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">During the study of this chapter, remember to run the backend of the application found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.42.1"> folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.45.1"> command.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor190"/><a id="_idTextAnchor191"/><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.46.1">Template-driven forms</span></h1>
<p><span class="koboSpan" id="kobo.47.1">Angular has two</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.48.1"> different ways of working with forms: </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">template-driven</span></strong><span class="koboSpan" id="kobo.50.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">reactive</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">First, let’s explore template-driven forms. </span><span class="koboSpan" id="kobo.52.3">As we can see by the name, we maximize the use of the capabilities of the HTML template to create and manage the</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.53.1"> data model linked to </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the form.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">We will evolve our Gym Diary application to better exemplify this concept. </span><span class="koboSpan" id="kobo.55.2">In the following command line, we use the Angular CLI to create the new </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">page component:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.57.1">
ng g c diary/new-entry-form-template</span></pre> <p><span class="koboSpan" id="kobo.58.1">To access the new assignment form, we’ll refactor the journal page component so the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Add New Entry</span></strong><span class="koboSpan" id="kobo.60.1"> button takes the user to the component </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">we created.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Let’s add to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">DiaryModule</span></strong><span class="koboSpan" id="kobo.64.1"> module the import of the framework module responsible for managing the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">application’s routes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
. </span><span class="koboSpan" id="kobo.66.2">. </span><span class="koboSpan" id="kobo.66.3">.
</span><span class="koboSpan" id="kobo.66.4">import { </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">RouterModule</span></strong><span class="koboSpan" id="kobo.68.1"> } from '@angular/router';
@NgModule({
 declarations: [
   DiaryComponent,
   EntryItemComponent,
   ListEntriesComponent,
   NewItemButtonComponent,
   NewEntryFormTemplateComponent,
 ],
 imports: [CommonModule, DiaryRoutingModule, </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">RouterModule</span></strong><span class="koboSpan" id="kobo.70.1">],
})
export class DiaryModule {}</span></pre> <p><span class="koboSpan" id="kobo.71.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">RouterModule</span></strong><span class="koboSpan" id="kobo.73.1"> module imported, we will be able to use Angular’s route services. </span><span class="koboSpan" id="kobo.73.2">For more details on routing, see </span><a href="B19562_07.xhtml#_idTextAnchor207"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.75.1">, </span><em class="italic"><span class="koboSpan" id="kobo.76.1">Routes and Routers</span></em><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">We will add the new component to a </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.78.1">route in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">DiaryRoutingModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.81.1">
. </span><span class="koboSpan" id="kobo.81.2">. </span><span class="koboSpan" id="kobo.81.3">.
</span><span class="koboSpan" id="kobo.81.4">import { NewEntryFormTemplateComponent } from './new-entry-form-template/new-entry-form-template.component';
const routes: Routes = [
  {
    path: '',
    component: DiaryComponent,
  },
  {
    path: 'new-template',
    component: NewEntryFormTemplateComponent,
  },
];
@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class DiaryRoutingModule {}</span></pre> <p><span class="koboSpan" id="kobo.82.1">To be able to</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.83.1"> compare the two form creation approaches, we will create a route for each example component that we are going to create. </span><span class="koboSpan" id="kobo.83.2">Here, the URL </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">/home/new-template</span></strong><span class="koboSpan" id="kobo.85.1"> will direct us to the template-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">form route.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">We will now refactor </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">DiaryComponent</span></strong><span class="koboSpan" id="kobo.89.1"> to modify the behavior of the </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">Add New </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.91.1">Entry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1"> button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
. </span><span class="koboSpan" id="kobo.93.2">. </span><span class="koboSpan" id="kobo.93.3">.
</span><span class="koboSpan" id="kobo.93.4">import { Router } from '@angular/router';
@Component({
  templateUrl: './diary.component.html',
  styleUrls: ['./diary.component.css'],
})
export class DiaryComponent implements OnInit {
  private exerciseSetsService = inject(ExerciseSetsService);
  private router = inject(Router)
. </span><span class="koboSpan" id="kobo.93.5">. </span><span class="koboSpan" id="kobo.93.6">.
</span><span class="koboSpan" id="kobo.93.7">  addExercise(newSet: ExerciseSet) {
    this.router.navigate(['/home/new-template'])
  }
. </span><span class="koboSpan" id="kobo.93.8">. </span><span class="koboSpan" id="kobo.93.9">.
</span><span class="koboSpan" id="kobo.93.10">}</span></pre> <p><span class="koboSpan" id="kobo.94.1">First, we need to inject Angular’s router service.We change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">addExercise</span></strong><span class="koboSpan" id="kobo.96.1"> method to use the service and, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">navigate</span></strong><span class="koboSpan" id="kobo.98.1"> method, direct to </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the page.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">We can proceed to the HTML template of our form in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">new-entry-form-template.component.html</span></strong><span class="koboSpan" id="kobo.102.1"> file and place only the elements of </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
&lt;div class="flex h-screen items-center justify-center bg-gray-200"&gt;
  &lt;form class="mx-auto max-w-sm rounded bg-gray-200 p-4"&gt;
      . </span><span class="koboSpan" id="kobo.104.2">. </span><span class="koboSpan" id="kobo.104.3">.
</span><span class="koboSpan" id="kobo.104.4">      &lt;input
        type="date"
        id="date"
         name="date"
     /&gt;
. </span><span class="koboSpan" id="kobo.104.5">. </span><span class="koboSpan" id="kobo.104.6">.
</span><span class="koboSpan" id="kobo.104.7">      &lt;input
        type="text"
        id="exercise"
        name="exercise"
      /&gt;
. </span><span class="koboSpan" id="kobo.104.8">. </span><span class="koboSpan" id="kobo.104.9">.
</span><span class="koboSpan" id="kobo.104.10">      &lt;input
        type="number"
        id="sets"
        name="sets"
      /&gt;
  &lt;/div&gt;
  &lt;input
    type="number"
    id="reps"
    name="reps"
  /&gt;
   &lt;/div&gt;
   &lt;div class="flex items-center justify-center"&gt;
     &lt;button
       type="submit"
     &gt;
     Add Entry
     &lt;/button&gt;
...</span></pre> <p><span class="koboSpan" id="kobo.105.1">Angular uses HTML</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.106.1"> best practices, so we will now create the form fields under the HTML </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">&lt;form&gt;</span></strong><span class="koboSpan" id="kobo.108.1"> tag. </span><span class="koboSpan" id="kobo.108.2">In the input fields, we are respecting the HTML semantics and creating the fields as </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">&lt;input&gt;</span></strong><span class="koboSpan" id="kobo.110.1"> with the correct types for the type of information the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">client needs.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Let’s run our application with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">ng serve</span></strong><span class="koboSpan" id="kobo.114.1"> command. </span><span class="koboSpan" id="kobo.114.2">By clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">New Entry</span></strong><span class="koboSpan" id="kobo.116.1"> button, we will be able to notice our diary entry </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">addition form.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.118.1"><img alt="Figure 6.1 – Gym Diary Form UI" src="image/B19562_06_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Figure 6.1 – Gym Diary Form UI</span></p>
<p><span class="koboSpan" id="kobo.120.1">Here, we have the</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.121.1"> structure and template of our form. </span><span class="koboSpan" id="kobo.121.2">Now, we are going to prepare for Angular to manage the state of the fields via user input in the template. </span><span class="koboSpan" id="kobo.121.3">To use the template-driven form, we need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">FormModule</span></strong><span class="koboSpan" id="kobo.123.1"> module to our feature </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">module, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">DiaryModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
import { FormsModule } from '@angular/forms';
@NgModule({
  declarations: [
    DiaryComponent,
    EntryItemComponent,
    ListEntriesComponent,
    NewItemButtonComponent,
    NewEntryFormTemplateComponent,
  ],
  imports: [CommonModule, DiaryRoutingModule, RouterModule, </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">FormsModule</span></strong><span class="koboSpan" id="kobo.129.1">],
})
export class DiaryModule {}</span></pre> <p><span class="koboSpan" id="kobo.130.1">In our form template, we</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.131.1"> will add the directives that will create and link the form information to its </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">data model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.133.1">
. </span><span class="koboSpan" id="kobo.133.2">. </span><span class="koboSpan" id="kobo.133.3">.
</span><span class="koboSpan" id="kobo.133.4">&lt;form
  </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">(ngSubmit)="newEntry()"</span></strong><span class="koboSpan" id="kobo.135.1">
  class="mx-auto max-w-sm rounded bg-gray-200 p-4"&gt;
    &lt;div class="mb-4"&gt;
      . </span><span class="koboSpan" id="kobo.135.2">. </span><span class="koboSpan" id="kobo.135.3">.
</span><span class="koboSpan" id="kobo.135.4">      &lt;input type="date" id="date" name="date"
      . </span><span class="koboSpan" id="kobo.135.5">. </span><span class="koboSpan" id="kobo.135.6">.
</span><span class="koboSpan" id="kobo.135.7">        </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">[(ngModel)]="entry.date"</span></strong><span class="koboSpan" id="kobo.137.1">
      /&gt;
    &lt;/div&gt;
    &lt;div class="mb-4"&gt;
      . </span><span class="koboSpan" id="kobo.137.2">. </span><span class="koboSpan" id="kobo.137.3">.
</span><span class="koboSpan" id="kobo.137.4">      &lt;input type="text" id="exercise" name="exercise"
</span><strong class="bold"><span class="koboSpan" id="kobo.138.1">[(ngModel)]="entry.exercise"</span></strong><span class="koboSpan" id="kobo.139.1">
      . </span><span class="koboSpan" id="kobo.139.2">. </span><span class="koboSpan" id="kobo.139.3">. </span><span class="koboSpan" id="kobo.139.4">/&gt;
    &lt;/div&gt;
    &lt;div class="mb-4"&gt;
. </span><span class="koboSpan" id="kobo.139.5">. </span><span class="koboSpan" id="kobo.139.6">.
</span><span class="koboSpan" id="kobo.139.7">      &lt;input type="number" id="sets" name="sets"  </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">[(ngModel)]="entry.sets"</span></strong><span class="koboSpan" id="kobo.141.1">
. </span><span class="koboSpan" id="kobo.141.2">. </span><span class="koboSpan" id="kobo.141.3">./&gt;
    &lt;/div&gt;
    &lt;div class="mb-4"&gt;
. </span><span class="koboSpan" id="kobo.141.4">. </span><span class="koboSpan" id="kobo.141.5">.
</span><span class="koboSpan" id="kobo.141.6">      &lt;input type="number" id="reps" name="reps" </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">[(ngModel)]="entry.reps"</span></strong><span class="koboSpan" id="kobo.143.1">
 . </span><span class="koboSpan" id="kobo.143.2">. </span><span class="koboSpan" id="kobo.143.3">./&gt;
. </span><span class="koboSpan" id="kobo.143.4">. </span><span class="koboSpan" id="kobo.143.5">.
</span><span class="koboSpan" id="kobo.143.6">&lt;/form&gt;
&lt;/div&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.144.1">{{ entry | json }}</span></strong></pre> <p><span class="koboSpan" id="kobo.145.1">The first change we need to</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.146.1"> make to our template is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">ngSubmit</span></strong><span class="koboSpan" id="kobo.148.1"> parameter to state which method will be called by Angular when the user submits the form. </span><span class="koboSpan" id="kobo.148.2">Then, we link the HTML input elements with the data model that will represent the form. </span><span class="koboSpan" id="kobo.148.3">We do this through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">[(</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">ngModel)]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1"> directive.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">ngModel</span></strong><span class="koboSpan" id="kobo.153.1"> is an object managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">FormModule</span></strong><span class="koboSpan" id="kobo.155.1"> module that represents the form’s data model. </span><span class="koboSpan" id="kobo.155.2">The use of square brackets and parentheses signals to Angular that we are performing a two-way data binding on </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the property.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">ngModel</span></strong><span class="koboSpan" id="kobo.159.1"> property will both receive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">form</span></strong><span class="koboSpan" id="kobo.161.1"> property and emit events. </span><span class="koboSpan" id="kobo.161.2">Finally, for development and debugging purposes, we are placing the content of the entry object in the footer and formatting it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">JSON pipe.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Let’s finish the form by changing the component’s </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">TypeScript file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
export class NewEntryFormTemplateComponent {
private exerciseSetsService = inject(ExerciseSetsService);
private router = inject(Router);
entry: ExerciseSet = { date: new Date(), exercise: '', reps: 0, sets: 0 };
      newEntry() {
   const newEntry = { ...this.entry };
   this.exerciseSetsService
     .addNewItem(newEntry)
     .subscribe((entry) =&gt; this.router.navigate(['/home']));
 }
}</span></pre> <p><span class="koboSpan" id="kobo.166.1">First, we inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.168.1"> service for the backend communication and the router service because we want to return to the diary as soon as the user creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">new entry.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Soon after we create the entry object that represents the form’s data model, it is important that we start it with an empty object because Angular makes the binding as soon as the form is loaded. </span><span class="koboSpan" id="kobo.170.2">Finally, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">newEntry</span></strong><span class="koboSpan" id="kobo.172.1"> method, which will send the form data to the backend through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">ExerciseSetsService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> service.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">For more details about Angular services, see </span><a href="B19562_05.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.177.1">, </span><em class="italic"><span class="koboSpan" id="kobo.178.1">Angular Services and the Singleton Pattern</span></em><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">If we run our project and fill in the data, we can see that we are back to the diary screen with the</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.180.1"> new entry </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Notice that at no point did we need to interact with the entry object, as Angular’s form template engine took care of that for us! </span><span class="koboSpan" id="kobo.182.2">This type of form can be used for simpler situations, but now we will see the way recommended by the Angular team to create all types of forms: </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">reactive</span><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.184.1"> forms!</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.185.1">Reactive forms</span></h1>
<p><span class="koboSpan" id="kobo.186.1">Reactive forms use a</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.187.1"> declarative and explicit approach to creating and manipulating form data. </span><span class="koboSpan" id="kobo.187.2">Let’s put this concept into practice by creating a new form for </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">our project.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">First, on the command line, let’s use the Angular CLI to generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">new component:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.191.1">
ng g c diary/new-entry-form-reactive</span></pre> <p><span class="koboSpan" id="kobo.192.1">In the same way as we did with the </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.193.1">template-driven form, let’s add this new component to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">DiaryRoutingModule</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.195.1">routing module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
import { NewEntryFormReactiveComponent } from './new-entry-form-reactive/new-entry-form-reactive.component';
const routes: Routes = [
  {
    path: '',
    component: DiaryComponent,
  },
  {
    path: 'new-template',
    component: NewEntryFormTemplateComponent,
  },
  {
    path: 'new-reactive',
    component: NewEntryFormReactiveComponent,
  },
];</span></pre> <p><span class="koboSpan" id="kobo.197.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">DiaryModule</span></strong><span class="koboSpan" id="kobo.199.1"> module, we need to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.201.1"> module responsible for all the functionality that Angular makes available to us for this type </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">of form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
@NgModule({
  declarations: [
    . </span><span class="koboSpan" id="kobo.203.2">. </span><span class="koboSpan" id="kobo.203.3">.
</span><span class="koboSpan" id="kobo.203.4">  ],
  imports: [
    . </span><span class="koboSpan" id="kobo.203.5">. </span><span class="koboSpan" id="kobo.203.6">.
</span><span class="koboSpan" id="kobo.203.7">    </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">ReactiveFormsModule</span></strong><span class="koboSpan" id="kobo.205.1">,
  ],
})</span></pre> <p><span class="koboSpan" id="kobo.206.1">To finalize the</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.207.1"> component’s route, let’s change the main screen of our application, replacing the route that the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">New Entry</span></strong><span class="koboSpan" id="kobo.209.1"> button </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">will call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
addExercise(newSet: ExerciseSet) {
  this.router.navigate(['/home/new-reactive']);
}</span></pre> <p><span class="koboSpan" id="kobo.212.1">We will now start creating the reactive form. </span><span class="koboSpan" id="kobo.212.2">First, let’s configure the component elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">new-entry-form-reactive.component.ts</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.214.1">TypeScript file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
export class NewEntryFormReactiveComponent implements OnInit {
  public entryForm!: FormGroup;
  private formBuilder = inject(FormBuilder);
  ngOnInit() {
    this.entryForm = this.formBuilder.group({
      date: [''],
      exercise: [''],
      sets: [''],
      reps: [''],
    });
  }
}</span></pre> <p><span class="koboSpan" id="kobo.216.1">Note that the first </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.217.1">attribute is </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">entryForm</span></strong><span class="koboSpan" id="kobo.219.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">FormGroup</span></strong><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">It will represent our form—not just the data model, but the whole form—as validations, field structure, and </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Then, we inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">FormBuilder</span></strong><span class="koboSpan" id="kobo.225.1"> service responsible for assembling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">entryForm</span></strong><span class="koboSpan" id="kobo.227.1"> object. </span><span class="koboSpan" id="kobo.227.2">Note the name of the service that Angular uses from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">Builder</span></strong><span class="koboSpan" id="kobo.229.1"> design pattern, which has the objective of creating complex objects, such as a </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">reactive form.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">To initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">entryForm</span></strong><span class="koboSpan" id="kobo.233.1"> attribute, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">onInit</span></strong><span class="koboSpan" id="kobo.235.1"> component lifecycle hook. </span><span class="koboSpan" id="kobo.235.2">Here, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">group</span></strong><span class="koboSpan" id="kobo.237.1"> method to define the form’s data model. </span><span class="koboSpan" id="kobo.237.2">This method receives the object, and each attribute receives an array that contains the characteristics of that attribute in the form. </span><span class="koboSpan" id="kobo.237.3">The first element of the array is the initial value of </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">the attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">In the component’s template, we will create the structure of the form, which, in relation to the template-driven form example, is </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">very similar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
&lt;div class="flex h-screen items-center justify-center bg-gray-200"&gt;
  &lt;form
    </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">[formGroup]="entryForm"</span></strong><span class="koboSpan" id="kobo.243.1">
  &gt;
    &lt;input
      type="date"
      id="date"
      name="date"
      </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">formControlName="date"</span></strong><span class="koboSpan" id="kobo.245.1">
    /&gt;
    &lt;input
      type="text"
      id="exercise"
      name="exercise"
      </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">formControlName="exercise"</span></strong><span class="koboSpan" id="kobo.247.1">
    /&gt;
    &lt;input
      type="number"
      id="sets"
      name="sets"
      </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">formControlName="sets"</span></strong><span class="koboSpan" id="kobo.249.1">
    /&gt;
    &lt;input
      type="number"
      id="reps"
      name="reps"
      </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">formControlName="reps"</span></strong><span class="koboSpan" id="kobo.251.1">
    /&gt;
    &lt;button type="submit"&gt;
      Add Entry
    &lt;/button&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.252.1">{{ entryForm.value | json }}</span></strong></pre> <p><span class="koboSpan" id="kobo.253.1">The first difference is the </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.254.1">use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">formGroup</span></strong><span class="koboSpan" id="kobo.256.1"> attribute to associate the template with the object we created earlier. </span><span class="koboSpan" id="kobo.256.2">To associate each template field to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">FormGroup</span></strong><span class="koboSpan" id="kobo.258.1"> attribute, we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">formControlName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1"> element.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">To debug the data model, we are also using the JSON pipe, but note that to get the data model filled in by the user, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">value</span></strong><span class="koboSpan" id="kobo.263.1"> attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">entryForm</span></strong><span class="koboSpan" id="kobo.265.1"> object. </span><span class="koboSpan" id="kobo.265.2">Finally, we will complement the form with functionality and record the input using the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">project’s API.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">The next step is to change </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
export class NewEntryFormReactiveComponent implements OnInit {
  . </span><span class="koboSpan" id="kobo.269.2">. </span><span class="koboSpan" id="kobo.269.3">.
</span><span class="koboSpan" id="kobo.269.4">  private exerciseSetsService = inject(ExerciseSetsService);
  private router = inject(Router);
  . </span><span class="koboSpan" id="kobo.269.5">. </span><span class="koboSpan" id="kobo.269.6">.
</span><span class="koboSpan" id="kobo.269.7">  newEntry() {
    const newEntry = { ...this.entryForm.value };
    this.exerciseSetsService
      .addNewItem(newEntry)
      .subscribe((entry) =&gt; this.router.navigate(['/home']));
  }
}</span></pre> <p><span class="koboSpan" id="kobo.270.1">Here, we inject the</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.271.1"> consumer services of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.273.1"> API and the Angular route </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">service router.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">newEntry</span></strong><span class="koboSpan" id="kobo.277.1"> method, as in the previous example, we capture the data that the user typed. </span><span class="koboSpan" id="kobo.277.2">However, in the reactive form, it is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">value</span></strong><span class="koboSpan" id="kobo.279.1"> attribute, and we send this attribute to the API using </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the service.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">Running the project, we can see that the interface works like its counterpart written for the </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">template-driven form.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.283.1"><img alt="Figure 6.2 – Gym Diary Form UI using a reactive -form" src="image/B19562_06_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.284.1">Figure 6.2 – Gym Diary Form UI using a reactive -form</span></p>
<p><span class="koboSpan" id="kobo.285.1">You may be wondering, what is</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.286.1"> the advantage of using the reactive form and why is it recommended by the Angular community and team? </span><span class="koboSpan" id="kobo.286.2">Next, we’ll see how to use the form’s built-in validations and how to integrate them into our </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">r</span><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.288.1">eactive form.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.289.1">Data validation</span></h1>
<p><span class="koboSpan" id="kobo.290.1">A good UX practice is to validate the </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.291.1">information that users enter in the form as soon as it leaves the filled field. </span><span class="koboSpan" id="kobo.291.2">This minimizes user frustration while improving the information that will be sent to </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">Using reactive forms, we can use utility classes created by the Angular team to add validations that are commonly used in forms. </span><span class="koboSpan" id="kobo.293.2">Let’s improve our project, first in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">NewEntryFormReactiveComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
. </span><span class="koboSpan" id="kobo.296.2">. </span><span class="koboSpan" id="kobo.296.3">.
</span><span class="koboSpan" id="kobo.296.4">import { FormBuilder, FormGroup, Validators } from '@angular/forms';
. </span><span class="koboSpan" id="kobo.296.5">. </span><span class="koboSpan" id="kobo.296.6">.
</span><span class="koboSpan" id="kobo.296.7">export class NewEntryFormReactiveComponent implements OnInit {
. </span><span class="koboSpan" id="kobo.296.8">. </span><span class="koboSpan" id="kobo.296.9">.
 </span><span class="koboSpan" id="kobo.296.10">ngOnInit() {
   this.entryForm = this.formBuilder.group({
     date: ['', Validators.required],
     exercise: ['', Validators.required],
     sets: ['', [Validators.required, Validators.min(0)]],
     reps: ['', [Validators.required, Validators.min(0)]],
   });
 }
newEntry() {
   if (this.entryForm.valid) {
     const newEntry = { ...this.entryForm.value };
     this.exerciseSetsService
       .addNewItem(newEntry)
       .subscribe((entry) =&gt; this.router.navigate(['/home']));
   }
 }
}</span></pre> <p><span class="koboSpan" id="kobo.297.1">In the preceding example, we are </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.298.1">importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">Validators</span></strong><span class="koboSpan" id="kobo.300.1"> package from Angular that will provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">utility</span></strong><span class="koboSpan" id="kobo.302.1"> class for the basic validations of our report. </span><span class="koboSpan" id="kobo.302.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">ngOnInit</span></strong><span class="koboSpan" id="kobo.304.1"> method where we create the reactive form object, the validations are in the second position of the array that defines the </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">form’s fields.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">We use the required validation in all fields of the form, and in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">sets</span></strong><span class="koboSpan" id="kobo.308.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">reps</span></strong><span class="koboSpan" id="kobo.310.1"> fields, we add another validation to guarantee that the number is positive. </span><span class="koboSpan" id="kobo.310.2">To add more than one validation, we can add another array with </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">the validations.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">Another change we made to our component is that it now checks whether the form is valid before starting the interaction with the backend. </span><span class="koboSpan" id="kobo.312.2">We do this by checking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">valid</span></strong><span class="koboSpan" id="kobo.314.1"> attribute of the object. </span><span class="koboSpan" id="kobo.314.2">Angular automatically updates this field as the user </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">enters data.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">In the template file, let’s add the error messages for </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
  &lt;div
    *ngIf="entryForm.get('date')?.invalid &amp;&amp; entryForm.get('date')?.touched"
    class="mt-1 text-red-500"
  &gt;
    Date is required.
</span><span class="koboSpan" id="kobo.318.2">  &lt;/div&gt;
  &lt;div
    *ngIf="
      entryForm.get('exercise')?.invalid &amp;&amp;
      entryForm.get('exercise')?.touched
      "
    class="mt-1 text-red-500"
  &gt;
    Exercise is required.
</span><span class="koboSpan" id="kobo.318.3">  &lt;/div&gt;
   . </span><span class="koboSpan" id="kobo.318.4">. </span><span class="koboSpan" id="kobo.318.5">.
</span><span class="koboSpan" id="kobo.318.6">  &lt;div
    *ngIf="entryForm.get('sets')?.invalid &amp;&amp; entryForm.get('sets')?.touched"
    class="mt-1 text-red-500"
  &gt;
    Sets is required and must be a positive number.
</span><span class="koboSpan" id="kobo.318.7">  &lt;/div&gt;
  &lt;div
    *ngIf="entryForm.get('reps')?.invalid &amp;&amp; entryForm.get('reps')?.touched"
    class="mt-1 text-red-500"
  &gt;
    Reps is required and must be a positive number.
</span><span class="koboSpan" id="kobo.318.8">  &lt;/div&gt;
  &lt;button
    type="submit"
    [disabled]="entryForm.invalid"
    [class.opacity-50]="entryForm.invalid"
  &gt;
    Add Entry
  &lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.319.1">To show validation in the </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.320.1">template, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">div</span></strong><span class="koboSpan" id="kobo.322.1"> elements with the message we want. </span><span class="koboSpan" id="kobo.322.2">To decide whether or not the message will appear, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">ngIf</span></strong><span class="koboSpan" id="kobo.324.1"> directive, checking the status of </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the field.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">For this, we first get the </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.327.1">field using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">GET</span></strong><span class="koboSpan" id="kobo.329.1"> method and check the following </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">two properties:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.331.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">invalid</span></strong><span class="koboSpan" id="kobo.333.1"> property checks whether the field is invalid according to what was configured in </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">the component.</span></span></li>
<li><span class="koboSpan" id="kobo.335.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">touched</span></strong><span class="koboSpan" id="kobo.337.1"> property checks whether the user has accessed the field. </span><span class="koboSpan" id="kobo.337.2">It is recommended not to show all the validations when the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">is loaded.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.339.1">In addition to the validations in each field, to improve usability, we changed the </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">Submission</span></strong><span class="koboSpan" id="kobo.341.1"> button by disabling it while the form was invalid and applying the CSS to make it clear to </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">Running the project, we can see the validations accessing all fields without filling </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">any field.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.345.1"><img alt="Figure 6.3 – Gym Diary Form UI validations" src="image/B19562_06_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.346.1">Figure 6.3 – Gym Diary Form UI validations</span></p>
<p><span class="koboSpan" id="kobo.347.1">We’ve learned how to use Angular’s utility classes to perform validation, so let’s explore how we can create our own </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">cus</span><a id="_idTextAnchor197"/><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.349.1">tom validations.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.350.1">Custom validations</span></h1>
<p><span class="koboSpan" id="kobo.351.1">We can expand the use of validations and</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.352.1"> create custom functions that can even receive parameters to maximize reuse in our projects. </span><span class="koboSpan" id="kobo.352.2">To illustrate this, let’s create a custom validation to evaluate whether the number of repetitions or sets are multiples of two and </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">three, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">Let’s create a new</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.355.1"> file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">custom-validation.ts</span></strong><span class="koboSpan" id="kobo.357.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">following function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
export function multipleValidator(multiple: number): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null =&gt; {
    const isNotMultiple = control.value % multiple !== 0;
    return isNotMultiple ? </span><span class="koboSpan" id="kobo.359.2">{ isNotMultiple: { value: control.value } } : null;
  };
}</span></pre> <p><span class="koboSpan" id="kobo.360.1">For Angular to recognize the form validation function, it must return a new function with the signature described in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">ValidatorFn</span></strong><span class="koboSpan" id="kobo.362.1"> interface. </span><span class="koboSpan" id="kobo.362.2">This signature defines that it will receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">AbstractControl</span></strong><span class="koboSpan" id="kobo.364.1"> and must return an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">ValidationErrors</span></strong><span class="koboSpan" id="kobo.366.1"> that allows the template to interpret the new type </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">of validation.</span></span></p>
<p><span class="koboSpan" id="kobo.368.1">Here, we get the input value using </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">control.value</span></strong><span class="koboSpan" id="kobo.370.1">, and if it is not a multiple of three, we will return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">error</span></strong><span class="koboSpan" id="kobo.372.1"> object. </span><span class="koboSpan" id="kobo.372.2">Otherwise, we will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">null</span></strong><span class="koboSpan" id="kobo.374.1">, which will indicate to Angular that the value </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">is correct.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">To use this function, we are going to refactor our form component </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
. </span><span class="koboSpan" id="kobo.378.2">. </span><span class="koboSpan" id="kobo.378.3">.
</span><span class="koboSpan" id="kobo.378.4">ngOnInit() {
  this.entryForm = this.formBuilder.group({
    date: ['', Validators.required],
    exercise: ['', Validators.required],
    sets: [
      '',
      [Validators.required, Validators.min(0), </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">multipleValidator(2)</span></strong><span class="koboSpan" id="kobo.380.1">],
    ],
    reps: [
      '',
      [Validators.required, Validators.min(0), </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">multipleValidator(3)</span></strong><span class="koboSpan" id="kobo.382.1">],
    ],
  });
}
. </span><span class="koboSpan" id="kobo.382.2">. </span><span class="koboSpan" id="kobo.382.3">.</span></pre> <p><span class="koboSpan" id="kobo.383.1">To use our</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.384.1"> custom function, we import it from the new file we created and use it in the validation array in the construction of the form object in the same way as standard </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">Angular validations.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Finally, let’s change the form template to add the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">error message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
. </span><span class="koboSpan" id="kobo.388.2">. </span><span class="koboSpan" id="kobo.388.3">.
</span><span class="koboSpan" id="kobo.388.4">    &lt;div
      *ngIf="
        entryForm.get('sets')?.errors?.['isNotMultiple'] &amp;&amp;
        entryForm.get('sets')?.touched
      "
      class="mt-1 text-red-500"
    &gt;
      sets is required and must be multiple of 2.
</span><span class="koboSpan" id="kobo.388.5">    &lt;/div&gt;
. </span><span class="koboSpan" id="kobo.388.6">. </span><span class="koboSpan" id="kobo.388.7">.
</span><span class="koboSpan" id="kobo.388.8">    &lt;div
      *ngIf="
        entryForm.get('reps')?.errors?.['isNotMultiple'] &amp;&amp;
        entryForm.get('reps')?.touched
      "
      class="mt-1 text-red-500"
    &gt;
      Reps is required and must be multiple of 3.
</span><span class="koboSpan" id="kobo.388.9">    &lt;/div&gt;
. </span><span class="koboSpan" id="kobo.388.10">. </span><span class="koboSpan" id="kobo.388.11">.</span></pre> <p><span class="koboSpan" id="kobo.389.1">We include the </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.390.1">new </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">div</span></strong><span class="koboSpan" id="kobo.392.1"> elements, but to specifically validate the error of multiples of the input, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">error</span></strong><span class="koboSpan" id="kobo.394.1"> attribute and in it the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">isNotMultiple</span></strong><span class="koboSpan" id="kobo.396.1"> attribute of our </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">custom function.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">We are using this parameter in square brackets because it is defined at runtime and Angular will warn at compile time that it does </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">not exist.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Running our project, we can see the </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">new validations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.402.1"><img alt="Figure 6.4 – Gym Diary Form UI﻿ custom validations" src="image/B19562_06_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.403.1">Figure 6.4 – Gym Diary Form UI</span><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.404.1"> custom validations</span></p>
<p><span class="koboSpan" id="kobo.405.1">In addition to </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.406.1">validations, reactive forms from version 14 of Angular can be better typed to ensure higher productivity and security in the development of your project. </span><span class="koboSpan" id="kobo.406.2">We will go over this function </span><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.407.1">in the </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">next section.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.409.1">Typed reactive forms</span></h1>
<p><span class="koboSpan" id="kobo.410.1">In our project, if we look at the </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.411.1">types of objects and values, we can see that they are all of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">any</span></strong><span class="koboSpan" id="kobo.413.1"> type. </span><span class="koboSpan" id="kobo.413.2">Although functional, it is possible to improve this development experience by better using TypeScript’s </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">type checking.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1"> Let’s refactor our code in the component </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
export class NewEntryFormReactiveComponent {
  private formBuilder = inject(FormBuilder);
  private exerciseSetsService = inject(ExerciseSetsService);
  private router = inject(Router);
  public entryForm = this.formBuilder.group({
    date: [new Date(), Validators.required],
    exercise: ['', Validators.required],
    sets: [0, [Validators.required, Validators.min(0), multipleValidator(2)]],
    reps: [0, [Validators.required, Validators.min(0), multipleValidator(3)]],
  });
  newEntry() {
    if (this.entryForm.valid) {
      const newEntry = { ...this.entryForm.value };
      this.exerciseSetsService
        .addNewItem(newEntry)
        .subscribe((entry) =&gt; this.router.navigate(['/home']));
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.418.1">We moved the creation</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.419.1"> of the form object to the construction of the component and set the initialization of the fields with the types that will be accepted by the API. </span><span class="koboSpan" id="kobo.419.2">Using Visual Studio Code’s IntelliSense, we can see that Angular infers the types and now we have an object very close to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">ExerciseSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">With this change, however, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">addNewItem</span></strong><span class="koboSpan" id="kobo.424.1"> method threw an error, which is actually a good thing, as it means that we are now using TypeScript’s type checking to discover possible bugs that could only appear at runtime. </span><span class="koboSpan" id="kobo.424.2">To resolve this issue, we first need to change the service to receive an object that can contain some of the attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">ExerciseSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">In the service, change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">addNewItem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
addNewItem(item: Partial&lt;ExerciseSet&gt;): Observable&lt;ExerciseSet&gt; {
  return this.httpClient.post&lt;ExerciseSet&gt;(this.url, item);
}</span></pre> <p><span class="koboSpan" id="kobo.432.1">Here, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Partial</span></strong><span class="koboSpan" id="kobo.434.1"> type of TypeScript to inform the function that it can receive an object with part of the interface attributes. </span><span class="koboSpan" id="kobo.434.2">Returning to our component, we can see that it still has an error. </span><span class="koboSpan" id="kobo.434.3">This happens because it can receive </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">null</span></strong><span class="koboSpan" id="kobo.436.1"> values in the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">form’s attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">To resolve this, let’s change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">FormBuilder</span></strong><span class="koboSpan" id="kobo.440.1"> service to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">NonNullableFormBuilder</span></strong><span class="koboSpan" id="kobo.442.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
export class NewEntryFormReactiveComponent {
. </span><span class="koboSpan" id="kobo.444.2">. </span><span class="koboSpan" id="kobo.444.3">.
</span><span class="koboSpan" id="kobo.444.4">  private formBuilder = inject(NonNullableFormBuilder);
. </span><span class="koboSpan" id="kobo.444.5">. </span><span class="koboSpan" id="kobo.444.6">.
</span><span class="koboSpan" id="kobo.444.7">}</span></pre> <p><span class="koboSpan" id="kobo.445.1">With this change, Angular</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.446.1"> itself performs this verification. </span><span class="koboSpan" id="kobo.446.2">The only requirement is that all the form fields are initialized, which we have already </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">done here.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">With that, we have our reactive form working and can now use TypeScript’s type-che</span><a id="_idTextAnchor203"/><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.449.1">cking </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">more effectively!</span></span></p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.451.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.452.1">In this chapter, we explored Angular forms and how to use them to improve our user experience and our team’s productivity. </span><span class="koboSpan" id="kobo.452.2">We learned how to use template forms for simpler requirements and explored how Angular performs the binding between the HTML and the data model using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">ngModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1"> We also work with reactive forms, which opens up many possibilities for creating and manipulating forms. </span><span class="koboSpan" id="kobo.455.2">Regarding reactive forms, we studied how to apply validations to fields and how to create our own custom validation functions. </span><span class="koboSpan" id="kobo.455.3">Finally, we refactored our reactive form to use TypeScript type checking using </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">typed forms.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">In the next chapter, we will explore Angular’s routing mechanism and the possibilities it can ha</span><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.458.1">ve for </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">our applications.</span></span></p>
</div>
</body></html>