- en: Lists - Display Simple Collection Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using state to render list items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List avatars and text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `List` component in Material-UI is used to render data collections. Lists
    are like tables, only simpler. If you need to display an array of users, for example, you
    can render them in a list, showing only the most relevant data, instead of several
    properties in a tabular format. Material-UI lists are generic and provide a lot
    of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Using state to render list items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data source used to render `List` components often comes from the state
    of your component. A collection—usually an array of objects—is mapped to `ListItem`
    components. As the objects in this array change, the Material-UI list items change
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have an array of three objects that you need to display
    as a list on one of your screens. You can add this array to the state of your
    component, then map each array item to a `ListItem` component. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what you''ll see when you first load the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94276506-36f9-41c5-80a9-64c12c56496a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `items` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` property is the `primary` text, and the `timestamp` property is
    the `secondary` text for each list item. Next, let''s look at the `List` markup
    that transforms this state into rendered list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ListItem` component has two Boolean properties passed to it – `button`
    and `dense`. The `button` property makes the list item behave like a button. For
    example, if you move your mouse pointer over an item in the list, you'll see the
    hover styles applied to it. The `dense` property removes extra padding from the
    list item. Without this property, the list takes up more space on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListItemText` component uses the `primary` and `secondary` properties to
    render the `name` and `timestamp` properties respectively. The `primary` text
    is meant to stand out relative to the `secondary` information displayed in the
    item – in this case, the `timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example could have used props instead of state, because the items never
    changed. Let''s modify it so that the user can select items from the list. Here''s
    what the new `List` markup looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `selected` property passed to the `ListItem` component will apply selected
    styles to the item when `true`. This value comes from the `item.selected` state,
    which is `false` by default for every item (nothing is selected). Next, the `ListItem`
    component has an `onClick` handler.
  prefs: []
  type: TYPE_NORMAL
- en: The `ListItemText` component also has styles applied to it based on the selected
    state of the item. Behind the scenes, item text is rendered using the `Typography`
    component. You can use the `primaryTypographyProps` property to pass properties
    to the `Typography` component. In this case, you're changing the `color` of the
    text to `primary` when it's selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `onClick()` handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a higher-order function, which returns an event handler function based
    on the `index` argument. It toggles the selected state for the item at the given
    index.
  prefs: []
  type: TYPE_NORMAL
- en: The `onClick` property isn't a `ListItem` property. It's a `button` property.
    Since you've set the `button` property to `true`, `ListItem` uses a `button` property
    and passes it to your `onClick` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the list looks like when First Item is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ae5643d-2472-454a-bd5a-0104eea6d755.png)'
  prefs: []
  type: TYPE_IMG
- en: The change to the background color is caused by the selected property of `ListItem`.
    The change to the text color is caused by the `primaryTypographyProps` property
    of `ListItemText`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` demos: [https://material-ui.com/demos/lists/](https://material-ui.com/demos/lists/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Typography` API documentation: [https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ListItem` components have first-class support for icons. By rendering icons
    in each list item, you can make it clear to the user what types of objects are
    displayed in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have an array of user objects that you want to render in
    a `List`. You could render each item with a user icon to make it clear what each
    item in the list is. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you load the screen, this is what the list should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a97d33c-9391-4968-8c8a-f40ec04cd137.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ListItemIcon` component can be used as a child of `ListItem` components.
    In the previous example, it comes before the text, so it ends up to the left of
    the item text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You could place the icon after the text as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e1235f3-5d00-43c5-923e-004d4bb25ea5.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can mark `ListItem` components as selected by setting the `selected` property
    to `true`. You can also change the icon to give a better visual indication that
    an item has been selected. Here''s the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the list looks like with First User selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62929b69-1f2a-4163-8a45-8201860a0956.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The icon for the selected items changes into a circled checkmark. Let''s break
    down the changes that were introduced to make this happen, starting with the `MaybeSelectedIcon`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will render either `CheckCircleOutlineIcon` or the `Icon` component
    that is passed in as a property. This depends on the `selected` property. Next,
    let''s look at how this component is used inside `ListItemIcon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When a list item is clicked on, the `selected` state for that item is toggled.
    Then, the `selected` state is passed to `MaybeSelectedIcon`. The `AccountCircleIcon`
    component is the icon that's rendered when the list item isn't selected, because
    it's passed to the `Icon` property.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` demos: [https://material-ui.com/demos/lists/](https://material-ui.com/demos/lists/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListItemIcon` API documentation: [https://material-ui.com/api/list-item-icon/](https://material-ui.com/api/list-item-icon/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List avatars and text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your list items have `primary` and `secondary` text, using an icon on its
    own can be less visually appealing than with an avatar surrounding the icon. It
    fills the space within the list item better.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have four categories of messages that can be displayed
    by your app. To access a given category, the user clicks on one of the list items.
    To help the user understand the categories, you''ll use icons. And to make the
    icons stand out against the `primary` and `secondary` text of the list item, you''ll
    wrap it with an `Avatar` component. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the list looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d61c49f7-3d39-4b51-8fbc-ca11ddcf042b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The circle that surrounds the icon is the `Avatar` component, and it helps
    the icon stand out. Here''s what this list looks like without avatars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/696b5773-89c1-45a4-a07f-45fc82433fac.png)'
  prefs: []
  type: TYPE_IMG
- en: It's the same content and the same icons, but because of the height of the list
    item text, there's a lot of excess space surrounding the icon. The `Avatar` component
    helps fill this space while drawing attention to the icon.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Avatar` component is used on icons with a circular shape. The color of
    the circle comes from the theme palette – the shade of grey used depends on whether
    the theme is light or dark. The icon itself is passed as the child element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you use an `Avatar` with the icons in your list items, you can change the
    color of the `Avatar` and you can apply a badge to indicate unacknowledged actions
    to be taken. Let''s modify the example so that each item in the items state can
    have a `notifications` property; that is, a number representing the number of
    unread messages for the category. If this number is greater than 0, you can change
    the `Avatar` color and display number of `notifications` in a badge. Here''s what
    the result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d35471a6-7ea4-4786-89ea-fae941c44423.png)'
  prefs: []
  type: TYPE_IMG
- en: The first item in the list has an `Avatar` that's using the primary `theme`
    color and a badge showing the number of `notifications`. The rest of the items
    don't have any `notifications`, so the `Avatar` color uses the default, and the
    badge isn't displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this is done, starting with the styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `activeAvatar` style is applied to the `Avatar` component when the `notifications`
    state is a number greater than 0\. It looks up the primary `theme` color based
    on the theme type (light or dark). Next, let''s look at the state of the first
    item in the items array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `notifications` value is `1`, the color of the avatar changes,
    and the badge is displayed. Lastly, let''s see how all of this comes together
    in the component markup using the `Badge` and `Avatar` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `color` property of `Badge` is based on the `notifications` state of the
    item being greater than 0\. If it is, the primary color is used. If it isn't,
    `undefined` is passed to `Badge`. In this case, this is necessary so that an empty
    badge circle doesn't show up when there aren't any notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Passing `undefined` as a property value is equivalent to not setting the property
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `badgeContent` property is set based on the `notifications` state
    of the item. If it's not greater than 0, then you don't want any value set. Finally,
    setting the color of the `Avatar` component uses `clsx()` to apply the `activeAvatar`
    class if the `notifications` state for the item is greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Badge` demos: [https://material-ui.com/demos/badges/](https://material-ui.com/demos/badges/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avatar` demos: [https://material-ui.com/demos/avatars/](https://material-ui.com/demos/avatars/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List` demos: [https://material-ui.com/demos/lists/](https://material-ui.com/demos/lists/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your lists have more than just a few items in them, you might want to consider
    organizing the items into sections. To do this, you split your lists into several
    smaller lists, which are stacked on top of one another with a divider in between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have several list items that can be divided into three
    sections. You can use three `List` components to group your items into their respective
    sections, and use a `Divider` component to visually indicate the section boundary
    for the user. Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the rendered list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec27a12f-f55d-421a-b5e3-8991cbf43b87.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each section is its own `List` component, with its own `ListItem` components.
    The `Divider` component separates the lists. For example, the first section looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of having a `Divider` component separate your list sections, you can
    use `Typography` to label your sections. This could help your users make sense
    of the items in each section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the list looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b49890e-e663-4f48-ad56-a0cbd12cf698.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` demos: [https://material-ui.com/demos/lists/](https://material-ui.com/demos/lists/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Typography` API documentation: [https://material-ui.com/api/typography/](https://material-ui.com/api/typography/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists can be nested. This is useful when you have a large number of items to
    render. Instead of showing everything all at once, you can only display those
    item categories. Then the user can click on these categories to display the items.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have two item categories. When the user clicks on a category,
    the items in that category should be displayed. Here''s the code to do this, by
    using the `List` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first load the screen, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3b01e21-0be0-4c9c-a1aa-082685c016e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on each of these categories, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f278173-7b83-4634-bcc2-b76537911c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you click on a category, the down arrow icon changes to an up arrow. Beneath
    the category, the list items belonging to that category are displayed. Let''s
    break down what''s happening in this code, starting with the component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Each object in the items array represents a list category. In this case, the
    categories are `Messages` and `Contacts`. The `Icon` property is the icon component
    to render for the category. The `expanded` property determines the state of the
    expand arrow icon, and whether or not the items in the category should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `children` array contains the items that belong to the category. They have
    a `name` and an `Icon` property just like the category items, because they're
    all rendered using `ListItem` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the markup used to render each category and its child
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The category `ListItem` component has an `onClick` handler that toggles the
    `expanded` state of the category. Next, the `Collapse` component is used to control
    the visibility of the child items of the category, based on the value of `expanded`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can improve on the appearance of your nested list by differentiating the
    appearance of the sub-items. Right now, the only difference between the category
    items and subitems is that the category items have expand and collapse arrows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, list items are indented to indicate that they''re part of another
    item in the hierarchy. Let''s create a style that will allow you to indent subitems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paddingLeft` style property will shift everything in the list item to
    the right. Now, let''s apply this class to `subItem` while also making the item
    smaller than the category items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `dense` and the `className` properties to `ListItem`, your users
    should be more easily able to differentiate between the category and its subitems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca35d0b4-d02d-4886-b3e2-743e689d23ad.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` demos: [https://material-ui.com/demos/lists/](https://material-ui.com/demos/lists/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collapse` API documentation: [https://material-ui.com/api/collapse/](https://material-ui.com/api/collapse/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List items can be clickable, resulting in a change in state, or a link being
    followed, or something else entirely. This is the primary action of the item.
    You can have secondary actions on lists called controls. These are common actions
    that you might perform, depending on the type of item.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have a list of devices. When you click on a list item,
    it might take you to a details page for the device. Each device has Bluetooth
    connectivity that can be toggled on or off. This is a good candidate secondary
    action to render in the item. Here''s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the screen looks like when it first loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84d6128b-bdbc-489d-a004-910521d8d36d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can toggle the Bluetooth state of one of the items by clicking on the icon
    buttons. Here''s what it looks like after toggling the Bluetooth state of the
    first item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18e9886d-4239-4341-b5e0-863729df9965.png)'
  prefs: []
  type: TYPE_IMG
- en: The Bluetooth icon has changed to indicate the `disabled` state. Clicking on
    the icon again will enable Bluetooth.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the markup that''s used to render each list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListItemSecondaryAction` component is used as a container for any controls
    in your list item. In this example, an `IconButton` is used as the control. It
    shows a different icon depending on the state of the item, using the `MaybeBluetoothIcon`
    component. The `onBluetoothClick()` function is used to return the event handler
    function for the item. Let''s take a look at this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The device item is looked up in the `items` array. Then, the Bluetooth state
    is toggled, and the new `items` array is returned to set as the new state. This
    results in the updated icon in the list item control.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can have more than one control in your list item. For example, let's say
    that in addition to toggling the Bluetooth state of a device, another common action
    for your users is toggling the `power` state of the device. When the device is
    powered off, the list item and the Bluetooth control should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid having too many controls as secondary actions in your list items. Doing
    so detracts from the convenience of having one or two common actions easily accessible
    by your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a new `power` state to each item in your component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a toggle click handler that can handle updating both the
    Bluetooth and the `power` state of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the `onBluetoothClick()` handler. Now, it accepts an
    additional `prop` argument. This is used to tell the function which property to
    update – `bluetooth` or `power`. Finally, let''s look at the updated `ListItem`
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `disabled` property of `ListItem` depends on  the `power` state of the item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's another `IconButton` control for toggling the `power` state of the item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onToggleClick()` function is used by both controls to toggle the state
    of the item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how the screen looks now, when first loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a24567fe-1600-4059-a6b3-b60dd23d470e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on the power icon, the list item and the Bluetooth button become
    disabled. Here''s what it looks like when the first item is powered off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a714fd66-3ce9-44a2-9b34-e0f5b5f22682.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ListItemSecondaryAction` API documentation: [https://material-ui.com/api/list-item-secondary-action/](https://material-ui.com/api/list-item-secondary-action/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IconButton` API documentation: [https://material-ui.com/api/icon-button/](https://material-ui.com/api/icon-button/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your lists contain a limited number of items in them, you're safe to just
    iterate over the item data, and render `ListItem` components. This becomes a problem
    when you have the potential for lists with over 1,000 items in them. You can render
    these items fast enough, but having this many items in the **Document Object Model**
    (**DOM**) eats a lot of browser resources, and can lead to unpredictable performance
    challenges for the user. The solution is to virtualize your Material-UI lists
    using `react-virtualized`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say that you have a list of 1,000 items in it. You want to render these
    items inside a list with a fixed height. In order to provide predictable performance
    characteristics for your users, you only want to render items that are actually
    visible to the user as they scroll through the list. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When you first load the screen, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/968263e2-fde7-4907-9cee-79eafd2ab234.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you scroll through the list, here''s what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/165daa3f-47fc-46df-bdf3-00593ab6c915.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, here''s what the bottom of the list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c148fa82-2065-4378-ac8f-0dc5585ff994.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s take a look at how the `items` state is generated. First, there''s
    a `genItems()` generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the spread operator is used to turn the generated `items` into an array
    for the component state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the `rowRenderer()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This function returns the `ListItem` component that should be rendered at the
    given index. Instead of manually mapping this component to `items`, the `List`
    component from `react-virtualized` orchestrates when to call it for you, based
    on how the user scrolls through the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `key` and the `style` values that are passed to this function are required
    by `react-virtualized` in order to work correctly. For example, the `style` value
    is used to control the visibility of the item as scrolling happens. The `isScrolling`
    value is used to render different data while the list is actively being scrolled.
    For example, imagine that instead of just a text label within the list item, you
    also had an icon, along with other controls that are all based on state. Trying
    to render these things while scrolling is going on is expensive and wasteful.
    Instead, you can render something that''s less resource intensive, such as a placeholder
    string: `''...''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s examine the markup used to render this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `List` component is the container for everything else. Next, the `AutoSizer`
    component from `react-virtualized` figures out the width of the list, which is
    needed as a `VirtualList` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`List` is imported from `react-virtualized` using the alias `VirtualList`.
    This is to avoid the naming conflict with `List` from `material-ui`. You could
    import `List` from `material-ui` as an alias instead, if you prefer.'
  prefs: []
  type: TYPE_NORMAL
- en: The `List` component from `react-virtualized` also takes the height of the list,
    the height of each row, and the row count, in order to determine which rows to
    render. With this in place, you never have to worry about the performance of your
    application because of a list component with too many items.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Virtualized documentation: [https://bvaughn.github.io/react-virtualized/](https://bvaughn.github.io/react-virtualized/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List` demos: https://material-ui.com/demos/lists/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
