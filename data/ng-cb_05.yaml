- en: '*Chapter 5*: Angular and RxJS – Awesomeness Combined'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：Angular和RxJS - 令人敬畏的组合'
- en: Angular and RxJS create a killer combination of awesomeness. By combining these,
    you can handle your data reactively, work with streams, and do really complex
    stuff in your Angular apps. That's exactly what you're going to learn in this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Angular和RxJS结合起来，创造了一种令人敬畏的组合。通过结合它们，您可以以响应式的方式处理数据，处理流，并在Angular应用程序中执行非常复杂的操作。这正是您将在本章中学到的内容。
- en: 'Here are the recipes we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要涵盖的示例：
- en: Working with RxJS operators using instance methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实例方法处理RxJS操作符
- en: Working with RxJS operators using static methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态方法处理RxJS操作符
- en: Unsubscribing streams to avoid memory leaks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消订阅流以避免内存泄漏
- en: Using an Observable with the `async` pipe to synchronously bind data to your
    Angular templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`async`管道与Observable同步绑定数据到您的Angular模板
- en: Using `combineLatest` to subscribe to multiple streams together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`combineLatest`同时订阅多个流
- en: Using the `flatMap` operator to create sequential **HyperText Transfer Protocol**
    (**HTTP**) calls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`flatMap`操作符创建顺序的**超文本传输协议**（**HTTP**）调用
- en: Using the `switchMap` operator to switch the last subscription with a new one
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`switchMap`操作符将最后一个订阅切换为新的订阅
- en: Debouncing HTTP requests using RxJS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS进行去抖动HTTP请求
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your Terminal. The code
    for this chapter can be found at the following link: [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter05](
    https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter05).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，请确保您的计算机上已安装了**Git**和**Node.js**。您还需要安装`@angular/cli`包，可以在终端中使用`npm
    install -g @angular/cli`来安装。本章的代码可以在以下链接找到：[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter05](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter05)。
- en: Working with RxJS operators using instance methods
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实例方法处理RxJS操作符
- en: In this recipe, you'll learn to use RxJS operators' instance methods to work
    with streams. We'll start with a basic app in which you can start listening to
    a stream with the `interval` method. We'll then introduce some instance methods
    in the subscription to modify the output.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用RxJS操作符的实例方法来处理流。我们将从一个基本应用程序开始，在该应用程序中，您可以使用`interval`方法开始监听流。然后，我们将在订阅中引入一些实例方法来修改输出。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project that we are going to work with resides in `chapter05/start_here/rxjs-operators-instance-methods`,
    inside the cloned repository.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter05/start_here/rxjs-operators-instance-methods`，在克隆的存储库中。
- en: Open the project in **Visual Studio Code** (**VS Code**).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Visual Studio Code**（**VS Code**）中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. Tap the **Start Stream** button,
    and you should see something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。点击**开始流**按钮，您应该会看到类似这样的东西：
- en: '![Figure 5.1 – The rxjs-operators-instance-methods app running on http://localhost:4200'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 - rxjs-operators-instance-methods应用程序在http://localhost:4200上运行'
- en: '](image/Figure_5.1_B15150.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.1_B15150.jpg)'
- en: Figure 5.1 – The rxjs-operators-instance-methods app running on http://localhost:4200
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - rxjs-operators-instance-methods应用程序在http://localhost:4200上运行
- en: Now that we have the app running, we will move on to the steps for the recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，我们将继续进行示例的步骤。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: We have an Angular app that has some things already set up. By tapping the **Start
    Stream** button, we can start viewing the stream output that is using the `interval`
    method from RxJS to create an Observable that outputs a sequence of numbers from
    `0` onward. We'll use some operators to show the elements from our `inputStreamData`
    array instead, which is the goal of this recipe. Let's begin.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个Angular应用程序，已经设置了一些东西。通过点击**开始流**按钮，我们可以开始查看使用RxJS的`interval`方法创建输出从`0`开始的数字序列的Observable的流输出。我们将使用一些操作符来显示来自我们的`inputStreamData`数组的元素，这是本教程的目标。让我们开始吧。
- en: First, we'll use the `map` operator to make sure that we are mapping the numbers
    generated from the `interval` Observable to the valid indices of our array. For
    this, we'll update the `app.component.ts` file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`map`操作符确保我们将从`interval` Observable生成的数字映射到我们数组的有效索引。为此，我们将更新`app.component.ts`文件。
- en: 'We have to make sure that the mapped numbers are not greater than or equal
    to the length of `inputStreamData`. We''ll do this by taking a modulus on the
    number each time, using the `map` operator as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保映射的数字不大于或等于`inputStreamData`的长度。我们将使用`map`操作符每次对数字取模来做到这一点，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you tap the **Start Stream** button now, you''ll see that the output we
    get is `0, 1, 2, 0, 1, 2`... and so forth. This makes sure we can always get an
    item from the `inputStreamData` array using the number as an index:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在点击**开始流**按钮，您会看到我们得到的输出是`0, 1, 2, 0, 1, 2`...等等。这确保我们始终可以使用数字作为索引从`inputStreamData`数组中获取项目：
- en: '![Figure 5.2 – The stream outputs a 0,1,2.. sequence using the modulus on inputStreamData.length'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 - 流使用inputStreamData.length上的模数输出0,1,2..序列'
- en: '](image/Figure_5.2_B15150.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.2_B15150.jpg)'
- en: Figure 5.2 – The stream outputs a 0,1,2.. sequence using the modulus on inputStreamData.length
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 流使用inputStreamData.length上的模数输出0,1,2..序列
- en: 'Now, we''ll use another `map` method to fetch an element from the array for
    each of the stream''s outputs, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用另一个`map`方法来获取数组中每个流输出的元素，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that we''ve renamed the parameter of the `subscribe` method as `element`
    instead of `input`. This is because we get an element in the end. See the following
    screenshot, demonstrating how the stream outputs the elements from `inputStreamData`
    using indices:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已将`subscribe`方法的参数重命名为`element`而不是`input`。这是因为最终我们得到了一个元素。请参阅以下屏幕截图，演示了流如何使用索引输出来自`inputStreamData`的元素：
- en: '![Figure 5.3 – The stream outputs elements from inputStreamData using indices'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 流使用索引从inputStreamData输出元素'
- en: '](image/Figure_5.3_B15150.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.3_B15150.jpg)'
- en: Figure 5.3 – The stream outputs elements from inputStreamData using indices
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 流使用索引从inputStreamData输出元素
- en: 'Now, to make things more interesting, we''ll create another stream that will
    emit cartoon titles using the same `interval` method approach, but with a `1000ms`
    interval. Add the following code to your `startStream` method:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了使事情更有趣，我们将创建另一个流，使用相同的`interval`方法来发出卡通标题，但间隔为`1000ms`。将以下代码添加到您的`startStream`方法中：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ll also create stream data named `cartoonStreamData` (used in the previous
    code) in the `AppComponent` class as a property. The code should look like this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将在`AppComponent`类中创建名为`cartoonStreamData`的流数据（在先前的代码中使用）。代码应该是这样的：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have the `cartoonsStreamData` stream data in place, we can also
    add that to our template so that we can show it on the view as well. The children
    of the `<div class="input-stream">` element in `app.component.html` should look
    like this:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将`cartoonsStreamData`流数据放在了适当的位置，我们还可以将其添加到模板中，以便我们也可以在视图上显示它。在`app.component.html`中`<div
    class="input-stream">`元素的子元素应该是这样的：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we'll use the `merge` (instance) method to combine the two streams and
    add an element from the respective stream data array when the streams emit a value.
    Interesting, right?
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `merge`（实例）方法来合并这两个流，并在流发出值时从各自的流数据数组中添加一个元素。有趣，对吧？
- en: 'We''ll achieve this using the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码来实现这一点：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The usage of the `merge` method as an instance method is deprecated in favor
    of the static `merge` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `merge` 方法作为实例方法的用法已被弃用，推荐使用静态的 `merge` 方法。
- en: 'Great! You have now implemented the entire recipe, with an interesting merge
    of two streams. The following screenshot shows the final output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您现在已经实现了整个食谱，实现了两个流的有趣合并。以下截图显示了最终输出：
- en: '![Figure 5.4 – Final output of the recipe'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 食谱的最终输出'
- en: '](image/Figure_5.4_B15150.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.4_B15150.jpg)'
- en: Figure 5.4 – Final output of the recipe
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 食谱的最终输出
- en: Let's move on to the next section to understand how it all works.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `map` operator provides you the stream's output value, and you're supposed
    to return a value that you want to map it to. We made sure that we converted the
    autogenerated sequential numbers to the array's indices by taking a modulus of
    the array's length. Then, we used another `map` operator on top of these indices
    to fetch the actual element from the array. Finally, we created another stream
    and used the `merge` method to combine the outputs of both streams and add this
    to the `outputStreamData` array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 操作符为您提供了流的输出值，您应该返回要将其映射到的值。我们确保通过取数组长度的模数将自动生成的顺序数字转换为数组的索引。然后，我们在这些索引之上使用另一个
    `map` 操作符来获取数组中的实际元素。最后，我们创建了另一个流，并使用 `merge` 方法来合并这两个流的输出，并将其添加到 `outputStreamData`
    数组中。'
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Catch the Dot Game*—RxJS documentation ([https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game](https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game))'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抓住小点游戏*—RxJS 文档（[https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game](https://www.learnrxjs.io/learn-rxjs/recipes/catch-the-dot-game)）'
- en: RxJS `map` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map))
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `map` 操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map)）
- en: RxJS `merge` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/merge](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge))
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `merge` 操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/combination/merge](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge)）
- en: Working with RxJS operators using static methods
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态方法处理 RxJS 操作符
- en: In this recipe, you'll learn to use RxJS operators' static methods to work with
    streams. We'll start with a basic app in which you can start listening to a stream
    with the `interval` method. We'll then introduce some static methods in the subscription
    to modify the output, to see it on the **user interface** (**UI**). After that,
    we'll split the streams using the `partition` static operator. And finally, we'll
    be merging the partitioned streams using the `merge` static operator to see their
    output.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习使用 RxJS 操作符的静态方法来处理流。我们将从一个基本应用程序开始，在该应用程序中，您可以使用 `interval` 方法开始监听流。然后，我们将在订阅中引入一些静态方法来修改输出，以在**用户界面**（**UI**）上看到它。之后，我们将使用
    `partition` 静态操作符来拆分流。最后，我们将使用 `merge` 静态操作符来合并分区流，以查看它们的输出。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project for this recipe resides in `chapter05/start_here/rxjs-operators-static-methods`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的项目位于 `chapter05/start_here/rxjs-operators-static-methods`。
- en: Open the project in VS Code.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器标签中打开应用程序，你应该能够看到类似这样的东西：
- en: '![Figure 5.5 – The rxjs-operators-static-methods app running on http://localhost:4200'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – rxjs-operators-static-methods应用程序在http://localhost:4200上运行'
- en: '](image/Figure_5.5_B15150.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.5_B15150.jpg)'
- en: Figure 5.5 – The rxjs-operators-static-methods app running on http://localhost:4200
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – rxjs-operators-static-methods应用程序在http://localhost:4200上运行
- en: 'We also have the following data, which is composed of both movies and cartoons,
    and this is what we''ll get as the output of the streams:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有以下数据，其中包括电影和卡通，这将是流的输出结果：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序在本地运行，让我们在下一节中看一下配方的步骤。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We have an Angular app in hand that has some data in an array called `combinedStreamData`.
    By tapping the **Start Stream** button, we can start viewing the output of the
    stream in both the **Movies** output section and the **Cartoons** output section.
    We'll use the `partition` and `merge` operators to get the desired output and
    also to show the count of movies and the cartoons shown on output at the moment.
    Let's begin.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手头有一个Angular应用程序，其中有一个名为`combinedStreamData`的数组中有一些数据。通过点击**开始流**按钮，我们可以开始查看流在**电影**输出部分和**卡通**输出部分的输出。我们将使用`partition`和`merge`操作符来获得期望的输出，并且还会显示当前输出的电影和卡通数量。让我们开始吧。
- en: 'First, we''ll import the `partition` and `merge` operators from RxJS (unlike
    how we imported it from `rxjs/operators` in the previous recipe). The import should
    look like this in the `app.component.ts` file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从RxJS中导入`partition`和`merge`操作符（与之前的配方不同，我们不是从`rxjs/operators`中导入）。在`app.component.ts`文件中，导入应该如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we''ll create two properties, `movies` and `cartoons`, in the `AppComponent`
    class, one to hold the movies and one to hold the cartoons:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`AppComponent`类中创建两个属性，`movies`和`cartoons`，一个用于保存电影，一个用于保存卡通：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And now, we''ll use the appropriate variables in the template for movies and
    cartoons, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在模板中使用适当的变量来表示电影和卡通，步骤如下：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''ll now use the `partition` operator to create two streams out of the `streamSource`
    property. Your `startStream` method should look like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用`partition`操作符从`streamSource`属性创建两个流。你的`startStream`方法应该如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have the streams split up, we can merge those to subscribe to a
    single stream, push to the appropriate output array, and just log the value to
    the console as the output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将流拆分，我们可以合并它们以订阅单个流，推送到适当的输出数组，并将值记录到控制台输出。
- en: 'Let''s merge the streams now, and we''ll add them to the appropriate output
    array using the `tap` operator, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们合并这些流，然后使用`tap`操作符将它们添加到适当的输出数组中，步骤如下：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this change, you should be able to see the correct value in the appropriate
    container—that is, whether it is a movie or a cartoon. See the following screenshot,
    which shows how the partitioned streams emit values to the appropriate Observables:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，你应该能够在适当的容器中看到正确的数值——也就是说，无论是电影还是卡通。请参考以下截图，显示了分区流如何向适当的Observables发出数值：
- en: '![Figure 5.6 – Partitioned streams outputting data to the appropriate views'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 分区流将数据输出到适当的视图'
- en: '](image/Figure_5.6_B15150.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.6_B15150.jpg)'
- en: Figure 5.6 – Partitioned streams outputting data to the appropriate views
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 分区流将数据输出到适当的视图
- en: 'Finally, since we have merged the stream, we can use `console.log` to see each
    value being output. We''ll remove the `outputStreamData` property from `AppComponent`
    and use a `console.log` statement instead of pushing to `outputStreamData` in
    the `subscribe` block, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于我们已经合并了流，我们可以使用`console.log`来查看每个输出的值。我们将从`AppComponent`中删除`outputStreamData`属性，并在`subscribe`块中使用`console.log`语句而不是推送到`outputStreamData`，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As soon as you refresh the app, you should see the logs on the console, as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦刷新应用程序，您应该在控制台上看到如下日志：
- en: '![Figure 5.7 – Logs on console for each output in the subscribe block from
    the merged streams'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 - 合并流中订阅块中每个输出的控制台日志'
- en: '](image/Figure_5.7_B15150.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.7_B15150.jpg)'
- en: Figure 5.7 – Logs on console for each output in the subscribe block from the
    merged streams
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 - 合并流中订阅块中每个输出的控制台日志
- en: Great! You now know how to use static operators from RxJS (specifically, `partition`
    and `merge`) to work with streams in real-life use cases. See the next section
    on how this works.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何使用RxJS的静态操作符（特别是`partition`和`merge`）来处理实际用例中的流。请参阅下一节，了解其工作原理。
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: RxJS has a bunch of static operators/methods that we can use for our particular
    use cases. In this recipe, we used the `partition` operator to create two different
    streams based on the `predicate` function provided as the second argument, which
    returns an array with two Observables. The first one will contain all values that
    satisfy the predicate, and the second one will contain all values that don't satisfy
    the predicate. *Why did we split the streams?* Glad you asked. Because we needed
    to show the appropriate outputs in different output containers. And what's GREAT
    is that we merged those streams later on so that we only had to subscribe to one
    stream, and we could then unsubscribe from that very stream as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS有一堆静态操作符/方法，我们可以根据特定的用例来使用。在这个示例中，我们使用`partition`操作符根据作为第二个参数提供的`predicate`函数创建了两个不同的流，它返回一个包含两个Observables的数组。第一个将包含满足谓词的所有值，第二个将包含不满足谓词的所有值。*为什么要分割流？*很高兴你问。因为我们需要在不同的输出容器中显示适当的输出。而且很棒的是，我们后来合并了这些流，这样我们只需要订阅一个流，然后也可以取消订阅这个流。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: RxJS `map` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map))
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `map`操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/transformation/map](https://www.learnrxjs.io/learn-rxjs/operators/transformation/map)）
- en: RxJS `merge` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/merge](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge))
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `merge`操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/combination/merge](https://www.learnrxjs.io/learn-rxjs/operators/combination/merge)）
- en: RxJS `partition` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/partition](https://www.learnrxjs.io/learn-rxjs/operators/transformation/partition))
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS `partition`操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/transformation/partition](https://www.learnrxjs.io/learn-rxjs/operators/transformation/partition)）
- en: Unsubscribing streams to avoid memory leaks
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅流以避免内存泄漏
- en: Streams are fun to work with and they're awesome, and you'll know much more
    about RxJS when you've finished this chapter, although problems occur when streams
    are used without caution. One of the biggest mistakes to do with streams is to
    not unsubscribe them when we no longer need them, and in this recipe, you'll learn
    how to unsubscribe streams to avoid memory leaks in your Angular apps.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 流很有趣，而且很棒，当你完成这一章时，你会对RxJS有更多了解，尽管在不小心使用流时会出现问题。在处理流时最大的错误之一是在不再需要时不取消订阅它们，而在这个示例中，您将学习如何取消订阅流以避免在Angular应用程序中出现内存泄漏。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project for this recipe resides in `chapter05/start_here/rxjs-unsubscribing-streams`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的项目位于`chapter05/start_here/rxjs-unsubscribing-streams`中。
- en: Open the project in VS Code.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，您应该会看到类似于这样的东西：
- en: '![Figure 5.8 – The rxjs-unsubscribing-streams app running on http://localhost:4200'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – rxjs-unsubscribing-streams应用程序在http://localhost:4200上运行'
- en: '](image/Figure_5.8_B15150.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.8_B15150.jpg)'
- en: Figure 5.8 – The rxjs-unsubscribing-streams app running on http://localhost:4200
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – rxjs-unsubscribing-streams应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看一下配方的步骤。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We currently have an app with two routes—that is, **Home** and **About**. This
    is to show you that unhandled subscriptions can cause memory leaks in an app.
    The default route is **Home**, and in the `HomeComponent` class, we handle a single
    stream that outputs data using the `interval` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有一个具有两个路由的应用程序，即**主页**和**关于**。这是为了向您展示未处理的订阅可能会导致应用程序内存泄漏。默认路由是**主页**，在`HomeComponent`类中，我们处理一个使用`interval`方法输出数据的单个流。
- en: Tap the **Start Stream** button, and you should see the stream emitting values.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开始流**按钮，您应该看到流发出值。
- en: Then, navigate to the **About** page by tapping the **About** button from the
    header (top right), and then come back to the **Home** page.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过点击页眉（右上角）的**关于**按钮导航到**关于**页面，然后返回到**主页**。
- en: What do you see? Nothing? Everything looks fine, right? Well, not exactly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么？什么都没有？一切看起来都很好，对吧？嗯，并不完全是这样。
- en: 'To see whether we have an unhandled subscription, which is an issue, let''s
    put a `console.log` inside the `startStream` method in the `home.component.ts`
    file—specifically, inside the `.subscribe` method''s block, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看我们是否有未处理的订阅（这是一个问题），让我们在`home.component.ts`文件中的`startStream`方法内放置一个`console.log`，具体来说，在`.subscribe`方法的块内，如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you now perform the same steps as mentioned in *Step 1*, you''ll see the
    following output on the console:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在执行与*步骤1*中提到的相同步骤，您将在控制台上看到以下输出：
- en: '![Figure 5.9 – The rxjs-unsubscribing-streams app running on http://localhost:4200'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – rxjs-unsubscribing-streams应用程序在http://localhost:4200上运行'
- en: '](image/Figure_5.9_B15150.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.9_B15150.jpg)'
- en: Figure 5.9 – The rxjs-unsubscribing-streams app running on http://localhost:4200
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – rxjs-unsubscribing-streams应用程序在http://localhost:4200上运行
- en: Want to have some more fun? Try performing *Step 1* a couple of times without
    refreshing the page even once. What you'll see will be **CHAOS**!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 想要再玩一些吗？尝试执行*步骤1*几次，甚至不刷新页面一次。你将看到**混乱**！
- en: 'So, to solve the issue, we''ll use the simplest approach—that is, unsubscribing
    the stream when the user navigates away from the route. Let''s implement the `ngOnDestroy`
    lifecycle method for that, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们将使用最简单的方法，即在用户从路由中导航离开时取消订阅流。让我们实现`ngOnDestroy`生命周期方法，如下所示：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Great! If you follow the instructions from *Step 1* again, you'll see that there's
    no further log on the console once you navigate away from the **Home** page, and
    our app doesn't have an unhandled stream causing memory leaks now. Read the next
    section to understand how it works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！如果您再次按照*步骤1*的说明操作，您会发现一旦从**主页**导航离开，控制台上就不会再有进一步的日志输出，我们的应用程序现在没有未处理的流导致内存泄漏。阅读下一节以了解其工作原理。
- en: How it works…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: When we create an Observable/stream and we subscribe to it, RxJS automagically
    adds our provided `.subscribe` method block as a handler to the Observable. So,
    whenever there's a value emitted from the Observable, our method is supposed to
    be called. The fun part is that Angular doesn't automatically destroy that subscription/handler
    when the component unmounts or when you have navigated away from the route. That's
    because the core of Observables is RxJS, not Angular, and therefore it isn't Angular's
    responsibility to handle it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个Observable/流并订阅它时，RxJS会自动将我们提供的`.subscribe`方法块添加为Observable的处理程序。因此，每当Observable发出值时，我们的方法应该被调用。有趣的是，当组件卸载或从路由导航离开时，Angular不会自动销毁该订阅/处理程序。这是因为Observable的核心是RxJS，而不是Angular，因此处理它不是Angular的责任。
- en: Angular provides certain lifecycle methods, and we used the `OnDestroy` (`ngOnDestroy`)
    method. This is because when we navigate away from a route, Angular destroys that
    route, and that's when we would want to unsubscribe from all streams we have subscribed
    to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了某些生命周期方法，我们使用了`OnDestroy`（`ngOnDestroy`）方法。这是因为当我们从一个路由导航离开时，Angular会销毁该路由，这时我们希望取消订阅所有已订阅的流。
- en: There's more…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In a complex Angular app, there will be cases where you''d have more than one
    subscription in a component, and when the component is destroyed, you''d want
    to clean all those subscriptions at once. Similarly, you might want to unsubscribe
    based on certain events/conditions rather than the `OnDestroy` lifecycle. Here
    is an example, where you have multiple subscriptions in hand and you want to clean
    up all of them together when the component destroys:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的Angular应用程序中，会有一些情况下，您可能会在一个组件中有多个订阅，并且当组件被销毁时，您希望一次清理所有这些订阅。同样，您可能希望根据某些事件/条件取消订阅，而不是`OnDestroy`生命周期。这是一个例子，您手头有多个订阅，并且希望在组件销毁时一起清理所有这些订阅：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we're not saving the **Subscription** from `streamSource` to `this.subscription`
    anymore, and we have also removed the code from the `stopStream` method. The reason
    for this is because we don't have individual properties/variables for each Subscription.
    Instead, we'll have a single variable to work with. Let's look at the following
    recipe steps to get things rolling.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再将`streamSource`的**Subscription**保存到`this.subscription`中，我们还从`stopStream`方法中删除了代码。原因是因为我们没有为每个Subscription拥有单独的属性/变量。相反，我们将有一个单一的变量来处理。让我们看一下以下的步骤来开始工作。
- en: 'First, we''ll create a property in the `HomeComponent` class named `isComponentAlive`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在`HomeComponent`类中创建一个名为`isComponentAlive`的属性：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''ll import the `takeWhile` operator from `rxjs/operators`, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`rxjs/operators`中导入`takeWhile`操作符，如下所示：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ll now use the `takeWhile` operator with each of our streams to make them
    work only when the `isComponentAlive` property is set to `true`. Since `takeWhile`
    takes a `predicate` method, it should look like this:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`takeWhile`操作符与我们的每个流，使它们只在`isComponentAlive`属性设置为`true`时工作。由于`takeWhile`需要一个`predicate`方法，它应该是这样的：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you press the **Start Stream** button right now on the **Home** page, you
    still won't see any output or logs because the `isComponentAlive` property is
    still `undefined`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在在**主页**上按下**开始流**按钮，您仍然看不到任何输出或日志，因为`isComponentAlive`属性仍然是`undefined`。
- en: 'To make the streams work, we''ll set the `isComponentAlive` property to `true`
    in the `ngOnInit` method as well as in the `startStream` method. The code should
    look like this:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使流工作，我们将在`ngOnInit`方法以及`startStream`方法中将`isComponentAlive`属性设置为`true`。代码应该是这样的：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After this step, if you now try to start the stream and navigate away from the
    page, you'll still see the same issue with the streams—that is, they've not been
    unsubscribed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤之后，如果您现在尝试启动流并从页面导航离开，您仍将看到与流相同的问题-即它们尚未取消订阅。
- en: 'To unsubscribe all streams at once, we''ll set the value of `isComponentAlive`
    to `false` in the `stopStream` method, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要一次取消订阅所有流，我们将在`stopStream`方法中将`isComponentAlive`的值设置为`false`，如下所示：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And boom! Now, if you navigate away from the route while the streams are emitting
    values, the streams will stop immediately as soon as you navigate away from the
    **Home** route. Voilà!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后！ 现在，如果您在流发出值时导航离开路由，流将立即停止，就在您离开**主页**路由时。 瞧！
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read about RxJS Subscription (https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读RxJS订阅（https://www.learnrxjs.io/learn-rxjs/concepts/rxjs-primer#subscription）
- en: '`takeWhile` docs (https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeWhile`文档（https://www.learnrxjs.io/learn-rxjs/operators/filtering/takewhile）'
- en: Using an Observable with the async pipe to synchronously bind data to your Angular
    templates
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Observable和async管道将数据同步绑定到您的Angular模板
- en: As you learned in the previous recipe, it is crucial to unsubscribe the streams
    you subscribe to. What if we had an even simpler way to unsubscribe them when
    the component gets destroyed—that is, letting Angular take care of it somehow?
    In this recipe, you'll learn how to use Angular's `async` pipe with an Observable
    to directly bind the data in the stream to the Angular template instead of having
    to subscribe in the `*.component.ts` file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一个配方中所学到的，取消订阅您订阅的流至关重要。 如果我们有一种更简单的方法在组件被销毁时取消订阅它们-也就是说，让Angular以某种方式来处理它，那该多好？
    在这个配方中，您将学习如何使用Angular的`async`管道与Observable直接将流中的数据绑定到Angular模板，而无需在`*.component.ts`文件中订阅。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: The project for this recipe resides in `chapter05/start_here/using-async-pipe`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的项目位于`chapter05/start_here/using-async-pipe`。
- en: Open the project in VS Code.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. As soon as the page is opened,
    you should see something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序。 一旦页面打开，您应该看到类似于这样的东西：
- en: '![Figure 5.10 – The using-async-pipe app running on http://localhost:4200'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ！[图5.10-使用异步管道应用程序在http://localhost:4200上运行
- en: '](image/Figure_5.10_B15150.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ']（image/Figure_5.10_B15150.jpg）'
- en: Figure 5.10 – The using-async-pipe app running on http://localhost:4200
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10-使用异步管道应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看到该配方的步骤。
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The app we have right now has three streams/Observables observing values at
    different intervals. We're relying on the `isComponentAlive` property to keep
    the subscription alive or make it stop when the property is set to `false`. We'll
    remove the usage of `takeWhile` and somehow make everything work similarly to
    what we have right now.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的应用程序有三个流/可观察对象在不同的时间间隔观察值。 我们依赖于`isComponentAlive`属性来保持订阅活动或在属性设置为`false`时停止它。
    我们将删除对`takeWhile`的使用，并以某种方式使一切都与我们现在拥有的类似地工作。
- en: 'First, remove the `subscription` property from the `home.component.ts` file
    and add an `Observable` type property named `streamOutput$`. The code should look
    like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从`home.component.ts`文件中删除`subscription`属性，并添加一个名为`streamOutput$`的`Observable`类型属性。
    代码应如下所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this change, the app would break because of some missing variables. Fear
    not! I'm here to help you.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种改变，应用程序会因为一些缺少的变量而崩溃。 不要害怕！ 我在这里帮助您。
- en: 'We''ll now combine all the streams to give out a single output—that is, the
    `outputStreamData` array. We''ll remove all the existing `.pipe` and `.subscribe`
    methods from the `startStream()` method, so the code should now look like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将组合所有的流以输出单个输出，即`outputStreamData`数组。我们将从`startStream()`方法中删除所有现有的`.pipe`和`.subscribe`方法，所以代码现在应该是这样的：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this change, the linters will still complain. Why? Because the `merge`
    operator combines all streams and outputs the latest value. This is a `Observable<number>`
    data type, instead of `Observable<string[]>`, which is the type of `streamsOutput$`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个改变，linters仍然会抱怨。为什么？因为`merge`操作符会合并所有流并输出最新的值。这是一个`Observable<number>`数据类型，而不是`Observable<string[]>`，这是`streamsOutput$`的类型。
- en: 'Since we want to assign the entire array containing every output emitted from
    the streams, we''ll use a `map` operator and add each output to the `outputStreamData`
    array, and return the latest state of the `outputStreamData` array, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要分配包含从流中发出的每个输出的整个数组，我们将使用`map`操作符，并将每个输出添加到`outputStreamData`数组中，并返回`outputStreamData`数组的最新状态，如下所示：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remove the `stopStream` method from the `HomeComponent` class since we don't
    need it anymore. Also, remove its usage from the `ngOnDestroy` method.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`HomeComponent`类中删除`stopStream`方法，因为我们不再需要它。同时，从`ngOnDestroy`方法中删除它的使用。
- en: 'Finally, modify the template in `home.component.html` to use the `streamOutput$`
    Observable with the `async` pipe to loop over the output array:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改`home.component.html`模板，使用`streamOutput$` Observable和`async`管道来循环输出数组：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To verify that the subscription REALLY gets destroyed on component destruction,
    let''s put a `console.log` in the `startStream` method inside the `map` operator,
    as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证订阅在组件销毁时确实被销毁，让我们在`startStream`方法中的`map`操作符中放置一个`console.log`，如下所示：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hurray! With this change, you can try refreshing the app, navigate away from
    the **Home** route, and you'll see that the console logs stop as soon as you do
    that. Do you feel the achievement we just got by removing all that extra code?
    I certainly do. Well, see in the next section how it all works.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！有了这个改变，你可以尝试刷新应用程序，离开**Home**路由，你会发现控制台日志会在你这样做时立即停止。你感受到我们通过删除所有那些额外代码所获得的成就了吗？我当然感受到了。好吧，接下来看看它是如何工作的。
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Angular's `async` pipe automatically destroys/unsubscribes the subscription
    as soon as the component destroys. This gives us a great opportunity to use it
    where possible. In the recipe, we basically combined all the streams using the
    `merge` operator. The fun part was that for the `streamsOutput$` property, we
    wanted an Observable of the output array on which we could loop over. However,
    merging the stream only combines them and emits the latest value emitted by any
    of the streams. So, we added a `.pipe()` method with the `.map()` operator to
    take the latest output out of the combined stream, added it to the `outputStreamData`
    array for persistence, and returned it from the `.map()` method so that we get
    the array in the template when we use the `async` pipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的`async`管道在组件销毁时会自动销毁/取消订阅。这给了我们一个很好的机会在可能的情况下使用它。在这个示例中，我们基本上使用`merge`操作符组合了所有的流。有趣的是，对于`streamsOutput$`属性，我们希望得到一个输出数组的Observable，我们可以对其进行循环。然而，合并流只是将它们组合在一起并发出任何一个流发出的最新值。因此，我们添加了一个`.pipe()`方法和`.map()`操作符，以从组合的流中取出最新的输出，将其添加到`outputStreamData`数组中以进行持久化，并从`.map()`方法中返回它，这样我们在模板中使用`async`管道时就可以得到数组。
- en: Fun fact—streams don't emit any value unless they're subscribed to. "*But Ahsan,
    we didn't subscribe to the stream, we just merged and mapped the data. Where's
    the subscription?*" Glad you asked. Angular's `async` pipe subscribes to the stream
    itself, which triggers our `console.log` as well that we added in *Step 6*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实-流不会发出任何值，除非它们被订阅。"*但是，阿赫桑，我们没有订阅流，我们只是合并和映射数据。订阅在哪里？*"很高兴你问。Angular的`async`管道订阅了流本身，这也触发了我们在*步骤6*中添加的`console.log`。
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `async` pipe has a limitation, which is that you cannot stop the subscription
    until the component is destroyed. In such cases, you'd want to go for in-component
    subscriptions using something such as the `takeWhile`/`takeUntil` operator or
    doing a regular `.unsubscribe` method yourself when the component is destroyed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 管道有一个限制，即在组件销毁之前无法停止订阅。在这种情况下，您可能希望使用类似`takeWhile`/`takeUntil`操作符的组件内订阅，或者在组件销毁时自己执行常规的`.unsubscribe`方法。'
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular `async` pipe documentation ([https://angular.io/api/common/AsyncPipe](https://angular.io/api/common/AsyncPipe))
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `async` 管道文档（[https://angular.io/api/common/AsyncPipe](https://angular.io/api/common/AsyncPipe)）
- en: Using combineLatest to subscribe to multiple streams together
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用combineLatest订阅多个流
- en: In the previous recipe, we had to merge all the streams, which resulted in a
    single output being last emitted by any of the streams. In this recipe, we'll
    work with `combineLatest`, which results in having an array as an output, combining
    all the streams. This approach is appropriate for when you want the latest output
    from all the streams, combined in a single subscribe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们不得不合并所有流，这导致最后由任何一个流发出的单个输出。在这个示例中，我们将使用`combineLatest`，它的输出是一个数组，结合了所有的流。这种方法适用于当您想要来自所有流的最新输出，组合在一个单独的订阅中。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project that we are going to work with resides in `chapter05/start_here/using-combinelatest-operator`,
    inside the cloned repository.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要使用的项目位于克隆存储库内的`chapter05/start_here/using-combinelatest-operator`中。
- en: Open the project in VS Code.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，你应该看到类似这样的东西：
- en: '![Figure 5.11 – The using-combinelatest-operator app running on http://localhost:4200'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11 - 使用combinelatest-operator应用程序在http://localhost:4200上运行'
- en: '](image/Figure_5.11_B15150.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.11_B15150.jpg)'
- en: Figure 5.11 – The using-combinelatest-operator app running on http://localhost:4200
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 - 使用combinelatest-operator应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个示例的步骤。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: For this recipe, we have an app that displays a box. The box has a size (width
    and height), a border radius, a background color, and a color for its text. It
    also has four inputs to modify all the mentioned factors. Right now, we have to
    apply the changes manually with the click of a button. What if we could subscribe
    to the changes to the inputs and update the box right away? That's what we're
    going to do here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们有一个显示框的应用程序。框有一个大小（宽度和高度），一个边框半径，一个背景颜色，以及文本的颜色。它还有四个输入来修改所有提到的因素。现在，我们必须手动点击按钮来应用更改。如果我们可以订阅输入的更改并立即更新框呢？这就是我们要做的。
- en: 'We''ll begin by creating a method named `listenToInputChanges`, in which we''ll
    subscribe to the changes for each of the inputs and combine those streams using
    the `combineLatest` operator. Update the `home/home.component.ts` file, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`listenToInputChanges`的方法，在其中我们将订阅每个输入的更改，并使用`combineLatest`操作符组合这些流。更新`home/home.component.ts`文件如下：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remember that not unsubscribing streams is a BAD idea? And that''s what we
    have here: a subscribed stream. We''ll use the `async` pipe instead of the current
    Subscription used in the `home.component.ts` file. For that, let''s create an
    Observable property named `boxStyles$` and remove the `boxStyles` property. Then,
    assign the stream from `combineLatest` to it, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住不取消订阅流是一个坏主意吗？这就是我们在这里的情况：一个已订阅的流。我们将使用`async`管道代替`home.component.ts`文件中当前使用的订阅。为此，让我们创建一个名为`boxStyles$`的Observable属性，并删除`boxStyles`属性。然后，将`combineLatest`的流分配给它，如下所示：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We need to remove the `setBoxStyles()` and `applyChanges()` methods and the
    usages of the `applyChanges()` method from the `home.component.ts` file. Update
    the file, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从`home.component.ts`文件中删除`setBoxStyles()`和`applyChanges()`方法以及`applyChanges()`方法的使用。更新文件如下：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need to remove the usage of the `applyChanges()` method from the template
    as well. Remove the `(ngSubmit)` handler from the `<form>` element in the `home.component.html`
    file so that it looks like this:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从模板中删除`applyChanges()`方法的使用。从`home.component.html`文件中的`<form>`元素中删除`(ngSubmit)`处理程序，使其如下所示：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to get rid of the `submit-btn-container` element from the `home.component.html`
    template as we don''t need it anymore. Delete the following chunk from the file:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从`home.component.html`模板中删除`submit-btn-container`元素，因为我们不再需要它。从文件中删除以下内容：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you refresh the app, you'll notice that the box doesn't show at all. We'll
    fix this in the next step.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新应用程序，你会注意到框根本不显示。我们将在下一步中修复这个问题。
- en: 'Since we''re using the `combineLatest` operator when the app starts, but we
    don''t have it triggered because none of the inputs have changed, we need to initialize
    the box with some initial values. To do so, we''ll use the `startWith` operator
    with the initial values, as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在应用程序启动时使用了`combineLatest`操作符，但我们没有触发它，因为没有一个输入发生了变化，我们需要使用`startWith`操作符和初始值来初始化框。为此，我们将使用`startWith`操作符和初始值，如下所示：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that we have the `boxStyles$` Observable in place, let''s use it in the
    template instead of the `boxStyles` property:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了`boxStyles$` Observable，让我们在模板中使用它，而不是`boxStyles`属性：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And voilà! Everything works perfectly fine now.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大功告成！现在一切都运行得很完美。
- en: Congratulations on finishing the recipe. You're now the master of streams and
    the `combineLatest` operator. See the next section to understand how it works.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜完成了食谱。现在你是流和`combineLatest`操作符的大师了。查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The beauty of **reactive forms** is that they provide much more flexibility
    than the regular `ngModel` binding or even template-driven forms. And for each
    form control, we can subscribe to its `valueChanges` Observable, which receives
    a new value whenever the input is changed. So, instead of relying on the **Submit**
    button's click, we subscribed directly to the `valueChanges` property of each
    **form control**. In a regular scenario, that would result in four different streams
    for four inputs, which means we would have four subscriptions that we need to
    take care of and make sure we unsubscribe them. This is where the `combineLatest`
    operator comes into play. We used the `combineLatest` operator to combine those
    four streams into one, which means we needed to unsubscribe only one stream on
    component destruction. But hey! Remember that we don't need to do this if we use
    the `async` pipe? That's exactly what we did. We removed the subscription from
    the `home.component.ts` file and used the `.pipe()` method with the `.map()` operator.
    The `.map()` operator transformed the data to our needs, and then returned the
    transformed data to be set to the `boxStyles$` Observable. Finally, we used the
    async pipe in our template to subscribe to the `boxStyles$` Observable and assigned
    its value as the `[ngStyle]` to our box element.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式表单**的美妙之处在于它们提供比常规的`ngModel`绑定或者甚至模板驱动表单更灵活的功能。对于每个表单控件，我们可以订阅它的`valueChanges`
    Observable，每当输入发生变化时就会接收到一个新的值。因此，我们不再依赖于**提交**按钮的点击，而是直接订阅了每个**表单控件**的`valueChanges`属性。在常规情况下，这将导致四个不同的流用于四个输入，这意味着我们需要处理四个订阅并确保取消订阅。这就是`combineLatest`操作符发挥作用的地方。我们使用`combineLatest`操作符将这四个流合并为一个，这意味着我们只需要在组件销毁时取消订阅一个流。但是！记住如果我们使用`async`管道就不需要这样做了？这正是我们所做的。我们从`home.component.ts`文件中移除了订阅，并使用了`.pipe()`方法和`.map()`操作符。`.map()`操作符将数据转换为我们需要的格式，然后将转换后的数据返回给`boxStyles$`
    Observable。最后，我们在模板中使用async管道订阅`boxStyles$` Observable，并将其值分配为我们盒子元素的`[ngStyle]`。'
- en: Important note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `combineLatest` method will not emit an initial value until each Observable
    emits at least one value. Therefore, we use the `startWith` operator with each
    individual form control's `valueChanges` stream to provide an initial emitted
    value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest`方法在每个Observable至少发出一个值之前不会发出初始值。因此，我们使用`startWith`操作符与每个单独的表单控件的`valueChanges`流来提供一个初始发出的值。'
- en: See also
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`combineLatest` operator documentation ([https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest](https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest))'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineLatest`操作符文档（[https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest](https://www.learnrxjs.io/learn-rxjs/operators/combination/combinelatest)）'
- en: Visual representation of the `combineLatest` operator ([https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest](https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest))
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineLatest`操作符的可视化表示（[https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest](https://rxjs-dev.firebaseapp.com/api/index/function/combineLatest)）'
- en: Using the flatMap operator to create sequential HTTP calls
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flatMap操作符创建顺序的HTTP调用
- en: The days of using **Promises** were awesome. It's not that those days are gone,
    but we as developers surely prefer **Observables** over **Promises** for a lot
    of reasons. One of the things I really like about Promises is that you can chain
    Promises to do things such as sequential HTTP calls. In this recipe, you'll learn
    how to do the same with **Observables** using the `flatMap` operator.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Promises**的日子很棒。并不是说那些日子已经过去了，但我们作为开发者肯定更喜欢**Observables**而不是**Promises**，有很多原因。我真的很喜欢Promises的一件事是你可以链接Promises来做一些事情，比如顺序的HTTP调用。在这个教程中，你将学习如何使用`flatMap`操作符来使用**Observables**做同样的事情。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The project that we are going to work with resides in `chapter05/start_here/using-flatmap-operator`,
    inside the cloned repository.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的`chapter05/start_here/using-flatmap-operator`中。
- en: Open the project in VS Code.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，你应该会看到类似这样的东西：
- en: '![Figure 5.12 – The using-flatmap-operator app running on http://localhost:4200'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.12 – 使用-flatmap-operator应用程序正在http://localhost:4200上运行'
- en: '](image/Figure_5.12_B15150.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.12_B15150.jpg)'
- en: Figure 5.12 – The using-flatmap-operator app running on http://localhost:4200
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 使用-flatmap-operator应用程序正在http://localhost:4200上运行
- en: The app right now seems perfect, actually. Nothing suspicious, right? Well,
    not exactly. Follow these steps to find out what is wrong.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序看起来完美，实际上。没有什么可疑的，对吧？嗯，不完全是。按照以下步骤找出问题所在。
- en: Open Chrome DevTools.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome DevTools。
- en: Go to the **Network** tab and simulate the **Slow 3G** network, as follows:![Figure
    5.13 – Simulatina slow 3G network in Chrome DevTools
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**网络**选项卡，并模拟**慢3G**网络，如下所示：![图5.13 – 在Chrome DevTools中模拟慢3G网络
- en: '](image/Figure_5.13_B15150.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.13_B15150.jpg)'
- en: Figure 5.13 – Simulatina slow 3G network in Chrome DevTools
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 在Chrome DevTools中模拟慢3G网络
- en: If you tap on any card from the home page, you should reach the particular user's
    details page.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击主页上的任何卡片，你应该能够到达特定用户的详细信息页面。
- en: 'Refresh the app now, see the **Network** tab, and you can see the HTTP calls
    executing in parallel, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在刷新应用程序，查看**网络**选项卡，你会看到HTTP调用并行执行，如下所示：
- en: '![Figure 5.14 – Parallel calls loading data asynchronously'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14 – 并行调用异步加载数据'
- en: '](image/Figure_5.14_B15150.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.14_B15150.jpg)'
- en: Figure 5.14 – Parallel calls loading data asynchronously
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 并行调用异步加载数据
- en: The problem is that we're not sure which data would come first due to both HTTP
    calls executing in parallel. Therefore, the user might see similar users before
    the main user is loaded. Let's see how to avoid this.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们不确定由于两个HTTP调用并行执行，哪个数据会先到来。因此，用户可能会在主用户加载之前看到类似的用户。让我们看看如何避免这种情况。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In order to fix the issue that our similar users can be loaded before our main
    user, we'll have to sequentially load the data and show the appropriate content
    respectively, and while the content is loading, we'll show a loader. Let's get
    started.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决类似用户可能在主用户之前加载的问题，我们将不得不顺序加载数据，并分别显示相应的内容，而在内容加载时，我们将显示一个加载器。让我们开始吧。
- en: 'First, let''s modify our `user-detail/user-detail.component.html` file to show
    the loader while we''re loading and while we load the similar users as well. The
    code should look like this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们修改我们的`user-detail/user-detail.component.html`文件，以便在加载时显示加载器，以及在加载类似的用户时也显示加载器。代码应该如下所示：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you refresh the app, you should see both loaders appearing before the calls
    are made.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新应用程序，你应该会看到在进行调用之前两个加载器都出现。
- en: We want to make the calls sequential, and for that, we can't have the streams
    directly bound to Observables in the `UserDetailComponent` class. That is, we
    can't even use the `async` pipe.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望进行顺序调用，为此，我们不能直接将流绑定到`UserDetailComponent`类中的Observables。也就是说，我们甚至不能使用`async`管道。
- en: 'Let''s convert the Observable properties to regular properties in the `UserDetailComponent`
    class, as follows:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`UserDetailComponent`类中的Observable属性转换为常规属性，如下所示：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You should already have the app breaking as soon as you save this aforementioned
    change.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 只要保存上述更改，应用程序就会立即崩溃。
- en: 'Let''s use the new variables that we modified in the previous step inside our
    template. Modify the `user-detail.component.html` file, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在模板中使用我们在上一步中修改的新变量。修改`user-detail.component.html`文件，如下所示：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, let''s use the `flatMap` operator now to execute the calls sequentially
    and to assign the received values to the appropriate variables, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们现在使用`flatMap`运算符按顺序执行调用，并将接收到的值分配给相应的变量，如下所示：
- en: '[PRE36]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And yes! If you now refresh the app, you''ll notice that the calls are sequential
    as we first get the main user, and then the similar users. To confirm, you can
    open Chrome DevTools and see the network log for the **application programming
    interface** (**API**) calls. You should see something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！如果您现在刷新应用程序，您会注意到调用是顺序的，因为我们首先获取主用户，然后获取相似用户。要确认，您可以打开Chrome DevTools并查看**应用程序编程接口**（**API**）调用的网络日志。您应该会看到类似以下内容：
- en: '![Figure 5.15 – API calls executing synchronously'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.15 – API调用同步执行'
- en: '](image/Figure_5.15_B15150.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.15_B15150.jpg)'
- en: Figure 5.15 – API calls executing synchronously
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 – API调用同步执行
- en: Now that you've finished the recipe, see the next section on how this works.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了这个步骤，请查看下一节，了解其工作原理。
- en: How it works…
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `flatMap` operator takes the output from the previous Observable and is
    supposed to return a new Observable back. This helps us to sequentially execute
    our HTTP calls to be sure that the data is loaded according to its priority, or
    our business logic.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`运算符获取前一个Observable的输出，并应返回一个新的Observable。这有助于我们按顺序执行HTTP调用，以确保数据根据其优先级或我们的业务逻辑加载。'
- en: Since we wanted to execute the calls whenever a new user is selected, which
    can happen from the `UserDetailComponent` class itself, we put a `flatMap` operator
    on the `route.paramsMap` directly. Whenever that happens, we first set the `user`
    and `similarUsers` properties to `null`. "*But why?*" Well, because if we're on
    the `UserDetailsComponent` page and we click on any similar user, the page wouldn't
    change since we're already on it. This means the user and `similarUsers` variables
    will still contain their previous values. And since they'll have values already
    (that is, they're not `null`), the loader will not show in that case on tapping
    any similar user. Smart, right?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在选择新用户时执行调用，这可以从`UserDetailComponent`类本身发生，我们直接在`route.paramsMap`上放置了`flatMap`运算符。每当发生这种情况时，我们首先将`user`和`similarUsers`属性设置为`null`。"*但为什么？*"嗯，因为如果我们在`UserDetailsComponent`页面上并单击任何相似用户，页面不会更改，因为我们已经在上面。这意味着用户和`similarUsers`变量仍将包含其先前的值。而且由于它们已经有值（即它们不是`null`），在点击任何相似用户时，加载程序将不会显示在这种情况下。聪明，对吧？
- en: Anyways, after assigning the variables to `null`, we return the Observable back
    from the `this.userService.getUser(userId)` chunk, which results in executing
    the first HTTP call to get the main user. Then, we use a pipe and `flatMap` on
    the first call's Observable to get the main user, assign it to the `this.user`
    chunk, and then return the Observable from the second call—that is, the `this.userService.getSimilarUsers(userId)`
    code. Finally, we use the `.subscribe` method to receive the value from `getSimilarUsers(userId)`
    and once the value is received, we assign it to `this.similarUsers`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在将变量分配为`null`之后，我们将Observable从`this.userService.getUser(userId)`块返回，这将导致执行第一个HTTP调用以获取主用户。然后，我们在第一个调用的Observable上使用管道和`flatMap`来获取主用户，将其分配给`this.user`块，然后返回第二个调用的Observable——即`this.userService.getSimilarUsers(userId)`代码。最后，我们使用`.subscribe`方法从`getSimilarUsers(userId)`接收值，一旦接收到值，我们将其分配给`this.similarUsers`。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '`flatMap`/`mergeMap` documentation ([https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap))'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`/`mergeMap`文档（[https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap](https://www.learnrxjs.io/learn-rxjs/operators/transformation/mergemap)）'
- en: Using the switchMap operator to switch the last subscription with a new one
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用switchMap操作符来切换最后一个订阅与新的订阅
- en: For a lot of apps, we have features such as searching content as the user types.
    This is a really good **user experience** (**UX**) as the user doesn't have to
    press a button to do a search. However, if we send a call to the server on every
    keyboard press, that's going to result in a lot of HTTP calls being sent, and
    we can't know which HTTP call will complete first; thus, we can't be sure if we
    will have the correct data shown on the view or not. In this recipe, you'll learn
    to use the `switchMap` operator to cancel out the last subscription and create
    a new one instead. This would result in canceling previous calls and keeping only
    one call—the last one.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序，我们有诸如用户输入时搜索内容的功能。这是一个非常好的**用户体验**（**UX**），因为用户不必按按钮进行搜索。然而，如果我们在每次按键时向服务器发送调用，那将导致大量的HTTP调用被发送，我们无法知道哪个HTTP调用会首先完成；因此，我们无法确定我们是否会在视图上看到正确的数据。在这个示例中，您将学习如何使用`switchMap`操作符来取消上一个订阅并创建一个新的订阅。这将导致取消以前的调用并保留一个调用
    - 最后一个调用。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project that we are going to work with resides in `chapter05/start_here/using-switchmap-operator`,
    inside the cloned repository.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的`chapter05/start_here/using-switchmap-operator`中。
- en: Open the project in VS Code.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，你应该会看到类似于这样的东西：
- en: '![Figure 5.16 – The using-switchmap-operator app running on http://localhost:4200'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.16 - 使用switchmap-operator应用程序在http://localhost:4200上运行'
- en: '](image/Figure_5.16_B15150.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.16_B15150.jpg)'
- en: Figure 5.16 – The using-switchmap-operator app running on http://localhost:4200
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 - 使用switchmap-operator应用程序在http://localhost:4200上运行
- en: 'Now that we have the app running locally, open Chrome DevTools and go to the
    **Network** tab. Type `''huds''` in the search input, and you''ll see four calls
    being sent to the API server, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，打开Chrome DevTools并转到**Network**选项卡。在搜索输入框中输入`'huds'`，你会看到有四个调用被发送到API服务器，如下所示：
- en: '![Figure 5.17 – A separate call sent for each input change'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.17 - 每次输入更改都发送一个单独的调用'
- en: '](image/Figure_5.17_B15150.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.17_B15150.jpg)'
- en: Figure 5.17 – A separate call sent for each input change
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 - 每次输入更改都发送一个单独的调用
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: You can start typing into the search box on the home page to see the filtered
    users, and if you see the **Network** tab, you'll notice that whenever the input
    changes, we send a new HTTP call. Let's avoid sending a call on each keypress
    by using the `switchMap` operator.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在主页的搜索框中开始输入以查看筛选后的用户，如果您查看**Network**选项卡，您会注意到每次输入更改时，我们都会发送一个新的HTTP调用。让我们通过使用`switchMap`操作符来避免在每次按键时发送调用。
- en: 'First, import the `switchMap` operator from `rxjs/operators` in the `home/home.component.ts`
    file, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`home/home.component.ts`文件中从`rxjs/operators`中导入`switchMap`操作符，如下所示：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will now modify our subscription to the `username` form control— specifically,
    the `valueChanges` Observable to use the `switchMap` operator for the `this.userService.searchUsers(query)`
    method call. This returns an `Observable` containing the result of the HTTP call.
    The code should look like this:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将修改对`username`表单控件的订阅，具体来说是使用`switchMap`操作符来调用`this.userService.searchUsers(query)`方法的`valueChanges`
    Observable。这将返回一个包含HTTP调用结果的`Observable`。代码应该如下所示：
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you refresh the app now, open Chrome DevTools, and check the network type
    while typing `''huds''`, you''ll see that all the previous calls are canceled
    and we only have the latest HTTP call succeeding:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序，打开Chrome DevTools，并在输入“'huds'”时检查网络类型，您会看到所有先前的调用都被取消，我们只有最新的HTTP调用成功：
- en: '![Figure 5.18 – switchMap canceling prior HTTP calls'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18 – switchMap取消先前的HTTP调用'
- en: '](image/Figure_5.18_B15150.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.18_B15150.jpg)'
- en: Figure 5.18 – switchMap canceling prior HTTP calls
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – switchMap取消先前的HTTP调用
- en: Woot! We now have only one call that'll succeed, process the data, and end up
    in the view. See the next section on how it works.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！现在我们只有一个调用会成功，处理数据，并最终显示在视图中。请参阅下一节了解其工作原理。
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `switchMap` operator cancels the previous (inner) subscription and subscribes
    to a new Observable instead. That's why it cancels all the HTTP calls sent before
    in our example and just subscribes to the last one. This was the intended behavior
    for our app.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchMap`操作符会取消先前（内部）的订阅，并订阅一个新的Observable。这就是为什么它会取消我们示例中之前发送的所有HTTP调用，只订阅最后一个的原因。这是我们应用程序的预期行为。'
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`switchMap` operator documentation (https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switchMap`操作符文档（https://www.learnrxjs.io/learn-rxjs/operators/transformation/switchmap）'
- en: Debouncing HTTP requests using RxJS
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJS进行HTTP请求去抖
- en: In the previous recipe, we learned how to use the `switchMap` operator to cancel
    previous HTTP calls if a new HTTP call comes. This is fine, but why even send
    multiple calls when we can use a technique to wait a while before we send an HTTP
    call? Ideally, we'll just keep listening to duplicate requests for a period of
    time and will then proceed with the latest request. In this recipe, we'll be using
    the `debounceTime` operator to make sure we're only sending the HTTP call when
    the user stops typing for a while.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何使用`switchMap`操作符来取消先前的HTTP调用，如果有新的HTTP调用。这很好，但是为什么在我们可以使用一种技术在发送HTTP调用之前等待一段时间呢？理想情况下，我们将继续监听一段时间的重复请求，然后继续进行最新的请求。在这个示例中，我们将使用`debounceTime`操作符来确保我们只在用户停止输入一段时间后才发送HTTP调用。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project that we are going to work with resides in `chapter05/start_here/using-debouncetime-operator`,
    inside the cloned repository.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于克隆存储库中的`chapter05/start_here/using-debouncetime-operator`中。
- en: Open the project in VS Code.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器选项卡中打开应用程序，并且您应该会看到类似于这样的内容：
- en: '![Figure 5.19 – The using-debouncetime-operator app running on http://localhost.4200'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.19 – 使用debouncetime操作符的应用程序运行在http://localhost.4200上'
- en: '](image/Figure_5.19_B15150.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.19_B15150.jpg)'
- en: Figure 5.19 – The using-debouncetime-operator app running on http://localhost.4200
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 – 使用debouncetime操作符的应用程序运行在http://localhost.4200上
- en: 'Now that we have the app running, open Chrome DevTools, go to the **Network**
    tab, and then type `''Irin''` in the user search bar. You should see something
    like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，打开Chrome DevTools，转到**网络**选项卡，然后在用户搜索栏中输入“'Irin'”。您应该会看到类似于这样的内容：
- en: '![Figure 5.20 – A new call being sent to the server on each keyboard input'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20 - 每次键盘输入都会发送到服务器的新调用'
- en: '](image/Figure_5.20_B15150.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.20_B15150.jpg)'
- en: Figure 5.20 – A new call being sent to the server on each keyboard input
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 - 每次键盘输入都会发送到服务器的新调用
- en: Notice how the third call's response comes after the fourth call? That's the
    issue we're trying to solve by using some sort of debounce.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第三次调用的响应是在第四次调用之后吗？这就是我们试图通过使用某种防抖来解决的问题。
- en: Let's jump into the recipe steps in the next section.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中跳转到食谱步骤。
- en: How to do it…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: As we see when we type into the search box on the home page (that is, whenever
    the input changes), we send a new HTTP call.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在主页的搜索框中输入时（也就是说，每当输入发生变化时），我们会发送一个新的HTTP调用。
- en: 'In order to make sure we only send one call when the search input is idle after
    typing, we''ll put a `debounceTime` operator on the `this.searchForm.get(''username'').valueChanges`
    Observable. Update the `home/home.component.ts` file, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在输入搜索后处于空闲状态时只发送一次调用，我们将在`this.searchForm.get('username').valueChanges`
    Observable上放置一个`debounceTime`操作符。更新`home/home.component.ts`文件，如下所示：
- en: '[PRE39]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And that''s it! If you type `''irin''` in the search input while inspecting
    the **Network** tab, you should see only one call being sent to the server, as
    follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如果您在检查**网络**选项卡时在搜索输入框中输入`'irin'`，您应该只看到一次调用被发送到服务器，如下所示：
- en: '![Figure 5.21 – debounceTime causing only one call to be sent to the server'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21 - debounceTime只导致一次调用发送到服务器'
- en: '](image/Figure_5.21_B15150.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.21_B15150.jpg)'
- en: Figure 5.21 – debounceTime causing only one call to be sent to the server
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 - debounceTime只导致一次调用发送到服务器
- en: See the next section to understand how it all works.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `debounceTime` operator waits for a particular time before emitting a value
    from the source Observable, and that too only when there's no more source emission
    at hand. This allows us to use the operator on the input's `valueChanges` Observable.
    When you type something in the input, the `debounceTime` operator waits for 300ms
    to see if you're still typing. And if you've not typed for those 300ms, it moves
    forward with the emission, causing the HTTP call at the end.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`debounceTime`操作符在从源Observable发出值之前等待一段时间，而且只有在没有更多的源发射时才会发出值。这使我们能够在输入的`valueChanges`
    Observable上使用该操作符。当您在输入框中输入内容时，`debounceTime`操作符会等待300毫秒，以查看您是否仍在输入。如果您在这300毫秒内没有输入，它将继续发出值，导致最终进行HTTP调用。'
- en: See also
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`debounceTime` operator documentation ([https://rxjs-dev.firebaseapp.com/api/operators/debounceTime](https://rxjs-dev.firebaseapp.com/api/operators/debounceTime))'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounceTime`操作符文档（[https://rxjs-dev.firebaseapp.com/api/operators/debounceTime](https://rxjs-dev.firebaseapp.com/api/operators/debounceTime))'
- en: '`debounce` operator documentation ([https://rxjs-dev.firebaseapp.com/api/operators/debounce](https://rxjs-dev.firebaseapp.com/api/operators/debounce))'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounce`操作符文档（[https://rxjs-dev.firebaseapp.com/api/operators/debounce](https://rxjs-dev.firebaseapp.com/api/operators/debounce))'
- en: '`delay` operator documentation ([https://rxjs-dev.firebaseapp.com/api/operators/delay](https://rxjs-dev.firebaseapp.com/api/operators/delay))'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`操作符文档（[https://rxjs-dev.firebaseapp.com/api/operators/delay](https://rxjs-dev.firebaseapp.com/api/operators/delay))'
