- en: '*Chapter 8*: Use Case Scenario 2 – Jotai'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：用例场景 2 – Jotai'
- en: Jotai ([https://github.com/pmndrs/jotai](https://github.com/pmndrs/jotai)) is
    a small library for the global state. It's modeled after `useState`/`useReducer`
    and with what are called atoms, which are usually small pieces of state. Unlike
    Zustand, it is a component state, and like Zustand, it is an immutable update
    model. The implementation is based on the Context and Subscription patterns we
    learned about in [*Chapter 5*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073),
    *Sharing Component State with Context and Subscription*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai ([https://github.com/pmndrs/jotai](https://github.com/pmndrs/jotai)) 是一个用于全局状态的轻量级库。它模仿了
    `useState`/`useReducer`，并使用所谓的原子，这些通常是小的状态片段。与 Zustand 不同，它是一个组件状态，并且像 Zustand
    一样，它是一个不可变更新模型。其实现基于我们在 [*第 5 章*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073)
    中学到的上下文和订阅模式，*使用上下文和订阅共享组件状态*。
- en: In this chapter, we will learn about the basic usage of the Jotai library and
    how it deals with optimizing re-renders. With atoms, the library can track dependencies
    and trigger re-renders based on the dependencies. Because Jotai internally uses
    Context and atoms themselves do not hold values, atom definitions are reusable,
    unlike the module state. We will also discuss a novel pattern with atoms, called
    **Atoms-in-Atom**, which is a technique to optimize re-renders with an array structure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Jotai 库的基本用法以及它是如何处理优化重新渲染的。使用原子，库可以跟踪依赖关系并根据依赖关系触发重新渲染。因为 Jotai
    内部使用 Context，而原子本身不持有值，所以原子定义是可重用的，与模块状态不同。我们还将讨论一个使用原子的新颖模式，称为 **原子中的原子**，这是一种使用数组结构优化重新渲染的技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Jotai
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Jotai
- en: Exploring render optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索渲染优化
- en: Understanding how Jotai works to store atom values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Jotai 如何存储原子值
- en: Adding an array structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加数组结构
- en: Using the different features of Jotai
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jotai 的不同功能
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have moderate knowledge of React, including React hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你具备适度的 React 知识，包括 React hooks。请参考官方网站 [https://reactjs.org](https://reactjs.org)
    了解更多。
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用 TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，你应该对其有基本了解。
- en: The code in this chapter is available on GitHub at [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_08](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在 GitHub 上找到 [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_08](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_08)。
- en: To run the code snippets in this chapter, you need a React environment—for example,
    Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    or CodeSandbox ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码片段，你需要一个 React 环境——例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    或 CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: Understanding Jotai
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Jotai
- en: To understand the Jotai **application programming interface** (**API**), let's
    remind ourselves of a simple counter example and the solution with Context.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Jotai 的 **应用程序编程接口**（**API**），让我们回顾一个简单的计数器示例和 Context 的解决方案。
- en: 'Here is an example with two separate counters:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含两个独立计数器的示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because these `Counter1` and `Counter2` components have their own local states,
    the numbers shown in these components are isolated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些 `Counter1` 和 `Counter2` 组件有自己的局部状态，所以这些组件中显示的数字是隔离的。
- en: If we want those two components to share a single count state, we can lift the
    state up and use Context to pass it down, as we discussed in the *Effectively
    using local states* section of [*Chapter 2*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035),
    *Using Local and Global States*. Let's see an example that is solved with Context.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让这两个组件共享一个单一的计数状态，我们可以将状态提升并使用 Context 来传递，正如我们在 [*第 2 章*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035)
    的 *有效使用局部状态* 部分所讨论的那样，*使用局部和全局状态*。让我们看看一个使用 Context 解决的示例。
- en: 'First, we create a `Context` variable to hold the count state, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `Context` 变量来保存计数状态，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the `Context` value is the same state, `useState(0)`, as we used in the
    previous example (marked **[1]**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Context` 值与我们在上一个示例中使用的相同状态 `useState(0)`（标记为 **[1]**）。
- en: 'Then, the following are the modified components, where we replace `useState(0)`
    with `useContext(CountContext)`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下是对修改后的组件的修改，我们将`useState(0)`替换为`useContext(CountContext)`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we wrap those components with `CountProvider`, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用`CountProvider`包裹这些组件，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This makes it possible to have a shared count state, and you will see that two
    `count` numbers in `Counter1` and `Counter2` components are incremented at once.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得拥有一个共享的计数状态成为可能，你将看到`Counter1`和`Counter2`组件中的两个`count`数字会同时增加。
- en: 'Now, let''s see how Jotai is helpful compared to Context. There are two benefits
    when using Jotai, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看与Context相比，Jotai是如何有帮助的。使用Jotai有两个好处，如下所示：
- en: Syntax simplicity
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法简洁性
- en: Dynamic atom creation
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态原子创建
- en: Let's start with the first benefit—how Jotai can help to simplify the syntax.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个好处开始——Jotai如何帮助简化语法。
- en: Syntax simplicity
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法简洁性
- en: 'To understand syntax simplicity, let''s look at the same counter example with
    Jotai. First, we need to import some functions from the Jotai library, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解语法的简洁性，让我们看看使用Jotai的相同计数示例。首先，我们需要从Jotai库中导入一些函数，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `atom` function and the `useAtom` hook are basic functions provided by Jotai.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`atom`函数和`useAtom`钩子是Jotai提供的基本函数。'
- en: 'An atom represents a piece of a state. An atom is usually a small piece of
    state, and it is a minimum unit of triggering re-renders. The `atom` function
    creates a definition of an atom. The `atom` function takes one argument to specify
    an initial value, just as `useState` does. The following code is used to define
    a new atom:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原子代表状态的一部分。原子通常是一小块状态，它是触发重新渲染的最小单位。`atom`函数创建原子的定义。`atom`函数接受一个参数来指定初始值，就像`useState`一样。以下代码用于定义一个新的原子：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the similarity with `useState(0)`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与`useState(0)`的相似性。
- en: 'Now, we use the atom in counter components. Instead of `useState(0)`, we use
    `useAtom(countAtom)`, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在计数组件中使用原子。我们不用`useState(0)`，而是使用`useAtom(countAtom)`，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because `useAtom(countAtom)` returns the same tuple, `[count, setCount]`, as
    `useState(0)` does, the rest of the code doesn't need to be changed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`useAtom(countAtom)`返回与`useState(0)`相同的元组`[count, setCount]`，所以其余的代码不需要更改。
- en: 'Finally, our `App` component is the same as in the first example of this chapter,
    which is without Context, as illustrated in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`App`组件与本章的第一个例子相同，即没有使用Context，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unlike the second example of this chapter, which is with Context, we don't need
    a provider. This is possible due to the "default store" in Context, as we learned
    in the *Implementing the Context and Subscription pattern* section of [*Chapter
    5*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073), *Sharing Component State
    with Context and Subscription*. We can optionally use a provider when we need
    to provide different values for different subtrees.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章的第二个例子不同，该例子使用Context，我们不需要提供者。这是由于Context中的“默认存储”，正如我们在[*第五章*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073)的*实现Context和订阅模式*部分所学的，*使用Context和订阅共享组件状态*。当我们需要为不同的子树提供不同的值时，我们可以选择使用提供者。
- en: 'To have a better understanding of the syntax simplicity in Jotai, let''s suppose
    you want to add another global state—say, `text`; you would end up adding the
    following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Jotai中语法的简洁性，假设你想添加另一个全局状态——比如说，`text`；你最终会添加以下代码：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is not too bad. What we added is a Context definition and a provider definition,
    and we wrapped `App` with the `Provider` component. You can also avoid provider
    nesting, as we learned in the *Best practices for using Context* section of [*Chapter
    3*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049), *Sharing the Component State
    with Context*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太糟糕。我们添加的是一个Context定义和一个提供者定义，并且用`Provider`组件包裹了`App`。你还可以避免提供者嵌套，正如我们在[*第三章*](B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049)的*使用Context的最佳实践*部分所学的，*使用Context共享组件状态*。
- en: 'However, the same example could be done with Jotai atoms, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相同的例子也可以用Jotai原子来完成，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is far simpler. Essentially, we added just a one-line atom definition.
    Even if we had more atoms, we would just need a line for each atom definition
    in Jotai. On the other hand, using Context would require creating a Context for
    each piece of state. It's possible to do it with Context, but not trivial. Jotai's
    syntax is much more simplified. This is the first benefit of Jotai.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这要简单得多。本质上，我们只添加了一行原子定义。即使我们有更多的原子，我们只需要为每个原子定义一行在Jotai中。另一方面，使用Context需要为每个状态片段创建一个Context。虽然可以用Context做，但并不简单。Jotai的语法要简单得多。这是Jotai的第一个好处。
- en: While the syntax simplicity is great, it doesn't give any new capability. Let's
    briefly discuss the second benefit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语法简洁性很好，但它并没有提供任何新的功能。让我们简要地讨论第二个好处。
- en: Dynamic atom creation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态原子创建
- en: The second benefit of Jotai is a new capability—that is, dynamic atom creation.
    Atoms can be created and destroyed in the React component lifecycle. This is not
    possible with the multiple-Context approach, because adding a new state means
    adding a new `Provider` component. If you add a new component, all its child components
    will be remounted, throwing away their states. We will cover a use case of dynamic
    atom creation in the *Adding an array structure* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai的第二个好处是新的功能——即动态原子创建。原子可以在React组件的生命周期中创建和销毁。这与多上下文方法不同，因为添加新状态意味着添加一个新的`Provider`组件。如果你添加了一个新组件，所有其子组件都将重新挂载，丢弃它们的状态。我们将在*添加数组结构*部分介绍动态原子创建的用例。
- en: The implementation of Jotai is based on what we learned in [*Chapter 5*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073),
    *Sharing Component State with Context and Subscription*. Jotai's store is basically
    a `WeakMap` object ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap))
    of atom config objects and atom values. An `atom` function. An `useAtom` hook
    returns. Subscription in Jotai is atom-based, which means the `useAtom` hook subscribes
    to a certain atom in `store`. Atom-based Subscription gives the ability to avoid
    extra re-renders. We will discuss this further in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai的实现基于我们在[*第五章*](B17780_05_Final_VK_ePub.xhtml#_idTextAnchor073)学到的内容，*使用上下文和订阅共享组件状态*。Jotai的store基本上是一个原子配置对象和原子值的`WeakMap`对象([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap))。一个`atom`函数。`useAtom`钩子返回。Jotai中的订阅是基于原子的，这意味着`useAtom`钩子订阅了`store`中的某个原子。基于原子的订阅提供了避免额外重新渲染的能力。我们将在下一节进一步讨论这一点。
- en: In this section, we discussed the basic mental model and the API of the Jotai
    library. Next up, we will dive into how the atom model solves render optimization.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Jotai库的基本心智模型和API。接下来，我们将深入了解原子模型是如何解决渲染优化的。
- en: Exploring render optimization
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索渲染优化
- en: Let's recap on selector-based render optimization. We will start by using an
    example from [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing
    Module State with Subscription*, where we created `createStore` and `useStoreSelector`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下基于选择器的渲染优化。我们将从一个例子开始，这个例子来自[*第四章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)，*使用订阅共享模块状态*，在那里我们创建了`createStore`和`useStoreSelector`。
- en: 'Let''s define a new `store` person with `createStore`. We define three properties:
    `firstName`, `lastName`, and `age`, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`createStore`定义一个新的`store`对象`person`。我们定义三个属性：`firstName`、`lastName`和`age`，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Suppose we would like to create a component that shows `firstName` and `lastName`.
    One straightforward way is to select those properties. Here is an example with
    `useStoreSelector`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个显示`firstName`和`lastName`的组件。一种直接的方法是选择这些属性。以下是一个使用`useStoreSelector`的例子：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we have selected only two properties from the `store`, when the non-selected
    property, `age`, is changed, `PersonComponent` will not re-render.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只从`store`中选择了两个属性，当未选择的属性`age`发生变化时，`PersonComponent`不会重新渲染。
- en: This `store` and selector approach is what we call `store` that holds everything
    and select pieces of state from the `store` as necessary.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`store`和选择器方法就是我们所说的“store”，它包含了一切，并在需要时从`store`中选择状态片段。
- en: 'Now, what would Jotai atoms look like for the same example? First, we define
    atoms, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Jotai原子对于相同的示例会是什么样子呢？首先，我们定义原子，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Atoms are units of triggering re-renders. You can make atoms as small as you
    want to control re-renders, like primitive values. But atoms can be objects too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 原子是触发重新渲染的单位。你可以将原子做得尽可能小以控制重新渲染，就像原始值一样。但原子也可以是对象。
- en: '`PersonComponent` can be implemented with the `useAtom` hook, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonComponent`可以使用`useAtom`钩子实现，如下所示：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because this has no relationship with `ageAtom`, `PersonComponent` won't re-render
    when the value of `ageAtom` is changed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这与`ageAtom`没有关系，所以当`ageAtom`的值发生变化时，`PersonComponent`不会重新渲染。
- en: 'Atoms can be as small as possible, but that means we would probably have too
    many atoms to organize. Jotai has a notion of derived atoms, where you can create
    another atom from existing atoms. Let''s create a `personAtom` variable that holds
    the first name, last name, and age. We can use the `atom` function, which takes
    a `read` function to generate a derived value. The code is illustrated in the
    following snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 原子可以尽可能小，但这意味着我们可能会有太多的原子需要组织。Jotai有一个关于派生原子的概念，你可以从现有原子中创建另一个原子。让我们创建一个名为`personAtom`的变量，它包含名字、姓氏和年龄。我们可以使用`atom`函数，它接受一个`read`函数来生成派生值。代码在以下代码片段中展示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `read` function takes an argument called `get`, with which you can refer
    to other atoms and get their values. The value of `personAtom` is an object with
    three properties—`firstName`, `lastName`, and `age`. This value is updated whenever
    one of the properties is changed, which means when `firstNameAtom`, `lastNameAtom`,
    or `ageAtom` is updated. This is called dependency tracking and is automatically
    done by the Jotai library.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`函数接受一个名为`get`的参数，你可以通过它引用其他原子并获取它们的值。`personAtom`的值是一个具有三个属性的对象——`firstName`、`lastName`和`age`。这个值在任何一个属性发生变化时都会更新，这意味着当`firstNameAtom`、`lastNameAtom`或`ageAtom`更新时。这被称为依赖跟踪，并且由Jotai库自动完成。'
- en: Important Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Dependency tracking is dynamic and works for conditional evaluations. For example,
    suppose a `read` function is `(get) => get(a) ? get(b) : get(c)`. In this case,
    if the value of `a` is truthy, the dependency is `a` and `b`, whereas if the value
    of `a` is falsy, the dependency is `a` and `c`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '依赖跟踪是动态的，适用于条件评估。例如，假设一个`read`函数是`(get) => get(a) ? get(b) : get(c)`。在这种情况下，如果`a`的值是真实的，则依赖项是`a`和`b`，而如果`a`的值是假的，则依赖项是`a`和`c`。'
- en: 'Using `personAtom`, we could re-implement `PersonComponent`, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`personAtom`，我们可以重新实现`PersonComponent`，如下所示：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, this is not what we expect. It will re-render when `ageAtom` changes
    its value, hence causing extra re-renders.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们预期的结果。当`ageAtom`改变其值时，它会重新渲染，从而引起额外的重新渲染。
- en: 'To avoid extra re-renders, we should create a derived atom including only values
    we use. Here is another atom, named `fullNameAtom` this time:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免额外的重新渲染，我们应该创建一个只包含我们使用的值的派生原子。这里有一个名为`fullNameAtom`的另一个原子：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using `fullNameAtom`, we can implement `PersonComponent` once again, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fullNameAtom`，我们可以再次实现`PersonComponent`，如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Thanks to `fullNameAtom`, this doesn't re-render even when the `ageAtom` value
    is changed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`fullNameAtom`，即使`ageAtom`的值发生变化，它也不会重新渲染。
- en: We call this a **bottom-up** approach. We create small atoms and combine them
    to create bigger atoms. We can optimize re-renders by adding only atoms that will
    be used in components. The optimization is not automatic, but more straightforward
    with the atom model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这为**自下而上**的方法。我们创建小的原子并将它们组合起来创建更大的原子。我们可以通过仅添加将在组件中使用到的原子来优化重新渲染。优化不是自动的，但在原子模型中更为直接。
- en: 'How could we do the last example with a store and selector approach? Here is
    an example with an `identity` selector:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用存储和选择器方法来完成最后一个示例？以下是一个使用`identity`选择器的示例：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you might guess, this causes extra re-renders. When the `age` property in
    the `store` is changed, the component re-renders.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这会导致额外的重新渲染。当`store`中的`age`属性发生变化时，组件会重新渲染。
- en: 'A possible fix would be to select only `firstName` and `lastName`. The following
    example illustrates this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的修复方法是只选择`firstName`和`lastName`。以下示例说明了这一点：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, this doesn't work. When `age` is changed, the `selectFullName`
    function is re-evaluated, and it returns a new object with the same property values.
    `useStoreSelector` assumes the new object may contain new values and trigger re-renders,
    which causes extra re-renders. This is a well-known issue with the selector approach,
    and typical solutions are to use either a custom equality function or a memoization
    technique.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这不起作用。当 `age` 发生变化时，`selectFullName` 函数会被重新评估，并返回一个具有相同属性值的新对象。`useStoreSelector`
    假设新对象可能包含新值并触发重新渲染，这导致额外的重新渲染。这是选择器方法的一个已知问题，典型的解决方案是使用自定义相等函数或记忆化技术。
- en: The benefit of the atom model is that the composition of atoms can easily relate
    to what will be shown in a component. Thus, it's straightforward to control re-renders.
    Render optimization with atoms doesn't require the custom equality function or
    the memoization technique.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 原子模型的优点是原子组合可以轻松地与组件中将要显示的内容相关联。因此，控制重新渲染非常简单。使用原子的渲染优化不需要自定义相等函数或记忆化技术。
- en: 'Let''s look at a counter example to learn more about the derived atoms. First,
    we define two `count` atoms, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个反例来了解派生原子。首先，我们定义两个 `count` 原子，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We define a component to use those `count` atoms. Instead of defining two counter
    components, we define a single `Counter` component that works for both atoms.
    To this end, the component receives `countAtom` in its `props`, as illustrated
    in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个组件来使用那些 `count` 原子。我们不是定义两个计数组件，而是定义一个适用于两个原子的单个 `Counter` 组件。为此，组件接收
    `countAtom` 作为其 `props`，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is reusable for any `countAtom` configs. Even if we define a new `count3Atom`
    config, we don't need to define a new component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于任何 `countAtom` 配置都是可重用的。即使我们定义了一个新的 `count3Atom` 配置，我们也不需要定义一个新的组件。
- en: 'Next, we define a derived atom that calculates the total number of two counts.
    We use `atom` with a `read` function as the first argument, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个派生原子，用于计算两个计数的总数。我们使用 `atom` 和一个 `read` 函数作为第一个参数，如下所示：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the `read` function, `atom` will create a derived atom. The value of the
    derived atom is the result of the `read` function. The derived atom will re-evaluate
    its `read` function and update its value only when dependencies are changed. In
    this case, either `count1Atom` or `count2Atom` is changed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `read` 函数，`atom` 将创建一个派生原子。派生原子的值是 `read` 函数的结果。只有当依赖项发生变化时，派生原子才会重新评估其 `read`
    函数并更新其值。在这种情况下，`count1Atom` 或 `count2Atom` 发生变化。
- en: 'The `Total` component is a component to use `totalAtom` and show the `total`
    number, as illustrated in the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Total` 组件是一个用于使用 `totalAtom` 并显示 `total` 数值的组件，如下面的代码片段所示：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`totalAtom` is a derived atom and it''s read-only because its value is the
    result of the `read` function. Hence, there''s no notion of setting a value of
    `totalAtom`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalAtom` 是一个派生原子，它是只读的，因为它的值是 `read` 函数的结果。因此，没有设置 `totalAtom` 值的概念。'
- en: 'Finally, we define an `App` component. It passes `count1Atom` and `count2Atom`
    to `Counter` components, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个 `App` 组件。它将 `count1Atom` 和 `count2Atom` 传递给 `Counter` 组件，如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Atoms can be passed as `props`, such as the `Counter` atom in this example,
    or they can be passed by any other means—constants at the module level, `props`,
    contexts, or even as values in other atoms. We will learn about the use case of
    putting atoms in another atom in the *Adding an array structure* section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 原子可以作为 `props` 传递，例如本例中的 `Counter` 原子，或者可以通过任何其他方式传递——模块级别的常量、`props`、上下文，甚至作为其他原子中的值。我们将在
    *添加数组结构* 部分了解将原子放入另一个原子的用例。
- en: 'When you run the app, you will see an equation of the first count, the second
    count, and the total number. By clicking the buttons shown right after the counts,
    you will see the count incremented as well as the total number, as illustrated
    in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会看到一个包含第一个计数、第二个计数和总数的等式。通过点击显示在计数之后的按钮，你会看到计数增加以及总数，如下面的截图所示：
- en: '![Figure 8.1 – Screenshot of the counter app ](img/Figure_8.1_B17780.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 计数应用程序的截图](img/Figure_8.1_B17780.jpg)'
- en: Figure 8.1 – Screenshot of the counter app
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 计数应用程序的截图
- en: In this section, we learned about the atom model and render optimization in
    the Jotai library. Next up, we'll look into how Jotai stores atom values.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了 Jotai 库中的原子模型和渲染优化。接下来，我们将探讨 Jotai 如何存储原子值。
- en: Understanding how Jotai works to store atom values
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Jotai 如何存储原子值
- en: So far, we haven't discussed how Jotai uses Context. In this section, we'll
    show how Jotai stores atom values and how atoms are reusable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论Jotai如何使用Context。在本节中，我们将展示Jotai如何存储原子值以及原子是如何可重用的。
- en: 'First, let''s revisit a simple atom definition, `countAtom`. `atom` takes an
    initial value of `0` and returns an atom config, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一个简单的原子定义，`countAtom`。`atom`接受一个初始值`0`并返回一个原子配置，如下所示：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implementation-wise, `countAtom` is an object holding some properties representing
    the atom behavior. In this case, `countAtom` is a primitive atom, which is an
    atom with a value that can be updated with a value or an updating function. A
    primitive atom is designed to behave like `useState`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上，`countAtom`是一个包含一些表示原子行为的属性的对象。在这种情况下，`countAtom`是一个原始原子，它是一个可以更新为值或更新函数的值的原子。原始原子被设计成像`useState`一样行为。
- en: What is important is that atom configs such as `countAtom` don't hold their
    values. We have a `store` that holds atom values. A `store` has a `WeakMap` object
    whose key is an atom config object and whose value is an atom value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，像`countAtom`这样的原子配置不持有它们的值。我们有一个`store`来持有原子值。`store`有一个`WeakMap`对象，其键是一个原子配置对象，其值是一个原子值。
- en: 'When we use `useAtom`, by default, it uses a default `store` defined at the
    module level. However, Jotai provides a component named `Provider`, which lets
    you create a `store` at the component level. We can import `Provider` from the
    Jotai library along with `atom` and `useAtom`, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`useAtom`时，默认情况下，它使用在模块级别定义的默认`store`。然而，Jotai提供了一个名为`Provider`的组件，它允许你在组件级别创建`store`。我们可以从Jotai库中导入`Provider`以及`atom`和`useAtom`，如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s suppose we have the `Counter` component defined, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经定义了`Counter`组件，如下所示：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the same component we defined in the *Understanding Jotai* section and
    the *Exploring render optimization* section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在*理解Jotai*部分和*探索渲染优化*部分中定义的相同组件。
- en: 'We then define an `App` component using `Provider`. We use two `Provider` components
    and put in two `Counter` components for each `Provider` component, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用`Provider`定义一个`App`组件。我们使用两个`Provider`组件，并为每个`Provider`组件放入两个`Counter`组件，如下所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The two `Provider` components in `App` isolate stores. Hence, `countAtom` used
    in `Counter` components is isolated. The two `Counter` components under the first
    `Provider` component share the `countAtom` value, but the other two `Counter`
    components under the second `Provider` component have different values of `countAtom`
    from the value in the first `Provider` component, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`中的两个`Provider`组件隔离了存储。因此，在`Counter`组件中使用的`countAtom`是隔离的。第一个`Provider`组件下的两个`Counter`组件共享`countAtom`的值，但第二个`Provider`组件下的另外两个`Counter`组件的`countAtom`值与第一个`Provider`组件中的值不同，如上图所示：
- en: '![Figure 8.2 – Screenshot of the two-provider app ](img/Figure_8.2_B17780.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 两个-provider应用的截图](img/Figure_8.2_B17780.jpg)'
- en: Figure 8.2 – Screenshot of the two-provider app
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 两个-provider应用的截图
- en: Again, what is important is that `countAtom` itself doesn't hold a value. Thus,
    `countAtom` is reusable for multiple `Provider` components. This is a notable
    difference from module states.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，重要的是`countAtom`本身不持有值。因此，`countAtom`可以用于多个`Provider`组件。这与模块状态有显著的不同。
- en: 'We could define a derived atom. Here is a derived atom to define the doubled
    number of `countAtom`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个派生原子。以下是一个用于定义`countAtom`双倍数值的派生原子：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As `countAtom` doesn't hold a value, `doubledCountAtom` doesn't either. If `doubledCountAtom`
    is used in the first `Provider` component, it represents the doubled value of
    the `countAtom` value in the `Provider` component. The same applies to the second
    `Provider` component, and the values in the first `Provider` component can be
    different from the values in the second `Provider` component.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`countAtom`不持有值，`doubledCountAtom`也不持有值。如果`doubledCountAtom`在第一个`Provider`组件中使用，它表示`Provider`组件中`countAtom`值的两倍。同样适用于第二个`Provider`组件，并且第一个`Provider`组件中的值可以与第二个`Provider`组件中的值不同。
- en: Because atom configs are just definitions that don't hold values, the atom configs
    are reusable. The example shows it's reusable for two `Provider` components, but
    essentially, it's reusable for more `Provider` components. Furthermore, a `Provider`
    component can be used dynamically in the React component life cycle. Implementation-wise,
    Jotai is totally based on Context, and Jotai can do everything that Context can
    do. In this section, we learned that atom configs don't hold values and thus are
    reusable. Next up, we will learn how to deal with arrays with Jotai.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为原子配置只是定义而没有持有值，所以原子配置是可重用的。示例显示它可以用于两个`Provider`组件，但本质上，它可以用于更多`Provider`组件。此外，`Provider`组件可以在React组件生命周期中动态使用。在实现上，Jotai完全基于Context，Jotai可以做Context能做的所有事情。在本节中，我们了解到原子配置不持有值，因此是可重用的。接下来，我们将学习如何使用Jotai处理数组。
- en: Adding an array structure
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数组结构
- en: An array structure is tricky to handle in React. When a component renders an
    array structure, we need to pass stable `key` properties to the array items. This
    is especially necessary when we remove or reorder the array items.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中处理数组结构很棘手。当组件渲染数组结构时，我们需要为数组项传递稳定的`key`属性。这在删除或重新排序数组项时尤其必要。
- en: In this section, we'll learn how to handle array structures in Jotai. We'll
    start with a traditional approach, and then a new pattern that we call **Atoms-in-Atom**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Jotai中处理数组结构。我们将从一个传统方法开始，然后介绍一种我们称之为**原子中的原子**的新模式。
- en: Let's use the same to-do app example that we used in the *Handling structured
    data* section of [*Chapter 7*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092),
    *Use Case Scenario 1 – Zustand*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在[*第7章*](B17780_07_Final_VK_ePub.xhtml#_idTextAnchor092)的*处理结构化数据*部分中使用的相同的待办事项应用示例，即*用例场景1
    – Zustand*。
- en: 'First, we define a `Todo` type. It has the `id` string, `title` string, and
    `done` Boolean properties, as illustrated in the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`Todo`类型。它具有`id`字符串、`title`字符串和`done`布尔属性，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we define `todosAtom`, which represents an array of defined `Todo` items,
    as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`todosAtom`，它代表定义的`Todo`项数组，如下所示：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We annotate the `atom()` function with the `Todo[]` type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`Todo[]`类型注解`atom()`函数。
- en: 'We then define a `TodoItem` component. This is a pure component that receives
    `todo`, `removeTodo`, and `toggleTodo` as `props`. The code is illustrated in
    the following snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`TodoItem`组件。这是一个纯组件，它接收`todo`、`removeTodo`和`toggleTodo`作为`props`。代码如下所示：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `onChange` callback in `<input>` invokes `toggleTodo`, and the `onClick`
    callback in `<button>` invokes `removeTodo`. Both are based on the `id` string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`<input>`中的`onChange`回调调用`toggleTodo`，而`<button>`中的`onClick`回调调用`removeTodo`。两者都基于`id`字符串。'
- en: 'We wrap `TodoItem` with `memo` to create a memoized version, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`memo`包装`TodoItem`以创建一个记忆化的版本，如下所示：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This allows us to avoid re-renders unless `todo`, `removeTodo`, or `toggleTodo`
    are changed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们避免不必要的重新渲染，除非`todo`、`removeTodo`或`toggleTodo`发生变化。
- en: 'Now, we are ready to create a `TodoList` component. It uses `todosAtom`, defines
    `removeTodo` and `toggleTodo` with `useCallback`, and maps over the `todo` array,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好创建一个`TodoList`组件。它使用`todosAtom`，使用`useCallback`定义`removeTodo`和`toggleTodo`，并对`todo`数组进行映射，如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `TodoList` component renders the `MemoedTodoItem` component for each `todos`
    array item. The `key` prop is specified as `todo.id`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList`组件为每个`todos`数组项渲染`MemoedTodoItem`组件。`key`属性指定为`todo.id`。'
- en: 'The next component is `NewTodo`. It uses `todosAtom` and adds a new item on
    button click. The `id` value of the new atom should be uniquely generated, and
    in the following example, it uses `nanoid` ([https://www.npmjs.com/package/nanoid](https://www.npmjs.com/package/nanoid)):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是`NewTodo`。它使用`todosAtom`并在按钮点击时添加一个新项。新原子的`id`值应该是唯一生成的，在下面的示例中，它使用了`nanoid`([https://www.npmjs.com/package/nanoid](https://www.npmjs.com/package/nanoid))：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For simplicity, we used `useAtom` for `todosAtom`. However, this actually makes
    the `NewTodo` component re-render when the value of `todosAtom` is changed. We
    could easily avoid this with an additional utility hook called `useUpdateAtom`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们使用了`useAtom`来处理`todosAtom`。然而，这实际上使得`NewTodo`组件在`todosAtom`的值改变时重新渲染。我们可以通过一个额外的实用钩子`useUpdateAtom`轻松避免这种情况。
- en: 'Finally, we create an `App` component to render `TodoList` and `NewTodo`, as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`App`组件来渲染`TodoList`和`NewTodo`，如下所示：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This works perfectly. You can add, remove, and toggle to-do items without any
    issues, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得非常完美。你可以添加、删除和切换待办事项，没有任何问题，如下所示：
- en: '![Figure 8.3 – Screenshot of the Todo app ](img/Figure_8.3_B17780.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – Todo应用的截图](img/Figure_8.3_B17780.jpg)'
- en: Figure 8.3 – Screenshot of the Todo app
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – Todo应用的截图
- en: 'There are two concerns, though, from the developer''s perspective, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从开发者的角度来看，有两个问题，如下所示：
- en: The first concern is we need to modify the entire `todos` array to mutate a
    single item. In the `toggleTodo` function, it needs to iterate over all the items
    and mutate just one item. In the atomic model, it would be nice if we could simply
    mutate one item. This is also related to performance. When `todos` array items
    are mutated, the `todos` array itself is changed. Thus, `TodoList` re-renders.
    Thanks to `MemoedTodoItem`, the `MemoedTodoItem` components don't re-render unless
    the specific item is changed. Ideally, we want to trigger those specific `MemoedTodoItem`
    components to re-render.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是我们需要修改整个`todos`数组来修改单个项目。在`toggleTodo`函数中，它需要遍历所有项目并修改其中一个项目。在原子模型中，如果能简单地修改一个项目那就很好了。这也与性能有关。当`todos`数组的项目被修改时，`todos`数组本身也会改变。因此，`TodoList`会重新渲染。多亏了`MemoedTodoItem`，`MemoedTodoItem`组件只有在特定项目改变时才会重新渲染。理想情况下，我们希望触发那些特定的`MemoedTodoItem`组件重新渲染。
- en: The second concern is the `id` value of an item. The `id` value is primarily
    for `key` in `map`, and it would be nice if we could avoid using `id`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个问题是项目的`id`值。`id`值主要用于`map`中的`key`，如果能避免使用`id`那就更好了。
- en: With Jotai, we propose a new pattern, **Atoms-in-Atom**, with which we put atom
    configs in another atom value. This pattern addresses the two concerns and is
    more consistent with Jotai's mental model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jotai，我们提出了一种新的模式，**原子中的原子**，我们将原子配置放在另一个原子值中。这个模式解决了两个问题，并且与Jotai的心智模型更一致。
- en: Let's see how we can re-create the same Todo app we created previously in this
    section with the new pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用新的模式在这个部分重新创建之前创建的相同的Todo应用。
- en: 'We start by defining the `Todo` type, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`Todo`类型，如下所示：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This time, the `Todo` type doesn't have an `id` value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Todo`类型没有`id`值。
- en: 'We then create a `TodoAtom` type with `PrimitiveAtom`, which is a generic type
    exported by the Jotai library. The code is illustrated in the following snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`PrimitiveAtom`创建一个`TodoAtom`类型，这是Jotai库导出的一个泛型类型。代码如下所示：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We use this `TodoAtom` type to create a `todoAtomsAtom` config, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个`TodoAtom`类型来创建一个`todoAtomsAtom`配置，如下所示：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The name is explicit, to tell that it's an `atom` that represents an array of
    `TodoAtom`. This structure is why the pattern is named **Atoms-in-Atom**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是明确的，表明这是一个代表`TodoAtom`数组的`atom`。这种结构就是为什么这个模式被命名为**原子中的原子**。
- en: 'Here is the `TodoItem` component. It receives `todoAtom` and `remove` properties.
    The component uses the `todoAtom` atom with `useAtom`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`TodoItem`组件。它接收`todoAtom`和`remove`属性。组件使用`todoAtom`原子和`useAtom`：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Thanks to the `useAtom` config in the `TodoItem` component, the `onChange` callback
    is very simple and only cares about the item. It doesn't depend on the fact that
    it's an item of the array.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`TodoItem`组件中的`useAtom`配置，`onChange`回调非常简单，只关心项目。它不依赖于它是否是数组中的一个项目。
- en: 'The `TodoList` component should be carefully looked at. It uses `todoAtomsAtom`,
    which returns `todoAtoms` as its value. The `todoAtoms` variable holds an array
    of `todoAtom`. The `remove` function is interesting as it takes `todoAtom` as
    the atom config and filters the `todoAtom` array in `todoAtomsAtom`. The full
    code of `TodoList` is shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 应该仔细查看`TodoList`组件。它使用`todoAtomsAtom`，它返回`todoAtoms`作为其值。`todoatoms`变量包含一个`todoAtom`数组。`remove`函数很有趣，因为它接受`todoAtom`作为原子配置，并在`todoAtomsAtom`中过滤`todoAtom`数组。`TodoList`的完整代码如下所示：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`TodoList` maps over the `todoAtoms` variable and renders `MemoedTodoItem`
    for each `todoAtom` config. For `key` in `map`, we specify the stringified `todoAtom`
    config. An atom config returns a `TodoList` component is slightly different from
    the previous version. Because it deals with `todoAtomsAtom` won''t be changed
    if one of the items is toggled with `toggleTodo`. Thus, it can reduce some extra
    re-renders by nature.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoList`遍历`todoatoms`变量，并为每个`todoAtom`配置渲染`MemoedTodoItem`。对于`map`中的`key`，我们指定了字符串化的`todoAtom`配置。原子配置返回的`TodoList`组件与上一个版本略有不同。因为它处理`todoatomsAtom`，如果其中一个项目使用`toggleTodo`被切换，它不会改变。因此，它可以自然地减少一些额外的重新渲染。'
- en: 'The `NewTodo` component is almost the same as the previous example. One exception
    is that when creating a new item, it will create a new atom config and push it
    into `todoAtomsAtom`. The following snippet shows the `NewTodo` component code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewTodo` 组件几乎与前一个示例相同。一个例外是，在创建新项目时，它将创建一个新的原子配置并将其推入 `todoAtomsAtom`。以下代码片段显示了
    `NewTodo` 组件的代码：'
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The reset of the code and the behavior of the `NewTodo` component are basically
    equivalent to the previous example.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分和 `NewTodo` 组件的行为基本上与前一个示例等效。
- en: 'Finally, we have the same `App` component to run the app, as illustrated here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有相同的 `App` 组件来运行应用程序，如图所示：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you run the app, you will see no differences from the previous example. As
    described, the differences are for developers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你将看不到与前一个示例的差异。如描述的那样，这些差异是为了开发者。
- en: 'Let''s summarize the difference with the **Atoms-in-Atom** pattern, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下与 **原子内原子** 模式的区别，如下所示：
- en: An array atom is used to hold an array of item atoms.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组原子用于存储项目原子的数组。
- en: To add a new item in the array, we create a new atom and add it.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在数组中添加新项目，我们创建一个新的原子并将其添加。
- en: Atom configs can be evaluated as strings, and they return UIDs.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子配置可以作为字符串进行评估，并返回 UIDs。
- en: A component that renders an item uses an item atom in each component. It eases
    mutating the item value and avoids extra re-renders naturally.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个渲染项目的组件在每个组件中使用项目原子。它简化了项目值的修改，并自然地避免了额外的重新渲染。
- en: In this section, we learned how to handle the array structure. We saw two patterns—a
    naive one and an **Atoms-in-Atom** one—and their differences. Next up, we will
    learn about some other features that the Jotai library provides.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何处理数组结构。我们看到了两种模式——一种天真模式和一种 **原子内原子** 模式——以及它们的区别。接下来，我们将学习 Jotai
    库提供的其他一些功能。
- en: Using the different features of Jotai
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jotai 的不同功能
- en: So far, we've learned some basics of the Jotai library. There are some more
    basic features that we will cover in this section. These features are necessary
    if you need to deal with complex scenarios. We'll also briefly introduce some
    advanced features whose use cases are out of the scope of this book.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 Jotai 库的一些基础知识。在本节中，我们将介绍一些更基本的功能，这些功能在处理复杂场景时是必要的。我们还将简要介绍一些高级功能，这些功能的用例超出了本书的范围。
- en: 'In this section, we''ll discuss the following topics:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下主题：
- en: Defining the `write` function of atoms
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义原子的 `write` 函数
- en: Using action atoms
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动作原子
- en: Understanding the `onMount` option of atoms
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解原子的 `onMount` 选项
- en: Introducing the `jotai/utils` bundle
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 `jotai/utils` 包
- en: Understanding library usage
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解库的使用
- en: Introduction to more advanced features
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级功能的介绍
- en: Let's take a look at each one now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看。
- en: Defining the write function of atoms
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义原子的 `write` 函数
- en: 'We have seen how to create a derived atom. For example, `doubledCountAtom`
    with `countAtom` is defined in the *Understanding how Jotai works to store atom
    values* section, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建派生原子。例如，`doubledCountAtom` 与 `countAtom` 在 *理解 Jotai 如何存储原子值* 部分中定义，如下所示：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`countAtom` is called a primitive atom because it''s not derived from another
    atom. A primitive atom is a writable atom where you can change the value.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`countAtom` 被称为原始原子，因为它不是从另一个原子派生出来的。原始原子是一个可写的原子，你可以更改其值。'
- en: '`doubledCountAtom` is a read-only derived atom because its value is fully dependent
    on `countAtom`. The value of `doubledCountAtom` can only be changed by changing
    the value of `countAtom`, which is a writable atom.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`doubledCountAtom` 是一个只读的派生原子，因为它的值完全依赖于 `countAtom`。`doubledCountAtom` 的值只能通过更改
    `countAtom` 的值来更改，而 `countAtom` 是一个可写的原子。'
- en: To create a writable derived atom, the `atom` function accepts an optional second
    argument for the `write` function, in addition to the first argument `read` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可写的派生原子，`atom` 函数除了接受第一个参数 `read` 函数外，还接受一个可选的第二个参数 `write` 函数。
- en: 'For example, let''s redefine `doubledCountAtom` to be writable. We pass a `write`
    function that will change the value of `countAtom`, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们重新定义 `doubledCountAtom` 以使其可写。我们传递一个 `write` 函数，该函数将改变 `countAtom` 的值，如下所示：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `write` function takes three arguments, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 函数接受三个参数，如下所示：'
- en: '`get` is a function to return the value of an atom.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` 是一个返回原子值的函数。'
- en: '`set` is a function to set the value of an atom.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 是一个用于设置原子值的函数。'
- en: '`arg` is an arbitrary value to receive when updating the atom (in this case,
    `doubledCountAtom`).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg` 是在更新原子时接收的任意值（在这种情况下，`doubledCountAtom`）。'
- en: With the `write` function, the created atom is writable as if it is a primitive
    atom. Actually, it is not exactly the same as `countAtom` because `countAtom`
    accepts an updating function such as `setCount((c) => c + 1)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `write` 函数，创建的原子可以像原始原子一样写入。实际上，它并不完全像 `countAtom`，因为 `countAtom` 接受一个更新函数，例如
    `setCount((c) => c + 1)`。
- en: 'We can technically create a new atom that behaves identically to `countAtom`.
    What would be the use case? For example, you can add logging, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以技术上创建一个与 `countAtom` 行为完全相同的新的原子。这会有什么用例？例如，你可以添加日志，如下所示：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`anotherCountAtom` works like `countAtom`, and it shows a logging message when
    it sets a value.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`anotherCountAtom` 与 `countAtom` 的工作方式相同，并在设置值时显示一条日志消息。'
- en: Writable derived atoms are a powerful feature that can help in some complex
    scenarios. In the next subsection, we'll see another pattern using `write` functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可写派生原子是一个强大的功能，可以在某些复杂场景中提供帮助。在下一小节中，我们将看到使用 `write` 函数的另一种模式。
- en: Using action atoms
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动作原子
- en: To organize state mutation code, we often create a function or a set of functions.
    We can use atoms for that purpose and call them action atoms.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了组织状态变更代码，我们通常会创建一个或多个函数。我们可以为此目的使用原子，并将它们称为动作原子。
- en: To create action atoms, we only use the `write` function of the `atom` function's
    second argument. The first argument can be anything, but we often use `null` as
    a convention.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建动作原子，我们只使用 `atom` 函数第二个参数的 `write` 函数。第一个参数可以是任何东西，但我们通常使用 `null` 作为惯例。
- en: 'Let''s look at an example. We have `countAtom` as usual and `incrementCountAtom`,
    which is an action atom, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。我们有 `countAtom` 如常，以及 `incrementCountAtom`，它是一个动作原子，如下所示：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, the `write` function of `incrementCountAtom` only uses `set`,
    out of three arguments.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`incrementCountAtom` 的 `write` 函数只使用了三个参数中的 `set`。
- en: 'We can use this atom like normal atoms, and just ignore its value. For example,
    here is a component to show a button to increment the count:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个原子像普通原子一样，只需忽略它的值。例如，这里是一个显示增加计数按钮的组件：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is a simple case without an argument. You could accept an argument and
    you could create as many action atoms as you want.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有参数的简单案例。你可以接受一个参数，并且可以创建任意数量的动作原子。
- en: Next, we will see a less commonly used but important feature.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一个不太常用但很重要的特性。
- en: Understanding the onMount option of atoms
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解原子的 onMount 选项
- en: In some use cases, we want to run certain logic once an atom starts to be used.
    A good example is to subscribe to an external data source. This can be done with
    the `useEffect` hook, but to define logic at the atom level, Jotai atoms have
    the `onMount` option.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，我们希望在原子开始使用时运行某些逻辑。一个很好的例子是订阅外部数据源。这可以通过 `useEffect` 钩子来完成，但为了在原子级别定义逻辑，Jotai
    原子有 `onMount` 选项。
- en: 'To understand how it is used, let''s create an atom that shows a login message
    on mount and unmount, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它是如何使用的，让我们创建一个原子，它在挂载和卸载时显示登录消息，如下所示：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The body of the `onMount` function is showing a logging message about the start
    of use. It also returns an `onUnmount` function, which shows a logging message
    about the end of use. The `onMount` function takes an argument, which is a function
    to update `countAtom`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMount` 函数的主体显示有关使用开始的日志消息。它还返回一个 `onUnmount` 函数，显示有关使用结束的日志消息。`onMount`
    函数接受一个参数，这是一个用于更新 `countAtom` 的函数。'
- en: This is a contrived example, but there are many real use cases to connect external
    data sources.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个虚构的例子，但有许多实际用例可以连接外部数据源。
- en: Next, we'll talk about utility functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论实用函数。
- en: Introducing the jotai/utils bundle
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 jotai/utils 包
- en: The Jotai library provides two basic functions, `atom` and `useAtom`, and an
    additional `Provider` component in the main bundle. While the small API is good
    to understand the basic features, we want some utility functions to help development.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai 库提供了两个基本函数 `atom` 和 `useAtom`，以及主包中的一个额外的 `Provider` 组件。虽然小 API 很好理解基本功能，但我们希望有一些实用函数来帮助开发。
- en: Jotai provides a separate bundle named `jotai/utils` that contains a variety
    of utility functions. For example, `atomWithStorage` is a function to create atoms
    with a specific feature—that is, to synchronize with persistent storage. For more
    information and other utility functions, refer to the project site at [https://github.com/pmndrs/jotai](https://github.com/pmndrs/jotai).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Jotai 提供了一个名为 `jotai/utils` 的单独包，其中包含各种实用函数。例如，`atomWithStorage` 是一个创建具有特定功能的原子的函数——即与持久存储同步。有关更多信息和其他实用函数，请参阅项目网站
    [https://github.com/pmndrs/jotai](https://github.com/pmndrs/jotai)。
- en: Next, we will discuss how the Jotai library can be used in other libraries.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在其他库中使用Jotai库。
- en: Understanding library usage
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解库的使用
- en: Suppose two libraries use the Jotai library internally. If we develop an app
    that uses the two libraries, there's an issue of double providers. Because Jotai
    atoms are distinguished by reference, it is possible that the atoms in the first
    library accidentally connect to the provider in the second library. As a result,
    it may not work as expected by the library authors. The Jotai library provides
    a notion of "scope", which is the way to connect to a specific provider. To make
    it work as expected, we should pass the same scope variable to the `Provider`
    component and the `useAtom` hook.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个库在内部使用Jotai库。如果我们开发一个使用这两个库的应用程序，将存在双重提供者的问题。因为Jotai原子通过引用来区分，所以第一个库中的原子可能会意外地连接到第二个库中的提供者。结果，它可能无法按库作者的预期工作。Jotai库提供了一个“作用域”的概念，这是连接到特定提供者的方式。为了使其按预期工作，我们应该将相同的范围变量传递给`Provider`组件和`useAtom`钩子。
- en: Implementation-wise, this is how Context works. The scope feature is just used
    to put back the Context feature. It's still under exploration how this feature
    can be used for other purposes. We, as a community, will work on more use cases
    with this feature.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，这是Context的工作方式。作用域功能只是用来恢复Context功能。如何使用此功能进行其他目的仍在探索中。作为社区的一员，我们将利用此功能进行更多用例的开发。
- en: Finally, we'll see some advanced features in the Jotai library.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到Jotai库中的一些高级功能。
- en: Introduction to more advanced features
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级功能介绍
- en: There are more advanced features that we didn't cover in this book.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们还没有涵盖更多高级功能。
- en: Most notably, Jotai supports the React Suspense feature. When a derived atom's
    `read` function returns a promise, the `useAtom` hook will suspend, and React
    will show a fallback. This feature is experimental and subject to change, but
    it's a very important feature to explore.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最值得注意的是，Jotai 支持React Suspense功能。当一个派生原子的`read`函数返回一个promise时，`useAtom`钩子将暂停，React将显示一个回退。这个功能是实验性的，可能会发生变化，但它是一个非常重要的功能值得探索。
- en: Another note is about library integrations. Jotai is a library to solve a single
    problem with the atomic model, which is to avoid extra re-renders. By integrating
    with other libraries, the use case expands. The atomic model is flexible to integrate
    with other libraries, and especially, the `onMount` option is necessary for external
    data sources.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是关于库的集成。Jotai是一个使用原子模型解决单个问题的库，即避免额外的重新渲染。通过与其他库集成，使用场景得以扩展。原子模型具有足够的灵活性，可以与其他库集成，特别是对于外部数据源，`onMount`选项是必要的。
- en: 'To learn more about these advanced features, refer to the project site:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这些高级功能的信息，请参考项目网站：
- en: '[https://github.com/pmndrs/jotai](https://github.com/pmndrs/jotai)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pmndrs/jotai](https://github.com/pmndrs/jotai)'
- en: In this section, we discussed some additional features that the Jotai library
    provides. Jotai is a primitive library to provide building blocks, yet is flexible
    enough to cover real use cases.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Jotai库提供的其他一些功能。Jotai是一个提供构建块的原始库，但足够灵活，可以覆盖实际使用场景。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about a library called Jotai. It's based on the
    atomic model and Context. We've seen simple examples to learn its basics, yet
    they show the flexibility of the atomic model. The combination of Context and
    Subscription is the only way to have a React-oriented global state. If your requirement
    is Context without extra re-renders, this approach should be your choice.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了名为Jotai的库。它基于原子模型和Context，我们通过简单的示例学习了其基础知识，但它们展示了原子模型的灵活性。Context和订阅的组合是唯一实现面向React的全局状态的方法。如果你的需求是Context且没有额外的重新渲染，这种方法应该是你的选择。
- en: In the next chapter, we will learn about another library, called Valtio, which
    is a library primarily for module state, with a unique syntax.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个名为Valtio的库，这是一个主要用于模块状态的库，具有独特的语法。
