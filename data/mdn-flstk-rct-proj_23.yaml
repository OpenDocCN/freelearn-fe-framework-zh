- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Advanced Next.js Concepts and Optimizations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Next.js 概念和优化
- en: Now that we’ve learned about the essential features of Next.js and **React Server
    Components** (**RSCs**), let’s dive a bit deeper into the Next.js framework. In
    this chapter, we are going to learn how caching works in Next.js and how it can
    be used to optimize our applications. We are also going to learn how to implement
    API routes in Next.js. Then, we are going to learn how to optimize a Next.js app
    for search engines and social media by adding metadata. Finally, we are going
    to learn how to optimally load images and fonts in Next.js.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Next.js 和 **React 服务器组件**（**RSCs**）的基本功能，让我们更深入地探讨 Next.js 框架。在本章中，我们将学习
    Next.js 中的缓存工作原理以及如何利用它来优化我们的应用程序。我们还将学习如何在 Next.js 中实现 API 路由。然后，我们将学习如何通过添加元数据来优化
    Next.js 应用程序以适应搜索引擎和社交媒体。最后，我们将学习如何在 Next.js 中最优地加载图片和字体。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining API routes in Next.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Next.js 中定义 API 路由
- en: Caching in Next.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 中的缓存
- en: '**Search engine optimization** (**SEO**) with Next.js'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索引擎优化**（**SEO**）与 Next.js'
- en: Optimized image and font loading in Next.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Next.js 中优化的图片和字体加载
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装来自 [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) *为全栈开发做准备* 和 [*第 2
    章*](B19385_02.xhtml#_idTextAnchor028) *了解 Node.js 和 MongoDB* 的所有要求。
- en: The versions listed in those chapters are the ones used in this book. While
    installing a newer version should not be an issue, please note that certain steps
    might work differently. If you are having an issue with the code and steps provided
    in this book, please try using the versions mentioned in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)
    and *2*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是本书中使用的版本。虽然安装较新版本可能不会有问题，但请注意，某些步骤可能会有所不同。如果你在使用本书中提供的代码和步骤时遇到问题，请尝试使用
    [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) 和 *2* 中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch18)。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/jzCRoJPGoG0](https://youtu.be/jzCRoJPGoG0).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可在以下网址找到：[https://youtu.be/jzCRoJPGoG0](https://youtu.be/jzCRoJPGoG0)。
- en: Defining API routes in Next.js
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Next.js 中定义 API 路由
- en: In the previous chapter, we used RSCs to access our database via a data layer;
    no API routes were needed for that! However, sometimes, it still makes sense to
    expose an external API. As an example, we might want to allow third-party apps
    to query blog posts. Thankfully, Next.js also has a feature to define API routes,
    called Route Handlers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 RSCs 通过数据层访问我们的数据库；为此不需要 API 路由！然而，有时公开外部 API 仍然是有意义的。例如，我们可能希望允许第三方应用程序查询博客文章。幸运的是，Next.js
    也提供了一个名为路由处理器（Route Handlers）的功能来定义 API 路由。
- en: 'Route Handlers are also defined inside the `src/app/` directory but in a `route.js`
    file instead of a `page.js` file (a path can only be either a route or a page,
    so only one of these files should be placed inside a folder). Instead of exporting
    a page component, we need to export functions that handle various types of requests
    there. For example, to handle a `GET` request, we must define and export the following
    function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理器也定义在 `src/app/` 目录下，但是在一个 `route.js` 文件中而不是 `page.js` 文件中（一个路径只能是路由或页面，所以文件夹中只能放置这些文件中的一个）。我们不需要导出一个页面组件，而是需要导出处理各种类型请求的函数。例如，要处理
    `GET` 请求，我们必须定义并导出以下函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next.js supports the following HTTP methods for Route Handlers: `GET`, `POST`,
    `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS`. For unsupported methods, Next.js
    will return a `405 Method Not` `Allowed` response.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 支持以下 HTTP 方法用于路由处理器：`GET`、`POST`、`PUT`、`PATCH`、`DELETE`、`HEAD` 和 `OPTIONS`。对于不支持的方法，Next.js
    将返回 `405 Method Not Allowed` 响应。
- en: Next.js supports the native `Request` ([https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request))
    and `Response` ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response))
    web APIs but extends them into `NextRequest` and `NextResponse` APIs, which make
    handling cookies and headers easier. We used the `cookies()` function from Next.js
    to easily create, get, and delete a cookie for the JWT in the previous chapter.
    The `headers()` function makes it easy to get headers from a request. These functions
    can be used in the same way in RSCs and Route Handlers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js支持原生的`Request`([https://developer.mozilla.org/en-US/docs/Web/API/Request](https://developer.mozilla.org/en-US/docs/Web/API/Request))和`Response`([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response))网络API，但将它们扩展为`NextRequest`和`NextResponse`
    API，这使得处理cookie和头部信息变得更容易。我们在上一章中使用了Next.js的`cookies()`函数来轻松创建、获取和删除JWT的cookie。`headers()`函数使得从请求中获取头部信息变得容易。这些函数可以在RSCs和路由处理器中以相同的方式使用。
- en: Creating an API route for listing blog posts
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为列出博客文章创建API路由
- en: 'Let’s start by defining an API route for listing blog posts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个用于列出博客文章的API路由：
- en: 'Copy the existing **ch17** folder to a new **ch18** folder, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤将现有的**ch17**文件夹复制到新的**ch18**文件夹：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the **ch18** folder in VS Code.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开**ch18**文件夹。
- en: To make the API routes easier to distinguish from pages on our app, create a
    new **src/app/api/** folder.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使API路由更容易与我们的应用页面区分开来，创建一个新的**src/app/api/**文件夹。
- en: Inside the **src/app/api/** folder, create a new **src/app/api/v1/** folder
    to make sure our API is versioned for potential changes to the API later.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**src/app/api/**文件夹内，创建一个新的**src/app/api/v1/**文件夹，以确保我们的API在将来可能对API进行更改时进行了版本控制。
- en: Next, create a **src/app/api/v1/posts/** folder for the **/****api/v1/posts**
    route.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为**/****api/v1/posts**路由创建一个**src/app/api/v1/posts/**文件夹。
- en: 'Create a new **src/app/api/posts/route.js** file, where we import the **initDatabase**
    function and the **listAllPosts** function from the data layer:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**src/app/api/posts/route.js**文件，其中我们从数据层导入**initDatabase**函数和**listAllPosts**函数：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, define and export a **GET** function. This is going to handle HTTP GET
    requests to the **/****api/v1/posts** route:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义并导出一个**GET**函数。这个函数将处理对**/****api/v1/posts**路由的HTTP GET请求：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside it, we must initialize the database and get a list of all posts:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，我们必须初始化数据库并获取所有文章的列表：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use the **Response** web API to generate a JSON response:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Response**网络API生成JSON响应：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure Docker and the MongoDB container are running properly!
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Docker和MongoDB容器运行正常！
- en: 'Start the Next.js app, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤启动Next.js应用：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, go to **http://localhost:3000/api/v1/posts** to see the posts being returned
    as JSON, as shown in the following figure:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前往**http://localhost:3000/api/v1/posts**查看返回的JSON格式的文章，如下所示：
- en: '![Figure 18.1 – JSON response with posts generated from the Next.js Route Handler](img/B19385_18_1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图18.1 – 由Next.js路由处理器生成的JSON响应](img/B19385_18_1.jpg)'
- en: Figure 18.1 – JSON response with posts generated from the Next.js Route Handler
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1 – 由Next.js路由处理器生成的JSON响应
- en: Now, third-party apps can also get the posts via our API! Let’s continue by
    learning more about caching in Next.js.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第三方应用也可以通过我们的API获取文章！让我们继续学习更多关于Next.js中的缓存知识。
- en: Caching in Next.js
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Next.js中的缓存
- en: So far, we have always been using Next.js in dev mode. In dev mode, most of
    the caching that Next.js does is turned off to make it easy for us to develop
    our apps with hot reloading and always up-to-date data. However, once we switch
    to production mode, static rendering and caching are turned on by default. Static
    rendering means that if a page only contains static components (such as an “About
    Us” or “Imprint” page, which only contains static content), it will be statically
    rendered and served as HTML, or as static text/JSON for routes. Additionally,
    Next.js will try to cache data and server-side rendered components as much as
    possible to keep your app performant.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直都在使用Next.js的dev模式。在dev模式下，Next.js所做的大多数缓存都被关闭，以便我们能够使用热重载和始终更新的数据来开发我们的应用。然而，一旦我们切换到生产模式，静态渲染和缓存默认开启。静态渲染意味着如果一个页面只包含静态组件（例如“关于我们”或“版权声明”页面，这些页面只包含静态内容），它将被静态渲染并作为HTML或作为静态文本/JSON为路由提供服务。此外，Next.js会尽可能缓存数据和服务器端渲染的组件，以保持应用性能。
- en: 'Next.js has four main types of cache:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js有四种主要的缓存类型：
- en: '**Data cache**: A server-side cache for storing data across user requests and
    deployments. This is persistent but can be revalidated.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据缓存**：用于在用户请求和部署之间存储数据的服务器端缓存。这是持久的，但可以进行验证。'
- en: '**Request memoization**: A server-side cache for return values of functions
    if they are called multiple times in a single request.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求记忆化**：如果函数在单个请求中多次调用，则为函数的返回值提供服务器端缓存。'
- en: '**Full route cache**: A server-side cache of Next.js routes. This cache is
    persistent but can be revalidated.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整路由缓存**：Next.js路由的服务器端缓存。此缓存是持久的，但可以进行验证。'
- en: '**Router cache**: A client-side cache of routes to reduce server requests on
    navigation, for a single user session or time-based.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由缓存**：一种客户端缓存，用于存储路由以减少导航时的服务器请求，适用于单个用户会话或基于时间的。'
- en: The first two types of cache (data cache and request memoization) mainly apply
    to using the `fetch()` function on the server side to, for example, pull data
    from a third-party API. However, recently, it is also possible to use these two
    types of caches for any function by wrapping them with the `unstable_cache()`
    function. Despite its name, this function can already safely be used in production.
    It is only called “unstable” because the API might change and require code changes
    when new Next.js versions are released. See [https://nextjs.org/docs/app/api-reference/functions/unstable_cache](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)
    for more information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种缓存类型（数据缓存和请求记忆化）主要适用于在服务器端使用 `fetch()` 函数，例如从第三方API获取数据。然而，最近，也可以通过使用 `unstable_cache()`
    函数将这些两种类型的缓存应用于任何函数。尽管这个名字听起来不稳定，但这个函数已经可以在生产环境中安全使用。它之所以被称为“不稳定”，是因为当发布新的Next.js版本时，API可能会改变并需要代码更改。有关更多信息，请参阅[https://nextjs.org/docs/app/api-reference/functions/unstable_cache](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)。
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, the React **cache()** function could be used to memoize return
    values of functions, but the Next.js **unstable_cache()** function is more flexible,
    allowing us to dynamically revalidate the cache via a path or tag. We are going
    to learn more about cache revalidation later in this section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用React的 **cache()** 函数来记忆化函数的返回值，但Next.js的 **unstable_cache()** 函数更灵活，允许我们通过路径或标签动态重新验证缓存。我们将在本节的后面部分学习更多关于缓存重新验证的内容。
- en: The full route cache is an additional cache that makes sure that when data doesn’t
    change, we don’t even need to re-render pages on the server side so that Next.js
    can directly return pre-rendered static HTML and the RSC payload. However, invalidating
    the data cache will also invalidate the corresponding full route cache and trigger
    a re-render.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完整路由缓存是一个额外的缓存，确保当数据没有变化时，我们甚至不需要在服务器端重新渲染页面，这样Next.js可以直接返回预渲染的静态HTML和RSC有效负载。然而，验证数据缓存也会使相应的完整路由缓存失效并触发重新渲染。
- en: The router cache is a client-side cache and is mainly used when the user navigates
    between pages, allowing us to instantly show pages that they have already visited
    without having to fetch them from the server again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 路由缓存是一种客户端缓存，主要用于用户在页面之间导航时，允许我们立即显示他们已经访问过的页面，而无需再次从服务器获取。
- en: Additionally, if Next.js detects that a page or route only contains static content,
    it will pre-render and store it as static content. Static content cannot be revalidated
    anymore, so we need to be careful and ensure that all dynamic content on our apps
    is considered “dynamic” by Next.js and not accidentally detected as “static” content.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果Next.js检测到某个页面或路由只包含静态内容，它将预渲染并存储为静态内容。静态内容不能再进行验证，因此我们需要小心并确保我们应用中的所有动态内容都被Next.js视为“动态”的，而不是意外地被检测为“静态”内容。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we call this process **static rendering**. However, on other resources,
    it may also be called “automatic static optimization” or “static site generation.”
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们称这个过程为 **静态渲染**。然而，在其他资源中，它也可能被称为“自动静态优化”或“静态站点生成”。
- en: 'Next.js will opt out of static rendering and consider a page or route dynamic
    in the following instances:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，Next.js将退出静态渲染并考虑页面或路由为动态：
- en: When using a dynamic function, such as **cookies()**, **headers()**, or **searchParams**
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用动态函数，如 **cookies()**、**headers()** 或 **searchParams**
- en: When setting **export const dynamic = 'force-dynamic'** or **export const revalidate
    = 0**
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置 **export const dynamic = 'force-dynamic'** 或 **export const revalidate =
    0**
- en: When a Route Handler handles a non-GET request
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当路由处理器处理非GET请求时
- en: 'For more in-depth information on the different types of caching, have a look
    at the Next.js documentation on caching: [https://nextjs.org/docs/app/building-your-application/caching](https://nextjs.org/docs/app/building-your-application/caching).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更深入地了解不同类型的缓存信息，请查看Next.js关于缓存的文档：[https://nextjs.org/docs/app/building-your-application/caching](https://nextjs.org/docs/app/building-your-application/caching)。
- en: Now, let’s explore how static rendering works in practice by looking at how
    our route behaves in a production build of our app.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过查看我们的路由在生产构建中的应用行为来探索静态渲染在实际中的工作方式。
- en: Exploring static rendering in API routes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索API路由中的静态渲染
- en: 'In this chapter, we implemented a Route Handler for getting blog posts. Now,
    let’s explore how this route behaves in dev and production mode:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一个用于获取博客文章的路由处理器。现在，让我们探索这个路由在开发和生产模式下的行为：
- en: 'Edit **src/app/api/v1/posts/route.js** and add a **currentTime** value with
    **Date.now()** to the response, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/app/api/v1/posts/route.js**，并在响应中添加一个**currentTime**值，使用**Date.now()**，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Refresh the page on **http://localhost:3000/api/v1/posts** a couple of times;
    you will see that **currentTime** is always the latest timestamp.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**http://localhost:3000/api/v1/posts**上刷新页面几次；你会看到**currentTime**总是最新的时间戳。
- en: Quit the Next.js development server by using *Ctrl* + *C*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *C*退出Next.js开发服务器。
- en: 'Build the Next.js app for production and start it, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤构建Next.js应用以用于生产并启动它：
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Refresh the page on **http://localhost:3000/api/v1/posts** a couple of times.
    Now, **currentTime** doesn’t change at all! Even if we restart the Next.js server,
    **currentTime** still doesn’t change. The response of the **GET /api/v1/posts**
    route is statically rendered during build time.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**http://localhost:3000/api/v1/posts**上刷新页面几次。现在，**currentTime**一点都没有变化！即使我们重启Next.js服务器，**currentTime**仍然不会改变。**GET
    /api/v1/posts**路由的响应在构建时是静态渲染的。
- en: Static rendering works similarly for routes and pages, so pages will also be
    statically rendered by default. This means that RSCs do *not* require a server,
    per se; they can also run during build time. We only need a Node.js server if
    we want to have dynamic pages/routes. This means we could, for example, create
    a blog or website in Next.js and export a static bundle, allowing us to host it
    on a simple web server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路由和页面，静态渲染的工作方式相似，因此页面也将默认进行静态渲染。这意味着RSC（React Server Components）本身不需要服务器；它们也可以在构建时运行。如果我们想要有动态的页面/路由，我们才需要一个Node.js服务器。这意味着我们可以在Next.js中创建一个博客或网站，并导出一个静态包，这样我们就可以将其托管在简单的Web服务器上。
- en: Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Exporting a Next.js app as a static bundle can be achieved by specifying the
    **output: ''export''** option in the **next.config.js** file.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '通过在**next.config.js**文件中指定**output: ''export''**选项，可以将Next.js应用导出为静态包。'
- en: 'Interestingly, if we create a new blog post, our home page *does* get updated.
    However, that is only the case because `RootLayout` uses `cookies()` to check
    if the user is logged in, making all pages on our blog app dynamic (and thus not
    statically rendered). This can also be seen by looking at the output of `npm`
    `run build`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果我们创建一个新的博客文章，我们的主页*确实*会更新。然而，这种情况只因为`RootLayout`使用了`cookies()`来检查用户是否登录，使得我们博客应用上的所有页面都是动态的（因此不是静态渲染）。这也可以通过查看`npm
    run build`的输出看到：
- en: "![Figure 18.2 – Seeing which routes are statically and dynamically \uFEFFrendered\
    \ in the build output](img/B19385_18_2.jpg)"
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图18.2 – 在构建输出中查看哪些路由是静态和动态渲染的](img/B19385_18_2.jpg)'
- en: Figure 18.2 – Seeing which routes are statically and dynamically rendered in
    the build output
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 – 在构建输出中查看哪些路由是静态和动态渲染的
- en: As can be seen from *Figure 18**.2*, the `/api/v1/posts` route is “prerendered
    as static content,” while all other routes are “server-rendered on demand using
    Node.js.”
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图18**.2*所示，`/api/v1/posts`路由是“作为静态内容预渲染”，而所有其他路由则是“使用Node.js按需服务器渲染。”
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we wanted to statically render some pages in our blog, we would have to make
    sure the user bar isn’t visible on those pages. For example, we could create a
    **route group** ([https://nextjs.org/docs/app/building-your-application/routing/route-groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups))
    for all pages that have a user bar, with a separate layout that contains the user
    bar. Then, we can remove the user bar from the root layout. That way, we could
    create, for example, an About page that is statically rendered while keeping the
    rest of the blog dynamic.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在博客中静态渲染一些页面，我们必须确保用户栏在这些页面上不可见。例如，我们可以为所有带有用户栏的页面创建一个 **路由组** ([https://nextjs.org/docs/app/building-your-application/routing/route-groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups))，并使用一个包含用户栏的单独布局。然后，我们可以从根布局中移除用户栏。这样，我们就可以创建一个静态渲染的关于页面，同时保持博客的其他部分动态。
- en: As we have seen, in Next.js, pages and routes are statically rendered by default
    (if possible). However, in the case of our API route, this is not what we want!
    We want to be able to dynamically fetch posts from the API. Static rendering and
    caching in Next.js can be confusing when we’re starting out developing apps with
    it, but it becomes a powerful tool for keeping our apps optimized.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，在 Next.js 中，页面和路由默认是静态渲染的（如果可能）。然而，在我们的 API 路由的情况下，这并不是我们想要的！我们希望能够从
    API 动态获取帖子。当我们刚开始用 Next.js 开发应用程序时，静态渲染和缓存可能会让人困惑，但它成为了一个强大的工具，可以帮助我们优化应用程序。
- en: Now, let’s learn how to properly handle the cache to make our pages and routes
    dynamic when they need to be while keeping them cached whenever possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何正确处理缓存，以便在需要时使我们的页面和路由动态化，同时在可能的情况下保持它们被缓存。
- en: Making the route dynamic
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使路由动态化
- en: 'To make the route dynamic, we need to set the `export const dynamic = ''force-dynamic''`
    flag on it. Follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使路由动态化，我们需要在它上面设置 `export const dynamic = 'force-dynamic'` 标志。按照以下步骤操作：
- en: 'Edit **src/app/api/v1/posts/route.js** and add the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app/api/v1/posts/route.js** 并添加以下代码：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Quit the currently running Next.js server.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出当前运行的 Next.js 服务器。
- en: 'Build the Next.js app for production and start it, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤构建 Next.js 应用程序以进行生产并启动它：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Refresh the page on **http://localhost:3000/api/v1/posts** a couple of times.
    Now, the API route behaves the same way as it did on the development server!
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **http://localhost:3000/api/v1/posts** 上刷新页面几次。现在，API 路由的行为与开发服务器上的行为相同！
- en: Unfortunately, we now have completely disabled the cache, so we also don’t get
    any of the benefits of using a cache. Next, we’ll learn how to turn on the cache
    for specific functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们现在已经完全禁用了缓存，因此我们也没有使用缓存带来的任何好处。接下来，我们将学习如何为特定函数打开缓存。
- en: Caching functions in the data layer
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据层中缓存函数
- en: 'To cache functions from our data layer, we can use the `unstable_cache()` function
    from Next.js. The `unstable_cache(fetchData, keyParts, options)` function accepts
    three arguments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的数据层缓存函数，我们可以使用 Next.js 的 `unstable_cache()` 函数。`unstable_cache(fetchData,
    keyParts, options)` 函数接受三个参数：
- en: '**fetchData**: The first argument is the function to be called. The function
    can also have arguments.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fetchData**: 第一个参数是要调用的函数。该函数也可以有参数。'
- en: '**keyParts**: The second argument is an array of unique keys that identify
    the function in the cache. Arguments that are passed to the function in the first
    argument will automatically be added to this array as well.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**keyParts**: 第二个参数是一个唯一键的数组，用于在缓存中标识函数。传递给第一个参数中函数的参数也将自动添加到这个数组中。'
- en: '**options**: The third argument is an object containing options for the cache,
    where we can specify **tags** to revalidate the cache later, and a **revalidate**
    timeout to automatically revalidate the cache after a certain number of seconds.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**options**: 第三个参数是一个包含缓存选项的对象，其中我们可以指定 **标签** 以在以后重新验证缓存，以及一个 **重新验证** 超时，在经过一定秒数后自动重新验证缓存。'
- en: 'Now, let’s enable this cache for all functions where it makes sense. Follow
    these steps to get started:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为所有合适的函数启用这个缓存。按照以下步骤开始：
- en: 'Edit **src/data/posts.js** and import the **unstable_cache()** function, aliasing
    it as **cache()**:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/data/posts.js** 并导入 **unstable_cache()** 函数，将其别名为 **cache()**：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wrap the **listAllPosts** function with **cache()**, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **listAllPosts** 函数用 **cache()** 包装，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, wrap the **getPostById** function:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包装 **getPostById** 函数：
- en: '[PRE13]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may notice that there is now an error when getting posts because **ObjectId**
    from MongoDB is getting serialized into a string by the cache. Edit **src/components/Post.jsx**
    and adjust **propType**, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会注意到，在获取帖子时现在出现了错误，因为MongoDB中的**ObjectId**被缓存序列化为字符串。编辑**src/components/Post.jsx**并调整**propType**，如下所示：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Edit **src/data/users.js** and import **unstable_cache** there:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/data/users.js**并在其中导入**unstable_cache**：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Wrap the **getUserInfoById** function:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装**getUserInfoById**函数：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Quit the currently running Next.js server.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止当前运行的Next.js服务器。
- en: 'Rebuild and start the app in production. You will notice that after creating
    a new post, it does not update the home page (or the API route) anymore:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中重新构建并启动应用。你会注意到在创建新帖子后，它不再更新主页（或API路由）了：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s because our posts are now cached!
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那是因为我们的帖子现在被缓存了！
- en: 'This cache even works in dev mode. Quit the Next.js server and start it again,
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个缓存即使在开发模式下也能工作。按照以下步骤停止Next.js服务器并重新启动：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a new post; you will see that neither the home page nor the API route
    has the newly created post in the list.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的帖子；你会看到主页和API路由列表中都没有新创建的帖子。
- en: Now that caching has been configured, let’s learn how to deal with revalidating
    the cache (causing data in the cache to be updated).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在缓存已经配置好了，让我们学习如何处理缓存重新验证（导致缓存中的数据更新）。
- en: Revalidating the cache via Server Actions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Server Actions重新验证缓存
- en: 'The best way of dealing with stale data is to revalidate the cache when new
    data comes in, for example, via Server Actions. To do this, we have two options:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过时数据的最佳方式是在新数据到来时重新验证缓存，例如通过Server Actions。为此，我们有两种选择：
- en: Revalidating all route segments at a specific path by using the **revalidatePath**
    function
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**revalidatePath**函数在特定路径上重新验证所有路由段
- en: Revalidating with a specific tag (and thus potentially revalidating multiple
    paths) by using the **revalidateTag** function
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**revalidateTag**函数通过特定的标签（从而可能重新验证多个路径）进行重新验证
- en: Revalidation means that the next time data is requested from the cached function,
    the function will be called, and new data will be returned and cached (instead
    of returning previously cached data). Both functions revalidate the data cache
    and thus revalidate the full router cache and the client-side router cache as
    well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重新验证意味着下次从缓存的函数请求数据时，该函数将被调用，并将返回新数据并将其缓存（而不是返回之前缓存的旧数据）。这两个函数都会重新验证数据缓存，因此也会重新验证完整的路由缓存和客户端路由缓存。
- en: 'Follow these steps to call the `revalidateTag` function after creating new
    posts:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在创建新帖子后调用`revalidateTag`函数：
- en: 'Edit **src/app/create/page.js** and import the **revalidateTag** function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**src/app/create/page.js**并导入**revalidateTag**函数：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside **createPostAction**, call the **revalidateTag** function on the **posts**
    tag after creating the new post:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**createPostAction**内部，在创建新帖子后，对**posts**标签调用**revalidateTag**函数：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, create a new post and go to the home page. You will see that the newly
    created post appears in the list! The API route will also show the newly created
    post now.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的帖子并转到主页。你会看到新创建的帖子出现在列表中！API路由现在也会显示新创建的帖子。
- en: Revalidating the cache when data is changed via Server Actions is the most direct
    way of updating the cache. However, sometimes, we will be fetching data from third-party
    APIs, where revalidating is not possible. We’ll explore this case now.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过Server Actions更改时重新验证缓存是更新缓存的最直接方式。然而，有时我们会从第三方API获取数据，在这种情况下无法进行重新验证。我们现在将探讨这种情况。
- en: Revalidating the cache via a Webhook
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Webhook重新验证缓存
- en: If the data comes from a third-party source, we can revalidate the cache via
    a Webhook. Webhooks are APIs that can be used as callbacks. For example, when
    data changes, the third-party source calls our API endpoint to let us know that
    we need to re-fetch the data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据来自第三方源，我们可以通过Webhook重新验证缓存。Webhooks是可以用作回调的API。例如，当数据发生变化时，第三方源会调用我们的API端点，让我们知道我们需要重新获取数据。
- en: Integrating a third-party API
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成第三方API
- en: Before we can start implementing a Webhook, let’s integrate a third-party API
    into our app. For this example, we are going to use the WorldTimeAPI ([https://worldtimeapi.org/](https://worldtimeapi.org/)),
    but feel free to use any API of your choice.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现Webhook之前，让我们将第三方API集成到我们的应用中。在这个例子中，我们将使用WorldTimeAPI ([https://worldtimeapi.org/](https://worldtimeapi.org/))，但你可以自由选择任何你喜欢的API。
- en: 'Let’s start implementing a page that fetches from a third-party API:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现一个从第三方API获取数据的页面：
- en: Create a new **src/app/time/** folder. Inside it, create a new **src/app/time/page.js**
    file.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/app/time/** 文件夹中创建一个新的文件夹。在其内部，创建一个新的 **src/app/time/page.js** 文件。
- en: 'Edit **src/app/time/page.js** and define an asynchronous page component:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app/time/page.js** 并定义一个异步页面组件：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the component, fetch the current time from the WorldTimeAPI and parse
    the response as JSON:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件内部，从 WorldTimeAPI 获取当前时间并将响应解析为 JSON：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Render the current timestamp:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染当前时间戳：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you go to the **http://localhost:3000/time** page in your browser, you will
    see that it shows the current time. However, when refreshing, the time never updates.
    That is because requests with **fetch** are cached by default, similar to what
    happened after we added **unstable_cache()** to our data layer functions.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你通过浏览器访问 **http://localhost:3000/time** 页面，你会看到它显示了当前时间。然而，当刷新时，时间永远不会更新。这是因为使用
    **fetch** 的请求默认被缓存，类似于我们在数据层函数中添加 **unstable_cache()** 后发生的情况。
- en: Implementing the Webhook
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现钩子
- en: 'Now, let’s create a Webhook API endpoint in our app that, when called, revalidates
    the cache for the third-party data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的应用程序中创建一个 Webhook API 端点，当被调用时，重新验证第三方数据的缓存：
- en: Create a new **src/app/api/v1/webhook/** folder. Inside it, create a new **src/app/api/v1/webhook/route.js**
    file.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/app/api/v1/webhook/** 文件夹中创建一个新的文件夹。在其内部，创建一个新的 **src/app/api/v1/webhook/route.js**
    文件。
- en: 'Edit **src/app/api/v1/webhook/route.js** and import the **revalidatePath**
    function:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app/api/v1/webhook/route.js** 并导入 **revalidatePath** 函数：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, define a new **GET** Route Handler that calls **revalidatePath** on the
    **/time** page and then returns a response telling us that it was successful:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个新的 **GET** 路由处理器，它在 **/time** 页面上调用 **revalidatePath**，然后返回一个表示成功的响应：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Usually, Webhooks are defined as `POST` Route Handlers (because they influence
    the state of the app), but to make it simpler to trigger the Webhook by visiting
    the page in our browser, we defined it as a `GET` Route Handler. A `POST` route
    would opt out of static rendering, but a `GET` route does not, so we need to specify
    `force-dynamic`.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，Webhooks 被定义为 `POST` 路由处理器（因为它们会影响应用程序的状态），但为了简化通过在浏览器中访问页面来触发 Webhook，我们将其定义为
    `GET` 路由处理器。`POST` 路由将放弃静态渲染，但 `GET` 路由不会，因此我们需要指定 `force-dynamic`。
- en: Visit **http://localhost:3000/api/v1/webhook** in your browser, then visit **http://localhost:3000/time**
    again; you should see that the time has been updated! In the real world, we would
    be adding our Webhook URL to the interface of the third-party website that provides
    the API.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问 **http://localhost:3000/api/v1/webhook**，然后再次访问 **http://localhost:3000/time**；你应该看到时间已经更新了！在现实世界中，我们会将我们的
    Webhook URL 添加到提供 API 的第三方网站界面中。
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Alternatively, we could add a tag to the request by passing the **next.tags**
    option in the **fetch()** function, as follows: **fetch(''https://worldtimeapi.org/api/timezone/UTC'',
    { next: { tags: [''time''] } })**. Then, we could revalidate the cache by calling
    **revalidateTag(''time'')**.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，我们可以在请求中添加一个标签，通过在 **fetch()** 函数中传递 **next.tags** 选项，如下所示：**fetch(''https://worldtimeapi.org/api/timezone/UTC'',
    { next: { tags: [''time''] } })**。然后，我们可以通过调用 **revalidateTag(''time'')** 来重新验证缓存。'
- en: As we can see, revalidating the cache using Webhooks works great. However, sometimes,
    we cannot even add a Webhook to a third-party API. Let’s explore what to do when
    we have no control over the third-party API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 Webhooks 重新验证缓存效果很好。然而，有时我们甚至无法向第三方 API 添加 Webhook。让我们探讨当我们无法控制第三方
    API 时应该做什么。
- en: Revalidating the cache periodically
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定期重新验证缓存
- en: 'If we have no control whatsoever over the third-party data source, we can tell
    Next.js to periodically revalidate the cache. Let’s set that up now:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对第三方数据源完全没有控制权，我们可以告诉 Next.js 定期重新验证缓存。现在让我们设置一下：
- en: 'Edit **src/app/time/page.js** and adjust the **fetch()** function, adding the
    **next.revalidate** option to it:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/app/time/page.js** 并调整 **fetch()** 函数，向其中添加 **next.revalidate** 选项：
- en: '[PRE26]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we told Next.js to revalidate the data cache the next time the
    API is requested if at least 10 seconds have passed since the last request.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们告诉 Next.js 在下次请求 API 时重新验证数据缓存，如果自上次请求以来至少过去了 10 秒。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With **unstable_cache()**, we can pass the **revalidate** option in the third
    argument. For routes and pages, we can specify **export const revalidate = 10**,
    which will revalidate the corresponding route/page.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **unstable_cache()**，我们可以在第三个参数中传递 **revalidate** 选项。对于路由和页面，我们可以指定 **export
    const revalidate = 10**，这将重新验证相应的路由/页面。
- en: Refresh the **http://localhost:3000/time** page in your browser. You will see
    the time update. Refresh the page again; the time will not update again. If you
    refresh after at least 10 seconds, the time will update again.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中刷新 **http://localhost:3000/time** 页面。你会看到时间更新。再次刷新页面；时间将不会再次更新。如果你在至少 10
    秒后刷新，时间将再次更新。
- en: Now that we have learned about revalidating the cache periodically, let’s learn
    about opting out of caching.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了定期重新验证缓存的方法，让我们学习如何退出缓存。
- en: Opting out of caching
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出缓存
- en: 'Sometimes, you may want to opt out of caching completely for certain requests.
    To do this, pass the following option to the `fetch` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望完全退出某些请求的缓存。为此，将以下选项传递给 `fetch` 函数：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: export const metadata = {
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 导出 const metadata = {
- en: 'title: ''Full-Stack Next.js Blog'','
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'title: ''全栈 Next.js 博客'','
- en: 'description: ''A blog about React and Next.js'','
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'description: ''关于 React 和 Next.js 的博客'','
- en: '}'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: export async function generateMetadata({ params }) {
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导出异步函数 generateMetadata({ params }) {
- en: const id = params.id
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const id = params.id
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: const post = await getPostById(id)
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const post = 等待 getPostById(id)
- en: if (!post) notFound()
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (!post) notFound()
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: return {
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return {
- en: 'title: `${post.title} | Full-Stack Next.js Blog`,'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'title: `${post.title} | 全栈 Next.js 博客`,'
- en: 'description: `Written by ${post.author.username}`,'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'description: `由 ${post.author.username} 撰写`,'
- en: '}'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE31]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'User-agent: *'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'User-agent: *'
- en: 'Allow: /'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Allow: /'
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: export default async function ViewPostPage({ params }) {
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导出默认异步函数 ViewPostPage({ params }) {
- en: await initDatabase()
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待初始化数据库()
- en: const [id] = params.path
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const [id] = params.path
- en: const post = await getPostById(id)
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const post = 等待 getPostById(id)
- en: '[PRE33]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: export async function generateMetadata({ params }) {
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导出异步函数 generateMetadata({ params }) {
- en: const [id] = params.path
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const [id] = params.path
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: $ npm install slug@8.2.3
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ npm install slug@8.2.3
- en: '[PRE35]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: import slug from 'slug'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 slug 从 'slug'
- en: '[PRE36]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <Link href={`/posts/${_id}/${slug(title)}`}>{title}</Link>
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Link href={`/posts/${_id}/${slug(title)}`}>{title}</Link>
- en: '[PRE37]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: BASE_URL=http://localhost:3000
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: BASE_URL=http://localhost:3000
- en: '[PRE38]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: import { initDatabase } from '@/db/init'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 { initDatabase } 从 '@/db/init'
- en: import { listAllPosts } from '@/data/posts'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 { listAllPosts } 从 '@/data/posts'
- en: import slug from 'slug'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 slug 从 'slug'
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: export default async function sitemap() {
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导出默认异步函数 sitemap() {
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: const staticPages = [
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const staticPages = [
- en: '{'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'url: `${process.env.BASE_URL}`,'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'url: `${process.env.BASE_URL}`,'
- en: '},'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'url: `${process.env.BASE_URL}/create`,'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'url: `${process.env.BASE_URL}/create`,'
- en: '},'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'url: `${process.env.BASE_URL}/login`,'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'url: `${process.env.BASE_URL}/login`,'
- en: '},'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'url: `${process.env.BASE_URL}/signup`,'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'url: `${process.env.BASE_URL}/signup`,'
- en: '},'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: 'url: `${process.env.BASE_URL}/time`,'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'url: `${process.env.BASE_URL}/time`,'
- en: '},'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: ']'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE41]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: await initDatabase()
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待初始化数据库()
- en: const posts = await listAllPosts()
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const posts = 等待 listAllPosts()
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: const postsPages = posts.map((post) => ({
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const postsPages = posts.map((post) => ({
- en: 'url: `${process.env.BASE_URL}/posts/${post._id}/${slug(post.title)}`,'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'url: `${process.env.BASE_URL}/posts/${post._id}/${slug(post.title)}`,'
- en: 'lastModified: post.updatedAt,'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'lastModified: post.updatedAt,'
- en: '}))'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}))'
- en: '[PRE43]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: return [...staticPages, ...postsPages]
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return [...staticPages, ...postsPages]
- en: '}'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: import { Inter } from 'next/font/google'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 { Inter } 从 'next/font/google'
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: const inter = Inter({
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const inter = Inter({
- en: 'subsets: [''latin''],'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'subsets: [''latin''],'
- en: 'display: ''swap'','
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'display: ''swap'','
- en: '})'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <html lang='en' className={inter.className}>
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <html lang='en' className={inter.className}>
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: import Image from 'next/image'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 Image 从 'next/image'
- en: import logo from './logo.png'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 logo 从 './logo.png'
- en: '[PRE48]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: return (
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return (
- en: <html lang='en' className={inter.className}>
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <html lang='en' className={inter.className}>
- en: <body>
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <body>
- en: <Image
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Image
- en: src={logo}
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: src={logo}
- en: alt='Full-Stack Next.js Blog Logo'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: alt='全栈 Next.js 博客 Logo'
- en: width={500}
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: width={500}
- en: height={47}
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: height={47}
- en: />
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: />
- en: <nav>
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <nav>
- en: <Navigation username={user?.username} logoutAction={logoutAction} />
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Navigation username={user?.username} logoutAction={logoutAction} />
- en: </nav>
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </nav>
- en: '[PRE49]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
