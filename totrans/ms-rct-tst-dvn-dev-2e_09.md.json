["```js\n{\n  firstName: \"First name is required\",\n  lastName: undefined,\n  phoneNumber: \"Phone number must contain only numbers, spaces, and any of the following: + - ( ) .\"\n}\n```", "```js\n    describe(\"validation\", () => {\n      it(\"renders an alert space for first name validation errors\", () => {\n        render(<CustomerForm original={blankCustomer} />);\n        expect(\n          element(\"#firstNameError[role=alert]\")\n        ).not.toBeNull();\n      });\n    });\n    ```", "```js\n    <input\n      type=\"text\"\n      name=\"firstName\"\n      id=\"firstName\"\n      value={customer.firstName}\n      onChange={handleChange}\n    />\n    <span id=\"firstNameError\" role=\"alert\" />\n    ```", "```js\n    it(\"sets alert as the accessible description for the first name field\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      expect(\n        field(\n          \"firstName\"\n        ).getAttribute(\"aria-describedby\")\n      ).toEqual(\"firstNameError\");\n    });\n    ```", "```js\n    <input\n      type=\"text\"\n      name=\"firstName\"\n      id=\"firstName\"\n      value={customer.firstName}\n      onChange={handleChange}\n      aria-describedby=\"firstNameError\"\n    />\n    ```", "```js\n    export const withFocus = (target, fn) =>\n      act(() => {\n        target.focus();\n        fn();\n        target.blur();\n      });\n    ```", "```js\n    import {\n      ...,\n      withFocus,\n    } from \"./reactTestExtensions\";\n    ```", "```js\n    it(\"displays error after blur when first name field is blank\", () => {\n      render(<CustomerForm original={blankCustomer} />);\n      withFocus(field(\"firstName\"), () =>\n        change(field(\"firstName\"), \" \");\n      )\n      expect(\n        element(\"#firstNameError[role=alert]\")\n      ).toContainText(\"First name is required\");\n    });\n    ```", "```js\n    <span id=\"firstNameError\" role=\"alert\">\n      First name is required\n    </span>\n    ```", "```js\n    it(\"initially has no text in the first name field alert space\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      expect(\n        element(\"#firstNameError[role=alert]\").textContent\n      ).toEqual(\"\");\n    });\n    ```", "```js\n    const required = value =>\n      !value || value.trim() === \"\"\n        ? \"First name is required\"\n        : undefined;\n    ```", "```js\n    const [\n      validationErrors, setValidationErrors\n    ] = useState({});\n    ```", "```js\n    const handleBlur = ({ target }) => {\n      const result = required(target.value);\n      setValidationErrors({\n        ...validationErrors,\n        firstName: result\n      });\n    };\n    ```", "```js\n    const hasFirstNameError = () =>\n      validationErrors.firstName !== undefined;\n    ```", "```js\n    <input\n      type=\"text\"\n      name=\"firstName\"\n      ...\n      onBlur={handleBlur}\n    />\n    <span id=\"firstNameError\" role=\"alert\">\n      {hasFirstNameError()\n        ? validationErrors[\"firstName\"]\n        : \"\"}\n    </span>\n    ```", "```js\n    const renderFirstNameError = () => (\n      <span id=\"firstNameError\" role=\"alert\">\n        {hasFirstNameError()\n          ? validationErrors[\"firstName\"]\n          : \"\"}\n      <span>\n    );\n    ```", "```js\n    <input\n      type=\"text\"\n      name=\"firstName\"\n      ...\n    />\n    {renderFirstNameError()}\n    ```", "```js\n    <input\n      type=\"text\"\n      name=\"firstName\"\n      ...\n    />\n    {renderFirstNameError(\"firstName\")}\n    ```", "```js\n    const renderFirstNameError = (fieldName) => (\n      <span id={`${fieldName}Error`} role=\"alert\">\n        {hasFirstNameError()\n          ? validationErrors[fieldName]\n          : \"\"}\n      <span>\n    );\n    ```", "```js\n    const renderFirstNameError = (fieldName) => (\n      <span id={`${fieldName}Error`} role=\"alert\">\n        {hasFirstNameError(fieldName)\n          ? validationErrors[fieldName]\n          : \"\"}\n      <span>\n    );\n    ```", "```js\n    const hasFirstNameError = fieldName =>\n      validationErrors[fieldName] !== undefined;\n    ```", "```js\n    const handleBlur = ({ target }) => {\n      const validators = {\n        firstName: required\n      };\n      const result = \n        validators[target.name](target.value);\n      setValidationErrors({\n        ...validationErrors,\n        [target.name]: result\n      });\n    };\n    ```", "```js\n    const required = description => value =>\n      !value || value.trim() === \"\"\n        ? description\n        : undefined;\n    ```", "```js\n    const validators = {\n      firstName: required(\"First name is required\")\n    };\n    ```", "```js\n    const errorFor = (fieldName) =>\n      element(`#${fieldName}Error[role=alert]`);\n    ```", "```js\n    const itRendersAlertForFieldValidation = (fieldName) => {\n      it(`renders an alert space for ${fieldName} validation errors`, async () => {\n        render(<CustomerForm original={blankCustomer} />);\n        expect(errorFor(fieldName)).not.toBeNull();\n      });\n    };\n    ```", "```js\n    itRendersAlertForFieldValidation(\"firstName\");\n    ```", "```js\n    const itSetsAlertAsAccessibleDescriptionForField = (\n      fieldName\n    ) => {\n      it(`sets alert as the accessible description for the ${fieldName} field`, async () => {\n        render(<CustomerForm original={blankCustomer} />);\n        expect(\n          field(fieldName).getAttribute(\n            \"aria-describedby\"\n          )\n        ).toEqual(`${fieldName}Error`);\n      });\n    };\n    ```", "```js\n    itSetsAlertAsAccessibleDescriptionForField(\n      \"firstName\"\n    );\n    ```", "```js\n    const itInvalidatesFieldWithValue = (\n      fieldName,\n      value,\n      description\n    ) => {\n      it(`displays error after blur when ${fieldName} field is '${value}'`, () => {\n        render(<CustomerForm original={blankCustomer} />);\n        withFocus(field(fieldName), () =>\n          change(field(fieldName), value)\n        );\n        expect(\n          errorFor(fieldName)\n        ).toContainText(description);\n      });\n    };\n    ```", "```js\n    itInvalidatesFieldWithValue(\n      \"firstName\",\n      \" \",\n      \"First name is required\"\n    );\n    ```", "```js\n    const itInitiallyHasNoTextInTheAlertSpace = (fieldName) => {\n      it(`initially has no text in the ${fieldName} field alert space`, async () => {\n        render(<CustomerForm original={blankCustomer} />);\n        expect(\n          errorFor(fieldName).textContent\n        ).toEqual(\"\");\n      });\n    };\n    ```", "```js\n    itInitiallyHasNoTextInTheAlertSpace(\"firstName\");\n    ```", "```js\n    itRendersAlertForFieldValidation(\"lastName\");\n    ```", "```js\n    <label htmlFor=\"lastName\">Last name</label>\n    <input\n      type=\"text\"\n      name=\"lastName\"\n      id=\"lastName\"\n      value={customer.lastName}\n      onChange={handleChange}\n    />\n    {renderError(\"lastName\")}\n    ```", "```js\n    itSetsAlertAsAccessibleDescriptionForField(\n      \"lastName\"\n    );\n    ```", "```js\n    <input\n      type=\"text\"\n      name=\"lastName\"\n      ...\n      aria-describedby=\"lastNameError\"\n    />\n    ```", "```js\n    itInvalidatesFieldWithValue(\n      \"lastName\",\n      \" \",\n      \"Last name is required\"\n    );\n    ```", "```js\n    const validators = {\n      firstName: required(\"First name is required\"),\n      lastName: required(\"Last name is required\"),\n    };\n    ```", "```js\n    itInitiallyHasNoTextInTheAlertSpace(\"lastName\");\n    ```", "```js\n    itInvalidatesFieldWithValue(\n      \"phoneNumber\",\n      \"invalid\",\n      \"Only numbers, spaces and these symbols are allowed: ( ) + -\"\n    );\n    ```", "```js\n    const match = (re, description) => value =>\n      !value.match(re) ? description : undefined;\n    ```", "```js\n    const list = (...validators) => value =>\n      validators.reduce(\n        (result, validator) => result || validator(value),\n        undefined\n      );\n    ```", "```js\n    const validators = {\n      ...\n      phoneNumber: list(\n        required(\"Phone number is required\"),\n        match(\n          /^[0-9+()\\- ]*$/,\n          \"Only numbers, spaces and these symbols are allowed: ( ) + -\"\n        )\n      )\n    };\n    ```", "```js\n    it(\"accepts standard phone number characters when validating\", () => {\n      render(<CustomerForm original={blankCustomer} />);\n      withFocus(field(\"phoneNumber\"), () =>\n        change(field(\"phoneNumber\"), \"0123456789+()- \")\n      );\n      expect(errorFor(\"phoneNumber\")).not.toContainText(\n        \"Only numbers\" \n      );\n    });\n    ```", "```js\n    export const validCustomer = {\n      firstName: \"first\",\n      lastName: \"last\",\n      phoneNumber: \"123456789\"\n    };\n    ```", "```js\n    import {\n      blankCustomer,\n      validCustomer,\n    } from \"./builders/customer\";\n    ```", "```js\n    render(<CustomerForm original={validCustomer} />);\n    ```", "```js\n    it(\"does not submit the form when there are validation errors\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      await clickAndWait(submitButton());\n      expect(global.fetch).not.toBeCalled();\n    });\n    ```", "```js\n    const validateMany = fields =>\n      Object.entries(fields).reduce(\n        (result, [name, value]) => ({\n          ...result,\n          [name]: validators[name](value)\n        }),\n        {}\n      );\n    ```", "```js\n    const anyErrors = errors =>\n      Object.values(errors).some(error => (\n        error !== undefined\n      )\n    );\n    ```", "```js\n    const handleSubmit = async e {\n      e.preventDefault();\n      const validationResult = validateMany(customer);\n      if (!anyErrors(validationResult)) {\n        ... existing code ...\n      }\n    }\n    ```", "```js\n    import {\n      ...,\n      textOf,\n      elements,\n    } from \"./reactTestExtensions\";\n    ```", "```js\n    it(\"renders validation errors after submission fails\", async () => {\n      render(<CustomerForm original={blankCustomer} />);\n      await clickAndWait(submitButton());\n      expect(\n        textOf(elements(\"[role=alert]\"))\n      ).not.toEqual(\"\");\n    });\n    ```", "```js\n    if (!anyErrors(validationResult)) {\n      ...\n    } else {\n      setValidationErrors(validationResult);\n    }\n    ```", "```js\n    import {\n      required,\n      match,\n      list,\n    } from \"./formValidation\";\n    ```", "```js\n    const renderError = fieldName => {\n      if (hasError(validationErrors, fieldName)) {\n        ...\n     }\n    }\n    ```", "```js\n    const hasError = (validationErrors, fieldName) =>\n      validationErrors[fieldName] !== undefined;\n    ```", "```js\n    const validateMany = (validators, fields) =>\n      Object.entries(fields).reduce(\n       (result, [name, value]) => ({\n        ...result,\n        [name]: validators[name](value)\n      }),\n      {}\n    );\n    ```", "```js\n    const handleBlur = ({ target }) => {\n      const result = validateMany(validators, {\n        [target.name] : target.value\n      });\n      setValidationErrors({\n        ...validationErrors,\n        ...result\n      });\n    }\n    ```", "```js\n    const validationResult = validateMany(\n      validators,\n      customer\n    );\n    ```", "```js\n    import {\n      required,\n      match,\n      list,\n      hasError,\n      validateMany,\n      anyErrors,\n    } from \"./formValidation\";\n    ```", "```js\n{\n  \"errors\": {\n    \"phoneNumber\": \"Phone number already exists in the system\"\n  }\n}\n```", "```js\n    const fetchResponseError = (\n      status = 500,\n      body = {}\n    ) => ({\n      ok: false,\n      status,\n      json: () => Promise.resolve(body),\n    });\n    ```", "```js\n    it(\"renders field validation errors from server\", async () => {\n      const errors = {\n        phoneNumber: \"Phone number already exists in the system\"\n      };\n      global.fetch.mockResolvedValue(\n        fetchResponseError(422, { errors })\n      );\n      render(<CustomerForm original={validCustomer} />);\n      await clickAndWait(submitButton());\n      expect(errorFor(\"phoneNumber\")).toContainText(\n        errors.phoneNumber\n      );\n    });\n    ```", "```js\n    if (result.ok) {\n      setError(false);\n      const customerWithId = await result.json();\n      onSave(customerWithId);\n    } else if (result.status === 422) {\n      const response = await result.json();\n      setValidationErrors(response.errors);\n    } else {\n      setError(true);\n    }\n    ```", "```js\n...\nif (!anyErrors(validationResult)) {\n  setSubmitting(true);\n  const result = await global.fetch(...);\n  setSubmitting(false);\n  ...\n}\n...\n```", "```js\n    import { act } from \"react-dom/test-utils\";\n    ```", "```js\n    import {\n      ...,\n      click,\n      clickAndWait,\n    } from \"./reactTestExtensions\";\n    ```", "```js\n    describe(\"submitting indicator\", () => {\n      it(\"displays when form is submitting\", async () => {\n        render(\n          <CustomerForm\n            original={validCustomer}\n            onSave={() => {}}\n          />\n        );\n        click(submitButton());\n        await act(async () => {\n          expect(\n            element(\"span.submittingIndicator\")\n          ).not.toBeNull();\n        });\n      });\n    });\n    ```", "```js\n    return (\n      <form id=\"customer\" onSubmit={handleSubmit}>\n        ...\n        <input type=\"submit\" value=\"Add\" />\n        <span className=\"submittingIndicator\" />\n      </form>\n    );\n    ```", "```js\n    it(\"initially does not display the submitting indicator\", () => {\n      render(<CustomerForm original={validCustomer} />);\n      expect(element(\".submittingIndicator\")).toBeNull();\n    });\n    ```", "```js\n    const [submitting, setSubmitting] = useState(false);\n    ```", "```js\n    {submitting ? (\n      <span className=\"submittingIndicator\" />\n    ) : null}\n    ```", "```js\n    if (!anyErrors(validationResult)) {\n      setSubmitting(true);\n      const result = await global.fetch(/* ... */);\n      ...\n    }\n    ```", "```js\n    it(\"hides after submission\", async () => {\n      render(\n        <CustomerForm\n          original={validCustomer}\n          onSave={() => {}}\n        />\n      );\n      await clickAndWait(submitButton());\n      expect(element(\".submittingIndicator\")).toBeNull();\n    });\n    ```", "```js\n    if (!anyErrors(validationResult)) {\n      setSubmitting(true);\n      const result = await global.fetch(/* ... */);\n      setSubmitting(false);\n      ...\n    }\n    ```"]