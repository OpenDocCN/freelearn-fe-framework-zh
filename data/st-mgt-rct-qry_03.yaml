- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: React Query – Introducing, Installing, and Configuring It
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Query – 介绍、安装和配置
- en: React Query is a library created to make it easier for React developers to manage
    their server state. It makes it easier for developers to overcome all the challenges
    that come with server state while making their applications faster, easier to
    maintain, and reducing many lines in their code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 是一个库，旨在让 React 开发者更容易地管理他们的服务器状态。它使得开发者能够克服与服务器状态相关的所有挑战，同时使他们的应用程序更快、更容易维护，并减少代码中的许多行。
- en: In this chapter, you will be introduced to React Query and understand why it
    was created.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 React Query 并了解为什么它被创建。
- en: You will also get to know the main concepts of React Query – **queries** and
    **mutations**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解 React Query 的主要概念——**查询**和**突变**。
- en: Once you have been introduced to React Query, we’ll install it in our application
    and identify the initial configurations we need to make in our code to get ready
    to use it fully.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了 React Query，我们将在我们的应用程序中安装它，并确定我们需要在代码中进行的初始配置，以便完全使用它。
- en: By the end of this chapter, you will know all about React Query Devtools so
    that you can have a better developer experience while using React Query.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解所有关于 React Query Devtools 的内容，以便在使用 React Query 时拥有更好的开发者体验。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is React Query?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 React Query？
- en: Installing React Query
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 React Query
- en: Configuring React Query
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 React Query
- en: Adding React Query Devtools to your application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 React Query Devtools 添加到你的应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will add React Query v4 to our application. To do so, there
    are a couple of things we need:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的应用程序添加 React Query v4。为此，我们需要做几件事情：
- en: 'Your browser needs to be compatible with the following configurations:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的浏览器需要与以下配置兼容：
- en: The Google Chrome version needs to be at least version 73
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Chrome 版本需要至少为 73
- en: The Mozilla Firefox version needs to be at least version 78
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla Firefox 版本需要至少为 78
- en: The Microsoft Edge version needs to be at least version 79
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Edge 版本需要至少为 79
- en: The Safari version needs to be at least version 12.0
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari 版本需要至少为 12.0
- en: The Opera version needs to be at least version 53
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Opera 版本需要至少为 53
- en: A React project after version 16.8
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 16.8 之后的 React 项目
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3%0D)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3%0D)
- en: What is React Query?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 React Query？
- en: React Query is a protocol-agnostic collection of hooks for fetching, caching,
    and updating server state in React.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 是一个协议无关的钩子集合，用于在 React 中获取、缓存和更新服务器状态。
- en: It was created by Tanner Linsley and is part of a collection of open source
    libraries called TanStack.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由 Tanner Linsley 创建的，是名为 TanStack 的一系列开源库的一部分。
- en: By default, React Query can also work with React Native out of the box, and
    it is written in TypeScript so that you can benefit from all its advantages, such
    as type narrowing and type inference.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Query 也可以与 React Native 无缝协作，并且它是用 TypeScript 编写的，这样你可以从所有其优势中受益，例如类型缩小和类型推断。
- en: Since version 4, React Query has been embedded in a collection of libraries
    called TanStack Query. TanStack Query made it possible to propagate all the amazing
    features of React Query to other frameworks and libraries, such as Vue, Solid,
    and Svelte.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 4 以来，React Query 已嵌入到名为 TanStack Query 的一系列库中。TanStack Query 使得将 React Query
    的所有惊人功能传播到其他框架和库（如 Vue、Solid 和 Svelte）成为可能。
- en: React Query leverages queries and mutations to handle your server state. Upon
    reading this last sentence, you might wonder what queries and mutations are. I’ll
    show you some code in subsequent chapters so that you can see how React Query
    handles them, but first, let us learn about queries and mutations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 利用查询和突变来处理你的服务器状态。在阅读最后一句话后，你可能会想知道查询和突变是什么。我将在后续章节中展示一些代码，以便你可以看到
    React Query 如何处理它们，但首先，让我们了解查询和突变。
- en: Query
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: A query is a request you make to an asynchronous source to fetch your data.
    Queries can be performed in React Query as long as you have a function that triggers
    the data-fetching request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是你向异步源发出的请求，以获取你的数据。只要你有触发数据获取请求的函数，你就可以在 React Query 中执行查询。
- en: By allowing us to wrap our requests inside of promise-returning functions, React
    Query supports REST, GraphQL, and any other asynchronous data-fetching clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许我们将请求包裹在返回 promise 的函数中，React Query 支持 REST、GraphQL 以及任何其他异步数据获取客户端。
- en: In React Query, the `useQuery` custom hook allows you to subscribe to queries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Query 中，`useQuery` 自定义钩子允许你订阅查询。
- en: Mutation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**突变**'
- en: A mutation is an operation that allows you to create, update, or delete your
    server state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 突变是一种操作，允许你创建、更新或删除你的服务器状态。
- en: Like queries, as long as you have a function that triggers a mutation, React
    Query supports REST, GraphQL, and any other asynchronous data-fetching clients.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询一样，只要你有触发突变的函数，React Query 就支持 REST、GraphQL 以及任何其他异步数据获取客户端。
- en: In React Query, the `useMutation` custom hook allows you to perform a mutation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Query 中，`useMutation` 自定义钩子允许你执行突变。
- en: How does React Query solve my server state challenges?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Query 如何解决我的服务器状态挑战？
- en: '*What if I told you that all the challenges presented in the previous chapter
    could be solved by* *React Query?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我告诉你，前一章中提出的所有挑战都可以通过 React Query 解决，你会怎么想？*'
- en: 'Out of the box and with zero configurations, React Query supports all the following
    amazing features:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无需配置，React Query 支持以下所有令人惊叹的功能：
- en: '**Caching**: After each query, data will be cached during a configurable time
    and can be reused throughout your application.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：在每次查询之后，数据将在可配置的时间内被缓存，并且可以在整个应用程序中重复使用。'
- en: '**Query cancelation**: Your queries can be canceled, and you can perform an
    action after this cancelation.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询取消**：你的查询可以被取消，你可以在取消后执行一个操作。'
- en: '**Optimistic updates**: During a mutation, you can easily update your state
    so that you can provide a better user experience to your users. You are also able
    to easily revert to a previous state if the mutation fails.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乐观更新**：在突变过程中，你可以轻松地更新你的状态，以便为用户提供更好的用户体验。如果突变失败，你还可以轻松地回滚到之前的状态。'
- en: '**Parallel queries**: If you need to execute one or more queries simultaneously,
    you can do so without any difficulty or impacting your cache.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行查询**：如果你需要同时执行一个或多个查询，你可以轻松地做到这一点，而不会对你的缓存造成任何影响。'
- en: '**Dependent queries**: Sometimes, we need to execute a query after another
    one finishes. React Query makes this simple and avoids chaining promises.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖查询**：有时，我们需要在另一个查询完成后执行一个查询。React Query 使这变得简单，并避免了链式 promise。'
- en: '**Paginated queries**: This UI pattern is made easier with React Query. You’ll
    find that using a paginated API, changing pages, and rendering the fetched data
    is super simple.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页查询**：使用 React Query 可以使这种 UI 模式变得更加简单。你会发现使用分页 API、切换页面和渲染获取的数据非常简单。'
- en: '**Infinite queries**: Another UI pattern that is made easier by React Query.
    You can implement infinite scrolls into your UI and trust React Query to make
    your life easier when fetching data.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限查询**：React Query 使这种 UI 模式变得更加简单。你可以将无限滚动实现到你的 UI 中，并且可以信任 React Query
    在获取数据时使你的生活变得更简单。'
- en: '**Scroll restoration**: Have you ever navigated from a page and, when navigated
    back, found that the page was scrolled to the exact point where you were before
    you navigated away? This is scroll restoration, and as long as your query results
    are cached, it will work out of the box.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动恢复**：你是否曾经从一个页面导航出去，然后当你导航回来时，发现页面滚动到了你离开时的确切位置？这是滚动恢复，只要你的查询结果被缓存，它就会自动工作。'
- en: '**Data refetching**: Need to trigger a refetch for your data? React Query allows
    you to do this with pretty much a line of code.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据重新获取**：需要触发数据重新获取吗？React Query 允许你通过几乎一行代码就能做到这一点。'
- en: '**Data prefetching**: Sometimes, you can identify ahead of time what the needs
    and next actions of your users are. When this happens, you can trust React Query
    to help you prefetch that data ahead of time and cache it for you. This way, your
    user experience will be improved, and you will have happier users.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据预获取**：有时，你可以提前识别出用户的需求和后续操作。当这种情况发生时，你可以信任 React Query 在此之前帮助你预获取那些数据并为你缓存它们。这样，你的用户体验将得到改善，并且用户会感到更加满意。'
- en: '**Tracking network mode and offline support**: Have you ever had to deal with
    scenarios where your user lost their internet connection while using your application?
    Well, don’t worry because React Query can track the current state of your network,
    and if a query fails because the user lost connection, it will be retried once
    the network returns.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪网络模式和离线支持**：你是否曾经遇到过用户在使用你的应用程序时丢失互联网连接的情况？别担心，因为 React Query 可以跟踪你的网络当前状态，如果查询失败是因为用户失去了连接，那么一旦网络恢复，它将重试。'
- en: Looking at this list is amazing, right?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这个列表真是太棒了，对吧？
- en: Just having caching out of the box is a super, great timesaver because it is
    definitely one of the hardest things to implement when dealing with server state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有开箱即用的缓存，这绝对是一个节省时间的超级好方法，因为当处理服务器状态时，这绝对是最难实现的事情之一。
- en: Before React Query, it was much harder to handle the server state in our applications.
    We tried, but our solutions ended up growing more complex and with less maintainable
    code. Often, these implementations would even end up impacting the user experience
    because our applications would get less responsive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Query 之前，处理我们应用程序中的服务器状态要困难得多。我们尝试过，但我们的解决方案最终变得更加复杂，代码的可维护性更低。通常，这些实现甚至会影响用户体验，因为我们的应用程序会变得不那么响应。
- en: With React Query, you are now able to greatly reduce the number of lines in
    your code, make your application much easier to read and simple, and at the same
    time, make your application faster and much more responsive.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Query，你现在能够大大减少代码中的行数，使你的应用程序更容易阅读和简单，同时，使你的应用程序更快、更响应。
- en: I won’t get into more technical details right now because, hopefully, in the
    following chapters, you will see all these features working and start understanding
    why React Query makes your life so much easier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在不会深入更多技术细节，因为，希望在下章中，你会看到所有这些功能的工作，并开始理解为什么 React Query 使你的生活变得如此简单。
- en: For now, let us start by installing React Query in our applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先在我们的应用程序中安装 React Query。
- en: Installing React Query
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 React Query
- en: Now that you are aware of React Query, you are probably thinking, *wow, I really
    need to add this to my project.* Wait no more – here is what you need to do to
    install React Query.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 React Query，你可能正在想，“哇，我真的很需要把这个添加到我的项目中。”别再等了——这就是你需要做的来安装 React Query。
- en: Depending on your project type, you can install React Query in several ways.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的项目类型，你可以以几种方式安装 React Query。
- en: npm
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: npm
- en: If you are running npm in your project, then this is what you need to do to
    install React Query.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在你的项目中运行 npm，那么这是你需要做的来安装 React Query。
- en: 'In your terminal, run the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，运行以下命令：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yarn
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yarn
- en: If Yarn is what you prefer, then this is what you need to do to install React
    Query.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢 Yarn，那么这是你需要做的来安装 React Query。
- en: 'In your terminal, run the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，运行以下命令：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: pnpm
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pnpm
- en: If you are a fan of a new package manager, such as pnpm, and are using it in
    your project, then this is what you need to do to install React Query.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一位新包管理器的粉丝，比如 pnpm，并且正在你的项目中使用它，那么你需要这样做来安装 React Query。
- en: 'In your terminal, run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，运行以下命令：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Script tag
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本标签
- en: Not using a package manager? Don’t worry, because React Query can be added to
    your application by using a global build that is hosted on a **content** **delivery
    network**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用包管理器？别担心，因为你可以通过使用托管在 **内容** **分发网络** 上的全局构建来将 React Query 添加到你的应用程序中。
- en: Content delivery network (CDN)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 内容分发网络 (CDN)
- en: A CDN is a geographically distributed group of servers that work together to
    allow for faster delivery of content on the internet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CDN 是一组地理上分布的服务器集合，它们协同工作以允许在互联网上更快地交付内容。
- en: 'To add React Query to your application, add the next `script` tag at the end
    of your HTML file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 React Query 添加到你的应用程序中，在你的 HTML 文件末尾添加以下 `script` 标签：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should now have React Query installed in your project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在项目中安装了 React Query。
- en: Now, we need to do the initial configurations on our projects to be able to
    use all the core functionalities of React Query.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的项目中进行初始配置，以便能够使用 React Query 的所有核心功能。
- en: Configuring React Query
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 React Query
- en: React Query has a very fast and simple configuration. This improves the developer
    experience and can prepare you to start migrating your server state to React Query
    as soon as possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 具有非常快速和简单的配置。这提高了开发者的体验，并可以让你尽快开始将你的服务器状态迁移到 React Query。
- en: 'To add React Query to your application, there are only two things you need
    to know:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 React Query 添加到您的应用程序中，您只需要了解两件事：
- en: '**QueryClient**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QueryClient**'
- en: '**QueryClientProvider**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QueryClientProvider**'
- en: QueryClient
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QueryClient
- en: As you should be aware right now, caching is one of the most important things
    React Query makes easier for developers. In React Query, there are two mechanisms
    used to handle this cache called **QueryCache** and **MutationCache**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所应知道的，缓存是 React Query 为开发者简化的重要事情之一。在 React Query 中，有两种机制用于处理此缓存，称为 **QueryCache**
    和 **MutationCache**。
- en: '`QueryCache` is responsible for storing all the data related to your queries.
    This can be the data of your query as well as its current state.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryCache` 负责存储与您的查询相关的所有数据。这可以是您的查询数据以及其当前状态。'
- en: '`MutationCache` is responsible for storing all the data related to your mutations.
    This can be the data of your mutation as well as its current state.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutationCache` 负责存储与您的突变相关的所有数据。这可以是您的突变数据以及其当前状态。'
- en: To make it easier for a developer to abstract from both caches, React Query
    created `QueryClient`. This is responsible for being the interface between a developer
    and a cache.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让开发者更容易从这两个缓存中抽象出来，React Query 创建了 `QueryClient`。这是开发者与缓存之间的接口。
- en: 'The first thing you should do when setting your application with React Query
    is to create a `QueryClient` instance. To do so, you need to import it from the
    `@tanstack/react-query` package and instantiate it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 React Query 设置应用程序时，您应该做的第一件事是创建一个 `QueryClient` 实例。为此，您需要从 `@tanstack/react-query`
    包中导入它并实例化它：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we create a new `QueryClient` object. As we don’t
    pass any argument when instantiating the object, `QueryClient` will assume all
    the defaults.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个新的 `QueryClient` 对象。由于我们在实例化对象时没有传递任何参数，因此 `QueryClient` 将假定所有默认值。
- en: 'There are four options we can send as arguments when creating our `QueryClient`.
    They are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的 `QueryClient` 时，我们可以作为参数发送四个选项。它们如下所示：
- en: '`queryCache`: The query cache that this client will use throughout our application.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryCache`：此客户端将在整个应用程序中使用查询缓存。'
- en: '`mutationCache`: The mutation cache that this client will use throughout our
    application.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutationCache`：此客户端将在整个应用程序中使用突变缓存。'
- en: '`logger`: The logger that this client will use to display errors, warnings,
    and useful information for debugging. When nothing is specified, then React Query
    will use the console object.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger`：此客户端将使用它来显示错误、警告以及调试时有用的信息。如果没有指定任何内容，React Query 将使用控制台对象。'
- en: '`defaultOptions`: The default options that all queries and mutations will use
    throughout our application.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultOptions`：所有查询和突变将在整个应用程序中使用的默认选项。'
- en: Now, you might be wondering when you should manually set each one of these arguments
    instead of using the default ones. The following subsections will tell you when.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道何时应该手动设置这些参数而不是使用默认值。以下的小节将告诉您何时这样做。
- en: QueryCache and MutationCache
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QueryCache 和 MutationCache
- en: Here is a small spoiler that hopefully you will review and understand better
    in the following chapters, but it is essential to understand when you should manually
    configure either `QueryCache` or `MutationCache` – all queries and mutations can
    execute some code whenever there is an error, or when its execution succeeds.
    This code is represented by the `onSuccess` and `onError` functions. Also, in
    the case of mutations, you can also execute some code before the mutation executes.
    In this scenario, the function that represents this is called `onMutate`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小小的预告，希望您在接下来的章节中能够复习并更好地理解，但了解何时手动配置 `QueryCache` 或 `MutationCache` 是非常重要的——所有查询和突变都可以在出现错误或执行成功时执行一些代码。这些代码由
    `onSuccess` 和 `onError` 函数表示。此外，在突变的情况下，您还可以在突变执行之前执行一些代码。在这种情况下，表示这个功能的函数被称为
    `onMutate`。
- en: 'In the case of `QueryCache`, this is how it would look:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `QueryCache` 的情况下，它看起来是这样的：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before explaining the preceding snippet, let’s look at the very similar `MutationCache`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释前面的代码片段之前，让我们先看看与之非常相似的 `MutationCache`：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, both snippets are similar, except for the `onMutate` function
    on `MutationCache`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个代码片段非常相似，只是在 `MutationCache` 上的 `onMutate` 函数有所不同。
- en: By default, these functions don’t have any behavior, but if, for some reason,
    you intend on always doing something whenever you perform a mutation or a query,
    then you can do this configuration inside the respective function of the respective
    object when instantiating the cache object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些函数没有任何行为，但如果出于某种原因，你打算在执行突变或查询时始终执行某些操作，那么你可以在实例化缓存对象时，在相应对象的相应函数中进行此配置。
- en: 'Then, you can send this object to `QueryClient` when instantiating it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在实例化`QueryClient`时将此对象发送给它：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding snippet, we instantiated a new `QueryClient` with our custom
    `MutationCache` and `QueryCache` functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用我们的自定义`MutationCache`和`QueryCache`函数实例化了一个新的`QueryClient`。
- en: Logger
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Logger
- en: Are you using `logger` outside of the `console` object in your project? Then,
    you might want to configure it in your `QueryClient`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你在你的项目中是否在`console`对象之外使用`logger`？那么，你可能想在`QueryClient`中配置它。
- en: 'Here is what you need to do:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你需要做的是：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we created a `logger` object. This object has three
    functions that React Query will call whenever it needs to `log` an error, `warn`
    about an error, or display `error`. You can override these functions and add your
    custom logger.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个`logger`对象。这个对象有三个函数，React Query将在需要`记录`错误、`警告`错误或显示`错误`时调用这些函数。你可以覆盖这些函数并添加你自己的自定义记录器。
- en: 'Then, all you need to do is pass this `logger` object to your `QueryClient`
    when instantiating it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你所需要做的就是在你实例化`QueryClient`时传递这个`logger`对象：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding snippet, we instantiated a new `QueryClient` with our custom
    logger.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用我们的自定义记录器实例化了一个新的`QueryClient`。
- en: defaultOptions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: defaultOptions
- en: There are options that are used as defaults for all the mutations or queries
    that you execute throughout your application. `defaultOptions` allows you to override
    these defaults. There are many defaults, and I’ll avoid showing all of them to
    avoid spoilers for the next chapters, but don’t worry – I’ll do a callback to
    these options when the right time arrives.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些选项被用作你在整个应用程序中执行的所有突变或查询的默认值。`defaultOptions`允许你覆盖这些默认值。有很多默认值，我会避免展示所有这些，以免泄露下一章的内容，但请放心——在适当的时候，我会对这些选项进行回调。
- en: 'Here is how you override your `defaultOptions`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何覆盖你的`defaultOptions`：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we did in the preceding snippet was create a `defaultOptions` object and,
    inside it, a `queries` object. Inside this `queries` object, we specified that
    `staleTime` for all queries will be `Infinity`. Once again, don’t worry about
    not having a definition for this yet. You will understand it in the next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个`defaultOptions`对象，并在其中创建了一个`queries`对象。在这个`queries`对象内部，我们指定了所有查询的`staleTime`都将设置为`Infinity`。再次提醒，不要担心现在还没有对这个定义，你将在下一章中理解它。
- en: Once this setup is done, all you need to do is pass this `defaultOptions` object
    to your `QueryClient` when instantiating it, and all the queries will have the
    `staleTime` property set to `Infinity`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个设置，你所需要做的就是在你实例化`QueryClient`时传递这个`defaultOptions`对象，这样所有的查询都将具有`staleTime`属性并设置为`Infinity`。
- en: 'Here is how to do it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何操作的：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, we instantiated a new `QueryClient` with our custom
    `defaultOptions` object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用我们的自定义`defaultOptions`对象实例化了一个新的`QueryClient`。
- en: Okay, so now you are aware of `QueryClient` and should understand its role as
    the brain of React Query.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在你应该已经了解了`QueryClient`及其在React Query中作为大脑的角色。
- en: So, you might be thinking, considering that React Query is based on hooks for
    doing the queries and mutations, do we need to always pass our `QueryClient` to
    all our hooks?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能正在想，考虑到React Query是基于钩子进行查询和突变的，我们是否需要始终将我们的`QueryClient`传递给所有的钩子？
- en: Imagine if this was the case! We all would be sick and tired of all the prop
    drilling in our application even before we used our second or third hook.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下如果是这种情况！在我们使用第二个或第三个钩子之前，我们都会对应用程序中的所有属性钻探感到厌烦。
- en: Let us now see the way that React Query saves us some time by introducing `QueryClientProvider`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看React Query通过引入`QueryClientProvider`如何帮助我们节省时间。
- en: QueryClientProvider
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QueryClientProvider
- en: To make the process of sharing our `QueryClient` easier for every developer,
    React Query resorted to something we learned about in [*Chapter 1*](B18501_01.xhtml#_idTextAnchor016),
    and that is React Context. By creating its custom provider called `QueryClientProvider`,
    React Query allows you to share `QueryClient` with all the custom hooks it provides
    automatically.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让每个开发者更容易地共享我们的 `QueryClient`，React Query 采用了我们在 [*第 1 章*](B18501_01.xhtml#_idTextAnchor016)
    中学到的某种方法，那就是 React Context。通过创建其自定义提供者 `QueryClientProvider`，React Query 允许您与它自动提供的所有自定义钩子共享
    `QueryClient`。
- en: 'The following snippet shows you how to use React Query’s `QueryClientProvider`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何使用 React Query 的 `QueryClientProvider`：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding snippet, all you need to do is import your `QueryClientProvider`
    from the `@tanstack/react-query` package, wrap your main component with it, and
    pass it to `queryClient` as a prop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码片段中所看到的，您需要做的就是从 `@tanstack/react-query` 包中导入您的 `QueryClientProvider`，用它包裹您的主体组件，并将其作为属性传递给
    `queryClient`。
- en: Your application is now ready to start using React Query.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在已准备好开始使用 React Query。
- en: Now, let us see how we can add and use React Query-dedicated developer tools.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何添加和使用 React Query 专用的开发者工具。
- en: Adding React Query Devtools
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 React Query Devtools
- en: When debugging our applications, we often find ourselves thinking how amazing
    it would be to have a way to visualize what is happening inside our application.
    Well, with React Query, you don’t have to worry because it has its own developer
    tools, or devtools.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试我们的应用程序时，我们经常发现自己在想，如果有一种方法可以可视化应用程序内部发生的事情，那会多么美妙。好吧，有了 React Query，您不必担心，因为它有自己的开发者工具，或者称为
    devtools。
- en: React Query Devtools allows you to see and understand the current state of all
    your queries and mutations. This will save you a lot of time debugging and avoid
    polluting all your code with unnecessary log functions, even if temporarily.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: React Query Devtools 允许您查看和理解所有查询和突变当前的状态。这将为您节省大量调试时间，并避免在所有代码中污染不必要的日志函数，即使只是暂时性的。
- en: 'Depending on the type of project, you can install React Query Devtools in several
    ways:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目类型，您可以通过几种方式安装 React Query Devtools：
- en: 'If you are running npm in your project, run the following command:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在项目中运行 npm，请运行以下命令：
- en: '[PRE13]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you are using Yarn, run the following command:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用 Yarn，请运行以下命令：
- en: '[PRE14]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are using pnpm, run the following command:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用 pnpm，请运行以下命令：
- en: '[PRE15]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you should have React Query Devtools installed in your application. Let’s
    now see how we can add them to our code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该在您的应用程序中安装了 React Query Devtools。现在，让我们看看如何将它们添加到我们的代码中。
- en: There are two ways to use Devtools. They are Floating Mode and Embedded Mode.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Devtools 有两种方式。它们是浮动模式和嵌入式模式。
- en: Floating Mode
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮动模式
- en: Floating Mode will render the React Query logo floating in the corner of your
    screen. By clicking on it, you can toggle Devtools on or off.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动模式将在屏幕角落浮动显示 React Query 标志。通过点击它，您可以切换 Devtools 的开启或关闭。
- en: 'The logo that will show up in the corner of your screen is the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示在您屏幕角落的标志如下：
- en: '![](img/Figure_3.1_B18501.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.1](img/Figure_3.1_B18501.jpg)'
- en: Figure 3.1 – The React Query Devtools logo
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – React Query Devtools 的标志
- en: 'Once you toggle it, then you will see Devtools:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦切换，您将看到 Devtools：
- en: '![](img/Figure_3.2_B18501.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.2](img/Figure_3.2_B18501.jpg)'
- en: Figure 3.2 – React Query Devtools’ Floating Mode
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – React Query Devtools 的浮动模式
- en: Devtools will be rendered in your **DOM tree** inside a separate HTML element.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Devtools 将在您的 **DOM 树**中作为单独的 HTML 元素渲染。
- en: '![](img/Figure_3.3_B18501.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.3](img/Figure_3.3_B18501.jpg)'
- en: Figure 3.3 – React Query Devtools’ Floating Mode on the DOM
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – React Query Devtools 的浮动模式在 DOM 上的显示
- en: 'To add Devtools in Floating Mode to your application, you need to import it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Devtools 以浮动模式添加到您的应用程序中，您需要导入它：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once imported, just add it as close to your `QueryClientProvider` as you can:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，只需将其添加到尽可能靠近您的 `QueryClientProvider` 的位置：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Embedded Mode
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式模式
- en: Embedded Mode will add Devtools embedded as a regular component in your application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式模式会将 Devtools 嵌入为应用程序中的常规组件。
- en: 'Here is how it looks on your application:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在您的应用程序中的样子：
- en: '![](img/Figure_3.4_B18501.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.4](img/Figure_3.4_B18501.jpg)'
- en: Figure 3.4 – React Query Devtools’ Embedded Mode
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – React Query Devtools 的嵌入式模式
- en: If you look at your DOM tree, you will see that Devtools is rendered like a
    regular component.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看您的 DOM 树，您将看到 Devtools 被像常规组件一样渲染。
- en: '![](img/Figure_3.5_B18501.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.5](img/Figure_3.5_B18501.jpg)'
- en: Figure 3.5 – React Query Devtools’ Embedded Mode on the DOM
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – React Query Devtools 的嵌入式模式在 DOM 上的显示
- en: 'To use Devtools in Embedded Mode in your application, you need to import it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的应用程序中使用嵌入式模式的 Devtools，你需要导入它：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once they are imported, just add them as close to your `QueryClientProvider`
    as possible:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们被导入，只需将它们添加到尽可能靠近你的 `QueryClientProvider` 的位置：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, Devtools is not included in production builds. Nevertheless, you
    might want to load them in production to help you debug something. In the next
    section, we’ll see how to do that.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Devtools 不包含在生产构建中。尽管如此，你可能会想在生产环境中加载它们以帮助调试某些问题。在下一节中，我们将看到如何做到这一点。
- en: Enabling Devtools in your production build
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用生产构建中的 Devtools
- en: If you decide to load Devtools in your production environment, you must delay
    loading it and instead load it dynamically. This is important to help reduce your
    application bundle size. It is also important to lazy load Devtools because when
    using our application in production, we might never want to use it, so we want
    to avoid adding stuff to our build that we will end up not using at all. To lazy
    load components in React, we can use `React.lazy`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定在生产环境中加载 Devtools，你必须延迟加载它，而不是动态加载。这很重要，可以帮助减少你的应用程序包大小。同样重要的是懒加载 Devtools，因为当我们在生产环境中使用我们的应用程序时，我们可能永远不想使用它，所以我们想避免在我们的构建中添加最终根本不会使用的东西。在
    React 中，我们可以使用 `React.lazy` 来懒加载组件。
- en: 'Here is how we can import Devtools using `React.lazy`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用 `React.lazy` 导入 Devtools 的方法：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding snippet wraps a `React.lazy` and assigns the return of the promise
    to `ReactQueryDevtoolsProduction`, so that we can lazily load it in our production
    environment without increasing our bundle size.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段包裹了一个 `React.lazy` 并将承诺的返回值赋给 `ReactQueryDevtoolsProduction`，这样我们就可以在我们的生产环境中懒加载它，而不会增加我们的包大小。
- en: What is a dynamic import?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是动态导入？
- en: A dynamic import allows you to load a module from any place in your code asynchronously.
    This import will return a promise that, when fulfilled, returns an object containing
    the exports from the module.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入允许你从代码中的任何位置异步加载一个模块。此导入将返回一个承诺，当承诺被满足时，返回一个包含模块导出的对象。
- en: 'The previous snippet should work with all bundlers. If you are using a more
    modern bundler that supports package exports, then instead you can dynamically
    import your module like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段应该适用于所有打包器。如果你使用的是一个支持包导出的更现代的打包器，那么你可以像这样动态导入你的模块：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this snippet, we change the path from where we will import our module to
    one that will work with more modern bundlers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们将导入模块的路径从我们将要导入的路径更改为一个可以与更现代的打包器一起工作的路径。
- en: When using `React.lazy` and trying to render the component we just lazy loaded,
    React requires that the component should be wrapped with a **Suspense** component.
    This is important in a scenario where we want to show a fallback while our lazy-loaded
    component is pending.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `React.lazy` 并尝试渲染我们刚刚懒加载的组件时，React 要求该组件应该被一个 **Suspense** 组件包裹。这在我们要在懒加载的组件待定期间显示回退内容的情况下非常重要。
- en: What is Suspense?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是悬念？
- en: '`Suspense` allows you to render a loading indication in your UI while the component
    inside of it is not ready to be rendered yet.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suspense` 允许你在组件内部尚未准备好渲染时，在你的 UI 中显示加载指示。'
- en: 'Let us see what we need to do to load our `ReactQueryDevtoolsProduction` component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要做什么来加载我们的 `ReactQueryDevtoolsProduction` 组件：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see in the snippet, we wrap our `ReactQueryDevtoolsProduction` component
    with `Suspense` so it can be lazy loaded. You can also see that we didn’t provide
    any fallback since what we are trying to load are Devtools, and we don’t need
    to add any pending state while the module is loading.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码片段所示，我们用 `Suspense` 包裹了 `ReactQueryDevtoolsProduction` 组件，以便它可以被懒加载。你还可以看到我们没有提供任何回退，因为我们正在尝试加载的是
    Devtools，我们不需要在模块加载期间添加任何待定状态。
- en: Now, we don’t want to automatically load Devtools whenever we render our component.
    What we want is a way to toggle them in our application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不想在渲染我们的组件时自动加载 Devtools。我们想要的只是在我们的应用程序中切换它们的方式。
- en: Since this is a production build, we don’t want to include a button there that
    might confuse our users. So, a potential way to handle this is by creating a function
    inside our `window` object called `toggleDevtools`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个生产构建，我们不希望在其中有可能会让用户困惑的按钮。因此，一种潜在的处理方式是在我们的 `window` 对象内部创建一个名为 `toggleDevtools`
    的函数。
- en: 'This is how the React Query documentation suggests we do it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 React Query 文档建议我们这样做的方式：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is what we are doing in the preceding snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: Creating a state variable to hold the current state of the Devtools. This state
    variable is updated whenever the user toggles the Devtools on or off.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个状态变量来保存Devtools的当前状态。这个状态变量在用户打开或关闭Devtools时更新。
- en: Running an effect where we assign the toggle function to our `window`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`window`上运行一个效果，将切换函数分配给我们的`window`。
- en: Inside our return, when our `showDevtools` is toggled on, since we are lazy
    loading our `ReactQueryDevtoolsProduction` component, we need to wrap it with
    `Suspense` to be able to render it.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的返回中，当我们的`showDevtools`被切换为开启时，由于我们正在懒加载我们的`ReactQueryDevtoolsProduction`组件，我们需要用`Suspense`包裹它，以便能够渲染它。
- en: At this point, you have all that you need to start using React Query in your
    application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经拥有了在应用程序中使用React Query所需的一切。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about TanStack Query and how React Query fits into
    it. By now, you should be able to identify the primary way React Query makes server
    state management easier and how it uses queries and mutations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了TanStack Query以及React Query如何融入其中。到现在，你应该能够识别React Query使服务器状态管理变得更容易的主要方式，以及它是如何使用查询和突变的。
- en: You learned about `QueryClient` and `QueryClientProvider` and understood how
    they are fundamental to running React Query in your application. You also learned
    how you can customize your own `QueryClient` if you need to do so.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了`QueryClient`和`QueryClientProvider`，并了解了它们对于在应用程序中运行React Query是基本性的。你还学习了如果你需要，你可以如何自定义自己的`QueryClient`。
- en: Finally, you got to meet the React Query Devtools and learned how to configure
    it in your project. Also, you are now able to load it into production for those
    special scenarios when you need to do some extra debugging.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将遇到React Query Devtools，并学习如何在你的项目中配置它。现在，你也能够在需要做额外调试的特殊场景中将它加载到生产环境中。
- en: In [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091), *Fetching Data with React
    Query*, you will get to know your best friend for dealing with queries, the `useQuery`
    custom hook. You’ll understand how it works, how to use it, and how it can cache
    data. You will also learn the ways you can trigger query refetches and how to
    build dependent queries.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18501_04.xhtml#_idTextAnchor091)，*使用React Query获取数据*中，你将了解你的最佳查询助手——`useQuery`自定义钩子。你将理解它是如何工作的，如何使用它，以及它如何缓存数据。你还将了解你可以触发查询重新获取查询的方式，以及如何构建依赖查询。
- en: 'Part 2: Managing Server State with React Query'
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：使用React Query管理服务器状态
- en: When dealing with server state, many challenges are attached to how we read
    from it. From caching to pagination, we will understand how the React Query custom
    hook called `useQuery` makes this work while giving an amazing combined developer
    and user experience.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理服务器状态时，许多挑战都与我们从其中读取的方式有关。从缓存到分页，我们将了解React Query的自定义钩子`useQuery`是如何使这项工作变得容易，同时提供令人惊叹的开发者和用户体验。
- en: As well as the challenges of how we read our server state, creating, updating,
    and deleting it brings about another set of challenges. Luckily, React Query has
    another custom hook that comes to the rescue called `useMutation`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以及我们读取服务器状态时的挑战，创建、更新和删除它又带来了一组新的挑战。幸运的是，React Query还有一个名为`useMutation`的自定义钩子来提供帮助。
- en: After understanding the pillars of React Query, you might be wondering whether
    popular server-side frameworks such as Next.js and Remix allow you to use React
    Query. Spoiler alert – they do, and you will learn how here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了React Query的支柱之后，你可能想知道流行的服务器端框架如Next.js和Remix是否允许你使用React Query。剧透一下——它们确实可以，你在这里将学习如何使用。
- en: To wrap up and make sure that you will be able to sleep well at night, you will
    learn a set of recipes you can use to test your React Query, using components
    and custom hooks by levering Mock Service Worker and the React Testing Library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结并确保你晚上能睡得香，你将学习一套你可以用来测试React Query的食谱，通过利用Mock Service Worker和React Testing
    Library来使用组件和自定义钩子。
- en: 'This part includes the following chapters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包括以下章节：
- en: '[*Chapter 4*](B18501_04.xhtml#_idTextAnchor091), *Fetching Data with React
    Query*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18501_04.xhtml#_idTextAnchor091), *使用React Query获取数据*'
- en: '[*Chapter 5*](B18501_05.xhtml#_idTextAnchor140), *More Data-Fetching Challenges*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18501_05.xhtml#_idTextAnchor140), *更多数据获取挑战*'
- en: '[*Chapter 6*](B18501_06.xhtml#_idTextAnchor159), *Performing Data Mutations
    with React Query*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18501_06.xhtml#_idTextAnchor159), *使用React Query执行数据突变*'
- en: '[*Chapter 7*](B18501_07.xhtml#_idTextAnchor173), *Server-Side Rendering with
    Next.js or Remix*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18501_07.xhtml#_idTextAnchor173), *使用Next.js或Remix进行服务器端渲染*'
- en: '[*Chapter 8*](B18501_08.xhtml#_idTextAnchor184), *Testing React Query Hooks
    and Components*'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18501_08.xhtml#_idTextAnchor184), *测试 React Query 钩子和组件*'
