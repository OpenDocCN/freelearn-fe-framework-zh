<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Supporting Server Data Persistence</h1>
                
            
            <article>
                
<p class="calibre3">It's now time to talk to the server! There is no fun in creating a workout, adding exercises, and saving it to later realize that all our efforts are lost because the data did not persist anywhere. We need to fix this.</p>
<p class="calibre3">Seldom are applications self-contained. Any consumer app, irrespective of its size, has parts that interact with elements outside its boundary. With web-based applications, the interaction is mostly with a server. Apps interact with the server to authenticate, authorize, store/retrieve data, validate data, and perform other such operations.</p>
<p class="calibre3">This chapter explores the constructs that Angular provides for client-server interaction. In the process, we add a persistence layer to <em class="calibre17">Personal Trainer</em> that loads and saves data to a backend server.</p>
<p class="calibre3">The topics we cover in this chapter include the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Provisioning a backend to persist workout data</strong>: We set up a MongoLab account and use its Data API to access and store workout data.</li>
<li class="calibre12"><strong class="calibre1">Understanding the Angular HttpClient</strong>: The <kbd class="calibre13">HttpClient</kbd> allows us to interact with a server over HTTP. You'll learn how to make all types of <kbd class="calibre13">GET</kbd>, <kbd class="calibre13">POST</kbd>, <kbd class="calibre13">PUT</kbd>, and <kbd class="calibre13">DELETE</kbd> requests with the <kbd class="calibre13">HttpClient</kbd>.</li>
<li class="calibre12"><strong class="calibre1">Implementing the loading and saving of workout data</strong>: We use the <kbd class="calibre13">HTTPClient</kbd> to load and store workout data in the MongoLab databases.</li>
<li class="calibre12"><strong class="calibre1">Two ways in which we can use the HttpClient's XMLHttpRequest</strong>: Either Observables or with promises.</li>
<li class="calibre12"><strong class="calibre1">Using RxJS and Observables</strong>: To subscribe to and query streams of data.</li>
<li class="calibre12"><strong class="calibre1">Using promises</strong>: In this chapter, we will see how to use promises as part of HTTP invocation and response.</li>
<li class="calibre12"><strong class="calibre1">Working with cross-domain access</strong>: As we are interacting with a MongoLab server in a different domain, you will learn about browser restrictions on cross-domain access. You will also learn how JSONP and CORS help us make cross-domain access easy and about Angular JSONP support.</li>
</ul>
<p class="calibre3">Let's set the ball rolling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular and server interactions</h1>
                
            
            <article>
                
<p class="calibre3">Any client-server interaction typically boils down to sending HTTP requests to a server and receiving responses from a server. For heavy JavaScript apps, we depend on the AJAX request/response mechanism to communicate with the server. To support AJAX-based communication, Angular provides the Angular <kbd class="calibre13"><span>HttpClient</span></kbd> module. Before we delve into the <kbd class="calibre13"><span>HttpClient</span></kbd> module, we need to set up our server platform that stores the data and allows us to manage it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up the persistence store</h1>
                
            
            <article>
                
<p class="calibre3">For data persistence, we use a document database called MongoDB (<a href="https://www.mongodb.com/" target="_blank" class="calibre10"><span>https://www.mongodb.com/</span></a>), hosted over MongoLab (<span class="calibre6"><a href="https://www.mlab.com/" class="calibre10">https://www.mlab.com/</a></span>), as our data store. The reason we zeroed in on MongoLab is that it provides an interface to interact with the database directly. This saves us the effort of setting up server middleware to support MongoDB interaction.</p>
<div class="packt_infobox">
<p class="calibre20">It is never a good idea to expose the data store/database directly to the client. But in this case, since our primary aim is to learn about Angular and client-server interaction, we take this liberty and directly access the MongoDB instance hosted in MongoLab. There is also a new breed of apps that are built over <strong class="calibre23">noBackend</strong> solutions. In such a setup, frontend developers build apps without the knowledge of the exact backend involved. Server interaction is limited to making API calls to the backend. If you are interested in knowing more about these noBackend solutions, do check out <span class="calibre22"><a href="http://nobackend.org/" class="calibre21">http://nobackend.org/</a></span><span class="calibre22">.</span></p>
</div>
<p class="calibre3">Our first task is to provision an account on MongoLab and create a database:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Go to <a href="https://mlab.com" target="_blank" class="calibre10">https://mlab.com</a> and sign up for an mLab account by following the instructions on the website</li>
<li value="2" class="calibre12">Once the account is provisioned, log in and create a new Mongo database by clicking on the <span>Create New</span> button on the home page</li>
<li value="3" class="calibre12">On the database creation screen, you need to make some selections to provision the database. See the following screenshot to select the free database tier and other options:</li>
</ol>
<div class="packt_figure"><img class="image-border11" src="../images/00052.jpeg"/></div>
<ol start="4" class="calibre14">
<li value="4" class="calibre12">Create the database and make a note of the database name that you create</li>
<li value="5" class="calibre12">Once the database is provisioned, open the database and add two collections to it from the <span>Collection</span> tab:
<ul class="calibre30">
<li class="calibre12"><kbd class="calibre13">exercises</kbd>: This stores all <em class="calibre2">Personal Trainer</em> exercises</li>
<li class="calibre12"><kbd class="calibre13">workouts</kbd>: This stores all <em class="calibre2">Personal Trainer</em> workouts</li>
</ul>
</li>
</ol>
<p class="calibre3">Collections in the MongoDB world equate to a database table.</p>
<div class="packt_infobox">
<p class="calibre20">MongoDB belongs to a breed of databases called <strong class="calibre23">document databases</strong>. The central concepts here are documents, attributes, and their linkages. And unlike traditional databases, the schema is not rigid. We will not be covering what document databases are and how to perform data modeling for document-based stores in this book. <em class="calibre25">Personal Trainer</em> has a limited storage requirement and we manage it using the two previously mentioned document collections. We may not even be using the document database in its true sense.</p>
</div>
<p class="calibre3">Once the collections are added, add yourself as a user to the database from the <span class="calibre6">Users</span> tab.</p>
<p class="calibre3">The next step is to determine the API key for the MongoLab account. The provisioned API key has to be appended to every request made to MongoLab. To get the API key, perform the following steps:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Click on the username (not the account name) in the top-right corner to open the user profile.</li>
<li value="2" class="calibre12">In the section titled <span>API Key</span>, the current API key is displayed; copy it. At the same time, click on the button below the API key to <span>Enable Data API access</span>. This is disabled by default.</li>
</ol>
<p class="calibre3">The data store schema is complete. We now need to seed these collections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Seeding the database</h1>
                
            
            <article>
                
<p class="calibre3">The <em class="calibre17">Personal Trainer</em> app already has a predefined workout and a list of 12 exercises. We need to seed the collections with this data.</p>
<p class="calibre3">Open <kbd class="calibre13">seed.js</kbd> in the <kbd class="calibre13">trainer/db</kbd> folder for checkpoint 5.1 from the companion code base. It contains the seed JSON script and detailed instructions on how to seed data into the MongoLab database instance.</p>
<p class="calibre3">Once seeded, the database will have one workout in the workouts collection and 12 exercises in the exercises collection. Verify this on the MongoLab site; the collections should show the following:</p>
<div class="packt_figure"><img class="calibre28" src="../images/00053.jpeg"/></div>
<p class="calibre3">Everything has been set up now, so let's start our discussion of the <span class="calibre6"><kbd class="calibre13">HttpClient</kbd> </span>module and implement workout/exercise persistence for the <em class="calibre17">Personal Trainer</em> app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The basics of the HTTPClient module</h1>
                
            
            <article>
                
<p class="calibre3">At the core of the <kbd class="calibre13">HTTPClient</kbd> module is the <kbd class="calibre13">HttpClient</kbd>. It performs HTTP requests using <kbd class="calibre13">XMLHttpRequest</kbd> as the default backend (JSONP is also available, as we will see later in this chapter). It supports requests such as <kbd class="calibre13">GET</kbd>, <kbd class="calibre13">POST</kbd>, <kbd class="calibre13">PUT</kbd>, and <kbd class="calibre13">DELETE</kbd>. In this chapter, we will use the <kbd class="calibre13">HttpClient</kbd> to make all of these types of requests. As we will see, the <kbd class="calibre13">HttpClient</kbd> makes it easy to make these calls with a minimal amount of setup and complexity. None of this terminology will come as a surprise to anyone who has previously worked with Angular or built JavaScript applications that communicate with a backend data store.</p>
<p class="calibre3">However, there is a substantial change in the way Angular handles HTTP requests. Calling a request now returns an Observable of HTTP responses. It does so by using the RxJS library, which is a well-known open source implementation of the asynchronous Observable pattern.</p>
<div class="packt_infobox">
<p class="calibre20">You can find the RxJS project on GitHub at <span class="calibre22"><a href="https://github.com/Reactive-Extensions/RxJS" class="calibre21">https://github.com/Reactive-Extensions/RxJS</a></span>. <span class="calibre22">The site indicates that the project is</span> being actively developed by Microsoft in collaboration with a community of open source developers. We will not be covering the asynchronous Observable pattern in great detail here, and we encourage you to visit that site to learn more about the pattern and how RxJS implements it. The version of RxJS that Angular is using is beta 5.</p>
</div>
<p class="calibre3">In the simplest of terms, using Observables allows a developer to think about the data that flows through an application as streams of information that the application can dip into and use whenever it wants. These streams change over time, which allows the application to react to these changes. This quality of Observables provides a foundation for <strong class="calibre5">functional reactive programming</strong> (<strong class="calibre5">FRP</strong>), which fundamentally shifts the paradigm for building web applications from imperative to reactive.</p>
<p class="calibre3">The <kbd class="calibre13">RxJS</kbd> library provides operators that allow you to subscribe to and query these data streams. Moreover, you can easily mix and combine them, as we will see in this chapter. Another advantage of Observables is that it is easy to cancel or unsubscribe from them, making it possible to seamlessly handle errors inline.</p>
<p class="calibre3">While it is still possible to use promises, the default method in Angular uses Observables. We will also cover promises in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Personal Trainer and server integration</h1>
                
            
            <article>
                
<p class="calibre3">As described in the previous section, client-server interaction is all about asynchronicity. As we alter our <em class="calibre17">Personal Trainer</em> app to load data from the server, this pattern becomes self-evident.</p>
<p class="calibre3">In the previous chapter, the initial set of workouts and exercises was hardcoded in the <kbd class="calibre13">WorkoutService</kbd> implementation. Let's see how to load this data from the server first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Loading exercise and workout data</h1>
                
            
            <article>
                
<p class="calibre3">Earlier in this chapter, we seeded our database with a data form, the <kbd class="calibre13">seed.js</kbd> file. We now need to render this data in our views. The MongoLab Data API is going to help us here.</p>
<div class="packt_infobox">
<p class="calibre20">The <span class="calibre22">MongoLab</span> Data API uses an API key to authenticate access requests. Every request made to the <span class="calibre22">MongoLab</span> endpoints needs to have a query string parameter, <kbd class="calibre24">apikey=&lt;key&gt;</kbd>, where <kbd class="calibre24">key</kbd> is the API key that we provisioned earlier in the chapter. Remember that the key is always provided to a user and associated with their account. Avoid sharing your API keys with others.</p>
</div>
<p class="calibre3">The API follows a predictable pattern to query and update data. For any MongoDB collection, the typical endpoint access pattern is one of the following (given here is the base URL: <a href="https://api.mongolab.com/api/1/databases" class="calibre10"><span>https://api.mongolab.com/api/1/databases</span></a>):</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">/&lt;dbname&gt;/collections/&lt;name&gt;?apiKey=&lt;key&gt;</kbd>: This has the following requests:
<ul class="calibre30">
<li class="calibre12"> <kbd class="calibre13">GET</kbd>: This action gets all objects in the given collection name.</li>
<li class="calibre12"> <kbd class="calibre13">POST</kbd>: This action adds a new object to the collection name. MongoLab has an <kbd class="calibre13">_id</kbd> property that uniquely identifies the document (object). If not provided in the posted data, it is auto-generated.</li>
</ul>
</li>
<li class="calibre12"><kbd class="calibre13">/&lt;dbname&gt;/collections/&lt;name&gt;/&lt;id&gt;?apiKey=&lt;key&gt;</kbd>: This has the following requests:
<ul class="calibre30">
<li class="calibre12"> <kbd class="calibre13">GET</kbd>: This gets a specific document/collection item with a specific ID (a match done on the <kbd class="calibre13">_id</kbd> property) from the collection name.</li>
<li class="calibre12"> <kbd class="calibre13">PUT</kbd>: This updates the specific item (<kbd class="calibre13">id</kbd>) in the collection name.</li>
<li class="calibre12"> <kbd class="calibre13">DELETE</kbd>: This deletes the item with a specific ID from the collection name.</li>
</ul>
</li>
</ul>
<div class="packt_infobox">
<p class="calibre20">For more details on the Data API interface, visit the MongoLab Data API documentation at <span class="calibre22"><a href="http://docs.mlab.com/data-api" class="calibre21">http://docs.mlab.com/data-api</a></span><span class="calibre22">.</span></p>
</div>
<p class="calibre3">Now we are in a position to start implementing exercise/workout list pages.</p>
<div class="packt_infobox">
<p class="calibre20">The code that we are starting with in this chapter is <kbd class="calibre24">checkpoint 4.6</kbd> (folder: <kbd class="calibre24">trainer</kbd>) in the GitHub repository for this book. It is available on GitHub (<span class="calibre22"><a href="https://github.com/chandermani/angular6byexample" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample</a>)</span>. Checkpoints are implemented as branches in GitHub. If you are not using Git, download the snapshot of checkpoint 4.6 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/tree/checkpoint4.6" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint4.6</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Loading exercise and workout lists from a server</h1>
                
            
            <article>
                
<p class="calibre3">To pull exercise and workout lists from the MongoLab database, we have to rewrite our <kbd class="calibre13">WorkoutService</kbd> service methods: <kbd class="calibre13">getExercises</kbd> and <kbd class="calibre13">getWorkouts</kbd>. But before we can do that, we have to set up our service to work with Angular's HTTPClient module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding the HTTPClient module and RxJS to our project</h1>
                
            
            <article>
                
<p class="calibre3">The Angular HTTPClient module is included in the Angular bundles that you have already installed. To use it, we need to import it into <kbd class="calibre13">app.module.ts,</kbd> like so (make sure that the import follows <kbd class="calibre13">BrowserModule</kbd>):</p>
<pre class="calibre19"><strong class="calibre1">import { HttpClientModule } from '@angular/common/http';</strong>
. . . 
@NgModule({ 
  imports: [ 
    BrowserModule,
    <strong class="calibre1">HttpClientModule,</strong> 
. . . 
})</pre>
<p class="calibre3">We also need an external third-party library: <strong class="calibre5">Reactive Extensions for JavaScript</strong> (<strong class="calibre5">RxJS</strong>). RxJS implements the Observable pattern and it is used by Angular with the HTTPClient module. It is included in the Angular bundles that are already part of our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating workout-service to use the HTTPClient module and RxJS</h1>
                
            
            <article>
                
<p class="calibre3">Open  <kbd class="calibre13">workout.service.ts</kbd> from <kbd class="calibre13">trainer/src/app/core</kbd>. In order to use the HTTPClient and RxJS within the <kbd class="calibre13">WorkoutService</kbd>, we need to add the following imports to that file:</p>
<pre class="calibre19">import { HttpClient } from '@angular/common/http';<br class="title-page-name"/>import { Observable } from 'rxjs/Observable';<br class="title-page-name"/>import { catchError } from 'rxjs/operators';</pre>
<p class="calibre3">We are importing the <kbd class="calibre13">HTTPClient</kbd> module along with <kbd class="calibre13">Observable</kbd> from RxJS and one additional RxJS operator: <kbd class="calibre13">catchError</kbd>. We'll see how this operator is used as we work through the code in this section.</p>
<p class="calibre3">In the class definition, add the following properties, which include a workout property and ones that set the URL for the collections in our Mongo database and the key to that database as well as another property: <kbd class="calibre13">params</kbd>, which sets up the API key as a query string for API access:</p>
<pre class="calibre19">workout: WorkoutPlan; 
collectionsUrl = "https://api.mongolab.com/api/1/ databases/&lt;dbname&gt;/collections"; 
apiKey = &lt;key&gt; 
params = '?apiKey=' + this._apiKey; </pre>
<p class="calibre3">Replace the <kbd class="calibre13">&lt;dbname&gt;</kbd> and <kbd class="calibre13">&lt;key&gt;</kbd> tokens with the database name and API key of the database that we provisioned earlier in the chapter.</p>
<p class="calibre3">Next, inject the HTTPClient module into the <kbd class="calibre13">WorkoutServiceconstructor</kbd> using the following line of code:</p>
<pre class="calibre19">constructor(public http: HttpClient) {
}</pre>
<p class="calibre3">Then change the <kbd class="calibre13">getExercises()</kbd> method to the following:</p>
<pre class="calibre19">getExercises() {<br class="title-page-name"/>    return this.http.get&lt;ExercisePlan&gt;(this.collectionsUrl + '/exercises' + this.params)<br class="title-page-name"/>        .pipe(catchError(WorkoutService.handleError));<br class="title-page-name"/>}</pre>
<p class="calibre3">If you are used to working with promises for asynchronous data operations, what you see here will look different. Instead of a promise that has a call to <kbd class="calibre13">then()</kbd> chained to it, what happens here is that the <kbd class="calibre13">http.get</kbd> method returns an Observable from the RxJS library. <span class="calibre6">Notice that we are also setting the response to be of type </span><kbd class="calibre13">&lt;ExercisePlan&gt;</kbd><span class="calibre6"> to make explicit to our upstream callers what type of Observable is being returned from our HTTP GET call.</span></p>
<div class="packt_infobox">
<p class="calibre20">Returning an Observable is the default response when using the <kbd class="calibre24">HTTPClient</kbd> module's <kbd class="calibre24">get</kbd> method. The Observable can, however, be converted to a promise. And, as we will see later in this chapter, the option to return JSONP also exists.</p>
</div>
<p class="calibre3">Before we move on, there is one more thing to touch upon in this code. Notice that we are using a pipe method to add a <kbd class="calibre13">catchError</kbd> operator. This operator accepts a method, <kbd class="calibre13">handleError</kbd>, for handling a failed response. The <kbd class="calibre13">handleError</kbd> method takes the failed response as a parameter. We log the error to the console and use <kbd class="calibre13">Observable.throw</kbd> to return the error to the consumer:</p>
<pre class="calibre19">static handleError (error: Response) { 
    console.error(error); 
    return Observable.throw(error || 'Server error');
}</pre>
<p class="calibre3">To be clear, this is not production code, but it will give us the opportunity to show how to write code upstream to handle errors that are generated as part of data access.</p>
<div class="packt_infobox">
<p class="calibre20">It is important to understand that at this stage no data is flowing through the Observable until there is a subscription to it. This can bring about a gotcha moment for things such as adds and updates if you are not careful to add subscriptions to your Observables.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modifying getWorkouts() to use the HTTPClient module</h1>
                
            
            <article>
                
<p class="calibre3">The change in the code for retrieving workouts is almost identical to that for the exercises:</p>
<pre class="calibre19">getWorkouts() {<br class="title-page-name"/>    return this.http.get&lt;WorkoutPlan[]&gt;(this.collectionsUrl + '/workouts' + this.params)<br class="title-page-name"/>        .pipe(catchError(WorkoutService.handleError));<br class="title-page-name"/>}</pre>
<p class="calibre3"><span class="calibre6">Again we are specifying the type of Observable—in this case</span><span class="calibre6"> </span><span class="calibre6"><kbd class="calibre13">&lt;WorkoutPlan[]&gt;</kbd></span>—<span class="calibre6">that will be returned by our HTTP GET call and using <kbd class="calibre13">pipe</kbd> to add a <kbd class="calibre13">catchError</kbd> operator.</span></p>
<p class="calibre3">Now that the <kbd class="calibre13">getExercises</kbd> and <kbd class="calibre13">getWorkouts</kbd> methods are updated, we need to make sure that they work with the upstream callers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating the workout/exercise list pages</h1>
                
            
            <article>
                
<p class="calibre3">The exercise and workout list pages (as well as <kbd class="calibre13">LeftNavExercises</kbd>) call either the <kbd class="calibre13">getExercises</kbd> or <kbd class="calibre13">getWorkouts</kbd> method in <kbd class="calibre13">model.ts</kbd>. In order to get these working with the remote calls that are now being made using the <kbd class="calibre13">HTTPClient</kbd> module, we need to modify those calls to subscribe to the Observable that is being returned by the <kbd class="calibre13">HTTPClient</kbd> module. So, update the code in the <kbd class="calibre13">ngOnInit</kbd> method in <kbd class="calibre13">exercises.component.ts</kbd> to the following:</p>
<pre class="calibre19">  ngOnInit() {<br class="title-page-name"/>    this.workoutService.getExercises()<br class="title-page-name"/>    .subscribe(<br class="title-page-name"/>        exercises =&gt; this.exerciseList = exercises,<br class="title-page-name"/>        (err: any) =&gt; console.error<br class="title-page-name"/>    );</pre>
<p class="calibre3">Our method now subscribes to the Observable that is being returned by the <kbd class="calibre13">getExercises</kbd> method; at the point when the response arrives, it assigns the results to <kbd class="calibre13">exerciseList</kbd>. If there is an error, it assigns it to a <kbd class="calibre13">console.error</kbd> call that displays the error in the console. All of this is now being handled asynchronously using the <kbd class="calibre13">HTTPClient</kbd> module with RxJS.</p>
<p class="calibre3">Go ahead and make similar changes to the <kbd class="calibre13">ngOnInit</kbd> methods in <kbd class="calibre13">workouts.component.ts</kbd> and <kbd class="calibre13">left-nav-exercises.component.ts</kbd>.</p>
<p class="calibre3">Refresh the workout/exercise list page and the workout and exercise data will be loaded from the database server.</p>
<div class="packt_infobox">
<p class="calibre20">Look at the complete implementation in checkpoint 5.1 in the GitHub repository if you are having difficulty in retrieving/showing data. Note that in this checkpoint, we have disabled navigation links to the workout and exercise screens because we still have to add the Observable implementation to them. We'll do that in the next section. Also remember to replace the database name and API key before you run the code from <kbd class="calibre24">Checkpoint 5.1</kbd>. If you are not using Git, download the snapshot of <kbd class="calibre24">Checkpoint 5.1</kbd> (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/tree/checkpoint5.1" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint5.1</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>
<p class="calibre3">This looks good and the lists are loading fine. Well, almost! There is a small glitch in the workout list page. We can easily spot it if we look carefully at any list item (in fact, there is only one item):</p>
<div class="packt_figure"><img class="image-border12" src="../images/00054.jpeg"/></div>
<p class="calibre3">The workout duration calculations are not working anymore! What could be the reason? We need to look back at how these calculations were implemented. The <kbd class="calibre13">WorkoutPlan</kbd> service (in <kbd class="calibre13">model.ts</kbd>) defines a <kbd class="calibre13">totalWorkoutDuration</kbd> method that does the math for this.</p>
<p class="calibre3">The difference is in the workout array that is bound to the view. In the previous chapter, we created the array with model objects that were created using the <kbd class="calibre13">WorkoutPlan</kbd> service. But now, since we are retrieving data from the server, we bind a simple array of JavaScript objects to the view, which for obvious reasons has no calculation logic.</p>
<p class="calibre3">We can fix this problem by mapping a server response to our model class objects and returning them to any upstream caller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mapping server data to application models</h1>
                
            
            <article>
                
<p class="calibre3">Mapping server data to our model and vice versa may be unnecessary if the model and server storage definition match. If we look at the <kbd class="calibre13">Exercise</kbd> model class and the seed data that we have added for the exercise in MongoLab, we will see that they do match and hence mapping becomes unnecessary.</p>
<p class="calibre3">Mapping a server response to the model data becomes imperative if:</p>
<ul class="calibre11">
<li class="calibre12">Our model defines any methods</li>
<li class="calibre12">A stored model is different from its representation in code</li>
<li class="calibre12">The same model class is used to represent data from different sources (this can happen for mashups, where we pull data from disparate sources)</li>
</ul>
<p class="calibre3">The <kbd class="calibre13">WorkoutPlan</kbd> service is a prime example of an impedance mismatch between a model representation and its storage. Look at the following screenshot to understand these differences:</p>
<div class="packt_figure"><img class="calibre28" src="../images/00055.jpeg"/></div>
<p class="calibre3">The two major differences between the model and server data are as follows:</p>
<ul class="calibre11">
<li class="calibre12">The model defines the <kbd class="calibre13">totalWorkoutDuration</kbd> method.</li>
<li class="calibre12">The <kbd class="calibre13">exercises</kbd> array representation also differs. The <kbd class="calibre13">exercises</kbd> array of the model contains the full <kbd class="calibre13">Exercise</kbd> object, while the server data stores just the exercise identifier or name.</li>
</ul>
<p class="calibre3">This clearly means that loading and saving a workout requires model mapping.</p>
<p class="calibre3">The way we will do this is by adding another operator to transform the Observable response object. So far, we have only returned a plain JavaScript object as the response. The nice thing is that the pipe method that we used to add error handling also allows us to add additional operators that we can use to transform the JavaScript object into the <kbd class="calibre13">WorkoutPlan</kbd> type in our model.</p>
<p class="calibre3">Let's rewrite the <kbd class="calibre13">getWorkouts</kbd> method in the <kbd class="calibre13">workout-service.ts</kbd> file to the following:</p>
<pre class="calibre19">    getWorkouts(): Observable&lt;WorkoutPlan[]&gt; {<br class="title-page-name"/>        return this.http.get&lt;WorkoutPlan[]&gt;(this.collectionsUrl + '/workouts' + this.params)<br class="title-page-name"/>            .pipe(<br class="title-page-name"/>                map((workouts: Array&lt;any&gt;) =&gt; {<br class="title-page-name"/>                  const result: Array&lt;WorkoutPlan&gt; = [];<br class="title-page-name"/>                  if (workouts) {<br class="title-page-name"/>                      workouts.forEach((workout) =&gt; {<br class="title-page-name"/>                          result.push(<br class="title-page-name"/>                              new WorkoutPlan(<br class="title-page-name"/>                                  workout.name,<br class="title-page-name"/>                                  workout.title,<br class="title-page-name"/>                                  workout.restBetweenExercise,<br class="title-page-name"/>                                  workout.exercises,<br class="title-page-name"/>                                  workout.description<br class="title-page-name"/>                              ));<br class="title-page-name"/>                      });<br class="title-page-name"/>                  }<br class="title-page-name"/>                  return result;<br class="title-page-name"/>                }),<br class="title-page-name"/>                catchError(this.handleError&lt;WorkoutPlan[]&gt;('getWorkouts', []))<br class="title-page-name"/>            );<br class="title-page-name"/>    }</pre>
<p class="calibre3">We have added a  <kbd class="calibre13">map</kbd> operator that transforms this Observable into one made up of <kbd class="calibre13">WorkoutPlan</kbd> objects. Each <kbd class="calibre13">WorkoutPlan</kbd> object (we have only one at the moment) will then have the <kbd class="calibre13">totalWorkoutDuration</kbd> method that we need.</p>
<p class="calibre3">Looking at the code you can see that we operate on the JSON results HTTPClient response, which is why we are using the <kbd class="calibre13">&lt;any&gt;</kbd> type. And then we create a typed array of <kbd class="calibre13">WorkoutPlans</kbd> and iterate through the first array using a fat arrow <kbd class="calibre13">forEach</kbd> function, assigning each JavaScript object to a <kbd class="calibre13">WorkoutPlan</kbd> object. </p>
<p class="calibre3">We return the results of these mappings to the callers that subscribe to them, <kbd class="calibre13">workouts.component.ts</kbd> in this case. We have also updated the <kbd class="calibre13">catchError</kbd> operator with a new <kbd class="calibre13">handleError</kbd> method which you can find in <kbd class="calibre13">Checkpoint 5.2</kbd>. The callers do not need to make any changes to the code they use to subscribe to our workouts Observable. Instead, the model mapping can take place at one spot in the application and then be used throughout it.</p>
<p class="calibre3">If you rerun the application, you will see that the total number of seconds now displays properly:</p>
<div class="packt_figure"><img class="image-border13" src="../images/00056.jpeg"/></div>
<div class="packt_infobox">
<p class="calibre20">Checkpoint 5.2 in the GitHub repository contains the working implementation for what we have covered so far. The GitHub branch is <kbd class="calibre24">checkpoint5.2</kbd> (folder: <kbd class="calibre24">trainer</kbd>).</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Loading exercise and workout data from the server</h1>
                
            
            <article>
                
<p class="calibre3">Just as we fixed the <kbd class="calibre13">getWorkouts</kbd> implementation in <kbd class="calibre13">WorkoutService</kbd> earlier, we can implement other get operations for exercise- and workout-related stuff. Copy the service implementation for the <kbd class="calibre13">getExercise</kbd> and <kbd class="calibre13">getWorkout</kbd> methods of <kbd class="calibre13">WorkoutService</kbd> from <kbd class="calibre13">workout.service.ts</kbd> in the <kbd class="calibre13">trainer/src/app/core</kbd> folder in checkpoint 5.2.</p>
<div class="packt_infobox">
<p class="calibre20">The <kbd class="calibre24">getWorkout</kbd> and <kbd class="calibre24">getExercise</kbd> methods use the name of the workout/exercise to retrieve results. Every MongoLab collection item has an <kbd class="calibre24">_id</kbd> property that uniquely identifies the item/entity. In the case of our <kbd class="calibre24">Exercise</kbd> and <kbd class="calibre24">WorkoutPlan</kbd> objects, we use the name of the exercise for unique identification. Hence, the <kbd class="calibre24">name</kbd> and <kbd class="calibre24">_id</kbd> property of each object always match.</p>
</div>
<p class="calibre3">At this point, we will need to add one more import to <kbd class="calibre13">workout.service.ts</kbd>:</p>
<pre class="calibre19">import { forkJoin } from 'rxjs/observable/forkJoin';</pre>
<p class="calibre3">This import brings in the <kbd class="calibre13">forkJoin</kbd> operator, which we will be discussing shortly.</p>
<p class="calibre3">Pay special attention to the implementation for the <kbd class="calibre13">getWorkout</kbd> method because there is a decent amount of data transformation happening due to the model and data storage format mismatch. This is how the <kbd class="calibre13">getWorkout</kbd> method now looks:</p>
<pre class="calibre19">    getWorkout(workoutName: string): Observable&lt;WorkoutPlan&gt; {<br class="title-page-name"/>      return forkJoin (<br class="title-page-name"/>          this.http.get(this.collectionsUrl + '/exercises' + this.params),<br class="title-page-name"/>          this.http.get(this.collectionsUrl + '/workouts/' + workoutName + this.params))<br class="title-page-name"/>          .pipe(<br class="title-page-name"/>               map(<br class="title-page-name"/>                  (data: any) =&gt; {<br class="title-page-name"/>                      const allExercises = data[0];<br class="title-page-name"/>                      const workout = new WorkoutPlan(<br class="title-page-name"/>                          data[1].name,<br class="title-page-name"/>                          data[1].title,<br class="title-page-name"/>                          data[1].restBetweenExercise,<br class="title-page-name"/>                          data[1].exercises,<br class="title-page-name"/>                          data[1].description<br class="title-page-name"/>                      );<br class="title-page-name"/>                      workout.exercises.forEach(<br class="title-page-name"/>                          (exercisePlan: any) =&gt; exercisePlan.exercise = allExercises.find(<br class="title-page-name"/>                              (x: any) =&gt; x.name === exercisePlan.name<br class="title-page-name"/>                          )<br class="title-page-name"/>                      );<br class="title-page-name"/>                      return workout;<br class="title-page-name"/>                  }<br class="title-page-name"/>              ),<br class="title-page-name"/>              catchError(this.handleError&lt;WorkoutPlan&gt;(`getWorkout id=${workoutName}`))<br class="title-page-name"/>        );<br class="title-page-name"/>      }</pre>
<p class="calibre3">There is a lot happening inside <kbd class="calibre13">getWorkout</kbd> that we need to understand.</p>
<p class="calibre3">The <kbd class="calibre13">getWorkout</kbd> method uses Observable and its <kbd class="calibre13">forkJoin</kbd> operator to return two Observable objects: one that retrieves the <kbd class="calibre13">Workout</kbd> and another that retrieves a list of all the <kbd class="calibre13">Exercises</kbd>. What is interesting about the <kbd class="calibre13">forkJoin</kbd> operator is that not only does it allow us to return multiple Observable streams, but it also waits until both Observable streams have retrieved their data before further processing the results. In other words, it enables us to stream the responses from multiple concurrent HTTP requests and then operate on the combined results.</p>
<p class="calibre3">Once we have the <kbd class="calibre13">Workout</kbd> details and the complete list of exercises, we then <kbd class="calibre13">pipe</kbd> the results to the <kbd class="calibre13">map</kbd> operator (which we saw previously with the code for the <kbd class="calibre13">Workouts</kbd> list), which we use to change the <kbd class="calibre13">exercises</kbd> array of the workout to the correct <kbd class="calibre13">Exercise</kbd> class object. We do this by searching the <kbd class="calibre13">allExercises</kbd> Observable for the name of the exercise in the <kbd class="calibre13">workout.exercises</kbd> array returned from the server, and then assigning the matching exercise to the workout services array. The end result is that we have a complete <kbd class="calibre13">WorkoutPlan</kbd> object with the <kbd class="calibre13">exercises</kbd> array set up correctly.</p>
<p class="calibre3">These <kbd class="calibre13">WorkoutService</kbd> changes warrant fixes in upstream callers too. We have already fixed the lists of exercises in the <kbd class="calibre13">LeftNavExercises</kbd> and <kbd class="calibre13">Exercises</kbd> components and the workouts in the <kbd class="calibre13">Workouts</kbd> component. Now let's fix the <kbd class="calibre13">Workout</kbd> and <kbd class="calibre13">Exercise</kbd> components along similar lines. The <kbd class="calibre13">getWorkout</kbd> and <kbd class="calibre13">getExercise</kbd> methods in the workout services are not directly called by these components, but by builder services. So we'll have to fix the builder services together with the <kbd class="calibre13">Workout</kbd> and <kbd class="calibre13">Exercise</kbd> components and the two resolvers—<kbd class="calibre13">WorkoutResolver</kbd> and <kbd class="calibre13">ExerciseResolver</kbd>—that we have added to the routes for these components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing the builder services</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have <kbd class="calibre13">WorkoutService</kbd> set up to retrieve a workout from our remote data store, we have to modify <kbd class="calibre13">WorkoutBuilderService</kbd> to be able to retrieve that workout as an Observable. The method that pulls the <kbd class="calibre13">Workout</kbd> details is <kbd class="calibre13">startBuilding</kbd>. In order to do that, we will break the current <kbd class="calibre13">startBuilding</kbd> method into two methods, one for new workouts and one for existing workouts that we have retrieved from the server. Here is the code for new workouts:</p>
<pre class="calibre19">    startBuildingNew() {<br class="title-page-name"/>      const exerciseArray: ExercisePlan[] = [];<br class="title-page-name"/>      this.buildingWorkout = new WorkoutPlan('', '', 30, exerciseArray);<br class="title-page-name"/>      this.newWorkout = true;<br class="title-page-name"/>      return this.buildingWorkout;<br class="title-page-name"/>    }</pre>
<p class="calibre3">For existing workouts, we add the following code:</p>
<pre class="calibre19">    startBuildingExisting(name: string) {<br class="title-page-name"/>      this.newWorkout = false;<br class="title-page-name"/>      return this.workoutService.getWorkout(name);<br class="title-page-name"/>    }</pre>
<p class="calibre3">We'll let you make the same fixes in <kbd class="calibre13">ExerciseBuilderService</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating the resolvers</h1>
                
            
            <article>
                
<p class="calibre3">As we move on to using Observable types with our data access, we are going to have to make some adjustments to the resolvers that we have created for the routes leading to workout and exercise screens. We start with the <kbd class="calibre13">WorkoutResolver</kbd> in <kbd class="calibre13">workout-resolver.ts</kbd> that can be found in the <kbd class="calibre13">workout</kbd> folder.</p>
<p class="calibre3">First add the following imports from RxJs:</p>
<pre class="calibre19">import { Observable } from 'rxjs/Observable';<br class="title-page-name"/>import { of } from 'rxjs/observable/of';<br class="title-page-name"/>import { map, catchError } from 'rxjs/operators';</pre>
<p class="calibre3">Next update the<span class="calibre6"> </span><kbd class="calibre13">resolve</kbd><span class="calibre6"> </span>method as follows:</p>
<pre class="calibre19">  resolve(<br class="title-page-name"/>    route: ActivatedRouteSnapshot,<br class="title-page-name"/>    state: RouterStateSnapshot): Observable&lt;WorkoutPlan&gt; {<br class="title-page-name"/>    const workoutName = route.paramMap.get('id');<br class="title-page-name"/><br class="title-page-name"/>    if (!workoutName) {<br class="title-page-name"/>        return this.workoutBuilderService.startBuildingNew();<br class="title-page-name"/>    } else {<br class="title-page-name"/>        return this.workoutBuilderService.startBuildingExisting(workoutName)<br class="title-page-name"/>        .pipe(<br class="title-page-name"/>          map(workout =&gt; {<br class="title-page-name"/>            if (workout) {<br class="title-page-name"/>              this.workoutBuilderService.buildingWorkout = workout;<br class="title-page-name"/>              return workout;<br class="title-page-name"/>            } else {<br class="title-page-name"/>              this.router.navigate(['/builder/workouts']);<br class="title-page-name"/>              return null;<br class="title-page-name"/>            }<br class="title-page-name"/>          }),<br class="title-page-name"/>          catchError(error =&gt; {<br class="title-page-name"/>            console.log('An error occurred!');<br class="title-page-name"/>            this.router.navigate(['/builder/workouts']);<br class="title-page-name"/>            return of(null);<br class="title-page-name"/>          })<br class="title-page-name"/>        );<br class="title-page-name"/>    }</pre>
<p class="calibre3">As you can see, we have split out the behavior for a new workout (one where there is no workout name being passed as a parameter in the URL) and that for an existing workout. In the former case, we call <kbd class="calibre13">workoutBuilderService.startBuildingExisting</kbd>, which will return a new <kbd class="calibre13">WorkoutPlan</kbd>. In the latter case, we call <kbd class="calibre13">workoutBuilderService.startBuildingExisting</kbd> and <span class="calibre6">pipe the results and then map them to </span>return the <kbd class="calibre13">workout</kbd> unless it is not found, in which case we route the user back to the <kbd class="calibre13">Workouts</kbd> screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing the Workout and Exercise components</h1>
                
            
            <article>
                
<p class="calibre3">Once we have fixed the <kbd class="calibre13">WorkoutBuilderService</kbd> and the <kbd class="calibre13">WorkoutResolver</kbd>, there are actually no further fixes needed in the <kbd class="calibre13">WorkoutComponent</kbd>. All the work to handle the Observables has been done further downstream and all we need to do at this stage is subscribe to the route data <span class="calibre6">and retrieve the workout</span> <span class="calibre6">as we have already been doing:</span></p>
<pre class="calibre19">  ngOnInit() {<br class="title-page-name"/>      this.sub = this.route.data<br class="title-page-name"/>          .subscribe(<br class="title-page-name"/>            (data: { workout: WorkoutPlan }) =&gt; {<br class="title-page-name"/>              this.workout = data.workout;<br class="title-page-name"/>            }<br class="title-page-name"/>          );<br class="title-page-name"/>  }</pre>
<p class="calibre3">To test the implementation, uncomment the following highlighted code contained in the <kbd class="calibre13">onSelect</kbd> method within <kbd class="calibre13">workouts.component.ts</kbd>:</p>
<pre class="calibre19">  onSelect(workout: WorkoutPlan) {<br class="title-page-name"/>      <strong class="calibre1">this.router.navigate( ['./builder/workout', workout.name] );</strong><br class="title-page-name"/>  }</pre>
<p class="calibre3">Then click on any existing workout, such as <em class="calibre17">7 Minute Workout</em>, from the list of workouts displayed at <kbd class="calibre13">/builder/workouts/</kbd>. The workout data should load successfully.</p>
<p class="calibre3">The <kbd class="calibre13">ExerciseBuilderService</kbd><span class="calibre6"> and </span><kbd class="calibre13">ExerciseResolver</kbd> also need fixing. <kbd class="calibre13">Checkpoint 5.2</kbd> contains those fixes. You can copy those files or do it yourself and compare the implementation. And don't forget to uncomment the code in the <kbd class="calibre13">onSelect</kbd> method in <kbd class="calibre13">exercises.component.ts</kbd>.</p>
<div class="packt_infobox">
<p class="calibre20"><kbd class="calibre24">Checkpoint 5.2</kbd> in the GitHub repository contains the working implementation for what we have covered thus far. If you are not using Git, download the snapshot of Checkpoint 5.2 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/tree/checkpoint5.2" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint5.2</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>
<p class="calibre3">It is now time to fix, create, and update scenarios for the exercises and workouts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Performing CRUD on exercises/workouts</h1>
                
            
            <article>
                
<p class="calibre3">When it comes to create, read, update, and delete (CRUD) operations, all save, update, and delete methods need to be converted to the Observable pattern.</p>
<p class="calibre3">Earlier in the chapter, we detailed the endpoint access pattern for CRUD operations in a MongoLab collection. Head back to the <em class="calibre17">Loading exercise and workout data</em> section and revisit the access patterns. We need this now as we plan to create/update workouts.</p>
<p class="calibre3">Before we start the implementation, it is important to understand how MongoLab identifies a collection item and what our ID generation strategy is. Each collection item in MongoDB is uniquely identified in the collection using the <kbd class="calibre13">_id</kbd> property. While creating a new item, either we supply an ID or the server generates one itself. Once <kbd class="calibre13">_id</kbd> is set, it cannot be changed. For our model, we will use the <kbd class="calibre13">name</kbd> property of the exercise/workout as the unique ID and copy the name into the <kbd class="calibre13">_id</kbd> field (hence, there is no autogeneration of <kbd class="calibre13">_id</kbd>). Also remember that our model classes do not contain this <kbd class="calibre13">_id</kbd> field; it has to be created before saving the record for the first time.</p>
<p class="calibre3">Let's fix the workout creation scenario first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a new workout</h1>
                
            
            <article>
                
<p class="calibre3">Taking the bottom-up approach, the first thing that needs to be fixed is <kbd class="calibre13">WorkoutService</kbd>. Update the <kbd class="calibre13">addWorkout</kbd> method as shown in the following code:</p>
<pre class="calibre19">    addWorkout(workout: WorkoutPlan) {<br class="title-page-name"/>      const workoutExercises: any = [];<br class="title-page-name"/>      workout.exercises.forEach(<br class="title-page-name"/>          (exercisePlan: any) =&gt; {<br class="title-page-name"/>              workoutExercises.push({name: exercisePlan.exercise.name, duration: exercisePlan.duration});<br class="title-page-name"/>          }<br class="title-page-name"/>      );<br class="title-page-name"/><br class="title-page-name"/>      const body = {<br class="title-page-name"/>          '_id': workout.name,<br class="title-page-name"/>          'exercises': workoutExercises,<br class="title-page-name"/>          'name': workout.name,<br class="title-page-name"/>          'title': workout.title,<br class="title-page-name"/>          'description': workout.description,<br class="title-page-name"/>          'restBetweenExercise': workout.restBetweenExercise<br class="title-page-name"/>      };<br class="title-page-name"/><br class="title-page-name"/>      return this.http.post(this.collectionsUrl + '/workouts' + this.params, body)<br class="title-page-name"/>        .pipe(<br class="title-page-name"/>          catchError(this.handleError&lt;WorkoutPlan&gt;())<br class="title-page-name"/>        );<br class="title-page-name"/>    }</pre>
<p class="calibre3">In <kbd class="calibre13">getWorkout</kbd>, we had to map data from the server model to our client model; the reverse has to be done here. First, we create a new array for the exercises, <kbd class="calibre13">workoutExercises</kbd>, and then add to that array a version of the exercises that is more compact for server storage. We only want to store the exercise name and duration in the exercises array on the server (this array is of type <kbd class="calibre13">any</kbd> because in its compact format it does not conform to the <kbd class="calibre13">ExercisePlan</kbd> type).</p>
<p class="calibre3">Next, we set up the body of our post by mapping these changes into a JSON object. Note that as part of constructing this object, we set the <kbd class="calibre13">_id</kbd> property as the name of the workout to uniquely identify it in the database of the workouts collection.</p>
<div class="packt_infobox">
<p class="calibre20">The simplistic approach of using the <em class="calibre25">name</em> of the workout/exercise as a record identifier (or <kbd class="calibre24">id</kbd>) in MongoDB will break for any decent-sized app. Remember that we are creating a web-based application that can be accessed simultaneously by many users. Since there is always the possibility of two users coming up with the same name for a workout/exercise, we need a strong mechanism to make sure that names are not duplicated. Another problem with the MongoLab REST API is that if there is a duplicate <kbd class="calibre24">POST</kbd> request with the same <kbd class="calibre24">id</kbd> field, one will create a new document and the second will update it, instead of the second failing. This implies that any duplicate checks on the <kbd class="calibre24">id</kbd> field on the client side still cannot safeguard against data loss. In such a scenario, assigning auto generation of the <kbd class="calibre24">id</kbd> value is preferable. In standard cases where we are creating entities, unique ID generation is done on the server (mostly by the database). The response to when an entity is created then contains the generated ID. In such a case, we need to update the model object before we return data to the calling code.</p>
</div>
<p class="calibre3">Lastly, we call the <kbd class="calibre13">post</kbd> method of the <kbd class="calibre13">HTTPClient</kbd> module, passing the URL to connect to, an extra query string parameter (<kbd class="calibre13">apiKey</kbd>), and the data we are sending.</p>
<p class="calibre3">The last return statement should look familiar, as we use Observables to return the workout object as part of the Observable resolution. You need to be sure you add <kbd class="calibre13">.subscribe</kbd> to the Observable chain in order to make it work. We'll do that shortly by adding a subscription to the <kbd class="calibre13">save</kbd> method to <kbd class="calibre13">WorkoutComponent</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Updating a workout</h1>
                
            
            <article>
                
<p class="calibre3">Why not try to implement the update operation? The <kbd class="calibre13">updateWorkout</kbd> method can be fixed in the same manner, the only difference being that the <kbd class="calibre13">HTTPClient</kbd> module's <kbd class="calibre13">put</kbd> method is required:</p>
<pre class="calibre19">    updateWorkout(workout: WorkoutPlan) {<br class="title-page-name"/>      const workoutExercises: any = [];<br class="title-page-name"/>      workout.exercises.forEach(<br class="title-page-name"/>          (exercisePlan: any) =&gt; {<br class="title-page-name"/>              workoutExercises.push({name: exercisePlan.exercise.name, duration: exercisePlan.duration});<br class="title-page-name"/>          }<br class="title-page-name"/>      );<br class="title-page-name"/><br class="title-page-name"/>      const body = {<br class="title-page-name"/>          '_id': workout.name,<br class="title-page-name"/>          'exercises': workoutExercises,<br class="title-page-name"/>          'name': workout.name,<br class="title-page-name"/>          'title': workout.title,<br class="title-page-name"/>          'description': workout.description,<br class="title-page-name"/>          'restBetweenExercise': workout.restBetweenExercise<br class="title-page-name"/>      };<br class="title-page-name"/><br class="title-page-name"/>      return this.http.put(this.collectionsUrl + '/workouts/' + workout.name + this.params, body)<br class="title-page-name"/>        .pipe(<br class="title-page-name"/>          catchError(this.handleError&lt;WorkoutPlan&gt;())<br class="title-page-name"/>        );<br class="title-page-name"/>    }</pre>
<p class="calibre3">The preceding request URL now contains an extra fragment (<kbd class="calibre13">workout.name</kbd>) that denotes the identifier of the collection item that needs to be updated.</p>
<p class="calibre3">The MongoLab <kbd class="calibre13">PUT</kbd> API request creates the document passed in as the request body if the document is not found in the collection. While making the <kbd class="calibre13">PUT</kbd> request, make sure that the original record exists. We can do this by making a <kbd class="calibre13">GET</kbd> request for the same document first and confirming that we get a document before we update it. We'll leave that for you to implement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deleting a workout</h1>
                
            
            <article>
                
<p class="calibre3">The last operation that needs to be fixed is deleting the workout. Here is a simple implementation where we call the <kbd class="calibre13">HTTPClient</kbd> module's <kbd class="calibre13">delete</kbd> method to delete the workout referenced by a specific URL:</p>
<pre class="calibre19">    deleteWorkout(workoutName: string) {<br class="title-page-name"/>        return this.http.delete(this.collectionsUrl + '/workouts/' + workoutName + this.params)<br class="title-page-name"/>          .pipe(<br class="title-page-name"/>            catchError(this.handleError&lt;WorkoutPlan&gt;())<br class="title-page-name"/>          );<br class="title-page-name"/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing the upstream code</h1>
                
            
            <article>
                
<p class="calibre3">With that, it's now time to fix the <kbd class="calibre13">WorkoutBuilderService</kbd> and <kbd class="calibre13">Workout</kbd> components. The <kbd class="calibre13">save</kbd> method of <kbd class="calibre13">WorkoutBuilderService</kbd> now looks as follows:</p>
<pre class="calibre19">    save() {<br class="title-page-name"/>      const workout = this.newWorkout ?<br class="title-page-name"/>          this.workoutService.addWorkout(this.buildingWorkout) :<br class="title-page-name"/>          this.workoutService.updateWorkout(this.buildingWorkout);<br class="title-page-name"/>      this.newWorkout = false;<br class="title-page-name"/>      return workout;<br class="title-page-name"/>   }</pre>
<p class="calibre3">Most of it looks the same as it was earlier because it is the same! We did not have to update this code because we effectively isolated the interaction with the external server in our <kbd class="calibre13">WorkoutService</kbd> component.</p>
<p class="calibre3">Finally, the save code for the <kbd class="calibre13">Workout</kbd> component is shown here:</p>
<pre class="calibre19">  save(formWorkout: any) {<br class="title-page-name"/>    this.submitted = true;<br class="title-page-name"/>    if (!formWorkout.valid) { return; }<br class="title-page-name"/>    this.workoutBuilderService.save().subscribe(<br class="title-page-name"/>      success =&gt; this.router.navigate(['/builder/workouts']),<br class="title-page-name"/>      err =&gt; console.error(err)<br class="title-page-name"/>    );<br class="title-page-name"/>  }</pre>
<p class="calibre3">Here we have made a change so that we now subscribe to the save. As you may recall from our previous discussions, <kbd class="calibre13">subscribe</kbd> makes an Observable live so that we can complete the save.</p>
<p class="calibre3">And that's it! We can now create new workouts and update existing workouts (we'll leave completion of deleting workouts to you). That was not too difficult!</p>
<p class="calibre3">Let's try it out. Open the new <kbd class="calibre13">Workout Builder</kbd> page, create a workout, and save it. Also try to edit an existing workout. Both scenarios should work seamlessly.</p>
<div class="packt_infobox">
<p class="calibre20">Check out <kbd class="calibre24">checkpoint 5.3</kbd> for an up-to-date implementation if you are having issues running your local copy. If you are not using Git, download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular2byexample/tree/checkpoint5.3" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint5.3</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>
<p class="calibre3">Something interesting happens on the network side while we make <kbd class="calibre13">POST</kbd> or <kbd class="calibre13">PUT</kbd> requests save data. Open the browser's network log console (<em class="calibre17"><span class="calibre6">F12</span></em>) and see the requests being made. The log looks something like the following:</p>
<div class="packt_figure"><img class="image-border14" src="../images/00057.gif"/></div>
<div class="packt_figref">The network log</div>
<p class="calibre3">An <kbd class="calibre13">OPTIONS</kbd> request is made to the same endpoint before the actual <kbd class="calibre13">POST</kbd><span class="calibre6"> or</span><span class="calibre6"> </span><kbd class="calibre13">PUT</kbd> is done. The behavior that we witness here is termed as a <strong class="calibre5">prefight request</strong>. This happens because we are making a cross-domain request to <kbd class="calibre13">api.mongolab.com</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using promises for HTTP requests</h1>
                
            
            <article>
                
<p class="calibre3">The bulk of this chapter has focused on how the Angular <kbd class="calibre13">HTTPClient</kbd> uses Observables as the default for <kbd class="calibre13">XMLHttpRequests</kbd>. This represents a significant change from the way things used to work. Many developers are familiar with using promises for asynchronous HTTP requests. With that being the case, Angular continues to support promises, but just not as the default choice. A developer has to opt for promises in an <kbd class="calibre13">XMLHttpRequest</kbd> in order to be able to use them.</p>
<p class="calibre3">For example, if we want to use promises with the <kbd class="calibre13">getExercises</kbd> method in <kbd class="calibre13">WorkoutService</kbd>, we will have to restructure the command as follows:</p>
<pre class="calibre19">    getExercises(): Promise&lt;Exercise[]&gt; {<br class="title-page-name"/>        return this.http.get&lt;Exercise[]&gt;(this.collectionsUrl + '/exercises' + this.params)<br class="title-page-name"/>        .toPromise()<br class="title-page-name"/>        .then(res =&gt; res)<br class="title-page-name"/>        .catch(err =&gt; {<br class="title-page-name"/>            return Promise.reject(this.handleError('getExercises', []));<br class="title-page-name"/>        });<br class="title-page-name"/>    }</pre>
<p class="calibre3">In order to convert this method to use promises, all we have to do is add <kbd class="calibre13">.toPromise()</kbd> to the method chain, a success parameter, <kbd class="calibre13">then</kbd>, for the promise, and  <kbd class="calibre13">catch</kbd> with a <kbd class="calibre13">Promise.reject</kbd> pointing to the existing <kbd class="calibre13">handleError</kbd> method.</p>
<p class="calibre3">For upstream components, we just have to switch to handling the return value as a promise rather than an Observable. So, to use promises in this case, we would have to change the code in <kbd class="calibre13">Exercises.component.ts</kbd> and <kbd class="calibre13">LeftNavExercises.component.ts</kbd> to first add a new property for the error message (we'll leave it to you as to how the error message is displayed on the screen):</p>
<pre class="calibre19">errorMessage: any;</pre>
<p class="calibre3">Then change the <kbd class="calibre13">ngOnInit</kbd> method that is calling <kbd class="calibre13">WorkoutService</kbd> to the following:</p>
<pre class="calibre19">  ngOnInit() {<br class="title-page-name"/>    this.workoutService.getExercises()<br class="title-page-name"/><strong class="calibre1">    .then(exerciseList =&gt; this.exerciseList = exerciseList,</strong><br class="title-page-name"/><strong class="calibre1">      error =&gt; this.errorMessage = &lt;any&gt;error</strong><br class="title-page-name"/>    );<br class="title-page-name"/>  }  </pre>
<p class="calibre3">Of course, the ease with which we can substitute promises for Observables in this simple example does not indicate that they are essentially the same. A <kbd class="calibre13">then</kbd> promise returns another promise, which means that you can create successively chained promises. In the case of an Observable, a subscription is essentially the end of the line and cannot be mapped or subscribed to beyond that point.</p>
<p class="calibre3">If you're familiar with promises, it may be tempting at this stage to stick with them and not give Observables a try. After all, much of what we have done with Observables in this chapter can be done with promises as well. For example, the mapping of two streams of Observables that we did with <kbd class="calibre13">getWorkouts</kbd> using the Observable's <kbd class="calibre13">forkJoin</kbd> operator can also be done with the promise's <kbd class="calibre13">q,all</kbd> function.</p>
<p class="calibre3">However, you would be selling yourself short if you took that approach. Observables open up an exciting new way of doing web development using what is called functional reactive programming. They involve a fundamental shift in thinking that treats an application's data as a constant stream of information to which the application reacts and responds. This shift allows applications to be built with a different architecture that makes them faster and more resilient. Observables are at the core of Angular in such things as event emitters and the new version of <kbd class="calibre13">NgModel</kbd>.</p>
<p class="calibre3">While promises are a useful tool to have in your toolkit, we encourage you to investigate Observables as you get into developing with Angular. They are part of the forward-looking philosophy of Angular and will be useful in future-proofing both your applications and your skill set.</p>
<div class="packt_infobox">
<p class="calibre20">Check out the <kbd class="calibre24">checkpoint 5.3</kbd> file for an up-to-date implementation that includes the promises-related code that we covered previously. If you are not using Git, download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/tree/checkpoint5.3" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint5.3</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time. Be aware that in the next section, we will be reverting to the use of Observables for this code. This code can be found in the <kbd class="calibre24">checkpoint 5.4</kbd> file.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The async pipe</h1>
                
            
            <article>
                
<p class="calibre3">As we have seen with many of the data operations covered in this chapter, there is a fairly common pattern being repeated over and over again. When an Observable is returned from an HTTP request, we convert the response to JSON and subscribe to it. The subscription then binds the Observable output to a UI element. Wouldn't it be nice if we could eliminate this repetitive coding and replace it with a simpler way to accomplish what we are wanting to do?</p>
<p class="calibre3">Not surprisingly, Angular provides us with just the right way to do that. It's called the <strong class="calibre5">async pipe</strong>, and it can be used like any other pipe for binding to an element on the screen. However, the async pipe is a much more powerful mechanism than other pipes. It takes an Observable or a promise as an input and subscribes to it automatically. It also handles the teardown of the subscription for an Observable without necessitating any further lines of code.</p>
<p class="calibre3">Let's look at an example of this in our application. Let's go back to the <kbd class="calibre13">LeftNavExercises</kbd> component that we were just looking at in the previous section in connection with promises. Note that we have converted this component and the <kbd class="calibre13">Exercises</kbd> component from promises back to using Observables.</p>
<div class="packt_infobox">
<p class="calibre20">Check out the <kbd class="calibre24">checkpoint 5.4</kbd> file for an up-to-date implementation that includes the conversion of this code to use Observables once again. If you are not using Git, download the snapshot of Checkpoint 5.4 (a ZIP file) from the following GitHub location: <a href="https://github.com/chandermani/angular6byexample/tree/checkpoint5.4" target="_blank" class="calibre21">https://github.com/chandermani/angular6byexample/tree/checkpoint5.4</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
</div>
<p class="calibre3">Then make the following changes in <kbd class="calibre13">LeftNavExercises</kbd>. First, import Observable from RxJs:</p>
<pre class="calibre19">import { Observable } from 'rxjs/Observable';</pre>
<p class="calibre3">Then change <kbd class="calibre13">exerciseList</kbd> from an array of exercises to an Observable of the same type:</p>
<pre class="calibre19">public exerciseList:Observable&lt;Exercise[]&gt;;</pre>
<p class="calibre3">Next modify the call to <kbd class="calibre13">WorkoutService</kbd> that gets the exercises to eliminate the subscription:</p>
<pre class="calibre19">this.exerciseList = this.workoutService.getExercises();</pre>
<p class="calibre3">Finally, open <kbd class="calibre13">left-nav-exercises.component.html</kbd> and add the <kbd class="calibre13">async</kbd> pipe to the <kbd class="calibre13">*ngFor</kbd> loop, as follows:</p>
<pre class="calibre19">&lt;div *ngFor="let exercise of exerciseList|async|orderBy:'title'"&gt;</pre>
<p class="calibre3">Refresh the page and you will still see the Exercise list displaying. But this time, we have used the <kbd class="calibre13">async</kbd> pipe to eliminate the need to set up the subscription to the Observable. Pretty cool! This is a nice convenience that Angular has added, and since we have been spending time in this chapter understanding how Observables work with subscriptions, we have a clear idea of what the <kbd class="calibre13">async</kbd> pipe is now handling for us under the hood.</p>
<p class="calibre3">We'll leave it to you to implement the same change in the <kbd class="calibre13">Exercises</kbd> component.</p>
<p class="calibre3">It is important to understand the cross-domain behavior of the HTTP request and the constructs that Angular provides to make cross-domain requests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cross-domain access and Angular</h1>
                
            
            <article>
                
<p class="calibre3">Cross-domain requests are requests made for resources in a different domain. Such requests, when originated from JavaScript, have some restrictions imposed by the browser; these are called <em class="calibre17">same-origin policy</em> restrictions. Such a restriction stops the browser from making AJAX requests to domains that are different from the script's original source. The source match is done strictly based on a combination of protocol, host, and port.</p>
<p class="calibre3">For our own app, the calls to <kbd class="calibre13">https://api.mongolab.com</kbd> are cross-domain invocations as our source code hosting is in a different domain (most probably, something like <kbd class="calibre13">http://localhost/....</kbd>).</p>
<p class="calibre3">There are some workarounds and some standards that help relax/control cross-domain access. We will be exploring two of these techniques as they are the most commonly used ones. They are as follows:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">JSON with Padding</strong> (<strong class="calibre1">JSONP</strong>)</li>
<li class="calibre12"><strong class="calibre1">Cross-Origin Resource Sharing</strong> (<strong class="calibre1">CORS</strong>)</li>
</ul>
<p class="calibre3">A common way to circumvent this same-origin policy is to use the JSONP technique.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using JSONP to make cross-domain requests</h1>
                
            
            <article>
                
<p class="calibre3">The JSONP mechanism of remote invocation relies on the fact that browsers can execute JavaScript files from any domain irrespective of the source of origin as long as the script is included via the <kbd class="calibre13">&lt;script&gt;</kbd> tag.</p>
<p class="calibre3">In JSONP, instead of making a direct request to a server, a dynamic <kbd class="calibre13">&lt;script&gt;</kbd> tag is generated, with the <kbd class="calibre13">src</kbd> attribute set to the server endpoint that needs to be invoked. This <kbd class="calibre13">&lt;script&gt;</kbd> tag, when appended to the browser's DOM, causes a request to be made to the target server.</p>
<p class="calibre3">The server then needs to send a response in a specific format, wrapping the response content inside a function invocation code (this extra padding around the response data gives this technique the name JSONP).</p>
<p class="calibre3">The Angular JSONP service hides this complexity and provides an easy API to make JSONP requests. The StackBlitz link, <span class="calibre6"><a href="https://stackblitz.com/edit/angular-nxeuxo" target="_blank" class="calibre10">https://stackblitz.com/edit/angular-nxeuxo</a></span>, highlights how JSONP requests are made. It uses the <em class="calibre17">IEX Free Stock API</em> (<a href="https://iextrading.com/developer/" target="_blank" class="calibre10">https://iextrading.com/developer/</a>) to get quotes for any stock symbol.</p>
<div class="packt_infobox">
<p class="calibre20">The Angular JSONP service only supports HTTP <kbd class="calibre24">GET</kbd> requests. Using any other HTTP request, such as <kbd class="calibre24">POST</kbd> or <kbd class="calibre24">PUT</kbd>, will generate an error.</p>
</div>
<p class="calibre3">If you look at the StackBlitz project, you will see the familiar pattern for component creation that we have followed throughout this book. We will not go over this pattern again, but will highlight a few details that are relevant to using the Angular JSONP service.</p>
<p class="calibre3">First, along with the imports for <kbd class="calibre13">FormsModule</kbd> and <kbd class="calibre13">HttpClientModule</kbd>, you will need to import <kbd class="calibre13">HttpClientJsonpModule</kbd> into <kbd class="calibre13">app.module.ts</kbd> as follows:</p>
<pre class="calibre19">. . . 
import { HttpClientModule, <strong class="calibre1">HttpClientJsonpModule</strong> } from '@angular/common/http';<br class="title-page-name"/>import { FormsModule } from '@angular/forms';
. . . 
@NgModule({<br class="title-page-name"/>. . . 
  imports: [<br class="title-page-name"/>    BrowserModule,<br class="title-page-name"/>    FormsModule,<br class="title-page-name"/>    HttpClientModule,<br class="title-page-name"/><strong class="calibre1">    HttpClientJsonpModule</strong><br class="title-page-name"/>  ],
. . . 
}) </pre>
<p class="calibre3">Next, we need to add the following imports to <kbd class="calibre13">get-quote.component.ts</kbd>:</p>
<pre class="calibre19">import { Component }from '@angular/core';<br class="title-page-name"/>import { HttpClient } from '@angular/common/http';<br class="title-page-name"/>import { Observable } from 'rxjs/Observable';<br class="title-page-name"/>import { map } from 'rxjs/operators';</pre>
<p class="calibre3">We are importing <kbd class="calibre13">HttpClient</kbd>, which contains the <kbd class="calibre13"><span>JSONP</span></kbd> methods we will be using, as well as the RxJS <kbd class="calibre13">Observable</kbd> and the <kbd class="calibre13">map </kbd> operator. These imports will look familiar to you from what we have been building in this chapter.</p>
<div class="packt_infobox">
<p class="calibre20">As you work with Angular JSONP, it is important to understand that by default, it returns Observables using RxJS. This means that we will have to follow the pattern for subscribing to those Observables and use the RxJS operators to manipulate the results. We can also use the async pipe to streamline these operations.</p>
</div>
<p class="calibre3">Then we inject <kbd class="calibre13">HttpClient</kbd> into the constructor:</p>
<pre class="calibre19">constructor(public http: HttpClient) {}</pre>
<p class="calibre3">Next we add several variables that we will be using in our JSONP call:</p>
<pre class="calibre19">   symbol: string;<br class="title-page-name"/>   quote: Observable&lt;string&gt;;<br class="title-page-name"/>   url: string = 'https://api.iextrading.com/1.0/stock/';</pre>
<p class="calibre3">The <kbd class="calibre13">symbol</kbd> variable will hold the search string provided by the user. The <kbd class="calibre13">quote</kbd> variable will be used in our template to display the returned value from the JSONP call. And the <kbd class="calibre13">url</kbd> variable is the base URL for the call we will be making to the service.</p>
<p class="calibre3">Now we have everything in place for our <kbd class="calibre13">getQuote</kbd> method. Let's take a look at it:</p>
<pre class="calibre19">   getQuote (){ <br class="title-page-name"/>      let searchUrl = `${this.url}${this.symbol}/quote`;<br class="title-page-name"/>      this.quote = this.http.jsonp(searchUrl, 'callback')<br class="title-page-name"/>          .pipe(<br class="title-page-name"/>          map( (res: string) =&gt; res)<br class="title-page-name"/>        ); <br class="title-page-name"/>    }; </pre>
<p class="calibre3">We first construct our <kbd class="calibre13">searchUrl</kbd> by concatenating the <kbd class="calibre13">url</kbd> with the <kbd class="calibre13">symbol</kbd> and adding <kbd class="calibre13">/quote</kbd>. The last part <kbd class="calibre13">quote</kbd> is what we need to pass to the quote service to return a stock quote.</p>
<p class="calibre3">We then use the HTTPClient's <kbd class="calibre13">jsonp</kbd> method to execute the remote call to the quote service. We pass the <kbd class="calibre13">searchUrl</kbd> as the first parameter of that method and a string <kbd class="calibre13">'callback'</kbd> as our second parameter. The latter parameter is used by Angular to augment the <kbd class="calibre13">searchUrl</kbd> with an extra query string parameter, <kbd class="calibre13">callback</kbd>. Internally, the Angular JSONP service then generates a dynamic <kbd class="calibre13">script</kbd> tag and a callback function and makes the remote request.</p>
<p class="calibre3">Open StackBlitz and enter symbols such as <kbd class="calibre13">GOOG</kbd>, <kbd class="calibre13">MSFT</kbd>, or <kbd class="calibre13">FB</kbd> to see the stock quote service in action. The browser network log for requests looks as follows:</p>
<pre class="calibre19">https://api.iextrading.com/1.0/stock/MSFT/quote?callback=ng_jsonp_callback_0</pre>
<p class="calibre3">Here, <kbd class="calibre13">ng_jsonp_callback_0</kbd> is the dynamically generated function. And the response looks as follows:</p>
<pre class="calibre19">typeof ng_jsonp_callback_0 === 'function' &amp;&amp; ng_jsonp_callback_0({"quote"::{"symbol":"MSFT"..});</pre>
<p class="calibre3">The response is wrapped in the callback function. Angular parses and evaluates this <span class="calibre6">response, which results in the invocation of the</span> <kbd class="calibre13">__ng_jsonp__.__req1</kbd> callback function. Then, this function internally routes the data to our function callback.</p>
<p class="calibre3">We hope this explains how JSONP works and what the underlying mechanism of a JSONP request is. However, JSONP has its limitations:</p>
<ul class="calibre11">
<li class="calibre12">First, we can make only <kbd class="calibre13">GET</kbd> requests (which is obvious as these requests originate due to script tags)</li>
<li class="calibre12">Second, the server also needs to implement the part of the solution that involves wrapping the response in a function callback</li>
<li class="calibre12">Third, there is always a security risk involved, as JSONP depends on dynamic script generation and injection</li>
<li class="calibre12">Fourth, error handling is not reliable too because it is not easy to determine why a script load failed</li>
</ul>
<p class="calibre3">Ultimately, we must recognize that JSONP is more of a workaround than a solution. As we move towards Web 2.0, where mashups become commonplace and more and more service providers decide to expose their API over the web, a far better solution/standard has emerged: CORS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cross-origin resource sharing</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Cross-origin Resource Sharing</strong> (<strong class="calibre5">CORS</strong>) provides a mechanism for the web server to support cross-site access control, allowing browsers to make cross-domain requests from scripts. With this standard, a consumer application (such as <em class="calibre17">Personal Trainer</em>) is allowed to make some types of requests, termed <strong class="calibre5">simple requests</strong>, without any special setup requirements. These simple requests are limited to <kbd class="calibre13">GET</kbd>, <kbd class="calibre13">POST</kbd> (with specific MIME types), and <kbd class="calibre13">HEAD</kbd>. All other types of requests are termed <strong class="calibre5">complex requests</strong>.</p>
<p class="calibre3">For complex requests, CORS mandates that the request should be preceded by an HTTP <kbd class="calibre13">OPTIONS</kbd> request (also called a preflight request) that queries the server for HTTP methods allowed for cross-domain requests. And only on successful probing is the actual request made.</p>
<div class="packt_infobox">
<p class="calibre20">You can learn more about CORS from the MDN documentation available at <span class="calibre22"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" class="calibre21">https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS</a></span>.</p>
</div>
<p class="calibre3">The best part about CORS is that the client does not have to make any adjustment as in the case of JSONP. The complete handshake mechanism is transparent to the calling code and our Angular <kbd class="calibre13">HTTPClient</kbd> calls work without a hitch.</p>
<p class="calibre3">CORS requires configurations to be made on the server, and the MongoLab servers have already been configured to allow cross-domain requests. So the preceding <kbd class="calibre13">POST</kbd> and <kbd class="calibre13">PUT</kbd> requests that we made to the MongoLab to add and update <kbd class="calibre13">Exercise</kbd> and <kbd class="calibre13">Workout</kbd> documents all caused the preflight <kbd class="calibre13">OPTIONS</kbd> request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling workouts not found</h1>
                
            
            <article>
                
<p class="calibre3">You might recall that in <a href="part0180.html#5BL580-7edc9b1e1ea341adae33006323903887" class="calibre10">Chapter 4</a>, <em class="calibre17">Personal Trainer</em>, we created the <kbd class="calibre13">WorkoutResolver</kbd> to not only retrieve a workout prior to navigation to the <kbd class="calibre13">WorkoutComponent</kbd>, but also prevent navigation to that component if a non-existent workout was in the route parameters. Now we would like to augment this functionality by displaying an error message on the workouts screen, indicating that the workout was not found.</p>
<p class="calibre3">In order to do this, we are going to modify <kbd class="calibre13">WorkoutResolver</kbd> so that it reroutes to the workouts screen if a workout is not found. To start, add the following child route to <kbd class="calibre13">WorkoutBuilderRoutingModule</kbd> (making sure it precedes the existing workouts route):</p>
<pre class="calibre19">children: [ 
  {path: '', pathMatch: 'full', redirectTo: 'workouts'}, 
<strong class="calibre1">  {path: 'workouts/workout-not-found', component: WorkoutsComponent'},</strong> 
  {path: 'workouts', component: 'WorkoutsComponent'}, 
   *** other child routes *** 
  }, 
]</pre>
<p class="calibre3">Next, modify the <kbd class="calibre13">resolve</kbd> method in the <kbd class="calibre13">WorkoutResolver</kbd> to redirect to this route in the event that a workout is not found:</p>
<pre class="calibre19">resolve(<br class="title-page-name"/>    route: ActivatedRouteSnapshot,<br class="title-page-name"/>    state: RouterStateSnapshot): Observable&lt;WorkoutPlan&gt; {<br class="title-page-name"/>    const workoutName = route.paramMap.get('id');<br class="title-page-name"/><br class="title-page-name"/>    if (!workoutName) {<br class="title-page-name"/>        return this.workoutBuilderService.startBuildingNew();<br class="title-page-name"/>    } else {<br class="title-page-name"/>        this.isExistingWorkout = true;<br class="title-page-name"/>        return this.workoutBuilderService.startBuildingExisting(workoutName)<br class="title-page-name"/>        .pipe(<br class="title-page-name"/>          map(workout =&gt; {<br class="title-page-name"/>            if (workout) {<br class="title-page-name"/>              this.workoutBuilderService.buildingWorkout = workout;<br class="title-page-name"/>              return workout;<br class="title-page-name"/>            } else {<br class="title-page-name"/>              <strong class="calibre1">this.router.navigate(['/builder/workouts/workout-not-found']);</strong><br class="title-page-name"/>              return null;<br class="title-page-name"/>            }<br class="title-page-name"/>          }),<br class="title-page-name"/>          catchError(error =&gt; {<br class="title-page-name"/>            console.log('An error occurred!');<br class="title-page-name"/>            this.router.navigate(['/builder/workouts']);<br class="title-page-name"/>            return of(null);<br class="title-page-name"/>          })<br class="title-page-name"/>        );<br class="title-page-name"/>    }</pre>
<p class="calibre3">Then add a <kbd class="calibre13">notFound</kbd> boolean set to <kbd class="calibre13">false</kbd> to the variables in the <kbd class="calibre13">Workouts</kbd> component:</p>
<pre class="calibre19">  workoutList: Array&lt;WorkoutPlan&gt; = [];<br class="title-page-name"/>  <strong class="calibre1">public notFound = false;</strong></pre>
<p class="calibre3">And, in the <kbd class="calibre13">ngOnInit</kbd> method of that component, add the following code to check for the <kbd class="calibre13">workout-not-found</kbd> path and set the <kbd class="calibre13">notFound</kbd> value to <kbd class="calibre13">true</kbd>:</p>
<pre class="calibre19">ngOnInit() {
  <strong class="calibre1">if(this.route.snapshot.url[1] &amp;&amp; this.route.snapshot.url[1].path === 
  'workout-not-found') this.notFound = true;</strong> 
  this.subscription = this.workoutService.getWorkouts() 
  .subscribe( 
    workoutList =&gt; this.workoutList = workoutList, 
    (err:any) =&gt; console.error(err) 
  ); 
}</pre>
<p class="calibre3">Finally in the <kbd class="calibre13">Workouts.component.html</kbd> template, add the following <kbd class="calibre13">div</kbd> tag above the workout list that will display if the <kbd class="calibre13">notFound</kbd> is set to <kbd class="calibre13">true</kbd>:</p>
<pre class="calibre19">&lt;div *ngIf="notFound" class="not-found-msgbox"&gt;Could not load the specific workout!&lt;/div&gt;</pre>
<p class="calibre3">If we find <kbd class="calibre13">workout-not-found</kbd> in the path when a user is returned to the <kbd class="calibre13">Workouts</kbd> page, then this displays the following message on the screen:</p>
<div class="packt_figure"><img class="image-border15" src="../images/00058.jpeg"/></div>
<p class="calibre3">We have fixed routing failure for the Workout Builder page, but the exercise builder page is still pending. Again, we will leave it to you to fix it yourself.</p>
<p class="calibre3">Another major (and pending) implementation is fixing <em class="calibre17">7 Minute Workout</em>, as it currently caters to only one workout routine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fixing the 7 Minute Workout app</h1>
                
            
            <article>
                
<p class="calibre3">As it stands now, the <em class="calibre17">7 Minute Workout</em> (or <em class="calibre17">Workout Runner</em>) app can play only one specific workout. It needs to be fixed to support the execution of any workout plan built using <em class="calibre17">Personal Trainer</em>. There is an obvious need to integrate these two solutions. We already have the groundwork done to commence this integration. We've got the shared model services and <kbd class="calibre13">WorkoutService</kbd> to load data, enough to get us started.</p>
<p class="calibre3">Fixing <em class="calibre17">7 Minute Workout</em> and converting it into a generic <em class="calibre17">Workout Runner</em> roughly involves the following steps:</p>
<ul class="calibre11">
<li class="calibre12">Removing the hardcoded workout and exercises used in <em class="calibre2">7 Minute Workout</em>.</li>
<li class="calibre12">Fixing the start page to show all available workouts and allowing users to select a workout to run.</li>
<li class="calibre12">Fixing the workout route configuration to pass the selected workout name as the route parameter to the workout page.</li>
<li class="calibre12">Loading the selected workout data using <kbd class="calibre13">WorkoutService</kbd> and starting the workout.</li>
<li class="calibre12">And, of course, we need to rename the <em class="calibre2">7 Minute Workout</em> part of the app; the name is now a misnomer. I think the complete app can be called <em class="calibre2">Personal Trainer</em>. We can remove all references to <em class="calibre2">7 Minute Workout</em> from the view as well.</li>
</ul>
<p class="calibre3">An excellent exercise to try out yourself! And that is why we are not going to walk you through the solution. Instead, go ahead and implement the solution. Compare your implementation with the one available at <kbd class="calibre13">checkpoint 5.4</kbd>.</p>
<p class="calibre3">It's time to end the chapter and summarize your learning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">We now have an app that can do a lot of stuff. It can run workouts, load workouts, save and update them, and track history. And if we look back, we have achieved this with minimal code. We bet that if we were to try this in standard jQuery or some other framework, it would require substantially more effort as compared to Angular.</p>
<p class="calibre3">We started the chapter by providing a <em class="calibre17">MongoDB</em> database on <em class="calibre17">MongoLab</em> servers. Since MongoLab provided a RESTful API to access the database, we saved some time by not setting up our own server infrastructure.</p>
<p class="calibre3">The first Angular construct that we touched upon was the <kbd class="calibre13">HTTPClient</kbd>, which is the primary service for connecting to any HTTP backend.</p>
<p class="calibre3">You also learned how the <kbd class="calibre13">HTTPClient</kbd> module uses Observables. For the first time, in this chapter, we created our own Observable and explained how to create subscriptions to those Observables.</p>
<p class="calibre3">We fixed our <em class="calibre17">Personal Trainer</em> app so that it uses the <kbd class="calibre13">HTTPClient</kbd> module to load and save workout data (note that data persistence for exercises is left for you to complete). In the process, you also learned about issues surrounding cross-domain resource access. You learned about JSONP, a workaround to circumvent a browser's <em class="calibre17">same-origin</em> restrictions, and how to issue JSONP requests using Angular. We also touched upon CORS, which has emerged as a standard when it comes to cross-domain communication.</p>
<p class="calibre3">We have now covered most of the building blocks of Angular, except the big one: Angular directives. We have used directives everywhere, but have not created one. The next chapter is exclusively dedicated to Angular directives. We will be creating a number of small directives, such as a remote validator, AJAX button, and a validation cues directive for the <em class="calibre17">Workout Builder</em> app.</p>


            </article>

            
        </section>
    </body></html>