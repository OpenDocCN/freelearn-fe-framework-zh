<html><head></head><body>
<div id="_idContainer102" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-191"><a id="_idTextAnchor192" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-192" class="calibre5"><a id="_idTextAnchor193" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Aggregating and Visualizing Statistics Using MongoDB and Victory</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In this chapter, we are going to learn how to collect, aggregate, and visualize statistics for our blog application using MongoDB and Victory. </span><span class="kobospan" id="kobo.3.2">We start out by learning how we can collect events from users viewing blog posts. </span><span class="kobospan" id="kobo.3.3">Then, we randomly generate some events to have a dataset to work with. </span><span class="kobospan" id="kobo.3.4">We use this dataset to learn how to aggregate data with MongoDB and generate summary statistics, such as the number of views per post, or the average session duration on a post. </span><span class="kobospan" id="kobo.3.5">This kind of information will help authors know how well their posts are doing. </span><span class="kobospan" id="kobo.3.6">Finally, we create some graphs to visualize these aggregated statistics using the </span><span><span class="kobospan" id="kobo.4.1">Victory library.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Collecting and </span><span><span class="kobospan" id="kobo.8.1">simulating events</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Aggregating data </span><span><span class="kobospan" id="kobo.10.1">with MongoDB</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Implementing data aggregation in </span><span><span class="kobospan" id="kobo.12.1">the backend</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Integrating and visualizing data on the frontend </span><span><span class="kobospan" id="kobo.14.1">using Victory</span></span></li>
</ul>
<h1 id="_idParaDest-193" class="calibre5"><a id="_idTextAnchor194" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.17.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.18.1">, </span><em class="italic"><span class="kobospan" id="kobo.19.1">Preparing for Full-Stack Development</span></em><span class="kobospan" id="kobo.20.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.21.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.22.1">, </span><em class="italic"><span class="kobospan" id="kobo.23.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.24.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.25.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.26.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.26.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.27.1">Chapters 1 </span></em><span><span class="kobospan" id="kobo.28.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.29.1"> 2.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.30.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.31.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.32.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch10</span></span></a><span><span class="kobospan" id="kobo.33.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.35.1">.git</span></strong><span class="kobospan" id="kobo.36.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">npm install</span></strong><span class="kobospan" id="kobo.38.1">. </span><span class="kobospan" id="kobo.38.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.39.1">git init</span></strong><span class="kobospan" id="kobo.40.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.41.1">chapter folder.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.43.1">at: </span></span><a href="https://youtu.be/DmSq2P_IQQs" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.44.1">https://youtu.be/DmSq2P_IQQs</span></span></a><span><span class="kobospan" id="kobo.45.1">.</span></span></p>
<h1 id="_idParaDest-194" class="calibre5"><a id="_idTextAnchor195" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1">Collecting and simulating events</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">Before we can get started aggregating and visualizing statistics, we first need to collect (and later simulate) events, which we are going to use to create the statistics. </span><span class="kobospan" id="kobo.47.2">We will start by thinking about which data we want to collect, and which data would be useful for us. </span><span class="kobospan" id="kobo.47.3">We will focus on post views for now, so we would like to show the following statistics </span><span><span class="kobospan" id="kobo.48.1">per post:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.49.1">Total number of views on </span><span><span class="kobospan" id="kobo.50.1">a post</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.51.1">Daily views on </span><span><span class="kobospan" id="kobo.52.1">a post</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.53.1">Daily average viewing duration on </span><span><span class="kobospan" id="kobo.54.1">a post</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.55.1">Let’s start by creating the database model for events that will allow us to show </span><span><span class="kobospan" id="kobo.56.1">these statistics.</span></span></p>
<h2 id="_idParaDest-195" class="calibre7"><a id="_idTextAnchor196" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.57.1">Creating the event model</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.58.1">To create these</span><a id="_idIndexMarker613" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.59.1"> statistics, we need to collect events from users. </span><span class="kobospan" id="kobo.59.2">Events will contain a reference to a post, a session ID to track events from the same viewing, an action (started viewing, ended viewing), and a date of when the </span><span><span class="kobospan" id="kobo.60.1">event happened.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">Let’s get started defining the database model </span><span><span class="kobospan" id="kobo.62.1">for events:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.63.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.64.1">ch9</span></strong><span class="kobospan" id="kobo.65.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.66.1">ch10</span></strong><span class="kobospan" id="kobo.67.1"> folder, </span><span><span class="kobospan" id="kobo.68.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.69.1">$ cp -R ch9 ch10</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.70.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.71.1">ch10</span></strong><span class="kobospan" id="kobo.72.1"> folder in </span><span><span class="kobospan" id="kobo.73.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.74.1">Create </span><a id="_idIndexMarker614" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.75.1">a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.76.1">backend/src/db/models/event.js</span></strong><span class="kobospan" id="kobo.77.1"> file. </span><span class="kobospan" id="kobo.77.2">Inside this file, define a schema that contains a reference to </span><span><span class="kobospan" id="kobo.78.1">a post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.79.1">
import mongoose, { Schema } from 'mongoose'
const eventsSchema = new Schema(
  {
    post: { type: Schema.Types.ObjectId, ref: 'post', required: true },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.80.1">Then define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.81.1">session</span></strong><span class="kobospan" id="kobo.82.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.83.1">action</span></strong><span class="kobospan" id="kobo.84.1">, </span><span><span class="kobospan" id="kobo.85.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.86.1">date</span></strong></span><span><span class="kobospan" id="kobo.87.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.88.1">
    session: { type: String, required: true },
    action: { type: String, required: true },
    date: { type: Date, required: true },
  },
  { timestamps: true },
)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.89.1">Finally, export </span><span><span class="kobospan" id="kobo.90.1">the</span></span><span><a id="_idIndexMarker615" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.91.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.92.1">
export const Event = mongoose.model('events', eventsSchema)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.93.1">Now that we have defined the database model, let’s continue by defining a service function and route to </span><span><span class="kobospan" id="kobo.94.1">track events.</span></span></p>
<h2 id="_idParaDest-196" class="calibre7"><a id="_idTextAnchor197" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.95.1">Defining a service function and route to track events</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.96.1">Now that we </span><a id="_idIndexMarker616" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.97.1">have successfully defined our database model for </span><a id="_idIndexMarker617" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.98.1">events, let’s create a service function and route to track new events, </span><span><span class="kobospan" id="kobo.99.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.100.1">To generate</span><a id="_idIndexMarker618" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1"> session IDs, we are going to </span><a id="_idIndexMarker619" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.102.1">use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.103.1">uuid</span></strong><span class="kobospan" id="kobo.104.1"> library, which</span><a id="_idIndexMarker620" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.105.1"> generates </span><strong class="bold"><span class="kobospan" id="kobo.106.1">universally unique identifiers (UUIDs)</span></strong><span class="kobospan" id="kobo.107.1"> for us. </span><span class="kobospan" id="kobo.107.2">Install it by running the </span><span><span class="kobospan" id="kobo.108.1">following commands:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.109.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.110.1">$ npm install uuid@9.0.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.111.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.112.1">backend/src/services/events.js</span></strong><span class="kobospan" id="kobo.113.1"> file. </span><span class="kobospan" id="kobo.113.2">Inside it, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.114.1">v4</span></strong><span class="kobospan" id="kobo.115.1"> function from </span><strong class="source-inline1"><span class="kobospan" id="kobo.116.1">uuid</span></strong><span class="kobospan" id="kobo.117.1"> and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.118.1">Event</span></strong><span class="kobospan" id="kobo.119.1"> model and define a function to create a new event document, </span><span><span class="kobospan" id="kobo.120.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.121.1">
import { v4 as uuidv4 } from 'uuid'
import { Event } from '../db/models/event.js'
export async function trackEvent({
  postId,
  action,
  session = uuidv4(),
  date = Date.now(),
}) {
  const event = new Event({ post: postId, action, session, date })
  return await event.save()
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.122.1">In the arguments to the function, we set the default session ID to a randomly generated UUID and the date to the </span><span><span class="kobospan" id="kobo.123.1">current date.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.124.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.125.1">backend/src/routes/events.js</span></strong><span class="kobospan" id="kobo.126.1"> file. </span><span class="kobospan" id="kobo.126.2">Inside it, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.127.1">trackEvent</span></strong><span class="kobospan" id="kobo.128.1"> function and the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.129.1">getPostById</span></strong></span><span><span class="kobospan" id="kobo.130.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.131.1">
import { trackEvent } from '../services/events.js'
import { getPostById } from '../services/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.132.1">Define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.133.1">POST /api/v1/events</span></strong><span class="kobospan" id="kobo.134.1"> route, in which we get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.135.1">postId</span></strong><span class="kobospan" id="kobo.136.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.137.1">session</span></strong><span class="kobospan" id="kobo.138.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.139.1">action</span></strong><span class="kobospan" id="kobo.140.1"> from </span><span><span class="kobospan" id="kobo.141.1">the body:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.142.1">
export function eventRoutes(app) {
  app.post('/api/v1/events', async (req, res) =&gt; {
    try {
      const { postId, session, action } = req.body</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.143.1">Then, we check</span><a id="_idIndexMarker621" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.144.1"> whether a post with the given ID</span><a id="_idIndexMarker622" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.145.1"> exists in the database. </span><span class="kobospan" id="kobo.145.2">If not, we return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.146.1">400 Bad Request</span></strong> <span><span class="kobospan" id="kobo.147.1">status code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.148.1">
      const post = await getPostById(postId)
      if (post === null) return res.status(400).end()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.149.1">If the post exists, we get the session ID and use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.150.1">trackEvent</span></strong><span class="kobospan" id="kobo.151.1"> function to create a </span><span><span class="kobospan" id="kobo.152.1">new event:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.153.1">
      const event = await trackEvent({ postId, session, action })
      return res.json({ session: event.session })
    } catch (err) {
      console.error('error tracking action', err)
      return res.status(500).end()
    }
  })
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.154.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.155.1">backend/src/app.js</span></strong><span class="kobospan" id="kobo.156.1"> and </span><span><span class="kobospan" id="kobo.157.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.158.1">eventRoutes</span></strong></span><span><span class="kobospan" id="kobo.159.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.160.1">
import { eventRoutes } from './routes/events.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.161.1">Then mount the routes to </span><span><span class="kobospan" id="kobo.162.1">the app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.163.1">
postRoutes(app)
userRoutes(app)
</span><strong class="bold1"><span class="kobospan1" id="kobo.164.1">eventRoutes(app)</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.165.1">Start the </span><a id="_idIndexMarker623" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.166.1">backend as follows (and keep it running</span><a id="_idIndexMarker624" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.167.1"> for </span><span><span class="kobospan" id="kobo.168.1">future development):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.169.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.170.1">$ npm run dev</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.171.1">Now that we have successfully defined a backend route to track events, let’s implement event collection on </span><span><span class="kobospan" id="kobo.172.1">the frontend.</span></span></p>
<h2 id="_idParaDest-197" class="calibre7"><a id="_idTextAnchor198" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.173.1">Collecting events on the frontend</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">After defining the </span><a id="_idIndexMarker625" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.175.1">route, let’s create the API function for the frontend and define a way to track when a user started and ended viewing a post. </span><span class="kobospan" id="kobo.175.2">Follow these steps to collect events on </span><span><span class="kobospan" id="kobo.176.1">the frontend:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.177.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.178.1">src/api/events.js</span></strong><span class="kobospan" id="kobo.179.1"> file and define a </span><strong class="source-inline1"><span class="kobospan" id="kobo.180.1">postTrackEvent</span></strong><span class="kobospan" id="kobo.181.1"> function, which takes an event object and sends it to the previously </span><span><span class="kobospan" id="kobo.182.1">defined route:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.183.1">
export const postTrackEvent = (event) =&gt;
  fetch(`${import.meta.env.VITE_BACKEND_URL}/events`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(event),
  }).then((res) =&gt; res.json())</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.184.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.185.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.186.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.187.1">useEffect</span></strong><span class="kobospan" id="kobo.188.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">useState</span></strong><span class="kobospan" id="kobo.190.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.191.1">useMutation</span></strong></span><span><span class="kobospan" id="kobo.192.1"> hooks:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.193.1">import { useEffect, useState } from 'react'</span></strong><span class="kobospan1" id="kobo.194.1">
import { useQuery</span><strong class="bold1"><span class="kobospan1" id="kobo.195.1">, useMutation</span></strong><span class="kobospan1" id="kobo.196.1"> } from '@tanstack/react-query'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.197.1">Additionally, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.198.1">postTrackEvent</span></strong> <span><span class="kobospan" id="kobo.199.1">API function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.200.1">
import { postTrackEvent } from '../api/events.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.201.1">Now, inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.202.1">ViewPost</span></strong><span class="kobospan" id="kobo.203.1"> function, define a new state hook to store the session ID, and a mutation to track the events. </span><span class="kobospan" id="kobo.203.2">When an event is successfully tracked, we get a session ID from the backend. </span><span class="kobospan" id="kobo.203.3">We store this in the </span><span><span class="kobospan" id="kobo.204.1">state hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.205.1">
  const [session, setSession] = useState()
  const trackEventMutation = useMutation({
    mutationFn: (action) =&gt; postTrackEvent({ postId, action, session }),
    onSuccess: (data) =&gt; setSession(data?.session),
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.206.1">Then, define a</span><a id="_idIndexMarker626" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.207.1"> new effect hook in which we track a </span><strong class="source-inline1"><span class="kobospan" id="kobo.208.1">startView</span></strong><span class="kobospan" id="kobo.209.1"> event a second after the user opened the post (to prevent tracking accidental events, such as from quick refreshes), and an </span><strong class="source-inline1"><span class="kobospan" id="kobo.210.1">endView</span></strong><span class="kobospan" id="kobo.211.1"> event when the effect hook unmounts. </span><span class="kobospan" id="kobo.211.2">We give it no dependencies to ensure the effect hook is only triggered when the page mounts </span><span><span class="kobospan" id="kobo.212.1">and unmounts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.213.1">
  useEffect(() =&gt; {
    let timeout = setTimeout(() =&gt; {
      trackEventMutation.mutate('startView')
      timeout = null
    }, 1000)
    return () =&gt; {
      if (timeout) clearTimeout(timeout)
      else trackEventMutation.mutate('endView')
    }
  }, [])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.214.1">Start the </span><a id="_idIndexMarker627" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.215.1">frontend as follows (and keep it running for </span><span><span class="kobospan" id="kobo.216.1">future development):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.217.1">$ npm run dev</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.218.1">Make sure to run this command in the root of the </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">ch10</span></strong><span class="kobospan" id="kobo.220.1"> folder, not inside the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">backend</span></strong></span><span><span class="kobospan" id="kobo.222.1"> folder.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.223.1">If you now open a post in your browser and take a look at the </span><strong class="bold"><span class="kobospan" id="kobo.224.1">Network</span></strong><span class="kobospan" id="kobo.225.1"> tab of the inspector, you will see that after a second, the </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">startView</span></strong><span class="kobospan" id="kobo.227.1"> event is tracked. </span><span class="kobospan" id="kobo.227.2">When we navigate away from the page, the </span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">endView</span></strong><span class="kobospan" id="kobo.229.1"> event </span><span><span class="kobospan" id="kobo.230.1">is tracked.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.231.1">Let’s now move on to simulating events so that we have more data to aggregate and </span><span><span class="kobospan" id="kobo.232.1">visualize later.</span></span></p>
<h2 id="_idParaDest-198" class="calibre7"><a id="_idTextAnchor199" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.233.1">Simulating events</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.234.1">Simulating </span><a id="_idIndexMarker628" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.235.1">events is a great way to generate sample data to be used for testing the aggregations and visualizations. </span><span class="kobospan" id="kobo.235.2">In our simulation, we first clear all current users from the database and then create a set of sample users. </span><span class="kobospan" id="kobo.235.3">We repeat the same process for posts, and then for events, simulating that a random user creates a post and that someone views a random post for a random amount </span><span><span class="kobospan" id="kobo.236.1">of time.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.237.1">Follow these steps to implement </span><span><span class="kobospan" id="kobo.238.1">a simulation:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.239.1">First of all, we should change the database to avoid losing any data we previously created in the other chapters. </span><span class="kobospan" id="kobo.239.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.240.1">backend/.env</span></strong><span class="kobospan" id="kobo.241.1"> and change the following line from </span><strong class="source-inline1"><span class="kobospan" id="kobo.242.1">blog</span></strong> <span><span class="kobospan" id="kobo.243.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.244.1">blog-simulated</span></strong></span><span><span class="kobospan" id="kobo.245.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.246.1">
DATABASE_URL=mongodb://localhost:27017/</span><strong class="bold1"><span class="kobospan1" id="kobo.247.1">blog-simulated</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.248.1">Now, create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.249.1">backend/simulateEvents.js</span></strong><span class="kobospan" id="kobo.250.1"> file, in which we import </span><strong class="source-inline1"><span class="kobospan" id="kobo.251.1">dotenv</span></strong><span class="kobospan" id="kobo.252.1">, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.253.1">initDatabase</span></strong><span class="kobospan" id="kobo.254.1"> function, and all the relevant models and </span><span><span class="kobospan" id="kobo.255.1">service </span></span><span><a id="_idIndexMarker629" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.256.1">functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.257.1">
import dotenv from 'dotenv'
dotenv.config()
import { initDatabase } from './src/db/init.js'
import { Post } from './src/db/models/post.js'
import { User } from './src/db/models/user.js'
import { Event } from './src/db/models/event.js'
import { createUser } from './src/services/users.js'
import { createPost } from './src/services/posts.js'
import { trackEvent } from './src/services/events.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.258.1">Define a start time for the simulation, which here is set to 30 days ago (30 days * 24 hours * 60 minutes * 60 seconds * 1000 milliseconds), and an end time, which </span><span><span class="kobospan" id="kobo.259.1">is now:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.260.1">
const simulationStart = Date.now() - 1000 * 60 * 60 * 24 * 30
const simulationEnd = Date.now()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.261.1">We also define the number of users, posts, and views </span><span><span class="kobospan" id="kobo.262.1">to simulate:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.263.1">
const simulatedUsers = 5
const simulatedPosts = 10
const simulatedViews = 10000</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.264.1">Then, define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">simulateEvents</span></strong><span class="kobospan" id="kobo.266.1"> function, in which we first initialize </span><span><span class="kobospan" id="kobo.267.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.268.1">
async function simulateEvents() {
  const connection = await initDatabase()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.269.1">Next, </span><em class="italic"><span class="kobospan" id="kobo.270.1">delete</span></em><span class="kobospan" id="kobo.271.1"> all existing users and create new users by initializing an empty array with the number</span><a id="_idIndexMarker630" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.272.1"> of users to be simulated and mapping </span><span><span class="kobospan" id="kobo.273.1">over it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.274.1">
  await User.deleteMany({})
  const createdUsers = await Promise.all(
    Array(simulatedUsers)
      .fill(null)
      .map(
        async (_, u) =&gt;
          await createUser({
            username: `user-${u}`,
            password: `password-${u}`,
          }),
      ),
  )
  console.log(`created ${createdUsers.length} users`)</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.275.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.276.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.277.1">Array(X)</span></strong><span class="kobospan" id="kobo.278.1"> function can be used to create an array with </span><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">X</span></strong><span class="kobospan" id="kobo.280.1"> entries, which then needs to be filled with an initial value before it can be </span><span><span class="kobospan" id="kobo.281.1">iterated over.</span></span></p>
<ol class="calibre15">
<li value="7" class="calibre11"><span class="kobospan" id="kobo.282.1">Now, repeat the same process </span><span><span class="kobospan" id="kobo.283.1">for posts:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.284.1">
  await Post.deleteMany({})
  const createdPosts = await Promise.all(
    Array(simulatedPosts)
      .fill(null)
      .map(async (_, p) =&gt; {
        const randomUser =
          createdUsers[Math.floor(Math.random() * simulatedUsers)]
        return await createPost(randomUser._id, {
          title: `Test Post ${p}`,
          contents: `This is a test post ${p}`,
        })
      }),
  )
  console.log(`created ${createdPosts.length} posts`)</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.285.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.286.1">We use </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">Math.floor(Math.random() * maxNumber)</span></strong><span class="kobospan" id="kobo.288.1"> to create a random integer between </span><strong class="source-inline1"><span class="kobospan" id="kobo.289.1">0</span></strong><span class="kobospan" id="kobo.290.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.291.1">maxNumber</span></strong><span class="kobospan" id="kobo.292.1"> (non-inclusive), which is perfect to be used for indexing </span><span><span class="kobospan" id="kobo.293.1">an array.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.294.1">Lastly, we</span><a id="_idIndexMarker631" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.295.1"> repeat the same </span><span><span class="kobospan" id="kobo.296.1">for events:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.297.1">
  await Event.deleteMany({})
  const createdViews = await Promise.all(
    Array(simulatedViews)
      .fill(null)
      .map(async () =&gt; {
        const randomPost =
          createdPosts[Math.floor(Math.random() * simulatedPosts)]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.298.1">Here, we start the session at a random time within the defined </span><span><span class="kobospan" id="kobo.299.1">simulation dates:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.300.1">
        const sessionStart =
          simulationStart + Math.random() * (simulationEnd - simulationStart)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.301.1">And we end it randomly after 0 to </span><span><span class="kobospan" id="kobo.302.1">5 minutes:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.303.1">
        const sessionEnd =
          sessionStart + 1000 * Math.floor(Math.random() * 60 * 5)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.304.1">Now, we</span><a id="_idIndexMarker632" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.305.1"> simulate the event collection, first by creating a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.306.1">startView</span></strong></span><span><span class="kobospan" id="kobo.307.1"> event:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.308.1">
        const event = await trackEvent({
          postId: randomPost._id,
          action: 'startView',
          date: new Date(sessionStart),
        })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.309.1">And then we simulate an </span><strong class="source-inline1"><span class="kobospan" id="kobo.310.1">endView</span></strong><span class="kobospan" id="kobo.311.1"> event, where we use the session ID returned from the </span><span><span class="kobospan" id="kobo.312.1">first event:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.313.1">
        await trackEvent({
          postId: randomPost._id,
          session: event.session,
          action: 'endView',
          date: new Date(sessionEnd),
        })
      }),
  )
  console.log(`successfully simulated ${createdViews.length} views`)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.314.1">Lastly, we disconnect from the database and call </span><span><span class="kobospan" id="kobo.315.1">the function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.316.1">
  await connection.disconnect()
}
simulateEvents()</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.317.1">Our simulation</span><a id="_idIndexMarker633" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.318.1"> is now ready to be used! </span><span class="kobospan" id="kobo.318.2">Execute the following command to </span><span><span class="kobospan" id="kobo.319.1">start it:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.320.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.321.1">$ node simulateEvents.js</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">You will see that the simulation first creates 5 users, then 10 posts, and finally simulates </span><span><span class="kobospan" id="kobo.323.1">10,000 views.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.324.1">In the next section, we are going to use this dataset to try out some aggregations </span><span><span class="kobospan" id="kobo.325.1">with MongoDB!</span></span></p>
<h1 id="_idParaDest-199" class="calibre5"><a id="_idTextAnchor200" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.326.1">Aggregating data with MongoDB</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.327.1">Sometimes, we do not just want to simply retrieve data from the database, but instead, we want to create some statistics from the data by combining and summarizing it. </span><span class="kobospan" id="kobo.327.2">This process is called </span><strong class="bold"><span class="kobospan" id="kobo.328.1">data aggregation</span></strong><span class="kobospan" id="kobo.329.1">, and it can help us understand more about the data. </span><span class="kobospan" id="kobo.329.2">For example, we can count the total number of views per post, get the number of daily views per post, or calculate the average session duration when viewing </span><span><span class="kobospan" id="kobo.330.1">a post.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.331.1">MongoDB </span><a id="_idIndexMarker634" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.332.1">supports a special aggregation syntax using the </span><strong class="source-inline"><span class="kobospan" id="kobo.333.1">.aggregate()</span></strong><span class="kobospan" id="kobo.334.1"> function on a collection. </span><span class="kobospan" id="kobo.334.2">Using this aggregation functionality from MongoDB allows us to efficiently query and process documents. </span><span class="kobospan" id="kobo.334.3">The </span><a id="_idIndexMarker635" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.335.1">operations it provides are similar to what can be done with </span><strong class="bold"><span class="kobospan" id="kobo.336.1">Structured Query Language</span></strong><span class="kobospan" id="kobo.337.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.338.1">SQL</span></strong><span class="kobospan" id="kobo.339.1">) queries. </span><span class="kobospan" id="kobo.339.2">Mainly, we are going to use the following </span><span><span class="kobospan" id="kobo.340.1">aggregation operations:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.341.1">$match</span></strong><span class="kobospan" id="kobo.342.1">: Used to </span><span><span class="kobospan" id="kobo.343.1">filter documents</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.344.1">$group</span></strong><span class="kobospan" id="kobo.345.1">: Used to group documents by a </span><span><span class="kobospan" id="kobo.346.1">certain property</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.347.1">$project</span></strong><span class="kobospan" id="kobo.348.1">: Used to map properties to different properties, or </span><span><span class="kobospan" id="kobo.349.1">process them</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">$sort</span></strong><span class="kobospan" id="kobo.351.1">: Used to </span><span><span class="kobospan" id="kobo.352.1">sort documents</span></span></li>
</ul>
<p class="callout-heading"><span class="kobospan" id="kobo.353.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.354.1">MongoDB provides many more advanced aggregation operations, all of which can be found in their documentation (</span><a href="https://www.mongodb.com/docs/manual/aggregation/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.355.1">https://www.mongodb.com/docs/manual/aggregation/</span></a><span class="kobospan" id="kobo.356.1">). </span><span class="kobospan" id="kobo.356.2">They are also constantly adding more operations to make aggregation even </span><span><span class="kobospan" id="kobo.357.1">more powerful.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.358.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">aggregate</span></strong><span class="kobospan" id="kobo.360.1"> function works by providing an array of objects, each of which defines a </span><strong class="bold"><span class="kobospan" id="kobo.361.1">stage</span></strong><span class="kobospan" id="kobo.362.1"> of the </span><strong class="bold"><span class="kobospan" id="kobo.363.1">aggregation pipeline</span></strong><span class="kobospan" id="kobo.364.1">. </span><span class="kobospan" id="kobo.364.2">We are going to learn more about aggregations in this chapter by using them </span><span><span class="kobospan" id="kobo.365.1">in practice.</span></span></p>
<h2 id="_idParaDest-200" class="calibre7"><a id="_idTextAnchor201" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.366.1">Getting the total number of views per post</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.367.1">The first aggregation that we</span><a id="_idIndexMarker636" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.368.1"> are going to define is a way to get the total number of views per post. </span><span class="kobospan" id="kobo.368.2">For such an aggregation, we are going to need </span><strong class="source-inline"><span class="kobospan" id="kobo.369.1">$match</span></strong><span class="kobospan" id="kobo.370.1"> to filter all </span><strong class="source-inline"><span class="kobospan" id="kobo.371.1">startView</span></strong><span class="kobospan" id="kobo.372.1"> actions (otherwise we would be counting views twice, because there is also an </span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">endView</span></strong><span class="kobospan" id="kobo.374.1"> action for each blog post view), and </span><strong class="source-inline"><span class="kobospan" id="kobo.375.1">$group</span></strong><span class="kobospan" id="kobo.376.1"> to group the results by post ID and then return the number of documents </span><span><span class="kobospan" id="kobo.377.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">$count</span></strong></span><span><span class="kobospan" id="kobo.379.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.380.1">Follow these steps to create your first </span><span><span class="kobospan" id="kobo.381.1">aggregation pipeline:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.382.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.383.1">backend/playground/</span></strong><span class="kobospan" id="kobo.384.1"> folder for our </span><span><span class="kobospan" id="kobo.385.1">playground scripts.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.386.1">Click on the MongoDB extension (the leaf icon) in the VS </span><span><span class="kobospan" id="kobo.387.1">Code sidebar.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.388.1">Connect to the database, then expand the </span><strong class="bold"><span class="kobospan" id="kobo.389.1">Playgrounds</span></strong><span class="kobospan" id="kobo.390.1"> section (if it is not expanded already), and click on the </span><strong class="bold"><span class="kobospan" id="kobo.391.1">Create New </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.392.1">Playground</span></strong></span><span><span class="kobospan" id="kobo.393.1"> button.</span></span><p class="calibre3"><span class="kobospan" id="kobo.394.1">A new file will open up with some code already predefined for us. </span><em class="italic"><span class="kobospan" id="kobo.395.1">Delete</span></em><span class="kobospan" id="kobo.396.1"> all predefined code, as we are going to </span><em class="italic"><span class="kobospan" id="kobo.397.1">replace</span></em><span class="kobospan" id="kobo.398.1"> it with </span><span><span class="kobospan" id="kobo.399.1">our own.</span></span></p></li>
<li class="calibre11"><span class="kobospan" id="kobo.400.1">First, define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.401.1">use</span></strong><span class="kobospan" id="kobo.402.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.403.1">db</span></strong><span class="kobospan" id="kobo.404.1"> globals, which the MongoDB Playground provides </span><span><span class="kobospan" id="kobo.405.1">for us:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.406.1">
/* global use, db */</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.407.1">Then, use the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.408.1">blog-simulated</span></strong></span><span><span class="kobospan" id="kobo.409.1"> database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.410.1">
use('blog-simulated')</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.411.1">Now, execute the following </span><span><span class="kobospan" id="kobo.412.1">aggregation function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.413.1">
db.getCollection('events').aggregate([</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.414.1">The first</span><a id="_idIndexMarker637" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.415.1"> stage of the pipeline will be matching all </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.416.1">startView</span></strong></span><span><span class="kobospan" id="kobo.417.1"> actions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.418.1">
  {
    $match: { action: 'startView' },
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.419.1">Then, we group by post. </span><span class="kobospan" id="kobo.419.2">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.420.1">$group</span></strong><span class="kobospan" id="kobo.421.1"> stage requires us to define an </span><strong class="source-inline1"><span class="kobospan" id="kobo.422.1">_id</span></strong><span class="kobospan" id="kobo.423.1">, which contains the property to be grouped by. </span><span class="kobospan" id="kobo.423.2">We need to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.424.1">$</span></strong><span class="kobospan" id="kobo.425.1"> operator to resolve the variable to be used, so </span><strong class="source-inline1"><span class="kobospan" id="kobo.426.1">$post</span></strong><span class="kobospan" id="kobo.427.1"> will access the </span><strong class="source-inline1"><span class="kobospan" id="kobo.428.1">event.post</span></strong><span class="kobospan" id="kobo.429.1"> property (which contains a </span><span><span class="kobospan" id="kobo.430.1">post ID):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.431.1">
  {
    $group: {
      _id: '$post',
      views: { $count: {} },
    },
  },
])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.432.1">Save the script as a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.433.1">backend/playground/views-per-post.mongodb.js</span></strong></span><span><span class="kobospan" id="kobo.434.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.435.1">Click on the </span><strong class="bold"><span class="kobospan" id="kobo.436.1">Play</span></strong><span class="kobospan" id="kobo.437.1"> icon at the top right to run the script. </span><span class="kobospan" id="kobo.437.2">A new tab will open with the results </span><a id="_idIndexMarker638" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.438.1">of </span><span><span class="kobospan" id="kobo.439.1">the aggregation:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer096">
<span class="kobospan" id="kobo.440.1"><img alt="Figure 10.1 – Our first MongoDB aggregation result!" src="image/B19385_10_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.441.1">Figure 10.1 – Our first MongoDB aggregation result!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.442.1">After creating and executing our first simple aggregation, let’s continue practicing by writing more </span><span><span class="kobospan" id="kobo.443.1">advanced aggregations.</span></span></p>
<h2 id="_idParaDest-201" class="calibre7"><a id="_idTextAnchor202" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.444.1">Getting the number of daily views per post</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.445.1">Now that we are already</span><a id="_idIndexMarker639" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.446.1"> familiar with the general process of writing MongoDB aggregations, let’s try writing a bit more complicated aggregation: getting the number of daily views per post. </span><span class="kobospan" id="kobo.446.2">Follow these steps to </span><span><span class="kobospan" id="kobo.447.1">create it:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.448.1">Create a new playground file, as before, with the following </span><span><span class="kobospan" id="kobo.449.1">aggregation function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.450.1">
/* global use, db */
use('blog-simulated')
db.getCollection('events').aggregate([</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.451.1">Again, we first match only the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.452.1">startView</span></strong></span><span><span class="kobospan" id="kobo.453.1"> actions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.454.1">
  {
    $match: { action: 'startView' },
  },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.455.1">Then we use </span><strong class="source-inline1"><span class="kobospan" id="kobo.456.1">$project</span></strong><span class="kobospan" id="kobo.457.1"> to keep the </span><strong class="source-inline1"><span class="kobospan" id="kobo.458.1">post</span></strong><span class="kobospan" id="kobo.459.1"> property, and define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.460.1">day</span></strong><span class="kobospan" id="kobo.461.1"> property, which uses the </span><strong class="source-inline1"><span class="kobospan" id="kobo.462.1">$dateTrunc</span></strong><span class="kobospan" id="kobo.463.1"> function to simplify the </span><strong class="source-inline1"><span class="kobospan" id="kobo.464.1">date</span></strong><span class="kobospan" id="kobo.465.1"> property to only cover days (instead of containing the </span><span><span class="kobospan" id="kobo.466.1">full timestamp):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.467.1">
  {
    $project: {
      post: '$post',
      day: { $dateTrunc: { date: '$date', unit: 'day' } },
    },
  },</span></pre><p class="calibre3"><span class="kobospan" id="kobo.468.1">An important thing to keep in mind with </span><strong class="source-inline"><span class="kobospan" id="kobo.469.1">$project</span></strong><span class="kobospan" id="kobo.470.1"> is that only properties that are listed here will be passed on to further stages in the pipeline, so we need to list all properties that we are still going to need </span><span><span class="kobospan" id="kobo.471.1">later here!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.472.1">Finally, we </span><a id="_idIndexMarker640" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.473.1">use </span><strong class="source-inline1"><span class="kobospan" id="kobo.474.1">$group</span></strong><span class="kobospan" id="kobo.475.1"> to group the documents by </span><strong class="source-inline1"><span class="kobospan" id="kobo.476.1">post</span></strong><span class="kobospan" id="kobo.477.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">day</span></strong><span class="kobospan" id="kobo.479.1"> by passing an object to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.480.1">_id</span></strong><span class="kobospan" id="kobo.481.1"> property. </span><span class="kobospan" id="kobo.481.2">We use </span><strong class="source-inline1"><span class="kobospan" id="kobo.482.1">$count</span></strong><span class="kobospan" id="kobo.483.1"> again to count the number of documents in </span><span><span class="kobospan" id="kobo.484.1">each group:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.485.1">
  {
    $group: {
      _id: { post: '$post', day: '$day' },
      views: { $count: {} },
    },
  },
])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.486.1">Save the script as a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.487.1">backend/playground/views-per-post-per-day.mongodb.js</span></strong></span><span><span class="kobospan" id="kobo.488.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.489.1">Run this script by clicking on the </span><strong class="bold"><span class="kobospan" id="kobo.490.1">Play</span></strong><span class="kobospan" id="kobo.491.1"> button and you will see that we are now getting a list of documents grouped by post and day, and the corresponding number of views of a certain post on a </span><span><span class="kobospan" id="kobo.492.1">certain day:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer097">
<span class="kobospan" id="kobo.493.1"><img alt="Figure 10.2 – Showing the number of views per post per day" src="image/B19385_10_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.494.1">Figure 10.2 – Showing the number of views per post per day</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">After getting the </span><a id="_idIndexMarker641" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.496.1">number of daily views per post, let’s continue practicing by calculating the average </span><span><span class="kobospan" id="kobo.497.1">session duration.</span></span></p>
<h2 id="_idParaDest-202" class="calibre7"><a id="_idTextAnchor203" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.498.1">Calculating the average session duration</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.499.1">As you may </span><a id="_idIndexMarker642" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.500.1">remember, we are first sending a </span><strong class="source-inline"><span class="kobospan" id="kobo.501.1">startView</span></strong><span class="kobospan" id="kobo.502.1"> action, and then later an </span><strong class="source-inline"><span class="kobospan" id="kobo.503.1">endView</span></strong><span class="kobospan" id="kobo.504.1"> action, both of which have a separate </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">date</span></strong><span class="kobospan" id="kobo.506.1">. </span><span class="kobospan" id="kobo.506.2">Let’s use aggregations to group these two actions together into a single document, and then compute the duration of </span><span><span class="kobospan" id="kobo.507.1">a session:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.508.1">Create a new playground file, and start writing an aggregation that first creates some new properties using </span><strong class="source-inline1"><span class="kobospan" id="kobo.509.1">$project</span></strong><span class="kobospan" id="kobo.510.1">, and keeps the </span><strong class="source-inline1"><span class="kobospan" id="kobo.511.1">session</span></strong><span class="kobospan" id="kobo.512.1"> property, as we will need </span><span><span class="kobospan" id="kobo.513.1">it later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.514.1">
/* global use, db */
use('blog-simulated')
db.getCollection('events').aggregate([
  {
    $project: {
      session: '$session',
      startDate: {
        $cond: [{ $eq: ['$action', 'startView'] }, '$date', undefined],
      },
      endDate: { $cond: [{ $eq: ['$action', 'endView'] }, '$date', undefined] },
    },
  },</span></pre><p class="calibre3"><span class="kobospan" id="kobo.515.1">Here, we are</span><a id="_idIndexMarker643" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.516.1"> using the </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">$cond</span></strong><span class="kobospan" id="kobo.518.1"> operator to create a conditional (kind of like a ternary/if statement). </span><span class="kobospan" id="kobo.518.2">It accepts an array with three elements: the first being a condition, the next a result if the condition matches, and lastly, a result if the condition does not match. </span><span class="kobospan" id="kobo.518.3">In our case, we check whether the </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">action</span></strong><span class="kobospan" id="kobo.520.1"> property is </span><strong class="source-inline"><span class="kobospan" id="kobo.521.1">startView</span></strong><span class="kobospan" id="kobo.522.1"> (using the </span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">$eq</span></strong><span class="kobospan" id="kobo.524.1"> operator). </span><span class="kobospan" id="kobo.524.2">If true, then we set the date to the </span><strong class="source-inline"><span class="kobospan" id="kobo.525.1">startDate</span></strong><span class="kobospan" id="kobo.526.1"> property. </span><span class="kobospan" id="kobo.526.2">Otherwise, we do not define the </span><strong class="source-inline"><span class="kobospan" id="kobo.527.1">startDate</span></strong><span class="kobospan" id="kobo.528.1"> property. </span><span class="kobospan" id="kobo.528.2">Similarly, if the action is </span><strong class="source-inline"><span class="kobospan" id="kobo.529.1">endView</span></strong><span class="kobospan" id="kobo.530.1">, we create an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">endDate</span></strong></span><span><span class="kobospan" id="kobo.532.1"> property.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.533.1">Now, we can group the documents by the session ID and select the lowest start date and the highest end date of </span><span><span class="kobospan" id="kobo.534.1">a session:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.535.1">
  {
    $group: {
      _id: '$session',
      startDate: { $min: '$startDate' },
      endDate: { $max: '$endDate' },
    },
  },</span></pre><p class="calibre3"><span class="kobospan" id="kobo.536.1">There should only be one </span><strong class="source-inline"><span class="kobospan" id="kobo.537.1">startView</span></strong><span class="kobospan" id="kobo.538.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">endView</span></strong><span class="kobospan" id="kobo.540.1"> action per session anyway, but we cannot guarantee this, so we need to aggregate them down into a </span><span><span class="kobospan" id="kobo.541.1">single value!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.542.1">Finally, we </span><a id="_idIndexMarker644" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.543.1">use </span><strong class="source-inline1"><span class="kobospan" id="kobo.544.1">$project</span></strong><span class="kobospan" id="kobo.545.1"> again to rename the </span><strong class="source-inline1"><span class="kobospan" id="kobo.546.1">_id</span></strong><span class="kobospan" id="kobo.547.1"> property to </span><strong class="source-inline1"><span class="kobospan" id="kobo.548.1">session</span></strong><span class="kobospan" id="kobo.549.1">, and calculate the </span><strong class="source-inline1"><span class="kobospan" id="kobo.550.1">duration</span></strong><span class="kobospan" id="kobo.551.1"> by subtracting the </span><strong class="source-inline1"><span class="kobospan" id="kobo.552.1">startDate</span></strong><span class="kobospan" id="kobo.553.1"> from </span><span><span class="kobospan" id="kobo.554.1">the </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.555.1">endDate</span></strong></span><span><span class="kobospan" id="kobo.556.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.557.1">
  {
    $project: {
      session: '$_id',
      duration: { $subtract: ['$endDate', '$startDate'] },
    },
  },
])</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.558.1">Save the script as a </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.559.1">backend/playground/session-duration.mongodb.js</span></strong></span><span><span class="kobospan" id="kobo.560.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.561.1">Run the script and</span><a id="_idIndexMarker645" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.562.1"> you will see a list of documents with a session ID and a corresponding duration </span><span><span class="kobospan" id="kobo.563.1">in milliseconds:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer098">
<span class="kobospan" id="kobo.564.1"><img alt="Figure 10.3 – Aggregation result of the session durations" src="image/B19385_10_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.565.1">Figure 10.3 – Aggregation result of the session durations</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.566.1">Now that we are more familiar with how data aggregation works in MongoDB, let’s implement similar aggregations in </span><span><span class="kobospan" id="kobo.567.1">our backend!</span></span></p>
<h1 id="_idParaDest-203" class="calibre5"><a id="_idTextAnchor204" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.568.1">Implementing data aggregation in the backend</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.569.1">For our backend, we are going to</span><a id="_idIndexMarker646" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.570.1"> use very similar aggregation pipelines. </span><span class="kobospan" id="kobo.570.2">However, we need to adjust them slightly, as we always want to get the data for a single post only. </span><span class="kobospan" id="kobo.570.3">As such, we will first be using </span><strong class="source-inline"><span class="kobospan" id="kobo.571.1">$match</span></strong><span class="kobospan" id="kobo.572.1"> to filter our documents. </span><span class="kobospan" id="kobo.572.2">This also ensures that the aggregation stays fast, even if we have millions of events in our database, because we are first filtering down to all events of a </span><span><span class="kobospan" id="kobo.573.1">single post!</span></span></p>
<h2 id="_idParaDest-204" class="calibre7"><a id="_idTextAnchor205" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.574.1">Defining aggregation service functions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.575.1">Follow these steps to </span><a id="_idIndexMarker647" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.576.1">implement the aggregation functions in </span><span><span class="kobospan" id="kobo.577.1">the backend:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.578.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.579.1">backend/src/services/events.js</span></strong><span class="kobospan" id="kobo.580.1"> and define a new function to get the total number of views for a post. </span><span class="kobospan" id="kobo.580.2">In this case, we can simplify our code by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.581.1">countDocuments</span></strong><span class="kobospan" id="kobo.582.1"> function instead of the </span><span><span class="kobospan" id="kobo.583.1">aggregate function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.584.1">
export async function getTotalViews(postId) {
  return {
    views: await Event.countDocuments({ post: postId, action: 'startView' }),
  }
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.585.1">Next, define a new function to get the daily views of a post with a given ID. </span><span class="kobospan" id="kobo.585.2">We now use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.586.1">$match</span></strong><span class="kobospan" id="kobo.587.1"> operation to only get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.588.1">startView</span></strong><span class="kobospan" id="kobo.589.1"> actions of a </span><span><span class="kobospan" id="kobo.590.1">certain post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.591.1">
export async function getDailyViews(postId) {
  return await Event.aggregate([
    {
      $match: {
        post: postId,
        action: 'startView',
      },
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.592.1">Then, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.593.1">$group</span></strong><span class="kobospan" id="kobo.594.1"> operation in combination with </span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">$dateTrunc</span></strong><span class="kobospan" id="kobo.596.1"> to get the views per day, just</span><a id="_idIndexMarker648" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.597.1"> like we did before in the MongoDB </span><span><span class="kobospan" id="kobo.598.1">Playground script:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.599.1">
    {
      $group: {
        _id: {
          $dateTrunc: { date: '$date', unit: 'day' },
        },
        views: { $count: {} },
      },
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.600.1">Lastly, we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.601.1">$sort</span></strong><span class="kobospan" id="kobo.602.1"> operation to sort the resulting documents by </span><strong class="source-inline1"><span class="kobospan" id="kobo.603.1">_id</span></strong><span class="kobospan" id="kobo.604.1"> (which contains</span><a id="_idIndexMarker649" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.605.1">the day):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.606.1">
    {
      $sort: { _id: 1 },
    },
  ])
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.607.1">For the last function, we use our session duration aggregation, but extend it a little bit to give the average duration per day. </span><span class="kobospan" id="kobo.607.2">Again, we first need to match a </span><span><span class="kobospan" id="kobo.608.1">post ID:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.609.1">
export async function getDailyDurations(postId) {
  return await Event.aggregate([
    {
      $match: {
        post: postId,
      },
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.610.1">Then, we use the same </span><strong class="source-inline1"><span class="kobospan" id="kobo.611.1">$project</span></strong><span class="kobospan" id="kobo.612.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.613.1">$group</span></strong><span class="kobospan" id="kobo.614.1"> operations to get the </span><strong class="source-inline1"><span class="kobospan" id="kobo.615.1">session</span></strong><span class="kobospan" id="kobo.616.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.617.1">startDate</span></strong><span class="kobospan" id="kobo.618.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.619.1">endDate</span></strong><span class="kobospan" id="kobo.620.1">, just like we </span><span><span class="kobospan" id="kobo.621.1">did before:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.622.1">
    {
      $project: {
        session: '$session',
        startDate: {
          $cond: [{ $eq: ['$action', 'startView'] }, '$date', undefined],
        },
        endDate: {
          $cond: [{ $eq: ['$action', 'endView'] }, '$date', undefined],
        },
      },
    },
    {
      $group: {
        _id: '$session',
        startDate: { $min: '$startDate' },
        endDate: { $max: '$endDate' },
      },
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.623.1">Now, we use </span><a id="_idIndexMarker650" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.624.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.625.1">$project</span></strong><span class="kobospan" id="kobo.626.1"> operation to get </span><strong class="source-inline1"><span class="kobospan" id="kobo.627.1">day</span></strong><span class="kobospan" id="kobo.628.1"> from our </span><strong class="source-inline1"><span class="kobospan" id="kobo.629.1">startDate</span></strong><span class="kobospan" id="kobo.630.1">, like we did in the previous aggregation where we got the number of daily views of </span><span><span class="kobospan" id="kobo.631.1">a post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.632.1">
    {
      $project: {
        day: { $dateTrunc: { date: '$startDate', unit: 'day' } },
        duration: { $subtract: ['$endDate', '$startDate'] },
      },
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.633.1">We group the results per day, and calculate the average duration of </span><span><span class="kobospan" id="kobo.634.1">a day:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.635.1">
    {
      $group: {
        _id: '$day',
        averageDuration: { $avg: '$duration' },
      },
    },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.636.1">Finally, we sort the results </span><span><span class="kobospan" id="kobo.637.1">per day:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.638.1">
    {
      $sort: { _id: 1 },
    },
  ])
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.639.1">As we can see, aggregation </span><a id="_idIndexMarker651" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.640.1">pipelines are extremely powerful and allow us to do a lot of data processing directly in the database! </span><span class="kobospan" id="kobo.640.2">In the next section, we are going to create routes for these </span><span><span class="kobospan" id="kobo.641.1">aggregation functions.</span></span></p>
<h2 id="_idParaDest-205" class="calibre7"><a id="_idTextAnchor206" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.642.1">Defining the routes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.643.1">Defining the routes is pretty</span><a id="_idIndexMarker652" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.644.1"> straightforward; we simply check whether a post with the given ID exists, and if it does, we return the results from the corresponding aggregation service function. </span><span class="kobospan" id="kobo.644.2">Let’s start defining </span><span><span class="kobospan" id="kobo.645.1">the routes:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.646.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.647.1">backend/src/routes/events.js</span></strong><span class="kobospan" id="kobo.648.1"> and</span><a id="_idIndexMarker653" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.649.1"> import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.650.1">getTotalViews</span></strong><span class="kobospan" id="kobo.651.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.652.1">getDailyViews</span></strong><span class="kobospan" id="kobo.653.1">, and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.654.1">getDailyDurations</span></strong></span><span><span class="kobospan" id="kobo.655.1"> functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.656.1">
import {
  trackEvent,
</span><strong class="bold1"><span class="kobospan1" id="kobo.657.1">  getTotalViews,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.658.1">  getDailyViews,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.659.1">  getDailyDurations,</span></strong><span class="kobospan1" id="kobo.660.1">
} from '../services/events.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.661.1">Next, inside the </span><strong class="source-inline1"><span class="kobospan" id="kobo.662.1">eventRoutes</span></strong><span class="kobospan" id="kobo.663.1"> function, define a new route for getting the total number of views of a post, </span><span><span class="kobospan" id="kobo.664.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.665.1">
  app.get('/api/v1/events/totalViews/:postId', async (req, res) =&gt; {
    try {
      const { postId } = req.params
      const post = await getPostById(postId)
      if (post === nul</span><a id="_idTextAnchor207" class="pcalibre1 calibre17 pcalibre"/><span class="kobospan1" id="kobo.666.1">l) return res.</span><a id="_idTextAnchor208" class="pcalibre1 calibre17 pcalibre"/><span class="kobospan1" id="kobo.667.1">status(400).end()
      const stats = await getTotalViews(post._id)
      return res.json(stats)
    } catch (err) {
      console.error('error getting stats', err)
      return res.status(500).end()
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.668.1">Then define a similar route for the number of daily views of </span><span><span class="kobospan" id="kobo.669.1">a post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.670.1">
  app.get('/api/v1/events/dailyViews/:postId', async (req, res) =&gt; {
    try {
      const { postId } = req.params
      const post = await getPostById(postId)
      if (post === null) return res.status(400).end()
      const stats = await getDailyViews(post._id)
      return res.json(stats)
    } catch (err) {
      console.error('error getting stats', err)
      return res.status(500).end()
    }
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.671.1">And finally, define a </span><a id="_idIndexMarker654" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.672.1">route for the daily average viewing duration of </span><span><span class="kobospan" id="kobo.673.1">a post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.674.1">
  app.get('/api/v1/events/dailyDurations/:postId', async (req, res) =&gt; {
    try {
      const { postId } = req.params
      const post = await getPostById(postId)
      if (post === null) return res.status(400).end()
      const stats = await getDailyDurations(post._id)
      return res.json(stats)
    } catch (err) {
      console.error('error getting stats', err)
      return res.status(500).end()
    }
  })</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.675.1">Now that we have successfully defined routes for our aggregation functions, it’s time to integrate them into the frontend and start visualizing the data we have been simulating </span><span><span class="kobospan" id="kobo.676.1">and collecting!</span></span></p>
<h1 id="_idParaDest-206" class="calibre5"><a id="_idTextAnchor209" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.677.1">Integrating and visualizing data on the frontend using Victory</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.678.1">In this final section, we are going to integrate the aggregation endpoints we previously defined. </span><span class="kobospan" id="kobo.678.2">Then, we are going to introduce the Victory library in the frontend to create graphs to visualize our </span><span><span class="kobospan" id="kobo.679.1">aggregated data!</span></span></p>
<h2 id="_idParaDest-207" class="calibre7"><a id="_idTextAnchor210" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.680.1">Integrating the aggregation API</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.681.1">First of all, we need to </span><a id="_idIndexMarker655" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.682.1">integrate the API routes in the frontend, </span><span><span class="kobospan" id="kobo.683.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.684.1">Edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.685.1">src/api/events.js</span></strong><span class="kobospan" id="kobo.686.1"> file and add three new API functions to get the total views, daily views, and daily durations of </span><span><span class="kobospan" id="kobo.687.1">a post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.688.1">
export const getTotalViews = (postId) =&gt;
  fetch(`${import.meta.env.VITE_BACKEND_URL}/events/totalViews/${postId}`).then(
    (res) =&gt; res.json(),
  )
export const getDailyViews = (postId) =&gt;
  fetch(`${import.meta.env.VITE_BACKEND_URL}/events/dailyViews/${postId}`).then(
    (res) =&gt; res.json(),
  )
export const getDailyDurations = (postId) =&gt;
  fetch(
    `${import.meta.env.VITE_BACKEND_URL}/events/dailyDurations/${postId}`,
  ).then((res) =&gt; res.json())</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.689.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.690.1">src/components/PostStats.jsx</span></strong><span class="kobospan" id="kobo.691.1"> file, in which we are going to query these new API routes. </span><span class="kobospan" id="kobo.691.2">Start by importing </span><strong class="source-inline1"><span class="kobospan" id="kobo.692.1">useQuery</span></strong><span class="kobospan" id="kobo.693.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.694.1">PropTypes</span></strong><span class="kobospan" id="kobo.695.1">, and </span><a id="_idIndexMarker656" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.696.1">the three </span><span><span class="kobospan" id="kobo.697.1">API functions:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.698.1">
import { useQuery } from '@tanstack/react-query'
import PropTypes from 'prop-types'
import {
  getTotalViews,
  getDailyViews,
  getDailyDurations,
} from '../api/events.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.699.1">Define a new component that takes a </span><strong class="source-inline1"><span class="kobospan" id="kobo.700.1">postId</span></strong><span class="kobospan" id="kobo.701.1"> and fetches all the stats that we aggregated on the backend using </span><span><span class="kobospan" id="kobo.702.1">query hooks:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.703.1">
export function PostStats({ postId }) {
  const totalViews = useQuery({
    queryKey: ['totalViews', postId],
    queryFn: () =&gt; getTotalViews(postId),
  })
  const dailyViews = useQuery({
    queryKey: ['dailyViews', postId],
    queryFn: () =&gt; getDailyViews(postId),
  })
  const dailyDurations = useQuery({
    queryKey: ['dailyDurations', postId],
    queryFn: () =&gt; getDailyDurations(postId),
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.704.1">While the stats are </span><a id="_idIndexMarker657" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.705.1">loading, we display a simple </span><span><span class="kobospan" id="kobo.706.1">loading message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.707.1">
  if (
    totalViews.isLoading ||
    dailyViews.isLoading ||
    dailyDurations.isLoading
  ) {
    return &lt;div&gt;loading stats...&lt;/div&gt;
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.708.1">Once the stats are finished loading, we can display them. </span><span class="kobospan" id="kobo.708.2">For now, we simply display the total number of views and the JSON responses from the other two </span><span><span class="kobospan" id="kobo.709.1">API requests:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.710.1">
  return (
    &lt;div&gt;
      &lt;b&gt;{totalViews.data?.views} total views&lt;/b&gt;
      &lt;pre&gt;{JSON.stringify(dailyViews.data)}&lt;/pre&gt;
      &lt;pre&gt;{JSON.stringify(dailyDurations.data)}&lt;/pre&gt;
    &lt;/div&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.711.1">We still need to define the prop types for this component, </span><span><span class="kobospan" id="kobo.712.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.713.1">
PostStats.propTypes = {
  postId: PropTypes.string.isRequired,
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.714.1">Now we can render the </span><strong class="source-inline1"><span class="kobospan" id="kobo.715.1">PostStats</span></strong><span class="kobospan" id="kobo.716.1"> component in our </span><strong class="source-inline1"><span class="kobospan" id="kobo.717.1">ViewPost</span></strong><span class="kobospan" id="kobo.718.1"> page component. </span><span class="kobospan" id="kobo.718.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.719.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.720.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.721.1">PostStats</span></strong> <span><span class="kobospan" id="kobo.722.1">component there:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.723.1">
import { PostStats } from '../components/PostStats.jsx'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.724.1">Then, at the </span><a id="_idIndexMarker658" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.725.1">bottom of the component, render the stats </span><span><span class="kobospan" id="kobo.726.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.727.1">
      {post ? </span><span class="kobospan1" id="kobo.727.2">(
</span><strong class="bold1"><span class="kobospan1" id="kobo.728.1">        &lt;div&gt;</span></strong><span class="kobospan1" id="kobo.729.1">
          &lt;Post {...post} fullPost /&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.730.1">          &lt;hr /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.731.1">          &lt;PostStats postId={postId} /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.732.1">        &lt;/div&gt;</span></strong><span class="kobospan1" id="kobo.733.1">
      ) : (
        `Post with id ${postId} not found.`
      )}
    &lt;/div&gt;
  )
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.734.1">If you open a post on the frontend now (you may need to refresh the frontend if you see an error), you will see that all the stats are properly fetched! </span><span class="kobospan" id="kobo.734.2">Now, all that’s left to do is visualize the daily stats </span><span><span class="kobospan" id="kobo.735.1">using Victory!</span></span></p>
<h2 id="_idParaDest-208" class="calibre7"><a id="_idTextAnchor211" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.736.1">Visualizing data using Victory</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.737.1">Victory is a </span><a id="_idIndexMarker659" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.738.1">React library that provides modular components that can be used to create charts and all kinds of data visualizations. </span><span class="kobospan" id="kobo.738.2">It even supports interactive visualization tools, such as brushing and grouping (where you, for example, select a certain section of a graph to more closely inspect it on other graphs). </span><span class="kobospan" id="kobo.738.3">In this chapter, we are only going to scratch the surface of what Victory can do, as data visualization in React is a big topic on </span><span><span class="kobospan" id="kobo.739.1">its own.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.740.1">You can find more information about Victory </span><a id="_idIndexMarker660" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.741.1">on their official </span><span><span class="kobospan" id="kobo.742.1">website: </span></span><a href="https://commerce.nearform.com/open-source/victory/" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.743.1">https://commerce.nearform.com/open-source/victory/</span></span></a></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.744.1">Creating a bar chart</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.745.1">Let’s get started </span><a id="_idIndexMarker661" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.746.1">visualizing </span><a id="_idIndexMarker662" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.747.1">our data using </span><span><span class="kobospan" id="kobo.748.1">Victory now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.749.1">Install the library by executing the following command in the root of </span><span><span class="kobospan" id="kobo.750.1">the project:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.751.1">$ npm install victory@36.9.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.752.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.753.1">src/components/PostStats.jsx</span></strong><span class="kobospan" id="kobo.754.1"> and import the following components </span><span><span class="kobospan" id="kobo.755.1">from Victory:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.756.1">
import {
  VictoryChart,
  VictoryTooltip,
  VictoryBar,
  VictoryLine,
  VictoryVoronoiContainer,
} from 'victory'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.757.1">Replace</span></em><span class="kobospan" id="kobo.758.1"> the </span><strong class="source-inline1"><span class="kobospan" id="kobo.759.1">&lt;pre&gt;</span></strong><span class="kobospan" id="kobo.760.1"> tags at the end of the component with the following charts, starting with the daily </span><a id="_idIndexMarker663" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.761.1">views chart:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.762.1">
  return (
    &lt;div&gt;
      &lt;b&gt;{totalViews.data?.views} total views&lt;/b&gt;
      </span><strong class="bold1"><span class="kobospan1" id="kobo.763.1">&lt;div style={{ width: 512 }}&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.764.1">        &lt;h3&gt;Daily Views&lt;/h3&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.765.1">        &lt;VictoryChart domainPadding={16}&gt;</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.766.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.767.1">VictoryChart</span></strong><span class="kobospan" id="kobo.768.1"> component is a wrapper, used to combine all elements of a Victory chart. </span><span class="kobospan" id="kobo.768.2">We set </span><strong class="source-inline"><span class="kobospan" id="kobo.769.1">domainPadding</span></strong><span class="kobospan" id="kobo.770.1"> to 16 pixels, which is a padding inside of the</span><a id="_idIndexMarker664" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.771.1"> graph. </span><span class="kobospan" id="kobo.771.2">It makes sure that the lines and bar charts do not stick to the edges of the graph, making it look </span><span><span class="kobospan" id="kobo.772.1">slightly better.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.773.1">Then, define a bar chart with </span><strong class="source-inline1"><span class="kobospan" id="kobo.774.1">VictoryBar</span></strong><span class="kobospan" id="kobo.775.1">, using </span><strong class="source-inline1"><span class="kobospan" id="kobo.776.1">VictoryTooltip</span></strong><span class="kobospan" id="kobo.777.1"> to display </span><span><span class="kobospan" id="kobo.778.1">the labels:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.779.1">
          &lt;VictoryBar
            labelComponent={&lt;VictoryTooltip /&gt;}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.780.1">The tooltip looks </span><span><span class="kobospan" id="kobo.781.1">like this:</span></span></p></li> </ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer099">
<span class="kobospan" id="kobo.782.1"><img alt="Figure 10.4 – A tooltip on a bar chart in Victory" src="image/B19385_10_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.783.1">Figure 10.4 – A tooltip on a bar chart in Victory</span></p>
<ol class="calibre15">
<li value="5" class="calibre11"><span class="kobospan" id="kobo.784.1">Now we get to the most important part, the data. </span><span class="kobospan" id="kobo.784.2">Here, we map over our </span><strong class="source-inline1"><span class="kobospan" id="kobo.785.1">dailyViews</span></strong><span class="kobospan" id="kobo.786.1"> data returned by the query hook to bring it into a format that </span><span><span class="kobospan" id="kobo.787.1">Victory understands:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.788.1">
            data={dailyViews.data?.map((d) =&gt; ({</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.789.1">We map the </span><strong class="source-inline1"><span class="kobospan" id="kobo.790.1">_id</span></strong><span class="kobospan" id="kobo.791.1"> property to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.792.1">x</span></strong><span class="kobospan" id="kobo.793.1">-axis value (parsing it as a date), and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.794.1">views</span></strong><span class="kobospan" id="kobo.795.1"> property to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.796.1">y</span></strong></span><span><span class="kobospan" id="kobo.797.1">-axis value:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.798.1">
              x: new Date(d._id),
              y: d.views,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.799.1">Then we create a </span><a id="_idIndexMarker665" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.800.1">label, where we turn the day into a local date string</span><a id="_idIndexMarker666" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.801.1"> and then show the number of views on the </span><span><span class="kobospan" id="kobo.802.1">given day:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.803.1">
              label: `${new Date(d._id).toLocaleDateString()}: ${d.views} views`,
            }))}
          /&gt;
        &lt;/VictoryChart&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.804.1">We have successfully created our first visualization using Victory! </span><span class="kobospan" id="kobo.804.2">The chart will now look </span><span><span class="kobospan" id="kobo.805.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer100">
<span class="kobospan" id="kobo.806.1"><img alt="Figure 10.5 – Our first chart in Victory – a bar chart!" src="image/B19385_10_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.807.1">Figure 10.5 – Our first chart in Victory – a bar chart!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">As you can see, Victory</span><a id="_idIndexMarker667" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.809.1"> automatically formatted the dates for us and adjusted </span><a id="_idIndexMarker668" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.810.1">the axes to fit our chart into the </span><span><span class="kobospan" id="kobo.811.1">allotted space!</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.812.1">Let’s visualize the daily average viewing </span><span><span class="kobospan" id="kobo.813.1">duration next.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.814.1">Creating a line chart</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.815.1">Creating a line chart in</span><a id="_idIndexMarker669" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.816.1"> Victory is pretty similar to creating a bar chart, with </span><a id="_idIndexMarker670" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.817.1">one exception: the tooltips. </span><span class="kobospan" id="kobo.817.2">In line charts, we cannot use tooltips directly, as lines could theoretically be continuous (not discrete blocks of data), so it is unclear where to place the tooltip. </span><span class="kobospan" id="kobo.817.3">Instead, we </span><a id="_idIndexMarker671" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.818.1">use a </span><strong class="bold"><span class="kobospan" id="kobo.819.1">Voronoi container</span></strong><span class="kobospan" id="kobo.820.1"> for displaying tooltips on line charts in Victory. </span><span class="kobospan" id="kobo.820.2">The name Voronoi comes from mathematics, where a Voronoi diagram partitions a region into multiple sections. </span><span class="kobospan" id="kobo.820.3">In simple terms, the Voronoi container makes an intersection between the mouse position and the line chart, gets the data from that intersection point, and then displays a </span><span><span class="kobospan" id="kobo.821.1">tooltip there.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.822.1">With that in mind, let’s now get started creating the line chart for the daily average </span><span><span class="kobospan" id="kobo.823.1">viewing duration:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.824.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.825.1">src/components/PostStats.jsx</span></strong><span class="kobospan" id="kobo.826.1"> and continue where we left off with the other chart, adding a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.827.1">VictoryChart</span></strong><span class="kobospan" id="kobo.828.1"> after the container of the </span><span><span class="kobospan" id="kobo.829.1">bar chart:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.830.1">
        &lt;/VictoryChart&gt;
      &lt;/div&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.831.1">      &lt;div style={{ width: 512 }}&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.832.1">        &lt;h4&gt;Daily Average Viewing Duration&lt;/h4&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.833.1">        &lt;VictoryChart</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.834.1">          domainPadding={16}</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.835.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.836.1">VictoryChart</span></strong><span class="kobospan" id="kobo.837.1"> component, we now define </span><strong class="source-inline1"><span class="kobospan" id="kobo.838.1">containerComponent</span></strong><span class="kobospan" id="kobo.839.1">, which will contain</span><a id="_idIndexMarker672" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.840.1">our </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.841.1">VictoryVoronoiContainer</span></strong></span><span><span class="kobospan" id="kobo.842.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.843.1">
          containerComponent={
            &lt;VictoryVoronoiContainer
              voronoiDimension='x'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.844.1">We defined it to only intersect with the values on the </span><strong class="source-inline"><span class="kobospan" id="kobo.845.1">x</span></strong><span class="kobospan" id="kobo.846.1">-axis, meaning that the mouse pointer will only intersect with the days on </span><span><span class="kobospan" id="kobo.847.1">our chart.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.848.1">We can now </span><a id="_idIndexMarker673" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.849.1">define labels for our container, using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.850.1">datum</span></strong><span class="kobospan" id="kobo.851.1"> property to get the data entry that intersects with the mouse pointer to create a label. </span><span class="kobospan" id="kobo.851.2">Our label should display the current date and the viewing duration in minutes, fixed to two </span><span><span class="kobospan" id="kobo.852.1">decimal points:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.853.1">
              labels={({ datum }) =&gt;
                `${datum.x.toLocaleDateString()}: ${datum.y.toFixed(2)} minutes`
              }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.854.1">Again, we use </span><strong class="source-inline1"><span class="kobospan" id="kobo.855.1">VictoryTooltip</span></strong><span class="kobospan" id="kobo.856.1"> to display </span><span><span class="kobospan" id="kobo.857.1">these labels:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.858.1">
              labelComponent={&lt;VictoryTooltip /&gt;}
            /&gt;
          }
        &gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.859.1">Now we can finally define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.860.1">VictoryLine</span></strong><span class="kobospan" id="kobo.861.1"> chart, in which we map the data again, parsing</span><a id="_idIndexMarker674" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.862.1"> dates and dividing the average duration to convert it</span><a id="_idIndexMarker675" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.863.1"> from milliseconds </span><span><span class="kobospan" id="kobo.864.1">to minutes:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.865.1">          &lt;VictoryLine</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.866.1">            data={dailyDurations.data?.map((d) =&gt; ({</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.867.1">              x: new Date(d._id),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.868.1">              y: d.averageDuration / (60 * 1000),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.869.1">            }))}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.870.1">          /&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.871.1">        &lt;/VictoryChart&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.872.1">      &lt;/div&gt;</span></strong><span class="kobospan1" id="kobo.873.1">
    &lt;/div&gt;
  )
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.874.1">As you can see, the rest was pretty simple and similar to creating the bar chart! </span><span class="kobospan" id="kobo.874.2">It looks </span><span><span class="kobospan" id="kobo.875.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer101">
<span class="kobospan" id="kobo.876.1"><img alt="Figure 10.6 – A line chart using Victory, displaying the daily average viewing duration of a post!" src="image/B19385_10_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.877.1">Figure 10.6 – A line chart using Victory, displaying the daily average viewing duration of a post!</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.878.1">As you can see, Victory is a </span><a id="_idIndexMarker676" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.879.1">pretty powerful library for creating charts with React, and </span><a id="_idIndexMarker677" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.880.1">we have only scratched the surface of what it can do! </span><span class="kobospan" id="kobo.880.2">You can still customize the theme of the charts and create all sorts of complex visualizations. </span><span class="kobospan" id="kobo.880.3">In this chapter, however, we focused on the most essential and widely used charts: bar and </span><span><span class="kobospan" id="kobo.881.1">line charts.</span></span></p>
<h1 id="_idParaDest-209" class="calibre5"><a id="_idTextAnchor212" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.882.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.883.1">In this chapter, we learned about tracking events using our backend and frontend. </span><span class="kobospan" id="kobo.883.2">Then, we simulated events to be used as a sample dataset for our aggregations and visualizations. </span><span class="kobospan" id="kobo.883.3">Next, we learned how to aggregate data with MongoDB using the MongoDB Playground. </span><span class="kobospan" id="kobo.883.4">Then, we implemented data aggregation functions in our backend. </span><span class="kobospan" id="kobo.883.5">Finally, we integrated and visualized the data on the frontend </span><span><span class="kobospan" id="kobo.884.1">using Victory.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.885.1">In the next chapter, </span><a href="B19385_11.xhtml#_idTextAnchor213" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.886.1">Chapter 11</span></em></span></a><span class="kobospan" id="kobo.887.1">, </span><em class="italic"><span class="kobospan" id="kobo.888.1">Building a Backend with a GraphQL API</span></em><span class="kobospan" id="kobo.889.1">, we are going to learn how to use an alternative to REST, called GraphQL, to query deeply nested objects </span><span><span class="kobospan" id="kobo.890.1">more easily.</span></span></p>
</div>
</body></html>