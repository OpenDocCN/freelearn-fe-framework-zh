- en: Chapter 2. Ready, Set, Go!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：准备，设置，出发！
- en: 'In this chapter, we will start building our task management application. We''ll
    jump right into the core of the application and create the initial components
    required to manage a simple task list. In the process of going through this chapter,
    you''ll learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建我们的任务管理应用。我们将直接进入应用的核心，并创建管理简单任务列表所需的初始组件。在阅读本章的过程中，你将学习以下主题：
- en: Bootstrapping an Angular application using a main component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主组件引导 Angular 应用
- en: Component input and output
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件输入和输出
- en: Host property binding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宿主属性绑定
- en: Styling and view encapsulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式和视图封装
- en: Importing HTML templates using the SystemJS text loader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SystemJS 文本加载器导入 HTML 模板
- en: Using `EventEmitter` to emit custom events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `EventEmitter` 发射自定义事件
- en: Two-way data binding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: Component life cycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: Managing tasks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理任务
- en: After picking up the basics from the previous chapter, we will now go on and
    create a task management application together in the upcoming chapters. You'll
    learn about some concepts during the chapters and then use them with practical
    examples. You'll also learn how to structure an application using components.
    This begins with the folder structure and ends with setting up the interaction
    between components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章学习了基础知识之后，我们现在将在接下来的章节中一起创建一个任务管理应用。你将在章节中学习一些概念，然后通过实际示例来使用它们。你还将学习如何使用组件来构建应用。这从文件夹结构开始，以设置组件之间的交互结束。
- en: Vision
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉
- en: The task management application should enable users to manage tasks easily and
    help them organize small projects. Usability is the central aspect of any application;
    therefore, you'll need to design a modern and flexible user interface that will
    support the user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任务管理应用应使用户能够轻松管理任务，并帮助他们组织小型项目。可用性是任何应用的中心环节；因此，你需要设计一个现代且灵活的用户界面，以支持用户。
- en: '![Vision](img/image00304.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![视觉](img/image00304.jpeg)'
- en: A preview of the task management application we are going to build
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的任务管理应用的预览
- en: 'Our task management application will consist of components that will allow
    us to design a platform providing a great user experience for the purpose of managing
    tasks. Let''s define the core features of our application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理应用将包含组件，使我们能够设计一个提供出色用户体验的平台，用于管理任务。让我们定义我们应用的核心功能：
- en: Managing tasks within multiple projects and providing a project overview
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个项目中管理任务并提供项目概览
- en: Simple scheduling as well as a time-and-effort-tracking mechanism
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的调度以及时间和努力跟踪机制
- en: Overviewing the dashboard using graphical charts
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形图表概述仪表板
- en: Tracking activities and providing a visual audit log
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪活动并提供可视化的审计日志
- en: A simple commenting system that would work across different components
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个适用于不同组件的简单评论系统
- en: The task management application is the main example in this book. Therefore,
    the building blocks within the book should only contain the code that is relevant
    to the theme of the book. Of course, other than components, an application needs
    other functionalities, such as visual design, data, session management, and other
    important parts, to work. While the required code for each chapter can be downloaded
    online, we'll only discuss the code relevant to the topics learned within the
    book.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任务管理应用是本书的主要示例。因此，书中的构建块应仅包含与本书主题相关的代码。当然，除了组件之外，应用还需要其他功能，如视觉设计、数据、会话管理以及其他重要部分，才能运行。虽然每章所需的代码都可以在线下载，但我们只会讨论与书中学习到的主题相关的代码。
- en: Starting from scratch
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始
- en: 'Let''s start out by creating a new folder called `angular-2-components` in
    order to create our application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `angular-2-components` 的新文件夹开始，以便创建我们的应用：
- en: 'Open a console window inside our newly created folder and run the following
    command to initialize a new Node.js project:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们新创建的文件夹内打开控制台窗口，并运行以下命令以初始化一个新的 Node.js 项目：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finish the initialization wizard by confirming all the steps with the *Enter*
    key (default settings).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 *Enter* 键（默认设置）确认所有步骤来完成初始化向导。
- en: 'Since we''re using JSPM to manage our dependencies, we need to install it as
    a project Node.js package:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用 JSPM 来管理我们的依赖项，因此我们需要将其作为项目 Node.js 包进行安装：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s also initialize a new JSPM project within our project folder. Be sure
    to use the default settings (just hit the *Enter* key) for all settings, except
    for the step where you are asked which transpiler you''d like to use. Enter TypeScript
    at this stage:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目文件夹内初始化一个新的 JSPM 项目。请确保为所有设置使用默认设置（只需按 *Enter* 键），除了被询问你想要使用哪种编译器时。在此阶段输入
    TypeScript：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ll now use JSPM to install the relevant Angular 2 packages into our project
    as dependencies. We''ll also install a SystemJS loader plugin to load text files
    as modules. We''ll provide some details around this later on:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用 JSPM 将相关的 Angular 2 包安装到我们的项目中作为依赖项。我们还将安装一个 SystemJS 加载器插件来加载文本文件作为模块。我们将在稍后提供一些关于此的详细信息：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's examine what we've been creating so far by using the NPM and JSPM command-line
    tools.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 NPM 和 JSPM 命令行工具来检查到目前为止我们所创建的内容。
- en: 'The `package.json` file is our Node.js configuration file that we''re using
    as the base to work with JSPM (the package manager) and SystemJS (the module loader
    with transpiler). If you check out the `package.json` file, you will see an additional
    section for JSPM dependencies:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件是我们使用的 Node.js 配置文件，我们将其作为与 JSPM（包管理器）和 SystemJS（具有编译器的模块加载器）一起工作的基础。如果你查看
    `package.json` 文件，你将看到 JSPM 依赖项的附加部分：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s take a quick look at the dependencies we have installed using JSPM and
    their purpose:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看我们使用 JSPM 安装的依赖项及其用途：
- en: '| Package | Description |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 包 | 描述 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@angular/core` | This is the core package of Angular 2, hosted on NPM. If
    you remember from [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based
    User Interfaces"), *Component-Based User Interfaces*, JSPM is only a broker, and
    it delegates to other package repositories. The core package contains all Angular-core
    modules, such as the `@Component` decorator, change detection, dependency injection,
    and more. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `@angular/core` | 这是 Angular 2 的核心包，托管在 NPM 上。如果你还记得 [第 1 章](part0014.xhtml#aid-DB7S1
    "第 1 章。基于组件的用户界面")，*基于组件的用户界面*，JSPM 只是一个经纪人，并将任务委托给其他包仓库。核心包包含所有 Angular-core
    模块，例如 `@Component` 装饰器、变更检测、依赖注入等。|'
- en: '| `@angular/common` | The Angular `common` package provides us with base directives,
    such as `NgIf` and `NgFor`. It also contains all the base pipes and the directives
    that are used to control forms. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `@angular/common` | Angular 的 `common` 包为我们提供了基本指令，如 `NgIf` 和 `NgFor`。它还包含所有基本管道和控制表单的指令。|'
- en: '| `@angular/compiler` | The compiler package contains all the artifacts required
    to compile view templates. Angular not only provides the ability to precompile
    templates to gain faster booting time, but it also uses the compiler at runtime
    to convert text templates into compiled templates. This package is required if
    we''re compiling templates at runtime. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `@angular/compiler` | 编译器包包含编译视图模板所需的所有工件。Angular 不仅提供了预编译模板以获得更快的启动时间的能力，而且在运行时使用编译器将文本模板转换为编译后的模板。如果我们需要在运行时编译模板，则需要此包。|'
- en: '| `@angular/platform-browser-dynamic` | This package includes the bootstrapping
    functionality that will help us start our application. The bootstrap initiated
    by the platform-browser-dynamic package is dynamic in the sense of compiling templates
    at runtime. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `@angular/platform-browser-dynamic` | 此包包括启动功能，将帮助我们启动应用程序。由 platform-browser-dynamic
    包启动的引导是动态的，即在运行时编译模板。|'
- en: '| `typescript` | This development dependency is the TypeScript transpiler for
    SystemJS. It transpiles our ECMAScript 6 and TypeScript code to ECMAScript 5,
    from where it can run in the browser. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `typescript` | 这个开发依赖项是 SystemJS 的 TypeScript 编译器。它将我们的 ECMAScript 6 和 TypeScript
    代码编译成 ECMAScript 5，从而可以在浏览器中运行。|'
- en: '| `text` | This SystemJS loader supports the loading of text files in the form
    of JavaScript strings. This is especially useful if you like to load HTML templates
    and avoid asynchronous requests. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 这个 SystemJS 加载器支持以 JavaScript 字符串的形式加载文本文件。如果你喜欢加载 HTML 模板并避免异步请求，这特别有用。|'
- en: 'Our main entry point for displaying our application within the browser is our
    index site. The `index.html` file completes the following five actions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中显示应用程序的主要入口点是我们的索引站点。`index.html` 文件完成以下五个动作：
- en: Loading ECMAScript 6 polyfill es6-shim from a CDN. This script is required to
    make sure the browser understands the latest ECMAScript 6 APIs.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 CDN 加载 ECMAScript 6 兼容库 es6-shim。此脚本是为了确保浏览器理解最新的 ECMAScript 6 API。
- en: Loading the Angular 2 polyfills required by the framework. This includes various
    patches for the browser that are required to run an Angular 2 application. It's
    important to load these polyfills before we load any other code within our application.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载框架所需的Angular 2 polyfills。这包括运行Angular 2应用程序所需的浏览器补丁。在加载我们应用程序中的任何其他代码之前，加载这些polyfills非常重要。
- en: Loading SystemJS and the SystemJS `config.js` file that contains the mapping
    information generated by JSPM.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载SystemJS和包含由JSPM生成的映射信息的`config.js`文件。
- en: Using the `System.import` function to load and execute the main entry point,
    which is our `boostrap.js` file.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`System.import`函数加载和执行主入口点，即我们的`boostrap.js`文件。
- en: 'Let''s create a new `index.html` file within the root folder of our project:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的根文件夹内创建一个新的`index.html`文件：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's move on to our application component. You can think of it as the outermost
    component of your application. It's the main component in that it represents your
    whole application. Every application needs one and just one main component. This
    is where your component tree has its roots.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们的应用程序组件。你可以将其视为应用程序的最外层组件。它是主要组件，因为它代表了整个应用程序。每个应用程序都需要一个，并且只有一个主要组件。这是组件树根的位置。
- en: 'We''ll name our main component `App` because it represents our whole application.
    Let''s go ahead and create the component within a new `lib` folder in our project
    folder. Create a file, `app.js`, with the following content:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名我们的主要组件为`App`，因为它代表了我们的整个应用程序。让我们继续在我们的项目文件夹中的新`lib`文件夹内创建这个组件。创建一个名为`app.js`的文件，并包含以下内容：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s nothing different here from what we already know about structuring
    a component, something that we learned in the previous chapter. However, there
    are two main differences here compared to how we created the components before.
    If you look at how we configured the `template` property, you could tell that
    we didn''t write the HTML template directly within the JavaScript file inside
    the ECMAScript 6 template strings. Instead, we''re going to load the template
    into a JavaScript string using the text loader plugin in SystemJS. We can just
    load any text file from the file system by appending `!text` to our regular ECMAScript
    6 imports:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里与我们之前了解的结构化组件的知识没有不同，这是我们之前章节中学到的。然而，与之前创建组件的方式相比，这里有两个主要区别。如果你查看我们配置的`template`属性，你可以看出我们没有直接在JavaScript文件中的ECMAScript
    6模板字符串内编写HTML模板。相反，我们将使用SystemJS中的文本加载插件将模板加载到JavaScript字符串中。我们可以通过在常规ECMAScript
    6导入后附加`!text`来从文件系统中加载任何文本文件：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will load the file, `app.html`, from the current directory and make a default
    export with its content as a string.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载当前目录下的`app.html`文件，并以字符串的形式导出其内容。
- en: 'The second difference is that we''re using `ViewEncapsulation` to specify how
    Angular should handle view encapsulation. Angular has three ways, to handle view
    encapsulation, which provides different levels of granularity and has their own
    pros and cons. They are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是我们使用`ViewEncapsulation`来指定Angular应该如何处理视图封装。Angular有三种处理视图封装的方式，它们提供了不同级别的粒度，并且各有优缺点。具体如下：
- en: '| Encapsulation type | Description |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 封装类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ViewEncapsulation.Emulated` | If a component is set to emulated view encapsulation,
    it will emulate style encapsulation by attaching the generated attributes to the
    component element and modifying CSS selectors to include these attribute selectors.
    This will enable certain forms of encapsulation, although the outer styles can
    still leak into the component if there are other global styles.This view encapsulation
    mode is the default mode, if not specified otherwise. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `ViewEncapsulation.Emulated` | 如果组件设置为模拟视图封装，它将通过将生成的属性附加到组件元素并修改CSS选择器以包含这些属性选择器来模拟样式封装。这将启用某些形式的封装，尽管如果存在其他全局样式，外部样式仍然可能泄漏到组件中。这种视图封装模式是默认模式，除非指定其他方式。
    |'
- en: '| `ViewEncapsulation.Native` | Native view encapsulation is supposed to be
    the ultimate goal of the view encapsulation concept within Angular. It makes use
    of Shadow DOM, as described in the previous chapter, to create an isolated DOM
    for the whole component. This mode depends on the browser to support Shadow DOM
    natively, and therefore, can''t always be used. It''s also important to note that
    global styles will no longer be respected and local styles need to be placed within
    the component in inline style tags (or use the `styles` property on the component
    annotation). |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `ViewEncapsulation.Native` | 原生视图封装应该是Angular中视图封装概念的最终目标。它使用上一章中描述的Shadow
    DOM来为整个组件创建一个隔离的DOM。此模式依赖于浏览器原生支持Shadow DOM，因此不一定总是可以使用。还重要的是要注意，全局样式将不再被尊重，并且局部样式需要放置在组件内的行内样式标签中（或使用组件注释上的`styles`属性）。|'
- en: '| `ViewEncapsulation.None` | This mode tells Angular not to provide any template
    or style encapsulation. Within our application, we mainly rely on styles coming
    from a global CSS; therefore, we use this mode for most of the components. Neither
    Shadow DOM, nor attributes will be used to create style encapsulation; we can
    simply use the classes specified within our global CSS file. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ViewEncapsulation.None` | 此模式告诉Angular不提供任何模板或样式封装。在我们的应用程序中，我们主要依赖于来自全局CSS的样式；因此，我们为大多数组件使用此模式。既不使用Shadow
    DOM，也不使用属性来创建样式封装；我们可以简单地使用我们全局CSS文件中指定的类。|'
- en: 'As this component is now relying on a template to be loaded from the file system,
    we need to create the `app.html` file in the `lib` folder with some initial content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此组件现在依赖于从文件系统加载的模板，我们需要在`lib`文件夹中创建一个包含一些初始内容的`app.html`文件：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the time being, that''s everything we put in our template. Our directory
    should look similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，这就是我们放入模板中的所有内容。我们的目录应该看起来类似于此：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have created our main application component, we can add the component''s
    host element to our `index.html` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的主要应用程序组件，我们可以将组件的主元素添加到我们的`index.html`文件中：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Bootstrapping
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导
- en: The `index.html` file will load the `bootstrap.js` module using SystemJS in
    an inline `script` tag. It's a best practice to have a main entry point for your
    scripts when working with SystemJS. Our `bootstrap.js` file is responsible for
    loading all the necessary JavaScript dependencies for our application as well
    as bootstrapping the Angular framework.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`文件将使用SystemJS在行内`script`标签中加载`bootstrap.js`模块。当与SystemJS一起工作时，为您的脚本提供一个主入口点是一个最佳实践。我们的`bootstrap.js`文件负责加载我们应用程序所需的所有必要JavaScript依赖项以及启动Angular框架。'
- en: 'We can go ahead and bootstrap our Angular application by providing our main
    application component, `App`. We need to import the `bootstrap` function from
    the `angular2` module. We can then import our `App` component and call the `bootstrap`
    function, passing it as parameter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续引导我们的Angular应用程序，通过提供我们的主要应用程序组件`App`。我们需要从`angular2`模块中导入`bootstrap`函数。然后我们可以导入我们的`App`组件并调用`bootstrap`函数，将其作为参数传递：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running the application
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'The code we''ve produced so far should now be in a state where we can run it.
    Before we run our code using the live-server module, let''s ensure we have all
    the files ready. At this stage, our directory should look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止生成的代码现在应该处于可以运行的状态。在我们使用live-server模块运行我们的代码之前，让我们确保我们已准备好所有文件。在这个阶段，我们的目录应该看起来像这样：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s start live server to start a server and a browser with live reload.
    For this, we need to simply execute the following command on the command line
    within our project folder:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始启动实时服务器，以启动一个服务器和一个带有实时重载功能的浏览器。为此，我们只需在我们的项目文件夹内命令行中执行以下命令即可：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If everything goes well, you will have an open web browser that shows **Hello
    World!**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将打开一个显示**Hello World!**的网页浏览器。
- en: Recap
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Let''s recap what we have done so far:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们到目前为止所做的工作：
- en: We initialized a new project using NPM and JSPM and installed the Angular dependencies
    using JSPM.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用NPM和JSPM初始化了一个新项目，并使用JSPM安装了Angular依赖项。
- en: We created our main application component in `app.js`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`app.js`中创建了我们的主要应用程序组件。
- en: We also created a `bootstrap.js` script to include the Angular framework boot
    of our application.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建了一个`bootstrap.js`脚本，用于包含我们应用程序的Angular框架引导。
- en: We added our component to the `index.html` file by including an element that
    matches our component selector property.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过包含一个与我们的组件选择器属性匹配的元素，将我们的组件添加到`index.html`文件中。
- en: Finally, we used live server to start a basic web server and launch a web browser.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用了live server来启动一个基本的Web服务器并打开一个网页浏览器。
- en: Creating a task list
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务列表
- en: Now that we have our main application component set up, we can go on and flesh
    out our task application. The second component that we're going to create will
    be responsible for listing tasks. Following the concept of composition, we'll
    create a `task-list` component as a subcomponent of our main application component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了主要的应用组件，我们可以继续完善我们的任务应用。我们将要创建的第二个组件将负责列出任务。遵循组合的概念，我们将创建一个`task-list`组件，作为我们主要应用组件的子组件。
- en: 'Let''s create a folder within the `lib` folder called `task-list` and a new
    JavaScript file called `task-list.js`, where we will write our component code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`lib`文件夹中创建一个名为`task-list`的文件夹和一个名为`task-list.js`的新JavaScript文件，我们将在这里编写我们的组件代码：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've created a very simple `task-list` component that has a list of tasks stored
    internally. This component will be attached to HTML elements that match the CSS
    element selector `ngc-task-list`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的`task-list`组件，该组件内部存储了一个任务列表。这个组件将被附加到匹配CSS元素选择器`ngc-task-list`的HTML元素上。
- en: 'Now let''s create a view for this component to display the tasks. As you can
    see from the import within the component JavaScript file, we are looking for a
    file called `task-list.html`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个组件创建一个视图来显示任务。正如您从组件JavaScript文件中的导入中可以看到，我们正在寻找一个名为`task-list.html`的文件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the `NgFor` directive to repeat the `<div>` element with the class task
    for as many tasks as we have in the task list of our component. The `NgFor` directive
    in Angular will create a template element from its underlying content and instantiate
    as many elements from the template as the expression evaluates to. We currently
    have two tasks in our `task-list` component, so this will create two instances
    of our template.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`NgFor`指令重复具有class task的`<div>`元素，以匹配我们组件任务列表中的任务数量。Angular中的`NgFor`指令将从其底层内容创建一个模板元素，并根据表达式评估的结果实例化模板中的元素。我们目前在`task-list`组件中有两个任务，因此这将创建我们模板的两个实例。
- en: 'Your folder structure inside the `lib` folder should now look similar to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您在`lib`文件夹内的文件夹结构现在应该类似于这个：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All that''s left to do in order to make our task list work is the inclusion
    of the `task-list` component within the main application component. We can go
    ahead and modify our `app.js` file and add the following line on top of it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的任务列表工作，我们剩下的工作是在主要应用组件中包含`task-list`组件。我们可以继续修改我们的`app.js`文件，并在其顶部添加以下行：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we want to add the `task-list` component to our main application view template,
    we also need to make sure that Angular knows about the component when compiling
    the view. For this, we need to add the `directives` property to our main application
    component within the `app.js` file and include our imported `TaskList` component
    class within the list of directives:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将`task-list`组件添加到我们的主要应用视图模板中，我们还需要确保Angular在编译视图时知道该组件。为此，我们需要在`app.js`文件中为主应用组件添加`directives`属性，并将我们导入的`TaskList`组件类包含在指令列表中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we need to include the host element of our `task-list` component in
    the template of the main application, which is located within the `app.html` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在主要应用的模板中包含`task-list`组件的主机元素，该模板位于`app.html`文件中：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These were the last changes we needed to make in order to make our `task-list`
    component work. To view your changes, you can start the live server by executing
    the `live-server` command within your `angular-2-components` directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要做的最后更改，以便使我们的`task-list`组件工作。要查看您的更改，您可以在`angular-2-components`目录中执行`live-server`命令来启动live
    server。
- en: Recap
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Let''s look at what we have done in the previous building block. We achieved
    a simple listing of tasks within an encapsulated component by following these
    steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在上一个构建块中做了什么。通过遵循以下步骤，我们实现了在封装组件内对任务的简单列出：
- en: We created the component JavaScript file that contains the logic of our component.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了包含我们组件逻辑的组件JavaScript文件。
- en: We created the component's view within a separate HTML file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在单独的HTML文件中创建了组件的视图。
- en: We included the component class within the configuration of our main application
    component.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在主要应用组件的配置中包含了组件类。
- en: We included the component HTML element within our main application view template.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在主要应用视图模板中包含了组件的HTML元素。
- en: The right level of encapsulation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确的封装级别
- en: Our task list is displayed correctly and the code we used to achieve this looks
    quite okay. However, if we want to follow a better approach for composition, we
    should rethink the design of our `task-list` component. If we draw a line at enlisting
    the task list responsibilities, we would come up with things such as listing tasks,
    adding new tasks to the list, and sorting and filtering the task list; however,
    operations are not performed on an individual task itself. Also, rendering the
    task itself falls outside of the responsibilities of the task list. The `task-list`
    component should only serve as a container for tasks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务列表显示正确，我们用来实现这一点的代码看起来相当不错。然而，如果我们想遵循更好的组合方法，我们应该重新思考我们的`task-list`组件的设计。如果我们划一条线来列出任务列表的职责，我们会得到诸如列出任务、向列表添加新任务以及排序和过滤任务列表等内容；然而，操作并不是在单个任务本身上执行的。此外，渲染任务本身超出了任务列表的职责范围。`task-list`组件应该仅作为任务的容器。
- en: If we look at our code again, we will see that we're violating the single responsibility
    principle and rendering the whole task body within our `task-list` component.
    Let's take a look at how we can fix this by increasing the granularity of the
    encapsulation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们的代码，我们会发现我们违反了单一职责原则，在`task-list`组件内部渲染整个任务主体。让我们看看我们如何通过增加封装的粒度来解决这个问题。
- en: The goal now is to do a code refactoring exercise, also known as extraction.
    We are pulling our task's relevant template out of the task list template and
    creating a new component that encapsulates the tasks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的目标是进行代码重构练习，也称为提取。我们将任务的相关模板从任务列表模板中提取出来，并创建一个新的组件来封装任务。
- en: 'For this, we need to create a new sub folder within the `task-list` folder
    called `task`. Within this folder, we will create a template file with the name
    `task.html`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在`task-list`文件夹内创建一个新的子文件夹，命名为`task`。在这个文件夹内，我们将创建一个名为`task.html`的模板文件：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The content of our new `task.html` file is pretty much the same as what we already
    have within our `task-list.html` template. The only difference is that we will
    now refer to a new model called `task`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`task.html`文件的内容基本上与我们已经在`task-list.html`模板中拥有的内容相同。唯一的区别是，我们现在将引用一个新的模型，称为`task`。
- en: 'Now, within the `task` folder, let''s create the JavaScript file, `task.js`,
    which will contain the controller class of our component:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`task`文件夹内，让我们创建一个JavaScript文件，名为`task.js`，它将包含我们组件的控制器类：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous chapter of this book, we spoke about encapsulation and the preconditions
    to establish a clean encapsulation for UI components. One of these preconditions
    is the possibility to design proper interfaces in and out of the component. Such
    input and output methods are necessary to make the component work within compositions.
    That's how a component will receive and publish information.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一章中，我们讨论了封装和为UI组件建立干净封装的先决条件。这些先决条件之一是能够在组件内外设计适当的接口。这些输入和输出方法是使组件在组合中工作所必需的。这就是组件如何接收和发布信息的方式。
- en: As you can see from our task component implementation, we are now building such
    an interface using the `@Input` annotation on a class instance field. In order
    to use this annotation, we will first need to import it from the angular core
    module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们的任务组件实现中看到的那样，我们现在正在使用类实例字段上的`@Input`注解来构建这样一个接口。为了使用这个注解，我们首先需要从angular核心模块中导入它。
- en: Input properties in Angular allow us to bind the expressions in our templates
    to class instance fields on our components. This way, we can pass data from the
    outside of the component to the component inside, using the components template.
    This can be thought of as an example of one-way binding, from the view to the
    component.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的输入属性允许我们将模板中的表达式绑定到组件的类实例字段上。这样，我们可以通过组件的模板从组件外部传递数据到组件内部。这可以被视为从视图到组件的单向绑定示例。
- en: 'If we''re using property binding on a regular DOM property, Angular will create
    a binding of the expression directly to the element''s DOM property. We''re using
    such a type of binding to bind the task completed flag to the `checked` property
    of the checkbox''s `input` element:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在常规DOM属性上使用属性绑定，Angular将直接将表达式绑定到元素的DOM属性上。我们正在使用这种类型的绑定来将任务完成标志绑定到复选框的`input`元素的`checked`属性上：
- en: '| Usage | Description |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 用法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Input() inputProp;` | This allows us to bind the `inputProp` attribute
    to the component element within the parent component.Angular assumes that the
    attribute of the element has the same name as that of the `input` property. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `@Input() inputProp;` | 这允许我们将`inputProp`属性绑定到父组件内的组件元素。Angular假设元素的属性名与`input`属性名相同。|'
- en: '| `@Input(''inp'') inputProp;` | You can also override the name of the attribute
    that should be mapped to this input. Here, the `inp` attribute of the component''s
    HTML element is mapped to the component''s input property, `inputProp`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `@Input(''inp'') inputProp;` | 您也可以覆盖映射到此输入的属性的名称。在这里，组件的HTML元素的`inp`属性被映射到组件的输入属性`inputProp`。|'
- en: The last missing piece to use our newly created task component is the modification
    of the existing template of the task list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新创建的任务组件的最后一步是修改现有的任务列表模板。
- en: 'We include the task component within our task list template by using an `<ngc-task>`
    element, as specified in the selector within our task component. Also, we create
    a property binding on the task element. There, we pass the `task` object from
    the current `NgFor` iteration to the `task` input of the `task` component. We
    need to replace all the existing content in the `task.html` file with the following
    lines of code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用在任务组件中指定的选择器内的`<ngc-task>`元素，将任务组件包含在我们的任务列表模板中。同时，我们在任务元素上创建了一个属性绑定。在那里，我们将当前`NgFor`迭代的`task`对象传递给`task`组件的`task`输入。我们需要用以下代码行替换`task.html`文件中的所有现有内容：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to make our `task-list` component recognize the task component element,
    we need to add it to the `task-list` component''s `directives` property within
    the `task-list.js` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`task-list`组件能够识别任务组件元素，我们需要将其添加到`task-list.js`文件中的`task-list`组件的`directives`属性中：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Congratulations! You've successfully refactored your task list by extracting
    the task into its own component and have established a clean encapsulation. Also,
    we can now say that our task list is a composition of tasks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经通过提取任务到其自己的组件中成功重构了您的任务列表，并建立了清晰的封装。此外，我们现在可以说我们的任务列表是由任务组成的。
- en: If you think about maintainability and reusability, this was actually a very
    important step in the process of building our application. You should constantly
    look out for such encapsulation opportunities, and if you feel something could
    be arranged into multiple subcomponents, you should probably go for it. Of course,
    you can also overdo this. There's simply no golden rule to determine what granularity
    of encapsulation is the right one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑可维护性和可重用性，这实际上是我们构建应用程序过程中的一个非常重要的步骤。你应该不断寻找这样的封装机会，如果你觉得某些东西可以组织成多个子组件，那么你很可能应该这样做。当然，你也可以做得太过分。实际上并没有一条金科玉律来确定封装粒度应该是多少。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The right granularity of encapsulation for a component architecture always depends
    on the context. My personal tip here is to use known principles from OOP, such
    as single responsibility, to lay the groundwork for a good design of your component
    tree. Always make sure your components are only doing things that they are supposed
    to do as their names suggest. A task list has the responsibility of listing tasks
    and providing some filters or other controls for the list. The responsibility
    of operating on individual task data and rendering the necessary view clearly
    belongs to a task component and not the task list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 组件架构的封装粒度始终取决于上下文。我个人的建议是使用面向对象编程的已知原则，如单一职责，为你的组件树的良好设计打下基础。始终确保你的组件只做它们应该做的事情，正如它们的名称所暗示的那样。任务列表有列出任务和提供一些过滤器或其他控制列表的责任。操作单个任务数据并渲染必要视图的责任显然属于任务组件，而不是任务列表。
- en: Recap
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: 'In this building block, we cleaned up our component tree and established clean
    encapsulation using subcomponents. Then, we set up the interfaces provided by
    Angular using input bindings. We performed these actions by following the ensuing
    steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构建块中，我们通过使用子组件清理了我们的组件树，并建立了清晰的封装。然后，我们通过输入绑定设置了Angular提供的接口。我们通过以下步骤执行了这些操作：
- en: We created a task subcomponent.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个任务子组件。
- en: We used the task subcomponent with the `task-list` component.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了任务子组件和`task-list`组件。
- en: We used input bindings and DOM element property bindings to establish one-way
    data binding in the task component.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用输入绑定和DOM元素属性绑定在任务组件中建立单向数据绑定。
- en: Input generates output
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入生成输出
- en: Our task list looks nice already, but it would be quite useless if the user
    is unable to add new tasks to the list. Let's create a component for entering
    new tasks together. As this component belongs to the `task-list` component, we're
    going to create a new folder called `enter-task` within the `task-list` folder.
    The responsibilities of this component will be to handle all the UI logic necessary
    for entering a new task.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务列表看起来已经很不错了，但如果用户无法向列表中添加新任务，那将毫无用处。让我们一起创建一个用于输入新任务的组件。由于这个组件属于 `task-list`
    组件，我们将在 `task-list` 文件夹内创建一个新的文件夹名为 `enter-task`。这个组件的职责将包括处理所有必要的 UI 逻辑，以便输入一个新任务。
- en: 'Using the same naming convention as with the rest of our components, let''s
    create a file called `enter-task.html` to store the template of our component:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与我们的其他组件相同的命名约定，让我们创建一个名为 `enter-task.html` 的文件来存储我们组件的模板：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This template consists of an input field as well as a button to enter a new
    task. Here, we're making use of the so-called local view variables by specifying
    that our input field should have the reference name `#titleInput`. We can reference
    this variable within the current component view by the name `titleInput`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板包括一个输入字段以及一个用于输入新任务的按钮。在这里，我们通过指定我们的输入字段应该具有引用名称 `#titleInput` 来使用所谓的局部视图变量。我们可以在当前组件视图中通过名称
    `titleInput` 来引用这个变量。
- en: In this case, we are actually using the variable to pass the input field DOM
    element to the `enterTask` function that we call on a click event on the `Add
    Task` button.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实际上使用这个变量将输入字段 DOM 元素传递给我们在点击 `添加任务` 按钮时调用的 `enterTask` 函数。
- en: 'Let''s take a look at the implementation of our `Component` class for entering
    a new task by using the following code in a newly-created `enter-task.js` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在新建的 `enter-task.js` 文件中使用以下代码来查看我们用于输入新任务的 `Component` 类的实现：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For this component, we've chosen a design approach where we use a loose relation
    to our task list where the actual task will be created. Although this component
    is closely related to the task list, it's better to keep the components as loosely
    coupled as possible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，我们选择了一种设计方法，即我们使用一种松散的关系来处理任务列表，实际的任务将在其中创建。尽管这个组件与任务列表密切相关，但最好将组件保持得尽可能松散耦合。
- en: 'One of the simplest forms of inversion of control, a callback function or event
    listener is a great principle to establish loose coupling. In this component,
    we are using the `@Output` annotation to create an event emitter. The output properties
    need to be instance fields that hold an event emitter within the component. On
    the component''s HTML element, we can then use event bindings to capture any events
    emitted. This gives us great flexibility that we can use to create a clean application
    design, where we glue components together through the binding within the view:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转的一种最简单形式是回调函数或事件监听器，这是一个建立松散耦合的绝佳原则。在这个组件中，我们使用 `@Output` 注解来创建一个事件发射器。输出属性需要是组件中的实例字段，它们持有事件发射器。在组件的
    HTML 元素上，我们可以使用事件绑定来捕获任何发出的事件。这为我们提供了极大的灵活性，我们可以用它来创建一个干净的应用程序设计，通过视图中的绑定将组件粘合在一起：
- en: '| Usage | Description |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 使用 | 描述 |'
- en: '| --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Output() outputProp = new EventEmitter();` | When `outputProp.next()` is
    called, a custom event with the name `outputProp` will be emitted on the component.
    Angular will look for event bindings on the component''s HTML element (where the
    component is used) and execute them:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '| `@Output() outputProp = new EventEmitter();` | 当调用 `outputProp.next()` 时，组件上会发出一个名为
    `outputProp` 的自定义事件。Angular 将在组件的 HTML 元素（组件被使用的地方）上查找事件绑定并执行它们：'
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Within the expressions in event bindings, you will always have access to a synthetic
    variable called `$event`. This variable is a reference to the data emitted by
    `EventEmitter`. |
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件绑定中的表达式内，你将始终可以访问一个名为 `$event` 的合成变量。这个变量是对 `EventEmitter` 发射的数据的引用。|
- en: '| `@Output(''out'') outputProp = new EventEmitter();` | Use this way of declaring
    your output properties if you''d want to name your events differently from what
    your property name is. In this example, a custom event with the name `out` will
    be fired when `outputProp.next()` is called:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '| `@Output(''out'') outputProp = new EventEmitter();` | 如果你希望你的事件名称与属性名称不同，可以使用这种方式声明你的输出属性。在这个例子中，当调用
    `outputProp.next()` 时，将触发一个名为 `out` 的自定义事件：'
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Okay, let''s use this newly created component to add new tasks within our `task-list`
    component. First, let''s modify the existing template of the `task-list` component.
    Open the file, `task-list.html`, in the `task-list` component folder. We need
    to add the `EnterTask` component to the template and also handle the custom event
    that we''re going to emit, once a new task is entered within the component:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们使用这个新创建的组件在我们的 `task-list` 组件中添加新的任务。首先，让我们修改 `task-list` 组件的现有模板。在 `task-list`
    组件文件夹中打开文件，`task-list.html`。我们需要将 `EnterTask` 组件添加到模板中，并处理我们将要发射的自定义事件，一旦在组件中输入了新的任务：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since the output property within the `enter-task` component is called `taskEntered`,
    we can bind it with the event binding attribute, `(taskEntered)=""`, on the host
    element.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `enter-task` 组件中的输出属性名为 `taskEntered`，我们可以使用事件绑定属性 `(taskEntered)=""` 在宿主元素上将其绑定。
- en: Within the event binding expression, we then call a function on our `task-list`
    component called `addTask`. Also, we use the synthetic variable `$event`, which
    contains the task title emitted from the `enter-task` component. Now, whenever
    we push the button in our `enter-task` component and an event gets emitted from
    the component, we catch the event in our event binding and handle it within the
    `task-list` component.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件绑定表达式中，我们调用 `task-list` 组件上的 `addTask` 函数。我们还使用了合成变量 `$event`，它包含从 `enter-task`
    组件发射的任务标题。现在，每次我们在 `enter-task` 组件中按下按钮并从组件中发射事件时，我们都会在事件绑定中捕获该事件，并在 `task-list`
    组件中处理它。
- en: 'We also need to make some minor changes to the `task-list` component''s JavaScript
    file. Let''s open `task-list.js` and modify it with the following changes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对 `task-list` 组件的 JavaScript 文件做一些小的修改。让我们打开 `task-list.js` 并对其进行以下修改：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only thing we changed within the `task-list` component module is its ability
    to declare the `EnterTask` component in the directives property so that the compiler
    recognizes our `enter-task` component correctly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `task-list` 组件模块中，我们唯一改变的是其能够在指令属性中声明 `EnterTask` 组件，以便编译器正确识别我们的 `enter-task`
    组件。
- en: We have also added a function, `addTask`, which will add a new task to our task
    list with a title that is passed to the function. Now the circle is closed and
    our event from the `enter-task` component is routed to this function within the
    view of the `task-list` component.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个名为 `addTask` 的函数，该函数将带有传递给函数的标题的新任务添加到我们的任务列表中。现在闭环完成，我们的 `enter-task`
    组件的事件被路由到 `task-list` 组件的视图中这个函数。
- en: You can now start live server from your project directory in order to test the
    newly added functionality using the `live-server` command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从项目目录中启动 live-server，以使用 `live-server` 命令测试新添加的功能。
- en: Recap
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾
- en: 'We have added a new subcomponent of the task list that is responsible for providing
    the UI logic to add new tasks. In other words, we have covered the following topics:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为任务列表添加了一个新的子组件，该组件负责提供添加新任务的 UI 逻辑。换句话说，我们已经涵盖了以下主题：
- en: We created a subcomponent that is loosely coupled using output properties and
    event emitters.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个使用输出属性和事件发射器松散耦合的子组件。
- en: We learned about the `@Output` annotation and how to use it to create output
    properties.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们学习了关于 `@Output` 注解及其如何用于创建输出属性的使用方法。
- en: We used event bindings to link the behavior together, from the view of a component.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用事件绑定将行为链接在一起，从组件的视图来看。
- en: Custom UI elements
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 UI 元素
- en: The standard UI elements in the browser are great, but sometimes, modern web
    applications require more complex and intelligent input elements than the ones
    available within the browser.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的标准 UI 元素非常出色，但有时，现代 Web 应用程序需要比浏览器内可用的更复杂和智能的输入元素。
- en: 'We''ll now create two specific custom UI elements that we''ll use within our
    application going forward in order to provide a nice user experience:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建两个特定的自定义 UI 元素，我们将使用这些元素在我们的应用程序中提供良好的用户体验：
- en: '**Checkbox**: There''s already a native checkbox input in the browser, but
    sometimes, it''s hard to fit it into the visual design of an application. Native
    checkboxes are limited in their styling possibilities, and therefore, it''s hard
    to make them look great. Sometimes, it''s those minor details that make an application
    look appealing.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复选框**：浏览器中已经有一个原生的复选框输入，但有时很难将其融入应用程序的视觉设计中。原生复选框在样式方面有限制，因此很难使其看起来很棒。有时，正是这些细节让应用程序看起来很有吸引力。'
- en: '**Toggle buttons**: This is a list of toggle buttons, where only one button
    can be toggled within the list. They could also be represented with a native radio
    button list. However, like with native checkboxes, radio buttons are sometimes
    not really the nicest visual solution to the problem. A list of toggle buttons
    that also represents a select-one-user input element is much more modern and provides
    the visual aspect that we are looking for. Besides, who does not like to push
    buttons?'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换按钮**：这是一个切换按钮列表，其中列表中只能切换一个按钮。它们也可以用原生的单选按钮列表来表示。然而，就像原生的复选框一样，单选按钮有时并不是解决问题的最佳视觉解决方案。一个既代表单选用户输入元素又表示切换按钮列表的列表更加现代，并提供了我们所需的视觉方面。此外，谁不喜欢按按钮呢？'
- en: Let's create our custom checkbox UI element first. As we'll probably come up
    with a few custom UI elements, first let's create a new subfolder called `ui`
    within the `lib` folder.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的自定义复选框UI元素。由于我们可能会想出几个自定义UI元素，首先让我们在`lib`文件夹内创建一个名为`ui`的新子文件夹。
- en: 'Within the `ui` folder, we now create a folder with the name `checkbox` for
    our checkbox component. Starting with the template of our new component, we now
    create a file with the name `checkbox.html` within the `checkbox` folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ui`文件夹内，我们现在为我们的复选框组件创建一个名为`checkbox`的文件夹。从我们新组件的模板开始，我们现在在`checkbox`文件夹内创建一个名为`checkbox.html`的文件：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On the `checkbox` input, we have two bindings. First, we have a property binding
    for the `checked` property on the DOM element. We are binding the DOM property
    to the `checked` member field on our component, which we are going to create in
    a moment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`checkbox`输入上，我们有两个绑定。首先，我们对DOM元素上的`checked`属性进行属性绑定。我们将DOM属性绑定到我们即将创建的组件的`checked`成员字段上。
- en: Also, we have an event binding on the input element where we listen for the
    checkbox change DOM event and call the method `onCheckedChange` on our component
    class. We use the synthetic variable `$event` to pass the `checked` property on
    the checkbox DOM element where the change event is originated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在输入元素上有一个事件绑定，我们监听复选框变化的DOM事件，并在我们的组件类上调用`onCheckedChange`方法。我们使用合成变量`$event`传递复选框DOM元素上的`checked`属性，其中变化事件发生。
- en: 'Moving on to our `component` class implementation, we need to create a file
    with the name `checkbox.js` within the `checkbox` folder:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的`component`类实现，我们需要在`checkbox`文件夹内创建一个名为`checkbox.js`的文件：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's nothing special about this `component` class if we first look at it.
    It uses an input property to set the checked state from the outside, and it also
    has an output property with an event emitter that allows us to notify the outer
    component about the changes of the checked state using a custom event. However,
    there's a naming convention that makes this component a bit special. The convention
    of using an input property name also as an output property name but appending
    the word *change* is actually enabling a developer who uses the component to make
    use of the two-way data binding template shorthand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先看这个`component`类，它并没有什么特别之处。它使用一个输入属性从外部设置选中状态，并且它还有一个带有事件发射器的输出属性，允许我们通过自定义事件通知外部组件关于选中状态的变化。然而，有一个命名约定使得这个组件有点特别。使用输入属性名同时作为输出属性名，并在其后添加单词*change*的约定实际上是在启用使用该组件的开发者利用双向数据绑定模板简写。
- en: Angular does not come with two-way data binding out of the box. However, creating
    two-way binding is quite easy. Actually, two-way data binding is no different
    than combining a property binding with an event binding.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Angular并不自带双向数据绑定。然而，创建双向绑定相当容易。实际上，双向数据绑定与组合属性绑定和事件绑定并无不同。
- en: 'The following example creates a very simple two-way data binding process on
    an input field:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在输入字段上创建了一个非常简单的双向数据绑定过程：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The simplicity of Angular and the general approach of extending the native functionality
    of the browser makes implementing this mechanism a breeze.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的简洁性和扩展浏览器原生功能的一般方法使得实现这一机制变得轻而易举。
- en: Implementing two-way data binding between a component and its subcomponent isn't
    really too difficult. The only thing we need to take care about is that there
    are input and output properties of the subcomponent involved.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件及其子组件之间实现双向数据绑定并不太难。我们唯一需要关注的是子组件涉及输入和输出属性。
- en: 'Please have a look at the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下截图：
- en: '![Custom UI elements](img/image00305.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UI元素](img/image00305.jpeg)'
- en: A two-way data binding between member variables of a component and a subcomponent
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 组件成员变量与子组件之间的双向数据绑定
- en: 'Since two-way data binding was a highly requested feature in Angular, there''s
    a handy shorthand to write it. Let''s look at some examples on how to implement
    data bindings between a template of a component and its subcomponent:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于双向数据绑定在Angular中是一个高度请求的功能，因此有一个方便的简写来编写它。让我们看看一些如何在组件模板和其子组件之间实现数据绑定的示例：
- en: '| Subcomponent properties | Bindings in component template |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 子组件属性 | 组件模板中的绑定 |'
- en: '| --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `@Input() text;``@Output() textOut = new EventEmitter();` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `@Input() text;``@Output() textOut = new EventEmitter();` |'
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We bind the component's `myText` property to the subcomponent's text input.
    Also, we capture the `textOut` event emitted from the subcomponent and update
    our `myText` property. |
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组件的`myText`属性绑定到子组件的文本输入。同时，我们捕获从子组件发出的`textOut`事件并更新我们的`myText`属性。|
- en: '| `@Input() text;``@Output() textChange = new EventEmitter();` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `@Input() text;``@Output() textChange = new EventEmitter();` |'
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can simplify this two-way data binding by using the naming convention to
    append the word "change" to our event emitter identifier. This way, we can use
    the two-way data binding shorthand within our template using the `[(property)]`
    notation. |
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用命名约定将“change”一词附加到事件发射器标识符上来简化这种双向数据绑定。这样，我们就可以在模板中使用`[(property)]`符号来使用双向数据绑定的简写。
- en: If we look at our `checkbox` component implementation again, we will see that
    we are using the two-way data binding naming convention for the checked property
    of our component. This way, we enable the use of the template shorthand for two-way
    data binding wherever we use our custom checkbox UI component.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看我们的`checkbox`组件实现，我们会看到我们正在使用双向数据绑定的命名约定来为我们的组件的选中属性命名。这样，我们就可以在我们的自定义复选框UI组件的任何地方使用模板简写来启用双向数据绑定。
- en: 'Let''s integrate our checkbox in the task component to replace the native checkbox
    input we''re currently using there. For this, we need to modify the `task.html`
    file within the `task-list/task` folder, by replacing the native input checkbox
    that we have in the `task.html` file with the following line of code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将复选框集成到任务组件中，以替换我们目前在该处使用的原生复选框输入。为此，我们需要修改`task-list/task`文件夹中的`task.html`文件，将`task.html`文件中的原生输入复选框替换为以下代码行：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As always, we also need to tell the task component that we''d like to use the
    component within the template. Let''s change the code within the `task.js` file
    accordingly:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们还需要告诉任务组件我们希望在模板中使用该组件。让我们相应地更改`task.js`文件中的代码：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've already learned about the host property on components. It allows us to
    set property and event bindings on our component host element. The host element
    is the DOM element where our component is initialized within the parent component.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了组件上的宿主属性。它允许我们在组件宿主元素上设置属性和事件绑定。宿主元素是我们组件在父组件中初始化的DOM元素。
- en: There's another way through which we can set properties on our component host
    element, which becomes handy when we want to set a property based on some data
    within our component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过另一种方式在组件宿主元素上设置属性，这在我们需要根据组件中的某些数据设置属性时非常有用。
- en: Using the `@HostBinding` annotation, we can create property bindings on the
    component host element based on the members within our component. Let's use this
    annotation in order to create a binding that will conditionally set the `task--done`
    class on the component's HTML element. This is used to make some visual distinctions
    of finished tasks within our styles.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@HostBinding`注解，我们可以在组件宿主元素上创建基于我们组件内部成员的属性绑定。让我们使用这个注解来创建一个条件性地在组件的HTML元素上设置`task--done`类的绑定。这用于在我们的样式中对已完成任务进行一些视觉区分。
- en: This was just the last step to integrate our custom checkbox UI component within
    the task component. You can now start `live-server` in order to view your changes
    and play around with these large new checkboxes in the task list. Isn't that much
    more fun to do than activating regular checkboxes? Don't underestimate the effect
    of a user interface that is pleasing to use. This can have a very positive impact
    on the usage of your product.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将我们自定义的复选框UI组件集成到任务组件中的最后一步。现在你可以启动`live-server`来查看你的更改，并在任务列表中玩转这些新的大复选框。这难道不是比激活常规复选框更有趣吗？不要低估一个令人愉悦的用户界面的效果。这可能会对你的产品使用产生非常积极的影响。
- en: '![Custom UI elements](img/image00306.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UI元素](img/image00306.jpeg)'
- en: Our task list after adding our custom checkbox component
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加我们的自定义复选框组件后，我们的任务列表
- en: 'Now that we''ve created our `checkbox` component, let''s go ahead and create
    another UI component for toggle buttons that we''ll use in the next topic. We
    need to create a folder named `toggle` within the `ui` folder and create a template
    called `toggle.html` within the `toggle` folder:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的`checkbox`组件，让我们继续创建另一个用于切换按钮的UI组件，我们将在下一个主题中使用它。我们需要在`ui`文件夹内创建一个名为`toggle`的文件夹，并在`toggle`文件夹内创建一个名为`toggle.html`的模板：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nothing special here, really! We repeat a button by iterating over an instance
    field called `buttonList` using the `NgFor` directive. This button list will contain
    the labels of our toggle buttons. Conditionally, we set a class called `button--active`
    using a property binding and checking it against our current button within the
    iteration against an instance field called `selectedButton`. When the button is
    clicked, we call a method, `onButtonActivate`, on our component class and pass
    the current button label from the iteration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里实际上没有什么特别的！我们通过使用名为`buttonList`的实例字段并使用`NgFor`指令迭代来重复一个按钮。这个按钮列表将包含我们的切换按钮的标签。条件性地，我们使用属性绑定并检查它是否与迭代中的当前按钮（名为`selectedButton`的实例字段）匹配来设置一个名为`button--active`的类。当按钮被点击时，我们在我们的组件类上调用一个名为`onButtonActivate`的方法，并传递迭代中的当前按钮标签。
- en: 'Let''s create `toggle.js` inside the `toggle` folder and implement the `component`
    class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`toggle`文件夹内创建`toggle.js`并实现`component`类：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Within our `toggle` component, we rely on the `buttonList` member to be an array
    of objects, as we are using this array within our template on an `NgFor` directive.
    The `buttonList` member is annotated to be an input property; this way, we can
    pass the array into the component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`toggle`组件中，我们依赖于`buttonList`成员是一个对象数组，因为我们正在使用这个数组在我们的模板中通过`NgFor`指令。`buttonList`成员被注释为输入属性；这样，我们可以将数组传递到组件中。
- en: For the `selectedButton` member, which holds the object of the `buttonList`
    array that is currently selected, we use a two-way data binding approach. This
    way, we can not only set the toggled button from the outside of the component,
    but also get notified via the `toggle` component, when a button is toggled in
    the UI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`selectedButton`成员，它持有当前选中的`buttonList`数组中的对象，我们使用双向数据绑定方法。这样，我们不仅可以从组件外部设置切换按钮，还可以通过`toggle`组件在UI中切换按钮时收到通知。
- en: Within the `onButtonActivate` function, we are setting the `selectedButton`
    member as well as triggering the event emitter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onButtonActivate`函数中，我们设置`selectedButton`成员并触发事件发射器。
- en: The `ngOnInit` method is actually called by Angular within the life cycle of
    directives and components. In the case where the `selectedButton` input property
    was not specified, we'll add a check and select the first button from the available
    button list. Since `selectedButton` as well as `buttonList` are instance fields
    that are also input properties at the same time, we need to wait for them to be
    initialized in order to execute this logic. It's important not to perform this
    initialization within the component constructor. The life cycle hook, `OnInit`,
    will be called after the directive input and output properties have been checked
    for the first time. It is invoked only once when the directive is constructed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`方法实际上是由Angular在指令和组件的生命周期内调用的。在`selectedButton`输入属性未指定的情况下，我们将添加一个检查并从可用的按钮列表中选择第一个按钮。由于`selectedButton`以及`buttonList`既是实例字段也是输入属性，我们需要等待它们初始化以执行此逻辑。重要的是不要在组件构造函数内执行此初始化。生命周期钩子`OnInit`将在指令输入和输出属性第一次检查后调用。它仅在指令构造时被调用一次。'
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Angular will call any life cycle hooks that have been implemented on your component
    automatically.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会自动调用您组件上实现的所有生命周期钩子。
- en: The next diagram illustrates the life cycle of an Angular component. Upon component
    construction, all the life cycle hooks will be called as per the order shown in
    the diagram, except the `OnDestroy` hook, which will be called upon component
    destruction.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图示说明了Angular组件的生命周期。在组件构造时，所有生命周期钩子将按照图示的顺序被调用，除了`OnDestroy`钩子，它将在组件销毁时被调用。
- en: 'Change detection will also start a subset of life cycle hooks, where there
    will be at least two cycles in the following order:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 变更检测也会启动生命周期钩子的一部分，其中将按照以下顺序至少有两个周期：
- en: '`doCheck`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doCheck`'
- en: '`afterContentChecked`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterContentChecked`'
- en: '`afterViewChecked`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterViewChecked`'
- en: '`onChanges` (if any changes are detected)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onChanges`（如果检测到任何更改）'
- en: A detailed description of the life cycle hooks and their purpose is available
    on the Angular documentation website at [https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关生命周期钩子和它们目的的详细描述可在Angular文档网站上找到，网址为[https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html](https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html)。
- en: '![Custom UI elements](img/image00307.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UI元素](img/image00307.jpeg)'
- en: An illustration of the life cycle of an Angular component
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件生命周期的示意图
- en: Recap
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this block, you learned how to build custom UI components that are generic
    and loosely coupled so that they can be used in other components as subcomponents.
    We also completed the following tasks:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，你学习了如何构建通用的、松散耦合的定制UI组件，以便它们可以作为子组件在其他组件中使用。我们还完成了以下任务：
- en: We created a subcomponent that is loosely coupled using output properties and
    event emitters.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个使用输出属性和事件发射器的松散耦合子组件。
- en: We learned what the `@Output` annotation is and how to use it to create output
    properties.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们学习了`@Output`注解是什么以及如何使用它来创建输出属性。
- en: We used the `@HostBinding` annotation to create property bindings declaratively
    from within our component class.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`@HostBinding`注解在组件类内部声明性地创建属性绑定。
- en: We used event bindings to link the behavior together from the view of a component.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用事件绑定将组件视图的行为链接在一起。
- en: We built two-way data binding using a binding shorthand.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用绑定简写构建了双向数据绑定。
- en: We learned about the working of the Angular component life cycle and how we
    can use the `OnInit` life cycle hook to initialize the component after the input
    and output have been processed for the first time.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们了解了Angular组件的生命周期以及如何使用`OnInit`生命周期钩子在输入和输出第一次处理完毕后初始化组件。
- en: Filtering tasks
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤任务
- en: This is the last building block of this chapter. We have already learned a lot
    about building basic components and how to compose them together in order to form
    larger components. In the previous building block, we created generic UI components
    that could be used in other components. In this topic, we will use the toggle
    button component not only to create a filter for our task list, but also to improve
    the way we receive and store tasks by using data services.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一个构建块。我们已经学习了大量关于构建基本组件以及如何将它们组合在一起以形成更大组件的知识。在前一个构建块中，我们创建了可以在其他组件中使用的通用UI组件。在本主题中，我们将使用切换按钮组件不仅为我们的任务列表创建过滤器，而且通过使用数据服务来改进接收和存储任务的方式。
- en: Let's continue with another refactoring exercise. So far, we have stored our
    task list data directly within the `task-list` component, but let's change that
    here and use a service that will provide tasks for us.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行另一个重构练习。到目前为止，我们已经在`task-list`组件中直接存储了任务列表数据，但在这里让我们改变这一点，并使用一个将为我们提供任务的服务。
- en: Our service will still not use a database, but we'll get the task data out of
    our component. In order to use the service, we're making use of Angular's dependency
    injection for the first time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务仍然不会使用数据库，但我们将从组件中获取任务数据。为了使用服务，我们第一次使用了Angular的依赖注入。
- en: 'Let''s create a new file called `task-list-service.js` within the `lib/task-list`
    folder of our application:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序的`lib/task-list`文件夹中创建一个名为`task-list-service.js`的新文件：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've moved all our task data into the newly created service. In order to make
    our service class injectable, we need to decorate it with the `@Injectable` annotation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所有任务数据移动到新创建的服务中。为了使我们的服务类可注入，我们需要用`@Injectable`注解来装饰它。
- en: 'Let''s apply some changes to our `task-list` component and modify the `task-list.js`
    file within the `task-list` folder. The modified code in the file is highlighted
    in the following code excerpt:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`task-list`组件进行一些修改，并修改`task-list`文件夹内的`task-list.js`文件。文件中的修改代码在以下代码摘录中突出显示：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the import section of our module, we're going to import the task list service.
    We will use dependency injection to receive an instance of the `TaskListService`
    class within our component constructor. For this, we'll use a new annotation,
    which lets us specify the type we'd like to inject. The `Inject` decorator needs
    to be imported from the Angular core module in order to use the `@Inject` annotation.
    If you take a look at our constructor, you'll find that we're using the `@Inject`
    annotation there to specify what instance type we'd like to inject.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块的导入部分，我们将导入任务列表服务。我们将在组件构造函数中使用依赖注入来接收`TaskListService`类的实例。为此，我们将使用一个新的注解，它允许我们指定我们想要注入的类型。为了使用`@Inject`注解，`Inject`装饰器需要从Angular核心模块中导入。如果你查看我们的构造函数，你会发现我们正在那里使用`@Inject`注解来指定我们想要注入的实例类型。
- en: In addition to the `@Inject` annotation on the constructor, we need one last
    thing to make the injection work. We need to register `TaskListService` as a provider
    within the `providers` property of our `@Component` annotation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数上的`@Inject`注解外，我们还需要最后一件事来使注入工作。我们需要将`TaskListService`注册为`@Component`注解的`providers`属性中的一个提供者。
- en: Now we get the `TaskListService` injected when the directive is constructed,
    and we can store a reference to it inside an instance field.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到在指令构造时注入的`TaskListService`，我们可以在实例字段中存储对其的引用。
- en: Within the constructor of the component, we also want to store a list of states
    the task status filter can have. This list will also serve as input for our toggle
    button list. If you recall the input properties on our toggle button, we have
    a `buttonList` input that accepts a list of button labels. To store the currently
    selected filter type, we use an instance field called `selectedTaskFilter`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的构造函数中，我们还想存储任务状态过滤器可以具有的状态列表。此列表也将作为切换按钮列表的输入。如果你还记得我们的切换按钮的输入属性，我们有一个接受按钮标签列表的`buttonList`输入。为了存储当前选定的过滤器类型，我们使用一个名为`selectedTaskFilter`的实例字段。
- en: The last piece that we need to add to our `task-list` component is the method,
    `getFilteredTasks`. We no longer need to store the task list directly within an
    instance field, and tasks should only be received within the component using this
    method. The logic inside the method checks the `selectedTaskFilter` property and
    returns a filtered list that meets this condition.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到`task-list`组件中的最后一部分是`getFilteredTasks`方法。我们不再需要在实例字段中直接存储任务列表，任务应该只通过此方法在组件中接收。方法内部的逻辑检查`selectedTaskFilter`属性，并返回满足此条件的过滤列表。
- en: Since we want to use the toggle button component that we've created within the
    previous topic to create a filter button list, we will need to import the toggle
    component within the import section and also add the `Toggle` class to our `directives`
    property. Now we can use the toggle component within the template of our `task-list`
    component.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要使用在前一个主题中创建的切换按钮组件来创建一个过滤器按钮列表，因此我们需要在导入部分导入切换组件，并将`Toggle`类添加到我们的`directives`属性中。现在我们可以在`task-list`组件的模板中使用切换组件。
- en: 'Okay, that''s all we are going to change in our component implementation. We
    want to change our view template though to use the filtered task list coming from
    the data service and show a toggle button list to activate the different filter
    types. Let''s open the template file, `task-list.html`, inside the `task-list`
    folder and modify it with the following content:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是我们将在组件实现中进行的所有更改。我们想要更改视图模板，以便使用来自数据服务的数据过滤任务列表，并显示一个切换按钮列表以激活不同的过滤器类型。让我们打开位于`task-list`文件夹中的模板文件`task-list.html`，并使用以下内容进行修改：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we've added the toggle component within the `directives` property of our
    `task-list` component, we can use it now within our view template. We bind the
    input property `buttonList` to `taskFilterList` that we store within our `task-list`
    component. Also, we're using two-way data binding to bind the `selectedButton`
    input property of the toggle button list to the `selectedTaskFilter` instance
    field of the task list. This way, we can not only update the selected task filer
    from our `task-list` component programmatically, but also allow a user to change
    the value using the toggle button list.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `task-list` 组件的 `directives` 属性中添加了切换组件，现在我们可以在视图模板中使用它。我们将输入属性 `buttonList`
    绑定到存储在 `task-list` 组件中的 `taskFilterList`。此外，我们使用双向数据绑定将切换按钮列表的 `selectedButton`
    输入属性绑定到任务列表的 `selectedTaskFilter` 实例字段。这样，我们不仅可以从 `task-list` 组件中以编程方式更新选定的任务过滤器，还可以允许用户通过切换按钮列表来更改值。
- en: Now we only need to make a small change to the `NgFor` directive that repeats
    our task elements within the task list. Since we need to access the tasks of the
    `task-list` component with the `getFilteredTasks` method now, we also need to
    use that method within our repeater expression.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要对重复任务列表中的任务元素的 `NgFor` 指令进行微小修改。由于我们现在需要使用 `getFilteredTasks` 方法访问 `task-list`
    组件的任务，我们还需要在我们的重复表达式中使用该方法。
- en: 'That''s it already, congratulations! You''ve successfully added a filtering
    mechanism to your task list by reusing the toggle component that we created in
    the previous topic. You can now start your live server (using the `live-server`
    command) and should see a fully functional task list where you can enter new tasks
    and also filter the task list:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了，恭喜！你已经成功通过重用我们在前一个主题中创建的切换组件，为你的任务列表添加了过滤机制。你现在可以启动你的实时服务器（使用 `live-server`
    命令），应该会看到一个功能齐全的任务列表，你可以输入新任务并过滤任务列表：
- en: '![Filtering tasks](img/image00308.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![过滤任务](img/image00308.jpeg)'
- en: Screenshot of the task list with the newly added toggle button component for
    filtering the task state
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 新增切换按钮组件的截图，用于过滤任务状态
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a lot of new concepts on building UI-component-based
    applications with Angular. Also, we built the core component of our task management
    application, which is the task list itself. You learned about the concept of input
    and output properties and how to use them to build two-way data binding.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用 Angular 构建基于 UI 组件的应用程序的大量新概念。我们还构建了我们任务管理应用程序的核心组件，即任务列表本身。你了解了输入和输出属性的概念以及如何使用它们来构建双向数据绑定。
- en: We also covered the basics of the Angular component life cycle and how to use
    life cycle hooks to execute post initialization steps.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了 Angular 组件生命周期的基本知识以及如何使用生命周期钩子来执行初始化后的步骤。
- en: As the last step, we integrated a toggle button list component within our task
    list to filter the task states. We refactored our `task-list` component to use
    a service in order to obtain task data. For this, we used Angular's dependency
    injection.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们在任务列表中集成了切换按钮列表组件以过滤任务状态。我们将 `task-list` 组件重构以使用服务来获取任务数据。为此，我们使用了
    Angular 的依赖注入。
