- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introduction to TypeScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 简介
- en: As we learned in the previous chapter, when we built our very first Angular
    application, the code of an Angular project is written in TypeScript. Writing
    in TypeScript and leveraging its static typing gives us a remarkable advantage
    over other scripting languages. This chapter is not a thorough overview of the
    TypeScript language. Instead, we’ll focus on the core elements that will be useful
    for this book. As we will see very soon, having sound knowledge of these mechanisms
    is paramount to understanding how dependency injection works in Angular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，当我们构建我们的第一个 Angular 应用程序时，Angular 项目的代码是用 TypeScript 编写的。使用 TypeScript
    编写代码并利用其静态类型给我们带来了与其他脚本语言相比的显著优势。本章不是对 TypeScript 语言的全面概述。相反，我们将关注对本书有用的核心元素。很快我们就会看到，对这些机制有扎实的知识对于理解
    Angular 中的依赖注入工作至关重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: JavaScript essentials
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 基础知识
- en: What is TypeScript?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 TypeScript？
- en: Getting started with TypeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 TypeScript
- en: We will first refresh our knowledge of JavaScript by revisiting some essential
    features related to TypeScript, such as functions and classes. We will then investigate
    the background of TypeScript and the rationale behind its creation. We will also
    learn how to code and execute TypeScript code. We will emphasize the typing system,
    which is the main advantage of TypeScript, and learn how to use it to create basic
    types and interfaces.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过回顾与 TypeScript 相关的一些基本特性来刷新我们对 JavaScript 的知识，例如函数和类。然后，我们将研究 TypeScript
    的背景及其创建的原理。我们还将学习如何编写和执行 TypeScript 代码。我们将强调类型系统，这是 TypeScript 的主要优势，并学习如何使用它来创建基本类型和接口。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: '**GitHub** : [https://github.com/PacktPublishing/Learning-Angular-Fifth-Edition/tree/main/ch02](https://github.com/PacktPublishing/Learning-Angular-Fifth-Edition/tree/main/ch02
    )'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub** : [https://github.com/PacktPublishing/Learning-Angular-Fifth-Edition/tree/main/ch02](https://github.com/PacktPublishing/Learning-Angular-Fifth-Edition/tree/main/ch02
    )'
- en: '**Node.js** : [https://nodejs.org](https://nodejs.org )'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js** : [https://nodejs.org](https://nodejs.org )'
- en: '**Git** : [https://git-scm.com](https://git-scm.com )'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git** : [https://git-scm.com](https://git-scm.com )'
- en: '**VSCode** : [https://code.visualstudio.com](https://code.visualstudio.com
    )'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VSCode** : [https://code.visualstudio.com](https://code.visualstudio.com
    )'
- en: JavaScript essentials
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 基础知识
- en: 'JavaScript is a programming language that contains many features for building
    web applications. In this section, we will revisit and refresh our knowledge of
    some of the most basic ones as they are directly correlated with TypeScript and
    Angular development. TypeScript is a syntactic superset of JavaScript, meaning
    that it adds features such as types, interfaces, and generics. We will look at
    the following JavaScript features in more detail:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种包含许多用于构建 Web 应用的特性的编程语言。在本节中，我们将回顾并刷新我们对一些最基本特性的知识，因为它们与 TypeScript
    和 Angular 开发直接相关。TypeScript 是 JavaScript 的语法定义超集，这意味着它添加了诸如类型、接口和泛型等特性。我们将更详细地查看以下
    JavaScript 特性：
- en: Variable declaration
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明
- en: Function parameters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数
- en: Arrow functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Optional chaining
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选链
- en: Nullish coalescing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值合并
- en: Classes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Modules
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: 'You can run all the code samples in this section in the following ways:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式运行本节中的所有代码示例：
- en: Enter the code in a browser console window
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器控制台窗口中输入代码
- en: Type the code in a JavaScript file and use Node.js to execute it
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 文件中键入代码，并使用 Node.js 来执行它
- en: If you are comfortable with these features, you can skip directly to the *What
    is TypeScript?* section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉这些特性，你可以直接跳转到 *什么是 TypeScript？* 部分。
- en: Variable declaration
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'Traditionally, JavaScript developers have used the keyword `var` to declare
    objects, variables, and other artifacts. The reason was that the old semantics
    of the language only had a function scope where variables were unique within its
    context:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，JavaScript 开发者使用关键字 `var` 来声明对象、变量和其他实体。原因是该语言的老式语义只有函数作用域，其中变量在其上下文中是唯一的：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding function, no other variable can be declared as `x` inside
    its body. If you do declare one, then you effectively redefine it. However, there
    are cases in which scoping is not applied, such as in loops:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，其体内不能声明其他变量作为 `x`。如果你声明了一个，那么你实际上是在重新定义它。然而，在某些情况下，作用域不适用，例如在循环中：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding snippet, the `x` variable outside the loop will not affect
    the `x` variable inside because they have a different scope. To overcome the scope
    limitation, JavaScript introduced the `let` keyword:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，循环外部的 `x` 变量不会影响循环内部的 `x` 变量，因为它们有不同的作用域。为了克服作用域限制，JavaScript 引入了
    `let` 关键字：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `let` keyword allows us to change the reference of a variable multiple times
    in the code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 关键字允许我们在代码中多次更改变量的引用。'
- en: 'Another way to define variables in JavaScript is the `const` keyword, which
    indicates that a variable should never change. As a code base grows, changes may
    happen by mistake, which can be costly. The `const` keyword can prevent these
    types of mistakes. Consider the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中定义变量的另一种方式是 `const` 关键字，它表示变量不应该改变。随着代码库的增长，可能会发生错误，这可能会造成损失。`const`
    关键字可以防止这类错误。考虑以下代码片段：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we try to execute it, it will throw the following error message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试执行它，将会抛出以下错误信息：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding error will come up only at the top level. You need to be aware
    of this if you declare objects as constants, like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误只会在顶层出现。如果你声明对象为常量，比如这样，你需要注意这一点：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Declaring the `product` variable as a constant does not prevent the entire
    object but rather its reference from being edited. So, the preceding code is valid.
    If we try to change the reference of the variable, we will get the same type of
    error as before:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 声明 `product` 变量为常量不会阻止整个对象被编辑，而是阻止其引用被编辑。因此，前面的代码是有效的。如果我们尝试更改变量的引用，我们将得到与之前相同的错误：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is preferable to use the `const` keyword when we are sure that the properties
    of an object will not change during its lifetime because it prevents the object
    from accidentally changing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确信一个对象的属性在其生命周期内不会改变时，最好使用 `const` 关键字，因为它可以防止对象意外更改。
- en: 'When we want to combine variables, we can use the **spread parameter** syntax.
    A spread parameter uses the ellipsis ( `…` ) to expand the values of a variable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要合并变量时，我们可以使用 **扩展参数** 语法。扩展参数使用省略号（`…`）来展开变量的值：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding snippet, we combine the `categories` array and the `category`
    item to create a new array. The `categories` array still contains two items, whereas
    the new array contains three. The current behavior is called **immutability**
    , which means not changing a variable but creating a new one that comes from the
    original.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将 `categories` 数组与 `category` 项目合并，以创建一个新的数组。`categories` 数组仍然包含两个项目，而新的数组包含三个。当前的行为称为
    **不可变性**，这意味着不更改变量，而是创建一个新的变量，该变量来自原始变量。
- en: An object is not immutable if its properties can be changed or its properties
    are an object whose properties can be changed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象的属性可以被更改，或者其属性是一个其属性可以被更改的对象，那么这个对象就不是不可变的。
- en: 'We can also use a spread parameter on objects:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在对象上使用扩展参数：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding snippet, we didn’t change the original `product` object but
    created a merge between the two. The value of the `newProduct` object will be:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们没有更改原始的 `product` 对象，而是创建了两个对象之间的合并。`newProduct` 对象的值将是：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `newProduct` object takes the properties from the `product` object, adds
    new values on top of it, and replaces the existing ones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`newProduct` 对象从 `product` 对象中获取属性，在其之上添加新的值，并替换现有的值。'
- en: Function parameters
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: Functions in JavaScript are the processing machines we use to analyze input,
    digest information, and apply the necessary transformations to data. They use
    parameters to provide data for transforming the state of our application or returning
    an output that will be used to shape our application’s business logic or user
    interactivity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的函数是我们用来分析输入、消化信息并对数据进行必要转换的处理机。它们使用参数来提供数据以转换我们应用程序的状态或返回一个将被用来塑造应用程序的业务逻辑或用户交互性的输出。
- en: 'We can declare a function to accept default parameters so that the function
    assumes a default value when it’s not explicitly passed upon execution:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个函数以接受默认参数，这样函数在执行时如果没有明确传递，就会假定一个默认值：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we do not pass a value for the `quantity` parameter while calling the function,
    we will get a `product` object with `qty` set to `1` .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用函数时没有为 `quantity` 参数传递值，我们将得到一个 `qty` 设置为 `1` 的 `product` 对象。
- en: Default parameters must be defined after all *required* parameters in the function
    signature.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数必须在函数签名中的所有 **必需** 参数之后定义。
- en: 'One significant advantage of JavaScript flexibility when defining functions
    is accepting an unlimited, non-declared array of parameters called **rest parameters**
    . Essentially, we can define an additional parameter at the end of the arguments
    list prefixed by an ellipsis ( `…` ):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，JavaScript 的灵活性具有一个显著的优势，即接受一个无限的非声明参数数组，称为**剩余参数**。本质上，我们可以在参数列表的末尾定义一个额外的参数，该参数由省略号（`…`）前缀：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding function, we use the `join` method to create a comma-separated
    string from the `categories` parameter. We pass each parameter separately when
    calling the function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们使用 `join` 方法从 `categories` 参数创建一个以逗号分隔的字符串。我们调用函数时分别传递每个参数：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rest parameters are beneficial when we don’t know how many arguments will be
    passed as parameters. The `name` property is also set using another useful feature
    of the JavaScript language. Instead of setting the property in the `product` object
    explicitly, we used the property name directly. The following snippet is equivalent
    to the initial declaration of the `addProduct` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不知道将传递多少参数时，剩余参数非常有用。`name` 属性也是使用 JavaScript 语言的一个有用特性设置的。我们不是在 `product`
    对象中显式设置属性，而是直接使用属性名。以下代码片段与 `addProduct` 函数的初始声明等效：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The shorthand syntax for assigning property values can be used only when the
    parameter name matches the property name of an object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数名称与对象的属性名称匹配时，可以使用简写语法来分配属性值。
- en: Arrow functions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'In JavaScript, we can create functions in an alternate way called **arrow functions**
    . The purpose of an arrow function is to simplify the general function syntax
    and provide a bulletproof way to handle the function scope, which is traditionally
    handled by the `this` object. Consider the following example, which calculates
    a product discount given its price:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以以另一种方式创建函数，称为**箭头函数**。箭头函数的目的是简化通用函数语法，并提供一种安全处理函数作用域的方法，这在传统上是由
    `this` 对象处理的。考虑以下示例，它根据产品的价格计算产品折扣：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code does not have a `function` keyword, and the function body
    is defined by an arrow ( `=>` ). Arrow functions can be simplified further using
    the following best practices:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码没有 `function` 关键字，函数体由箭头（`=>`）定义。箭头函数可以通过以下最佳实践进一步简化：
- en: Omit the parentheses in the function parameters when the signature contains
    one parameter only.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当函数签名只有一个参数时，可以省略函数参数中的括号。
- en: Omit the curly braces in the function body and the `return` keyword if the function
    has only one statement.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数体只有一个语句，则可以省略花括号和 `return` 关键字。
- en: 'The resulting function will look much simpler and easier to read:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果函数将看起来更简单，更容易阅读：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s explain now how arrow functions are related to scope handling. The value
    of the `this` object can point to a different context, depending on where we execute
    a function. When we use it inside a callback, we lose track of the upper context,
    which usually leads us to use conventions such as assigning its value to an external
    variable. Consider the following function, which logs a product name using the
    native `setTimeout` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释箭头函数是如何与作用域处理相关的。`this` 对象的值可以指向不同的上下文，这取决于我们在哪里执行函数。当我们在一个回调函数内部使用它时，我们会失去上层上下文，这通常会导致我们使用诸如将其值赋给外部变量之类的约定。考虑以下函数，它使用原生的
    `setTimeout` 函数记录产品名称：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Execute the `getName` function using the following snippet and observe the
    console output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段执行 `getName` 函数，并观察控制台输出：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding snippet will not print the `Monitor` product name as expected
    because our code modifies the scope of the `this` object when evaluating the function
    inside the `setTimeout` callback. To fix it, convert the `setTimeout` function
    to use an arrow function instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段不会按预期打印出 `Monitor` 产品的名称，因为我们在 `setTimeout` 回调内部评估函数时修改了 `this` 对象的作用域。为了修复它，将
    `setTimeout` 函数转换为使用箭头函数：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our code is now simpler and we can use the function scope safely.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码现在更简单，我们可以安全地使用函数作用域。
- en: Optional chaining
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选链
- en: 'Optional chaining is a powerful feature that can help us with refactoring and
    simplifying our code. In a nutshell, it can guide our code to ignore the execution
    of a statement unless a value has been provided somewhere in that statement. Let’s
    look at optional chaining with an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链是一个强大的功能，可以帮助我们重构和简化代码。简而言之，它可以在某个语句中某个值未被提供的情况下，引导我们的代码忽略该语句的执行。让我们通过一个示例来看看可选链：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding snippet, we define a `getOrder` function that returns the
    product of a particular order. Next, let’s fetch the value of the `product` property,
    making sure that an `order` exists before reading it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个`getOrder`函数，它返回特定订单的产品。接下来，让我们获取`product`属性的值，确保在读取之前存在`order`：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The previous snippet is a precautionary step in case our object has been modified.
    If we do not check the object and it has become `undefined` , JavaScript will
    throw an error. However, we can use optional chaining to improve the previous
    statement:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段是在我们的对象已被修改的情况下采取的预防措施。如果我们不检查对象并且它已经变为`undefined`，JavaScript将抛出一个错误。然而，我们可以使用可选链来改进之前的语句：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The character `?` after the `order` object ensures that the `product` property
    will be accessed only if the object has a value. Optional chaining also works
    in more complicated scenarios, such as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`对象后面的字符`?`确保只有当对象有值时才会访问`product`属性。可选链在更复杂的场景中也同样适用，例如：'
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet, we also check if the `product` object has a value
    before accessing its `name` property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们也检查了`product`对象是否有值，然后再访问其`name`属性。
- en: Nullish coalescing
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值合并
- en: 'Nullish coalescing is related to providing a default value when a variable
    is not set. Consider the following example, which assigns a value to the `quantity`
    variable only if the `qty` variable exists:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并与在变量未设置时提供默认值相关。考虑以下示例，它只在`qty`变量存在时才将值赋给`quantity`变量：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The previous statement is called a **ternary operator** and operates like a
    conditional statement. If the `qty` variable does not have a value, the `quantity`
    variable will be initialized to the default value of `1` . We can rewrite the
    previous expression using nullish coalescing as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的语句被称为**三元运算符**，它的工作方式类似于条件语句。如果`qty`变量没有值，`quantity`变量将被初始化为默认值`1`。我们可以使用空值合并来重写之前的表达式：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Nullish coalescing helps us make our code readable and smaller.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并有助于使我们的代码更易读且更简洁。
- en: Classes
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'JavaScript classes allow us to structure our application code and create instances
    of each class. A class can have property members, a constructor, methods, and
    property accessors. The following code snippet illustrates what a class looks
    like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript类允许我们组织我们的应用程序代码并创建每个类的实例。一个类可以有属性成员、构造函数、方法和属性访问器。以下代码片段展示了类的外观：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The class statement wraps several elements that we can break down:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类语句封装了几个元素，我们可以将其分解：
- en: '**Member** : The `User` class contains the `firstName` , `lastName` , and `#isActive`
    members. Class members will only be accessible from within the class itself. Instances
    of the `User` class will have access only to the public properties `firstName`
    and `lastName` . The `#isActive` property will not be available because it is
    private, as denoted by the `#` character in front of the property name.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员**：`User`类包含`firstName`、`lastName`和`#isActive`成员。类成员只能从类本身内部访问。`User`类的实例将只能访问公共属性`firstName`和`lastName`。`#isActive`属性将不可用，因为它是一个私有属性，如属性名前的`#`字符所示。'
- en: '**Constructor** : The `constructor` is executed when we create an instance
    of the class. It is usually used to initialize the class members inside it with
    the parameters provided in the signature. We can also provide default values for
    parameters such as the `isActive` parameter.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：当创建类的实例时执行`constructor`。它通常用于使用签名中提供的参数初始化类成员。我们还可以为参数如`isActive`参数提供默认值。'
- en: '**Method** : A method represents a function and may return a value, such as
    the `getFullname` method, which constructs the full name of a user. It can also
    be defined as private, similar to class members.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：方法代表一个函数，可以返回一个值，例如`getFullname`方法，它构建用户的完整名称。它也可以定义为私有，类似于类成员。'
- en: '**Property accessor** : A property accessor is defined by prefixing a method
    with the `set` keyword to make it writable and the `get` keyword to make it readable,
    followed by the property name we want to expose. The `active` method is a property
    accessor that returns the value of the `#isActive` member.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性访问器**：属性访问器是通过在方法前加上`set`关键字使其可写，加上`get`关键字使其可读，然后跟我们要公开的属性名来定义的。`active`方法是一个属性访问器，它返回`#isActive`成员的值。'
- en: 'A class can also extend members and functionality of other classes. We can
    make a class inherit from another by appending the `extends` keyword to the class
    definition followed by the class we want to inherit:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类还可以扩展其他类的成员和功能。我们可以通过在类定义中添加 `extends` 关键字并跟随后要继承的类来使一个类继承另一个类：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding snippet, the `Customer` class extends the `User` class, which
    exposes `firstName` and `lastName` properties. Any instance of the `Customer`
    class can use those properties by default. We can also override methods from the
    `User` class by appending a method with the same name. The `constructor` is required
    to call the `super` method, which points to the `constructor` of the `User` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Customer` 类扩展了 `User` 类，这暴露了 `firstName` 和 `lastName` 属性。`Customer`
    类的任何实例都可以默认使用这些属性。我们还可以通过添加具有相同名称的方法来覆盖 `User` 类的方法。`constructor` 方法需要调用 `super`
    方法，它指向 `User` 类的 `constructor`。
- en: Modules
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: As our applications scale and grow, there will be a time when we need to organize
    our code better and make it sustainable and reusable. Modules are a great way
    to accomplish these tasks, so let’s look at how they work and how we can implement
    them in our application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序规模和增长，将会有一个时刻我们需要更好地组织代码，并使其可持续和可重用。模块是实现这些任务的好方法，因此让我们看看它们是如何工作的，以及我们如何在应用程序中实现它们。
- en: In the preceding section, we learned how to work with classes. Having both classes
    in the same file is not scalable, and maintaining it won’t be easy. Imagine how
    much code you must process to make a simple change in one of the classes. Modules
    allow us to separate our application code into single files, enforcing the **Single
    Responsibility** **Pattern** ( **SRP** ). Each file is a different module concerned
    with a specific feature or functionality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用类。将两个类放在同一个文件中是不可扩展的，维护它也不会容易。想象一下，你必须处理多少代码才能在其中一个类中做简单的更改。模块允许我们将应用程序代码分离成单个文件，强制执行
    **单一职责模式**（**SRP**）。每个文件都是一个不同的模块，关注特定的功能或功能。
- en: A good indication to split a module into multiple files is when the module starts
    to occupy different domains. For example, a products module cannot contain logic
    for customers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块拆分为多个文件的良好迹象是当模块开始占据不同的领域时。例如，产品模块不能包含客户逻辑。
- en: 'Let’s refactor the code described in the previous section so that the `User`
    and `Customer` classes belong to separate modules:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构上一节中描述的代码，以便 `User` 和 `Customer` 类属于不同的模块：
- en: Open VSCode and create a new JavaScript file named `user.js` .
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VSCode 并创建一个名为 `user.js` 的新 JavaScript 文件。
- en: Enter the contents of the `User` class and add the `export` keyword in the class
    definition. The `export` keyword makes the module available to other modules and
    forms the public API of the module.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `User` 类的内容输入进去，并在类定义中添加 `export` 关键字。`export` 关键字使模块对其他模块可用，并形成模块的公共 API。
- en: Create a new JavaScript file named `customer.js` and add the contents of the
    `Customer` class. The `Customer` class cannot recognize the `User` class because
    they are in different files.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `customer.js` 的新 JavaScript 文件，并将 `Customer` 类的内容添加进去。`Customer` 类不能识别
    `User` 类，因为它们在不同的文件中。
- en: 'Import the `User` class into the `customer.js` file by adding the following
    statement at the top of the file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在文件顶部添加以下语句将 `User` 类导入到 `customer.js` 文件中：
- en: '[PRE27]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use the `import` keyword and the relative path of the module file without
    the extension to import the `User` class. If a module exports more than one artifact,
    we place them inside curly braces separated by a comma, such as:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `import` 关键字和模块文件的无扩展名相对路径来导入 `User` 类。如果一个模块导出多个工件，我们将它们放在大括号内，用逗号分隔，例如：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Exploring modules concludes our journey of the JavaScript essentials. In the
    following section, we will learn about TypeScript and how it helps us build web
    applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 探索模块结束了我们对 JavaScript 基础知识的旅程。在下一节中，我们将学习 TypeScript 以及它是如何帮助我们构建 Web 应用程序的。
- en: What is TypeScript?
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 TypeScript？
- en: Transforming small web applications into thick monolithic clients was impossible
    due to the limitations of earlier JavaScript versions. In a nutshell, large-scale
    JavaScript applications suffered from serious maintainability and scalability
    problems as soon as they grew in size and complexity. This issue became more relevant
    as new libraries and modules required seamless integration into our applications.
    The lack of proper mechanisms for interoperability led to cumbersome solutions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于早期 JavaScript 版本的限制，将小型网络应用程序转换为厚重的单体客户端是不可能的。简而言之，大规模 JavaScript 应用程序在规模和复杂性增加后，就面临着严重的可维护性和可扩展性问题。随着新库和模块需要无缝集成到我们的应用程序中，这个问题变得更加相关。缺乏适当的互操作性机制导致了繁琐的解决方案。
- en: To overcome those difficulties, Microsoft built a superset of the JavaScript
    language that would help build enterprise applications with a lower error footprint
    using static type checking, better tooling, and code analysis. TypeScript 1.0
    was introduced in 2014. It ran ahead of JavaScript, implemented the same features,
    and provided a stable environment for building large-scale applications. It introduced
    optional static typing through type annotations, thereby ensuring type checking
    at compile time and catching errors early in the development process. Its support
    for declaration files also enabled developers to describe the interface of their
    modules so that other developers could better integrate them into their code workflow
    and tooling.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些困难，微软构建了一个 JavaScript 超集，这将有助于使用静态类型检查、更好的工具和代码分析来构建具有较低错误足迹的企业应用程序。TypeScript
    1.0 于 2014 年推出。它领先于 JavaScript，实现了相同的功能，并为构建大规模应用程序提供了一个稳定的环境。它通过类型注解引入了可选的静态类型，从而确保了编译时的类型检查并在开发过程中早期捕捉到错误。它对声明文件的支持还使开发者能够描述他们模块的接口，以便其他开发者能够更好地将它们集成到他们的代码工作流程和工具中。
- en: The official TypeScript website can be reached at [https://www.typescriptlang.org](https://www.typescriptlang.org)
    . It contains extensive language documentation and a playground that gives us
    access to a quick tutorial to get up to speed with the language in no time. It
    includes some ready-made code examples that cover some of the most common traits
    of the language.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 [https://www.typescriptlang.org](https://www.typescriptlang.org) 访问官方
    TypeScript 网站。它包含了广泛的语言文档和一个游乐场，我们可以快速通过教程熟悉语言。它包含了一些现成的代码示例，涵盖了语言的一些最常见特性。
- en: As a superset of JavaScript, one of the main advantages of embracing TypeScript
    in your next project is the low entry barrier. If you know JavaScript, you are
    pretty much all set since all the additional features in TypeScript are optional.
    You can pick and introduce any of them to achieve your goal. Overall, there is
    a long list of solid arguments for using TypeScript in your next project, and
    all apply to Angular.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 JavaScript 的超集，在您的下一个项目中采用 TypeScript 的一大优势是低门槛。如果您了解 JavaScript，那么您基本上已经准备好了，因为
    TypeScript 中的所有附加功能都是可选的。您可以挑选并引入其中任何一项来实现您的目标。总的来说，使用 TypeScript 在您的下一个项目中有很多坚实的论据，并且这些论据都适用于
    Angular。
- en: 'Here is a short rundown of some of the advantages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些优势的简要概述：
- en: Annotating your code with types ensures the consistent integration of your different
    code units and improves code readability and comprehension.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型注释注释您的代码确保了您不同代码单元的一致集成，并提高了代码的可读性和理解性。
- en: The built-in type-checker analyzes your code at compile time and helps you prevent
    errors before executing your code.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的类型检查器在编译时分析您的代码，并帮助您在执行代码之前防止错误。
- en: The use of types ensures consistency across your application. Combined with
    the previous two, the overall code error footprint is minimized in the long run.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型确保了您应用程序的一致性。结合前两点，从长远来看，整体代码错误足迹得到了最小化。
- en: Interfaces ensure the smooth and seamless integration of your libraries in other
    systems and code bases.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口确保了您的库在其他系统和代码库中的平稳无缝集成。
- en: Language support across different IDEs is amazing, and you can benefit from
    features such as highlighting code, real-time type checking, and automatic compilation
    at no cost.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同 IDE 上的语言支持令人惊叹，您可以免费享受代码高亮、实时类型检查和自动编译等特性。
- en: The syntax is familiar to developers from other OOP-based backgrounds, such
    as Java, C#, and C++.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法对来自其他基于 OOP 的背景（如 Java、C# 和 C++）的开发者来说很熟悉。
- en: In the following section, we will learn how to develop and execute a TypeScript
    application. In Angular applications, we do not need to execute TypeScript code
    manually because it is automatically handled by the Angular CLI; however, it is
    good to know how it works under the hood.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何开发和执行 TypeScript 应用程序。在 Angular 应用程序中，我们不需要手动执行 TypeScript 代码，因为
    Angular CLI 会自动处理它；然而，了解其底层工作原理是很好的。
- en: Getting started with TypeScript
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 TypeScript
- en: 'The TypeScript language is an npm package that can be installed from the npm
    registry using the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 语言是一个可以从 npm 注册表安装的 npm 包，使用以下命令进行安装：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding command, we chose to install TypeScript globally in our system
    so that we can use it from any path in our development environment. Let’s see
    how we can use TypeScript through a simple example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们选择在系统中全局安装 TypeScript，这样我们就可以在开发环境的任何路径中使用它。让我们通过一个简单的示例来看看如何使用 TypeScript：
- en: Open VSCode and select **File** | **New File…** from the main menu options.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VSCode 并从主菜单选项中选择 **文件** | **新建文件…**。
- en: Enter `app.ts` in the **New File…** dialog and press *Enter* .
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新建文件…** 对话框中输入 `app.ts` 并按 *Enter* 键。
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_02_01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，屏幕截图，字体，行描述由自动创建](img/B21418_02_01.png)'
- en: 'Figure 2.1: New File… dialog'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：新建文件… 对话框
- en: As we have already learned, TypeScript files have a `.ts` extension.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学到的，TypeScript 文件具有 `.ts` 扩展名。
- en: Select the path where you want to create the new file. VSCode will then open
    that file inside the editor.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要创建新文件的路径。VSCode 将在编辑器中打开该文件。
- en: 'Type the following snippet into the `app.ts` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段输入到 `app.ts` 文件中：
- en: '[PRE30]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Although we have created a TypeScript file, the preceding snippet is valid JavaScript
    code. Recall that TypeScript is a superset of JavaScript that provides syntactic
    sugar through its typing system. However, writing plain JavaScript code with TypeScript
    does not give us any clear benefit.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经创建了一个 TypeScript 文件，但上述代码片段是有效的 JavaScript 代码。回想一下，TypeScript 是 JavaScript
    的超集，它通过其类型系统提供语法糖。然而，使用 TypeScript 编写纯 JavaScript 代码并不会给我们带来任何明显的优势。
- en: 'Open a terminal window and run the following command to compile the TypeScript
    file into JavaScript:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口并运行以下命令以将 TypeScript 文件编译成 JavaScript：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding command initiates a process called **transpilation** performed
    by the `tsc` executable, a compiler that is at the core of the TypeScript language.
    We need to compile TypeScript code into JavaScript because browsers do not currently
    support TypeScript out of the box.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令启动了一个名为 **编译** 的过程，由 `tsc` 可执行文件执行，它是 TypeScript 语言的核心理念。我们需要将 TypeScript
    代码编译成 JavaScript，因为浏览器目前不支持 TypeScript。
- en: Angular uses a compiler that utilizes the TypeScript compiler under the hood
    to build Angular applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用一个编译器，该编译器在底层使用 TypeScript 编译器来构建 Angular 应用程序。
- en: The TypeScript compiler supports extra configuration options that we can pass
    to the `tsc` executable through the terminal window or a configuration file. The
    complete list of available compiler options can be found at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    .
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器支持额外的配置选项，我们可以通过终端窗口或配置文件将它们传递给 `tsc` 可执行文件。完整的编译器选项列表可以在 [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html)
    找到。
- en: 'The transpilation process will create an `app.js` file in the same folder as
    the TypeScript file. The new file will contain the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译过程将在 TypeScript 文件所在的同一文件夹中创建一个 `app.js` 文件。新文件将包含以下代码：
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since we have not used any specific TypeScript feature yet, the preceding snippet
    looks almost identical to the original except for the variable declaration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未使用任何特定的 TypeScript 功能，上述代码片段几乎与原始代码相同，除了变量声明。
- en: 'The transpilation process replaced the `const` keyword with the `var` keyword
    because the TypeScript compiler uses an old JavaScript version by default. We
    can change that by specifying a `target` in the `tsc` command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译过程将 `const` 关键字替换为 `var` 关键字，因为 TypeScript 编译器默认使用旧的 JavaScript 版本。我们可以通过在
    `tsc` 命令中指定 `target` 来更改这一点：
- en: '[PRE33]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding command, we specified `es2022` , which represents the most
    recent version of the JavaScript language at the time of writing. Angular applications
    that we will build throughout this book also target the same JavaScript version
    by default.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们指定了 `es2022`，这代表了撰写时的 JavaScript 语言的最新版本。我们将在本书中构建的 Angular 应用程序默认也针对相同的
    JavaScript 版本。
- en: 'Since we will use the latest JavaScript version in the rest of this chapter,
    let’s define the `target` option using a TypeScript configuration file. Create
    a file named `tsconfig.json` in the current folder and add the following contents:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在本章的其余部分使用最新的 JavaScript 版本，让我们使用 TypeScript 配置文件来定义 `target` 选项。在当前文件夹中创建一个名为
    `tsconfig.json` 的文件，并添加以下内容：
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can find more options for the TypeScript configuration file at [https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)
    .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)
    找到 TypeScript 配置文件的更多选项。
- en: Run the command `tsc` in a terminal window to verify that the output JavaScript
    file remains unchanged.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中运行 `tsc` 命令以验证输出 JavaScript 文件保持不变。
- en: When we run the `tsc` command without options, it will compile all TypeScript
    files in the current folder using the options from the configuration file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不带选项运行 `tsc` 命令时，它将使用配置文件中的选项编译当前文件夹中的所有 TypeScript 文件。
- en: The TypeScript code we have written so far does not use TypeScript-specific
    features. In the following section, we will learn how to use the typing system,
    which is the most powerful and essential feature of the TypeScript language.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止编写的 TypeScript 代码没有使用 TypeScript 特定功能。在下一节中，我们将学习如何使用类型系统，这是 TypeScript
    语言最强大和最基本的功能。
- en: Types
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: Working with TypeScript or any other coding language means working with data,
    and this data can represent different sorts of content, called **types** . Types
    are used to represent the fact that data can be text, an integer value, or an
    array of these value types, among others.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript 或任何其他编程语言意味着处理数据，这些数据可以代表不同类型的内容，称为 **类型**。类型用于表示数据可以是文本、整数值或这些值类型的数组等。
- en: Types disappear during transpilation and are not included in the final JavaScript
    code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在编译过程中消失，并且不包括在最终的 JavaScript 代码中。
- en: You may have already encountered types in JavaScript since we have always worked
    implicitly with them. In JavaScript, any given variable could assume (or return,
    in the case of functions) any value. Sometimes, this leads to errors and exceptions
    in our code because of type collisions between what our code returned and what
    we expected to return type-wise. However, statically typing our variables gives
    our IDE and us a good picture of what kind of data we should find in each code
    instance. It becomes an invaluable way to help debug our applications at compile
    time before the code is executed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在 JavaScript 中遇到了类型，因为我们总是隐式地使用它们。在 JavaScript 中，任何给定的变量都可能假设（或返回，在函数的情况下）任何值。有时，这会导致我们的代码中出现错误和异常，因为代码返回的类型与我们期望返回的类型之间发生类型冲突。然而，静态类型化我们的变量为我们和我们的
    IDE 提供了一个很好的了解，在每个代码实例中我们应该找到什么类型的数据。这成为了一种在代码执行之前在编译时帮助我们调试应用程序的无价方式。
- en: String
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'One of the most widely used primitive types is the `string` , which populates
    a variable with text:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的原始类型之一是 `string`，它用文本填充变量：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The type is defined by adding a colon and the type name next to the variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是通过在变量旁边添加冒号和类型名称来定义的。
- en: Boolean
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔
- en: 'The `boolean` type defines a variable that can have a value of either `true`
    or `false` :'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型定义了一个变量，它可以具有 `true` 或 `false` 的值：'
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result of a `boolean` variable represents the fulfillment of a conditional
    statement.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 变量的结果是条件语句的满足。'
- en: Number
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字
- en: 'The `number` type is probably the other most widely used primitive data type,
    along with `string` and `boolean` :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 类型可能是除 `string` 和 `boolean` 之外最广泛使用的原始数据类型：'
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use the `number` type to define a floating-point number and hexadecimal,
    decimal, binary, and octal literals.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `number` 类型来定义浮点数和十六进制、十进制、二进制和八进制字面量。
- en: Array
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'The **array** type defines a list of items that contain a certain type only.
    Handling exceptions that arise from errors, such as assigning wrong member types
    in a list, can now be easily avoided with this type. We can define arrays using
    the square bracket syntax or the `Array` keyword:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**类型定义了一个只包含特定类型的项的列表。现在，我们可以通过这种类型轻松避免由错误引起的异常，例如在列表中分配错误的成员类型。我们可以使用方括号语法或`Array`关键字来定义数组：'
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Agreeing with your team on either syntax and sticking with it during application
    development is advisable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发期间，与团队就语法达成一致并坚持使用它是明智的。
- en: If we try to add a new item to the `categories` array with a type other than
    `string` , TypeScript will throw an error, ensuring our typed members remain consistent
    and that our code is error-free.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试向`categories`数组添加一个类型不是`string`的新项，TypeScript将抛出一个错误，确保我们的类型化成员保持一致，我们的代码无错误。
- en: any
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`any`'
- en: In all preceding cases, typing is optional because TypeScript is smart enough
    to infer the data types of variables from their values with a certain level of
    accuracy.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的情况下，类型是可选的，因为TypeScript足够智能，可以从变量的值中推断出数据类型，具有一定的准确性。
- en: Letting the typing system infer the types is very important, instead of typing
    it manually. The type system is never wrong, but the developer can be.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让类型系统推断类型非常重要，而不是手动进行类型化。类型系统永远不会出错，但开发者可能会出错。
- en: 'However, if it is not possible, the typing system will automatically assign
    the dynamic `any` type to the loosely typed data at the cost of reducing type
    checking to a bare minimum. Additionally, we can add the `any` type in our code
    manually when it is hard to infer the data type from the information we have at
    any given point. The `any` type includes all the other existing types, so we can
    type any data value with it and assign any value to it later:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果不可能，类型系统将自动将动态的`any`类型分配给弱类型数据，代价是降低类型检查到最低限度。此外，当从任何给定点的信息中难以推断数据类型时，我们可以在代码中手动添加`any`类型。`any`类型包括所有其他现有类型，因此我们可以用它可以对任何数据值进行类型化，并在以后将其赋值：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: TypeScript contains another type, similar to the `any` type, called `unknown`
    . A variable of the `unknown` type can have a value of any type. The main difference
    is that TypeScript will not let us apply arbitrary operations to unknown values,
    such as calling a method, unless we perform type checking first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript包含另一种类型，类似于`any`类型，称为`unknown`。`unknown`类型的变量可以具有任何类型的值。主要区别在于，除非我们首先进行类型检查，否则TypeScript不会让我们对未知值执行任意操作，例如调用方法。
- en: However, with great power comes great responsibility. If we bypass the convenience
    of static type checking, we open the door to type errors when piping data through
    our application. It is up to us to ensure type safety throughout our application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，权力越大，责任越大。如果我们绕过静态类型检查的便利性，我们就会打开在通过我们的应用程序传输数据时出现类型错误的门。确保我们应用程序中的类型安全取决于我们。
- en: Custom types
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义类型
- en: 'In TypeScript, you can come up with your own type if you need to by using the
    `type` keyword in the following way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，如果你需要，可以通过以下方式使用`type`关键字来自定义类型：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then create a variable of a specific type as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个特定类型的变量，如下所示：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code is perfectly valid as `computing` is one of the allowed values
    and works as intended. Custom types are an excellent way to add types with a finite
    number of allowed values.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码作为`computing`是允许的值之一，并且按预期工作。自定义类型是添加有限数量允许值的类型的绝佳方式。
- en: 'When we want to create a custom type from an object, we can use the `keyof`
    operator. The `keyof` operator enables us to iterate over the properties of an
    object and extract them into a new type:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从一个对象创建一个自定义类型时，我们可以使用`keyof`运算符。`keyof`运算符使我们能够遍历对象的属性并将它们提取到一个新类型中：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding snippet, the `CategoryType` produced the same result as the
    `Categories` type. We will learn how we can use the `keyof` operator to iterate
    over object properties dynamically in *Chapter 4* , *Enriching Applications Using
    Pipes and Directives* .
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`CategoryType`产生的结果与`Categories`类型相同。我们将学习如何在第4章中动态地使用`keyof`运算符遍历对象属性，即*使用管道和指令丰富应用程序*。
- en: The typing system of TypeScript is mainly used to annotate JavaScript code with
    types. It improves the developer experience by providing intelliSense and preventing
    bugs early in development. In the following section, we will learn more about
    adding type annotations in functions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的类型系统主要用于用类型注解 JavaScript 代码。它通过提供智能感应和防止开发早期出现的错误来提高开发者体验。在下一节中，我们将学习更多关于在函数中添加类型注解的内容。
- en: Functions
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: Functions in TypeScript are not that different from regular JavaScript, except
    that, like everything else in TypeScript, they can be annotated with static types.
    Thus, they improve the compiler by providing the information it expects in their
    signature and the data type it aims to return, if any.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中的函数与普通 JavaScript 函数没有太大区别，除了像 TypeScript 中的其他一切一样，它们可以用静态类型进行注解。因此，它们通过在它们的签名中提供编译器期望的信息以及它们旨在返回的数据类型（如果有的话）来改进编译器。
- en: 'The following example showcases how a regular function is annotated in TypeScript:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在 TypeScript 中注解普通函数：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding snippet, we annotated the returned value of the function by
    adding the `string` type to the function declaration. We can also add types in
    function parameters, such as:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过在函数声明中添加 `string` 类型来注解了函数的返回值。我们也可以在函数参数中添加类型，例如：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding snippet, we annotated the parameters declared in the function
    signature, which makes sense since the compiler will want to check whether the
    data provided holds the correct type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们注解了在函数签名中声明的参数，这是有意义的，因为编译器将想要检查提供的数据是否具有正确的类型。
- en: As mentioned in the previous section, the TypeScript compiler is smart enough
    to infer types when no annotation is provided. In both preceding functions, we
    could omit the type because the compiler could infer it from the arguments provided
    and the returned statements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，TypeScript 编译器足够智能，能够在没有提供注解的情况下推断类型。在上述两个函数中，我们可以省略类型，因为编译器可以从提供的参数和返回语句中推断出它。
- en: 'When a function does not return a type, we can annotate it using the `void`
    type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数不返回类型时，我们可以使用 `void` 类型来注解它：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have already learned how to use default and rest parameters in JavaScript
    functions. TypeScript extends functions’ capabilities by introducing optional
    parameters. Parameters are defined as optional by adding the character `?` after
    the parameter name:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在 JavaScript 函数中使用默认和剩余参数。TypeScript 通过引入可选参数扩展了函数的功能。通过在参数名称后添加字符
    `?` 来定义可选参数：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding function, we have defined `quantity` as an optional parameter.
    We have also used the nullish coalescing syntax to set the `qty` property of the
    `product` object if `quantity` is not passed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们将 `quantity` 定义为可选参数。我们还使用了空值合并运算符来设置 `product` 对象的 `qty` 属性，如果未传递
    `quantity`。
- en: We can invoke the `addToCart` function by passing only the `productId` parameter
    or both.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过仅传递 `productId` 参数或两者都传递来调用 `addToCart` 函数。
- en: Optional parameters should be placed last in a function signature.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数应该放在函数签名中的最后。
- en: We have already learned how JavaScript classes can help us structure our application
    code. In the following section, we will see how to use them in TypeScript to improve
    our application further.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 JavaScript 类来帮助我们组织应用程序代码。在下一节中，我们将看到如何在 TypeScript 中使用它们来进一步改进我们的应用程序。
- en: Classes
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: 'Consider the `User` class that we defined in the `user.js` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在 `user.js` 文件中定义的 `User` 类：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will take simple, small steps to add types throughout the class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取简单、小步骤来在整个类中添加类型：
- en: Convert the file to TypeScript by renaming it `user.ts` .
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件重命名为 `user.ts` 以将其转换为 TypeScript。
- en: 'Add the following types to all class properties:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有类属性添加以下类型：
- en: '[PRE48]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding snippet, we also used the `private` modifier to define the
    `isActive` property as private.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们还使用了 `private` 修饰符来定义 `isActive` 属性为私有。
- en: 'Modify the `constructor` by adding types to parameters:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为参数添加类型来修改 `constructor`：
- en: '[PRE49]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Alternatively, we could omit class properties and have the `constructor` create
    them automatically by declaring parameters as `private` :'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以省略类属性，让 `constructor` 通过将参数声明为 `private` 自动创建它们：
- en: '`constructor(private firstName: string, private lastName: string, private isActive:
    boolean = true) {}`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor(private firstName: string, private lastName: string, private isActive:
    boolean = true) {}`'
- en: 'Finally, add types in the `active` property accessor and the `getFullname`
    method:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `active` 属性访问器和 `getFullname` 方法中添加类型：
- en: '[PRE50]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Converting a JavaScript class into TypeScript and adding types is an important
    step toward taking advantage of the typing feature in TypeScript.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JavaScript 类转换为 TypeScript 并添加类型是利用 TypeScript 中类型功能的重要步骤。
- en: 'Another great feature of TypeScript related to classes is the `instanceOf`
    keyword. It allows us to check the class instance type and provides the correct
    properties according to the related class. Let’s explore it with the `Customer`
    class defined in the `customer.js` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 与类相关的一个伟大特性是 `instanceOf` 关键字。它允许我们检查类实例的类型，并按照相关类提供正确的属性。让我们通过在
    `customer.js` 文件中定义的 `Customer` 类来探索它：
- en: Convert the file to TypeScript by renaming it `customer.ts` .
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件重命名为 `customer.ts` 以将其转换为 TypeScript。
- en: 'Rewrite the `Customer` class as follows to add types:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式重写 `Customer` 类以添加类型：
- en: '[PRE51]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create an object outside of the class that can be of both the `User` and `Customer`
    type:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以在 `User` 和 `Customer` 类型之间切换的对象：
- en: '[PRE52]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can now use the `instanceOf` keyword to access different properties of the
    `account` object according to the underlying class:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `instanceOf` 关键字根据底层类访问 `account` 对象的不同属性：
- en: '[PRE53]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'TypeScript is smart enough to understand that the `account` object in the `else`
    statement does not have a `taxNumber` property because it is of the `User` type.
    Even if we try to access it by mistake, VSCode will throw an error:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 足够智能，能够理解在 `else` 语句中的 `account` 对象没有 `taxNumber` 属性，因为它属于 `User`
    类型。即使我们错误地尝试访问它，VSCode 也会抛出一个错误：
- en: '![Εικόνα που περιέχει κείμενο, στιγμιότυπο οθόνης, γραμματοσειρά, γραμμή  Περιγραφή
    που δημιουργήθηκε αυτόματα](img/B21418_02_02.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图像，屏幕截图，字体，行描述由自动创建](img/B21418_02_02.png)'
- en: 'Figure 2.2: Property access error'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：属性访问错误
- en: TypeScript classes help us write well-structured code, can be instantiated,
    contain business logic, and provide static typing in our application. As applications
    scale and more classes are created, we need to find ways to ensure consistency
    and rule compliance in our code. As we will learn in the following section, one
    of the best ways to address the consistency and validation of types is to create
    **interfaces** .
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 类帮助我们编写结构良好的代码，可以被实例化，包含业务逻辑，并在我们的应用程序中提供静态类型。随着应用程序的扩展和更多类的创建，我们需要找到确保代码一致性和规则遵守的方法。正如我们将在下一节中学习的，解决一致性和类型验证的最佳方法之一是创建
    **接口**。
- en: Interfaces
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is a code contract that defines a particular schema. Any artifacts
    like classes and functions implementing an interface should comply with this schema.
    Interfaces are beneficial when we want to enforce strict typing on classes generated
    by factories or when we define function signatures to ensure that a particular
    typed property is found in the payload.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种代码契约，它定义了特定的模式。任何实现接口的类和函数等工件都应该遵守此模式。当我们想要对由工厂生成的类强制执行严格的类型检查，或者当我们定义函数签名以确保在有效负载中找到特定类型的属性时，接口是有益的。
- en: Interfaces disappear during transpilation and are not included in the final
    JavaScript code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在编译过程中消失，并且不会包含在最终的 JavaScript 代码中。
- en: 'In the following snippet, we define an interface for managing products:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们定义了一个用于管理产品的接口：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Interfaces are the recommended approach when working with data from a backend
    API or other source.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理来自后端 API 或其他来源的数据时，接口是推荐的方法。
- en: 'An interface can contain properties and methods. In the preceding snippet,
    the `Product` interface contained the `name` and `price` properties. It also defined
    the `getCategories` method. A class can use an interface by adding the `implements`
    keyword and the interface name in the class declaration:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口可以包含属性和方法。在上面的代码片段中，`Product` 接口包含了 `name` 和 `price` 属性。它还定义了 `getCategories`
    方法。一个类可以通过在类声明中添加 `implements` 关键字和接口名称来使用接口：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding snippet, the `Keyboard` class must implement all members of
    the `Product` interface; otherwise, TypeScript will throw an error. If we do not
    want to implement an interface member, we can define it as optional using the
    `?` character:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Keyboard` 类必须实现 `Product` 接口的所有成员；否则，TypeScript 会抛出一个错误。如果我们不想实现接口成员，我们可以使用
    `?` 字符将其定义为可选：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can also use interfaces to change the type of a variable from one type to
    another, called **type casting** . Type casting is useful when working with dynamic
    data or when TypeScript cannot infer the type of a variable automatically. In
    the following code, we instruct TypeScript to treat the `product` object as a
    `Product` type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用接口来改变变量的类型，从一种类型转换为另一种类型，这被称为**类型转换**。当处理动态数据或TypeScript无法自动推断变量类型时，类型转换非常有用。在以下代码中，我们指示TypeScript将`product`对象视为`Product`类型：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: However, type casting should be used with caution. In the preceding snippet,
    we intentionally omitted to add the `getCategories` method, but TypeScript did
    not throw an error. When we use type casting, we tell TypeScript that a variable
    *pretends* to be of a specific type.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型转换应该谨慎使用。在先前的代码片段中，我们故意省略了添加`getCategories`方法，但TypeScript没有抛出错误。当我们使用类型转换时，我们告诉TypeScript一个变量*假装*是特定类型。
- en: It is recommended to avoid type casting if possible and define types explicitly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 建议尽可能避免类型转换，并明确定义类型。
- en: Interfaces can be combined with **generics** to provide a general code behavior
    regardless of the data type, as we will learn in the following section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以与**泛型**结合使用，无论数据类型如何，都可以提供通用的代码行为，正如我们将在下一节中学习的那样。
- en: Generics
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics are used when we want to use dynamic types in other TypeScript artifacts,
    such as methods.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在其他TypeScript元素（如方法）中使用动态类型时，会使用泛型。
- en: 'Suppose that we want to create a function for saving a `Product` object in
    the local storage of the browser:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个用于在浏览器本地存储中保存`Product`对象的函数：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding code, we explicitly define the `data` parameter as a `Product`
    . If we also want to save `Keyboard` objects, we should modify the `save` method
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们明确地将`data`参数定义为`Product`。如果我们还想保存`Keyboard`对象，我们应该按以下方式修改`save`方法：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, the preceding approach does not scale well if we would like to add
    other types in the future. Instead, we can use generics to let the consumer of
    the `save` method decide upon the data type passed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们未来想要添加其他类型，先前的这种方法并不容易扩展。相反，我们可以使用泛型来让`save`方法的消费者决定传递的数据类型：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding example, the type of `T` is not evaluated until we use the
    method. We use `T` as a convention to define generics, but you can also use other
    letters. We can execute the `save` method for a `Product` object as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，`T`的类型直到我们使用该方法时才会被评估。我们使用`T`作为定义泛型的约定，但你也可以使用其他字母。我们可以按照以下方式为`Product`对象执行`save`方法：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As you can see, its type varies, depending on how you call it. It also ensures
    that you are passing the correct type of data. Suppose that the preceding method
    is called in this way:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，其类型根据你如何调用它而变化。它还确保你传递了正确的数据类型。假设先前的方法以这种方式被调用：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We specify that `T` should be a `Product` , but we insist on passing its value
    as a string. The compiler clearly states that this is not correct. If we would
    like to use more generics in our `save` method, we could use different letters,
    such as:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定`T`应该是`Product`，但我们坚持将其值作为字符串传递。编译器清楚地指出这是不正确的。如果我们想在`save`方法中使用更多泛型，我们可以使用不同的字母，例如：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Generics are often used in collections because they have similar behavior, regardless
    of the type. They can, however, be used on other constructs, such as methods.
    The idea is that generics should indicate if you are about to mix types in a way
    that isn’t allowed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型通常用于集合中，因为它们的行为相似，无论类型如何。然而，它们也可以用于其他构造，如方法。其理念是泛型应该表明你即将以不允许的方式混合类型。
- en: Generics are powerful to use if you have a typical behavior with many different
    data types. You probably won’t be writing custom generics, at least not initially,
    but it’s good to know what is going on.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个与许多不同数据类型相关的典型行为，泛型是非常强大的。你可能不会编写自定义泛型，至少最初不会，但了解正在发生的事情是好的。
- en: In the following section, we’ll look at some utility types related to interfaces
    that will help us during Angular development.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些与接口相关的实用类型，这些类型将有助于我们在Angular开发过程中。
- en: Utility types
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用类型
- en: Utility types are types that help us to derive new types from existing ones.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实用类型是帮助我们从现有类型派生出新类型的类型。
- en: 'The `Partial` type is used when we want to create an object from an interface
    where all its properties are optional. In the following snippet, we use the `Product`
    interface to declare a trimmed version of a product:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从一个所有属性都是可选的接口中创建对象时，会使用`Partial`类型。在下面的代码片段中，我们使用`Product`接口声明了一个产品的简化版本：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding snippet, we can see that the `mic` object does not contain
    the `getCategories` method. Alternatively, we could use the `Pick` type, which
    allows us to create an object from a subset of interface properties:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到`mic`对象不包含`getCategories`方法。或者，我们可以使用`Pick`类型，它允许我们从接口属性的一个子集中创建对象：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Some languages, such as C#, have a reserved type when defining a key-value
    pair object or dictionary, as it is known. In TypeScript, if we want to define
    such a type, we can use a `Record` type:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如C#，在定义键值对对象或字典时有一个保留类型，正如其名。在TypeScript中，如果我们想定义这样的类型，我们可以使用`Record`类型：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding snippet defines the product name as a `string` and the quantity
    as a `number` .
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将产品名称定义为`string`类型，将数量定义为`number`类型。
- en: You can find more utility types at [https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)
    .
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.typescriptlang.org/docs/handbook/utility-types.html](https://www.typescriptlang.org/docs/handbook/utility-types.html)找到更多实用类型。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: It was a long read, but this introduction to TypeScript was necessary to understand
    the logic behind many of the most brilliant parts of Angular. It allowed us to
    introduce the language syntax and explain the rationale behind its success as
    the syntax of choice for building the Angular framework.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然阅读起来很长，但这个TypeScript入门介绍对于理解Angular中许多最精彩部分的逻辑是必要的。它使我们能够介绍语言语法并解释其作为构建Angular框架首选语法的成功原因。
- en: We reviewed the type architecture and how we can create advanced business logic
    when designing functions with various alternatives for parameterized signatures.
    We even discovered how to bypass scope-related issues using the powerful arrow
    functions. We enhanced our knowledge of TypeScript by exploring some of the most
    common features used in Angular applications.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了类型架构以及在设计具有各种参数签名替代方案的功能时如何创建高级业务逻辑。我们还发现了如何使用强大的箭头函数绕过与作用域相关的问题。通过探索Angular应用程序中最常用的某些功能，我们增强了我们对TypeScript的了解。
- en: Probably the most relevant part of this chapter encompassed our overview of
    classes, methods, properties, and accessors and how we can handle inheritance
    and better application design through interfaces.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可能本章最相关的部分是我们对类、方法、属性和访问器的概述，以及我们如何通过接口处理继承和更好的应用程序设计。
- en: With all this knowledge, we can start learning how to apply it by building Angular
    applications. In the next chapter, we will learn how to use Angular components
    to create composable user interfaces to maintain our application code and make
    it more scalable.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了所有这些知识之后，我们可以开始通过构建Angular应用程序来学习如何应用它们。在下一章中，我们将学习如何使用Angular组件来创建可组合的用户界面，以维护我们的应用程序代码并使其更具可扩展性。
