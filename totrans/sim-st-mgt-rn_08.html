<html><head></head><body>
<div id="_idContainer043">
<h1 class="chapter-number" id="_idParaDest-96"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-97"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.2.1">Integrating Jotai in a React Native App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we ventured into the mathematical world of </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">XState</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">We will continue our journey by exploring another young state management library called </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Jotai</span></strong><span class="koboSpan" id="kobo.7.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Jotai</span></strong><span class="koboSpan" id="kobo.9.1"> is inspired by an experimental state management library created at </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Facebook</span></strong><span class="koboSpan" id="kobo.11.1"> called Recoil. </span><span class="koboSpan" id="kobo.11.2">In this chapter, we will take a brief look at </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Recoil</span></strong><span class="koboSpan" id="kobo.13.1">, an experimental state management library created by Facebook. </span><span class="koboSpan" id="kobo.13.2">Once we’re comfortable with the main ideas of this library, namely a new concept called an “atomic state”, we will take a deep dive into </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Jotai</span></strong><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">We will configure Jotai in our app, and we’ll continue to work on data fetching and managing liked images with the help of </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Jotai</span></strong><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Here’s what we will go over in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">What is </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">Recoil</span></strong><span class="koboSpan" id="kobo.21.1"> and an </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">atomic state?</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">is </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.25.1">Jotai</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">?</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Configuring </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">Jotai</span></strong><span class="koboSpan" id="kobo.29.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Funbook app</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Using </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">Jotai</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.33.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">FavoritedImages</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.35.1">By the end of this chapter, you will have a new way of looking at global state management – by dividing it into small items, called </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">atoms</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">You will also know how to set up </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Jotai</span></strong><span class="koboSpan" id="kobo.39.1"> in a new project, and how to use it for data fetching and </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">data management.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.41.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.42.1">In order to follow along with this chapter, you will need some knowledge of </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">JavaScript</span></strong><span class="koboSpan" id="kobo.44.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">ReactJS</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">If you have followed at least </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Chapters 1 to 4</span></em><span class="koboSpan" id="kobo.48.1"> of this book, you should be able to proceed without </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">any issues.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Feel free to use an IDE of your choice, as </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">React</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.52.1">Native</span></strong><span class="koboSpan" id="kobo.53.1"> does not need any specific functionality. </span><span class="koboSpan" id="kobo.53.2">Currently, the most popular IDEs for frontend developers are Microsoft’s VSCode, Atom, Sublime Text, </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">and WebStorm.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The code snippets provided in this chapter are here to illustrate what we should be doing with the code. </span><span class="koboSpan" id="kobo.55.2">They do not provide the whole picture. </span><span class="koboSpan" id="kobo.55.3">To code along easier, please open the GitHub repo in your IDE and look at the files in there. </span><span class="koboSpan" id="kobo.55.4">You can either start with the file in the folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">example-app-full</span></strong><span class="koboSpan" id="kobo.57.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">chapter-8</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">If you start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">example-app-full</span></strong><span class="koboSpan" id="kobo.61.1">, you will be responsible for implementing the solutions described in this chapter. </span><span class="koboSpan" id="kobo.61.2">If you choose to look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">chapter-8</span></strong><span class="koboSpan" id="kobo.63.1">, you will see the entire solution implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">by me.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">If you get stuck or lost, you can check the code in the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">repo: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8"><span class="No-Break"><span class="koboSpan" id="kobo.67.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.68.1">.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.69.1">What is Recoil and an atomic state?</span></h1>
<p><span class="koboSpan" id="kobo.70.1">If you’ve been following this </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.71.1">book chapter by chapter, you may be feeling as though the list of </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.72.1">different types of state management libraries is never-ending. </span><span class="koboSpan" id="kobo.72.2">You would be right, to some extent. </span><span class="koboSpan" id="kobo.72.3">New state management libraries pop up every few weeks; they are sometimes purely open source, and sometimes company-backed. </span><span class="koboSpan" id="kobo.72.4">However, they rarely propose groundbreaking solutions. </span><span class="koboSpan" id="kobo.72.5">More often than not, they are newer implementations of known concepts. </span><span class="koboSpan" id="kobo.72.6">Those implementations are greatly appreciated, as every developer likes working comfortably – and what are those known concepts, you </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">may ask?</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">There’s a consensus in the </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">ReactJS</span></strong><span class="koboSpan" id="kobo.76.1"> world that state management libraries can be divided into </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">three types:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.78.1">Flux type – these are state </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.79.1">management libraries </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.80.1">that hold the state outside of components and use </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.81.1">a unidirectional data flow. </span><span class="koboSpan" id="kobo.81.2">They are inspired by </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">Facebook’s Flux</span></strong><span class="koboSpan" id="kobo.83.1">, the </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.84.1">most famous example being </span><strong class="bold"><span class="koboSpan" id="kobo.85.1">Redux</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">There are modern </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.87.1">implementations of this flow, such as </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">Redux Toolkit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.89.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.90.1">Zustand</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">Proxy type – these libraries “wrap” the state, conceptually similar to what a proxy does. </span><span class="koboSpan" id="kobo.92.2">When </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.93.1">using this type of state management, the </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.94.1">developer can subscribe to, and read, wrapped values like any other values in the component. </span><span class="koboSpan" id="kobo.94.2">The best examples of proxy-type state management are </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">React’s Context</span></strong><span class="koboSpan" id="kobo.96.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">MobX</span></strong><span class="koboSpan" id="kobo.98.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.100.1">Valtio</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Atomic type – this is the </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.103.1">state set at the lowest level, managed </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.104.1">naturally by </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">setState</span></strong><span class="koboSpan" id="kobo.106.1"> in class components and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">useState</span></strong><span class="koboSpan" id="kobo.108.1"> hook in function components. </span><span class="koboSpan" id="kobo.108.2">Values set in this way can be passed around the app and used in a bigger context. </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Facebook</span></strong><span class="koboSpan" id="kobo.110.1"> created an experimental library to promote this type of state management, called </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Recoil</span></strong><span class="koboSpan" id="kobo.112.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">Jotai</span></strong><span class="koboSpan" id="kobo.114.1"> soon </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">followed suit.</span></span></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.116.1">Recoil</span></strong><span class="koboSpan" id="kobo.117.1"> was created around </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.118.1">mid-2020 and quickly garnered lots of attention. </span><span class="koboSpan" id="kobo.118.2">It was published by Facebook itself, the creators of React, so everyone was expecting a great new solution. </span><span class="koboSpan" id="kobo.118.3">The idea of using the smallest possible denomination of pieces of state, peppered and accessible throughout </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">React</span></strong><span class="koboSpan" id="kobo.120.1"> apps, was enticing. </span><span class="koboSpan" id="kobo.120.2">Unfortunately, after the first gasp of excitement, a big part of the React community lost interest in </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">Recoil</span></strong><span class="koboSpan" id="kobo.122.1"> and went about their days continuing to work mostly with Redux. </span><span class="koboSpan" id="kobo.122.2">Two years later, </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Recoil’s</span></strong><span class="koboSpan" id="kobo.124.1"> documentation still states that it’s experimental and few people are talking </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">about it.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">A small community of developers was paying more attention than the rest of us though. </span><em class="italic"><span class="koboSpan" id="kobo.127.1">Poimandres</span></em><span class="koboSpan" id="kobo.128.1">, an open source developer </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.129.1">collective, went to work and created their implementation of an atomic state. </span><span class="koboSpan" id="kobo.129.2">They called it </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Jotai</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">If you visit their GitHub page, you will see they </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.132.1">also developed </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">Valtio</span></strong><span class="koboSpan" id="kobo.134.1">, a proxy-type state management library, and </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Zustand</span></strong><span class="koboSpan" id="kobo.136.1">, a lightweight flux-type </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.137.1">state management library. </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">Valtio</span></strong><span class="koboSpan" id="kobo.139.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">Zustand</span></strong><span class="koboSpan" id="kobo.141.1"> are so far in the shadow of their more famous alternatives, but </span><strong class="bold"><span class="koboSpan" id="kobo.142.1">Jotai</span></strong><span class="koboSpan" id="kobo.143.1"> has dominated the stage for atomic state management. </span><span class="koboSpan" id="kobo.143.2">This library is production-ready; it’s being actively developed through </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">GitHub</span></strong><span class="koboSpan" id="kobo.145.1">, and its developers provide constant support on an open Discord server. </span><span class="koboSpan" id="kobo.145.2">This is why we will talk about </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">Jotai</span></strong><span class="koboSpan" id="kobo.147.1">, and not </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">Recoil</span></strong><span class="koboSpan" id="kobo.149.1">, in </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">this chapter.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.151.1">What is Jotai?</span></h1>
<p><span class="koboSpan" id="kobo.152.1">As mentioned in the previous section, </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Jotai</span></strong><span class="koboSpan" id="kobo.154.1"> is an atomic-type state management library, created by a developer </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.155.1">named </span><em class="italic"><span class="koboSpan" id="kobo.156.1">Daishi Kato</span></em><span class="koboSpan" id="kobo.157.1">, as part of the </span><em class="italic"><span class="koboSpan" id="kobo.158.1">Poimandres</span></em><span class="koboSpan" id="kobo.159.1"> open source developer collective. </span><span class="koboSpan" id="kobo.159.2">I asked Daishi Kato a few questions through Twitter, and he was nice enough to answer me. </span><span class="koboSpan" id="kobo.159.3">The first question I had was why he decided to create </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Jotai</span></strong><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">He said: “I have been creating various global state libraries, to eliminate necessity of memoizing selectors. </span><span class="koboSpan" id="kobo.161.3">One notable one is react-tracked, which is heavily depending on proxies. </span><span class="koboSpan" id="kobo.161.4">I noticed proxies don’t work best for many cases and wanted another solution. </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Recoil’s</span></strong><span class="koboSpan" id="kobo.163.1"> model is a best match for this. </span><span class="koboSpan" id="kobo.163.2">So, to solve my problem, I developed </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">Jotai</span></strong><span class="koboSpan" id="kobo.165.1">.” </span><span class="koboSpan" id="kobo.165.2">As simple as that! </span><span class="koboSpan" id="kobo.165.3">He added that maintaining the various state management libraries he created takes about half of his time, leaving the rest to do freelance work. </span><span class="koboSpan" id="kobo.165.4">Daishi said he likes working most with </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Jotai</span></strong><span class="koboSpan" id="kobo.167.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">Valtio</span></strong><span class="koboSpan" id="kobo.169.1"> as they have unique features. </span><span class="koboSpan" id="kobo.169.2">“</span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Zustand</span></strong><span class="koboSpan" id="kobo.171.1"> is valuable for being minimal. </span><span class="koboSpan" id="kobo.171.2">It’s almost nothing. </span><span class="koboSpan" id="kobo.171.3">Likewise, react-tracked is </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.172.1">still valuable providing minimal features.” </span><span class="koboSpan" id="kobo.172.2">– Daishi added. </span><span class="koboSpan" id="kobo.172.3">When I asked how he would categorize state management libraries, he said he would divide them into two groups: keeping the state internal (as with </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">useState</span></strong><span class="koboSpan" id="kobo.174.1">) or externally. </span><span class="koboSpan" id="kobo.174.2">Daishi is continually working on new things; you can observe all his work in the </span><em class="italic"><span class="koboSpan" id="kobo.175.1">Jotai Labs</span></em> <strong class="bold"><span class="koboSpan" id="kobo.176.1">GitHub</span></strong><span class="koboSpan" id="kobo.177.1"> repo: </span><a href="https://github.com/jotai-labs"><span class="koboSpan" id="kobo.178.1">https://github.com/jotai-labs</span></a><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">He’s also interested in developing features for fetching and </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">React’s Suspense</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">You can find more links to his projects in the </span><em class="italic"><span class="koboSpan" id="kobo.182.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">We now have a good understanding of why Jotai was created. </span><span class="koboSpan" id="kobo.185.2">It aims to solve state management problems from a new perspective, following React’s best practices and concepts proposed by the experimental Recoil library. </span><span class="koboSpan" id="kobo.185.3">It’s time we try this “atomic” state approach in our app. </span><span class="koboSpan" id="kobo.185.4">Let’s get </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">to coding!</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.187.1">Configuring Jotai in the Funbook app</span></h1>
<p><span class="koboSpan" id="kobo.188.1">If you’re a fan of </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.189.1">simplicity, my dear reader, you may just fall in </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.190.1">love with this state management library. </span><span class="koboSpan" id="kobo.190.2">Configuring it in our app only requires running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">install</span></strong><span class="koboSpan" id="kobo.192.1"> command in </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.194.1">
npm install jotai</span></pre>
<p><span class="koboSpan" id="kobo.195.1">Alternatively, see </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.197.1">
Yarn add jotai</span></pre>
<p><span class="koboSpan" id="kobo.198.1">There’s one hidden gem of configuration to be added: Suspense. </span><span class="koboSpan" id="kobo.198.2">I specifically used the word gem because this configuration requirement of </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Jotai</span></strong><span class="koboSpan" id="kobo.200.1"> will make your app crash less. </span><span class="koboSpan" id="kobo.200.2">Suspense is a new ReactJS functionality, created to only be able to render components that </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.201.1">are ready to be rendered. </span><span class="koboSpan" id="kobo.201.2">As with any new </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.202.1">functionality, the users need to get used to it, and sometimes need to be forced to try it. </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Jotai</span></strong><span class="koboSpan" id="kobo.204.1"> is doing exactly this: forcing the users to use Suspense, for their own good! </span><span class="koboSpan" id="kobo.204.2">Let’s go ahead and add it at the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">our app:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
// ./App.js
import React, { useState, Suspense } from "react";
export default function App() {
//…
  if (!fontsLoaded) {
    return &lt;AppLoading /&gt;;
  }
  return (
    &lt;SafeAreaProvider&gt;
//…
            &lt;Suspense fallback={&lt;AppLoading /&gt;}&gt;
              &lt;NavigationContainer theme={MyTheme}&gt;
                &lt;Stack.Navigator&gt;
//…</span></pre>
<p><span class="koboSpan" id="kobo.207.1">Now, our app can use </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">Jotai</span></strong><span class="koboSpan" id="kobo.209.1">’s atoms and it’s less prone to unexpected crashes. </span><span class="koboSpan" id="kobo.209.2">Let’s move on to using atoms </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">ListOfFavoritedImages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.213.1">Using Jotai for ListOfFavoritedImages</span></h1>
<p><span class="koboSpan" id="kobo.214.1">You may have </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.215.1">noticed that we didn’t give much of a theoretical </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.216.1">introduction to </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">Jotai</span></strong><span class="koboSpan" id="kobo.218.1">. </span><span class="koboSpan" id="kobo.218.2">This is because this library is minimal. </span><span class="koboSpan" id="kobo.218.3">There is no boilerplate, no complex concepts. </span><span class="koboSpan" id="kobo.218.4">All we need to do is create an atom and use it thanks to a custom hook in the app. </span><span class="koboSpan" id="kobo.218.5">Let’s start by creating an atom with some mock data for the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">liked images:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.220.1">
// src/atoms/imagesAtoms.js
import { atom } from "jotai";
export const imageListAtom = atom([
  {
    "itemId": 1,
    "authorId": 11,
    "timeStamp": "2 hrs ago",
    "url": "…",
    "likes": "28",
    "conversations": "12"
  },
  {
    "itemId": 2,
    "authorId": 7,
    "timeStamp": "1 week ago",
    "url": "…",
    "likes": "8",
    "conversations": "123"
  },
]);</span></pre>
<p><span class="koboSpan" id="kobo.221.1">We have the mocked images array ready; all we need to do now is use it. </span><span class="koboSpan" id="kobo.221.2">Given our previous </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.222.1">experiences with other state management libraries, you </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.223.1">are probably expecting to see some sort of setup, wrapper, subscription, or something similar. </span><span class="koboSpan" id="kobo.223.2">I’m sorry to disappoint, but all we need to do to use the </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Jotai</span></strong><span class="koboSpan" id="kobo.225.1"> atom is… use it. </span><span class="koboSpan" id="kobo.225.2">Let’s change the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">ListOfFavoritedImages</span></strong><span class="koboSpan" id="kobo.227.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
import { useAtom } from "jotai";
import { imageListAtom } from "../atoms/imagesAtoms";
export const ListOfFavorites = ({ navigation }) =&gt; {
  const [imageList] = useAtom(imageListAtom);
  if (!imageList) {
    return &lt;AppLoading /&gt;;
  }
//…
  return (
    //…
      &lt;FlatList
        data={imageList}
//…</span></pre>
<p><span class="koboSpan" id="kobo.230.1">In the preceding code, we imported the </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">Jotai</span></strong><span class="koboSpan" id="kobo.232.1"> custom hook named </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">useAtom</span></strong><span class="koboSpan" id="kobo.234.1"> and the atom we created in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">imagesAtom</span></strong><span class="koboSpan" id="kobo.236.1"> file. </span><span class="koboSpan" id="kobo.236.2">And what is the result? </span><span class="koboSpan" id="kobo.236.3">Let’s run the app in the simulator and </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">find out!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.238.1"><img alt="Figure 8.1 – App displaying images based on Jotai atoms " src="image/Figure_8.01_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">Figure 8.1 – App displaying images based on Jotai atoms</span></p>
<p><span class="koboSpan" id="kobo.240.1">Everything works! </span><span class="koboSpan" id="kobo.240.2">I must </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.241.1">admit, this feels almost magical. </span><span class="koboSpan" id="kobo.241.2">Surely, fetching </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.242.1">will be </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">more complicated?</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.244.1">Fetching data with Jotai</span></h2>
<p><span class="koboSpan" id="kobo.245.1">We successfully </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.246.1">set up mocked image data in our app, but we would like to </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.247.1">fetch real data from the server. </span><span class="koboSpan" id="kobo.247.2">Going back to the </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Jotai</span></strong><span class="koboSpan" id="kobo.249.1"> docs, we will find a guide on asynchronous atoms (you can find a link to this part of the documentation in the </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Further reading</span></em><span class="koboSpan" id="kobo.251.1"> section). </span><span class="koboSpan" id="kobo.251.2">Here’s what our async atom for fetching images will </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
// src/atoms/imageAtoms.js
import { requestBase } from "../utils/constants";
import { atom } from "jotai";
export const imageListAtom = atom([]);
  const urlAtom = atom(requestBase + "/john_doe/likedImages.    json");
export const fetchImagesAtom = atom(async (get) =&gt; {
  const response = await fetch(get(urlAtom));
  return await response.json();
});</span></pre>
<p><span class="koboSpan" id="kobo.254.1">We add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">requestBase</span></strong><span class="koboSpan" id="kobo.256.1"> import to use URLs more comfortably. </span><span class="koboSpan" id="kobo.256.2">Then, we proceed to create a basic atom </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.257.1">with the specific URL. </span><span class="koboSpan" id="kobo.257.2">The last function is the async </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.258.1">atom. </span><span class="koboSpan" id="kobo.258.2">We know it’s async because it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">async</span></strong><span class="koboSpan" id="kobo.260.1"> keyword. </span><span class="koboSpan" id="kobo.260.2">The body of the async atom function is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">fetch</span></strong><span class="koboSpan" id="kobo.262.1"> function and data return. </span><span class="koboSpan" id="kobo.262.2">The atom is ready, but it’s not connected to anything just yet. </span><span class="koboSpan" id="kobo.262.3">We will need to call it in the app and make it fill </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.264.1">. </span><span class="koboSpan" id="kobo.264.2">Let’s start by invoking the fetching. </span><span class="koboSpan" id="kobo.264.3">A good place to do so will be at the root of the app once the user is logged in. </span><span class="koboSpan" id="kobo.264.4">This means we will not be fetching in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">App.js</span></strong><span class="koboSpan" id="kobo.266.1"> root component, but rather in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Home</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.269.1">
// src/surfaces/Home.js
import { useAtom } from "jotai";
import { fetchImagesAtom } from "../atoms/imageAtoms";
//…
export const Home = () =&gt; {
  const [json] = useAtom(fetchImagesAtom);</span></pre>
<p><span class="koboSpan" id="kobo.270.1">We start by importing the necessary pieces: a custom hook from </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Jotai</span></strong><span class="koboSpan" id="kobo.272.1"> and our fetching atom. </span><span class="koboSpan" id="kobo.272.2">Then, we </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.273.1">use the hook in the component. </span><span class="koboSpan" id="kobo.273.2">This is a good moment to check </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.274.1">that everything is working correctly. </span><span class="koboSpan" id="kobo.274.2">I suggest adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">console.log</span></strong><span class="koboSpan" id="kobo.276.1"> to the component and seeing whether the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">json</span></strong><span class="koboSpan" id="kobo.278.1"> is the same as expected. </span><span class="koboSpan" id="kobo.278.2">By the way, there is no rule for naming the returns of atoms. </span><span class="koboSpan" id="kobo.278.3">You may as well </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">write this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
  const [thisIsAVeryFancyAndCuteFetchingMechanism] =    useAtom(fetchImagesAtom);</span></pre>
<p><span class="koboSpan" id="kobo.281.1">If you’re using linter plugins (such as </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">ESLint</span></strong><span class="koboSpan" id="kobo.283.1">) in your IDE, you may have received a warning about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">json</span></strong><span class="koboSpan" id="kobo.285.1"> value being declared but not used. </span><span class="koboSpan" id="kobo.285.2">What good does it do to fetch images if we’re not doing anything with them? </span><span class="koboSpan" id="kobo.285.3">And what should we do with them? </span><span class="koboSpan" id="kobo.285.4">We should make the newly fetched array of images fill </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.287.1">. </span><span class="koboSpan" id="kobo.287.2">The way to accomplish this is to change our read-only </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.289.1"> to a </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">read-write atom.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.291.1">Reading and writing atoms</span></h2>
<p><span class="koboSpan" id="kobo.292.1">Ah! </span><span class="koboSpan" id="kobo.292.2">Finally, some </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.293.1">theory! </span><span class="koboSpan" id="kobo.293.2">I’m sure you’ve been craving this, my dear </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.294.1">reader! </span><span class="koboSpan" id="kobo.294.2">(Since it’s difficult to convey irony in a technical text, let me take this opportunity to explain: the previous sentence </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">is sarcastic).</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">There are three types of atoms: read-only, write-only, and read-write atoms. </span><span class="koboSpan" id="kobo.296.2">The read-only atoms are the simplest: all you do is create them and set the value they need to hold on to, </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
const onlyReadMe = atom('I like to read')</span></pre>
<p><span class="koboSpan" id="kobo.299.1">Read-only atoms can hold more than simple values or strings. </span><span class="koboSpan" id="kobo.299.2">If you need more complex logic in your atom, you should use the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
  const readMeButInUpperCase  = atom((get) =&gt;    get(onlyReadMe).toUpperCase())</span></pre>
<p><span class="koboSpan" id="kobo.302.1">In the preceding short snippet, you can observe that atoms have access to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">getter</span></strong><span class="koboSpan" id="kobo.304.1"> function, which, in turn, can access </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">other atoms.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">If we wanted to add a write functionality to our atom, we can add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">setter</span></strong><span class="koboSpan" id="kobo.308.1"> function as the second argument to </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">the atom:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
const readMeButInUpperCase  = atom(
      (get) =&gt; get(onlyReadMe).toUpperCase(),
      (get, set, newText) =&gt; {
          set(onlyReadMe, newText)
       }
)</span></pre>
<p><span class="koboSpan" id="kobo.311.1">We’ve added a </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.312.1">new function, which will accept a new text and pass it to </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.313.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">onlyReadMe</span></strong><span class="koboSpan" id="kobo.315.1"> atom. </span><span class="koboSpan" id="kobo.315.2">If you were to use it in a component, it would look </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
const FancyTextComponent = () =&gt; {
    const [fancyText, setFancyText] =      useAtom(readMeButInUpperCase  );
return (
      &lt;Pressable onPress={() =&gt; setFancyText         ('I do not like to swim')&gt;
        &lt;Text&gt;Likes and dislikes: {fancyText}&lt;/Text&gt;
    &lt;/Pressable&gt;
)</span></pre>
<p><span class="koboSpan" id="kobo.318.1">In the example component in the preceding screenshot, you can observe how a read-write atom can be implemented. </span><span class="koboSpan" id="kobo.318.2">We start by importing the atom, but we declare two values: the value and the setter, very similar to what we would use in a regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">useState</span></strong><span class="koboSpan" id="kobo.320.1"> hook. </span><span class="koboSpan" id="kobo.320.2">Lower in the component, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">{fancyText}</span></strong><span class="koboSpan" id="kobo.322.1"> to display the text from the atom, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">setFancyText</span></strong><span class="koboSpan" id="kobo.324.1"> function to set a new text through a </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">button press.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">The last type of atom we can talk about is the write-only atom. </span><span class="koboSpan" id="kobo.326.2">The only difference between this atom and a read-write atom is that we declare the read argument as </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">null</span></strong><span class="koboSpan" id="kobo.328.1">. </span><span class="koboSpan" id="kobo.328.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
const onlyUsedForSettingValues  = atom(null,
       (get, set) =&gt; {
           set(onlyReadMe, 'I like using write only atoms')
       }
)</span></pre>
<p><span class="koboSpan" id="kobo.331.1">When using this type of atom, you always need to make sure to accommodate the hook with the non-existing default value. </span><span class="koboSpan" id="kobo.331.2">Here’s how this write-only hook would be used in the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">example component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
const FancyTextComponent = () =&gt; {
const [readOnlyFancyText] = useAtom(onlyReadMe);
    const [, setStaticText] =      useAtom(onlyUsedForSettingValues  );
return (
    &lt;Pressable onPress={() =&gt; setFancyText()&gt;
        &lt;Text&gt;Likes and dislikes: { readOnlyFancyText }&lt;/Text&gt;
    &lt;/Pressable&gt;
)</span></pre>
<p><span class="koboSpan" id="kobo.334.1">Notice the comma in </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.335.1">the array with values derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">useAtom</span></strong><span class="koboSpan" id="kobo.337.1"> hook. </span><span class="koboSpan" id="kobo.337.2">It indicates </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.338.1">there is a null value on the first index, but we choose to not </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">use it.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.340.1">Adding read-write functionality to the imageListAtom</span></h2>
<p><span class="koboSpan" id="kobo.341.1">So far, we have </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.342.1">a read-only </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.344.1"> and an </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.345.1">async </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">fetchImagesAtom</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">Let’s add a write functionality to </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.349.1"> so that it can accept values </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">fetchImagesAtom</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
// src/atoms/imageAtoms.js
export const imageListAtom = atom([], (get, set, newArray) =&gt; {
  set(imageListAtom, newArray);
});</span></pre>
<p><span class="koboSpan" id="kobo.354.1">The atom is ready to receive values, so let’s give it some. </span><span class="koboSpan" id="kobo.354.2">We have to go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">Home</span></strong><span class="koboSpan" id="kobo.356.1"> component where we kicked off data fetching, and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">useEffect</span></strong><span class="koboSpan" id="kobo.358.1">, which will update </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">Here’s what the code should </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
// src/surfaces/Home.js
export const Home = () =&gt; {
  const [json] = useAtom(fetchImagesAtom);
  const [, setAllImages] = useAtom(imageListAtom);
  useEffect(() =&gt; {
    if (json) {
      setAllImages(json);
    }
  }, [json]);</span></pre>
<p><span class="koboSpan" id="kobo.363.1">This is a good moment to check again whether everything works fine in the app since we just implemented </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.364.1">data fetching. </span><span class="koboSpan" id="kobo.364.2">If </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.365.1">everything is, in fact, working as expected, we’ll move on to implementing functionality for the </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">Like</span></strong><span class="koboSpan" id="kobo.367.1"> button. </span><span class="koboSpan" id="kobo.367.2">If you run into any issues, start by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">console.log</span></strong><span class="koboSpan" id="kobo.369.1"> to check that the atoms hold and return the values you are expecting them to have. </span><span class="koboSpan" id="kobo.369.2">If you continue to have issues, you can join the </span><em class="italic"><span class="koboSpan" id="kobo.370.1">Poimandres</span></em><span class="koboSpan" id="kobo.371.1"> Discord server (link in the </span><em class="italic"><span class="koboSpan" id="kobo.372.1">Further reading</span></em><span class="koboSpan" id="kobo.373.1"> section), where you’ll find a </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">Jotai</span></strong><span class="koboSpan" id="kobo.375.1">-dedicated channel. </span><em class="italic"><span class="koboSpan" id="kobo.376.1">Daishi Kato</span></em><span class="koboSpan" id="kobo.377.1">, the author of </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">Jotai</span></strong><span class="koboSpan" id="kobo.379.1">, answers all sorts of questions on this </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">channel himself.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Once you are sure that everything is good, we’ll move on to implementing the </span><strong class="bold"><span class="koboSpan" id="kobo.382.1">Like</span></strong><span class="koboSpan" id="kobo.383.1"> button </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">ImageDetailsModal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.387.1">Implementing the Like button</span></h2>
<p><span class="koboSpan" id="kobo.388.1">The full functionality </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.389.1">of the </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">Like</span></strong><span class="koboSpan" id="kobo.391.1"> button in </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.393.1"> consists of two parts: the heart icon being full or not – indicating </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.394.1">whether the image has been liked, and the actual action of liking an image – which means adding the new image to the array of images on the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">Favorited surface.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Let’s start by creating the necessary atom for the heart icon. </span><span class="koboSpan" id="kobo.396.2">We need to know whether a given image has been liked or not. </span><span class="koboSpan" id="kobo.396.3">We can establish whether it has been liked by filtering the array of images and checking whether a given image is present in the array. </span><span class="koboSpan" id="kobo.396.4">Here’s what the resulting atom will </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
// src/atoms/imageAtoms.js
  export const isImageLikedAtom = atom(false,    (get, set, newImage) =&gt; {
  const imageList = get(imageListAtom);
  const checkIfLiked =
      imageList?.filter((favoritedImg) =&gt; favoritedImg.itemId         === newImage.itemId)
      .length &gt; 0;
  set(isImageLikedAtom, checkIfLiked);
});</span></pre>
<p><span class="koboSpan" id="kobo.399.1">As per the atom syntax, we start by establishing the default value as </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">false</span></strong><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">We then add a setter function, which will receive the new image object. </span><span class="koboSpan" id="kobo.401.3">Inside the setter function, we use </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Jotai’s</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.403.1">get</span></strong><span class="koboSpan" id="kobo.404.1"> function to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.406.1"> and check our current image object against it. </span><span class="koboSpan" id="kobo.406.2">Finally, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">isImageLikedAtom</span></strong><span class="koboSpan" id="kobo.408.1"> to the correct value. </span><span class="koboSpan" id="kobo.408.2">Once the atom is created, we need to use it in </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
// src/surfaces/ImageDetailsModal.js
export const ImageDetailsModal = ({ navigation, route }) =&gt; {
    const [isCurrentImageLiked, setIsLiked] =      useAtom(isImageLikedAtom);
  setIsLiked(route.params.imageItem);
//…</span></pre>
<p><span class="koboSpan" id="kobo.411.1">You may wonder why we are calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">setIsLiked</span></strong><span class="koboSpan" id="kobo.413.1"> function so crudely – why not add </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">useEffect</span></strong><span class="koboSpan" id="kobo.415.1">? </span><span class="koboSpan" id="kobo.415.2">The fact of the matter is that we need this function to be called when the </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.416.1">component is rendered and only then. </span><span class="koboSpan" id="kobo.416.2">We </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.417.1">could add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">useEffect</span></strong><span class="koboSpan" id="kobo.419.1"> hook with an empty dependency array, but it would achieve the same result while looking </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">more complicated.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.421.1">When does it run?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.422.1">There are some subtleties to the React component life cycle. </span><span class="koboSpan" id="kobo.422.2">They are more obvious with class components, where we would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">componentDidMount</span></strong><span class="koboSpan" id="kobo.424.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">componentWillUnmount</span></strong><span class="koboSpan" id="kobo.426.1">, and so on. </span><span class="koboSpan" id="kobo.426.2">Functional components have the same life cycle, without being as obvious about it. </span><span class="koboSpan" id="kobo.426.3">And it so happens that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">useEffect</span></strong><span class="koboSpan" id="kobo.428.1"> hook only runs after a given component has finished rendering, while functions called directly do not wait for the render </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">to finish.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">As far as our example goes, we do not need to make sure the rendering is complete before calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">setIsLiked</span></strong><span class="koboSpan" id="kobo.432.1"> function. </span><span class="koboSpan" id="kobo.432.2">However, big applications often ask a lot of their developers, and you may face a case where you need to closely control when a given atom setter function (or any other function for that matter) is run. </span><span class="koboSpan" id="kobo.432.3">You can read more on this topic in </span><em class="italic"><span class="koboSpan" id="kobo.433.1">Difference between ‘useEffect’ and calling function directly inside a component</span></em><span class="koboSpan" id="kobo.434.1">, linked in the </span><em class="italic"><span class="koboSpan" id="kobo.435.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.436.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.437.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Circling back to our use case: we have a very nice </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">isImageLiked</span></strong><span class="koboSpan" id="kobo.440.1"> atom in place. </span><span class="koboSpan" id="kobo.440.2">You can test that it works correctly by opening image modals on the </span><strong class="bold"><span class="koboSpan" id="kobo.441.1">Feed</span></strong><span class="koboSpan" id="kobo.442.1"> surface – where the heart icon should be empty – and on the </span><strong class="bold"><span class="koboSpan" id="kobo.443.1">Favorites</span></strong><span class="koboSpan" id="kobo.444.1"> surface – where the heart icon should </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">be full.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Now, on to the liking action! </span><span class="koboSpan" id="kobo.446.2">We will not need to do anything too fancy here. </span><span class="koboSpan" id="kobo.446.3">We must take </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.448.1"> and add a new image </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">to it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.450.1">
// src/atoms/imageAtoms.js
export const addImageToArray = atom(
         null,
         (get, set, newImage) =&gt; {
          const clonedArray = get(imageListAtom);
          clonedArray.unshift(newImage);
          set(imageListAtom, clonedArray);
          set(isImageLikedAtom, newImage);
         }
);</span></pre>
<p><span class="koboSpan" id="kobo.451.1">As with the </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.452.1">example write-only atom, we start by </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.453.1">declaring a null for the default atom value. </span><span class="koboSpan" id="kobo.453.2">In the setter function, we get </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.455.1"> and we add the new image using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">unshift</span></strong><span class="koboSpan" id="kobo.457.1"> function, which adds items to the beginning of the original array. </span><span class="koboSpan" id="kobo.457.2">We finish by setting the newly created array as </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">imageListAtom</span></strong><span class="koboSpan" id="kobo.459.1"> and by triggering the setter in </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">isImageLikedAtom</span></strong><span class="koboSpan" id="kobo.461.1">. </span><span class="koboSpan" id="kobo.461.2">Let’s add this to the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">modal component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
// src/surfaces/ImageDetailsModal.js
export const ImageDetailsModal = ({ navigation, route }) =&gt; {
  const [, addImage] = useAtom(addImageToArray);
  const [isCurrentImageLiked, setIsLiked] = useAtom(isImageLikedAtom);
  setIsLiked(route.params.imageItem);
return (
//…
    &lt;Pressable
          onPress={() =&gt; {
            if (isCurrentImageLiked) {
              // add remove image functionality here
            } else {
              addImage(route.params.imageItem);
            }
          }}
        &gt;
            &lt;Ionicons name={isCurrentImageLiked ? </span><span class="koboSpan" id="kobo.463.2">"heart" :              "heart-outline"} /&gt;
        &lt;/Pressable&gt;
//…</span></pre>
<p><span class="koboSpan" id="kobo.464.1">We must import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">addImageToArray</span></strong><span class="koboSpan" id="kobo.466.1"> atom into our component and then call it in the right place </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.467.1">upon the button being tapped. </span><span class="koboSpan" id="kobo.467.2">Let’s test </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.468.1">our app! </span><span class="koboSpan" id="kobo.468.2">Chances are everything is working perfectly fine. </span><span class="koboSpan" id="kobo.468.3">You can tap the heart icon when it’s empty and it becomes full, and when you close the modal and go to the </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">Favorites</span></strong><span class="koboSpan" id="kobo.470.1"> surface, the image is present there. </span><span class="koboSpan" id="kobo.470.2">If you don’t see the new image on the </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Favorites</span></strong><span class="koboSpan" id="kobo.472.1"> surface appear immediately, you may be facing an issue caused </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">FlatList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">React Native’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">FlatList</span></strong><span class="koboSpan" id="kobo.478.1"> is a pure component, which means it does not re-render unless specifically instructed to do so. </span><span class="koboSpan" id="kobo.478.2">We have encountered this same problem already when using </span><strong class="bold"><span class="koboSpan" id="kobo.479.1">MobX</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">In the case of </span><strong class="bold"><span class="koboSpan" id="kobo.481.1">MobX</span></strong><span class="koboSpan" id="kobo.482.1">, we used special utilities to pass values to </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">FlatList</span></strong><span class="koboSpan" id="kobo.484.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">Jotai</span></strong><span class="koboSpan" id="kobo.486.1">, being minimal, does not offer these specialized utilities. </span><span class="koboSpan" id="kobo.486.2">We must manage this problem outside of </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">Jotai</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">There are a few things we can do. </span><span class="koboSpan" id="kobo.488.3">We can try using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">extraData</span></strong><span class="koboSpan" id="kobo.490.1"> prop from </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">FlatList</span></strong><span class="koboSpan" id="kobo.492.1"> – we can pass atom values to </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">useState</span></strong><span class="koboSpan" id="kobo.494.1"> and let the natural </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.495.1">state re-render the component. </span><span class="koboSpan" id="kobo.495.2">We </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.496.1">can also take advantage of the utilities provided by the React Navigation library. </span><span class="koboSpan" id="kobo.496.2">This is my favorite approach, and it is the one I chose to use. </span><span class="koboSpan" id="kobo.496.3">There’s a </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">useIsFocused</span></strong><span class="koboSpan" id="kobo.498.1"> custom hook in </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">React</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.500.1">Navigation</span></strong><span class="koboSpan" id="kobo.501.1">, which can be used to force a re-render when a tab is focused. </span><span class="koboSpan" id="kobo.501.2">From this description, you can see that this is exactly what we need! </span><span class="koboSpan" id="kobo.501.3">Let’s add this hook to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Favorites</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1"> surface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
// src/surfaces/Favorites.js
import { useIsFocused } from "@react-navigation/native";
export const Favorites = ({ navigation }) =&gt; {
  const isFocused = useIsFocused();
  return (
      &lt;SafeAreaView style={{ flex: 1, paddingTop: headerHeight         }}&gt;
      &lt;Suspense fallback={&lt;AppLoading /&gt;}&gt;
        &lt;ListOfFavorites navigation={navigation} isFocused={isFocused} /&gt;
//…</span></pre>
<p><span class="koboSpan" id="kobo.505.1">Using this hook, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Favorites</span></strong><span class="koboSpan" id="kobo.507.1"> surface will re-render every time this tab is focused. </span><span class="koboSpan" id="kobo.507.2">Of course, this is a hook to be used with great caution. </span><span class="koboSpan" id="kobo.507.3">Too many re-renders cause apps to crash unexpectedly. </span><span class="koboSpan" id="kobo.507.4">If you do decide to use it, make sure the re-render </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">is necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">Time to visit the Funbook app again! </span><span class="koboSpan" id="kobo.509.2">In this section, we started by using a basic hook with a mock array of images. </span><span class="koboSpan" id="kobo.509.3">We then implemented data fetching using </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">Jotai</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">We learned about </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.512.1">the three types of atoms: read-only, write-only, and </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.513.1">read-write. </span><span class="koboSpan" id="kobo.513.2">We used all of this knowledge to create the </span><strong class="bold"><span class="koboSpan" id="kobo.514.1">Like</span></strong><span class="koboSpan" id="kobo.515.1"> button functionality with </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">Jotai</span></strong><span class="koboSpan" id="kobo.517.1"> atoms. </span><span class="koboSpan" id="kobo.517.2">So, when you test your app, try using the </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">Like</span></strong><span class="koboSpan" id="kobo.519.1"> button in </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.521.1"> and check whether your images on the </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">Favorites</span></strong><span class="koboSpan" id="kobo.523.1"> surface are </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">updated correctly.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.525.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.526.1">In this chapter, we covered </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">Jotai</span></strong><span class="koboSpan" id="kobo.528.1">, a new kid on the block of state management libraries. </span><span class="koboSpan" id="kobo.528.2">Inspired by a new, atomic approach to state management proposed by Facebook through their library named </span><strong class="bold"><span class="koboSpan" id="kobo.529.1">Recoil</span></strong><span class="koboSpan" id="kobo.530.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">Jotai</span></strong><span class="koboSpan" id="kobo.532.1"> has become more and more popular within the React community. </span><span class="koboSpan" id="kobo.532.2">It offers a bottom-up approach, as opposed to top-down libraries, such as </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">Redux</span></strong><span class="koboSpan" id="kobo.534.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">MobX</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">It’s honestly stupidly easy to configure and use. </span><span class="koboSpan" id="kobo.536.3">It doesn’t offer many utilities, but the documentation is very clear and easy to use. </span><span class="koboSpan" id="kobo.536.4">In this chapter, we managed to use it to fetch and store data, and we also used it to implement actions on that data, such as adding items to an array. </span><strong class="bold"><span class="koboSpan" id="kobo.537.1">Jotai</span></strong><span class="koboSpan" id="kobo.538.1"> marks the end of our journey with classic state </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">management libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">In the next chapter, we’ll talk about </span><strong class="bold"><span class="koboSpan" id="kobo.541.1">React Query</span></strong><span class="koboSpan" id="kobo.542.1">, which is not a state management library, but a data-fetching library. </span><span class="koboSpan" id="kobo.542.2">It does have its place in this book, however. </span><span class="koboSpan" id="kobo.542.3">More on that in the next chapter! </span><span class="koboSpan" id="kobo.542.4">See </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">you there!</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.544.1">Further reading</span></h1>
<ul>
<li><a href="https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html"><span class="koboSpan" id="kobo.545.1">https://marmelab.com/blog/2022/06/23/proxy-state-with-valtio.html</span></a><span class="koboSpan" id="kobo.546.1">: A State Management Tour: Proxy State </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">with Valtio.</span></span></li>
<li><a href="https://github.com/facebookexperimental/Recoil/tree/main"><span class="koboSpan" id="kobo.548.1">https://github.com/facebookexperimental/Recoil/tree/main</span></a><span class="koboSpan" id="kobo.549.1">: </span><em class="italic"><span class="koboSpan" id="kobo.550.1">Recoil</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.551.1">GitHub page.</span></span></li>
<li><a href="https://opencollective.com/pmndrs"><span class="koboSpan" id="kobo.552.1">https://opencollective.com/pmndrs</span></a><span class="koboSpan" id="kobo.553.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">Poimandres website.</span></span></li>
<li><a href="https://github.com/dai-shi/react-suspense-fetch"><span class="No-Break"><span class="koboSpan" id="kobo.555.1">https://github.com/dai-shi/react-suspense-fetch</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.556.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">react-suspense-fetch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">.</span></span></li>
<li><a href="https://github.com/dai-shi/react-hooks-fetch"><span class="No-Break"><span class="koboSpan" id="kobo.559.1">https://github.com/dai-shi/react-hooks-fetch</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.560.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">react-hooks-fetch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">.</span></span></li>
<li><a href="https://github.com/dai-shi/react-hooks-worker"><span class="No-Break"><span class="koboSpan" id="kobo.563.1">https://github.com/dai-shi/react-hooks-worker</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.564.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">react-hooks-worker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">.</span></span></li>
<li><a href="https://jotai.org/docs/guides/async"><span class="koboSpan" id="kobo.567.1">https://jotai.org/docs/guides/async</span></a><span class="koboSpan" id="kobo.568.1">: </span><em class="italic"><span class="koboSpan" id="kobo.569.1">Jotai – </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.570.1">Async</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">.</span></span></li>
<li><a href="https://discord.com/invite/poimandres"><span class="koboSpan" id="kobo.572.1">https://discord.com/invite/poimandres</span></a><span class="koboSpan" id="kobo.573.1">: Poimandres </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">Discord server.</span></span></li>
<li><a href="https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/"><span class="koboSpan" id="kobo.575.1">https://www.geekyhub.in/post/difference-between-useeffect-and-direct-function-call/</span></a><span class="koboSpan" id="kobo.576.1">: </span><em class="italic"><span class="koboSpan" id="kobo.577.1">Difference between ‘useEffect’ and calling function directly inside </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.578.1">a component</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></li>
<li><a href="https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook"><span class="koboSpan" id="kobo.580.1">https://reactnavigation.org/docs/function-after-focusing-screen/#re-rendering-screen-with-the-useisfocused-hook</span></a><span class="koboSpan" id="kobo.581.1">: React Navigation </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">useIsFocused</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.583.1"> hook.</span></span></li>
</ul>
</div>
</body></html>