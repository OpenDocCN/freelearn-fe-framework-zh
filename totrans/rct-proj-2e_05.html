<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-62"><em class="italic"><a id="_idTextAnchor066"/>Chapter 5</em>: Building a Personal Shopping List Application Using Context and Hooks</h1>
			<p>State management<a id="_idIndexMarker237"/> is a very important part of modern web and mobile applications and is something that React is very good at. Handling state management in React applications can be quite confusing, as there are multiple ways you can handle the current state of your application. The projects you created in the first four chapters of this book didn't focus on state management too much, something that will be investigated much more in this chapter. </p>
			<p>This chapter will show how you can handle state management in React by creating an application state that is accessible from every component. Before React v16.3, you needed third-party packages to handle state in React, but with the renewed version of the context API, this is no longer mandatory. Also, with the release of React Hooks, more ways to mutate this Context were introduced. Using an example application, the methods for handling state management for your application are demonstrated.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Using the context API for state management</li>
				<li>Mutating Context with Hooks</li>
				<li>Code splitting with React Suspense</li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor067"/>Project overview</h1>
			<p>In this <a id="_idIndexMarker238"/>chapter, we will build a personal shopping list by adding state management using Context and Hooks. We will advance upon a boilerplate application that has been created with Create React App and has declarative routing using <strong class="source-inline">react-router</strong>. Also, code splitting of the bundle is added with React Suspense.</p>
			<p>The build time is 2.5 hours.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor068"/>Getting started</h1>
			<p>The<a id="_idIndexMarker239"/> project that we'll create in this chapter builds upon an initial version that you can find on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05-initial</a>. The complete source code can also be found on GitHub: <a href="https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter05</a>.</p>
			<p>After downloading the initial application, make sure that you run <strong class="source-inline">npm install</strong> from the project's root directory. This project is created using Create React App and installs the <strong class="source-inline">react</strong>, <strong class="source-inline">react-dom</strong>, <strong class="source-inline">react-scripts</strong>, <strong class="source-inline">styled-components</strong>, and <strong class="source-inline">react-router-dom</strong> packages, which you've already seen in previous chapters. After finishing the installation process, you can run <strong class="source-inline">npm start</strong> from the same tab in Terminal and view the project in your browser (<strong class="source-inline">http://localhost:3000</strong>).</p>
			<p>The initial application for this section is created with Create React App and has routing and data fetching already implemented. When you open the application, a screen displaying a header, a navigation bar, and two lists are being rendered. If, for example, you click on the first list that is displayed here, a new page will open that displays the items of this list. On this page, you can click on the <strong class="bold">Add Item</strong> button in the top-right corner to open a new page, which has a form to add a new list and looks like this:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_5.1_B17390.jpg" alt="Figure 5.1 – The initial application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The initial application</p>
			<p>This<a id="_idIndexMarker240"/> form is rendered by the <strong class="source-inline">ListForm</strong> component and has no functionality yet, as you'll add this later on. When you click on the left button, it redirects you to the previously visited page, using the navigate method from <strong class="source-inline">react-router-dom</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">When you try to submit the form to either add a new list or add a new item to a list, nothing happens yet. The functionality of these forms will be added in this section later on, for which you'll use the Context API and React Hooks.</p>
			<p>The project is structured in the same manner as the applications you've created before. A distinction is made, however, between reusable function components in the <strong class="source-inline">components</strong> directory and components that represent a route in the <strong class="source-inline">pages</strong> directory. The page components are using the <strong class="source-inline">useDataFetching</strong> Hook, which we saw earlier in <a href="B17390_03_Final_NM_ePub.xhtml#_idTextAnchor039"><em class="italic">Chapter 3</em></a>, <em class="italic">Building a Dynamic Project Management Board</em>, which adds data fetching.</p>
			<p>The<a id="_idIndexMarker241"/> following is an overview of the complete structure of the project:</p>
			<p class="source-code">chapter-5-initial</p>
			<p class="source-code">  |- /node_modules</p>
			<p class="source-code">  |- /public</p>
			<p class="source-code">  |- /src</p>
			<p class="source-code">    |- /components</p>
			<p class="source-code">       |- /Button</p>
			<p class="source-code">          |- Button.js</p>
			<p class="source-code">       |- /FormItem</p>
			<p class="source-code">          |- FormItem.js</p>
			<p class="source-code">       |- /Header</p>
			<p class="source-code">          |- Header.js</p>
			<p class="source-code">       |- /NavBar</p>
			<p class="source-code">          |- NavBar.js</p>
			<p class="source-code">       |- /ListItem</p>
			<p class="source-code">          |- ListItem.js</p>
			<p class="source-code">    |- /hooks</p>
			<p class="source-code">       |- useDataFetching.js</p>
			<p class="source-code">    |- /pages</p>
			<p class="source-code">       |- ListDetail.js</p>
			<p class="source-code">       |- ListForm.js</p>
			<p class="source-code">       |- Lists.js</p>
			<p class="source-code">    |- App.js</p>
			<p class="source-code">    |- index.js</p>
			<p class="source-code">  package.json</p>
			<p>The entry point of this application is the <strong class="source-inline">src/index.js</strong> file that renders the <strong class="source-inline">App</strong> component, which sets up routing using a <strong class="source-inline">Router</strong> component from <strong class="source-inline">react-router-dom</strong>. The <strong class="source-inline">App</strong> component contains a <strong class="source-inline">Header</strong> component and a <strong class="source-inline">Switch</strong> router component that defines four routes. These routes are as follows:</p>
			<ul>
				<li><strong class="source-inline">/</strong>: Renders <strong class="source-inline">Lists</strong>, with an overview of all of the lists</li>
				<li><strong class="source-inline">/list/:listId</strong>: Renders <strong class="source-inline">ListDetail</strong>, with an overview of all items from a specific list</li>
				<li><strong class="source-inline">/list/:listId/new</strong>: Renders <strong class="source-inline">ListForm</strong>, with a form to add new items to a specific list</li>
			</ul>
			<p>The data is <a id="_idIndexMarker242"/>fetched from a mock server that was created using the free service, My JSON Server, which creates a server from the <strong class="source-inline">db.json</strong> file in the root directory of your project in GitHub. This file consists of a JSON object that has two fields, <strong class="source-inline">items</strong> and <strong class="source-inline">lists</strong>, which creates multiple endpoints on a mock server. The ones you'll be using in this chapter are as follows:</p>
			<ul>
				<li><a href="https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items">https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/items</a></li>
				<li><a href="https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists">https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/lists</a><p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">db.json</strong> file must be present in the master branch (or default branch) of your GitHub repository for My JSON Server to work. Otherwise, you'll receive a <strong class="bold">404 Not Found</strong> message when trying to request the API endpoints.</p></li>
			</ul>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor069"/>Personal shopping list</h1>
			<p>In this section, you'll build a<a id="_idIndexMarker243"/> personal shopping list application that has state management using Context and Hooks. With this application, you can create shopping lists that you can add items to, along with their quantities and prices. The starting point of this section is an initial application that has routing and local state management already enabled.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor070"/>Using the Context API for state management</h2>
			<p>State management is very important, as the current state of the application holds data that is valuable to the <a id="_idIndexMarker244"/>user. In previous chapters, you've already used local state management by using <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong> Hooks. This pattern is very useful when the data in the state is only of importance to the components you're setting the state in. As passing down the state as props through several components can become confusing, you'd need a way to access props throughout your application even when you're not specifically passing them as props. For this, you can use the Context API from React, which is also used by packages you've already used in previous chapters such as <strong class="source-inline">styled-components</strong> and <strong class="source-inline">react-router-dom</strong>.</p>
			<p>To share state across multiple components, a React feature called Context will be explored, starting in the first part of this section.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor071"/>Creating Context</h2>
			<p>When you want to add Context to your React application, you can do this by creating a new <a id="_idIndexMarker245"/>Context with the <strong class="source-inline">createContext</strong> method from React. This creates a Context object that consists of two React components, called Provider and Consumer. The Provider is where the initial (and subsequently current) value of the Context is placed, which can be accessed by components that are present within the Consumer.</p>
			<p>This is done in the <strong class="source-inline">App</strong> component in <strong class="source-inline">src/App.js</strong>, as you want the Context for the lists to be available in every component that is rendered by <strong class="source-inline">Route</strong>:</p>
			<ol>
				<li>Let's start by creating a Context for the lists and making it exportable so that the list data can be used everywhere. For this, you can create a new file called <strong class="source-inline">ListsContext.js</strong> inside a new directory, <strong class="source-inline">src/context</strong>. In this file, you can add the<a id="_idIndexMarker246"/> following code:<p class="source-code">import { createContext } from 'react';</p><p class="source-code">import useDataFetching from </p><p class="source-code">  '../hooks/useDataFetching';</p><p class="source-code">export const ListsContext = createContext();</p><p class="source-code">export const ListsContextProvider = ({ children }) =&gt; {</p><p class="source-code">  const [loading, error, data] = useDataFetching(</p><p class="source-code">    'https://my-json-server.typicode.com/</p><p class="source-code">     PacktPublishing/React-Projects-Second-Edition/</p><p class="source-code">     lists',</p><p class="source-code">  );</p><p class="source-code">  </p><p class="source-code">  return (</p><p class="source-code">    &lt;ListsContext.Provider value=</p><p class="source-code">      {{ lists: data, loading, error }}&gt;</p><p class="source-code">      {children}</p><p class="source-code">    &lt;/ListsContext.Provider&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default ListsContext;</p></li>
			</ol>
			<p>The previous code creates a Provider based on a <strong class="source-inline">Context</strong> object that is passed as a prop and sets a value based on the return from the <strong class="source-inline">useDataFetching</strong> Hook that is fetching all of the lists. Using the <strong class="source-inline">children</strong> prop, all of the components that will be wrapped inside the <strong class="source-inline">ListsContextProvider</strong> component can retrieve the data for the value from a Consumer.</p>
			<ol>
				<li value="2">This <strong class="source-inline">ListsContextProvider</strong> component can be imported inside your <strong class="source-inline">App</strong> component <a id="_idIndexMarker247"/>to wrap the Router component that is wrapping all the routes for our application:<p class="source-code"><strong class="bold">  import styled, { createGlobalStyle } from </strong></p><p class="source-code"><strong class="bold">    'styled-components';</strong></p><p class="source-code"><strong class="bold">  import { Route, Routes, BrowserRouter } from </strong></p><p class="source-code"><strong class="bold">    'react-router-dom';</strong></p><p class="source-code"><strong class="bold">+ import { ListsContextProvider } from </strong></p><p class="source-code"><strong class="bold">    './context/ListsContext';</strong></p><p class="source-code"><strong class="bold">  // ...</strong></p><p class="source-code"><strong class="bold">  function App() { </strong></p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">       &lt;GlobalStyle /&gt;</p><p class="source-code">       &lt;AppWrapper&gt;</p><p class="source-code"><strong class="bold">         &lt;BrowserRouter&gt;</strong></p><p class="source-code"><strong class="bold">           &lt;Header /&gt;</strong></p><p class="source-code"><strong class="bold">+          &lt;ListsContextProvider&gt;</strong></p><p class="source-code"><strong class="bold">             &lt;Routes&gt;</strong></p><p class="source-code">               // ...</p><p class="source-code"><strong class="bold">             &lt;/Routes&gt;</strong></p><p class="source-code"><strong class="bold">+          &lt;/ListsContextProvider&gt;</strong></p><p class="source-code">         &lt;/BrowserRouter&gt;</p><p class="source-code">       &lt;/AppWrapper&gt;</p><p class="source-code">     &lt;/&gt;</p><p class="source-code">   );</p><p class="source-code">  }</p><p class="source-code">  export default App;</p></li>
				<li>This way, you're now<a id="_idIndexMarker248"/> able to consume the value from the Provider for <strong class="source-inline">ListsContext</strong>, from all the components wrapped within <strong class="source-inline">ListsContextProvider</strong>. In the <strong class="source-inline">Lists</strong> component, this data can be retrieved using the <strong class="source-inline">useContext</strong> Hook from React by passing the <strong class="source-inline">ListsContext</strong> object to it. This data can then be used to render the lists, and the <strong class="source-inline">useDataFetching</strong> Hook can be removed from <strong class="source-inline">src/pages/Lists.js</strong>:<p class="source-code"><strong class="bold">+ import { useContext } from 'react';</strong></p><p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { Link, useNavigate } from </p><p class="source-code">    'react-router-dom';</p><p class="source-code"><strong class="bold">- import useDataFetching from</strong></p><p class="source-code"><strong class="bold">    '../hooks/useDataFetching';</strong></p><p class="source-code">  import NavBar from '../components/NavBar/NavBar';</p><p class="source-code"><strong class="bold">+ import ListsContext from '../context/ListsContext';</strong></p><p class="source-code">  // ...</p><p class="source-code">  const Lists = () =&gt; {</p><p class="source-code">    let navigate = useNavigate();</p><p class="source-code"><strong class="bold">-   const [loading, error, data] =</strong></p><p class="source-code"><strong class="bold">      useDataFetching('https://my-json-server.</strong></p><p class="source-code"><strong class="bold">      typicode.com/PacktPublishing/React-Projects-</strong></p><p class="source-code"><strong class="bold">      Second-Edition/lists');</strong></p><p class="source-code"><strong class="bold">+   const { loading, error, lists } = </strong></p><p class="source-code"><strong class="bold">      useContext(ListsContext);</strong></p><p class="source-code">  return (</p><p class="source-code">          &lt;&gt;</p><p class="source-code">        {navigate &amp;&amp; &lt;NavBar title='Your Lists' /&gt;}</p><p class="source-code">        &lt;ListWrapper&gt;</p><p class="source-code">          {loading || error ? (</p><p class="source-code">            &lt;span&gt;{error || 'Loading...'}&lt;/span&gt;</p><p class="source-code">          ) : (</p><p class="source-code"><strong class="bold">-           data.map((list) =&gt; (</strong></p><p class="source-code"><strong class="bold">+           lists.map((list) =&gt; (</strong></p><p class="source-code">              &lt;ListLink key={list.id} </p><p class="source-code">               to={`list/${list.id}`}&gt;</p><p class="source-code">                // ...</p></li>
			</ol>
			<p>Now that you've removed the <strong class="source-inline">useDataFetching</strong> Hook from <strong class="source-inline">Lists</strong>, no requests to the API are sent directly from this component anymore. The data for the lists is instead fetched from <strong class="source-inline">ListsContextProvider</strong> and is passed by <strong class="source-inline">ListsContext</strong>, which is used by the <strong class="source-inline">useContext</strong> Hook in <strong class="source-inline">Lists</strong>. If you <a id="_idIndexMarker249"/>open the application in the browser by going to <strong class="source-inline">http://localhost:3000/</strong>, you can see the lists are being rendered just as before.</p>
			<p>In the next section, you'll also add a Context object for the items, so the items are also available to all of the components within the Routes component from <strong class="source-inline">react-router</strong>. </p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>Nesting Context</h2>
			<p>Just as for<a id="_idIndexMarker250"/> the list data, the item data could also be stored in Context and passed to the components that need this data. That way, data is no longer fetched from any of the rendered components but from the Context only:</p>
			<ol>
				<li value="1">Again, start by creating a new file where both a Context and Provider are created. This time, it's called <strong class="source-inline">ItemsContext.js</strong>, which can also be added to the <strong class="source-inline">src/context</strong> directory:<p class="source-code">import { createContext } from 'react';</p><p class="source-code">import useDataFetching from </p><p class="source-code">  '../hooks/useDataFetching';</p><p class="source-code">export const ItemsContext = createContext();</p><p class="source-code">export const ItemsContextProvider = ({ children }) =&gt; {</p><p class="source-code">  const [loading, error, data] = useDataFetching(</p><p class="source-code">    'https://my-json-server.typicode.com/</p><p class="source-code">     PacktPublishing/React-Projects-Second-</p><p class="source-code">     Edition/items',</p><p class="source-code">  );</p><p class="source-code">  return (</p><p class="source-code">    &lt;ItemsContext.Provider value=</p><p class="source-code">      {{ items: data, loading, error }}&gt;</p><p class="source-code">      {children}</p><p class="source-code">    &lt;/ItemsContext.Provider&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default ItemsContext;</p></li>
				<li>Next, import <a id="_idIndexMarker251"/>this new Context and Provider in <strong class="source-inline">src/App.js</strong>, where you can nest this below the <strong class="source-inline">ListsContextProvider</strong> component:<p class="source-code">  // ...</p><p class="source-code">  import { ListsContextProvider } from </p><p class="source-code">    './context/ListsContext';</p><p class="source-code"><strong class="bold">+ import { ItemsContextProvider } from </strong></p><p class="source-code"><strong class="bold">    './context/ItemsContext';</strong></p><p class="source-code">  // ...</p><p class="source-code">  </p><p class="source-code">  function App() { </p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;GlobalStyle /&gt;</p><p class="source-code">        &lt;AppWrapper&gt;</p><p class="source-code">          &lt;BrowserRouter&gt;</p><p class="source-code">            &lt;Header /&gt;</p><p class="source-code">            &lt;ListsContextProvider&gt;</p><p class="source-code"><strong class="bold">+             &lt;ItemsContextProvider&gt;</strong></p><p class="source-code">                &lt;Routes&gt;</p><p class="source-code">                  // ...</p><p class="source-code">                &lt;/Routes&gt;</p><p class="source-code"><strong class="bold">+             &lt;/ItemsContextProvider&gt;</strong></p><p class="source-code">            &lt;/ListsContextProvider&gt;</p><p class="source-code">          &lt;/BrowserRouter&gt;</p><p class="source-code">        &lt;/AppWrapper&gt;</p><p class="source-code">      &lt;/&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default App;</p></li>
				<li>The <strong class="source-inline">ListDetail</strong> component can<a id="_idIndexMarker252"/> now get the item from <strong class="source-inline">ItemsContext</strong>, meaning we no longer have to use the <strong class="source-inline">useDataFetching</strong> Hook in this component. To accomplish this, you need to make the <a id="_idIndexMarker253"/>following changes to <strong class="source-inline">src/pages/ListDetail.js</strong>:<p class="source-code"><strong class="bold">- import { useState, useEffect } from 'react';</strong></p><p class="source-code"><strong class="bold">+ import { useState, useEffect, useContext } from </strong></p><p class="source-code"><strong class="bold">    'react';</strong></p><p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { useNavigate, useParams } from </p><p class="source-code">    'react-router-dom';</p><p class="source-code"><strong class="bold">- import useDataFetching from </strong></p><p class="source-code"><strong class="bold">    '../hooks/useDataFetching';</strong></p><p class="source-code">  import NavBar from '../components/NavBar/NavBar';</p><p class="source-code">  import ListItem from</p><p class="source-code">    '../components/ListItem/ListItem';</p><p class="source-code"><strong class="bold">+ import ItemsContext from '../context/ItemsContext';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function ListDetail() {</p><p class="source-code">    let navigate = useNavigate();</p><p class="source-code">    const { listId } = useParams();</p><p class="source-code"><strong class="bold">-   const [loading, error, data] =</strong></p><p class="source-code"><strong class="bold">      useDataFetching('https://my-json-server.</strong></p><p class="source-code"><strong class="bold">      typicode.com/PacktPublishing/React-Projects-</strong></p><p class="source-code"><strong class="bold">      Second-Edition/items/');</strong></p><p class="source-code"><strong class="bold">+   const { loading, error, items: data } = </strong></p><p class="source-code"><strong class="bold">      useContext(ItemsContext);</strong></p><p class="source-code">    // ...</p></li>
			</ol>
			<p>All of the data<a id="_idIndexMarker254"/> fetching is now no longer by the <strong class="source-inline">List</strong> and <strong class="source-inline">Lists</strong> components. By nesting these Context Providers, the return values can be consumed by multiple components. But this still isn't ideal, as you're now loading all of the lists and all of the items when starting your application.</p>
			<p>The downside of this approach is that once we open a detail page for a list, it will retrieve all items, even if they are not for this list. In the next section, you'll see how to get only the data you need by combining Context with custom Hooks.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor073"/>Mutating Context with Hooks</h1>
			<p>There are <a id="_idIndexMarker255"/>multiple ways in which you can get data conditionally from the <a id="_idIndexMarker256"/>Context; one of these is placing the data from the Context in the local state. That could be a solution for a smaller application, but can be inefficient for larger applications, as you'd still need to pass this state down your component tree. Another solution is to use React Hooks to create a function that is added to the value of your Context and can be invoked from any of the components that are nested in this Context. Also, this method of getting the data lets you efficiently load only the data that you'd need.</p>
			<p>How this can be used together with React life cycles and state management using Hooks is demonstrated in the first part of this section.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor074"/>Using life cycles in functional components</h2>
			<p>Previously, we used <a id="_idIndexMarker257"/>the <strong class="source-inline">useDataFetching</strong> Hook<a id="_idIndexMarker258"/> to do the data fetching for us, but this doesn't let us control when the data will be fetched exactly. From the components that are consuming our Context data, we want to be able to initiate the data fetching. Therefore we need to add life cycles to them, which invoke a function to do the data fetching inside our Context components. Follow these steps to implement this:</p>
			<ol>
				<li value="1">The first <a id="_idIndexMarker259"/>step in achieving this is by adding logic to do<a id="_idIndexMarker260"/> data fetching in the <strong class="source-inline">src/context/ItemsContext.js</strong> file. This logic will replace the usage of the <strong class="source-inline">useDataFetching</strong> Hook, starting with adding local state variables for the data fetching state:<p class="source-code"><strong class="bold">- import { createContext } from 'react';</strong></p><p class="source-code"><strong class="bold">- import useDataFetching from </strong></p><p class="source-code"><strong class="bold">    '../hooks/useDataFetching';</strong></p><p class="source-code"><strong class="bold">+ import { createContext, useCallback, useState } from</strong></p><p class="source-code"><strong class="bold">    'react';</strong></p><p class="source-code">  export const ItemsContext = createContext();</p><p class="source-code">  export const ItemsContextProvider = ({ children }) </p><p class="source-code">    =&gt; {</p><p class="source-code"><strong class="bold">-   const [loading, error, data] =</strong></p><p class="source-code"><strong class="bold">      useDataFetching('https://my-json-server.</strong></p><p class="source-code"><strong class="bold">      typicode.com/PacktPublishing/React-Projects-</strong></p><p class="source-code"><strong class="bold">      Second-Edition/items);</strong></p><p class="source-code"><strong class="bold">+   const [loading, setLoading] = useState(true);</strong></p><p class="source-code"><strong class="bold">+   const [items, setItems] = useState([]);</strong></p><p class="source-code"><strong class="bold">+   const [error, setError] = useState('');</strong></p><p class="source-code">    // ...</p></li>
				<li>After <a id="_idIndexMarker261"/>this, we can add a function <a id="_idIndexMarker262"/>called <strong class="source-inline">fetchItems</strong> that we pass to <strong class="source-inline">ItemsContextProvider</strong>, meaning it will be added to the Context. This function is wrapped in a <strong class="source-inline">useCallback</strong> Hook to prevent unneeded (re)renders of your component:<p class="source-code">    // ...</p><p class="source-code">    const [error, setError] = useState('');</p><p class="source-code"><strong class="bold">+   const fetchItems = useCallback(async (listId) =&gt; {</strong></p><p class="source-code"><strong class="bold">+     try {</strong></p><p class="source-code"><strong class="bold">+       const data = await fetch(`https://my-json-</strong></p><p class="source-code"><strong class="bold">          server.typicode.com/PacktPublishing/</strong></p><p class="source-code"><strong class="bold">          React-Projects-Second-Edition/lists/</strong></p><p class="source-code"><strong class="bold">          ${listId}/items`);</strong></p><p class="source-code"><strong class="bold">+       const result = await data.json();</strong></p><p class="source-code"><strong class="bold">+       if (result) {</strong></p><p class="source-code"><strong class="bold">+         setItems(result);</strong></p><p class="source-code"><strong class="bold">+         setLoading(false);</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     } catch (e) {</strong></p><p class="source-code"><strong class="bold">+       setLoading(false);</strong></p><p class="source-code"><strong class="bold">+       setError(e.message);</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }, [])</strong></p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;ItemsContext.Provider value={{ data: items,</strong></p><p class="source-code"><strong class="bold">        loading, error }}&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;ItemsContext.Provider value={{ items, loading,</strong></p><p class="source-code"><strong class="bold">        error, fetchItems }}&gt;</strong></p><p class="source-code">      // ...</p></li>
				<li>With <a id="_idIndexMarker263"/>this function in place, the next step <a id="_idIndexMarker264"/>would be to invoke it with a value for <strong class="source-inline">listId</strong> from the <strong class="source-inline">ListDetail</strong> component. This would mean that we no longer retrieve all the items once we load this component, but use the params from the URL to determine what data should be fetched and added to the Context:<p class="source-code"><strong class="bold">- import { useState, useEffect, useContext } from</strong></p><p class="source-code"><strong class="bold">   'react';</strong></p><p class="source-code"><strong class="bold">+ import { useEffect, useContext } from 'react';</strong></p><p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  // ...</p><p class="source-code">  function ListDetail() {</p><p class="source-code">    let navigate = useNavigate();</p><p class="source-code">    const { listId } = useParams();</p><p class="source-code"><strong class="bold">-   const { loading, error, items: data } =</strong></p><p class="source-code"><strong class="bold">      useContext(ItemsContext);</strong></p><p class="source-code"><strong class="bold">+   const { loading, error, items, fetchItems } = </strong></p><p class="source-code"><strong class="bold">      useContext(ItemsContext);</strong></p><p class="source-code"><strong class="bold">-   const [items, setItems] = useState([]);</strong></p><p class="source-code"><strong class="bold">-   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">-     data &amp;&amp; listId &amp;&amp; setItems(data.filter((item) =&gt;</strong></p><p class="source-code"><strong class="bold">        item.listId === parseInt(listId)));</strong></p><p class="source-code"><strong class="bold">-   }, [data, listId]);</strong></p><p class="source-code"><strong class="bold">+   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     listId &amp;&amp; !items.length &amp;&amp; fetchItems(listId);</strong></p><p class="source-code"><strong class="bold">+   }, [fetchItems, items, listId]);</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
			</ol>
			<p>The<a id="_idIndexMarker265"/> preceding <strong class="source-inline">useEffect</strong> Hooks call the <strong class="source-inline">fetchItems</strong> function when there's a <strong class="source-inline">listId</strong> present in the URL of the page, and when<a id="_idIndexMarker266"/> the value for <strong class="source-inline">items</strong> is an empty array. This prevents us from fetching the items again if they already exist in <strong class="source-inline">ItemsContext</strong>.</p>
			<p>By creating a function to do data fetching in our Context, we can now control when the data should be fetched, so there will no longer be unnecessary requests to the API. But other Hooks can also directly pass data to the Provider without having to duplicate <strong class="source-inline">useState</strong> Hooks. This will be demonstrated in the next part of this section.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor075"/>Using advanced state with useReducer</h2>
			<p>Another way <a id="_idIndexMarker267"/>to use actions for adding data to the <a id="_idIndexMarker268"/>Provider is by using a pattern similar to Flux, which was introduced by Facebook. The Flux pattern describes a data flow where actions are being dispatched that retrieve data from a store and return it to the view. This would mean that actions need to be described somewhere; there should be a central place where data is stored and this data can be read by the view. To accomplish this pattern with the Context API, you can use another Hook, called <strong class="source-inline">useReducer</strong>. This Hook can be used to return data not from a local state, but from any data variable:</p>
			<ol>
				<li value="1">Just as with the <strong class="source-inline">useState</strong> Hook, the <strong class="source-inline">useReducer</strong> Hook needs to be added to the component that is using it. <strong class="source-inline">useReducer</strong> will take an initial state and a function that determines which data should be returned. This initial value needs to be added to the <strong class="source-inline">src/context/ListsContext.js</strong> file before adding the Hook:<p class="source-code"><strong class="bold">- import { createContext } from 'react';</strong></p><p class="source-code"><strong class="bold">+ import { createContext, useCallback, useReducer }</strong></p><p class="source-code"><strong class="bold">    from 'react';</strong></p><p class="source-code"><strong class="bold">  const ListsContext = createContext();</strong></p><p class="source-code"><strong class="bold">+ const initialState = {</strong></p><p class="source-code"><strong class="bold">+   lists: [],</strong></p><p class="source-code"><strong class="bold">+   loading: true,</strong></p><p class="source-code"><strong class="bold">+   error: '',</strong></p><p class="source-code"><strong class="bold">+ };</strong></p><p class="source-code"><strong class="bold">  // ...</strong></p></li>
				<li>Next to an initial value, the <strong class="source-inline">useReducer</strong> Hook also takes a function that's called <strong class="source-inline">reducer</strong>. This <strong class="source-inline">reducer</strong> function should also be created and is a function that updates <strong class="source-inline">initialState</strong>, which was passed and returns the current value, based on the action that was sent to it. If the action that was dispatched doesn't <a id="_idIndexMarker269"/>match any of those defined in <strong class="source-inline">reducer</strong>, the <a id="_idIndexMarker270"/>reducer will just return the current value without any changes:<p class="source-code">  import { createContext, useReducer } from 'react';</p><p class="source-code">  const ListsContext = createContext();</p><p class="source-code"><strong class="bold">  // ...</strong></p><p class="source-code"><strong class="bold">+ const reducer = (state, action) =&gt; {</strong></p><p class="source-code"><strong class="bold">+   switch (action.type) {</strong></p><p class="source-code"><strong class="bold">+     case 'GET_LISTS_SUCCESS':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         lists: action.payload,</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code"><strong class="bold">+     case 'GET_LISTS_ERROR':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         lists: [],</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+         error: action.payload,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code"><strong class="bold">+     default:</strong></p><p class="source-code"><strong class="bold">+       return state;</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ };</strong></p><p class="source-code">  </p><p class="source-code">  export const ListsContextProvider = ({ children }) =&gt; {</p><p class="source-code">    // ...</p></li>
				<li>The two <a id="_idIndexMarker271"/>parameters for the <strong class="source-inline">useReducer</strong> Hook <a id="_idIndexMarker272"/>are now added to the file, so you need to add the actual Hook and pass <strong class="source-inline">initialState</strong> and <strong class="source-inline">reducer</strong> to it. The <strong class="source-inline">useDataFetching</strong> Hook can be removed, as this will be replaced with a new function that has data fetching logic:<p class="source-code"><strong class="bold">  // ...</strong></p><p class="source-code"><strong class="bold">  const ListsContextProvider = ({ children }) =&gt; { </strong></p><p class="source-code"><strong class="bold">-   const [loading, error, data] =</strong></p><p class="source-code"><strong class="bold">      useDataFetching('https://my-json-server.</strong></p><p class="source-code"><strong class="bold">      typicode.com/PacktPublishing/React-Projects-</strong></p><p class="source-code"><strong class="bold">      Second-Edition/lists');</strong></p><p class="source-code"><strong class="bold">+   const [state, dispatch] = </strong></p><p class="source-code"><strong class="bold">      useReducer(reducer, initialState);</strong></p><p class="source-code"><strong class="bold">  // ...</strong></p></li>
				<li>As you can see, <strong class="source-inline">reducer</strong> changes the value it returns when the <strong class="source-inline">GET_LISTS_SUCCESS</strong> or <strong class="source-inline">GET_LISTS_ERROR</strong> action is sent to it. Before it was mentioned, you can call this <strong class="source-inline">reducer</strong> by using the <strong class="source-inline">dispatch</strong> function that was returned by the <strong class="source-inline">useReducer</strong> Hook. However, as you also have to deal with the<a id="_idIndexMarker273"/> asynchronous fetching of the <a id="_idIndexMarker274"/>data, you can't invoke this function directly. Instead, you need to create an <strong class="source-inline">async/await</strong> function that calls the <strong class="source-inline">fetchData</strong> function and dispatches the correct action afterward:<p class="source-code">  // ...</p><p class="source-code">  export const ListsContextProvider = ({ children })</p><p class="source-code">    =&gt; {</p><p class="source-code">    const [state, dispatch] = </p><p class="source-code">      useReducer(reducer, initialState);</p><p class="source-code"><strong class="bold">+   const fetchLists = useCallback(async () =&gt; {</strong></p><p class="source-code"><strong class="bold">+     try {</strong></p><p class="source-code"><strong class="bold">+       const data = await fetch(`https://my-json-</strong></p><p class="source-code"><strong class="bold">          server.typicode.com/PacktPublishing/React-</strong></p><p class="source-code"><strong class="bold">          Projects-Second-Edition/lists`);</strong></p><p class="source-code"><strong class="bold">+       const result = await data.json();</strong></p><p class="source-code"><strong class="bold">+       if (result) {</strong></p><p class="source-code"><strong class="bold">+         dispatch({ type: 'GET_LISTS_SUCCESS', </strong></p><p class="source-code"><strong class="bold">                     payload: result });</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     } catch (e) {</strong></p><p class="source-code"><strong class="bold">+       dispatch({ type: 'GET_LISTS_ERROR', </strong></p><p class="source-code"><strong class="bold">          payload: e.message });</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }, [])</strong></p><p class="source-code">  return (</p><p class="source-code">    // ...</p></li>
				<li>The preceding <strong class="source-inline">fetchLists</strong> function calls the API and if there is a result, the <strong class="source-inline">GET_LISTS_SUCCESS</strong> action will be dispatched to the reducer using the <strong class="source-inline">dispatch</strong> function from the <strong class="source-inline">useReducer</strong> Hook. If not, the <strong class="source-inline">GET_LISTS_ERROR</strong> action will be dispatched, which returns an error message. </li>
				<li>The values<a id="_idIndexMarker275"/> from the state and the <strong class="source-inline">fetchLists</strong> function<a id="_idIndexMarker276"/> must be added to the Provider so that we can access them from other components through the Context:<p class="source-code">    // ...</p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;ListsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">        {{ loading, error, data: lists }}&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;ListsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">        {{ ...state, fetchLists }}&gt;</strong></p><p class="source-code">        {children}</p><p class="source-code">      &lt;/ListsContext.Provider&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">  export default ListsContext;</p></li>
				<li>This <strong class="source-inline">getLists</strong> function<a id="_idIndexMarker277"/> can now be invoked from<a id="_idIndexMarker278"/> the <strong class="source-inline">useEffect</strong> Hook in the component where the lists are displayed, the <strong class="source-inline">Lists</strong> component, on the first render. The lists should only be retrieved when there aren't any lists available yet:<p class="source-code"><strong class="bold">- import { useContext } from 'react';</strong></p><p class="source-code"><strong class="bold">+ import { useContext, useEffect } from 'react';</strong></p><p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { Link, useNavigate } from </p><p class="source-code">    'react-router-dom';</p><p class="source-code">  import NavBar from '../components/NavBar/NavBar';</p><p class="source-code">  import ListsContext from '../context/ListsContext';</p><p class="source-code">  // ...</p><p class="source-code">  function Lists() {</p><p class="source-code">    let navigate = useNavigate();</p><p class="source-code"> </p><p class="source-code"><strong class="bold">-   const { loading, error, lists } =</strong></p><p class="source-code"><strong class="bold">      useContext(ListsContext);</strong></p><p class="source-code"><strong class="bold">+   const { loading, error, lists, fetchLists } = </strong></p><p class="source-code"><strong class="bold">      useContext(ListsContext);</strong></p><p class="source-code"><strong class="bold">+   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     !lists.length &amp;&amp; fetchLists()</strong></p><p class="source-code"><strong class="bold">+   }, [fetchLists, lists])</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...</p></li>
			</ol>
			<p>If you now<a id="_idIndexMarker279"/> visit the project in the browser again, you <a id="_idIndexMarker280"/>can see the data from the lists is loaded just as before. The big difference is that the data is fetched using a Flux pattern, meaning this can be extended to fetch the data in other instances as well. The same can be done for <strong class="source-inline">ItemsContext</strong> as well, in the <strong class="source-inline">src/context/ItemsContext.js</strong> file:</p>
			<ol>
				<li value="1">First, import the <strong class="source-inline">useReducer</strong> Hook, and add the initial value for the items and the <strong class="source-inline">reducer</strong> function that we use with this Hook later:<p class="source-code"><strong class="bold">- import { createContext, useState } from 'react';</strong></p><p class="source-code"><strong class="bold">+ import { createContext, useReducer } from 'react';</strong></p><p class="source-code">  export const ItemsContext = createContext();</p><p class="source-code"><strong class="bold">+ const initialState = {</strong></p><p class="source-code"><strong class="bold">+   items: [],</strong></p><p class="source-code"><strong class="bold">+   loading: true,</strong></p><p class="source-code"><strong class="bold">+   error: '',</strong></p><p class="source-code"><strong class="bold">+ };</strong></p><p class="source-code"><strong class="bold">+ const reducer = (state, action) =&gt; {</strong></p><p class="source-code"><strong class="bold">+   switch (action.type) {</strong></p><p class="source-code"><strong class="bold">+     case 'GET_ITEMS_SUCCESS':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         items: action.payload,</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code"><strong class="bold">+     case 'GET_ITEMS_ERROR':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         items: [],</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+         error: action.payload,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code"><strong class="bold">+     default:</strong></p><p class="source-code"><strong class="bold">+       return state;</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+ };</strong></p><p class="source-code">  export const ItemsContextProvider = </p><p class="source-code">    ({ children }) =&gt; {</p><p class="source-code">    // ...</p></li>
				<li>After this, you <a id="_idIndexMarker281"/>can add the initial state and reducer<a id="_idIndexMarker282"/> to the <strong class="source-inline">useReducer</strong> Hook. The <strong class="source-inline">fetchItems</strong> function that already exists in this file must be changed so that it will use the <strong class="source-inline">dispatch</strong> function from <strong class="source-inline">useReducer</strong> instead of the <strong class="source-inline">update</strong> functions from the <strong class="source-inline">useState</strong> Hooks:<p class="source-code">  // ...</p><p class="source-code">  export const ItemsContextProvider =</p><p class="source-code">    ({ children }) =&gt; {</p><p class="source-code"><strong class="bold">-   const [loading, setLoading] = useState(true);</strong></p><p class="source-code"><strong class="bold">-   const [items, setItems] = useState([]);</strong></p><p class="source-code"><strong class="bold">-   const [error, setError] = useState('');</strong></p><p class="source-code"><strong class="bold">+   const [state, dispatch] =</strong></p><p class="source-code"><strong class="bold">      useReducer(reducer, initialState);</strong></p><p class="source-code"><strong class="bold">  const fetchItems = useCallback(async (listId) =&gt; {</strong></p><p class="source-code">    try {</p><p class="source-code">      const data = await fetch(`https://my-json-</p><p class="source-code">        server.typicode.com/PacktPublishing/React-</p><p class="source-code">        Projects-Second-Edition/lists/${listId}/</p><p class="source-code">        items`);</p><p class="source-code">      const result = await data.json();</p><p class="source-code">      if (result) {</p><p class="source-code"><strong class="bold">-       setItems(result);</strong></p><p class="source-code"><strong class="bold">-       setLoading(false);</strong></p><p class="source-code"><strong class="bold">+       dispatch({ type: 'GET_ITEMS_SUCCESS', </strong></p><p class="source-code"><strong class="bold">           payload: result });</strong></p><p class="source-code">      }</p><p class="source-code">    } catch (e) {</p><p class="source-code"><strong class="bold">-     setLoading(false);</strong></p><p class="source-code"><strong class="bold">-     setError(e.message);</strong></p><p class="source-code"><strong class="bold">+     dispatch({ type: 'GET_ITEMS_ERROR', </strong></p><p class="source-code"><strong class="bold">        payload: e.message });</strong></p><p class="source-code">    }</p><p class="source-code">  }, [])</p><p class="source-code">  return (</p><p class="source-code">    // ...</p></li>
				<li>Also, add <a id="_idIndexMarker283"/>the state and the <strong class="source-inline">fetchItems</strong> function <a id="_idIndexMarker284"/>to <strong class="source-inline">ListsContextProvider</strong>:<p class="source-code">    // ...</p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;ItemsContext.Provider value={{ items, loading, </strong></p><p class="source-code"><strong class="bold">        error, fetchItems }}&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;ItemsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">        {{ ...state, fetchItems }}&gt;</strong></p><p class="source-code">        {children}</p><p class="source-code">      &lt;/ItemsContext.Provider&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">  export default ItemsContext;</p></li>
			</ol>
			<p>If you were to open a specific list on the <strong class="source-inline">/lists/:listId</strong> route, for example, <strong class="source-inline">http://localhost:3000/list/1</strong>, you would see that nothing has changed and that the items for the list are still displayed.</p>
			<p>You might <a id="_idIndexMarker285"/>notice that the title of the list isn't displayed <a id="_idIndexMarker286"/>here. The information for the lists is only fetched when the <strong class="source-inline">Lists</strong> component is first rendered, so you'd need to create a new function to always fetch the information for the list that you're currently displaying in the <strong class="source-inline">List</strong> component:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">src/context/ListsContextProvider.js</strong> file, you need to extend <strong class="source-inline">initialState</strong> to also have a field called <strong class="source-inline">list</strong>:<p class="source-code">  import { createContext, useReducer } from 'react';</p><p class="source-code">  export const ListsContext = createContext();</p><p class="source-code">  const initialState = {</p><p class="source-code">    lists: [],</p><p class="source-code"><strong class="bold">+   list: {},</strong></p><p class="source-code">    loading: true,</p><p class="source-code">    error: '',</p><p class="source-code">  };</p><p class="source-code">  const reducer = (state, action) =&gt; {</p><p class="source-code">    // ...</p></li>
				<li>In <strong class="source-inline">reducer</strong>, you also now have to check for two new actions that either add the data about a list to the context or add an error message:<p class="source-code">  // ...</p><p class="source-code">  const reducer = (state, action) =&gt; {</p><p class="source-code">    switch (action.type) {</p><p class="source-code">      case 'GET_LISTS_SUCCESS':</p><p class="source-code">         // ...</p><p class="source-code">      case 'GET_LISTS_ERROR':</p><p class="source-code">        // ...</p><p class="source-code"><strong class="bold">+     case 'GET_LIST_SUCCESS':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         list: action.payload,</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code"><strong class="bold">+     case 'GET_LIST_ERROR':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         list: {},</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+         error: action.payload,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code">      default:</p><p class="source-code">        return state;</p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">  export const ListsContextProvider = </p><p class="source-code">    ({ children }) =&gt; {</p><p class="source-code">    // ...</p></li>
				<li>These actions <a id="_idIndexMarker287"/>will be dispatched from a<a id="_idIndexMarker288"/> new <strong class="source-inline">fetchList</strong> function that takes the specific ID of a list to call the API. If successful, the <strong class="source-inline">GET_LIST_SUCCESS</strong> action will be dispatched; otherwise, the <strong class="source-inline">GET_LIST_ERROR</strong> action is dispatched. Also, pass the function to the Provider so that it can be used from other components:<p class="source-code">  // ...</p><p class="source-code"><strong class="bold">+   const fetchList = useCallback(async (listId) =&gt; {</strong></p><p class="source-code"><strong class="bold">+     try {</strong></p><p class="source-code"><strong class="bold">+       const data = await fetch(`https://my-json-</strong></p><p class="source-code"><strong class="bold">          server.typicode.com/PacktPublishing/React-</strong></p><p class="source-code"><strong class="bold">          Projects-Second-Edition/lists/${listId}`);</strong></p><p class="source-code"><strong class="bold">+       const result = await data.json();</strong></p><p class="source-code"><strong class="bold">+       if (result) {</strong></p><p class="source-code"><strong class="bold">+         dispatch({ type: 'GET_LIST_SUCCESS',</strong></p><p class="source-code"><strong class="bold">            payload: result });</strong></p><p class="source-code"><strong class="bold">+       }</strong></p><p class="source-code"><strong class="bold">+     } catch (e) {</strong></p><p class="source-code"><strong class="bold">+       dispatch({ type: 'GET_LIST_ERROR', </strong></p><p class="source-code"><strong class="bold">          payload: e.message });</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   }, [])</strong></p><p class="source-code">    return (</p><p class="source-code"><strong class="bold">-     &lt;ListsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">        {{ ...state, fetchLists }}&gt;</strong></p><p class="source-code"><strong class="bold">+     &lt;ListsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">        {{ ...state, fetchLists, fetchList }}&gt;</strong></p><p class="source-code">        {children}</p><p class="source-code">      &lt;/ListsContext.Provider&gt;</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">  export default ListsContext;</p></li>
				<li>And, in <a id="_idIndexMarker289"/>the <strong class="source-inline">ListDetail</strong> component, we <a id="_idIndexMarker290"/>can get the list data from <strong class="source-inline">ListsContext</strong> by calling the <strong class="source-inline">fetchList</strong> function in a <strong class="source-inline">useEffect</strong> Hook. Also, pass it as a prop to the <strong class="source-inline">NavBar</strong> component so that it will be displayed:<p class="source-code">  import { useEffect, useCallback, useContext } from</p><p class="source-code">    'react';</p><p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { useNavigate, useParams } from </p><p class="source-code">    'react-router-dom';</p><p class="source-code">  import NavBar from '../components/NavBar/NavBar';</p><p class="source-code">  import ListItem from</p><p class="source-code">    '../components/ListItem/ListItem';</p><p class="source-code">  import ItemsContext from '../context/ItemsContext';</p><p class="source-code"><strong class="bold">+ import ListsContext from '../context/ListsContext';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function ListDetail() {</p><p class="source-code">    let navigate = useNavigate();</p><p class="source-code">    const { listId } = useParams();</p><p class="source-code">    const { loading, error, items, fetchItems } = </p><p class="source-code">      useContext(ItemsContext);</p><p class="source-code"><strong class="bold">+   const { list, fetchList } = </strong></p><p class="source-code"><strong class="bold">      useContext(ListsContext);</strong></p><p class="source-code">    useEffect(() =&gt; {</p><p class="source-code">      listId &amp;&amp; !items.length &amp;&amp; fetchItems(listId);</p><p class="source-code">    }, [fetchItems, items, listId]);</p><p class="source-code"><strong class="bold">+   useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">+     listId &amp;&amp; fetchList(listId);</strong></p><p class="source-code"><strong class="bold">+   }, [fetchList, listId]);</strong></p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        {navigate &amp;&amp; (</p><p class="source-code">          &lt;NavBar</p><p class="source-code">            goBack={() =&gt; navigate(-1)}</p><p class="source-code">            openForm={() =&gt;</p><p class="source-code">              navigate(`/list/${listId}/new`)}</p><p class="source-code"><strong class="bold">+           title={list &amp;&amp; list.title}</strong></p><p class="source-code">          /&gt;</p><p class="source-code">        )}</p><p class="source-code">        // ...</p></li>
			</ol>
			<p>In the <a id="_idIndexMarker291"/>previous code block, we're calling <a id="_idIndexMarker292"/>the <strong class="source-inline">fetchList</strong> function from a different <strong class="source-inline">useEffect</strong> Hook than the <strong class="source-inline">fetchItems</strong> function. This is a good way to separate concerns to keep our code clean and concise.</p>
			<p>All of the data in your application is now being loaded using the Providers, which means it's now detached from the views. Also, the <strong class="source-inline">useDataFetching</strong> Hook is completely removed, making your application structure more readable.</p>
			<p>Not only can you use the context API with this pattern to make data available to many components, but you can also mutate the data. How to mutate this data will be shown in the next section.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor076"/>Mutating data in the Provider</h1>
			<p>Not only <a id="_idIndexMarker293"/>can you retrieve data using this Flux pattern, but you can <a id="_idIndexMarker294"/>also use it to update data. The pattern remains the same: you dispatch an action that would trigger the request to the server and, based on the outcome, the reducer will mutate the data with this result. Depending on whether or not it was successful, you could display a success message or an error message.</p>
			<p>The code already <a id="_idIndexMarker295"/>has a form for adding a new item to a list—something that<a id="_idIndexMarker296"/> is not working yet. Let's create the mechanism to add items by updating the Provider for <strong class="source-inline">items</strong>:</p>
			<ol>
				<li value="1">The first step is to add new actions to the reducer in <strong class="source-inline">ItemsContext</strong>, which will be dispatched once we try to add a new item:<p class="source-code">  // ... </p><p class="source-code">  const reducer = (state, action) =&gt; {</p><p class="source-code">    switch (action.type) {</p><p class="source-code">      // ...   </p><p class="source-code"><strong class="bold">+     case 'ADD_ITEM_SUCCESS':</strong></p><p class="source-code"><strong class="bold">+       return {</strong></p><p class="source-code"><strong class="bold">+         ...state,</strong></p><p class="source-code"><strong class="bold">+         items: [...state.items, action.payload],</strong></p><p class="source-code"><strong class="bold">+         loading: false,</strong></p><p class="source-code"><strong class="bold">+       };</strong></p><p class="source-code">      default:</p><p class="source-code">        return state;</p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">  export const ItemsContextProvider = </p><p class="source-code">    ({ children }) =&gt; {</p><p class="source-code">    // ...</p></li>
				<li>We also need <a id="_idIndexMarker297"/>to add a new function that can handle <strong class="source-inline">POST</strong> requests, as <a id="_idIndexMarker298"/>this function should also set the method and a body when handling the <strong class="source-inline">fetch</strong> request. You can create this function in the preceding file as well, and pass it to the Provider:<p class="source-code">  // ...  </p><p class="source-code"><strong class="bold">+ const addItem = useCallback(async ({ listId, title,</strong></p><p class="source-code"><strong class="bold">    quantity, price }) =&gt; {</strong></p><p class="source-code"><strong class="bold">+   const itemId = Math.floor(Math.random() * 100);</strong></p><p class="source-code"><strong class="bold">+   try {</strong></p><p class="source-code"><strong class="bold">+     const data = await fetch(`https://my-json-</strong></p><p class="source-code"><strong class="bold">        server.typicode.com/PacktPublishing/React-</strong></p><p class="source-code"><strong class="bold">        Projects-Second-Edition/items`,</strong></p><p class="source-code"><strong class="bold">+       {</strong></p><p class="source-code"><strong class="bold">+         method: 'POST',</strong></p><p class="source-code"><strong class="bold">+         body: JSON.stringify({</strong></p><p class="source-code"><strong class="bold">+           id: itemId,</strong></p><p class="source-code"><strong class="bold">+           listId,</strong></p><p class="source-code"><strong class="bold">+           title,</strong></p><p class="source-code"><strong class="bold">+           quantity,</strong></p><p class="source-code"><strong class="bold">+           price,</strong></p><p class="source-code"><strong class="bold">+         }),</strong></p><p class="source-code"><strong class="bold">+       },</strong></p><p class="source-code"><strong class="bold">+     );</strong></p><p class="source-code"><strong class="bold">+     const result = await data.json();</strong></p><p class="source-code"><strong class="bold">+     if (result) {</strong></p><p class="source-code"><strong class="bold">+       dispatch({</strong></p><p class="source-code"><strong class="bold">+         type: 'ADD_ITEM_SUCCESS',</strong></p><p class="source-code"><strong class="bold">+         payload: {</strong></p><p class="source-code"><strong class="bold">+           id: itemId,</strong></p><p class="source-code"><strong class="bold">+           listId,</strong></p><p class="source-code"><strong class="bold">+           title,</strong></p><p class="source-code"><strong class="bold">+           quantity,</strong></p><p class="source-code"><strong class="bold">+           price,</strong></p><p class="source-code"><strong class="bold">+         },</strong></p><p class="source-code"><strong class="bold">+       });</strong></p><p class="source-code"><strong class="bold">+     }</strong></p><p class="source-code"><strong class="bold">+   } catch {}</strong></p><p class="source-code"><strong class="bold">+ }, [])</strong></p><p class="source-code">  return (</p><p class="source-code"><strong class="bold">-   &lt;ItemsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">      {{ ...state, fetchItems }}&gt;</strong></p><p class="source-code"><strong class="bold">+   &lt;ItemsContext.Provider value=</strong></p><p class="source-code"><strong class="bold">      {{ ...state, fetchItems, addItem }}&gt;</strong></p><p class="source-code">      // ...</p><p class="callout-heading">Note</p><p class="callout">The mock <a id="_idIndexMarker299"/>API from My JSON Server doesn't persist data once it <a id="_idIndexMarker300"/>is added, updated, or deleted with a request. However, you can see whether the request was successful by checking the request in the <strong class="bold">Network</strong> tab in the Developer Tools section of your browser. That's why the input content is spread over the value for <strong class="source-inline">items</strong>, so this data is available from the Consumer.</p></li>
				<li>As the <a id="_idIndexMarker301"/>function to add a new item to a list is now available <a id="_idIndexMarker302"/>from the Provider, the <strong class="source-inline">ListForm</strong> component in <strong class="source-inline">src/pages/ListForm.js</strong> is now able to use the <strong class="source-inline">addItem</strong> function, which will dispatch the action that will call the API and add the item to the state. However, the values of the input fields in the form need to be determined first. Therefore, the input fields need to be controlled components, meaning their value is controlled by the local state that encapsulates the value. Therefore we need to import the <strong class="source-inline">useState</strong> Hook and also a <strong class="source-inline">useContext</strong> Hook, which we'll use later to get values from the Context:<p class="source-code"><strong class="bold">+ import { useState, useContext } from 'react';</strong></p><p class="source-code">  import styled from 'styled-components';</p><p class="source-code">  import { useNavigate, useParams } from </p><p class="source-code">   'react-router-dom';</p><p class="source-code">  import NavBar from '../components/NavBar/NavBar';</p><p class="source-code">  import FormItem from </p><p class="source-code">    '../components/FormItem/FormItem';</p><p class="source-code">  import Button from '../components/Button/Button';</p><p class="source-code"><strong class="bold">+ import ItemsContext from '../context/ItemsContext';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function ListForm() {</p><p class="source-code">    let navigate = useNavigate();</p><p class="source-code">    const { listId } = useParams();</p><p class="source-code"><strong class="bold">+   const [title, setTitle] = useState('');</strong></p><p class="source-code"><strong class="bold">+   const [quantity, setQuantity] = useState('');</strong></p><p class="source-code"><strong class="bold">+   const [price, setPrice] = useState('');</strong></p><p class="source-code">    return (</p><p class="source-code">      // ...   </p></li>
			</ol>
			<p>For this, we used the <strong class="source-inline">useState</strong> Hook for every <strong class="source-inline">state</strong> value that we created. </p>
			<ol>
				<li value="4">The local <a id="_idIndexMarker303"/>state values and the function that triggers an <a id="_idIndexMarker304"/>update of the local state values must be set as a prop on the <strong class="source-inline">FormItem</strong> components: <p class="source-code">     // ...</p><p class="source-code">     return (</p><p class="source-code">       &lt;&gt;</p><p class="source-code">         {navigate &amp;&amp; &lt;NavBar goBack={() =&gt; </p><p class="source-code">           navigate(-1)} title={`Add Item`} /&gt;}</p><p class="source-code">         &lt;FormWrapper&gt;</p><p class="source-code">           &lt;form&gt;</p><p class="source-code">             &lt;FormItem</p><p class="source-code">               id='title'</p><p class="source-code">               label='Title'</p><p class="source-code">               placeholder='Insert title'</p><p class="source-code"><strong class="bold">+              value={title}</strong></p><p class="source-code"><strong class="bold">+              handleOnChange={(e) =&gt;</strong></p><p class="source-code"><strong class="bold">                 setTitle(e.currentTarget.value)}</strong></p><p class="source-code">             /&gt;</p><p class="source-code">             &lt;FormItem</p><p class="source-code">               id='quantity'</p><p class="source-code">               label='Quantity'</p><p class="source-code">               type='number'</p><p class="source-code">               placeholder='0'</p><p class="source-code"><strong class="bold">+              value={quantity}</strong></p><p class="source-code"><strong class="bold">+              handleOnChange={(e) =&gt;</strong></p><p class="source-code"><strong class="bold">                 setQuantity(e.currentTarget.value)}</strong></p><p class="source-code">             /&gt;</p><p class="source-code">             &lt;FormItem</p><p class="source-code">               id='price'</p><p class="source-code">               label='Price'</p><p class="source-code">               type='number'</p><p class="source-code">               placeholder='0.00'</p><p class="source-code"><strong class="bold">+              value={price}</strong></p><p class="source-code"><strong class="bold">+              handleOnChange={(e) =&gt; </strong></p><p class="source-code"><strong class="bold">                 setPrice(e.currentTarget.value)}</strong></p><p class="source-code">             /&gt;</p><p class="source-code">             &lt;SubmitButton&gt;Add Item&lt;/SubmitButton&gt;</p><p class="source-code">           &lt;/form&gt;</p><p class="source-code">         &lt;/FormWrapper&gt;</p><p class="source-code">       &lt;/&gt;</p><p class="source-code">     );</p><p class="source-code">  };</p><p class="source-code">  export default Form;</p></li>
				<li>The last <a id="_idIndexMarker305"/>thing you need to do now is to add a function <a id="_idIndexMarker306"/>that will be dispatched when the form is submitted by clicking the submit button. This function takes <strong class="source-inline">value</strong> for the local state, adds information about the item, and uses this to call the <strong class="source-inline">addItem</strong> function. After this function is called, the navigate function from <strong class="source-inline">useNavigate</strong> is called to go back to the overview for this list:<p class="source-code"><strong class="bold">  // ...</strong></p><p class="source-code"><strong class="bold">+ const { addItem } = useContext(ItemsContext);</strong></p><p class="source-code"><strong class="bold">+ function onSubmit(e) {</strong></p><p class="source-code"><strong class="bold">+   e.preventDefault();</strong></p><p class="source-code"><strong class="bold">+   if (title &amp;&amp; quantity &amp;&amp; price) {</strong></p><p class="source-code"><strong class="bold">+     addItem({</strong></p><p class="source-code"><strong class="bold">+       title,</strong></p><p class="source-code"><strong class="bold">+       quantity,</strong></p><p class="source-code"><strong class="bold">+       price,</strong></p><p class="source-code"><strong class="bold">+       listId,</strong></p><p class="source-code"><strong class="bold">+     });</strong></p><p class="source-code"><strong class="bold">+   }</strong></p><p class="source-code"><strong class="bold">+   navigate(`/list/${listId}`);</strong></p><p class="source-code"><strong class="bold">+ }</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;&gt;</p><p class="source-code">      {navigate &amp;&amp; &lt;NavBar goBack={() =&gt;</p><p class="source-code">        navigate(-1)} title={`Add Item`} /&gt;}</p><p class="source-code">      &lt;FormWrapper&gt;</p><p class="source-code"><strong class="bold">-       &lt;form&gt;</strong></p><p class="source-code"><strong class="bold">+       &lt;form onSubmit={onSubmit}&gt;</strong></p><p class="source-code">          // ...</p></li>
			</ol>
			<p>When you now<a id="_idIndexMarker307"/> submit the form, a <strong class="source-inline">POST</strong> request to the mock server <a id="_idIndexMarker308"/>will be sent. You'll be sent back to the previous page where you can see the result. If successful, the <strong class="source-inline">GET_LIST_SUCCESS</strong> action was dispatched and the item you inserted was added to the list.</p>
			<p>So far, the information from the Context has been used only separately by using the Providers, but this can also be combined into one application Context, as shown in the next section.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor077"/>Creating an application Context</h1>
			<p>If you look at the<a id="_idIndexMarker309"/> current structure of the routes in your <strong class="source-inline">App</strong> component, you can imagine that this will get messy if you add more Providers and Consumers to your application. State management packages such as Redux tend to have an application state where all of the data for the application is stored. When using Context, it's possible to create an application Context that can be accessed using the <strong class="source-inline">useContext</strong> Hook. This Hook acts as a Consumer and can retrieve values from the Provider of the Context that was passed to it. Let's refactor the current application to have an application Context:</p>
			<ol>
				<li value="1">Start by creating a file called <strong class="source-inline">AppContext.js</strong> in the <strong class="source-inline">src/context</strong> directory. This file will import both <strong class="source-inline">ListsContextProvider</strong> and <strong class="source-inline">ItemsContextProvider</strong>, nest them, and have them wrap any component that will be passed to it as a <strong class="source-inline">children</strong> prop:<p class="source-code">import { ListsContextProvider } from './ListsContext';</p><p class="source-code">import { ItemsContextProvider } from './ItemsContext';</p><p class="source-code">const AppContext = ({ children }) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;ListsContextProvider&gt;</p><p class="source-code">      &lt;ItemsContextProvider&gt;{children}</p><p class="source-code">      &lt;/ItemsContextProvider&gt;</p><p class="source-code">    &lt;/ListsContextProvider&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default AppContext;</p></li>
				<li>In the <strong class="source-inline">src/App.js</strong> file, we can now import this <strong class="source-inline">AppContext</strong> file in favor of the Providers <a id="_idIndexMarker310"/>for the lists and items and replace <strong class="source-inline">ListsContextProvider</strong> and <strong class="source-inline">ItemsContextProvider</strong> with <strong class="source-inline">AppContext</strong>:<p class="source-code">  import styled, { createGlobalStyle } from </p><p class="source-code">    'styled-components';</p><p class="source-code">  import { Route, Routes, BrowserRouter } from </p><p class="source-code">    'react-router-dom';</p><p class="source-code">  import Header from './components/Header/Header';</p><p class="source-code">  import Lists from './pages/Lists';</p><p class="source-code">  import ListDetail from './pages/ListDetail';</p><p class="source-code">  import ListForm from './pages/ListForm';</p><p class="source-code"><strong class="bold">- import { ListsContextProvider } from </strong></p><p class="source-code"><strong class="bold">    './context/ListsContext';</strong></p><p class="source-code"><strong class="bold">- import { ItemsContextProvider } from</strong></p><p class="source-code"><strong class="bold">    './context/ItemsContext';</strong></p><p class="source-code"><strong class="bold">+ import AppContext from './context/AppContext';</strong></p><p class="source-code">  // ...</p><p class="source-code">  function App() { </p><p class="source-code">    return (</p><p class="source-code">      &lt;&gt;</p><p class="source-code">        &lt;GlobalStyle /&gt;</p><p class="source-code">        &lt;AppWrapper&gt;</p><p class="source-code">          &lt;BrowserRouter&gt;</p><p class="source-code">            &lt;Header /&gt;</p><p class="source-code"><strong class="bold">+           &lt;AppContext&gt;</strong></p><p class="source-code"><strong class="bold">-           &lt;ListsContextProvider&gt;</strong></p><p class="source-code"><strong class="bold">-             &lt;ItemsContextProvider&gt;</strong></p><p class="source-code">                &lt;Routes&gt;</p><p class="source-code">                  // ...</p><p class="source-code">                &lt;/Routes&gt;</p><p class="source-code"><strong class="bold">-             &lt;/ItemsContextProvider&gt;</strong></p><p class="source-code"><strong class="bold">-           &lt;/ListsContextProvider&gt;</strong></p><p class="source-code"><strong class="bold">+           &lt;/AppContext&gt;</strong></p><p class="source-code">          &lt;/BrowserRouter&gt;</p><p class="source-code">        &lt;/AppWrapper&gt;</p><p class="source-code">      &lt;/&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  export default App;</p></li>
			</ol>
			<p>The <strong class="source-inline">AppContext</strong> component<a id="_idIndexMarker311"/> can be extended with all of the Context objects that you might want to add in the future. Our application now has a much cleaner structure, while the data is still being retrieved by the Providers.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/>Code splitting with React Suspense</h1>
			<p>So far, we've<a id="_idIndexMarker312"/> focused mostly on adding new features, such as <a id="_idIndexMarker313"/>routing or state management, to our application. But not much focus has been devoted to making our application more performant, something that we can do with code splitting. A React feature called Suspense can be used for code splitting, which means you split the compiled code (your bundle) into smaller chunks. This will prevent the browser from downloading the entire bundle with your compiled code at once, and instead load your bundle in chunks depending on the components that are rendered by the browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the previous chapter, we used Next.js instead of Create React App to create our React application, which has code splitting enabled by default.</p>
			<p>Suspense lets your components wait until the component you're importing is ready to be displayed. Before React 18 it could only be used for code splitting, but since the latest version of React it serves more purposes. When you fetch data from a component that is imported with Suspense, React will also wait until the data for that component is completely fetched.</p>
			<p>Suspense<a id="_idIndexMarker314"/> must be used together with the lazy method, which<a id="_idIndexMarker315"/> involves using JavaScript dynamic imports to load the component only when requested. Both methods can be imported from React in <strong class="source-inline">src/App.js</strong>, where the lazy method is used to import the components for our pages:</p>
			<p class="source-code"><strong class="bold">+ import { Suspense, lazy } from 'react';</strong></p>
			<p class="source-code">  import styled, { createGlobalStyle } from </p>
			<p class="source-code">    'styled-components';</p>
			<p class="source-code">  import { Route, Routes, BrowserRouter} from </p>
			<p class="source-code">    'react-router-dom';</p>
			<p class="source-code">  import Header from './components/Header/Header';</p>
			<p class="source-code"><strong class="bold">- import Lists from './pages/Lists';</strong></p>
			<p class="source-code"><strong class="bold">- import ListDetail from './pages/ListDetail';</strong></p>
			<p class="source-code"><strong class="bold">- import ListForm from './pages/ListForm';</strong></p>
			<p class="source-code">  import AppContext from './context/AppContext';</p>
			<p class="source-code"><strong class="bold">+ const Lists = lazy(() =&gt; import('./pages/Lists'));</strong></p>
			<p class="source-code"><strong class="bold">+ const ListDetail = lazy(() =&gt;</strong></p>
			<p class="source-code"><strong class="bold">    import('./pages/ListDetail'));</strong></p>
			<p class="source-code"><strong class="bold">+ const ListForm = lazy(() =&gt; import('./pages/ListForm'));</strong></p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  </p>
			<p class="source-code">  function App() {</p>
			<p class="source-code">    // ...</p>
			<p>In the <strong class="source-inline">return</strong><a id="_idIndexMarker316"/> statement for the <strong class="source-inline">App</strong> component, Suspense <a id="_idIndexMarker317"/>must be used with a fallback that will be displayed when the dynamically imported components are being loaded:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  function App() {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">      &lt;&gt;</p>
			<p class="source-code">        &lt;GlobalStyle /&gt;</p>
			<p class="source-code">        &lt;AppWrapper&gt;</p>
			<p class="source-code">          &lt;BrowserRouter&gt;</p>
			<p class="source-code">            &lt;Header /&gt;</p>
			<p class="source-code"><strong class="bold">+           &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;</strong></p>
			<p class="source-code">              &lt;AppContext&gt;</p>
			<p class="source-code">                // ...</p>
			<p class="source-code">              &lt;/AppContext&gt;</p>
			<p class="source-code"><strong class="bold">+           &lt;/Suspense&gt;</strong></p>
			<p class="source-code">          &lt;/BrowserRouter&gt;</p>
			<p class="source-code">        &lt;/AppWrapper&gt;</p>
			<p class="source-code">      &lt;/&gt;</p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">  export default App;</p>
			<p>When you look at the application in the browser, you don't see any changes, unless you have a slow internet connection. In that case, the fallback for Suspense will be displayed while the component is being loaded. However, when you open the <strong class="bold">Network</strong> tab in the developer console, you do see a difference. Here, all the network requests are shown, and all the <a id="_idIndexMarker318"/>downloaded JavaScript as well. For our application, we <a id="_idIndexMarker319"/>can see that multiple files are loaded, such as <strong class="source-inline">bundle.js</strong> and <strong class="source-inline">main.chunk.js</strong>. However, after applying code splitting, chunked components are also being loaded, for example,<strong class="source-inline"> src_pages_ListDetail_js.js</strong>.</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_5.2_B17390.jpg" alt="Figure 5.2 – The network requests for our application after code splitting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – The network requests for our application after code splitting</p>
			<p>Looking at the main route, which is <strong class="source-inline">/</strong>, we can see that a chunk named <strong class="source-inline">3.chunk.js</strong> is loaded. This isn't a very helpful filename, something we can change with <strong class="source-inline">webpackChunkName</strong> in an inline comment. With this addition, we can instruct webpack to name the file something more user friendly:</p>
			<p class="source-code">  // ...</p>
			<p class="source-code"><strong class="bold">- const Lists = lazy(() =&gt; import('./pages/Lists'));</strong></p>
			<p class="source-code"><strong class="bold">- const ListDetail = lazy(() =&gt;</strong></p>
			<p class="source-code"><strong class="bold">    import'./pages/ListDetail'));</strong></p>
			<p class="source-code"><strong class="bold">- const ListForm = lazy(() =&gt; import('./pages/ListForm'));</strong></p>
			<p class="source-code"><strong class="bold">+ const Lists = lazy(() =&gt; import(/* webpackChunkName:</strong></p>
			<p class="source-code"><strong class="bold">    "Lists" */ './pages/Lists'));</strong></p>
			<p class="source-code"><strong class="bold">+ const ListDetail = lazy(() =&gt; import(/* webpackChunkName:</strong></p>
			<p class="source-code"><strong class="bold">    "ListDetail" */ './pages/ListDetail'));</strong></p>
			<p class="source-code"><strong class="bold">+ const ListForm = lazy(() =&gt; import(/* webpackChunkName: </strong></p>
			<p class="source-code"><strong class="bold">    "ListForm" */ './pages/ListForm'));</strong></p>
			<p class="source-code">  function App() {</p>
			<p class="source-code">    // ...</p>
			<p>This latest <a id="_idIndexMarker320"/>addition makes recognizing which chunks (or components) are<a id="_idIndexMarker321"/> loaded in our application much easier, as you can see by reloading the application in the browser and checking the Network tab again.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/>Summary</h1>
			<p>In this chapter, you've created a shopping list application that uses the Context API and Hooks to pass and retrieve data. Context is used to store data and Hooks are used to retrieve and mutate data. With the Context API, you can create more advanced scenarios for state management using the <strong class="source-inline">useReducer</strong> Hook. Context is also used to create a situation where all of the data is stored application-wide and can be accessed from any component by creating a shared Context. Finally, we've used React Suspense to apply code splitting to our bundle for improved performance.</p>
			<p>The Context API will be used in the next chapter as well, which will show you how to build a hotel review application with automated testing using libraries such as Jest and Enzyme. It will introduce you to the multiple ways in which you can test your UI components created with React, and also show you how to test state management in your application using the Context API.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor080"/>Further reading</h1>
			<p>For more information, refer to the following links:</p>
			<ul>
				<li>Consuming multiple Context objects: <a href="https://reactjs.org/docs/context.html#consuming-multiple-contexts">https://reactjs.org/docs/context.html#consuming-multiple-contexts</a></li>
				<li>React Suspense: <a href="https://reactjs.org/docs/react-api.html#reactsuspense">https://reactjs.org/docs/react-api.html#reactsuspense</a></li>
			</ul>
		</div>
	</body></html>