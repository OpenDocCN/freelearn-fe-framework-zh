- en: '*Chapter 7*: Handling Image Uploads'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：处理图片上传'
- en: 'All social networks have one thing in common: each of them allows its users
    to upload custom and personal pictures, videos, or any other kind of document.
    This feature can take place inside chats, posts, groups, or profiles. To offer
    the same functionality, we are going to implement an image upload feature in Graphbook.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有社交网络都有一个共同点：每个都允许其用户上传自定义和个人图片、视频或任何其他类型的文档。这个功能可以在聊天、帖子、群组或个人资料中实现。为了提供相同的功能，我们将在Graphbook中实现图片上传功能。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up Amazon Web Services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置亚马逊网络服务
- en: Configuring an AWS S3bucket
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置AWS S3存储桶
- en: Accepting file uploads on the server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上接受文件上传
- en: Uploading images with React through Apollo
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Apollo使用React上传图片
- en: Cropping images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪图片
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter07)'
- en: Setting up Amazon Web Services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置亚马逊网络服务
- en: 'First, I have to mention that Amazon—or, to be specific, **Amazon Web Services**
    (**AWS**)—is not the only provider of hosting, storage, or computing systems.
    There are many such providers, including the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我必须提到，亚马逊——更具体地说，**亚马逊网络服务**（**AWS**）——并不是唯一提供托管、存储或计算系统的提供商。有许多这样的提供商，包括以下：
- en: Heroku
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku
- en: DigitalOcean
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigitalOcean
- en: Google Cloud
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云
- en: Microsoft Azure
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Azure
- en: AWS offers everything that you need to run a full-fledged web application, as
    with all the other providers. Furthermore, it is also widely used, which is why
    we are focusing on AWS for this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AWS提供了运行完整Web应用所需的一切，就像所有其他提供商一样。此外，它也被广泛使用，这就是为什么我们在这本书中专注于AWS。
- en: Its services span from databases to object storage, to security services, and
    so much more. Besides, AWS is the go-to solution that you will find in most other
    books and tutorials, and many big companies use it to power their complete infrastructure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其服务范围从数据库到对象存储，再到安全服务，等等。此外，AWS是大多数其他书籍和教程中都会找到的解决方案，许多大型公司也用它来支持其完整的基础设施。
- en: This book uses AWS for serving static files, such as images, to run the production
    database and the Docker container for our application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用AWS来托管静态文件，例如图片，运行生产数据库以及我们的应用程序的Docker容器。
- en: Before continuing with this chapter, you will be required to have an account
    for AWS. You can create one on the official web page at [https://aws.amazon.com/](https://aws.amazon.com/).
    For this, you will need a valid credit card; you can also run nearly all of the
    services on the Free Tier while working through this book without facing any problems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，您将需要AWS账户。您可以在官方网页[https://aws.amazon.com/](https://aws.amazon.com/)上创建一个账户。为此，您需要一个有效的信用卡；在阅读本书的过程中，您也可以在免费层上运行几乎所有服务，而不会遇到任何问题。
- en: 'Once you have successfully registered for AWS, you will see the following dashboard.
    This screen is called the **AWS Management Console**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您成功注册AWS，您将看到以下仪表板。这个屏幕被称为**AWS管理控制台**：
- en: '![Figure 7.1 – AWS Management Console'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – AWS管理控制台'
- en: '](img/Figure_7.01_B17337.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17337.jpg)'
- en: Figure 7.1 – AWS Management Console
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – AWS管理控制台
- en: The next section will cover the options for storing files with AWS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍使用AWS存储文件的选择。
- en: Configuring an AWS S3 bucket
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置AWS S3存储桶
- en: 'For this chapter, we will require a storage service to save all uploaded images.
    AWS provides different storage types for various use cases. In our scenario of
    a social network, we will have dozens of people accessing many images at once.
    **AWS Simple Storage Service** (**S3**) is the best option for our scenario. Follow
    these steps to set up an S3 bucket:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要一个存储服务来保存所有上传的图片。AWS为各种用例提供不同的存储类型。在我们的社交网络场景中，我们将有数十人同时访问许多图片。**AWS简单存储服务**（**S3**）是我们场景的最佳选择。按照以下步骤设置S3存储桶：
- en: You can visit the **Amazon S3** screen by clicking on the **Services** drop-down
    menu at the top of the page, and then looking under the **Storage** category in
    the drop-down menu. There, you will find a link to S3\. Having clicked on it,
    the screen will look like this:![Figure 7.2 – S3 management screen
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过点击页面顶部的**服务**下拉菜单，然后在下拉菜单中的**存储**类别下查找，来访问**Amazon S3**屏幕。在那里，您将找到一个指向S3的链接。点击它后，屏幕将看起来像这样：![图7.2
    – S3管理屏幕
- en: '](img/Figure_7.02_B17337.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17337.jpg)'
- en: Figure 7.2 – S3 management screen
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.2 – S3管理屏幕
- en: In S3, you create a bucket inside of a specific AWS region, where you can store
    files.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在S3中，您可以在特定的AWS区域内部创建一个存储桶，在那里您可以存储文件。
- en: The preceding screen provides many features for interacting with your S3 bucket.
    You can browse all of the files, upload your files via the management interface,
    and configure more settings.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一个屏幕提供了许多与您的S3存储桶交互的功能。您可以通过管理界面浏览所有文件，上传您的文件，并配置更多设置。
- en: 'We will now create a new bucket for our project by clicking on **Create bucket**
    in the upper-right corner, as shown in *Figure 7.2*. You will be presented with
    a form, as shown in the following screenshot. To create a bucket, you must fill
    it out:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过点击右上角的**创建存储桶**，如*图7.2*所示，为我们的项目创建一个新的存储桶。您将看到一个表单，如下面的截图所示。要创建存储桶，您必须填写以下内容：
- en: '![Figure 7.3 – S3 bucket wizard'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – S3存储桶向导'
- en: '](img/Figure_7.03_B17337.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B17337.jpg)'
- en: Figure 7.3 – S3 bucket wizard
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – S3存储桶向导
- en: The bucket has to have a unique name across all buckets in S3\. Then, we need
    to pick a region. For me, **EU (Frankfurt) eu-central-1** is the best choice,
    as it is the nearest origin point. Choose the best option for you, since the performance
    of a bucket corresponds to the distance between the region of the bucket and its
    accessor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 存储桶必须在S3的所有存储桶中具有唯一名称。然后，我们需要选择一个区域。对我来说，**欧洲（法兰克福）eu-central-1**是最好的选择，因为它是最接近的源点。选择最适合您的选项，因为存储桶的性能与其访问区域和存储桶区域之间的距离相对应。
- en: 'Then, you need to uncheck the **Block all public access** option and also check
    the acknowledgment with the warning sign. AWS shows us this warning because we
    should only give public access to S3 buckets when really required. It should look
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要取消选择**阻止所有公共访问**选项，并检查带有警告标志的确认。AWS显示此警告是因为我们只有在真正需要时才应向S3存储桶提供公共访问。它应该看起来像这样：
- en: '![Figure 7.4 – S3 bucket access'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – S3存储桶访问'
- en: '](img/Figure_7.04_B17337.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B17337.jpg)'
- en: Figure 7.4 – S3 bucket access
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – S3存储桶访问
- en: For our use case, we can stay with the default settings provided for all the
    other options in this form wizard. The other options can be helpful in more advanced
    scenarios. AWS offers many features, such as a complete access log and versioning.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，我们可以保留在此表单向导中为所有其他选项提供的默认设置。在其他更高级的场景中，其他选项可能会有所帮助。AWS提供了许多功能，例如完整的访问日志和版本控制。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many bigger companies have users across the globe, which requires a highly available
    application. When you reach this point, you can create many more S3 buckets in
    other regions, and you can set up the replication of one bucket to others living
    in various regions around the world. The correct bucket can then be distributed
    with AWS CloudFront and a router specific to each user. This approach gives every
    user the best possible experience.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型公司拥有全球用户，这需要一个高度可用的应用程序。当您达到这一点时，您可以在其他地区创建更多的S3存储桶，并且您可以将一个存储桶的复制设置到世界各地其他地区的存储桶。然后，可以使用AWS
    CloudFront和针对每个用户的特定路由器将正确的存储桶分发出去。这种方法为每个用户提供了最佳的可能体验。
- en: Finish the setup process by clicking on **Create bucket** at the bottom of the
    page. You will be redirected back to the table view for all buckets.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击页面底部的**创建存储桶**完成设置过程。您将被重定向回所有存储桶的表格视图。
- en: Generating AWS access keys
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成AWS访问密钥
- en: Before implementing the upload feature, we must create an AWS **application
    programming interface** (**API**) key to authorize our backend at AWS, in order
    to upload new files to the S3 bucket.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上传功能之前，我们必须创建一个AWS**应用程序编程接口**（**API**）密钥，以授权我们的AWS后端，以便将新文件上传到S3存储桶。
- en: Click on your username in the top bar of the AWS management screen. There, you
    will find a tab called **My Security Credentials**, which navigates to a screen
    offering various options to secure access to your AWS account.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 点击AWS管理屏幕顶部的用户名。在那里，您将找到一个名为**我的安全凭证**的标签页，它导航到一个提供各种选项以保护您的AWS账户访问权限的屏幕。
- en: 'You will be confronted with a dialog box like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个类似这样的对话框：
- en: '![Figure 7.5 – S3 Identity and Access Management (IAM) dialog'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – S3 身份和访问管理 (IAM) 对话框'
- en: '](img/Figure_7.05_B17337.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B17337.jpg)'
- en: Figure 7.5 – S3 Identity and Access Management (IAM) dialog
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – S3 身份和访问管理 (IAM) 对话框
- en: You can click on **Continue to Security Credentials** to continue. It is generally
    recommended to use AWS IAM, which allows you to efficiently manage secure access
    to AWS resources with separate IAM users. Throughout this book, we are going to
    use the root user in the same way that we are now, but I recommend looking at
    AWS IAM when writing your next application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以点击**继续到安全凭证**以继续。通常建议使用 AWS IAM，这允许您通过单独的 IAM 用户高效地管理对 AWS 资源的安全访问。在本书中，我们将以我们现在的方式使用根用户，但我建议在编写您的下一个应用程序时查看
    AWS IAM。
- en: 'You should now see the credentials page, with a big list of different methods
    for storing credentials. This is how it should look:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到凭证页面，其中列出了存储凭证的不同方法。它应该看起来像这样：
- en: '![Figure 7.6 – AWS access keys'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – AWS 访问密钥'
- en: '](img/Figure_7.06_B17337.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B17337.jpg)'
- en: Figure 7.6 – AWS access keys
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – AWS 访问密钥
- en: In the list, expand the tab titled **Access keys (access key ID and secret access
    key)** shown in the preceding screenshot. In this tab, you will find all access
    tokens for your AWS account.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，展开前一个屏幕截图中所显示的名为**访问密钥（访问密钥 ID 和秘密访问密钥）**的选项卡。在此选项卡中，您可以找到您 AWS 账户的所有访问令牌。
- en: 'To generate a new access token, click on **Create New Access Key**. The output
    should look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成新的访问令牌，请点击**创建新访问密钥**。输出应如下所示：
- en: '![Figure 7.7 – AWS access key'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – AWS 访问密钥'
- en: '](img/Figure_7.07_B17337.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B17337.jpg)'
- en: Figure 7.7 – AWS access key
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – AWS 访问密钥
- en: The best practice is to download the key file as prompted and save it somewhere
    securely, just in case you lose the key at any time. You cannot retrieve access
    keys again after closing the window, so if you lose them, you will have to delete
    the old key and generate a new one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是按照提示下载密钥文件并将其安全地保存到某个地方，以防您在任何时候丢失密钥。关闭窗口后，您无法再次检索访问密钥，因此如果您丢失了它们，您将不得不删除旧密钥并生成一个新的。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This approach is acceptable for explaining the basics of AWS. With such a huge
    platform, there are further steps that you have to take to secure your application
    even more. For example, it is recommended to renew API keys every 90 days. You
    can read more about all of the best practices at [https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html](https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以用来解释 AWS 的基础知识。对于这样一个庞大的平台，您必须采取进一步的步骤来进一步增强您应用程序的安全性。例如，建议每 90 天更换 API
    密钥。您可以在[https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html](https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html)上了解更多关于所有最佳实践的信息。
- en: As you can see in *Figure 7.7*, AWS gives us two tokens. Both are required to
    gain access to our S3 bucket.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*图 7.7*中所见，AWS 给我们提供了两个令牌。两者都是访问我们的 S3 存储桶所必需的。
- en: Now, we can start to program the uploading mechanism.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写上传机制了。
- en: Uploading images to Amazon S3
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图片上传到 Amazon S3
- en: Implementing file uploads and storing files is always a huge task, especially
    for image uploads in which the user may want to edit their files again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件上传和存储文件始终是一项巨大的任务，尤其是在用户可能希望再次编辑他们的文件时的图片上传。
- en: For our frontend, the user should be able to drag and drop their image into
    a dropzone, crop the image, and then submit it when they are finished. The backend
    needs to accept file uploads in general, which is not easy at all. The files must
    be processed and then stored efficiently so that all users can access them quickly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的前端，用户应该能够将他们的图片拖放到拖放区域，裁剪图片，然后在完成时提交。后端需要接受文件上传，这并不容易。文件必须被处理并有效地存储，以便所有用户都可以快速访问它们。
- en: As this is a vast topic, the chapter only covers the basic upload of images
    from React, using a multipart `POST` request to our GraphQL API, and then transferring
    the image to our S3 bucket. When it comes to compressing, converting, and cropping,
    you should check out further tutorials or books on this topic, including techniques
    for implementing them in the frontend and backend, since there is a lot to think
    about. For example, in many applications, it makes sense to store images in various
    resolutions that will be shown to the users in different situations, in order
    to save bandwidth.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个庞大的主题，本章仅涵盖了从 React 基本上传图像，使用多部分 `POST` 请求到我们的 GraphQL API，然后将图像传输到我们的
    S3 存储桶。当涉及到压缩、转换和裁剪时，您应该查看有关此主题的更多教程或书籍，包括在前端和后端实现这些技术的技巧，因为有很多东西需要考虑。例如，在许多应用程序中，存储不同分辨率的图像以供用户在不同情况下查看是有意义的，这样可以节省带宽。
- en: Let's start by implementing the upload process on the backend.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在后台实现上传过程开始。
- en: GraphQL image upload mutation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 图像上传突变
- en: When uploading images to S3, it is required to use an API key, which we have
    already generated. Because of this, we cannot directly upload the files from the
    client to S3 with the API key. Anyone accessing our application could read out
    the API key from the JavaScript code and access our bucket without us knowing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当将图像上传到 S3 时，需要使用一个 API 密钥，我们已生成。因此，我们不能直接使用 API 密钥从客户端上传文件到 S3。任何访问我们应用程序的人都可以从
    JavaScript 代码中读取 API 密钥，并访问我们的存储桶，而无需我们知道。
- en: Uploading images directly from the client into the bucket is generally possible,
    however. To do this, you would need to send the name and type of the file to the
    server, which would then generate a **Uniform Resource Locator** (**URL**) and
    signature. The client can then use the signature to upload the image. This technique
    results in many round trips for the client and does not allow us to postprocess
    the image, such as by converting or compressing, if needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从客户端将图像上传到存储桶通常是可能的。为此，您需要将文件的名称和类型发送到服务器，然后服务器会生成 **统一资源定位符** （**URL**） 和签名。然后客户端可以使用签名上传图像。这种技术会导致客户端进行多次往返，并且不允许我们进行后处理图像，例如转换或压缩（如果需要）。
- en: A better solution is to upload the images to our server, have the GraphQL API
    accept the file, and then make another request to S3—including the API key—to
    store the file in our bucket.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是将图像上传到我们的服务器，让 GraphQL API 接收文件，然后向 S3 发送另一个请求——包括 API 密钥——以将文件存储到我们的存储桶中。
- en: 'We have to prepare our backend to communicate with AWS and accept file uploads.
    The preparation steps are listed here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须准备我们的后端以与 AWS 通信并接受文件上传。准备工作如下：
- en: 'We install the official `npm` package to interact with AWS. It provides everything
    that''s needed to use any AWS feature, not just S3\. Also, we install `graphql-upload`,
    which provides some tools to resolve the file from any GraphQL request. The code
    to do this is illustrated here:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们安装官方的 `npm` 包以与 AWS 交互。它提供了使用任何 AWS 功能所需的一切，而不仅仅是 S3。我们还安装了 `graphql-upload`，它提供了一些工具来从任何
    GraphQL 请求中解析文件。以下是完成此操作的代码：
- en: '[PRE0]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the server `index.js` file, we need to add the initialization of the
    `graphql-upload` package. For that, import the Express dependency at the top,
    as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器 `index.js` 文件中，我们需要添加 `graphql-upload` 包的初始化。为此，在顶部导入 Express 依赖项，如下所示：
- en: '[PRE1]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `graphql` case at the end of the file, before executing the `applyMiddleware`
    function, we need to initiate it, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾的 `graphql` 案例中，在执行 `applyMiddleware` 函数之前，我们需要先初始化它，如下所示：
- en: '[PRE2]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next thing to do is edit the GraphQL schema and add an `Upload` scalar
    to the top of it. The scalar is used to resolve details such as the **Multipurpose
    Internet Mail Extensions** (**MIME**) type and encoding when uploading files.
    Here''s the code you''ll need:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要做的事情是编辑 GraphQL 模式，并在其顶部添加一个 `Upload` 标量。该标量用于在上传文件时解析诸如 **多用途互联网邮件扩展**
    （**MIME**） 类型和解码等细节。以下是您需要的代码：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the `File` type to the schema. This type returns the filename and the resulting
    URL under which the image can be accessed in the browser. The code is illustrated
    in the following snippet:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `File` 类型添加到模式中。此类型返回文件名和图像可以在浏览器中访问的结果 URL。代码如下所示：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new `uploadAvatar` mutation. The user needs to be logged in to upload
    avatar images, so append the `@auth` directive to the mutation. The mutation takes
    the previously mentioned `Upload` scalar as input. The code is illustrated in
    the following snippet:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`uploadAvatar`突变。用户需要登录才能上传头像图像，所以将`@auth`指令附加到突变上。突变接受之前提到的`Upload`标量作为输入。代码在下面的代码片段中展示：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will implement the mutation''s resolver function in the `resolvers.js`
    file. For this, we will import and set up our dependencies at the top of the `resolvers.js`
    file, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`resolvers.js`文件中实现突变解析函数。为此，我们将在`resolvers.js`文件顶部导入和设置我们的依赖项，如下所示：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will initialize the `s3` object that we will use to upload images in the
    next step. It is required to pass a `region` property as a property in which we
    created the S3 bucket. We set the `signatureVersion` property to version `'v4'`
    as this is recommended.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将初始化`s3`对象，我们将在下一步上传图像时使用它。需要传递一个`region`属性，这是我们创建S3存储桶的属性。我们将`signatureVersion`属性设置为版本`'v4'`，因为这被推荐使用。
- en: Note
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find details about the signature process of AWS requests at [https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html).
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html)找到关于AWS请求签名过程的详细信息。
- en: 'Inside the `r``esolvers.js` file, we need to add one `Upload` resolver, as
    follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resolvers.js`文件内部，我们需要添加一个`Upload`解析器，如下所示：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `mutation` property, insert the `uploadAvatar` function, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mutation`属性内部，插入`uploadAvatar`函数，如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we start by specifying the function as `async`
    so that we can use the `await` method to resolve the file and its details. The
    result of the resolved `await file` method consists of the `stream`, `filename`,
    `mimetype`, and `encoding` properties.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先将函数指定为`async`，这样我们就可以使用`await`方法解析文件及其详细信息。解析的`await file`方法的结果包括`stream`、`filename`、`mimetype`和`encoding`属性。
- en: 'Then, we collect the following parameters in the `params` variable, in order
    to upload our avatar image:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`params`变量中收集以下参数，以便上传我们的头像图像：
- en: The `Bucket` field holds the name of the bucket where we save the image. I took
    the name `'apollo-book'`, but you will need to enter the name that you entered
    during the creation of the bucket. You could have specified this directly inside
    of the `s3` object, but this approach is a bit more flexible since you can have
    multiple buckets for different file types, without the need for multiple `s3`
    objects.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bucket`字段持有我们保存图像的存储桶名称。我使用了`''apollo-book''`这个名字，但你需要输入你在创建存储桶时输入的名字。你可以在`s3`对象内部直接指定这个名字，但这种方法更灵活，因为你可以为不同类型的文件拥有多个存储桶，而不需要多个`s3`对象。'
- en: The `Key` property is the path and name under which the file is saved. Notice
    that we store the file under a new folder, which is just the user `context` variable.
    In a future application, you can introduce some kind of hash for every file. That
    would be good since the filename should not include characters that are not allowed.
    Furthermore, the files cannot be guessed programmatically when using a hash.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Key`属性是文件保存的路径和名称。请注意，我们将文件存储在一个新文件夹下，这个文件夹就是用户`context`变量。在未来的应用中，你可以为每个文件引入某种哈希值。那会很好，因为文件名不应该包含不允许的字符。此外，当使用哈希时，文件不能被程序性地猜测。'
- en: The `ACL` field sets the permission for who can access the file. Since uploaded
    images on a social network are publicly viewable by anyone on the internet, we
    set the property to `'public-read'`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACL`字段设置了谁可以访问文件的权限。由于社交网络上的上传图像可以被互联网上的任何人公开查看，我们将属性设置为`''public-read''`。'
- en: The `Body` field receives the `stream` variable, which we initially got by resolving
    the file. The `stream` variable is nothing more than the image itself as a stream,
    which we can directly upload into the bucket.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Body`字段接收`stream`变量，这是我们通过解析文件最初获得的。`stream`变量不过就是图像本身作为一个流，我们可以直接将其上传到存储桶中。'
- en: The `params` variable is given to the `s3.upload` function, which saves the
    file to our bucket. We directly chain the `promise` function onto the `upload`
    method. In the preceding code snippet, we use the `await` statement to resolve
    the promise returned by the `upload` function. Therefore, we specified the function
    as `async`. The `response` object of the AWS S3 upload includes the public URL
    under which the image is accessible to everyone.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`params` 变量被传递给 `s3.upload` 函数，该函数将文件保存到我们的存储桶。我们直接将 `promise` 函数链接到 `upload`
    方法。在前面的代码片段中，我们使用 `await` 语句来解决 `upload` 函数返回的承诺。因此，我们将函数指定为 `async`。AWS S3 上传的
    `response` 对象包括一个公共 URL，任何人都可以通过该 URL 访问图像。'
- en: The last step is to set the new avatar picture on the user in our database.
    We execute the `User.update` model function from Sequelize by setting the new
    URL from `response.Location`, which S3 gave us after we resolved the promise.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在我们的数据库中设置新的用户头像图片。我们通过设置从 `response.Location` 的新 URL（S3 在我们解决承诺后提供给我们）来执行
    Sequelize 的 `User.update` 模型函数。
- en: 'An example link to an S3 image is provided here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个指向 S3 图像的示例链接：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the URL is prefixed with the name of the bucket and then the
    region. The suffix is, of course, the folder, which is the user ID and the filename.
    The preceding URL will differ from the one that your backend generates because
    your bucket name and region will vary.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，URL 前缀是存储桶的名称，然后是区域。后缀当然是文件夹，即用户 ID 和文件名。前面的 URL 将与后端生成的 URL 不同，因为您的存储桶名称和区域将不同。
- en: After updating the user, we can return the AWS response to update the **user
    interface** (**UI**) accordingly, without refreshing the browser window.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更新用户后，我们可以返回 AWS 响应以相应地更新 **用户界面**（**UI**），而不需要刷新浏览器窗口。
- en: 'In the previous section, we generated access tokens in order to authorize our
    backend at AWS. By default, the AWS `JWT_SECRET`, we will set the tokens, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们生成了访问令牌以授权 AWS 的后端。默认情况下，AWS `JWT_SECRET`，我们将设置令牌，如下所示：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Insert your AWS tokens into the preceding code. The AWS SDK will detect both
    environment variables automatically. We do not need to read or configure them
    anywhere in our code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的 AWS 令牌插入到前面的代码中。AWS SDK 会自动检测环境变量。我们不需要在我们的代码中任何地方读取或配置它们。
- en: We will now continue and implement all of the image upload features in the frontend.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续在前端实现所有图像上传功能。
- en: React image cropping and uploading
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 图像裁剪和上传
- en: In social networks such as Facebook, there are multiple locations where you
    can select and upload files. You can send images in chats, attach them to posts,
    create galleries in your profile, and much more. For now, we will only look at
    how to change our user's avatar image. This is a great example for easily showing
    all of the techniques.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Facebook 这样的社交网络中，有多个位置可以供您选择和上传文件。您可以在聊天中发送图片，将它们附加到帖子中，在您的个人资料中创建相册，等等。现在，我们只看看如何更改我们用户的头像图片。这是一个展示所有技术的好例子。
- en: 'The result that we are targeting looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望达到的结果看起来像这样：
- en: '![Figure 7.8 – Cropping dialog'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 裁剪对话框](img/Figure_7.08_B17337.jpg)'
- en: '](img/Figure_7.08_B17337.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 裁剪对话框](img/Figure_7.08_B17337.jpg)'
- en: Figure 7.8 – Cropping dialog
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 裁剪对话框
- en: The user can select a file, crop it directly in the modal, and save it to AWS
    with the preceding dialog.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以选择一个文件，在模态框中直接裁剪它，并使用前面的对话框将其保存到 AWS。
- en: I am not a big fan of using too many `npm` packages, as this often makes your
    application unnecessarily big. As of the time of writing this book, we cannot
    write custom React components for everything, such as displaying a dialog or cropping,
    no matter how easy it might be.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是很喜欢使用太多的 `npm` 包，因为这通常会使您的应用程序变得不必要地大。截至本书编写时，我们无法为显示对话框或裁剪等一切编写自定义 React
    组件，无论这可能多么容易。
- en: 'To get the image upload working, we will install two new packages. To do this,
    you can follow these instructions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使图像上传工作，我们将安装两个新的包。为此，您可以按照以下说明操作：
- en: 'Install the packages with `npm`, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm` 安装包，如下所示：
- en: '[PRE11]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When using the `react-cropper` package, we can rely on its included `App.js`
    file, import it straight from the package itself, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 `react-cropper` 包时，我们可以依赖其包含的 `App.js` 文件，直接从包本身导入，如下所示：
- en: '[PRE12]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Webpack takes care of bundling all assets, as we are already doing with our
    custom CSS. The rest of the required CSS is available on the official GitHub repository
    of this book.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Webpack 负责打包所有资源，就像我们用自定义 CSS 所做的那样。其余所需的 CSS 都可在本书的官方 GitHub 仓库中找到。
- en: 'The next package that we will install is an extension for Apollo Client, which
    will enable us to upload files, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要安装的包是Apollo客户端的扩展，这将使我们能够上传文件，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To get the `apollo-upload-client` package running, we have to edit the `index.js`
    file from the `apollo` folder where we initialize Apollo Client and all of its
    links. Import the `createUploadLink` function at the top of the `index.js` file,
    as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行`apollo-upload-client`包，我们必须编辑`apollo`文件夹中的`index.js`文件，在那里我们初始化Apollo客户端及其所有链接。在`index.js`文件顶部导入`createUploadLink`函数，如下所示：
- en: '[PRE14]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You must replace the old `HttpLink` instance at the bottom of the link array
    with the new upload link. Instead of having a new `HttpLink`, we will now pass
    the `createUploadLink` function, but with the same parameters. When executing
    it, a regular link is returned. The link should look like this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须用新的上传链接替换链表底部的旧`HttpLink`实例。现在，我们将传递`createUploadLink`函数，但使用相同的参数。执行时，将返回一个常规链接。链接应如下所示：
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to note that when we make use of the new upload link and send
    a file with a GraphQL request, we do not send the standard `application/json`
    `Content-Type` request, but instead send a multipart `FormData` request. This
    allows us to upload files with GraphQL. Standard `file` objects.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的是，当我们使用新的上传链接并通过GraphQL请求发送文件时，我们不会发送标准的`application/json` `Content-Type`请求，而是发送一个多部分的`FormData`请求。这允许我们使用GraphQL上传标准`file`对象。
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, it is possible to send a `base64` string instead of a `file`
    object when transferring images. This procedure would save you from the work that
    we are doing right now, as sending and receiving strings is no problem with GraphQL.
    You have to convert the `base64` string to a file if you want to save it in AWS
    S3\. This approach only works for images, however, and web applications should
    be able to accept any file type.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，在传输图像时，可以发送一个`base64`字符串而不是`file`对象。这种方法将节省我们目前正在做的工作，因为发送和接收字符串在GraphQL中是没有问题的。如果您想将其保存到AWS
    S3，则必须将`base64`字符串转换为文件。然而，这种方法仅适用于图像，并且Web应用程序应该能够接受任何文件类型。
- en: Now that the packages are prepared, we can start to implement our `uploadAvatar`
    mutation component for the client. Create a new file called `uploadAvatar.js`
    in the `mutations` folder.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在包已经准备好了，我们可以开始为客户实现`uploadAvatar`突变组件。在`mutations`文件夹中创建一个名为`uploadAvatar.js`的新文件。
- en: 'At the top of the file, import all dependencies and parse all GraphQL requests
    with `gql` in the conventional way, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，导入所有依赖项，并以传统方式使用`gql`解析所有GraphQL请求，如下所示：
- en: '[PRE16]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we have just exported the new mutation by wrapping the GraphQL
    query with the `useMutation` Hook. Also, we added an `update` function that will
    update the cache by first getting the reference for the current user and afterward
    updating this one user by reference to the new avatar URL.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们只是通过将GraphQL查询包裹在`useMutation`钩子中导出了新的突变。我们还添加了一个`update`函数，该函数将首先获取当前用户的引用，然后通过引用更新此用户的新头像URL来更新缓存。
- en: 'Lastly, we need to add the `id` property to the `userAttributes` fragment.
    Otherwise, the update of the avatar URL on the user reference would only be reflected
    on the top bar and not with all the posts. The code is illustrated in the following
    snippet:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将`id`属性添加到`userAttributes`片段中。否则，用户引用上头像URL的更新只会反映在顶部栏上，而不会反映在所有帖子中。代码如下所示：
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preparation is now complete. We have installed all of the required packages,
    configured them, and implemented the new mutation component. We can begin to program
    the user-facing dialog to change the avatar image.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作现在已完成。我们已经安装了所有必需的包，进行了配置，并实现了新的突变组件。我们可以开始编写用户界面对话框来更改头像图像。
- en: For the purposes of this book, we are not relying on separate pages or anything
    like that. Instead, we are giving the user the opportunity to change their avatar
    when they click on their image in the top bar. To do so, we are going to listen
    for the click event on the avatar, opening up a dialog that includes a file dropzone
    and a button to submit the new image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，我们不是依赖于单独的页面或类似的东西。相反，我们给用户提供了在顶部栏点击他们的图像时更改头像的机会。为此，我们将监听头像上的点击事件，打开一个包含文件拖放区域和提交新图像按钮的对话框。
- en: 'Execute the following steps to get this logic running:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以运行此逻辑：
- en: It is always good to make your components as reusable as possible, so create
    an `avatarModal.js` file inside of the `components` folder.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是让您的组件尽可能可重用是一个好主意，因此请在 `components` 文件夹内创建一个 `avatarModal.js` 文件。
- en: 'As always, you will have to import the new `react-modal`, `react-cropper`,
    and `react-dropzone` packages first and then the mutation, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，您必须首先导入新的 `react-modal`、`react-cropper` 和 `react-dropzone` 包，然后是突变，如下所示：
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see in the preceding code snippet, we tell the modal package at which
    point in the browser's `setAppElement` method. For our use case, it is okay to
    take the `root` DOMNode, as this is the starting point of our application. The
    modal is instantiated in this DOMNode.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们告诉模态包在浏览器 `setAppElement` 方法的哪个点。对于我们的用例，取 `root` DOMNode 是可以的，因为这是我们应用程序的起点。模态框在这个
    DOMNode 中实例化。
- en: The modal component accepts a special `style` parameter for the different parts
    of the dropzone. We can style all parts of the modal by specifying the `modalStyle`
    object with the correct properties.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模态组件接受一个特殊的 `style` 参数，用于拖拽区域的不同部分。我们可以通过指定 `modalStyle` 对象和正确的属性来样式化模态框的所有部分。
- en: 'The `react-cropper` package gives the user the opportunity to crop the image.
    The result is not a `file` or `blob` object, but a `dataURI` object, formatted
    as `base64`. Generally, this is not a problem, but our GraphQL API expects that
    we send a real file, not just a string, as we explained previously. Consequently,
    we have to convert the `dataURI` object to a blob that we can send with our GraphQL
    request. Add the following function to take care of the conversion:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`react-cropper` 包给用户提供了裁剪图像的机会。结果是 `file` 或 `blob` 对象，而是一个 `dataURI` 对象，格式化为
    `base64`。通常这不会是问题，但我们的 GraphQL API 期望我们发送一个真实的文件，而不仅仅是字符串，正如我们之前解释的那样。因此，我们必须将
    `dataURI` 对象转换为 blob，我们可以将其与我们的 GraphQL 请求一起发送。添加以下函数来处理转换：'
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's not get too deep into the logic behind the preceding function. The only
    thing that you need to know is that it converts all readable `blob` object to
    the calling function. It converts data URIs to blobs.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们不要深入探讨前面函数的逻辑。您需要知道的是，它将所有可读的 `blob` 对象转换为调用函数。它将数据 URI 转换为 blob。
- en: 'The new component that we are implementing at the moment is called `AvatarUpload`.
    It receives the `isOpen` property, which sets the modal to visible or invisible.
    By default, the modal is invisible. Furthermore, when the modal is shown, the
    dropzone is rendered inside. First, set up the component itself and the required
    variables, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们目前正在实施的新组件被称为 `AvatarUpload`。它接收 `isOpen` 属性，该属性用于设置模态框的可见或不可见。默认情况下，模态框是不可见的。此外，当模态框显示时，拖拽区域将渲染在其中。首先，设置组件本身和所需的变量，如下所示：
- en: '[PRE20]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We require the `file` and `result` state variables to manage the original file
    selected and the cropped image. Furthermore, we set up the mutation and a reference
    using the `useRef` Hook, which is required for the `cropper` library.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要 `file` 和 `result` 状态变量来管理选定的原始文件和裁剪图像。此外，我们使用 `useRef` 钩子设置突变和引用，这对于 `cropper`
    库是必需的。
- en: 'Next, we need to set up all the component functions that we will use to handle
    different events and callbacks. Add the following functions to the component:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置所有我们将用于处理不同事件和回调的组件函数。将以下函数添加到组件中：
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `saveAvatar` function is the main function that will translate the `base64`
    string into a blob. The `onDrop` function is called when the user drops or selects
    an image. At this moment, we use `FileReader` to read the file and give us the
    `base64` string that we save in the `file` state variable as an object. The `useDropZone`
    Hook gives us all the properties that we can use to set up the actual dropzone.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`saveAvatar` 函数是主要函数，它将 `base64` 字符串转换为 blob。当用户拖放或选择图像时，会调用 `onDrop` 函数。此时，我们使用
    `FileReader` 读取文件，并给我们一个 `base64` 字符串，我们将其保存到 `file` 状态变量中作为一个对象。`useDropZone`
    钩子为我们提供了所有可以用来设置实际拖拽区域的属性。'
- en: The `changeImage` function will cancel the current crop process and allow us
    to upload a new file again.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`changeImage` 函数将取消当前的裁剪过程，并允许我们再次上传新文件。'
- en: The `onCrop` function is called every time the cropped selection is changed
    by the user. At this moment, we save the new cropped image as a `base64` string
    to the `result` state variable to have a clear separation between the original
    `file` variable and the `result` variable.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当用户更改裁剪选择时，都会调用 `onCrop` 函数。此时，我们将新的裁剪图像作为 `base64` 字符串保存到 `result` 状态变量中，以便在原始
    `file` 变量和 `result` 变量之间有清晰的分离。
- en: The `Modal` component takes an `onRequestClose` method, which executes the `showModal`
    function when the user tries to close the modal by clicking outside of it, for
    example. We receive the `showModal` function from the parent component, which
    we are going to cover in the next step. The modal also receives the default `style`
    property and a label.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Modal` 组件接受一个 `onRequestClose` 方法，当用户尝试通过点击外部关闭模态框时，会执行 `showModal` 函数，例如。我们从父组件接收
    `showModal` 函数，我们将在下一步中介绍。模态框还接收默认的 `style` 属性和一个标签。'
- en: 'The `Cropper` component needs to receive a function in the `crop` property
    that is called on every change. Also, the `Cropper` component receives the `src`
    property from the `file` state variable, as illustrated in the following code
    snippet:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Cropper` 组件需要在 `crop` 属性中接收一个函数，该函数在每次更改时被调用。同时，`Cropper` 组件从 `file` 状态变量接收
    `src` 属性，如下代码片段所示：'
- en: '[PRE22]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `return` statement, as you can see, only includes the modal as a wrapper
    and a cropper. At the end, we have a button calling `saveAvatar` to execute the
    mutation, and with it send the cropped image or `changeImage`, which cancels the
    cropping for the current image.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，`return` 语句仅包括作为包装器的模态框和一个裁剪器。最后，我们有一个调用 `saveAvatar` 的按钮来执行突变，并与之发送裁剪图像或
    `changeImage`，后者取消当前图像的裁剪。
- en: 'Don''t forget to add the `export` statement to the end of the file, as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在文件末尾添加 `export` 语句，如下所示：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, switch over to the `user.js` file in the `bar` folder, where all of the
    other application bar-related files are stored. Import the new `AvatarModal` component,
    as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到 `bar` 文件夹中的 `user.js` 文件，其中存储了所有其他应用程序栏相关的文件。按照以下方式导入新的 `AvatarModal`
    组件：
- en: '[PRE24]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `UserBar` component is the parent of `AvatarUploadModal`. Open the `user.js`
    file from the `bar` folder. That is why we handle the `isOpen` state variable
    of the dialog in the `UserBar` component. We introduce an `isOpen` state variable
    and catch the `onClick` event on the avatar of the user. Copy the following code
    into the `UserBar` component:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserBar` 组件是 `AvatarUploadModal` 的父组件。从 `bar` 文件夹中打开 `user.js` 文件。这就是为什么我们在
    `UserBar` 组件中处理对话框的 `isOpen` 状态变量。我们引入了一个 `isOpen` 状态变量，并在用户的头像上捕获 `onClick` 事件。将以下代码复制到
    `UserBar` 组件中：'
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Replace the `return` statement with the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `return` 语句替换为以下代码：
- en: '[PRE26]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The modal component directly receives the `isOpen` property, as we explained
    earlier. The `showModal` method is executed when the avatar image is clicked.
    This function updates the property of the `AvatarModal` component, and either
    shows or hides the modal.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模态组件直接接收 `isOpen` 属性，正如我们之前解释的那样。当点击头像图像时，会执行 `showModal` 方法。这个函数更新 `AvatarModal`
    组件的属性，并显示或隐藏模态框。
- en: 'Start the server and client with the matching `npm run` commands. Reload your
    browser and try out the new feature. When an image is selected, the cropping tool
    is displayed. You can drag and resize the image area that should be uploaded.
    You can see an example of this in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匹配的 `npm run` 命令启动服务器和客户端。重新加载浏览器并尝试新功能。当选择图像时，会显示裁剪工具。你可以拖动并调整要上传的图像区域的大小。你可以在以下屏幕截图中看到这个示例：
- en: '![Figure 7.9 – Cropping in progress'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.9 – Cropping in progress](img/Figure_7.09_B17337.jpg)'
- en: '](img/Figure_7.09_B17337.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.09 – B17337.jpg](img/Figure_7.09_B17337.jpg)'
- en: Figure 7.9 – Cropping in progress
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 7.9 – Cropping in progress
- en: Hitting `user` folder in the S3 bucket. Thanks to the mutation that we wrote,
    the avatar image in the top bar is updated with the new URL to the S3 bucket location
    of the image.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 S3 存储桶中点击 `user` 文件夹。多亏了我们编写的突变，顶栏中的头像图像被更新为指向图像在 S3 存储桶位置的新的 URL。
- en: The great thing that we have accomplished is that we send the images to our
    server. Our server transfers all of the images to S3\. AWS responds with the public
    URL, which is then placed directly into the avatar field in the browser. The way
    that we query the avatar image from the backend, using our GraphQL API, does not
    change. We return the URL to the S3 file, and everything works.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所取得的巨大成就是将图像发送到我们的服务器。我们的服务器将所有图像传输到 S3。AWS 响应公共 URL，然后直接放置在浏览器的头像字段中。我们使用
    GraphQL API 从后端查询头像图像的方式没有改变。我们返回 S3 文件的 URL，一切正常工作。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by creating an AWS account and an S3 bucket for
    uploading static images from our backend. Modern social networks consist of many
    images, videos, and other types of files. We introduced Apollo Client, which allows
    us to upload any type of file. In this chapter, we managed to upload an image
    to our server, and we covered how to crop images and save them through a server
    in AWS S3\. Your application should now be able to serve your users with images
    at any time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先创建了一个AWS账户和一个S3存储桶，用于从我们的后端上传静态图像。现代社交网络由许多图像、视频和其他类型的文件组成。我们介绍了Apollo客户端，它允许我们上传任何类型的文件。在本章中，我们成功地将一张图像上传到我们的服务器，并介绍了如何在AWS
    S3服务器上裁剪图像并保存它们。现在，您的应用程序应该能够随时为用户提供图像服务。
- en: The next chapter will cover the basics of client-side routing, with the use
    of React Router.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖客户端路由的基础知识，使用React Router实现。
