- en: Going into Production
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is almost ready and it's time to go into production. Since this
    is the age of cloud computing, we will be deploying our application to a cloud
    provider—Heroku, to be specific. Before we go on and deploy intended for Linux,
    but it is possible to use it with Mac and Windows using tools such as our application
    into production, we need to make sure our application is production ready in our
    local environment. It would also be beneficial to make ourselves familiar with
    technologies and tools that will be useful at this stage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the production database with Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Spring profiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging the application for local deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading to the newest version of JHipster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the deployment options supported by JHipster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production deployment to Heroku cloud
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Introduction to Docker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is one of the most disruptive technologies to have taken center stage
    in the world of DevOps in recent times. Docker is a technology that enables operating-system-level
    virtualization or containerization, and is also open source and free to use. Docker
    is intended for Linux, but it is possible to use it with Mac and Windows using
    tools such as Docker for Mac and Docker for Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about containers in the Docker world, we are technically talking
    about Linux containers. As stated by Red Hat on their website ([https://www.redhat.com/en/topics/containers/whats-a-linux-container](https://www.redhat.com/en/topics/containers/whats-a-linux-container)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A Linux container is a set of processes that are isolated from the rest of the
    system, running from a distinct image that provides all files necessary to support
    the processes. By providing an image that contains all of an application’s dependencies,
    it is portable and consistent as it moves from development to testing, and finally
    to production.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Though the concept is not new, Docker makes it possible to create containers
    that are easy to build, deploy, version, and share. A Docker container only contains
    dependencies that are required for the application to run on the host OS; it shares
    the OS and other dependencies for the host system hardware. This makes a Docker
    container lighter than a **virtual machine** (**VM**) in terms of size and resource
    usage as it doesn't have to ship an entire OS and emulate virtual hardware. Hence, Docker
    made virtual machines obsolete in many of the traditional use cases that were
    handled using VM technologies. This also means that, with Docker, we will be able
    to run more applications on the same hardware compared to running with VMs. Docker
    containers are instances of a docker image, which is a set of layers which describes
    the application that is being containerized. They contain the code, runtime, libraries,
    environment variables, and configuration files needed to run the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Dockerfile is a set of instructions that tells Docker how to build a Docker
    image. By running the `docker build` command on a specific Dockerfile, we will
    produce a docker image that can be used to create Docker containers. Existing
    docker images can be used as a base for new Dockerfiles, hence letting you reuse
    and extend existing images.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from the Dockerfile of our application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `FROM` instruction specifies the base image to use while initializing the
    build. Here, we specify open JDK 8 as our Java runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The `ENV` instruction is used to set environment variables, and the `CMD` instruction
    is used to specify commands to be executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The `EXPOSE` instruction is used to specify the port that the container listens
    to during runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for a complete reference.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Hub
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) is the online
    registry provided by Docker. It can be used to publish public and private docker
    images. This makes sharing and reusing docker images extremely easy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: To get a docker image from the registry, we just need to run `docker pull <image-name>`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: This makes it easy to use third-party tools without having to install them locally
    by just pulling and running the container from the registry.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Docker compose
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker compose is a tool in the Docker platform that is used to define and run
    multi-container applications. It lets us define how a container will behave when
    it is run in production, and also lets us define other services that it depends
    on and how services work with each other. Each application is a service as it
    defines the behavior of the container, for example, what port it runs on, what
    environment variables it uses, and so on. A YAML file is used for this. A single
    `docker.compose.yml` file can define all the services that are required for a
    multi-container application and can then be started with a single command. We
    will see more about Docker and docker -compose in [Chapter 11](9362521a-199a-4dda-ae0d-e55d9ed76957.xhtml), *Deploying
    with Docker Compose*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
    to learn more about Docker.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table is a list of useful commands for Docker and Docker compose:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '| `docker build -t myapp:1.0.` | Build an image from the Dockerfile in the
    current directory and tag the image |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `docker images` | List all images that are locally stored with the Docker engine
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `docker pull alpine:3.4` | Pull an image from a registry |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `docker push myrepo/myalpine:3.4` | Push an image to a registry |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `docker login` | Log in to a registry (the Docker Hub, by default) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `docker run --rm -it -p 5000:80 -v /dev/code alpine:3.4 /bin/sh` | Run a
    docker container**--rm**: Remove container automatically after it exits **-it**:
    Connect the container to the Terminal'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**-p**: Expose port `5000` externally and map to port `80`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**-v**: Create a host mapped volume inside the container'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**alpine:3.4**: The image from which the container is instantiated'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**/bin/sh**: The command to run inside the container |'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '| `docker stop myApp` | Stop a running container |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `docker ps` | List the running containers |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `docker rm -f $(docker ps -aq)` | Delete all running and stopped containers
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `docker exec -it web bash` | Create a new bash process inside the container
    and connect it to the Terminal |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `docker logs --tail 100 web` | Print the last 100 lines of a container''s
    logs |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `docker-compose up` | Start the services defined in the `docker-compose.yml`
    file in the current folder |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `docker-compose down` | Stop the services defined in the `docker-compose.yml`
    file in the current folder |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: Starting the production database with Docker
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JHipster creates a Dockerfile for the application and provides `docker-compose`
    files for all the technologies we choose, such as the database, search engine,
    Jenkins, and so on, under `src/main/docker`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see how we can start our production database using Docker from the compose
    file provided under `src/main/docker/mysql.yml`. You will need to use a Terminal
    for the following instructions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Run `docker --version` and `docker-compose --version` to ensure these are installed.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker ps` to list the running containers. If you are not already running
    any containers, you should see an empty list.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start the DB by running `docker-compose -f src/main/docker/mysql.yml up`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following console output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a0b7920-48c2-4abd-a248-20fb92ab1dfc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: If you want to run the service in the background, pass the `-d` flag to the
    command. `docker-compose -f src/main/docker/mysql.yml up -d` will let you continue
    to use the same Terminal without having to switch to another.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you run `docker ps` again, it should list the database service that
    we started:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/163a93cf-8eb3-4041-ac9e-c9000aa34411.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: An introduction to Spring profiles
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we prepare our application for production, let's talk a little bit about
    Spring profiles.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Spring profiles ([https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java))
    let you change the way your application behaves based on environments. This is
    achieved using the `@Profile` annotations and profile-specific configuration files,
    which can be activated by specifying the `spring.profiles.active` property. Based
    on the profile that we set here, Spring will choose the appropriate `application.properties/application.yml`
    files and will include/exclude components that are included/excluded for the specific
    profile using the `@Profile` annotation in the Java source code. For example,
    if we set `spring.profiles.active=prod`, all the Spring components that have `@Profile("prod")`
    will be instantiated and any component that has `@Profile("!prod")` will be excluded.
    Similarly, Spring will load and use the `application-prod.yml` or `application-prod.properties`
    file if it is available on the classpath.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'JHipster configures a `dev` and `prod` profile by default and includes an `application-dev.yml`
    and `application-prod.yml` in the `src/main/resources/config` folder, along with
    the base `application.yml` file. JHipster goes a step further and provides a `dev`
    and `prod` profile for the Gradle build as well (Available for Maven as well)
    so that we can build/run the application for a particular profile, which is very
    handy. Here are the profile and database configurations defined in the `application-dev.yml`
    file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following profiles are available in a JHipster application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '| `dev` | Tuned for development and productivity, it enables Spring dev tools,
    in-memory databases, and so on |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Tuned for production, it focuses on performance and stability |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `swagger` | Enables Swagger documentation for the API |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `no-liquibase` | Disables Liquibase, and is useful in production environments
    where you don''t want Liquibase to run |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: Packaging the application for local deployment
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's build our application and deploy it locally. This can be done in two
    ways, either using Docker or by building and executing a WAR file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying using Docker
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use a Gradle task to build our docker image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Use the `./gradlew tasks` command to list all available tasks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Terminal, go to the project root folder and execute; `./gradlew bootRepackage
    -Pprod buildDocker`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**bootRepackage**: Builds an executable archive (WAR) file for the application'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-Pprod**: Specifies the profile to use'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**buildDocker**: Builds a docker image based on the Dockerfile present in the `src/main/docker`
    folder'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using JHipster Version 5 or above, use `bootWar` instead of the `bootRepackage`
    command in Gradle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Once the task is completed successfully, we can deploy our app by running:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will also start the MySQL DB if you haven't started it already. If you
    already have it running from the previous step, then `docker-compose` will just
    skip it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will be ready once we see the following output in the console.
    As you can see, it''s running with the `prod` and `swagger` profiles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b7871d3-eb48-463f-9b18-466c3f0fb218.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Visit `http://localhost:8080` in your favorite browser to see the application
    in action.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying an executable archive
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you prefer not to use Docker, then we could deploy the app with a production
    profile locally by completing the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that MySQL DB is running from the previous step; otherwise,
    start it using `docker-compose -f src/main/docker/mysql.yml up -d`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's create an executable archive for the prod profile by running `./gradlew
    bootRepackage -Pprod`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the build is successful, there will be two archives (WAR) created under
    `build/libs`. The `store-0.0.1-SNAPSHOT.war` file is an executable archive which
    can be run directly on a JVM, and the `store-0.0.1-SNAPSHOT.war.original` is a
    normal WAR file that can be deployed to a server such as JBoss or Tomcat.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's use the executable archive. Just run `./build/libs/store-0.0.1-SNAPSHOT.war`
    to start the application. If you are on Windows, run `java -jar build/libs/store-0.0.1-SNAPSHOT.war`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the application starts up, you will see the URL printed on the console.
    Visit `http://localhost:8080` in your favorite browser to see the application
    in action.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading to the newest version of JHipster
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JHipster provides an upgrade sub-generator ([http://www.jhipster.tech/upgrading-an-application/](http://www.jhipster.tech/upgrading-an-application/)) to
    help you upgrade an application with a new JHipster version of it. It is quite
    useful as it automates a lot of manual steps for you, and the only thing you need
    to do is resolve merge conflicts if there are any after the upgrade is complete.
    Let's upgrade our application, shall we?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In your Terminal, execute the `jhipster upgrade` command. The upgrade process
    will start if there is a new version of JHipster available; otherwise the process
    will exit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the process starts, you will see a detailed console log of what is going
    on. As you can see, this sub-generator uses the global JHipster version instead
    of the local one, unlike other sub-generators:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sub-generator does the following in order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether there is a new version of JHipster available (not applicable
    if you are using `--force`).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checks whether the application is already initialized as a GIT repository; otherwise,
    JHipster will initialize one for you and commit the current codebase to the master
    branch.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checks to ensure that there are no uncommitted local changes in the repository.
    The process will exit if it finds any uncommitted changes.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checks whether a `jhipster_upgrade` branch exists. If not, a branch is created.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checks out the `jhipster_upgrade` branch.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrades JHipster to the latest available version globally.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleans the current project directory.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regenerates the application using the `jhipster --force --with-entities` command.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commits the generated code to the `jhipster_upgrade` branch.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merges the `jhipster_upgrade` branch back to the original branch from where
    the `jhipster upgrade` command was launched.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see what has changed after the upgrade before we resolve the merge conflicts.
    See the changes staged. Carefully check the changes to make sure everything is
    in order, especially in the files where we made customizations earlier. My changelog
    looks like this; note that I truncated the bottom as there were 147 updated files:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/385098d9-1701-4287-bbdc-1b12e53d1500.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Thankfully, we have only three conflicts and hence they should be easy to resolve.
    The conflict in `package.json` arises from the change we made to integrate Bootswatch.
    Carefully resolve the conflict stage in the file and move on to next file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the conflicts are resolved, stage the files and commit them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ensure that everything works. Run the server-side and client-side tests using
    `./gradlew test && yarn && yarn test`, and start the application to verify this
    by running the `./gradlew clean webpackBuildDev bootRun` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to deployment options supported by JHipster
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have verified our production builds by deploying it locally, let's
    see how we can take it to actual production by using a cloud service. JHipster
    supports most of the cloud platforms out of the box, and provides special sub-generator
    commands for the popular ones such as Heroku, Cloudfoundry, and AWS.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: JHipster also supports platforms such as Openshift, Google Cloud (using Kubernetes),
    and Rancher, but let's see them in upcoming chapters as they are more geared towards
    microservices. In theory, though, you could use them for Monolith deployments
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku ([https://www.heroku.com/](https://www.heroku.com/)) is the cloud platform
    from Salesforce. It lets you deploy, manage, and monitor your applications on
    the cloud. Heroku has a focus on Applications rather than on containers and supports
    languages ranging from NodeJS to Java to Go. JHipster provides the Heroku sub-generator,
    which was built and is maintained by Heroku, making it easy to deploy JHipster
    apps to Heroku cloud. It makes use of the Heroku CLI, and you need a Heroku account
    to use it. The sub-generator can be used to deploy and update your application
    to Heroku.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://www.jhipster.tech/heroku/](http://www.jhipster.tech/heroku/) for
    more info.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Foundry
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud Foundry is a multi-cloud computing platform governed by Cloud Foundry
    Foundation. It was originally created by VMWare, and is now under Pivotal, the
    company behind Spring Framework. It offers a multi-cloud solution which is currently
    supported by **Pivotal Cloud Foundry** (**PCF**), **Pivotal Web Services** (**PWS**),
    Atos Canary, SAP cloud platform, and IBM Bluemix among others. The platform is
    open source and hence can be used to set up your own private instance. JHipster
    provides a sub-generator to deploy JHipster applications to any Cloud Foundry
    provider easily. It makes use of the Cloud Foundry command line tool.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://www.jhipster.tech/cloudfoundry/](http://www.jhipster.tech/cloudfoundry/)
    for more info.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) is the leading cloud computing platform that
    offers platform, software, and infrastructure as a service. AWS offers Elastic
    Beanstalk as a simple platform to deploy and manage your applications on the cloud.
    JHipster provides a sub-generator to deploy JHipster applications to AWS or Boxfuse
    ([http://www.jhipster.tech/boxfuse](http://www.jhipster.tech/boxfuse)/), an alternative
    service.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://www.jhipster.tech/aws/](http://www.jhipster.tech/aws/) for more
    info.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Production deployment to Heroku cloud
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to choose a cloud provider. For this demo, let's choose Heroku.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Though the Heroku account is free and you get free credits, you will have to
    provide your credit card information to use MySQL and other add-ons. You will
    only be charged if you exceed the free quota.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deploy our application to Heroku by completing the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create an account in Heroku ([https://signup.heroku.com/](https://signup.heroku.com/)).
    It is free and you get free credits as well.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Heroku CLI tool by following  [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the Heroku CLI is installed fine by running `heroku --version`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login to Heroku by running `heroku login`. When prompted, enter your Heroku
    email and password.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now run the `jhipster heroku` command. You will start seeing questions.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose a name you like when asked Name to deploy as: (store). By, default it
    will use the application name. Try to choose a unique name since the Heroku namespace
    is shared.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be asked to choose a region—On which region do you want to deploy? Choose
    between US and EU, and proceed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generator will create the required files and accept changes suggested by
    the Gradle build files.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The console output will look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c22002f-f3e7-4535-bbd4-2c805f16922f.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: The generated `.yml` files add Heroku-specific configurations for the application.
    The `Procfile` contains the specific command that will be executed on Heroku for
    the application. The Gradle build is also modified to include dependencies required
    by Heroku.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'After generating the files, it will build the application and will start uploading
    artifacts. This may take several minutes based on your network latency. Once this
    has been successfully completed, you should see the following screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 生成文件后，它将构建应用程序并开始上传工件。这可能会根据你的网络延迟需要几分钟。一旦成功完成，你应该会看到以下屏幕：
- en: '![](img/eb2b31e1-4456-4b8d-83e1-4873bfc9d5ae.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb2b31e1-4456-4b8d-83e1-4873bfc9d5ae.png)'
- en: Now run the `heroku open` command to open the deployed application in a browser.
    That's it, you have successfully deployed your application to Heroku with a few
    commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `heroku open` 命令以在浏览器中打开已部署的应用程序。就这样，你已成功使用几个命令将应用程序部署到 Heroku。
- en: When you update the application further, you can rebuild the package using `./gradlew
    -Pprod bootRepackage` and then redeploy it using the `heroku deploy:jar --jar
    build/libs/*war` command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进一步更新应用程序时，你可以使用 `./gradlew -Pprod bootRepackage` 命令重新构建包，然后使用 `heroku deploy:jar
    --jar build/libs/*war` 命令重新部署它。
- en: 'Don''t forget to commit the changes made to `git` by executing the following
    command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记通过执行以下命令将所做的更改提交到 `git`：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Deployment to production is one of the most important phases of application
    development, and is the most crucial one as well. With the help of JHipster, we
    deployed our application to a cloud provider with ease. We also learned about
    Docker and the various other deployment options available. We also made use of
    the upgrade sub-generator to keep our application up-to-date with JHipster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到生产是应用程序开发中最重要阶段之一，也是最重要的一个。借助 JHipster，我们轻松地将应用程序部署到了云服务提供商。我们还了解了 Docker
    和其他可用的各种部署选项。我们还使用了升级子生成器来确保我们的应用程序与 JHipster 保持最新。
- en: So far, we've seen how we can develop and deploy a monolithic e-commerce application
    using JHipster. We started with a monolith and, in the upcoming chapters, we will
    see how we can scale our application into a microservice architecture with the
    help of JHipster.  In the next chapter, we will learn about different microservice
    technologies and tools. So, stay tuned!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了如何使用 JHipster 开发和部署单体电子商务应用程序。我们从一个单体开始，在接下来的章节中，我们将看到如何在 JHipster
    的帮助下将我们的应用程序扩展到微服务架构。在下一章中，我们将学习关于不同的微服务技术和工具。所以，请保持关注！
