- en: '*Chapter 11*: E2E Tests in Angular with Cypress'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用 Cypress 在 Angular 中进行 E2E 测试'
- en: 'An app having a couple of **end-to-end** (**E2E**) tests surely promises more
    reliability than an app having no tests at all, and in today''s world, with emerging
    businesses and complex applications, it becomes essential at some point to have
    E2E tests written to capture the entire flow of an application. Cypress is one
    of the best tools out there today when it comes to E2E tests for web applications.
    In this chapter, you''ll learn how to test your E2E flows in an Angular app with
    Cypress. Here are the recipes we''re going to cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序有几个端到端（E2E）测试，肯定比一个没有测试的应用程序更可靠，在当今世界，随着新兴企业和复杂应用程序的出现，编写端到端测试以捕获整个应用程序流程变得至关重要。Cypress
    是当今用于 Web 应用程序的 E2E 测试的最佳工具之一。在本章中，您将学习如何使用 Cypress 在 Angular 应用程序中测试您的 E2E 流程。以下是本章中要涵盖的内容：
- en: Writing your first Cypress test
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个 Cypress 测试
- en: Validating if a **Document Object Model** (**DOM**) element is visible on the
    view
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证文档对象模型（DOM）元素是否在视图上可见
- en: Testing form inputs and submission
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表单输入和提交
- en: Waiting for **XMLHttpRequests** (**XHRs**) to finish
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待 XMLHttpRequest（XHR）完成
- en: Using Cypress bundled packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 捆绑包
- en: Using Cypress fixtures to provide mock data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress fixtures 提供模拟数据。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter11](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter11).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的配方中，请确保您的计算机上已安装了 Git 和 Node.js。您还需要安装 `@angular/cli` 包，您可以在终端中使用 `npm install
    -g @angular/cli` 来完成。本章的代码可以在 [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter11](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter11)
    找到。
- en: Writing your first Cypress test
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个 Cypress 测试
- en: If you have been writing E2E tests already, you might have been doing this using
    Protractor. Working with Cypress is a completely different experience, though.
    In this recipe, you'll set up Cypress with an existing Angular application and
    will write your first E2E test with Cypress.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在编写 E2E 测试，您可能已经使用 Protractor 进行了这项工作。不过，使用 Cypress 是完全不同的体验。在这个配方中，您将使用现有的
    Angular 应用程序设置 Cypress，并将使用 Cypress 编写您的第一个 E2E 测试。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter11/start_here/angular-cypress-starter`,
    inside the cloned repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的 `chapter11/start_here/angular-cypress-starter` 中：
- en: Open the project in **Visual Studio Code** (**VS Code**).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目（VS Code）。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Now that we have the project opened locally, let's see the steps of the recipe
    in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地打开了项目，让我们在下一节中看看这个配方的步骤。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The app we''re working with is a simple counter application. It has a minimum
    and maximum values and some buttons that can increment, decrement, and reset the
    counter''s value. We''ll start by configuring Cypress for our application and
    will then move toward writing the test:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的应用程序是一个简单的计数器应用程序。它有最小和最大值，以及一些按钮，可以增加、减少和重置计数器的值。我们将首先为我们的应用程序配置 Cypress，然后开始编写测试：
- en: 'First, open a new terminal window/tab and make sure you''re inside the `chapter11/start_here/angular-cypress-starter`
    folder. Once inside, run the following command to install `Cypress` and `concurrently`
    in our project:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端窗口/标签，并确保你在`chapter11/start_here/angular-cypress-starter`文件夹内。进入后，运行以下命令在我们的项目中安装`Cypress`和`concurrently`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, open your `package.json` file and add the following script inside the
    `scripts` object, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开你的`package.json`文件，并在`scripts`对象内添加以下脚本，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s run the `cypress:test` command to simultaneously start the `http://localhost:4200`
    Angular server and to start Cypress tests as well, as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行`cypress:test`命令，同时启动`http://localhost:4200`的Angular服务器，并开始Cypress测试，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should also see that Cypress creates a folder named `cypress` and some example
    tests inside it by default. Cypress also creates a `cypress.json` file to be able
    to provide some configuration. We will not remove these default tests but will
    instead ignore them in the next step.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该看到Cypress默认创建了一个名为`cypress`的文件夹，并在其中创建了一些示例测试。Cypress还创建了一个`cypress.json`文件来提供一些配置。我们不会删除这些默认测试，而是在下一步中忽略它们。
- en: 'Ignore the default/example tests by modifying the `cypress.json` file, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改`cypress.json`文件来忽略默认/示例测试，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you look again at the Cypress window now, you should see that we don't have
    any integration tests, as follows:![Figure 11.1 – No integration tests to execute
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在再看Cypress窗口，你会发现我们没有任何集成测试，如下所示：![图11.1 - 没有集成测试可执行
- en: '](image/Figure_11.1_B15150.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.1_B15150.jpg)'
- en: Figure 11.1 – No integration tests to execute
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 没有集成测试可执行
- en: 'Let''s create our first test now. We''ll just check whether the browser title
    of our app is **Writing your first Cypress test**. Create a new file inside the
    `cypress/integration` folder named `app.spec.js`, and paste the following code
    inside:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在创建我们的第一个测试。我们只需检查我们应用程序的浏览器标题是否为**编写您的第一个Cypress测试**。在`cypress/integration`文件夹内创建一个名为`app.spec.js`的新文件，并粘贴以下代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you look again at the Cypress window, you should see a new `app.spec.js`
    file listed, as follows:![Figure 11.2 – The new app.spec.js test file being shown
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你再次看Cypress窗口，你会看到一个名为`app.spec.js`的新文件列出，如下所示：![图11.2 - 显示的新app.spec.js测试文件
- en: '](image/Figure_11.2_B15150.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.2_B15150.jpg)'
- en: Figure 11.2 – The new app.spec.js test file being shown
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 显示的新app.spec.js测试文件
- en: Tap the `app.spec.js` file in the window shown in *Figure 11.2*, and you should
    see the Cypress tests passing for the tests written in the file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*图11.2*中显示的窗口中的`app.spec.js`文件，你应该看到文件中编写的Cypress测试通过了。
- en: 'Kaboom! Within a few steps, we have now set up Cypress for our Angular application
    and have written our first test. You should see the Cypress window, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！在几个步骤内，我们已经为我们的Angular应用程序设置了Cypress，并编写了我们的第一个测试。你应该看到Cypress窗口，如下所示：
- en: '![Figure 11.3 – Our first Cypress test passes'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - 我们的第一个Cypress测试通过'
- en: '](image/Figure_11.3_B15150.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.3_B15150.jpg)'
- en: Figure 11.3 – Our first Cypress test passes
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 我们的第一个Cypress测试通过
- en: Easy! Right? Now that you know how to configure Cypress for an Angular app,
    see the next section to understand how it works.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧！对吧？现在你知道如何为Angular应用程序配置Cypress了，看看下一节来了解它是如何工作的。
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Cypress can be integrated with absolutely any framework and web development
    project. One interesting fact is that Cypress uses Mocha as the test runner behind
    the scenes. The tooling for Cypress watches for code changes so that you don't
    have to recompile the tests time and time again. Cypress also adds a shell around
    the application being tested to capture logs and access DOM elements during the
    tests, and some functionality for debugging tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress可以与任何框架和Web开发项目集成。有趣的是，Cypress在幕后使用Mocha作为测试运行器。Cypress的工具会监视代码更改，这样你就不必一次又一次地重新编译测试。Cypress还会在被测试的应用程序周围添加一个外壳，以捕获日志并在测试期间访问DOM元素，并提供一些用于调试测试的功能。
- en: At the very top of our `app.spec.js` file, we use the `context()` method that
    defines the test suite, basically defining the context of the tests about to be
    written inside. Then, we use a `beforeEach()` method to specify what should happen
    before each test is executed. Since each test starts with no data, we first have
    to make sure that Cypress navigates to our application's `http://localhost:4200`
    **Uniform Resource Locator** (**URL**). The reason we just specify `cy.visit('/')`
    and it still works is that we have already specified the `baseUrl` property in
    the `cypress.json` file. Therefore, we just have to provide relative URLs in our
    tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `app.spec.js` 文件的顶部，我们使用 `context()` 方法来定义测试套件，基本上是定义即将在内部编写的测试的上下文。然后，我们使用
    `beforeEach()` 方法来指定每个测试执行前应该发生什么。由于每个测试都从零数据开始，我们首先必须确保Cypress导航到我们应用程序的 `http://localhost:4200`
    **统一资源定位符** (**URL**)。我们之所以只指定 `cy.visit('/')` 并且它仍然有效，是因为我们已经在 `cypress.json`
    文件中指定了 `baseUrl` 属性。因此，在我们的测试中只需提供相对URL。
- en: Finally, we use the `it()` method to specify the titles for our first test,
    and then we use the `cy.title()` method, which is a handy helper, to fetch the
    text value of the **Title** of our **HyperText Markup Language** (**HTML**) page
    currently being rendered. We use the `'eq'` operator to check its value against
    the `'Writing your first Cypress test'` string, and it all works!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `it()` 方法来指定我们第一个测试的标题，然后我们使用 `cy.title()` 方法，这是一个方便的辅助工具，来获取当前正在呈现的**超文本标记语言**
    (**HTML**)页面的**标题**的文本值。我们使用 `'eq'` 运算符来将其值与 `'编写你的第一个Cypress测试'` 字符串进行比较，一切正常！
- en: See also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`cy.title()` documentation ([https://docs.cypress.io/api/commands/title.html#Syntax](https://docs.cypress.io/api/commands/title.html#Syntax))'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cy.title()` 文档 ([https://docs.cypress.io/api/commands/title.html#Syntax](https://docs.cypress.io/api/commands/title.html#Syntax))'
- en: Cypress documentation—*Writing Your First Test* ([https://docs.cypress.io/guides/getting-started/writing-your-first-test.html](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html))
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress文档—*编写你的第一个测试* ([https://docs.cypress.io/guides/getting-started/writing-your-first-test.html](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html))
- en: Validating if a DOM element is visible on the view
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证DOM元素在视图上是否可见
- en: In the previous recipe, we learned how to install and configure Cypress in an
    Angular app. There might be different cases in your application where you'd want
    to see if an element is visible on the DOM or not. In this recipe, we'll write
    some tests to identify if any elements are visible on the DOM.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何在Angular应用程序中安装和配置Cypress。在您的应用程序中可能有不同的情况，您想要查看DOM上的元素是否可见。在这个示例中，我们将编写一些测试来确定DOM上是否有任何元素可见。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides `in chapter11/start_here/cypress-dom-element-visibility`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的项目位于 `chapter11/start_here/cypress-dom-element-visibility`：
- en: Open the project in VS Code.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `npm run cypress:test`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `npm run cypress:test`。
- en: 'This should run the app at `https://localhost:4200` and should open the Cypress
    window, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在`https://localhost:4200`上运行应用程序，并应该打开Cypress窗口，如下所示：
- en: '![Figure 11.4 – Cypress tests running for the cypress-dom-element-visibility
    app'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4–Cypress测试运行cypress-dom-element-visibility应用程序'
- en: '](image/Figure_11.4_B15150.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.4_B15150.jpg)'
- en: Figure 11.4 – Cypress tests running for the cypress-dom-element-visibility app
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4–Cypress测试运行cypress-dom-element-visibility应用程序
- en: Now that we have the app and the Cypress tests running locally, let's see the
    steps of the recipe in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序和Cypress测试，让我们在下一节中看到食谱的步骤。
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have the same old counter app from the previous recipe. However, some things
    have changed. We now have a button at the top that toggles the visibility of the
    the counter component `(CounterComponent)`. Also, we have to hover over the counter
    card to actually see the **Increment**, **Decrement**, and **Reset** action buttons.
    Let''s start writing some tests to check the visibility of the the counter component
    `(CounterComponent)` and for the actions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有与上一个食谱相同的旧计数器应用程序。但是，有些事情已经改变。现在我们在顶部有一个按钮，可以切换计数器组件`(CounterComponent)`的可见性。此外，我们必须悬停在计数器卡上才能看到**增加**、**减少**和**重置**操作按钮。让我们开始编写一些测试来检查计数器组件`(CounterComponent)`的可见性和操作：
- en: 'Let''s write a test to check the visibility of the the counter component `(CounterComponent)`
    when we have clicked the **Toggle Counter Visibility** button to show it. We''ll
    check it by asserting the visibility of the elements having `.counter__heading`
    and `.counter` classes. Update the `cypress/integration/app.spec.js` file, as
    follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个测试，检查当我们点击**切换计数器可见性**按钮以显示它时，计数器组件`(CounterComponent)`的可见性。我们将通过断言具有`.counter__heading`和`.counter`类的元素的可见性来检查它。更新`cypress/integration/app.spec.js`文件，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we''ll write a test to check if our action buttons (**Increment**, **Decrement**,
    and **Reset**) show up when we hover over the `counter` component. Update the
    `app.spec.js` file, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个测试，检查当我们悬停在`counter`组件上时，我们的操作按钮（**增加**、**减少**和**重置**）是否显示出来。更新`app.spec.js`文件，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you look at the Cypress window now, you should see the test failing, as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看Cypress窗口，您应该看到测试失败，如下所示：
- en: '![Figure 11.5 – Unable to get action buttons on hovering'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5–悬停时无法获取操作按钮'
- en: '](image/Figure_11.5_B15150.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.5_B15150.jpg)'
- en: Figure 11.5 – Unable to get action buttons on hovering
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5–悬停时无法获取操作按钮
- en: The reason for the test's failure is that Cypress doesn't currently provide
    a **Cascading Style Sheets** (**CSS**) hover effect. In order to work around this,
    we'll install a package in the next step.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败的原因是Cypress目前不提供**层叠样式表**（**CSS**）悬停效果。为了解决这个问题，我们将在下一步中安装一个包。
- en: 'Stop the running Cypress and Angular app and then install the `cypress-real-events`
    package, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止运行Cypress和Angular应用程序，然后安装`cypress-real-events`包，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, open the `cypress/support/index.js` file and update it, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`cypress/support/index.js`文件并更新如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, update the `app.spec.js` file to use the `.realHover()` method from the
    package on the `.counter` element, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`app.spec.js`文件，使用包中的`.realHover()`方法在`.counter`元素上，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the `cypress:test` command again using `npm run cypress:test`. Once
    the app is running and the Cypress window is opened, you should see all the tests
    passing, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行`cypress:test`命令，使用`npm run cypress:test`。一旦应用程序运行并且Cypress窗口打开，您应该看到所有测试都通过了，如下所示：
- en: '![Figure 11.6 – All tests passing after using the cypress-real-events package'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6–使用cypress-real-events包后所有测试都通过'
- en: '](image/Figure_11.6_B15150.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.6_B15150.jpg)'
- en: Figure 11.6 – All tests passing after using the cypress-real-events package
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - 使用cypress-real-events包后所有测试都通过
- en: Awesomesauce! You've just learned how to check the visibility of DOM elements
    in different scenarios. These are, of course, not the only options available to
    identify and interact with DOM elements. Now that you've finished the recipe,
    see the next section to understand how it works.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了如何在不同场景下检查DOM元素的可见性。当然，这些不是唯一可用的标识和与DOM元素交互的选项。现在您已经完成了这个配方，请查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: At the beginning of the recipe, in our first test we use the `.should('have.length',
    0)` assertion. When we use the `'have.length'` assertion, Cypress checks the `length`
    property of the DOM elements found using the `cy.get()` method. Another assertion
    that we use is `.should('be.visible')`, which checks if an element is visible
    on the DOM. This assertion will pass as long as the element is visible on the
    screen—that is, none of the parent elements are hidden.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方的开头，在我们的第一个测试中，我们使用`.should('have.length', 0)`断言。当我们使用`'have.length'`断言时，Cypress会检查使用`cy.get()`方法找到的DOM元素的`length`属性。我们使用的另一个断言是`.should('be.visible')`，它检查元素在DOM上是否可见。只要元素在屏幕上可见，这个断言就会通过，也就是说，父元素中没有隐藏的元素。
- en: In the later test, we try to hover over the element with the `'.counter'` selector,
    using `cy.get('.counter').trigger('mouseover');`. This fails our test. Why? Because
    all the hover workarounds in Cypress eventually lead to triggering the JavaScript
    events and not affecting the CSS pseudo selectors, and since we have our action
    buttons (with the `'.counter__actions__action'` selector) shown on the `:hover`
    (CSS) of the element with the `'.counter'` selector, our tests fail because in
    the tests our action buttons are not actually shown. To tackle the issue, we use
    the `cypress-real-events` package, which has the `.realHover()` method that affects
    the pseudo selectors and eventually shows our action buttons.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的测试中，我们尝试悬停在具有`'.counter'`选择器的元素上，使用`cy.get('.counter').trigger('mouseover');`。这导致我们的测试失败。为什么？因为Cypress中的所有悬停解决方法最终都会触发JavaScript事件，而不会影响CSS伪选择器，而且由于我们的操作按钮（使用`'.counter__actions__action'`选择器）显示在具有`'.counter'`选择器的元素的`:hover`（CSS）上，我们的测试失败，因为在测试中我们的操作按钮实际上没有显示。为了解决这个问题，我们使用`cypress-real-events`包，它具有`.realHover()`方法，可以影响伪选择器，并最终显示我们的操作按钮。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Cypress official documentation on the visibility of items ([https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility](https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility))
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress官方关于项目可见性的文档（[https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility](https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility)）
- en: '`cypress-real-events` project repository ([https://github.com/dmtrKovalenko/cypress-real-events](https://github.com/dmtrKovalenko/cypress-real-events))'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cypress-real-events` 项目存储库（[https://github.com/dmtrKovalenko/cypress-real-events](https://github.com/dmtrKovalenko/cypress-real-events)）'
- en: Testing form inputs and submission
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试表单输入和提交
- en: If you're building a web app, there's a high chance that you're going to have
    at least one form in it, and when it comes to forms we need to make sure that
    we have the right **user experience** (**UX**) and the right business logic in
    place. What better way to make sure everything works as expected than writing
    E2E tests for them? In this recipe, we're going to test a login form using Cypress.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建Web应用程序，很有可能您的应用程序中至少会有一个表单，当涉及到表单时，我们需要确保我们有正确的**用户体验**（**UX**）和正确的业务逻辑。有什么比编写E2E测试来确保一切都按预期工作更好的方法呢？在这个配方中，我们将使用Cypress测试登录表单。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'The project for this recipe resides in `chapter11/start_here/cy-testing-forms`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的项目位于`chapter11/start_here/cy-testing-forms`中：
- en: Open the project in VS Code.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `npm run cypress:test`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`npm run cypress:test`。
- en: 'This should open a new Cypress window. Tap the `app.spec.ts` file and you should
    see the tests, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的Cypress窗口。点击`app.spec.ts`文件，你应该看到测试，如下所示：
- en: '![Figure 11.7 – Cypress tests running for the app cy-testing-forms'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - Cypress测试正在运行cy-testing-forms应用程序'
- en: '](image/Figure_11.7_B15150.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.7_B15150.jpg)'
- en: Figure 11.7 – Cypress tests running for the app cy-testing-forms
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - Cypress测试正在运行cy-testing-forms应用程序
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了Cypress测试，让我们在下一节看看这个步骤的详细过程。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have to make sure that we see a **Success** alert when the form is successfully
    submitted. We also need to make sure that we see relevant errors if any of the
    inputs have an invalid value. Let''s get started:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保当表单成功提交时，我们会看到一个**成功**提示。如果任何输入值无效，我们还需要确保我们看到相关的错误。让我们开始吧：
- en: Let's create a new file inside the `cypress/integration` folder, named `login.spec.js`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`cypress/integration`文件夹中创建一个名为`login.spec.js`的新文件。
- en: 'We''ll first make sure that our form cannot be submitted unless we have valid
    form inputs. To do that, let''s make sure that the **Submit** button is disabled
    when there are either no input values or invalid values. Open the `login.spec.js`
    file and add a test, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们要确保除非我们有有效的表单输入，否则我们的表单不能被提交。为了做到这一点，让我们确保当没有输入值或无效值时，**提交**按钮被禁用。打开`login.spec.js`文件并添加一个测试，如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, open the `login.spec.js` file in the Cypress window and you should see
    the tests passing, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Cypress窗口中打开`login.spec.js`文件，你应该看到测试都通过了，如下所示：
- en: '![Figure 11.8 – Checking if the Submit button is disabled when there is invalid
    input'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 - 检查当输入无效时提交按钮是否被禁用'
- en: '](image/Figure_11.8_B15150.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.8_B15150.jpg)'
- en: Figure 11.8 – Checking if the Submit button is disabled when there is invalid
    input
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 检查当输入无效时提交按钮是否被禁用
- en: 'Let''s add another test that validates that we see a success alert on submitting
    the right values for the inputs. Add another test in the `login.spec.js` file,
    as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试，验证当输入正确的值时，我们会看到一个成功提示。在`login.spec.js`文件中添加另一个测试，如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll add another test now to make sure the success alert hides on tapping
    the **Close** button. Since we''re using the same logic/code for the successful
    login, we''ll create a function to reuse it. Let''s modify the `login.spec.js`
    file, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加另一个测试，以确保成功提示在点击**关闭**按钮时隐藏。由于我们在成功登录时使用相同的逻辑/代码，我们将创建一个函数来重用它。让我们修改`login.spec.js`文件，如下所示：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The success alert should also hide when the input changes. To check that as
    well, let''s add another test, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功提示在输入更改时也应该隐藏。为了检查这一点，让我们添加另一个测试，如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, let''s write a test to make sure we show error messages on invalid
    inputs. Add another test in the `logic.spec.js` file, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们编写一个测试，确保我们在输入无效时显示错误消息。在`logic.spec.js`文件中添加另一个测试，如下所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you look at the **Tests** window now, you should see all the tests passing,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看**测试**窗口，你应该看到所有的测试都通过了，如下所示：
- en: '![Figure 11.9 – All tests passing for the Login page'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9 - 登录页面的所有测试都通过了'
- en: '](image/Figure_11.9_B15150.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.9_B15150.jpg)'
- en: Figure 11.9 – All tests passing for the Login page
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 登录页面的所有测试都通过了
- en: Awesome! You now know how to use Cypress to test forms with some interesting
    use cases and assertions. See the next section to understand how it all works.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何使用Cypress来测试一些有趣的用例和断言。查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Since our app''s logic has a rule that the **Submit** button should be disabled
    until both the email and password inputs have valid values, we check if the button
    is disabled in our tests. We do this by using the `''be.disabled''` assertion
    on the **Submit** button, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们应用程序的逻辑规定**提交**按钮在电子邮件和密码输入都有有效值之前应该被禁用，我们在测试中检查按钮是否被禁用。我们通过在**提交**按钮上使用`'be.disabled'`断言来实现这一点，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We then use`.type()` method chaining on the `cy.get()` selector to type in both
    inputs one by one, and check if the button is disabled either when we have an
    invalid value for any input or no value entered at all.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`cy.get()`选择器上使用`.type()`方法链来依次输入两个输入，并在任何输入无效值或根本没有输入时检查按钮是否被禁用。
- en: 'To perform a successful login, we execute the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 执行成功的登录，我们执行以下代码：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we get each input and type valid values in them, and then we call
    the `.click()` method on the **Submit** button. We then check if the success alert
    exists using the `'.alert.alert-success'` selector and the `should('be.visible')`
    assertion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们获取每个输入并在其中输入有效值，然后在**提交**按钮上调用`.click()`方法。然后，我们使用`'.alert.alert-success'`选择器和`should('be.visible')`断言来检查成功提示是否存在。
- en: 'In cases where we want to check that the success alert has been dismissed on
    clicking the **Close** button on the alert or when any of the inputs change, we
    can''t just use the `should(''not.be.visible'')` assertion. This is because Cypress
    in this case would expect the alert to be in the DOM but just not be visible,
    whereas in our case (in our Angular app), the element doesn''t even exist in the
    DOM, so Cypress fails to get it. Therefore, we use the following code to check
    that the success alert doesn''t even exist:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要检查成功提示在单击警报上的**关闭**按钮或任何输入更改时是否已被解除时，我们不能只使用`should('not.be.visible')`断言。这是因为在这种情况下，Cypress会期望警报在DOM中，但只是不可见，而在我们的情况下（在我们的Angular应用程序中），元素甚至不存在在DOM中，因此Cypress无法获取它。因此，我们使用以下代码来检查成功提示甚至不存在：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One final interesting thing is when we want to check if error messages for
    each input show when we type something in either of the inputs and clear the input.
    In this case, we use the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有趣的事情是当我们想要检查每个输入的错误消息是否在我们在任一输入中输入内容并清除输入时显示。在这种情况下，我们使用以下代码：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason we use the `.blur()` method is because when Cypress just clears the
    input the Angular change detection doesn't take place, which results in the error
    messages not showing on the view immediately. Since Angular's change detection
    does monkey-patching on the browser events, we trigger a `.blur()` event on both
    the inputs to trigger the change detection mechanism. As a result, our error messages
    show properly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`.blur()`方法的原因是因为当Cypress只清除输入时，Angular的变化检测不会立即发生，这导致错误消息不会立即显示在视图上。由于Angular的变化检测对浏览器事件进行了monkey-patching，我们在两个输入上触发`.blur()`事件来触发变化检测机制。结果，我们的错误消息会正确显示。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Cypress recipes: Form interactions ([https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions))'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cypress recipes: Form interactions ([https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions))'
- en: 'Cypress recipes: Login form ([https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms))'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cypress recipes: Login form ([https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms))'
- en: Waiting for XHRs to finish
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待XHR完成
- en: Testing **user interface** (**UI**) transitions is the essence of E2E testing.
    While it is important to test the predicted outcome of an action right away, there
    might be cases where the outcome actually has a dependency. For instance, if a
    user fills out the **Login** form, we can't show the success toast until we have
    a successful response from the backend server, hence we can't test whether the
    success toast is shown right away. In this recipe, you're going to learn how to
    wait for a specific XHR call to be completed before performing an assertion.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用户界面（UI）转换是E2E测试的本质。虽然测试立即预测结果的重要性很高，但实际上可能存在结果有依赖性的情况。例如，如果用户填写了登录表单，我们只有在从后端服务器成功收到响应后才能显示成功的提示，因此我们无法立即测试成功提示是否显示。在这个配方中，您将学习如何等待特定的XHR调用完成后再执行断言。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project for this recipe resides in `chapter11/start_here/waiting-for-xhr`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的配方项目位于`chapter11/start_here/waiting-for-xhr`。
- en: Open the project in VS Code.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `npm run cypress:test`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`npm run cypress:test`。
- en: 'This should open a new Cypress window. Tap the `user.spec.ts` file and you
    should see the tests, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的Cypress窗口。点击`user.spec.ts`文件，您应该会看到测试，如下所示：
- en: '![Figure 11.10 – Cypress tests running for the waiting-for-xhr app'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10 - Cypress测试正在运行等待XHR应用程序'
- en: '](image/Figure_11.10_B15150.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.10_B15150.jpg)'
- en: Figure 11.10 – Cypress tests running for the waiting-for-xhr app
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 - Cypress测试正在运行等待XHR应用程序
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让Cypress测试运行起来了，让我们在下一节中看看这个配方的步骤。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'All the tests right now work fine, even though we have XHR calls involved in
    getting the data. So, what is this recipe about exactly? Well, Cypress has a timeout
    of 4,000 **milliseconds** (**ms**) (4 seconds), during which it tries the assertion
    again and again until the assertion passes. What if our XHR takes more than 4,000
    ms? Let''s try it out in the recipe:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的测试都很好，即使我们涉及XHR调用来获取数据。那么，这个配方到底是关于什么的呢？嗯，Cypress在4,000毫秒（4秒）的时间内尝试断言，直到断言通过。如果我们的XHR花费超过4,000毫秒呢？让我们在这个配方中试一试：
- en: 'First of all, we need to simulate the scenario where the desired result occurs
    after 4,000 ms. We''ll use the `debounceTime` operator from `rxjs` for this, with
    a delay of 5,000 ms. Let''s apply it on the `valueChanges` Observable of the `searchForm`
    property in the `users.component.ts` file, as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要模拟期望结果在4,000毫秒后发生的情况。我们将使用`rxjs`中的`debounceTime`操作符，延迟为5,000毫秒。让我们将其应用于`users.component.ts`文件中`searchForm`属性的`valueChanges`
    Observable，如下所示：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you now check the Cypress tests, you should see a test failing, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在检查Cypress测试，您应该会看到一个测试失败，如下所示：
- en: '![Figure 11.11 – Assertion failing for the test for searching a particular
    user'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 - 测试搜索特定用户失败'
- en: '](image/Figure_11.11_B15150.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.11_B15150.jpg)'
- en: Figure 11.11 – Assertion failing for the test for searching a particular user
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 - 测试搜索特定用户失败
- en: 'We can now try to fix this, so it doesn''t matter how long the XHR takes—we''ll
    always wait for it to be completed before doing an assertion. Let''s intercept
    the XHR call and create an alias for it so that we can use it later to wait for
    the XHR call. Update the `users.spec.js` file, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试修复这个问题，这样无论XHR花费多长时间，我们都会等待它完成后再进行断言。让我们拦截XHR调用并为其创建一个别名，以便稍后使用它来等待XHR调用。更新`users.spec.js`文件，如下所示：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s use the alias to wait for the XHR call to complete before the assertion.
    Update the `users.spec.js` file, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用别名在断言之前等待XHR调用完成。更新`users.spec.js`文件，如下所示：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you check the Cypress tests now for `user.spec.js`, you should see all of
    them pass, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在检查`user.spec.js`的Cypress测试，你应该看到它们都通过了，如下所示：
- en: '![Figure 11.12 – Test waiting for the XHR call to be completed before the assertion'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12 – 测试等待XHR调用完成后进行断言'
- en: '](image/Figure_11.12_B15150.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.12_B15150.jpg)'
- en: Figure 11.12 – Test waiting for the XHR call to be completed before the assertion
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 测试等待XHR调用完成后进行断言
- en: Great!! You now know how to implement E2E tests with Cypress that include waiting
    for a particular XHR call to finish before an assertion. To understand all the
    magic behind the recipe, see the next section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何使用Cypress实现包括等待特定XHR调用完成在断言之前的E2E测试。要了解配方背后的所有魔力，请参阅下一节。
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the recipe, we use something called variable aliasing. We first use the `cy.intercept()`
    method so that Cypress can listen to the network call. Note that we use a wildcard
    for the URL by using `https://api.randomuser.me/*` as the parameter, and then
    we use a `.as('searchUsers')` statement to give an alias for this interception.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了一种叫做变量别名的东西。我们首先使用`cy.intercept()`方法，这样Cypress就可以监听网络调用。请注意，我们在参数中使用通配符作为URL，使用`https://api.randomuser.me/*`，然后我们使用`.as('searchUsers')`语句为这个拦截设置一个别名。
- en: Then, we use the `cy.wait('@searchUsers');` statement, using the `searchUsers`
    alias to inform Cypress that it has to wait until the aliased interception happens—that
    is, until the network call is made, regardless of how long it takes. This makes
    our tests pass, even though the regular 4,000 ms Cypress timeout has already passed
    before actually getting the network call. Magic, isn't it?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`cy.wait('@searchUsers');`语句，使用`searchUsers`别名告诉Cypress它必须等待直到别名的拦截发生——也就是说，直到网络调用被发出，无论需要多长时间。这使我们的测试通过，即使在实际获取网络调用之前，常规的4,000毫秒Cypress超时已经过去。神奇，不是吗？
- en: Well, I hope you liked this recipe—see the next section to view a link for further
    reading.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，希望你喜欢这个配方——查看下一节以查看进一步阅读的链接。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Waiting in Cypress ([https://docs.cypress.io/guides/guides/network-requests#Waiting](https://docs.cypress.io/guides/guides/network-requests#Waiting))
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Cypress中等待([https://docs.cypress.io/guides/guides/network-requests#Waiting](https://docs.cypress.io/guides/guides/network-requests#Waiting))
- en: Using Cypress bundled packages
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cypress捆绑包
- en: Cypress provides a bunch of bundled tools and packages that we can use in our
    tests to make things easier, not because writing tests with Cypress is otherwise
    hard, but because these libraries are used by many developers already and so they're
    familiar with them. In this recipe, we're going to look at the bundled `jQuery,
    Lodash, and Minimatch` libraries to test some of our use cases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress提供了一堆捆绑工具和包，我们可以在测试中使用它们来简化事情，不是因为使用Cypress编写测试本来就很难，而是因为这些库已经被许多开发人员使用，所以他们对它们很熟悉。在这个配方中，我们将看看捆绑的`jQuery、Lodash和Minimatch`库，以测试一些我们的用例。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter11/start_here/using-cypress-bundled-packages`,
    inside the cloned repository:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于`chapter11/start_here/using-cypress-bundled-packages`，在克隆的存储库中：
- en: Open the project in VS Code.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `npm run cypress:test`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`npm run cypress:test`。
- en: 'This should open a new Cypress window. Tap the `users.spec.ts` file and you
    should see the tests, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该打开一个新的Cypress窗口。点击`users.spec.ts`文件，你应该看到测试，如下所示：
- en: '![Figure 11.13 – using-cypress-bundled-packages tests running with Cypress'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13 - 使用Cypress捆绑包运行的测试'
- en: '](image/Figure_11.13_B15150.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.13_B15150.jpg)'
- en: Figure 11.13 – using-cypress-bundled-packages tests running with Cypress
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 - 使用Cypress捆绑包运行的测试
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Cypress测试运行，让我们在下一节中看看这个示例的步骤。
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, we have the `users` list and a search app that fetches some
    users from an **application programming interface** (**API**) endpoint. We''re
    going to assert a few conditions for the DOM, validate the response from the API,
    and will assert the URL changes as well. Let''s get started:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们有`users`列表和一个从**应用程序编程接口**（**API**）端点获取一些用户的搜索应用。我们将对DOM进行一些条件断言，验证API的响应，并且还会断言URL的变化。让我们开始吧：
- en: 'First of all, we''ll try out the bundled `jQuery` library along with Cypress.
    We can access this using `Cypress.$`. Let''s add another test and log out some
    DOM elements. Update the `users.spec.js` file, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将尝试使用捆绑的`jQuery`库以及Cypress。我们可以使用`Cypress.$`来访问它。让我们添加另一个测试并记录一些DOM元素。更新`users.spec.js`文件，如下所示：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you look at the tests now and specifically the console, you should see the
    log, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在看测试，特别是控制台，你应该会看到以下日志：
- en: '![Figure 11.14 – Search button logged using jQuery via Cypress.$'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14 - 使用jQuery通过Cypress.$记录的搜索按钮'
- en: '](image/Figure_11.14_B15150.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.14_B15150.jpg)'
- en: Figure 11.14 – Search button logged using jQuery via Cypress.$
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 - 使用jQuery通过Cypress.$记录的搜索按钮
- en: 'Now, let''s try to log the user cards that we see after the HTTP call. Add
    another query and log in to the same test, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试记录在HTTP调用之后看到的用户卡。添加另一个查询和登录到相同的测试中，如下所示：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you see the test and the logs again on the console in the Cypress window,
    you will see that the `Cypress.$('app-user-card')` query doesn't return any DOM
    elements. This is because when the query is run, the HTTP call isn't completed.
    So, should we wait for the HTTP call to finish? Let's try that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次在Cypress窗口的测试和日志中看到，你会发现`Cypress.$('app-user-card')`查询不会返回任何DOM元素。这是因为当运行查询时，HTTP调用尚未完成。那么，我们应该等待HTTP调用完成吗？让我们试试看。
- en: 'Let''s add a `cy.wait(5000)` to wait for 5 seconds, during which the HTTP call
    should have been completed, and let''s put an assertion with the `cy.wrap()` method
    as well to check that the **Search** button is disabled when there''s no value
    provided for the search input. Update the test, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个`cy.wait(5000)`来等待5秒，期间HTTP调用应该已经完成，并且让我们使用`cy.wrap()`方法进行断言，检查当搜索输入没有提供值时**搜索**按钮是否被禁用。更新测试，如下所示：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you see the Cypress test and the console, you will see that we still get
    no DOM elements for the `<app-user-card>` elements:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到Cypress测试和控制台，你会发现我们仍然没有得到`<app-user-card>`元素的DOM元素：
- en: '![Figure 11.15 – No user cards found using Cypress.$ even after using cy.wait
    (5000)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.15 - 即使使用cy.wait（5000）也找不到使用Cypress.$的用户卡'
- en: '](image/Figure_11.15_B15150.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.15_B15150.jpg)'
- en: Figure 11.15 – No user cards found using Cypress.$ even after using cy.wait
    (5000)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 - 即使使用cy.wait（5000）也找不到使用Cypress.$的用户卡
- en: We'll discuss in the *How it works…* section why this happens. For now, understand
    that you should only use `Cypress.$` for elements that are present in the DOM
    right from when the page is loaded.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*它是如何工作的...*部分讨论为什么会发生这种情况。现在，了解你应该只对从页面加载时就存在于DOM中的元素使用`Cypress.$`。
- en: 'Let''s clean up our test by removing the `cy.wait()` method and the console
    logs. It should then look like this:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过删除`cy.wait()`方法和控制台日志来清理我们的测试。然后它应该看起来像这样：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll now add a test to verify that we get the same users from the Random
    User API for the same seed string. We already have the `API_USERS.js` file that
    contains the expected result. Let''s use the bundled `lodash` library in our next
    test to assert the matching values for the first name, the last name, and the
    email of the returned users, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加一个测试来验证，对于相同的种子字符串，我们从随机用户API中获取相同的用户。我们已经有了包含预期结果的`API_USERS.js`文件。让我们在下一个测试中使用捆绑的`lodash`库来断言返回用户的名字、姓氏和电子邮件的匹配值，如下所示：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you see the test now in Cypress, it should be passing, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在Cypress中看到测试，它应该通过，如下所示：
- en: '![Figure 11.16 – Test passing with the usage of lodash via Cypress'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16 – 使用lodash通过Cypress进行测试通过'
- en: '](image/Figure_11.16_B15150.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.16_B15150.jpg)'
- en: Figure 11.16 – Test passing with the usage of lodash via Cypress
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 使用lodash通过Cypress进行测试通过
- en: 'We''re now going to use the `moment.js` package that is bundled with Cypress
    as well. Let''s assert that the user cards show the formatted date correctly,
    using `moment.js`. Write another test in the `users.spec.js` file, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用Cypress捆绑的`moment.js`包。让我们断言用户卡片正确显示格式化的日期，使用`moment.js`。在`users.spec.js`文件中编写另一个测试，如下所示：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next package we''ll explore is the `minimatch` package. When we tap on
    a user card, it opens the user details. Since we append a timestamp to the URL
    as a query parameter, we can''t compare the URL as an exact match with our assertion.
    Let''s use the `minimatch` package to assert using a pattern instead. Add a new
    test, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将探索的包是`minimatch`包。当我们点击用户卡片时，它会打开用户详细信息。由于我们将时间戳作为查询参数附加到URL上，我们无法将URL作为精确匹配与我们的断言进行比较。让我们使用`minimatch`包来使用模式进行断言。添加一个新的测试，如下所示：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And boom! We now have all the tests passing using the bundled packages with
    Cypress. Now that we've finished the recipe, let's see in the next section how
    it all works.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！现在我们使用Cypress捆绑的包都通过了所有的测试。既然我们已经完成了这个方法，让我们在下一节看看它是如何工作的。
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Cypress bundles `jQuery` with it and we use it via the `Cypress.$` property.
    This allows us to perform everything that the `jQuery` function permits us to.
    It automatically checks which page is in the view using the `cy.visit()` method,
    and then queries the document using the provided selector.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress将`jQuery`与其捆绑在一起，我们通过`Cypress.$`属性使用它。这使我们能够执行`jQuery`函数允许我们执行的一切。它使用`cy.visit()`方法自动检查视图中的哪个页面，然后使用提供的选择器查询文档。
- en: Important note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`Cypress.$` can only fetch from the document elements that are available immediately
    on the DOM. This is great for debugging the DOM using the Chrome DevTools in the
    Cypress test window. However, it is important to understand that it doesn''t have
    any context about the Angular change detection. Also, you can''t query any element
    that isn''t visible on the page right from the beginning, as we experienced following
    the recipe—that is, it doesn''t respect waiting for XHR calls for the elements
    to be visible.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cypress.$`只能从DOM上立即可用的文档元素中获取。这对于在Cypress测试窗口中使用Chrome DevTools调试DOM非常有用。然而，重要的是要理解它对Angular变化检测没有任何上下文。此外，你不能查询任何在页面上一开始就不可见的元素，就像我们在遵循该方法时所经历的那样——它不会等待XHR调用使元素可见。'
- en: 'Cypress also bundles `lodash` and exposes it via the `Cypress._` object. In
    the recipe, we use the `_.get()` method to get the nested properties from the
    `user` object. The `_.get()` method takes two parameters: the object, and a string
    that reflects the path for the properties—for example, we use `_.get(response,
    ''body.results'');`, which essentially returns a value for `response.body.results`.
    We also use the `_.each()` method to iterate over the arrays in the recipe. Note
    that we can use any `lodash` method in our Cypress test and not just the aforementioned
    methods.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress还捆绑了`lodash`并通过`Cypress._`对象公开它。在本教程中，我们使用`_.get()`方法从`user`对象中获取嵌套属性。`_.get()`方法接受两个参数：对象和反映属性路径的字符串，例如，我们使用`_.get(response,
    'body.results');`，它实质上返回`response.body.results`的值。我们还使用`_.each()`方法在本教程中迭代数组。请注意，我们可以在Cypress测试中使用任何`lodash`方法，而不仅仅是上述方法。
- en: We also used the `minimatch` package, which Cypress exposes via the `Cypress.minimatch`
    object. The `minimatch` package is great for matching and testing glob patterns
    against strings. We use it to test the URL after navigating to a user's detail
    page using a pattern.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了Cypress通过`Cypress.minimatch`对象公开的`minimatch`包。`minimatch`包非常适合与字符串匹配和测试glob模式。我们用它来测试导航到用户详细信息页面后的URL。
- en: Finally, we also use the `moment.js` package that Cypress exposes via the `Cypress.moment`
    object. We use it to make sure the date of birth of each user is shown in the
    expected format on the view. Easy peasy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还使用了Cypress通过`Cypress.moment`对象公开的`moment.js`包。我们用它来确保每个用户的出生日期在视图上显示为预期格式。非常简单。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Cypress bundled tools ([https://docs.cypress.io/guides/references/bundled-tools](https://docs.cypress.io/guides/references/bundled-tools))
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress捆绑工具([https://docs.cypress.io/guides/references/bundled-tools](https://docs.cypress.io/guides/references/bundled-tools))
- en: Moment.js ([https://momentjs.com/](https://momentjs.com/))
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moment.js ([https://momentjs.com/](https://momentjs.com/))
- en: jQuery ([https://jquery.com/](https://jquery.com/))
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery ([https://jquery.com/](https://jquery.com/))
- en: lodash ([https://lodash.com](https://lodash.com))
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lodash ([https://lodash.com](https://lodash.com))
- en: Minimatch.js ([https://github.com/isaacs/minimatch](https://github.com/isaacs/minimatch))
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minimatch.js ([https://github.com/isaacs/minimatch](https://github.com/isaacs/minimatch))
- en: Using Cypress fixtures to provide mock data
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cypress fixtures提供模拟数据
- en: When it comes to writing E2E tests, fixtures play a great role in making sure
    the tests are not flaky. Consider that your tests rely on fetching data from your
    API server or your tests include snapshot testing, which includes fetching images
    from a **content delivery network** (**CDN**) or a third-party API. Although they're
    technically required for the tests to run successfully, it is not important that
    the server data and the images are fetched from the original source, therefore
    we can create fixtures for them. In this recipe, we'll create fixtures for the
    users' data as well as for the images to be shown on the UI.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写端到端测试时，fixtures在确保测试不会出现问题方面发挥了重要作用。考虑到您的测试依赖于从API服务器获取数据，或者您的测试包括快照测试，其中包括从内容交付网络（CDN）或第三方API获取图像。尽管它们在技术上是测试成功运行所必需的，但重要的是服务器数据和图像不是从原始来源获取的，因此我们可以为它们创建fixtures。在本教程中，我们将为用户数据以及要在UI上显示的图像创建fixtures。
- en: Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter11/start_here/using-cypress-fixtures`,
    inside the cloned repository:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的`chapter11/start_here/using-cypress-fixtures`中：
- en: Open the project in VS Code.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `npm run cypress:test`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`npm run cypress:test`。
- en: 'This should open a new Cypress window. Tap the `users.spec.ts` file and you
    should see the tests, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个新的Cypress窗口。点击`users.spec.ts`文件，你应该会看到测试，如下所示：
- en: '![Figure 11.17 – using-cypress-fixtures tests running with Cypress'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17 - 使用Cypress fixtures测试在Cypress中运行'
- en: '](image/Figure_11.17_B15150.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.17_B15150.jpg)'
- en: Figure 11.17 – using-cypress-fixtures tests running with Cypress
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 - 使用Cypress fixtures测试在Cypress中运行
- en: Now that we have the Cypress tests running, let's see the steps of the recipe
    in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让Cypress测试运行了，让我们在下一节中看看这个示例的步骤。
- en: How to do it…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have the same Angular application as in the previous recipe. However, we''ll
    now use Cypress fixtures to provide fixtures for our data and images. Let''s get
    started:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有与上一个示例中相同的Angular应用程序。但是，我们现在将使用Cypress fixtures来提供我们的数据和图像fixture。让我们开始吧：
- en: 'We''ll first create a fixture for our HTTP call to the `randomuser.me` API.
    Create a new file under the `cypress/fixtures` folder, named `users.json`. Then,
    copy the code from the c`hapter11/final/using-cypress-fixtures/cypress/fixtures/users.json`
    file and paste it into the newly created file. It should look like this:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先为我们对`randomuser.me` API的HTTP调用创建一个fixture。在`cypress/fixtures`文件夹下创建一个名为`users.json`的新文件。然后，将代码从`chapter11/final/using-cypress-fixtures/cypress/fixtures/users.json`文件复制并粘贴到新创建的文件中。它应该看起来像这样：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s use the fixture in our `users.spec.js` file. We''ll use it in the
    `beforeEach()` life cycle hook since we want to use the fixture for all the tests
    in the file. This means we''ll also remove the existing usage of the `cy.intercept()`
    method in the file. Update the `users.spec.js` file, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`users.spec.js`文件中使用fixture。我们将在`beforeEach()`生命周期钩子中使用它，因为我们希望在文件中的所有测试中使用fixture。这意味着我们还将删除文件中现有的`cy.intercept()`方法的使用。更新`users.spec.js`文件，如下所示：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now need to remove the `constants/API_USERS.js` file from the project since
    we have the fixture now.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要从项目中删除`constants/API_USERS.js`文件，因为我们现在有了fixture。
- en: 'We''ll create a new variable in which we''ll store the value of the `users`
    array and will use it instead of the `API_USERS` array. Let''s modify the `users.spec.js`
    file further, as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新变量，其中我们将存储`users`数组的值，并将其用于替代`API_USERS`数组。让我们进一步修改`users.spec.js`文件，如下所示：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You''ll notice that all of our tests are still passing with the changes done.
    You can safely remove the `constants/API_USERS.js` file from the project now.
    Also, you can see the network calls in the Cypress **Tests** window to verify
    that we''re using the fixture instead of the actual API response, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，所有的测试都仍然通过了。您现在可以安全地从项目中删除`constants/API_USERS.js`文件。此外，您可以在Cypress **Tests**窗口中查看网络调用，以验证我们使用的是fixture而不是实际的API响应，如下所示：
- en: '![Figure 11.18 – Cypress tests using users.json fixture as XHR response'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.18 - Cypress测试使用users.json fixture作为XHR响应'
- en: '](image/Figure_11.18_B15150.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.18_B15150.jpg)'
- en: Figure 11.18 – Cypress tests using users.json fixture as XHR response
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 - Cypress测试使用users.json fixture作为XHR响应
- en: 'Now, let''s try to mock our images to load them from the disk instead of the
    `randomuser.me` API. For this, we already have the images stored in the `fixtures/images`
    folder. We just need to use them based on the URL for a particular user. To do
    so, modify the `users.spec.js` file, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试模拟我们的图像，从磁盘加载它们，而不是从`randomuser.me` API。为此，我们已经将图像存储在`fixtures/images`文件夹中。我们只需要根据特定用户的URL来使用它们。为此，请修改`users.spec.js`文件，如下所示：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you see the tests now, all of them should still be passing, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看测试，所有测试都应该仍然通过，如下所示：
- en: '![Figure 11.19 – All tests passing after using images fixtures'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19 - 使用图像fixture后所有测试都通过了'
- en: '](image/Figure_11.19_B15150.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.19_B15150.jpg)'
- en: Figure 11.19 – All tests passing after using images fixtures
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 - 使用图像fixture后所有测试都通过了
- en: 'Looking at the tests, you might be thinking: "*It all seems exactly as before,
    Ahsan. How do I know we''re mocking the images?*" Well, good question. We already
    have a way to test that.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 看着测试，你可能会想：“*这一切看起来和以前一样，阿赫桑。我怎么知道我们在模拟图像？*”好问题。我们已经有一种方法来测试这个。
- en: 'In the `cypress/fixtures/images` folder, we have a file named `9.jpg`, and
    another test file named `9_test.jpg`. Let''s modify the name of the `9.jpg` file
    to `9_original.jpg` and the `9_test.jpg` file to `9.jpg`. If you see the tests
    now, you should see a different result for the last test using the replaced file,
    as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cypress/fixtures/images`文件夹中，我们有一个名为`9.jpg`的文件，另一个测试文件名为`9_test.jpg`。让我们将`9.jpg`文件的名称修改为`9_original.jpg`，将`9_test.jpg`文件的名称修改为`9.jpg`。如果你现在看到测试，你应该会看到使用替换文件的最后一个测试的结果不同，如下所示：
- en: '![Figure 11.20 – Cypress tests using images from the fixture'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20 - 使用fixture中的图像进行Cypress测试'
- en: '](image/Figure_11.20_B15150.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.20_B15150.jpg)'
- en: Figure 11.20 – Cypress tests using images from the fixture
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 - 使用fixture中的图像进行Cypress测试
- en: Great!!! You now know how to use fixtures in Cypress E2E tests. Now that you've
    finished the recipe, see the next section on how this works.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何在Cypress E2E测试中使用fixtures了。现在你已经完成了这个教程，看看下一节关于它是如何工作的。
- en: How it works…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We use fixtures in a Cypress test using the `cy.fixture()` method, which allows
    us to use data from a file. In this recipe, we use fixtures for the HTTP call
    that gets the user data and for the images. But how does it work? Essentially,
    the `fixture` method has four overloads, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`cy.fixture()`方法在Cypress测试中使用fixtures，这允许我们使用文件中的数据。在这个教程中，我们使用fixtures来获取用户数据和图像的HTTP调用。但是它是如何工作的呢？实质上，`fixture`方法有四个重载，如下所示：
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `filePath` parameter takes a string as the file path relative to the `Fixture`
    folder, which defaults to the `cypress/fixture` path, although we can provide
    a different `Fixture` folder by defining a `fixturesFolder` property in the `cypress.json`
    configuration file. Notice that for the HTTP call, we use the `cy.fixture('users.json')`
    statement, which essentially points to the `cypress/fixture/users.json` file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`filePath`参数接受一个字符串作为相对于`Fixture`文件夹的文件路径，默认为`cypress/fixture`路径，尽管我们可以通过在`cypress.json`配置文件中定义`fixturesFolder`属性来提供不同的`Fixture`文件夹。请注意，对于HTTP调用，我们使用`cy.fixture(''users.json'')`语句，它实质上指向`cypress/fixture/users.json`文件。'
- en: First of all, we use the `cy.fixture('users.json')` method before the `cy.visit()`
    method to ensure that our immediate XHR call that triggers on launching the application
    uses the fixture. If you change the code otherwise, you'll see that it doesn't
    work as expected. We then use the `.then()` method to get hold of the data from
    the `users.json` file. Once we get the data (`response`) object, we use the `cy.intercept()`
    method using a Minimatch glob pattern to intercept the HTTP call to get the users'
    data, and we provide this `response` object from the fixture as the response for
    the HTTP call. As a result, all the calls made to the endpoint matching the `'`[https://api.randomuser.me/](https://api.randomuser.me/)*`'`
    glob use our fixture—that is, the `users.json` file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`cy.visit()`方法之前使用`cy.fixture('users.json')`方法，以确保我们在启动应用程序时触发的即时XHR调用使用fixture。如果你改变代码，你会发现它不会按预期工作。然后我们使用`.then()`方法来获取`users.json`文件中的数据。一旦我们得到数据（`response`对象），我们使用`cy.intercept()`方法使用Minimatch
    glob模式拦截HTTP调用以获取用户数据，并且我们将fixture中的`response`对象作为HTTP调用的响应。因此，所有对与`'`[https://api.randomuser.me/](https://api.randomuser.me/)*`'`
    glob匹配的端点的调用都使用我们的fixture，即`users.json`文件。
- en: We also do one more interesting thing in the recipe, and that is mocking the
    images to avoid fetching them from their original source. This is super-handy
    when you use a third-party API and you have to pay for each call made to the API.
    We already have the fixture images stored in the `cypress/fixture/images` folder.
    Therefore, we loop over the `API_USERS` array for each user and extract the filename
    (the `imageName` variable). We then intercept each HTTP call done to fetch the
    images and use the fixture image instead of the original resource in our tests.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们还做了一件有趣的事情，那就是模拟图片，以避免从原始来源获取它们。当你使用第三方API并且每次调用API都要付费时，这非常方便。我们已经将夹具图片存储在
    `cypress/fixture/images` 文件夹中。因此，我们循环遍历 `API_USERS` 数组中的每个用户，并提取文件名（`imageName`
    变量）。然后，我们拦截每个用于获取图片的HTTP调用，并在我们的测试中使用夹具图片代替原始资源。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Cypress fixtures documentation ([https://docs.cypress.io/api/commands/fixture](https://docs.cypress.io/api/commands/fixture))
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress 夹具文档（[https://docs.cypress.io/api/commands/fixture](https://docs.cypress.io/api/commands/fixture))
- en: '`cy.intercept()` method documentation ([https://docs.cypress.io/api/commands/intercept](https://docs.cypress.io/api/commands/intercept))'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cy.intercept()` 方法文档（[https://docs.cypress.io/api/commands/intercept](https://docs.cypress.io/api/commands/intercept)）'
