- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding React Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to this fundamental chapter of our React essentials guide! This chapter
    serves as a solid foundation for your journey into the exciting world of React
    development. We will delve into the fundamental concepts of React and provide
    you with the essential knowledge needed to kickstart your React projects with
    confidence.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how to think in components, a crucial mindset
    for building reusable and modular **user interfaces** (**UIs**). You will learn
    the art of breaking your application down into smaller, self-contained components,
    enabling you to create maintainable and scalable code bases. By understanding
    this fundamental concept, you will be equipped with the skills to architect robust
    and flexible React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will introduce you to the most commonly used Hooks in React,
    such as `useState`, `useEffect`, and more. These Hooks are powerful tools that
    allow you to manage state, handle side effects, and tap into React’s lifecycle
    methods within functional components. By mastering these Hooks, you will have
    the ability to create dynamic and interactive UIs effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be well prepared to explore more advanced
    topics and tackle real-world React challenges in the subsequent chapters of our
    guide. So, buckle up and get ready to embark on an exciting journey into the world
    of React.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static components in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating components with props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down UIs into components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing internal state in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the rendering process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring common React Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find it under [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch2).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static components in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React applications are built on components. A **component** can range from a
    simple function returning an HTML snippet to a more complex one that interacts
    with network requests, dynamically generates HTML tags, and even auto-refreshes
    based on backend service changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a basic scenario and define a **static component**. In React,
    a static component (also known as presentational components or dumb components)
    refers to a component that doesn’t have any state and doesn’t interact with the
    data or handle any events. It is a component that only renders the UI based on
    the props it receives. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This static component closely resembles the corresponding HTML snippet, which
    uses the `<article>` tag to structure content with a title and a paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While encapsulating static HTML in a component is useful, there may be a need
    for the component to represent different articles, not just a specific one. Just
    as we pass parameters to a function to make it more versatile, we can pass parameters
    into a component to make it useful in different contexts. That can be done with
    props, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating components with props
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, components can receive input in the form of properties, which are
    commonly referred to as props. **Props** allow us to pass data from a parent component
    to its child components. This mechanism enables components to be reusable and
    adaptable, as they can receive different sets of props to customize their behavior
    and appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Props are essentially JavaScript objects containing key-value pairs, where the
    keys represent the prop names and the values contain the corresponding data. These
    props can include various types of data, such as strings, numbers, Booleans, or
    even functions.
  prefs: []
  type: TYPE_NORMAL
- en: By passing props to a component, we can control its rendering and behavior dynamically.
    This allows us to create flexible and composable components that can be easily
    composed together to build complex UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move beyond a static component and see how we can make it more generic
    by using props. Suppose we want to display a list of blog posts, each with a heading
    and a summary. In HTML, we would manually write the HTML fragments. However, with
    React components, we can dynamically generate these HTML fragments using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s start with the basic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then pass the desired `heading` and `summary` values to the `Article`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could define another `Article` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using props, we can pass different values to the `heading` and `summary`
    props when we use the `Article` component. This makes the component versatile
    and reusable, as it can be used to display various articles with different titles
    and summaries based on the provided props.
  prefs: []
  type: TYPE_NORMAL
- en: Props are a fundamental concept in React that allows us to customize and configure
    components, making them dynamic and adaptable to different data or requirements.
  prefs: []
  type: TYPE_NORMAL
- en: A component can have any number of props, although it’s recommended to keep
    them to a manageable amount, preferably no more than five or six. This helps maintain
    clarity and understandability, as having too many props can make the component
    harder to comprehend and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down UIs into components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s examine a more complex UI and explore how to break it down into components
    and implement them separately. In this example, we will use a weather application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: A weather application](img/B21103_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: A weather application'
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire application can be defined as a `WeatherApplication` component,
    which includes several subcomponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each subcomponent can perform various tasks, such as fetching data from a remote
    server, conditionally rendering a drop-down list, or auto-refreshing periodically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `SearchBox` component might have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `search-results` section will only appear when data is fetched from the
    search query.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, a `Weather` component could be more straightforward, rendering
    whatever is passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When implementing components in real-world scenarios, it is crucial to pay attention
    to styling and refine the HTML structure with meticulous detail. Additionally,
    components should effectively manage their own state, ensuring consistency and
    responsiveness across renders.
  prefs: []
  type: TYPE_NORMAL
- en: By grasping the concept of components and their proper structuring in React,
    you gain the ability to construct dynamic and reusable UI elements that contribute
    to the overall functionality and organization of your application.
  prefs: []
  type: TYPE_NORMAL
- en: As you advance in your React development journey, don’t forget to polish the
    visual presentation through styling and consider efficient state management techniques
    to enhance the performance and interactivity of your components.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete `Weather` component could be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet defines two types: `Weather` and `WeatherType`. The `Weather`
    type represents the weather data with two properties: `main` (string) and `temperature`
    (number). The `WeatherType` type represents the structure of the weather data
    for a specific location, with a `name` property (string) for the location name
    and a `weather` property of the `Weather` type.'
  prefs: []
  type: TYPE_NORMAL
- en: The `WeatherCard` component receives the name and weather props of the `WeatherType`
    type. Inside the component, it renders a `div` container with a dynamic class
    based on the `weather.main` value.
  prefs: []
  type: TYPE_NORMAL
- en: When working on complex UIs, it is crucial to break them down into smaller,
    manageable components. Each component should represent a separate concept, and
    they can be combined together using **JSX** (**JavaScript Extension**), similar
    to writing HTML code. While props are useful for passing data to components, there
    are situations where we need to maintain data within a component itself. This
    is where states come into play, allowing us to manage and update data internally.
  prefs: []
  type: TYPE_NORMAL
- en: Managing internal state in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**State** in React refers to the internal data that components can hold and
    manage. It allows components to store and update information, enabling dynamic
    UI updates, interactivity, and data persistence. State is a fundamental concept
    in React that helps build responsive and interactive applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications feature various state types, such as a Boolean for toggle status,
    a loading state for network requests, or a user-input string for queries. We’ll
    explore the `useState` Hook, ideal for maintaining local state within a component
    across re-renders. React **Hooks** are a feature introduced in React 16.8 that
    enables functional components to have state and lifecycle features (we’ll discuss
    Hooks in more detail in the *Exploring common React Hooks* section later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by using a simple Hook for internal state management to understand
    how it maintains data within a component. For example, the following `SearchBox`
    component can be implemented with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet showcases that `SearchBox` includes an input field, a search
    button, and a display area for search results. The `useState` Hook is used to
    create a state variable called `query`, initialized as an empty string. The `handleChange`
    function captures the user’s input and updates the query state accordingly. Then,
    `component` renders the input field with the current value of `query`, a search
    button, and a `div` tag as a container displaying the search results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note here the `useState` Hook is used to manage state within the `SearchBox`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain this code a little more specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useState<string>("")`: This line declares a state variable called query and
    initializes it with an empty string (`""`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const [query, setQuery]`: This syntax uses array destructuring to assign the
    state variable (`query`) and its corresponding update function (`setQuery`) to
    variables with the same names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we have the state and the setter function bound to the input box. As we
    enter a city name in the input box, the `search-results` area is automatically
    updated, along with the input value. Although there are multiple re-renders occurring
    as we type, the state value persists throughout the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Managing state with useState](img/B21103_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Managing state with useState'
  prefs: []
  type: TYPE_NORMAL
- en: The `useState` Hook is excellent for managing internal state, yet real-world
    projects often require handling various other state types. As applications expand,
    managing global-level data shared across multiple components, such as from parent
    to children, becomes necessary. We’ll discuss different mechanisms for this kind
    of state management in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gained an understanding of how props and state enable us to
    create dynamic components, it is important to explore how changes in data impact
    the rendering process in React. By understanding this process, we can take steps
    to optimize our code for improved efficiency and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the rendering process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the data that a React component relies on changes, whether it is through
    updated props or a modified state, React needs to update the UI to reflect those
    changes. The process is called **rendering**, and is composed of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial render**: When a functional component is first rendered, it generates
    a virtual representation of the component’s UI. This virtual representation describes
    the structure and content of the UI elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State and props changes**: When there are changes in the component’s state
    or props, React re-evaluates the component’s function body. It performs a diffing
    algorithm to compare the previous and new function bodies, identifying the differences
    between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In React, a **diffing** algorithm is an internal mechanism that compares previous
    and new virtual **Document Object Model** (**DOM**) representations of a component
    and determines the minimal set of changes needed to update the actual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reconciliation**: React determines which parts of the UI need to be updated
    based on the differences identified during the diffing process. It updates only
    those specific parts of the UI, keeping the rest unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Re-rendering**: React re-renders the component by updating the virtual representation
    of the UI. It generates a new virtual DOM based on the updated function body,
    replacing the previous virtual DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM update**: Finally, React efficiently updates the real DOM to reflect
    the changes in the virtual DOM. It applies the necessary DOM manipulations, such
    as adding, removing, or updating elements, to make the UI reflect the updated
    state and props.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process ensures that the UI remains in sync with the component’s state
    and props, enabling a reactive and dynamic UI. React’s efficient rendering approach
    minimizes unnecessary DOM manipulations and provides a performant rendering experience
    in functional components.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will explore situations where writing high-performance code
    is crucial, ensuring that components only re-render when necessary while preserving
    unchanged parts. Achieving this requires utilizing Hooks effectively and employing
    various techniques to optimize rendering.
  prefs: []
  type: TYPE_NORMAL
- en: In an application, data management is essential, but we also encounter side
    effects such as network requests, DOM events, and the need for data sharing among
    components. To tackle these challenges, React provides a range of commonly used
    Hooks that serve as powerful tools for building applications. Let’s explore these
    Hooks and see how they can greatly assist us in our development process.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring common React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We briefly talked about Hooks in the *Managing internal state in React* section.
    In addition, Hooks allow for code reuse, improved readability, and easier testing
    by separating concerns and making component logic more modular.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss a few of the most common Hooks in this section. Please be aware
    that in this chapter, we are focusing on the most used Hooks. As we progress through
    the book, we will delve into several more advanced applications of these Hooks.
    Regarding the last Hook, `useContext`, we will initially explore its basic usage
    at the end of this section to provide an introductory understanding. In later
    chapters, we’ll employ `useContext` in more complex scenarios, allowing for a
    deeper and more practical grasp of its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: useState
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen the basic usage of `useState` Hook previously in this
    chapter. You can define as many states as you like inside a component, and it’s
    quite common to do so in real-world projects. For example, a login form might
    include a username, a password, and a **Remember Me** flag. All these states need
    to be remembered before the user clicks the submit (**Login**) button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Login form](img/B21103_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Login form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the UI, we’ll need three different states for the username, password,
    and a Boolean flag for **Remember Me**, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, we have to manage three different states, so it uses the
    `useState` Hook to manage state for the `username`, `password`, and `rememberMe`
    fields. The component renders input fields for username and password, a checkbox
    for **Remember Me**, and a **Login** button. User input updates the corresponding
    state variables, enabling the capture of form data.
  prefs: []
  type: TYPE_NORMAL
- en: useEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, a side effect refers to any code that is not directly related to rendering
    a component but has an impact outside the component’s scope. Side effects often
    involve interacting with external resources, such as making API calls, modifying
    the underlying DOM (not using the normal React virtual DOM), subscribing to event
    listeners, or managing timers.
  prefs: []
  type: TYPE_NORMAL
- en: React provides a built-in Hook called `useEffect` to handle side effects within
    functional components. The `useEffect` Hook allows you to perform side effects
    after rendering or when specific dependencies change.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `useEffect` Hook, you can ensure that side effects are executed
    at the appropriate times during the component’s lifecycle. This helps maintain
    the consistency and integrity of the application while separating side effects
    from the core rendering logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a typical use case of `useEffect`. We created an `Article`
    component in the *Creating components with props* section; now, let’s make a list
    of articles. Normally, an article list could return from some API calls; in JSON
    format, for example. We can use the `useEffect` Hook to send the request and set
    state once the response is returned from an API call, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet demonstrates the usage of the `useEffect` Hook in a React
    functional component. Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useEffect(() => { ... }, []);`: This line declares the `useEffect` Hook and
    provides two arguments. The first argument is a callback function that contains
    the side effect code to be executed. The second argument is an array of dependencies
    that determines when the side effect should be triggered. An empty array, `[]`,
    indicates that the side effect should only run once during the initial render.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const fetchArticles = async () => { ... }`: This line declares an asynchronous
    function called `fetchArticles`. Inside this function, an API call is made to
    fetch data from the `/``api/articles` endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch("/api/articles")...`: This line uses the `fetch` function to make a
    `GET` request to the specified API endpoint. The response is then processed using
    promises (`then`) to extract the JSON data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setArticles(data)`: This line updates the component’s state variable articles
    with the retrieved data using the `setArticles` function. This will trigger a
    re-render of the component with the updated data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchArticles()`: This line invokes the `fetchArticles` function, triggering
    the API call and updating the article’s state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have these articles, we can then use the `array.map` collection API
    to generate a list of articles.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth mentioning that when strict mode is on, in development, React runs
    setup and cleanup one extra time before the actual setup. In practice, you can
    wrap the whole application inside the `StrictMode` built-in component from React,
    and your components will re-render an extra time to find bugs caused by impure
    rendering along with other checks.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the second parameter of `useEffect` is critical. We used an
    empty array previously as we don’t want the effect to trigger each time, but there
    are cases we would like to perform the effect whenever one of the dependencies
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we have an `ArticleDetail` component, and whenever the
    `id` prop of the article changes, we need to re-fetch the data and re-render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `useEffect` Hook, the `fetchArticleDetail` function is defined to
    handle the API call. It fetches the article details based on the provided `id`
    prop, converts the response to JSON, and updates the article state using `setArticle`.
  prefs: []
  type: TYPE_NORMAL
- en: The effect is triggered when the `id` prop changes. Upon successful retrieval
    of the article data, the `Article` component is rendered with the `heading` and
    `summary` properties from the article state.
  prefs: []
  type: TYPE_NORMAL
- en: An essential feature of the `useEffect` Hook for handling side effects is the
    cleanup mechanism. When using `useEffect`, it’s recommended to return a cleanup
    function that React will call upon the component’s unmounting. For instance, if
    you set up a timer within `useEffect`, you should provide a function that clears
    this timer as the return value. This ensures proper resource management and prevents
    potential memory leaks in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we have a component that needs to execute an effect
    1 second after the initial rendering, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, within the `Timer` component, the `useEffect` Hook is used to handle a side
    effect. As the component mounts, a `setTimeout` function is set up to log the
    message `time is up` after a delay of `1000` milliseconds. The `useEffect` Hook
    then returns a cleanup function to prevent memory leaks. This cleanup function
    uses `clearTimeout` to clear the timer identified by `timerId` when the component
    unmounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `ArticleDetail` example, the complete version with the cleanup function
    would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, an `AbortController` component is used within a `useEffect`
    Hook to manage the lifecycle of a network request. When the component mounts,
    the `useEffect` Hook triggers, creating a new instance of `AbortController` and
    extracting its signal. This signal is passed to the `fetch` function, linking
    the request to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: If the component unmounts before the request completes, the cleanup function
    is called, using the `abort` method of the controller to cancel the ongoing fetch
    request. This prevents potential issues such as updating the state of an unmounted
    component, ensuring better performance and avoiding memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn our attention to another crucial Hook that enhances performance
    by preventing unnecessary function creation during re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: useCallback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useCallback` Hook in React is used to memoize and optimize the creation
    of callback functions. It is particularly useful when passing callbacks to child
    components or when using callbacks as dependencies in other Hooks. You can see
    it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useCallback` Hook takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback`: This is the function that you want to memoize. It can be an inline
    function or a function reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependencies`: This is an array of dependencies that the memoized callback
    depends on. If any of the dependencies change, the callback will be recreated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s explore a practical example. We require an editor component to modify
    the summary of an article. Whenever a user types a character, the summary needs
    to be updated, triggering a re-render. However, this re-rendering can result in
    the creation of a new function each time, which can impact performance. To mitigate
    this, we can utilize the `useCallback` Hook to optimize the rendering process
    and avoid unnecessary function recreations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `ArticleEditor` component, `useCallback` is used to memoize the `submitChange`
    function, which asynchronously makes a `POST` request to update an article, using
    the `fetch` API. This optimization with `useCallback` ensures that `submitChange`
    is only recreated when the `id` prop changes, enhancing performance by reducing
    unnecessary recalculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component then renders `ArticleForm`, passing `submitChange` as a prop
    for handling form submissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ArticleForm` uses the `useState` Hooks to track the summary state. When the
    form is submitted, `handleSubmit` prevents the default form action and calls `onSubmit`
    with the current summary. The `handleSummaryChange` function, optimized with `useCallback`,
    updates the summary state based on the `textarea` input. This use of `useCallback`
    ensures the function doesn’t get recreated unnecessarily on each render, improving
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: The React Context API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **React Context API** is a feature that allows you to pass data directly
    through the component tree, without having to pass props down manually at every
    level. This comes in handy when your application has global data that many components
    share, or when you have to pass data through components that don’t necessarily
    need the data but have to pass it down to their children.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that we are creating an application that includes a dark
    or light theme, depending on the current time (for instance, if it’s daytime,
    we use light mode). We would need to set the theme at the root level.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first, we define a type `ThemeContextType` and create a context instance
    `ThemeContext` of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a `ThemeProvider` component, which will use a React state to
    manage the current theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the `ThemeProvider` component in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In any component in our application, we can now access the current theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this setup, `ThemeContext` provides the current theme to any components in
    the tree that are interested in it. The theme is stored in a state variable in
    the `ThemeProvider` component, which is the root component of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided code may not offer much utility since the theme cannot be modified.
    However, by utilizing the Context API, you can define a modifier that allows children
    nodes to alter the status. This mechanism proves highly beneficial for data sharing,
    making it a valuable tool. Let’s modify the context interface a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We added a `toggleTheme` function in the context so that the component can modify
    the `theme` value when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the provider, we can utilize the `useState` Hook to define an
    internal state. By exposing the setter function, the children components can utilize
    it to update the value of the theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, in the calling site, it’s straightforward to use the `useContext`
    Hook to access values in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, whenever we click the **Toggle** button, it will change the theme and
    trigger a re-render:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Using a theme context](img/B21103_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Using a theme context'
  prefs: []
  type: TYPE_NORMAL
- en: In React, the Context API allows you to create and manage global state that
    can be accessed by components throughout your application. This capability enables
    you to combine multiple context providers, each representing a different slice
    or aspect of your application’s state.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using separate context providers, such as one for security, another for
    logging, and potentially others, you can organize and share related data and functionality
    efficiently. Each context provider encapsulates a specific concern, making it
    easier to manage and update related state without impacting other parts of the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the usage of React’s Context API to create and combine
    multiple context providers within an application component. `InteractionContext.Provider`,
    `SecurityContext.Provider`, and `LoggingContext.Provider` are used to wrap the
    children components and provide the respective context values.
  prefs: []
  type: TYPE_NORMAL
- en: There are several additional built-in Hooks available in React that are used
    less frequently. In the following chapters, we will introduce these Hooks as needed,
    focusing on the ones that are most relevant to the topics at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this introductory chapter, we covered essential concepts of React and laid
    the groundwork for your React development journey. We explored the concept of
    thinking in components, emphasizing the importance of breaking down applications
    into reusable and modular pieces. By adopting this mindset, you’ll be able to
    create maintainable and scalable code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we introduced you to the most commonly used Hooks in React, such
    as `useState` and `useEffect`, which empower you to manage state and handle side
    effects efficiently within functional components. These Hooks provide the flexibility
    and power to build dynamic and interactive UIs.
  prefs: []
  type: TYPE_NORMAL
- en: By mastering the fundamental principles of React and familiarizing yourself
    with the concept of thinking in components, you are now well prepared to dive
    deeper into the world of React development. In the upcoming chapters, we will
    explore more advanced topics and tackle real-world challenges, enabling you to
    become a proficient React developer.
  prefs: []
  type: TYPE_NORMAL
- en: Remember – React is a powerful tool that opens endless possibilities for creating
    modern and robust web applications. In the upcoming chapter, we will delve into
    the process of breaking down a design into smaller components and explore effective
    strategies for organizing these components. We will emphasize the importance of
    reusability and flexibility, ensuring that our components are adaptable to future
    changes.
  prefs: []
  type: TYPE_NORMAL
