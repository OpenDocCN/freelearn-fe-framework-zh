<html><head></head><body>
		<div>
			<div id="_idContainer062" class="Content">
			</div>
		</div>
		<div id="_idContainer063" class="Content">
			<h1 id="_idParaDest-50"><a id="_idTextAnchor074"/>2. Working with Data</h1>
		</div>
		<div id="_idContainer079" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will expand on what you learned in the previous chapter by introducing more ways to control data inside Vue components. You will learn how to set up advanced watchers to observe data changes inside your components, and utilize Vue's powerful reactive data feature, computed data properties, to concisely output just the data you need in your template. You will also be able to utilize asynchronous methods to fetch data for your Vue components.</p>
			<p class="callout">By the end of this chapter, you will be able to watch, manage, and manipulate data from various sources in your Vue.js components.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor075"/>Introduction</h1>
			<p>In the previous chapter, you were introduced to the concepts of single-file components and the Vue API, which provides access to methods, directives, and data properties. Building on these foundations, we will be introducing computed properties, which, like data properties, are reactive in the UI but can perform powerful calculations, and their results are cacheable, increasing the performance of your project. When building e-commerce stores, you will usually want to calculate pricing and cart items reactively as users interact with your UI, which in the past would need to be achieved without a page reload using something like <strong class="source-inline">jQuery</strong>. Vue.js makes short work of these common frontend tasks by introducing computed properties that react immediately to frontend user input.</p>
			<p>Let's begin by introducing reactive data that can be computed on the fly and understanding how to call and manipulate asynchronous data.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor076"/>Computed Properties</h1>
			<p>Computed properties are a unique data type that will reactively update when source data used within the property is updated. They may look like a Vue method, but they are not. In Vue, we can track changes to a data property by defining them as a computed property, add custom logic within this property, and use it anywhere within the component to return a value. Computed properties are cached by Vue, making them more performant for returning data than a data prop or using a Vue method.</p>
			<p>Instances where you may use a computed property include but are not limited to:</p>
			<ul>
				<li><strong class="bold">Form validation</strong>:<p>In this example, an error message will appear when the <strong class="source-inline">total</strong> data property is less than <strong class="source-inline">1</strong>. The computed property for <strong class="source-inline">total</strong> will update every time a new piece of data is added to the <strong class="source-inline">items</strong> array:</p><p class="source-code">&lt;template&gt;</p><p class="source-code">    &lt;div&gt;{{errorMessage}}&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">    export default {</p><p class="source-code">        data() {</p><p class="source-code">            return {</p><p class="source-code">                items: []</p><p class="source-code">            }</p><p class="source-code">        },</p><p class="source-code">        computed: {</p><p class="source-code">            total() {</p><p class="source-code">                return this.items.length</p><p class="source-code">            },</p><p class="source-code">            errorMessage() {</p><p class="source-code">                if (this.total &lt; 1) {</p><p class="source-code">                    return 'The total must be more than zero'</p><p class="source-code">                } else {</p><p class="source-code">                    return ''</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">&lt;/script&gt;</p><p>This will generate the following output:</p><p class="source-code">The total must be more than zero</p></li>
				<li><strong class="bold">Combining data props</strong>:<p>In the following example, you can use computed props to combine two pieces of data into one returnable string, <strong class="source-inline">formalName</strong>, that can be used within your component:</p><p class="source-code">&lt;template&gt;</p><p class="source-code">    &lt;div&gt;{{ formalName }}&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">    export default {</p><p class="source-code">        data() {</p><p class="source-code">            return {</p><p class="source-code">                title: 'Mr.',</p><p class="source-code">                surname: 'Smith'</p><p class="source-code">            }</p><p class="source-code">        },</p><p class="source-code">        computed: {</p><p class="source-code">            formalName() {</p><p class="source-code">                return this.title + ' ' + this.surname</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">&lt;/script&gt;</p><p>This will generate the following output:</p><p class="source-code">Mr. Smith</p></li>
				<li><strong class="bold"><a id="_idTextAnchor077"/><a id="_idTextAnchor078"/><a id="_idTextAnchor079"/>Outputting complex information into the Vue template</strong>:<p><a id="_idTextAnchor080"/>In this more complicated example, we use computed properties to break down the large data object called <strong class="source-inline">post</strong>. You will use the simplified and semantic computed properties to output the information into your components template. The computed properties in this example make it easier to identify and use the author's full name, see how many posts they have produced, and have the data to display their featured post:</p><p class="source-code">&lt;template&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;p&gt;{{ fullName }}&lt;/p&gt;</p><p class="source-code">        &lt;p&gt;{{ totalPosts }}&lt;/p&gt;</p><p class="source-code">        &lt;p&gt;{{ featuredPosts }}&lt;/p&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">    export default {</p><p class="source-code">        data() {</p><p class="source-code">            return {</p><p class="source-code">                post: {</p><p class="source-code">                    fields: {</p><p class="source-code">                        author: {</p><p class="source-code">                            firstName: 'John',</p><p class="source-code">                            lastName: 'Doe'</p><p class="source-code">                        },</p><p class="source-code">                        entries: [{</p><p class="source-code">                                title: "Entry 1",</p><p class="source-code">                                content: "Entry 1's content",</p><p class="source-code">                                featured: true</p><p class="source-code">                            },</p><p class="source-code">                            {</p><p class="source-code">                                title: "Entry 2",</p><p class="source-code">                                content: "Entry 2's content",</p><p class="source-code">                                featured: false</p><p class="source-code">                            }</p><p class="source-code">                       ]</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        },</p><p class="source-code">        computed: {</p><p class="source-code">            fullName() {</p><p class="source-code">                // Return string</p><p class="source-code">                return this.post.fields.author.firstName + ' ' +                  this.post.fields.author.lastName</p><p class="source-code">            },</p><p class="source-code">            totalPosts() {</p><p class="source-code">                // Return number</p><p class="source-code">                return this.post.fields.entries.length</p><p class="source-code">            },</p><p class="source-code">            featuredPosts() {</p><p class="source-code">                // Return string</p><p class="source-code">                return this.post.fields.entries.filter(entry =&gt; {</p><p class="source-code">                    // If featured is true, return the entry title</p><p class="source-code">                    if (entry.featured) {</p><p class="source-code">                        return entry</p><p class="source-code">                    }</p><p class="source-code">                })</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">&lt;/script&gt;</p><p>This will generate the following output:</p><div id="_idContainer064" class="IMG---Figure"><img src="image/B15218_02_01.jpg" alt="Figure 2.1: The computed name output&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 2.1: The computed name output</p>
			<p><a id="_idTextAnchor081"/>Computed properties are very valuable to a Vue developer when creating performant components. In the next exercise, we will explore how to use this inside of a Vue component.</p>
			<h2 id="_idParaDest-53">E<a id="_idTextAnchor082"/>xercise 2.01: Implementing Computed Data into a Vue Component</h2>
			<p>In this exercise, you will use a computed property to help cut down the amount of code you need to write inside your Vue templates by concisely outputting basic data. To access the code files for this exercise, refer to <a href="https://packt.live/3n1fQZY">https://packt.live/3n1fQZY</a>.</p>
			<ol>
				<li>Open a command-line terminal, navigate into the <strong class="source-inline">Exercise 2.01</strong> folder, and run the following commands in order:<p class="source-code">&gt; cd Exercise2.01/</p><p class="source-code">&gt; code .</p><p class="source-code">&gt; yarn</p><p class="source-code">&gt; yarn serve</p><p>Go to <strong class="source-inline">https://localhost:8080</strong>.</p></li>
				<li>Create an input field for the first name, use <strong class="source-inline">v-model</strong> to bind the data prop <strong class="source-inline">firstName</strong> to this field:<p class="source-code">&lt;input v-model="firstName" placeholder="First name" /&gt;</p></li>
				<li>Create a second input field for the last name, and use <strong class="source-inline">v-model</strong> to bind the data prop <strong class="source-inline">lastName</strong> to this field:<p class="source-code">&lt;input v-model="lastName" placeholder="Last name" /&gt;</p></li>
				<li>Include these new <strong class="source-inline">v-model</strong> data props in the Vue instance by returning them in the <strong class="source-inline">data()</strong> function:<p class="source-code">data() {</p><p class="source-code">    return {</p><p class="source-code">      firstName: '',</p><p class="source-code">      lastName: '',</p><p class="source-code">    }</p><p class="source-code">  },</p></li>
				<li>Create a computed data variable called <strong class="source-inline">fullName</strong>:<p class="source-code">computed: {</p><p class="source-code">    fullName() {</p><p class="source-code">      return `${this.firstName} ${this.lastName}`</p><p class="source-code">    },</p><p class="source-code">  },</p></li>
				<li>Underneath your input fields, using <strong class="source-inline">heading</strong> tags, output the computed data:<p class="source-code">&lt;h3 class="output"&gt;{{ fullName }}&lt;/h3&gt;</p><p>This will generate the following output:</p><div id="_idContainer065" class="IMG---Figure"><img src="image/B15218_02_02.jpg" alt="Figure 2.2: Output of the computed data will show the first and last name&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.2: Output of the computed data will show the first and last name</p>
			<p>In this exercise, we saw how we can write an expression inside a computed data property using data from the <strong class="source-inline">v-model</strong> and combine the first name and last name into a single output variable that can be reused.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor083"/>Computed Setters</h1>
			<p>In the last exercise, you saw how to write maintainable and declarative computed properties that are reusable and reactive and can be called anywhere within your component. In some real-world cases when a computed property is called, you may need to call an external API to correspond with that UI interaction or mutate data elsewhere in the project. The thing that performs this function is called a setter. </p>
			<p>Computed setters are demonstrated in the following example:</p>
			<p class="source-code">data() {</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    count: 0</p>
			<p class="source-code">  }</p>
			<p class="source-code">},</p>
			<p class="source-code">computed: {</p>
			<p class="source-code">    myComputedDataProp: {</p>
			<p class="source-code">      // getter</p>
			<p class="source-code">      get() {</p>
			<p class="source-code">        return this.count + 1</p>
			<p class="source-code">      },</p>
			<p class="source-code">      // setter</p>
			<p class="source-code">      set(val) {</p>
			<p class="source-code">        this.count = val - 1</p>
			<p class="source-code">        this.callAnotherApi(this.count)</p>
			<p class="source-code">      },</p>
			<p class="source-code">    },</p>
			<p class="source-code">  },</p>
			<p class="source-code">}</p>
			<p>By default, computed data is a getter only, which means it will only output the outcome of your expression. In this example, the computed <strong class="source-inline">myComputedDataProp</strong> data prop will output <strong class="source-inline">1</strong> in your Vue component:</p>
			<p class="source-code">  get() {</p>
			<p class="source-code">    return this.count + 1</p>
			<p class="source-code">  },</p>
			<p>Then, using a setter in a computed property allows you to reactively listen to data and run a callback (setter) that contains the returned value from the getter, which can optionally be used in the setter.</p>
			<p>In this example, the setter will update the data prop count to its new value (reflected in the getter) and then call a method within the component called <strong class="source-inline">callAnotherApi</strong>. Here, we pass in the count data prop to mimic sending this information somewhere useful:</p>
			<p class="source-code">  set(val) {</p>
			<p class="source-code">    this.count = val - 1</p>
			<p class="source-code">    this.callAnotherApi(this.count)</p>
			<p class="source-code">  },</p>
			<p>Yo<a id="_idTextAnchor084"/>u will find out exactly how to use computed data as both getters and setters in the following exercise.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor085"/>Exercise 2.02: Using Computed Setters</h2>
			<p>In this exercise, you will use a computed prop as a setter and a getter, which will both output expressions and set data when triggered by a user's input.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2GwYapA">https://packt.live/2GwYapA</a>.</p>
			<ol>
				<li value="1">Open a command-line terminal, navigate into the <strong class="source-inline">Exercise 2.02</strong> folder, and run the following commands in order:<p class="source-code">&gt; cd Exercise2.02/</p><p class="source-code">&gt; code .</p><p class="source-code">&gt; yarn</p><p class="source-code">&gt; yarn serve</p><p>Go to <strong class="source-inline">https://localhost:8080</strong>.</p></li>
				<li>Create an input field with a <strong class="source-inline">v-model</strong> value bound to a computed data value called <strong class="source-inline">incrementOne</strong>, return the value of a Vue data variable called <strong class="source-inline">count</strong> in the getter, and set the <strong class="source-inline">count</strong> variable in the setter:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;input type="number" v-model="incrementOne" /&gt;</p><p class="source-code">    &lt;h3&gt;Get input: {{ incrementOne }}&lt;/h3&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      count: -1,</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  computed: {</p><p class="source-code">    incrementOne: {</p><p class="source-code">      // getter</p><p class="source-code">      get() {</p><p class="source-code">        return this.count + 1</p><p class="source-code">      },</p><p class="source-code">      // setter</p><p class="source-code">      set(val) {</p><p class="source-code">        this.count = val - 1</p><p class="source-code">      },</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>The output of the preceding code will be as follows:</p><div id="_idContainer066" class="IMG---Figure"><img src="image/B15218_02_03.jpg" alt="Figure 2.3: First steps of a computed setter and getter&#13;&#10;"/></div><p class="figure-caption">Figure 2.3: First steps of a computed setter and getter</p></li>
				<li>Next, let's utilize the setter again. We will divide whatever the new <strong class="source-inline">val</strong> argument is by <strong class="source-inline">2</strong>, and save that to a new data variable called <strong class="source-inline">divideByTwo</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;input type="number" v-model="incrementOne" /&gt;</p><p class="source-code">    &lt;h3&gt;Get input: {{ incrementOne }}&lt;/h3&gt;</p><p class="source-code">    &lt;h5&gt;Set division: {{ divideByTwo }}&lt;/h5&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      count: -1,</p><p class="source-code">      divideByTwo: 0,</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">...</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">...</p></li>
				<li>Update the setter to divide <strong class="source-inline">val</strong> by <strong class="source-inline">2</strong>, and bind this new value to the <strong class="source-inline">divideByTwo</strong> variable:<p class="source-code">      set(val) {</p><p class="source-code">        this.count = val - 1</p><p class="source-code">        this.divideByTwo = val / 2</p><p class="source-code">      },</p><p>The output of the <strong class="source-inline">divideByTwo</strong> value should generate an outcome from the value entered in the input field, as follows:</p><div id="_idContainer067" class="IMG---Figure"><img src="image/B15218_02_04.jpg" alt="Figure 2.4: The outcome of the divideByTwo value&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.4: The outcome of the divideByTwo value</p>
			<p>In this exercise, we saw how we can use computed data to both get and set data reactively in our template by binding computed variables to the <strong class="source-inline">v-model</strong>.</p>
			<h1 id="_idParaDest-56">Watc<a id="_idTextAnchor086"/>hers</h1>
			<p>Vue <strong class="bold">watchers</strong> programmatically observe component data and run whenever a particular property changes. Watched data can contain two arguments: <strong class="source-inline">oldVal</strong> and <strong class="source-inline">newVal</strong>. This can help you when writing expressions to compare data before writing or binding new values. Watchers can observe objects as well as <strong class="source-inline">string</strong>, <strong class="source-inline">number</strong>, and <strong class="source-inline">array</strong> types. When observing objects, it will only trigger the handler if the whole object changes.</p>
			<p>In <em class="italic">Chapter 1</em>, <em class="italic">Starting Your First Vue Project</em>, we introduced life cycle hooks that run at specific times during a component's lifespan. If the <strong class="source-inline">immediate</strong> key is set to <strong class="source-inline">true</strong> on a watcher, then when this component initializes it will run this watcher on creation. You can watch all keys inside of any given object by including the key and value <strong class="source-inline">deep: true</strong> (default is <strong class="source-inline">false</strong>) To clean up your watcher code, you can assign a handler argument to a defined Vue method, which is best practice for large projects.</p>
			<p>Watchers complement the usage of computed data since they can passively observe values and cannot be used like normal Vue data variables, while computed data must always return a value and can be looked up. Remember not to use arrow functions unless you do not require the Vue context of <strong class="source-inline">this</strong>.</p>
			<p>The following watcher example demonstrates the <strong class="source-inline">immediate</strong> and <strong class="source-inline">deep</strong> optional keys; if any key inside of the <strong class="source-inline">myDataProperty</strong> object were to change it would trigger a console log:</p>
			<p class="source-code">watch: {</p>
			<p class="source-code">    myDataProperty: {</p>
			<p class="source-code">        handler: function(newVal, oldVal) {</p>
			<p class="source-code">          console.log('myDataProperty changed:', newVal, oldVal)</p>
			<p class="source-code">        },</p>
			<p class="source-code">        immediate: true,</p>
			<p class="source-code">        deep: true</p>
			<p class="source-code">    },</p>
			<p class="source-code">}</p>
			<p>Now, let's set some new values with the help of watchers.</p>
			<h2 id="_idParaDest-57">Exer<a id="_idTextAnchor087"/>cise 2.03: Using Watchers to Set New Values</h2>
			<p>In this exercise, you will use watcher arguments to watch data properties for changes, then use this watcher to set variables via a method.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/350ORI4">https://packt.live/350ORI4</a>.</p>
			<ol>
				<li value="1">Open a command-line terminal, navigate into the <strong class="source-inline">Exercise 2.03</strong> folder, and run the following commands in order:<p class="source-code">&gt; cd Exercise2.03/</p><p class="source-code">&gt; code .</p><p class="source-code">&gt; yarn</p><p class="source-code">&gt; yarn serve</p><p>Go to <strong class="source-inline">https://localhost:8080</strong>.</p></li>
				<li>Set up the document by adding a discount and an <strong class="source-inline">oldDiscount</strong> data variable with some styling:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h1&gt;Shop Watcher&lt;/h1&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      Black Friday sale</p><p class="source-code">      &lt;strike&gt;Was {{ oldDiscount }}%&lt;/strike&gt;</p><p class="source-code">      &lt;strong&gt; Now {{ discount }}% OFF&lt;/strong&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      oldDiscount: 0,</p><p class="source-code">      discount: 5,</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style lang="scss" scoped&gt;</p><p class="source-code">.container {</p><p class="source-code">  margin: 0 auto;</p><p class="source-code">  padding: 30px;</p><p class="source-code">  max-width: 600px;</p><p class="source-code">  font-family: 'Avenir', Helvetica, sans-serif;</p><p class="source-code">  margin: 0;</p><p class="source-code">}</p><p class="source-code">a {</p><p class="source-code">  display: inline-block;</p><p class="source-code">  background: rgb(235, 50, 50);</p><p class="source-code">  border-radius: 10px;</p><p class="source-code">  font-size: 14px;</p><p class="source-code">  color: white;</p><p class="source-code">  padding: 10px 20px;</p><p class="source-code">  text-decoration: none;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Observe the <strong class="source-inline">discount</strong> property by adding it to the <strong class="source-inline">watch</strong> object. Trigger a method called <strong class="source-inline">updateDiscount</strong>. Inside the method, set the <strong class="source-inline">oldDiscount</strong> data prop to be <strong class="source-inline">this.discount + 5</strong>:<p class="source-code">  watch: {</p><p class="source-code">    discount(newValue, oldValue) {</p><p class="source-code">      this.oldDiscount = oldValue</p><p class="source-code">    },</p><p class="source-code">  },</p></li>
				<li>Include a method that will augment the <strong class="source-inline">discount</strong> variable and trigger the watcher:<p class="source-code">  methods: {</p><p class="source-code">    updateDiscount() {</p><p class="source-code">      this.discount = this.discount + 5</p><p class="source-code">    },</p><p class="source-code">  },</p><p>Now add a line break, and an anchor element with the <strong class="source-inline">@click</strong> directive bound to the <strong class="source-inline">updateDiscount</strong> method:</p><p class="source-code">    &lt;br /&gt;</p><p class="source-code">    &lt;a href="#" @click="updateDiscount"&gt;Increase Discount!&lt;/a&gt;</p><p>The output of the preceding command will be as follows:</p><div id="_idContainer068" class="IMG---Figure"><img src="image/B15218_02_05.jpg" alt="Figure 2.5: A shop watcher page should look something like this&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.5: A shop watcher page should look something like this</p>
			<p>In this exercise, we saw how we can use watchers to observe and reactively manipulate data when data is changed by other methods in the Vue component.</p>
			<p>In the next section, we will learn about deep watching concepts.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor088"/>Deep Watching Concepts</h1>
			<p>When using Vue.js to watch a data property, you can purposefully observe keys inside an object for changes, rather than changes to the object itself. This is done by setting the optional <strong class="source-inline">deep</strong> property to <strong class="source-inline">true</strong>:</p>
			<p class="source-code">data() {</p>
			<p class="source-code">  return {</p>
			<p class="source-code">      organization: {</p>
			<p class="source-code">        name: 'ABC',</p>
			<p class="source-code">        employees: [</p>
			<p class="source-code">            'Jack', 'Jill'</p>
			<p class="source-code">        ]</p>
			<p class="source-code">      }</p>
			<p class="source-code">  }</p>
			<p class="source-code">},</p>
			<p class="source-code">watch: {</p>
			<p class="source-code">    organization: {</p>
			<p class="source-code">      handler: function(v) {</p>
			<p class="source-code">        this.sendIntercomData()</p>
			<p class="source-code">      },</p>
			<p class="source-code">      deep: true,</p>
			<p class="source-code">      immediate: true,</p>
			<p class="source-code">    },</p>
			<p class="source-code">  },</p>
			<p>This example will watch all available keys inside the organization data object for changes, so if the <strong class="source-inline">name</strong> property inside the organization changes, the organization watcher will trigger.</p>
			<p>If you do not need to observe every key inside of an object, it can be more performant to just watch a specific key inside an object for changes by specifying it as a <strong class="source-inline">myObj.value</strong> string. For example, you may allow a user to edit their company name and have that data sent to an API only when that key has been modified.</p>
			<p>In the following example, the watcher is specifically observing the <strong class="source-inline">name</strong> key of the <strong class="source-inline">organization</strong> object.</p>
			<p class="source-code">data() {</p>
			<p class="source-code">  return {</p>
			<p class="source-code">      organization: {</p>
			<p class="source-code">        name: 'ABC',</p>
			<p class="source-code">        employees: [</p>
			<p class="source-code">            'Jack', 'Jill'</p>
			<p class="source-code">        ]</p>
			<p class="source-code">      }</p>
			<p class="source-code">  }</p>
			<p class="source-code">},</p>
			<p class="source-code">watch: {</p>
			<p class="source-code">    'organization.name': {</p>
			<p class="source-code">      handler: function(v) {</p>
			<p class="source-code">        this.sendIntercomData()</p>
			<p class="source-code">      },</p>
			<p class="source-code">      immediate: true,</p>
			<p class="source-code">    },</p>
			<p class="source-code">  },</p>
			<p>We saw how deep watching works. Now, let's try the next exercise and watch the nested properties of a data object.</p>
			<h2 id="_idParaDest-59">Exerc<a id="_idTextAnchor089"/>ise 2.04: Watching Nested Properties of a Data Object</h2>
			<p>In this exercise, you will use watchers to observe keys within an object, which will update when a user triggers a method within the UI.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/353m59N">https://packt.live/353m59N</a>.</p>
			<ol>
				<li value="1">Open a command-line terminal, navigate to the <strong class="source-inline">Exercise 2.04</strong> folder, and run the following commands in order:<p class="source-code">&gt; cd Exercise2.04/</p><p class="source-code">&gt; code .</p><p class="source-code">&gt; yarn</p><p class="source-code">&gt; yarn serve</p><p>Go to <strong class="source-inline">https://localhost:8080</strong>.</p></li>
				<li>Start by defining a <strong class="source-inline">product</strong> object that contains a <strong class="source-inline">price</strong> and <strong class="source-inline">label</strong> and a <strong class="source-inline">discount</strong> key. Output these values into the template:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h1&gt;Deep Watcher&lt;/h1&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;h4&gt;{{ product.label }}&lt;/h4&gt;</p><p class="source-code">        &lt;h5&gt;${{ product.price }} (${{ discount }} Off)&lt;/h5&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      discount: 0,</p><p class="source-code">      product: {</p><p class="source-code">        price: 25,</p><p class="source-code">        label: 'Blue juice',</p><p class="source-code">      },</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style lang="scss" scoped&gt;</p><p class="source-code">.container {</p><p class="source-code">  margin: 0 auto;</p><p class="source-code">  padding: 30px;</p><p class="source-code">  max-width: 600px;</p><p class="source-code">  font-family: 'Avenir', Helvetica, sans-serif;</p><p class="source-code">  margin: 0;</p><p class="source-code">}</p><p class="source-code">a {</p><p class="source-code">  display: inline-block;</p><p class="source-code">  background: rgb(235, 50, 50);</p><p class="source-code">  border-radius: 10px;</p><p class="source-code">  font-size: 14px;</p><p class="source-code">  color: white;</p><p class="source-code">  padding: 10px 20px;</p><p class="source-code">  text-decoration: none;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Set up a button that will modify the price of the product. Do this by adding a button element with a <strong class="source-inline">click</strong> event bound to an <strong class="source-inline">updatePrice</strong> method that decrements the value of price:<p class="source-code">&lt;template&gt;</p><p class="source-code">...</p><p class="source-code">    &lt;a href="#" @click="updatePrice"&gt;Reduce Price!&lt;/a&gt;</p><p class="source-code">...</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">...</p><p class="source-code">  methods: {</p><p class="source-code">    updatePrice() {</p><p class="source-code">      if (this.product.price &lt; 1) return</p><p class="source-code">      this.product.price--</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">...</p><p class="source-code">&lt;/script&gt;</p><p>When you click the button, it should reduce the price as seen in the following screenshot:</p><div id="_idContainer069" class="IMG---Figure"><img src="image/B15218_02_06.jpg" alt="Figure 2.6: Screen displaying the reduced price of Blue juice&#13;&#10;"/></div><p class="figure-caption">Figure 2.6: Screen displaying the reduced price of Blue juice</p></li>
				<li>Time for the nested watcher. We will watch the <strong class="source-inline">product</strong> object's <strong class="source-inline">price</strong>, and increment the <strong class="source-inline">discount</strong> data prop:<p class="source-code">  watch: {</p><p class="source-code">    'product.price'() {</p><p class="source-code">      this.discount++</p><p class="source-code">    },</p><p class="source-code">  },</p><p>Now, as you reduce the <strong class="source-inline">price</strong>, the <strong class="source-inline">discount</strong> value will go up because of the watcher:</p><div id="_idContainer070" class="IMG---Figure"><img src="image/B15218_02_07.jpg" alt="Figure 2.7 Output displaying an increased discount value&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.7 Output displaying an increased discount value</p>
			<p>In this exercise, we used watchers to observe a key inside an object and then set new data with or without using the optional arguments parsed by the watcher.</p>
			<h1 id="_idParaDest-60">Methods<a id="_idTextAnchor090"/> versus Watchers versus Computed Props</h1>
			<p>In the Vue.js toolbox, we have access to methods, watchers, and computed properties. When should you use one or the other?</p>
			<p>Methods are best used to react to an event occurring in the <strong class="bold">DOM</strong>, and in situations where you would need to call a function or perform a call instead of reference a value, for example, <strong class="source-inline">date.now()</strong>.</p>
			<p>In Vue, you would compose an action denoted by <strong class="source-inline">@click</strong>, and reference a method:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">    &lt;button @click="getDate"&gt;Click me&lt;/button&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">    methods: {</p>
			<p class="source-code">        getDate() {</p>
			<p class="source-code">            alert(date.now())</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Computed props are best used when reacting to data updates or for composing complicated expressions for us in your template. In this instance, if the <strong class="source-inline">animalList</strong> data changes, the <strong class="source-inline">animals</strong> computed prop will also update by slicing the second item from the array and returning the new value:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">      &lt;div&gt;{{ animals }}&lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">    data() {</p>
			<p class="source-code">        return {</p>
			<p class="source-code">            animalList: ['dog', 'cat']</p>
			<p class="source-code">        }</p>
			<p class="source-code">    },</p>
			<p class="source-code">    computed: {</p>
			<p class="source-code">          animals() {</p>
			<p class="source-code">              return this.animalList.slice(1)</p>
			<p class="source-code">          }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Their reactive nature makes computed properties perfect for composing new data variables from existing data, such as when you are referencing specific keys of a larger, more complicated object, helping to simplify readability of your template. In this example, we output the authors twice in two different ways. However, notice in the <strong class="source-inline">authorName</strong> computed prop, you can compose conditional logic cleanly without bloating the HTML template:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">        &lt;p id="not-optimal"&gt;{{ authors[0].bio.name }}&lt;/p&gt;</p>
			<p class="source-code">        &lt;p id="optimal"&gt;{{ authorName }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">    data() {</p>
			<p class="source-code">       return {</p>
			<p class="source-code">           authors: [</p>
			<p class="source-code">              {</p>
			<p class="source-code">                 bio: {</p>
			<p class="source-code">                    name: 'John',</p>
			<p class="source-code">                    title: 'Dr.',</p>
			<p class="source-code">                 }</p>
			<p class="source-code">              }</p>
			<p class="source-code">           ]</p>
			<p class="source-code">       }</p>
			<p class="source-code">    },</p>
			<p class="source-code">    computed: {</p>
			<p class="source-code">         authorName () {</p>
			<p class="source-code">              return this.authors ? this.authors[0].bio.name :                 'No Name'</p>
			<p class="source-code">         }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Data watchers should be used when you need to listen to a data property change or a specific data property inside an object, and then perform an action. Because of the unique <strong class="source-inline">newVal</strong> and <strong class="source-inline">oldVal</strong> arguments of a watcher, you can watch a variable until a certain value is reached, and only then perform an action:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">        &lt;button @click="getNewName()"&gt;Click to generate name           &lt;/button&gt;</p>
			<p class="source-code">        &lt;p v-if="author"&gt;{{ author }}&lt;/p&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">    export default {</p>
			<p class="source-code">        data() {</p>
			<p class="source-code">            return {</p>
			<p class="source-code">                data: {},</p>
			<p class="source-code">                author: '',</p>
			<p class="source-code">            }</p>
			<p class="source-code">        },</p>
			<p class="source-code">        watch: {</p>
			<p class="source-code">            data: function(newVal, oldVal) {</p>
			<p class="source-code">                this.author = newVal.first</p>
			<p class="source-code">                alert(`Name changed from ${oldVal.first} to                   ${newVal.first}`)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        },</p>
			<p class="source-code">        methods: {</p>
			<p class="source-code">            async getNewName() {</p>
			<p class="source-code">                await fetch('https://randomuser.me/api/').                  then(response =&gt; response.json()).then(data =&gt; {</p>
			<p class="source-code">                    this.data = data.results[0].name</p>
			<p class="source-code">                })</p>
			<p class="source-code">            },</p>
			<p class="source-code">        },</p>
			<p class="source-code">    }</p>
			<p class="source-code">&lt;/script&gt; </p>
			<p>With this in mind, we will build a simple search functionality using a method, computed props, and a watcher to achieve a similar outcome and demonstrate the ability of each method.</p>
			<h2 id="_idParaDest-61">Exercis<a id="_idTextAnchor091"/>e 2.05: Handling Search Functionality Using a Vue Method, a Watcher, and Computed Props</h2>
			<p>In this exercise, you will create a component that allows users to search data arrays using three different methods in Vue. By the end of the exercise, you will be able to see firsthand how each different method works. </p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/32iDJVe">https://packt.live/32iDJVe</a>.</p>
			<ol>
				<li value="1">Open the command-line terminal, navigate to the <strong class="source-inline">Exercise 2.05</strong> folder, and run the following commands in order:<p class="source-code">&gt; cd Exercise2.05/</p><p class="source-code">&gt; code .</p><p class="source-code">&gt; yarn</p><p class="source-code">&gt; yarn serve</p><p>Go to <strong class="source-inline">https://localhost:8080</strong>.</p></li>
				<li>In the <strong class="source-inline">data</strong> object, add a list of frameworks in an array, assigned to the <strong class="source-inline">frameworkList</strong> value. Include an empty string with the key to input and an empty array with a key of <strong class="source-inline">methodFilterList</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      // Shared</p><p class="source-code">      frameworkList: [</p><p class="source-code">        'Vue',</p><p class="source-code">        'React',</p><p class="source-code">        'Backbone',</p><p class="source-code">        'Ember',</p><p class="source-code">        'Knockout',</p><p class="source-code">        'jQuery',</p><p class="source-code">        'Angular',</p><p class="source-code">      ],</p><p class="source-code">      // Method</p><p class="source-code">      input: '',</p><p class="source-code">      methodFilterList: [],</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>In the template, include a <strong class="source-inline">div</strong> container, a <strong class="source-inline">title</strong>, and a <strong class="source-inline">column</strong> container. Inside this <strong class="source-inline">column</strong> container, create an input that is bound to the <strong class="source-inline">v-model</strong> input, and bind the <strong class="source-inline">keyup</strong> event on the input to the <strong class="source-inline">searchMethod</strong> method:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h1&gt;Methods vs watchers vs computed props&lt;/h1&gt;</p><p class="source-code">    &lt;div class="col"&gt;</p><p class="source-code">      &lt;input</p><p class="source-code">        type="text"</p><p class="source-code">        placeholder="Search with method"</p><p class="source-code">        v-model="input"</p><p class="source-code">        @keyup="searchMethod"</p><p class="source-code">      /&gt;</p><p class="source-code">      &lt;ul&gt;</p><p class="source-code">        &lt;li v-for="(item, i) in methodFilterList" :key="i"&gt;          {{ item }}&lt;/li&gt;</p><p class="source-code">      &lt;/ul&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      // Shared</p><p class="source-code">      frameworkList: [</p><p class="source-code">        'Vue',</p><p class="source-code">        'React',</p><p class="source-code">        'Backbone',</p><p class="source-code">        'Ember',</p><p class="source-code">        'Knockout',</p><p class="source-code">        'jQuery',</p><p class="source-code">        'Angular',</p><p class="source-code">      ],</p><p class="source-code">      // Method</p><p class="source-code">      input: '',</p><p class="source-code">      methodFilterList: [],</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    searchMethod(e) {</p><p class="source-code">     console.log(e)</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style lang="scss" scoped&gt;</p><p class="source-code">.container {</p><p class="source-code">  margin: 0 auto;</p><p class="source-code">  padding: 30px;</p><p class="source-code">  max-width: 600px;  font-family: 'Avenir', Helvetica, Arial, sans-serif;</p><p class="source-code">}</p><p class="source-code">.col {</p><p class="source-code">  width: 33%;</p><p class="source-code">  height: 100%;</p><p class="source-code">  float: left;</p><p class="source-code">}</p><p class="source-code">input {</p><p class="source-code">  padding: 10px 6px;</p><p class="source-code">  margin: 20px 10px 10px 0;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p><p>The output of the preceding code will be as follows:</p><div id="_idContainer071" class="IMG---Figure"><img src="image/B15218_02_08.jpg" alt="Figure 2.8: Console should output the key input&#13;&#10;"/></div><p class="figure-caption">Figure 2.8: Console should output the key input</p></li>
				<li>Inside our <strong class="source-inline">searchMethod</strong> method, write a filter expression that binds the <strong class="source-inline">methodFilterList</strong> data prop to a filtered <strong class="source-inline">frameworkList</strong> array based on the input value. Trigger <strong class="source-inline">searchMethod</strong> on the <strong class="source-inline">created()</strong> life cycle hook so that when the component loads, a list is present:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  ...</p><p class="source-code">  created() {</p><p class="source-code">    this.searchMethod()</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    searchMethod() {</p><p class="source-code">      this.methodFilterList = this.frameworkList.filter(item =&gt;</p><p class="source-code">        item.toLowerCase().includes(this.input.toLowerCase())</p><p class="source-code">      )</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>On running the preceding code, you will be able to filter the list as shown in <em class="italic">Figure 2.9</em>:</p><div id="_idContainer072" class="IMG---Figure"><img src="image/B15218_02_09.jpg" alt="Figure 2.9: You should now be able to filter the list using a Vue method&#13;&#10;"/></div><p class="figure-caption">Figure 2.9: You should now be able to filter the list using a Vue method</p></li>
				<li>Let's make a filter using computed props. Include a new data prop called <strong class="source-inline">input2</strong> and create a <strong class="source-inline">computed</strong> prop called <strong class="source-inline">computedList</strong> that returns the same filter as the <strong class="source-inline">searchMethod</strong> but does not need to bind to another data prop:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    </p><p class="source-code">   ...</p><p class="source-code">    &lt;div class="col"&gt;</p><p class="source-code">      &lt;input type="text" placeholder="Search with computed"         v-model="input2" /&gt;</p><p class="source-code">      &lt;ul&gt;</p><p class="source-code">        &lt;li v-for="(item, i) in computedList" :key="i"&gt;          {{ item }}&lt;/li&gt;</p><p class="source-code">      &lt;/ul&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">   ...</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">       ...</p><p class="source-code">      // Computed</p><p class="source-code">      input2: '',</p><p class="source-code">      ...</p><p class="source-code">     </p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">...</p><p class="source-code">  computed: {</p><p class="source-code">    computedList() {</p><p class="source-code">      return this.frameworkList.filter(item =&gt; {</p><p class="source-code">        return item.toLowerCase().includes(this.input2.          toLowerCase())</p><p class="source-code">      })</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">...</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>You should now be able to filter the second column of frameworks with the help of computed props, as shown in the following screenshot:</p><div id="_idContainer073" class="IMG---Figure"><img src="image/B15218_02_10.jpg" alt="Figure 2.10: Filtering the second column of frameworks using computed props&#13;&#10;"/></div><p class="figure-caption">Figure 2.10: Filtering the second column of frameworks using computed props</p></li>
				<li>Finally, let's filter the same list using a watcher. Include an <strong class="source-inline">input3</strong> prop with an empty string and <strong class="source-inline">watchFilterList</strong> prop with an empty array. Also create a third column <strong class="source-inline">div</strong>, which contains an input bound to the <strong class="source-inline">input3</strong> <strong class="source-inline">v-model</strong>, and a list outputting the <strong class="source-inline">watchFilterList</strong> array:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    …</p><p class="source-code">    &lt;div class="col"&gt;</p><p class="source-code">      &lt;input type="text" placeholder="Search with watcher"         v-model="input3" /&gt;</p><p class="source-code">      &lt;ul&gt;</p><p class="source-code">        &lt;li v-for="(item, i) in watchFilterList" :key="i"&gt;          {{ item }}&lt;/li&gt;</p><p class="source-code">      &lt;/ul&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      ...</p><p class="source-code">      // Watcher</p><p class="source-code">      input3: '',</p><p class="source-code">      watchFilterList: [],</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code"> ...</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Create a watcher that watches the <strong class="source-inline">input3</strong> prop for changes and binds the result of the <strong class="source-inline">frameworkList</strong> filter to the <strong class="source-inline">watchFilterList</strong> array. Set the immediate key of <strong class="source-inline">input3</strong> to <strong class="source-inline">true</strong> so it will run when the component is created:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">...</p><p class="source-code">  watch: {</p><p class="source-code">    input3: {</p><p class="source-code">      handler() {</p><p class="source-code">        this.watchFilterList = this.frameworkList.filter(item =&gt;</p><p class="source-code">          item.toLowerCase().includes(this.input3.toLowerCase())</p><p class="source-code">        )</p><p class="source-code">      },</p><p class="source-code">      immediate: true,</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">...</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>With the help of a watcher, you should now be able to filter the third column, as shown in the following screenshot:</p><div id="_idContainer074" class="IMG---Figure"><img src="image/B15218_02_11.jpg" alt="Figure 2.11: Filtering the list using a watcher in the third column&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.11: Filtering the list using a watcher in the third column</p>
			<p>In this exercise, we have seen how we can achieve a filtered list using a method, computed props, and a watcher. Each has their own pros, cons, and use cases depending on what you are trying to achieve in your application.</p>
			<h1 id="_idParaDest-62">Async Metho<a id="_idTextAnchor092"/>ds and Data Fetching</h1>
			<p>Asynchronous functions in JavaScript are defined by the async function syntax and return an <strong class="source-inline">AsyncFunction</strong> object. These functions operate asynchronously via the event loop, using an implicit promise, which is an object that may return a result in the future. Vue.js uses this JavaScript behavior to allow you to declare asynchronous blocks of code inside methods by including the <strong class="source-inline">async</strong> keyword in front of a method. You can then chain <strong class="source-inline">then()</strong> and <strong class="source-inline">catch()</strong> functions or try the <strong class="source-inline">{}</strong> syntax inside these Vue methods and return the results.</p>
			<p><strong class="source-inline">Axios</strong> is a popular JavaScript library that allows you to make external requests for data using Node.js. It has wide browser support making it a versatile library when doing <strong class="source-inline">HTTP</strong> or API requests. We will be using this library in the next exercise.</p>
			<h2 id="_idParaDest-63">Exercise 2.<a id="_idTextAnchor093"/>06: Using Asynchronous Methods to Retrieve Data from an API</h2>
			<p>In this exercise, you will asynchronously fetch data from an external API source and display it in the frontend using computed props.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/353md9h">https://packt.live/353md9h</a>.</p>
			<ol>
				<li value="1">Open a command-line terminal, navigate to the <strong class="source-inline">Exercise 2.06</strong> folder, and run the following commands to install <strong class="source-inline">axios</strong>:<p class="source-code">&gt; cd Exercise2.06/</p><p class="source-code">&gt; code .</p><p class="source-code">&gt; yarn</p><p class="source-code">&gt; yarn add axios</p><p class="source-code">&gt; yarn serve</p><p>Go to <strong class="source-inline">https://localhost:8080</strong>.</p></li>
				<li>Let's start by importing <strong class="source-inline">axios</strong> into our component and creating a method called <strong class="source-inline">getApi()</strong>. Use <strong class="source-inline">axios</strong> to call a response from <a href="https://api.adviceslip.com/advice">https://api.adviceslip.com/advice</a> and <strong class="source-inline">console.log</strong> the result. Include a button that has a <strong class="source-inline">click</strong> event bound to the <strong class="source-inline">getApi()</strong> call:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h1&gt;Async fetch&lt;/h1&gt;</p><p class="source-code">    &lt;button @click="getApi()"&gt;Learn something profound&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import axios from 'axios'</p><p class="source-code">export default {</p><p class="source-code">  methods: {</p><p class="source-code">    async getApi() {</p><p class="source-code">      return   axios.get('https://api.adviceslip.com/advice').        then((response) =&gt; {</p><p class="source-code">        console.log(response)</p><p class="source-code">      })</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code"> </p><p class="source-code">&lt;style lang="scss" scoped&gt;</p><p class="source-code">.container {</p><p class="source-code">  margin: 0 auto;</p><p class="source-code">  padding: 30px;</p><p class="source-code">  max-width: 600px;</p><p class="source-code">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</p><p class="source-code">}</p><p class="source-code">blockquote {</p><p class="source-code">  position: relative;</p><p class="source-code">  width: 100%;</p><p class="source-code">  margin: 50px auto;</p><p class="source-code">  padding: 1.2em 30px 1.2em 30px;</p><p class="source-code">  background: #ededed;</p><p class="source-code">  border-left: 8px solid #78c0a8;</p><p class="source-code">  font-size: 24px;</p><p class="source-code">  color: #555555;</p><p class="source-code">  line-height: 1.6;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p><p>The output of the preceding code will be as follows:</p><div id="_idContainer075" class="IMG---Figure"><img src="image/B15218_02_12.jpg" alt="Figure 2.12: Screen displaying a very large object in the console&#13;&#10;"/></div><p class="figure-caption">Figure 2.12: Screen displaying a very large object in the console</p></li>
				<li>We are only interested in the data object inside the <strong class="source-inline">response</strong> object. Assign this data object to a Vue data prop called <strong class="source-inline">response</strong> that we can reuse:<p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      axiosResponse: {},</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    async getApi() {</p><p class="source-code">      return axios.get('https://api.adviceslip.com/advice').        then(response =&gt; {</p><p class="source-code">        this.axiosResponse = response.data</p><p class="source-code">      })</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p></li>
				<li>Output the <strong class="source-inline">quote</strong> from inside the <strong class="source-inline">response</strong> prop object using a computed prop that will update every time the <strong class="source-inline">response</strong> prop changes. Use a ternary operator to perform a conditional statement to check whether the <strong class="source-inline">response</strong> prop contains the <strong class="source-inline">slip</strong> object to avoid errors:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h1&gt;Async fetch&lt;/h1&gt;</p><p class="source-code">    &lt;button @click="getApi()"&gt;Learn something profound&lt;/button&gt;</p><p class="source-code">    &lt;blockquote v-if="quote"&gt;{{ quote }}&lt;/blockquote&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import axios from 'axios'</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      axiosResponse: {},</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  computed: {</p><p class="source-code">    quote() {</p><p class="source-code">      return this.axiosResponse &amp;&amp; this.axiosResponse.slip</p><p class="source-code">        ? this.axiosResponse.slip.advice</p><p class="source-code">        : null</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    async getApi() {</p><p class="source-code">      return axios.get('https://api.adviceslip.com/advice').        then(response =&gt; {</p><p class="source-code">        this.axiosResponse = response.data</p><p class="source-code">      })</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p><em class="italic">Figure 2.13</em> displays the output generated by the preceding code:</p><div id="_idContainer076" class="IMG---Figure"><img src="image/B15218_02_13.jpg" alt="Figure 2.13: Screen displaying the quote output in your template&#13;&#10;"/></div><p class="figure-caption">Figure 2.13: Screen displaying the quote output in your template</p></li>
				<li>As a final touch, include a <strong class="source-inline">loading</strong> data prop so the user can see when the UI is loading. Set <strong class="source-inline">loading</strong> to <strong class="source-inline">false</strong> by default. Inside the <strong class="source-inline">getApi</strong> method, set <strong class="source-inline">loading</strong> to <strong class="source-inline">true</strong>, and in the <strong class="source-inline">then()</strong> chain, set it back to <strong class="source-inline">false</strong> after 4 seconds using the <strong class="source-inline">setTimeout</strong> function. You can use a ternary operator to change the button text between the loading state and its default state:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="container"&gt;</p><p class="source-code">    &lt;h1&gt;Async fetch&lt;/h1&gt;</p><p class="source-code">    &lt;button @click="getApi()"&gt;{{</p><p class="source-code">      loading ? 'Loading...' : 'Learn something profound'</p><p class="source-code">    }}&lt;/button&gt;</p><p class="source-code">    &lt;blockquote v-if="quote"&gt;{{ quote }}&lt;/blockquote&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import axios from 'axios'</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      loading: false,</p><p class="source-code">      axiosResponse: {},</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  computed: {</p><p class="source-code">    quote() {</p><p class="source-code">      return this.axiosResponse &amp;&amp; this.axiosResponse.slip</p><p class="source-code">        ? this.axiosResponse.slip.advice</p><p class="source-code">        : null</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    async getApi() {</p><p class="source-code">      this.loading = true</p><p class="source-code">      return axios.get('https://api.adviceslip.com/advice').        then(response =&gt; {</p><p class="source-code">        this.axiosResponse = response.data</p><p class="source-code">        </p><p class="source-code">        setTimeout(() =&gt; {</p><p class="source-code">          this.loading = false</p><p class="source-code">        }, 4000);</p><p class="source-code">      })</p><p class="source-code">    },</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
			</ol>
			<p>The output of the preceding code will be as follows:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B15218_02_14.jpg" alt="Figure 2.14: Screen displaying the loading button state output in your template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14: Screen displaying the loading button state output in your template</p>
			<p>In this exercise, we saw how we can fetch data from an external source, assign it to a computed prop, display it in our template, and apply a loading state to our content.</p>
			<h2 id="_idParaDest-64">Activity 2.01:<a id="_idTextAnchor094"/> Creating a Blog List Using the Contentful API</h2>
			<p>In this activity, we will build a blog that lists articles from an API source. This will test your knowledge of Vue by using all the basic functions of a <strong class="bold">Single-File Component</strong> (<strong class="bold">SFC</strong>) and <strong class="source-inline">async</strong> methods to fetch remote data from an API and use computed properties to organize deep nested object structures.</p>
			<p><strong class="source-inline">Contentful</strong> is a headless <strong class="bold">content management system</strong> (<strong class="bold">CMS</strong>) that allows you to manage content separately to your code repository. You can consume this content using the API inside as many code repositories as you need. For example, you may have a blog website that acts as a primary source of information, but your clients want a standalone page on a different domain that only pulls in the most recent featured articles. Using a headless CMS inherently allows you to develop these two separate code bases and use the same updated data source.</p>
			<p>This activity will be using the headless CMS <strong class="source-inline">Contentful</strong>. The access keys and endpoints will be listed in the solution.</p>
			<p>The following steps will help you complete the activity:</p>
			<ol>
				<li value="1">Use the Vue CLI to create a new project that uses <strong class="source-inline">babel</strong> presets.</li>
				<li>Install the <strong class="source-inline">contentful</strong> dependency into your project.</li>
				<li>Use computed properties to output the deeply nested data from the API response.</li>
				<li>Use <strong class="source-inline">data</strong> props to output the user's <strong class="source-inline">name</strong>, <strong class="source-inline">job title</strong>, and <strong class="source-inline">description</strong>.</li>
				<li>Use <strong class="source-inline">SCSS</strong> to style the page.</li>
			</ol>
			<p>The expected outcome is as follows:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B15218_02_15.jpg" alt="Figure 2.15: Expected outcome with Contentful blog posts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15: Expected outcome with Contentful blog posts</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor383">this link</a>.</p>
			<p>After the activity has been completed, you should be able to use <strong class="source-inline">async</strong> methods to pull remote data from an API source into your Vue components. You will find that computed props are a sophisticated way of breaking down the information into smaller chunks of reusable data.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor095"/>Summary</h1>
			<p>In this<a id="_idTextAnchor096"/> chapter, you were introduced to Vue.js computed and watch properties, which allow you to observe and control reactive data. You also saw how to use methods to asynchronously fetch data from an API using the <strong class="source-inline">axios</strong> library and how to flatten the data to be more usable within the Vue template using computed props. The differences between using methods and computed and watch properties were demonstrated by building search functionality using each method.</p>
			<p>The next chapter will cover the Vue CLI and show you how to manage and debug your Vue.js applications that use these computed properties and events.</p>
		</div>
		<div>
			<div id="_idContainer080" class="Content">
			</div>
		</div>
	</body></html>