<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor127"/>8</h1>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Testing</h1>
<p>We have finally finished developing our application. Before we release it to production, we want to ensure that everything works <span class="No-Break">as expected.</span></p>
<p>In this chapter, we will learn how to test our application by using different testing approaches. This will give us the confidence to refactor the application, build new features, and modify the existing ones without worrying about breaking the current <span class="No-Break">application behavior.</span></p>
<p>We will be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">Unit testing</span></li>
<li><span class="No-Break">Integration testing</span></li>
<li><span class="No-Break">End-to-end testing</span></li>
</ul>
<p>By the end of this chapter, we will know how to test our application with different methods <span class="No-Break">and tools.</span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Technical requirements</h1>
<p>Before we get started, we need to set up our project. To be able to develop our project, we will need the following things installed on <span class="No-Break">our computer:</span></p>
<ul>
<li><strong class="bold">Node.js</strong> version 16 or above and <strong class="bold">npm</strong> version 8 <span class="No-Break">or above</span></li>
</ul>
<p>There are multiple ways to install Node.js and npm. Here is a great article that goes into more <span class="No-Break">detail: </span><a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js"><span class="No-Break">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</span></a><span class="No-Break">.</span></p>
<ul>
<li><strong class="bold">VSCode</strong> (optional) is currently the most popular editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source, has great integration with TypeScript, and we can extend its features via extensions. It can be downloaded <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
</ul>
<p>The code files for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/React-Application-Architecture-for-Production"><span class="No-Break">https://github.com/PacktPublishing/React-Application-Architecture-for-Production</span></a><span class="No-Break">.</span></p>
<p>The repository can be cloned locally with the <span class="No-Break">following command:</span></p>
<pre class="console">
git clone https://github.com/PacktPublishing/React-Application-Architecture-for-Production.git</pre>
<p>Once the repository has been cloned, we need to install the <span class="No-Break">application’s dependencies:</span></p>
<pre class="console">
npm install</pre>
<p>We can provide the environment variables using the <span class="No-Break">following command:</span></p>
<pre class="console">
cp .env.example .env</pre>
<p>Once the dependencies have been installed, we need to select the right stage of the code base that matches this chapter. We can do that by executing the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run stage:switch</pre>
<p>This command will prompt us with a list of stages for <span class="No-Break">each chapter:</span></p>
<pre class="console">
? What stage do you want to switch to? (Use arrow
 keys)
❯ chapter-02
  chapter-03
  chapter-03-start
  chapter-04
  chapter-04-start
  chapter-05
  chapter-05-start
(Move up and down to reveal more choices)</pre>
<p>This is the eighth chapter, so we can select <strong class="source-inline">chapter-08-start</strong> if we want to follow along, or <strong class="source-inline">chapter-08</strong> to see the final results of <span class="No-Break">this chapter.</span></p>
<p>Once the chapter has been selected, all the files required to follow along with this chapter <span class="No-Break">will appear.</span></p>
<p>For more information about the setup details, check out the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Unit testing</h1>
<p>Unit testing<a id="_idIndexMarker368"/> is a<a id="_idIndexMarker369"/> testing method where application units are tested in isolation without depending on <span class="No-Break">other parts.</span></p>
<p>For unit testing, we will use Jest, which is the most popular framework for testing <span class="No-Break">JavaScript applications.</span></p>
<p>In our <a id="_idIndexMarker370"/>application, we will unit test the <span class="No-Break">notifications store.</span></p>
<p>Let’s open the <strong class="source-inline">src/stores/notifications/__tests__/notifications.test.ts</strong> file and add <span class="No-Break">the following:</span></p>
<pre class="source-code">
import {
  notificationsStore,
  Notification,
} from '../notifications';
const notification = {
  id: '123',
  title: 'Hello World',
  type: 'info',
  message: 'This is a notification',
} as Notification;
describe('notifications store', () =&gt; {
  it('should show and dismiss notifications', () =&gt; {
    // 1
    expect(
      notificationsStore.getState().notifications.length
    ).toBe(0);
    // 2
    notificationsStore
      .getState()
      .showNotification(notification);
    expect(
      notificationsStore.getState().notifications
    ).toContainEqual(notification);
    // 3
    notificationsStore
      .getState()
      .dismissNotification(notification.id);
    expect(
      notificationsStore.getState().notifications
    ).not.toContainEqual(notification);
  });
});</pre>
<p>The <a id="_idIndexMarker371"/>notifications test <a id="_idIndexMarker372"/>works <span class="No-Break">as follows:</span></p>
<ol>
<li>We assert that the <strong class="source-inline">notifications</strong> array is <span class="No-Break">initially empty.</span></li>
<li>Then, we fire the <strong class="source-inline">showNotification</strong> action and test that the newly created notification exists in the <span class="No-Break"><strong class="source-inline">notifications</strong></span><span class="No-Break"> array.</span></li>
<li>Finally, we call the <strong class="source-inline">dismissNotification</strong> function to dismiss the notification and make sure the notification is removed from the <span class="No-Break"><strong class="source-inline">notifications</strong></span><span class="No-Break"> array.</span></li>
</ol>
<p>To run unit tests, we can execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run test</pre>
<p>Another use case for unit testing would be various utility functions and reusable components, including logic that could be tested in isolation. However, in our case, we will test our components mostly with integration tests, which we will see in the <span class="No-Break">next section.</span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Integration testing</h1>
<p>Integration testing <a id="_idIndexMarker373"/>is a<a id="_idIndexMarker374"/> testing method where multiple parts of the application are tested together. Integration tests are generally more helpful than unit tests, and most application tests should be <span class="No-Break">integration tests.</span></p>
<p>Integration tests <a id="_idIndexMarker375"/>are more valuable because they can give more confidence in our application since we are testing the functionality of different parts, the relationship between them, and how <span class="No-Break">they communicate.</span></p>
<p>For integration testing, we will use Jest and the React Testing Library. This is a great approach to testing features of the application in the same way the user would <span class="No-Break">use it.</span></p>
<p>In <strong class="source-inline">src/testing/test-utils.ts</strong>, we can define some utilities we can use in our tests. We should also re-export all utilities provided by the React Testing Library from here so that we can easily reach out to them whenever they are needed in our tests. Currently, in addition to<a id="_idIndexMarker376"/> all the functions provided by the React Testing Library, we are also exporting the <span class="No-Break">following utilities:</span></p>
<ul>
<li><strong class="source-inline">appRender</strong> is a function that calls the <strong class="source-inline">render</strong> function from the React Testing Library and adds <strong class="source-inline">AppProvider</strong> as a <strong class="source-inline">wrapper</strong>. We need this because, in our integration tests, our components rely on multiple dependencies defined in <strong class="source-inline">AppProvider</strong>, such as the React Query context, notifications, and more. Providing <strong class="source-inline">AppProvider</strong> as a <strong class="source-inline">wrapper</strong> will make it available when we render the component <span class="No-Break">during testing.</span></li>
<li><strong class="source-inline">checkTableValues</strong> is a function that goes through all the cells in the table and compares each value with the corresponding value from the provided data, ensuring that all the information is displayed in <span class="No-Break">the table.</span></li>
<li><strong class="source-inline">waitForLoadingToFinish</strong> is a function that waits for all loading spinners to disappear before we can proceed further with our tests. This is useful when we must wait for some data to be fetched before we can assert <span class="No-Break">the values.</span></li>
</ul>
<p>Another file worth mentioning is <strong class="source-inline">src/testing/setup-tests.ts</strong>, where we can configure different initialization and cleanup actions. In our case, it helps us initialize and reset the mocked API <span class="No-Break">between tests.</span></p>
<p>We can split our integration tests by pages and test all the parts on each page. The idea is to perform integration tests on the following parts of <span class="No-Break">our application:</span></p>
<ul>
<li>Dashboard <span class="No-Break">jobs page</span></li>
<li>Dashboard <span class="No-Break">job page</span></li>
<li>Create <span class="No-Break">job page</span></li>
<li><span class="No-Break">Login page</span></li>
<li>Public <span class="No-Break">job page</span></li>
<li>Public <span class="No-Break">organization page</span></li>
</ul>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Dashboard jobs page</h2>
<p>The<a id="_idIndexMarker377"/> functionality of the dashboard jobs page is based on the currently logged-in user. Here, we are fetching all the jobs of the user’s organization and displaying them in the <span class="No-Break">jobs table.</span></p>
<p>Let’s start by opening the <strong class="source-inline">src/__tests__/dashboard-jobs-page.test.tsx</strong> file and adding <span class="No-Break">the following:</span></p>
<pre class="source-code">
import DashboardJobsPage from '@/pages/dashboard/jobs';
import { getUser } from '@/testing/mocks/utils';
import { testData } from '@/testing/test-data';
import {
  appRender,
  checkTableValues,
  screen,
  waitForLoadingToFinish,
} from '@/testing/test-utils';
// 1
jest.mock('@/features/auth', () =&gt; ({
  useUser: () =&gt; ({ data: getUser() }),
}));
describe('Dashboard Jobs Page', () =&gt; {
  it('should render the jobs list', async () =&gt; {
    // 2
    await appRender(&lt;DashboardJobsPage /&gt;);
    // 3
    expect(screen.getByText(/jobs/i)).toBeInTheDocument();
    // 4
    await waitForLoadingToFinish();
    // 5
    checkTableValues({
      container: screen.getByTestId('jobs-list'),
      data: testData.jobs,
      columns: ['position', 'department', 'location'],
    });
  });
});</pre>
<p>The test is <a id="_idIndexMarker378"/>working <span class="No-Break">as follows:</span></p>
<ol>
<li value="1">Since loading the jobs depends on the currently logged-in user, we need to mock the <strong class="source-inline">useUser</strong> hook to return the proper <span class="No-Break">user object.</span></li>
<li>Then, we render <span class="No-Break">the page.</span></li>
<li>Then, we make sure the jobs page’s title is displayed on <span class="No-Break">the page.</span></li>
<li>To get the loaded jobs, we need to wait for them to <span class="No-Break">finish loading.</span></li>
<li>Finally, we assert the jobs values in <span class="No-Break">the table.</span></li>
</ol>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Dashboard job page</h2>
<p>The<a id="_idIndexMarker379"/> functionality of the dashboard job page is that we want to load the job data and display it on <span class="No-Break">the page.</span></p>
<p>Let’s start by opening the <strong class="source-inline">src/__tests__/dashboard-job-page.test.tsx</strong> file and<a id="_idIndexMarker380"/> adding <span class="No-Break">the following:</span></p>
<pre class="source-code">
import DashboardJobPage from '@/pages/dashboard/jobs/
  [jobId]';
import { testData } from '@/testing/test-data';
import {
  appRender,
  screen,
  waitForLoadingToFinish,
} from '@/testing/test-utils';
const job = testData.jobs[0];
const router = {
  query: {
    jobId: job.id,
  },
};
// 1
jest.mock('next/router', () =&gt; ({
  useRouter: () =&gt; router,
}));
describe('Dashboard Job Page', () =&gt; {
  it('should render all the job details', async () =&gt; {
    // 2
    await appRender(&lt;DashboardJobPage /&gt;);
    await waitForLoadingToFinish();
    const jobPosition = screen.getByRole('heading', {
      name: job.position,
    });
    const info = screen.getByText(job.info);
    // 3
    expect(jobPosition).toBeInTheDocument();
    expect(info).toBeInTheDocument();
  });
});</pre>
<p>The test <a id="_idIndexMarker381"/>works <span class="No-Break">as follows:</span></p>
<ol>
<li value="1">Since we are loading job data based on the <strong class="source-inline">jobId</strong> URL parameter, we need to mock the <strong class="source-inline">useRouter</strong> hook to return the proper <span class="No-Break">job ID.</span></li>
<li>Then, we render the page and wait for the data to load by waiting for all loaders to disappear from <span class="No-Break">the page.</span></li>
<li>Finally, we check that the job data is displayed on <span class="No-Break">the page.</span></li>
</ol>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Job creation page</h2>
<p>The<a id="_idIndexMarker382"/> job creation page contains a form which, when submitted, calls the API endpoint that creates a new job on the backend. When the request succeeds, we redirect the user to the dashboard jobs page and show the notification about successful <span class="No-Break">job creation.</span></p>
<p>Let’s start by opening the <strong class="source-inline">src/__tests__/dashboard-create-job-page.test.tsx</strong> file and adding <span class="No-Break">the following:</span></p>
<pre class="source-code">
import DashboardCreateJobPage from '@/pages/dashboard/jobs/
  create';
import {
  appRender,
  screen,
  userEvent,
  waitFor,
} from '@/testing/test-utils';
const router = {
  push: jest.fn(),
};
// 1
jest.mock('next/router', () =&gt; ({
  useRouter: () =&gt; router,
}));
const jobData = {
  position: 'Software Engineer',
  location: 'London',
  department: 'Engineering',
  info: 'Lorem Ipsum',
};
describe('Dashboard Create Job Page', () =&gt; {
  it('should create a new job', async () =&gt; {
    // 2
    appRender(&lt;DashboardCreateJobPage /&gt;);
    const positionInput = screen.getByRole('textbox', {
      name: /position/i,
    });
    const locationInput = screen.getByRole('textbox', {
      name: /location/i,
    });
    const departmentInput = screen.getByRole('textbox', {
      name: /department/i,
    });
    const infoInput = screen.getByRole('textbox', {
      name: /info/i,
    });
    const submitButton = screen.getByRole('button', {
      name: /create/i,
    });
    // 3
    userEvent.type(positionInput, jobData.position);
    userEvent.type(locationInput, jobData.location);
    userEvent.type(departmentInput, jobData.department);
    userEvent.type(infoInput, jobData.info);
    // 4
    userEvent.click(submitButton);
    // 5
    await waitFor(() =&gt;
      expect(
        screen.getByText(/job created!/i)
      ).toBeInTheDocument()
    );
  });
});</pre>
<p>The test works <span class="No-Break">as follows:</span></p>
<ol>
<li value="1">First, we need to mock the <strong class="source-inline">useRouter</strong> hook to contain the <strong class="source-inline">push</strong> method because it is used for navigating to the jobs page after <span class="No-Break">the submission.</span></li>
<li>Then, we<a id="_idIndexMarker383"/> render the <span class="No-Break">page component.</span></li>
<li>After that, we get all the inputs and insert values <span class="No-Break">into them.</span></li>
<li>Then, we submit the form by simulating the click event on the <span class="No-Break"><strong class="bold">Submit</strong></span><span class="No-Break"> button.</span></li>
<li>After the submission, we need to wait for the <strong class="bold">Job Created</strong> notification to appear in <span class="No-Break">the document.</span></li>
</ol>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Public organization page</h2>
<p>For the<a id="_idIndexMarker384"/> organization page, since we are rendering it on the server, we need to fetch the data on the server and display it on <span class="No-Break">the page.</span></p>
<p>Let’s start by opening the <strong class="source-inline">src/__tests__/public-organization-page.test.tsx</strong> file and defining the skeleton of the test suite, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import PublicOrganizationPage, {
  getServerSideProps,
} from '@/pages/organizations/[organizationId]';
import { testData } from '@/testing/test-data';
import {
  appRender,
  checkTableValues,
  screen,
} from '@/testing/test-utils';
const organization = testData.organizations[0];
const jobs = testData.jobs;
describe('Public Organization Page', () =&gt; {
  it('should use getServerSideProps that fetches and
    returns the proper data', async () =&gt; {
  });
  it('should render the organization details', async () =&gt; {
  });
  it('should render the not found message if the
    organization is not found', async () =&gt; {
  });
});</pre>
<p>Now, we will focus on each test in the <span class="No-Break">test suite.</span></p>
<p>First, we<a id="_idIndexMarker385"/> want to test that the <strong class="source-inline">getServerSideProps</strong> function fetches the right data and returns it as props, which will be provided on <span class="No-Break">the page:</span></p>
<pre class="source-code">
it('should use getServerSideProps that fetches and returns
  the proper data', async () =&gt; {
  const { props } = await getServerSideProps({
    params: {
      organizationId: organization.id,
    },
  } as any);
  expect(props.organization).toEqual(organization);
  expect(props.jobs).toEqual(jobs);
});</pre>
<p>Here, we are calling the <strong class="source-inline">getServerSideProps</strong> function and asserting that the returned value contains the <span class="No-Break">corresponding data.</span></p>
<p>In the <a id="_idIndexMarker386"/>second test, we want to verify that the data provided as props to the <strong class="source-inline">PublicOrganizationPage</strong> component is <span class="No-Break">rendered properly:</span></p>
<pre class="source-code">
it('should render the organization details', async () =&gt; {
  appRender(
    &lt;PublicOrganizationPage
      organization={organization}
      jobs={jobs}
    /&gt;
  );
  expect(
    screen.getByRole('heading', {
      name: organization.name,
    })
  ).toBeInTheDocument();
  expect(
    screen.getByRole('heading', {
      name: organization.email,
    })
  ).toBeInTheDocument();
  expect(
    screen.getByRole('heading', {
      name: organization.phone,
    })
  ).toBeInTheDocument();
  checkTableValues({
    container: screen.getByTestId('jobs-list'),
    data: jobs,
    columns: ['position', 'department', 'location'],
  });
});</pre>
<p>In this<a id="_idIndexMarker387"/> test, we are rendering the page component and verifying that all the values are displayed on <span class="No-Break">the page.</span></p>
<p>In the third test of the test suite, we want to assert that if the organization does not exist, we want to display the <em class="italic">not </em><span class="No-Break"><em class="italic">found</em></span><span class="No-Break"> message:</span></p>
<pre class="source-code">
it('should render the not found message if the organization is not found', async () =&gt; {
  appRender(
    &lt;PublicOrganizationPage
      organization={null}
      jobs={[]}
    /&gt;
  );
  const notFoundMessage = screen.getByRole('heading', {
    name: /not found/i,
  });
  expect(notFoundMessage).toBeInTheDocument();
});</pre>
<p>Here, we <a id="_idIndexMarker388"/>are rendering the <strong class="source-inline">PublicOrganizationPage</strong> component with an organization value of <strong class="source-inline">null</strong>, and then verifying that the <em class="italic">not found</em> message should be in <span class="No-Break">the document.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Public job page</h2>
<p>For<a id="_idIndexMarker389"/> the public job page, since we are rendering it on the server, we need to fetch the data on the server and display it on <span class="No-Break">the page.</span></p>
<p>Let’s start by opening the <strong class="source-inline">src/__tests__/public-job-page.test.tsx</strong> file and defining the skeleton for <span class="No-Break">the tests:</span></p>
<pre class="source-code">
import PublicJobPage, {
  getServerSideProps,
} from '@/pages/organizations/[organizationId]/jobs/[jobId]';
import { testData } from '@/testing/test-data';
import { appRender, screen } from '@/testing/test-utils';
const job = testData.jobs[0];
const organization = testData.organizations[0];
describe('Public Job Page', () =&gt; {
  it('should use getServerSideProps that fetches and
    returns the proper data', async () =&gt; {
  });
  it('should render the job details', async () =&gt; {
  });
  it('should render the not found message if the data does
    not exist', async () =&gt; {
  });
});</pre>
<p>Now, we can focus on each test in the <span class="No-Break">test suite.</span></p>
<p>First, we <a id="_idIndexMarker390"/>need to test the <strong class="source-inline">getServerSideProps</strong> function, which will fetch the data and return it via props to <span class="No-Break">the page:</span></p>
<pre class="source-code">
it('should use getServerSideProps that fetches and returns
  the proper data', async () =&gt; {
  const { props } = await getServerSideProps({
    params: {
      jobId: job.id,
      organizationId: organization.id,
    },
  } as any);
  expect(props.job).toEqual(job);
  expect(props.organization).toEqual(organization);
});</pre>
<p>Here, we <a id="_idIndexMarker391"/>are calling <strong class="source-inline">getServerSideProps</strong> and asserting whetherthe return value matches the <span class="No-Break">expected data.</span></p>
<p>Now, we can test <strong class="source-inline">PublicJobPage</strong>, where we want to ensure the provided data is displayed on <span class="No-Break">the page:</span></p>
<pre class="source-code">
it('should render the job details', async () =&gt; {
  appRender(
    &lt;PublicJobPage
      organization={organization}
      job={job}
    /&gt;
  );
  const jobPosition = screen.getByRole('heading', {
    name: job.position,
  });
  const info = screen.getByText(job.info);
  expect(jobPosition).toBeInTheDocument();
  expect(info).toBeInTheDocument();
});</pre>
<p>Here, we <a id="_idIndexMarker392"/>are rendering the page component and verifying that the given job’s data is displayed on <span class="No-Break">the page.</span></p>
<p>Finally, we want to assert the case where the data provided by <strong class="source-inline">getServerSideProps</strong> does <span class="No-Break">not exist:</span></p>
<pre class="source-code">
it('should render the not found message if the data does not exist', async () =&gt; {
  const { rerender } = appRender(
    &lt;PublicJobPage organization={null} job={null} /&gt;
  );
  const notFoundMessage = screen.getByRole('heading', {
    name: /not found/i,
  });
  expect(notFoundMessage).toBeInTheDocument();
  rerender(
    &lt;PublicJobPage
      organization={organization}
      job={null}
    /&gt;
  );
  expect(notFoundMessage).toBeInTheDocument();
  rerender(
    &lt;PublicJobPage organization={null} job={job} /&gt;
  );
  expect(notFoundMessage).toBeInTheDocument();
  rerender(
    &lt;PublicJobPage
      organization={organization}
      job={{ ...job, organizationId: '123' }}
    /&gt;
  );
  expect(notFoundMessage).toBeInTheDocument();
});</pre>
<p>Since there<a id="_idIndexMarker393"/> are several cases where the data can be considered invalid, we are using the <strong class="source-inline">rerender</strong> function, which can re-render the component with a different set of props. We assert that if the data is not found, the <em class="italic">not found</em> message is displayed on <span class="No-Break">the page.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Login page</h2>
<p>The<a id="_idIndexMarker394"/> login page renders the login form, which, when submitted successfully, navigates the user to <span class="No-Break">the dashboard.</span></p>
<p>Let’s start by opening the <strong class="source-inline">src/__tests__/login-page.test.tsx</strong> file and adding <span class="No-Break">the following:</span></p>
<pre class="source-code">
import LoginPage from '@/pages/auth/login';
import {
  appRender,
  screen,
  userEvent,
  waitFor,
} from '@/testing/test-utils';
// 1
const router = {
  replace: jest.fn(),
  query: {},
};
jest.mock('next/router', () =&gt; ({
  useRouter: () =&gt; router,
}));
describe('Login Page', () =&gt; {
  it('should login the user into the dashboard', async () =&gt; {
    // 2
    await appRender(&lt;LoginPage /&gt;);
    const emailInput = screen.getByRole('textbox', {
      name: /email/i,
    });
    const passwordInput =
      screen.getByLabelText(/password/i);
    const submitButton = screen.getByRole('button', {
      name: /log in/i,
    });
    const credentials = {
      email: 'user1@test.com',
      password: 'password',
    };
    // 3
    userEvent.type(emailInput, credentials.email);
    userEvent.type(passwordInput, credentials.password);
    userEvent.click(submitButton);
    // 4
    await waitFor(() =&gt;
      expect(router.replace).toHaveBeenCalledWith(
        '/dashboard/jobs'
      )
    );
  });
});</pre>
<p>The test<a id="_idIndexMarker395"/> works <span class="No-Break">as follows:</span></p>
<ol>
<li value="1">We need to mock the <strong class="source-inline">useRouter</strong> hook because it is being used to navigate the user to the dashboard on <span class="No-Break">successful submission.</span></li>
<li>Next, we render <span class="No-Break">the page.</span></li>
<li>Then, we enter the credentials into the form and <span class="No-Break">submit it.</span></li>
<li>Finally, we expect the <strong class="source-inline">replace</strong> method on the router to be called with the <strong class="source-inline">/dashboard/jobs</strong> value, which should navigate the user to the dashboard if the login <span class="No-Break">submission succeeds.</span></li>
</ol>
<p>To run the integration tests, we can execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run test</pre>
<p>If we want to watch the changes in the test, we can execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run test:watch</pre>
<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>End-to-end testing</h1>
<p>End-to-end testing<a id="_idIndexMarker396"/> is a testing method where an application<a id="_idIndexMarker397"/> is tested as a complete entity. Usually, these tests consist of running the entire application with the frontend and the backend in an automated way and verifying that the entire <span class="No-Break">system works.</span></p>
<p>In end-to-end tests, we usually want to test the happy path to confirm that everything works <span class="No-Break">as expected.</span></p>
<p>To test our application end to end, we will be using Cypress, a very popular testing framework that works by executing the tests in a headless browser. This means that the tests will be running in a real browser environment. In addition to Cypress, since we have become familiar with the React Testing Library, we will use the Testing Library plugin for Cypress to interact<a id="_idIndexMarker398"/> with <span class="No-Break">the page.</span></p>
<p>For our application, we want to test two flows of <span class="No-Break">the application:</span></p>
<ul>
<li><span class="No-Break">Dashboard flow</span></li>
<li><span class="No-Break">Public flow</span></li>
</ul>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Dashboard flow</h2>
<p>The <a id="_idIndexMarker399"/>dashboard flow is the flow for organization admins where we want to test authenticating the user and accessing and interacting with different parts of <span class="No-Break">the dashboard.</span></p>
<p>Let’s start by opening the <strong class="source-inline">cypress/e2e/dashboard.cy.ts</strong> file and adding the skeleton for <span class="No-Break">our test:</span></p>
<pre class="source-code">
import { testData } from '../../src/testing/test-data';
const user = testData.users[0];
const job = testData.jobs[0];
describe('dashboard', () =&gt; {
  it('should authenticate into the dashboard', () =&gt; {
  });
  it('should navigate to and visit the job details page', () =&gt; {
  });
  it('should create a new job', () =&gt; {
  });
  it('should log out from the dashboard', () =&gt; {
  });
});</pre>
<p>Now, let’s implement <span class="No-Break">the tests.</span></p>
<p>First, we <a id="_idIndexMarker400"/>want to authenticate into <span class="No-Break">the dashboard:</span></p>
<pre class="source-code">
it('should authenticate into the dashboard', () =&gt; {
  cy.clearCookies();
  cy.clearLocalStorage();
  cy.visit('http://localhost:3000/dashboard/jobs');
  cy.wait(500);
  cy.url().should(
    'equal',
    'http://localhost:3000/auth/login?redirect=/dashboard/
      jobs'
  );
  cy.findByRole('textbox', {
    name: /email/i,
  }).type(user.email);
  cy.findByLabelText(/password/i).type(
    user.password.toLowerCase()
  );
  cy.findByRole('button', {
    name: /log in/i,
  }).click();
  cy.findByRole('heading', {
    name: /jobs/i,
  }).should('exist');
});</pre>
<p>Here, we <a id="_idIndexMarker401"/>want to clear cookies and <strong class="source-inline">localStorage</strong>. Then, we must attempt to navigate to the dashboard; however, the application will redirect us to the login page. We must enter the credentials in the login form and submit it. After that, we will be redirected to the dashboard jobs page, where we can see the <span class="No-Break"><strong class="bold">Jobs</strong></span><span class="No-Break"> title.</span></p>
<p>Now that we are on the dashboard jobs page, we can proceed further by visiting the job <span class="No-Break">details page:</span></p>
<pre class="source-code">
it('should navigate to and visit the job details page', () =&gt; {
  cy.findByRole('row', {
    name: new RegExp(
      `${job.position} ${job.department} ${job.location}
        View`,
      'i'
    ),
  }).within(() =&gt; {
    cy.findByRole('link', {
      name: /view/i,
    }).click();
  });
  cy.findByRole('heading', {
    name: job.position,
  }).should('exist');
  cy.findByText(new RegExp(job.info, 'i')).should(
    'exist'
  );
});</pre>
<p>Here, we <a id="_idIndexMarker402"/>are clicking the <strong class="bold">View</strong> link of one of the jobs and navigating to the job details page, where we verify that the selected job data is being displayed on <span class="No-Break">the page.</span></p>
<p>Now, let’s test the job <span class="No-Break">creation process:</span></p>
<pre class="source-code">
it('should create a new job', () =&gt; {
  cy.go('back');
  cy.findByRole('link', {
    name: /create job/i,
  }).click();
  const jobData = {
    position: 'Software Engineer',
    location: 'London',
    department: 'Engineering',
    info: 'Lorem Ipsum',
  };
  cy.findByRole('textbox', {
    name: /position/i,
  }).type(jobData.position);
  cy.findByRole('textbox', {
    name: /department/i,
  }).type(jobData.department);
  cy.findByRole('textbox', {
    name: /location/i,
  }).type(jobData.location);
  cy.findByRole('textbox', {
    name: /info/i,
  }).type(jobData.info);
  cy.findByRole('button', {
    name: /create/i,
  }).click();
  cy.findByText(/job created!/i).should('exist');
});</pre>
<p>Since we<a id="_idIndexMarker403"/> are on the job details page, we need to navigate back to the dashboard jobs page, where we can click on the <strong class="bold">Create Job</strong> link. This will take us to the create job page. Here, we fill in the form and submit it. When the submission succeeds, the <strong class="bold">Job Created</strong> notification <span class="No-Break">should appear.</span></p>
<p>Now that we have tested at all the features of the dashboard, we can log out from <span class="No-Break">the dashboard:</span></p>
<pre class="source-code">
it('should log out from the dashboard', () =&gt; {
  cy.findByRole('button', {
    name: /log out/i,
  }).click();
  cy.wait(500);
  cy.url().should(
    'equal',
    'http://localhost:3000/auth/login'
  );
});</pre>
<p>Clicking the <strong class="bold">Log Out</strong> button logs the user out and redirects them to the <span class="No-Break">login page.</span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Public flow</h2>
<p>The <a id="_idIndexMarker404"/>public flow of the application is available for everyone who <span class="No-Break">visits it.</span></p>
<p>Let’s start by opening the <strong class="source-inline">cypress/e2e/public.cy.ts</strong> file and adding the skeleton of <span class="No-Break">the test:</span></p>
<pre class="source-code">
import { testData } from '../../src/testing/test-data';
const organization = testData.organizations[0];
const job = testData.jobs[0];
describe('public application flow', () =&gt; {
  it('should display the organization public page', () =&gt; {
  });
  it('should navigate to and display the public job details
    page', () =&gt; {
  });
});</pre>
<p>Now, let’s start implementing <span class="No-Break">the tests.</span></p>
<p>First, we want to visit the <span class="No-Break">organization page:</span></p>
<pre class="source-code">
it('should display the organization public page', () =&gt; {
  cy.visit(
    `http://localhost:3000/organizations/${organization.id}`
  );
  cy.findByRole('heading', {
    name: organization.name,
  }).should('exist');
  cy.findByRole('heading', {
    name: organization.email,
  }).should('exist');
  cy.findByRole('heading', {
    name: organization.phone,
  }).should('exist');
  cy.findByText(
    new RegExp(organization.info, 'i')
  ).should('exist');
});</pre>
<p>Here, we are<a id="_idIndexMarker405"/> visiting an organization details page and checking whether the data displayed there matches <span class="No-Break">the organization.</span></p>
<p>Now that we are on the organization details page, we can view a job of <span class="No-Break">the organization:</span></p>
<pre class="source-code">
it('should navigate to and display the public job details
  page', () =&gt; {
  cy.findByTestId('jobs-list').should('exist');
  cy.findByRole('row', {
    name: new RegExp(
      `${job.position} ${job.department} ${job.location}
        View`,
      'i'
    ),
  }).within(() =&gt; {
    cy.findByRole('link', {
      name: /view/i,
    }).click();
  });
  cy.url().should(
    'equal',
    `http://localhost:3000/organizations/$
      {organization.id}/jobs/${job.id}`
  );
  cy.findByRole('heading', {
    name: job.position,
  }).should('exist');
  cy.findByText(new RegExp(job.info, 'i')).should(
    'exist'
  );
});</pre>
<p>Here, we click the <strong class="bold">View</strong> link of a job, and then we navigate to the job details page, where we are asserting the <span class="No-Break">job data.</span></p>
<p>To <a id="_idIndexMarker406"/>run end-to-end tests, we need to build the application first by running the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run build</pre>
<p>Then, we can start the tests by opening <span class="No-Break">the browser:</span></p>
<pre class="console">
npm run e2e</pre>
<p>Alternatively, we can run the tests in headless mode since it is less resource-demanding, which is great <span class="No-Break">for CI:</span></p>
<pre class="console">
npm run e2e:headless</pre>
<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Summary</h1>
<p>In this chapter, we learned how to test our application, thus making it ready <span class="No-Break">for production.</span></p>
<p>We started by learning about unit testing by implementing unit tests for our <span class="No-Break">notifications store.</span></p>
<p>Since integration tests are much more valuable because they give more confidence that something is working properly, we used these tests to test <span class="No-Break">the pages.</span></p>
<p>Finally, we created end-to-end tests for public and dashboard flows, where we tested the entire functionality of <span class="No-Break">each flow.</span></p>
<p>In the next chapter, we will learn how to prepare and release our application to production. We will use these tests and integrate them within our CI/CD pipeline, where we  will not allow the application to be released to production if any of the tests fail. This will keep our  users more satisfied as there is less chance of bugs ending up <span class="No-Break">in production.</span></p>
</div>
</div></body></html>