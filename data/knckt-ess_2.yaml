- en: Chapter 2. KnockoutJS Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。KnockoutJS模板
- en: Once we have built our Catalog, it is time to add a cart to our application.
    When our code begins to grow, it's necessary to split it in several parts to keep
    it maintainable. When we split JavaScript code, we are talking about modules,
    classes, function, libraries, and so on. When we talk about HTML, we call these
    parts templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了我们的目录，就是时候给我们的应用程序添加一个购物车了。当我们的代码开始增长时，将其拆分成几个部分以保持可维护性是必要的。当我们拆分JavaScript代码时，我们谈论的是模块、类、函数、库等。当我们谈论HTML时，我们称这些部分为模板。
- en: 'KnockoutJS has a native template engine that we can use to manage our HTML.
    It is very simple, but also has a big inconvenience: templates, it should be loaded
    in the current HTML page. This is not a problem if our app is small, but it could
    be a problem if our application begins to need more and more templates.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: KnockoutJS有一个原生模板引擎，我们可以用它来管理我们的HTML。它非常简单，但也有一个很大的不便之处：模板应该在当前HTML页面中加载。如果我们的应用程序很小，这不是问题，但如果我们的应用程序开始需要越来越多的模板，这可能会成为一个问题。
- en: In this chapter, we are going to design our templates with the native engine
    and then we will speak about mechanisms and external libraries we can use to improve
    the Knockout template engine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用原生引擎设计我们的模板，然后我们将讨论可以用来改进Knockout模板引擎的机制和外部库。
- en: Preparing the project
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备项目
- en: 'We can begin from the project we did in [Chapter 1](ch01.html "Chapter 1. Refreshing
    the UI Automatically with KnockoutJS"), *Refreshing the UI Automatically with
    KnockoutJS*. First of all, we are going to add some style to the page. Add a file
    called `style.css` into the `css` folder. Add a reference in the `index.html`
    file, just below the `bootstrap` reference. The following is the content of the
    file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们在[第1章](ch01.html "第1章。使用KnockoutJS自动刷新UI")中完成的项目开始，*使用KnockoutJS自动刷新UI*。首先，我们将为页面添加一些样式。将一个名为`style.css`的文件添加到`css`文件夹中。在`index.html`文件中添加一个引用，就在`bootstrap`引用下面。以下是文件的内容：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now remove all the content from the body tag except for the script tags and
    paste in these lines:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从body标签中删除所有内容，除了脚本标签，然后粘贴下面这些行：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's review this code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来审查一下这段代码。
- en: We have two row classes. They will be our containers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个row类。它们将是我们的容器。
- en: The first container is named with the `id` value as `catalogContainer` and it
    will contain the catalog view and the cart. The second one is referenced by the
    `id` value as `orderContainer` and we will set our final order there.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个容器的名称为`catalogContainer`，它将包含目录视图和购物车。第二个引用为`orderContainer`的容器，我们将在那里设置我们的最终订单。
- en: We also have two more `<div>` tags at the bottom that will contain the modal
    dialogs to show the form to add products to our catalog (the one we built in [Chapter
    1](ch01.html "Chapter 1. Refreshing the UI Automatically with KnockoutJS"), *Refreshing
    the UI Automatically with KnockoutJS*) and the other one will contain a modal
    message to tell the user that our order is finished.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个更多的`<div>`标签在底部，将包含模态对话框，显示向我们的目录中添加产品的表单（我们在[第1章](ch01.html "第1章。使用KnockoutJS自动刷新UI")中构建的表单），另一个将包含一个模态消息，告诉用户我们的订单已经完成。
- en: Along with this code you can see a template binding inside the `data-bind` attribute.
    This is the binding that Knockout uses to bind templates to the element. It contains
    a `name` parameter that represents the ID of a template.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码，你还可以看到`data-bind`属性中的一个模板绑定。这是Knockout用来将模板绑定到元素的绑定。它包含一个`name`参数，表示模板的ID。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, this `<div>` element will contain the HTML that is inside the
    `<script>` tag with the ID `header`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这个`<div>`元素将包含位于ID为`header`的`<script>`标签内的HTML。
- en: Creating templates
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模板
- en: 'Template elements are commonly declared at the bottom of the body, just above
    the `<script>` tags that have references to our external libraries. We are going
    to define some templates and then we will talk about each one of them:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元素通常在body底部声明，就在具有对我们外部库引用的`<script>`标签上面。我们将定义一些模板，然后我们将讨论每一个模板：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each template name is descriptive enough by itself, so it's easy to know what
    we are going to set inside them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板的名称本身就足够描述性了，所以很容易知道我们将在其中设置什么。
- en: 'Let''s see a diagram showing where we dispose each template on the screen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个图表，展示我们在屏幕上放置每个模板的位置：
- en: '![Creating templates](img/7074OS_02_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建模板](img/7074OS_02_01.jpg)'
- en: Notice that the `cart-item` template will be repeated for each item in the cart
    collection. Modal templates will appear only when a modal dialog is displayed.
    Finally, the `order` template is hidden until we click to confirm the order.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cart-item`模板将针对购物车集合中的每个项目重复出现。模态模板只会在显示模态对话框时出现。最后，`order`模板在我们点击确认订单之前是隐藏的。
- en: In the `header` template, we will have the title and the menu of the page. The
    `catalog` template will contain the table with products we wrote in [Chapter 1](ch01.html
    "Chapter 1. Refreshing the UI Automatically with KnockoutJS"), *Refreshing the
    UI Automatically with KnockoutJS*. The `add-to-catalog-modal` template will contain
    the modal that shows the form to add a product to our catalog. The `cart-widget`
    template will show a summary of our cart. The `cart-item` template will contain
    the template of each item in the cart. The `cart` template will have the layout
    of the cart. The `order` template will show the final list of products we want
    to buy and a button to confirm our order.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`header`模板中，我们将有页面的标题和菜单。`catalog`模板将包含我们在[第1章](ch01.html "Chapter 1. Refreshing
    the UI Automatically with KnockoutJS")中编写的产品表格，*使用KnockoutJS自动刷新UI*。`add-to-catalog-modal`模板将包含显示向我们的目录添加产品的表单的模态框。`cart-widget`模板将显示我们购物车的摘要。`cart-item`模板将包含购物车中每个项目的模板。`cart`模板将具有购物车的布局。`order`模板将显示我们想购买的最终产品列表和确认订单的按钮。
- en: The header template
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部模板
- en: 'Let''s begin with the HTML markup that should contain the `header` template:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应该包含`header`模板的HTML标记开始：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We define a `<h1>` tag, and two `<button>` tags.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`<h1>`标签和两个`<button>`标签。
- en: The first button tag is attached to the modal that has the ID `#addToCatalogModal`.
    Since we are using Bootstrap as the CSS framework, we can attach modals by ID
    using the `data-target` attribute, and activate the modal using the `data-toggle`
    attribute.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按钮标签附加到具有ID`#addToCatalogModal`的模态框。由于我们使用的是Bootstrap作为CSS框架，我们可以使用`data-target`属性按ID附加模态，并使用`data-toggle`属性激活模态。
- en: The second button will show the full cart view and it will be available only
    if the cart has items. To achieve this, there are a number of different ways.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个按钮将显示完整的购物车视图，只有在购物车有商品时才可用。为了实现这一点，有许多不同的方法。
- en: The first one is to use the CSS-disabled class that comes with Twitter Bootstrap.
    This is the way we have used in the example. CSS binding allows us to activate
    or deactivate a class in the element depending on the result of the expression
    that is attached to the class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是使用Twitter Bootstrap提供的CSS-disabled类。这是我们在示例中使用的方式。CSS绑定允许我们根据附加到类的表达式的结果来激活或停用元素中的类。
- en: 'The other method is to use the `enable` binding. This binding enables an element
    if the expression evaluates to `true`. We can use the opposite binding, which
    is named `disable`. There is a complete documentation on the Knockout website
    [http://knockoutjs.com/documentation/enable-binding.html](http://knockoutjs.com/documentation/enable-binding.html):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`enable`绑定。如果表达式评估为`true`，此绑定将启用元素。我们可以使用相反的绑定，称为`disable`。Knockout网站上有完整的文档[http://knockoutjs.com/documentation/enable-binding.html](http://knockoutjs.com/documentation/enable-binding.html)：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first method uses CSS classes to enable and disable the button. The second
    method uses the HTML attribute, `disabled`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法使用CSS类来启用和禁用按钮。第二种方法使用HTML属性`disabled`。
- en: 'We can use a third option, which is to use a computed observable. We can create
    a computed observable variable in our view-model that returns `true` or `false`
    depending on the length of the cart:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第三个选项，即使用计算可观察值。我们可以在视图模型中创建一个计算可观察变量，根据购物车的长度返回`true`或`false`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To show the cart, we will use the `click` binding in the same way we used it
    in the previous chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示购物车，我们将以与上一章中相同的方式使用`click`绑定。
- en: 'Now we should go to our `viewmodel.js` file and add all the information we
    need to make this template work:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该转到我们的`viewmodel.js`文件，并添加所有我们需要使此模板工作的信息：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And you should expose these two objects in the view-model:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你应该在视图模型中公开这两个对象：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The catalog template
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录模板
- en: 'The next step is to define the `catalog` template just below the `header` template:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`header`模板下方定义`catalog`模板：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the same table we built in the previous chapter. We have just added
    a few new things:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在上一章中构建的相同表格。我们只是添加了一些新东西：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, each line uses the `style` binding to alert the user, while they are shopping,
    that the stock is reaching the maximum limit. The `style` binding works the same
    way that CSS binding does with classes. It allows us to add style attributes depending
    on the value of the expression. In this case, the color of the text in the line
    must be black if the stock is higher than five, and red if it is four or less.
    We can use other CSS attributes, so feel free to try other behaviors. For example,
    set the line of the catalog to green if the element is inside the cart. We should
    remember that if an attribute has dashes, you should wrap it in single quotes.
    For example, `background-color` will throw an error, so you should write `'background-color'`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每行使用 `style` 绑定来提醒用户，当他们购物时，库存达到最大限制。`style` 绑定与 CSS 绑定类似。它允许我们根据表达式的值添加样式属性。在这种情况下，如果库存高于五，行中的文本颜色必须是黑色，如果库存是四或更少，则为红色。我们可以使用其他
    CSS 属性，所以随时尝试其他行为。例如，如果元素在购物车内部，将目录的行设置为绿色。我们应记住，如果属性有连字符，你应该用单引号括起来。例如，`background-color`
    会抛出错误，所以你应该写成 `'background-color'`。
- en: 'When we work with bindings that are activated depending on the values of the
    view-model, it is good practice to use computed observables. Therefore, we can
    create a computed value in our product model that returns the value of the color
    that should be displayed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用根据视图模型的值激活的绑定时，最好使用计算观察值。因此，我们可以在我们的产品模型中创建一个计算值，该值返回应显示的颜色值：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It would be even better if we create a class in our `style.css` file that is
    called `stock-alert` and we use the CSS binding:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `style.css` 文件中创建一个名为 `stock-alert` 的类，并使用 CSS 绑定，效果会更好。
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, look inside the `<tfoot>` tag.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下 `<tfoot>` 标签内部。
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we can have nested templates. In this case, we have the `cart-widget`
    template inside our `catalog` template. This give us the possibility of having
    very complex templates, splitting them into very small pieces, and combining them,
    to keep our code clean and maintainable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们可以有嵌套模板。在这种情况下，我们在 `catalog` 模板内部有一个 `cart-widget` 模板。这使我们可以拥有非常复杂的模板，将它们分割成非常小的片段，并组合它们，以保持我们的代码整洁和可维护性。
- en: 'Finally, look at the last cell of each row:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看一下每行的最后一个单元格：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Look at how we call the `addToCart` method using the magic variable `$parent`.
    Knockout gives us some magic words to navigate through the different contexts
    we have in our app. In this case, we are in the `catalog` context and we want
    to call a method that lies one level up. We can use the magical variable called
    `$parent`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用魔术变量 `$parent` 调用 `addToCart` 方法。Knockout 给了我们一些魔术词来浏览我们应用程序中的不同上下文。在这种情况下，我们在
    `catalog` 上下文中，想要调用一个位于一级上的方法。我们可以使用名为 `$parent` 的魔术变量。
- en: There are other variables we can use when we are inside a Knockout context.
    There is complete documentation on the Knockout website [http://knockoutjs.com/documentation/binding-context.html](http://knockoutjs.com/documentation/binding-context.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Knockout 上下文中，还有其他变量可供使用。Knockout 网站上有完整的文档 [http://knockoutjs.com/documentation/binding-context.html](http://knockoutjs.com/documentation/binding-context.html)。
- en: In this project, we are not going to use all of them. But we are going quickly
    explain these binding context variables, just to understand them better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不会使用所有这些绑定上下文变量。但我们会快速解释这些绑定上下文变量，只是为了更好地理解它们。
- en: If we don't know how many levels deep we are, we can navigate to the top of
    the view-model using the magic word `$root`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道我们有多少级别深入，我们可以使用魔术词 `$root` 导航到视图模型的顶部。
- en: 'When we have many parents, we can get the magic array `$parents` and access
    each parent using indexes, for example, `$parents[0]`, `$parents[1]`. Imagine
    that you have a list of categories where each category contains a list of products.
    These products are a list of IDs and the category has a method to get the name
    of their products. We can use the `$parents` array to obtain the reference to
    the category:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有许多父级时，我们可以获得魔术数组 `$parents` 并使用索引访问每个父级，例如 `$parents[0]`，`$parents[1]`。想象一下，你有一个类别列表，每个类别包含一个产品列表。这些产品是一个
    ID 列表，而类别有一个获取其产品名称的方法。我们可以使用 `$parents` 数组来获取对类别的引用：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Look how helpful the `as` attribute is inside the `foreach` binding. It makes
    code more readable. But if you are inside a `foreach` loop, you can also access
    each item using the `$data` magic variable, and you can access the position index
    that each element has in the collection using the `$index` magic variable. For
    example, if we have a list of products, we can do this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`foreach`绑定内部的`as`属性有多有用。它使代码更易读。但是，如果你在`foreach`循环内部，你也可以使用`$data`魔术变量访问每个项目，并且可以使用`$index`魔术变量访问集合中每个元素的位置索引。例如，如果我们有一个产品列表，我们可以这样做：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should display:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示：
- en: '**0 – Product 1**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**0 – 产品 1**'
- en: '**1 – Product 2**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 – 产品 2**'
- en: '**2 – Product 3**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**2 – 产品 3**'
- en: '**...**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: '![The catalog template](img/7074OS_02_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![目录模板](img/7074OS_02_02.jpg)'
- en: KnockoutJS magic variables to navigate through contexts
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: KnockoutJS 魔术变量用于导航上下文
- en: Now that we know more about what binding variables are, let's go back to our
    code. We are now going to write the `addToCart` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更多地了解了绑定变量是什么，让我们回到我们的代码。我们现在将编写`addToCart`方法。
- en: 'We are going to define the cart items in our `js/models` folder. Create a file
    called `CartProduct.js` and insert the following code in it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`js/models`文件夹中定义购物车项目。创建一个名为`CartProduct.js`的文件，并插入以下代码：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each cart product is composed of the product itself and the units of the product
    we want to buy. We will also have a computed field that contains the subtotal
    of the line. We should give the object the responsibility for managing its units
    and the stock of the product. For this reason, we have added the `addUnit` and
    `removeUnit` methods. These methods add one unit or remove one unit of the product
    if they are called.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个购物车产品由产品本身和我们想购买的产品的单位组成。我们还将有一个计算字段，其中包含该行的小计。我们应该让对象负责管理其单位和产品的库存。因此，我们已经添加了`addUnit`和`removeUnit`方法。如果调用了这些方法，它们将增加一个产品单位或删除一个产品单位。
- en: We should reference this JavaScript file into our `index.html` file with the
    other `<script>` tags.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在我们的`index.html`文件中与其他`<script>`标签一起引用这个JavaScript文件。
- en: 'In the view-model, we should create a cart array and expose it in the return
    statement, as we have done earlier:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图模型中，我们应该创建一个购物车数组，并在返回语句中公开它，就像我们之前做的那样：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It''s time to write the `addToCart` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写`addToCart`方法了：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method searches the product in the cart. If it exists, it updates its units,
    and if not, it creates a new one. Since the cart is an observable array, we need
    to get it, manipulate it, and overwrite it, because we need to access the product
    object to know if the product is in the cart. Remember that observable arrays
    do not observe the objects they contain, just the array properties.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在购物车中搜索产品。如果存在，则更新其单位，如果不存在，则创建一个新的。由于购物车是一个可观察数组，我们需要获取它，操作它，并覆盖它，因为我们需要访问产品对象以了解产品是否在购物车中。请记住，可观察数组不会观察它们包含的对象，只会观察数组属性。
- en: The add-to-cart-modal template
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加到购物车模态框模板
- en: 'This is a very simple template. We just wrap the code we made in [Chapter 1](ch01.html
    "Chapter 1. Refreshing the UI Automatically with KnockoutJS"), *Refreshing the
    UI Automatically with KnockoutJS*, to add a product to a Bootstrap modal:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的模板。我们只需将我们在[第1章](ch01.html "第1章。使用 KnockoutJS 自动刷新 UI")中创建的代码包装在一起，*使用
    KnockoutJS 自动刷新 UI*，以将产品添加到 Bootstrap 模态框中：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The cart-widget template
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车小部件模板
- en: 'This template gives the user information quickly about how many items are in
    the cart and how much all of them cost:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板可以快速向用户提供有关购物车中有多少件商品以及它们的总成本的信息：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should define `totalItems` and `grandTotal` in our view-model:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在我们的视图模型中定义`totalItems`和`grandTotal`：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you should expose them in the return statement, as we always do. Don't worry
    about the format now, you will learn how to format currency or any kind of data
    in the future. Now you must focus on learning how to manage information and how
    to show it to the user.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该像我们一直做的那样在返回语句中公开它们。现在不要担心格式，你将在未来学习如何格式化货币或任何类型的数据。现在你必须专注于学习如何管理信息以及如何向用户显示信息。
- en: The cart-item template
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车项目模板
- en: 'The `cart-item` template displays each line in the cart:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart-item`模板显示购物车中的每一行：'
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We set an **x** button in the top-right of each line to easily remove a line
    from the cart. As you can see, we have used the `$root` magic variable to navigate
    to the top context because we are going to use this template inside a `foreach`
    loop, and it means this template will be in the loop context. If we consider this
    template as an isolated element, we can't be sure how deep we are in the context
    navigation. To be sure, we go to the right context to call the `removeFormCart`
    method. It's better to use `$root` instead of `$parent` in this case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每条线的右上角设置了一个**x**按钮，方便从购物车中移除一条线。正如您所见，我们使用了`$root`魔术变量来导航到顶级上下文，因为我们将在`foreach`循环中使用此模板，这意味着该模板将处于循环上下文中。如果我们把这个模板视为一个独立的元素，我们无法确定我们在上下文导航中有多深。为了确保，我们要到正确的上下文中调用`removeFormCart`方法。在这种情况下最好使用`$root`而不是`$parent`。
- en: 'The code for `removeFromCart` should lie in the view-model context and should
    look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeFromCart`的代码应该在view-model上下文中，代码应该如下所示：'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that in the `addToCart` method, we get the array that is inside the observable.
    We did that because we need to navigate inside the elements of the array. In this
    case, Knockout observable arrays have a method called `remove` that allows us
    to remove the object that we pass as a parameter. If the object is in the array,
    it will be removed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`addToCart`方法中，我们获得了observable内部的数组。我们这样做是因为我们需要导航到数组的元素内部。在这种情况下，Knockout可观察数组有一个叫做`remove`的方法，允许我们移除作为参数传递的对象。如果对象在数组中，则会被移除。
- en: Remember that the data context is always passed as the first parameter in the
    function we use in the click events.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，数据环境始终作为我们在单击事件中使用的函数的第一个参数传递。
- en: The cart template
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 购物车模板
- en: 'The `cart` template should display the layout of the cart:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`cart`模板应显示购物车的布局：'
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's important that you notice the template binding that we have just below
    `<h1>Cart</h1>`. We are binding a template with an array using the `foreach` argument.
    With this binding, Knockout renders the `cart-item` template for each element
    inside the cart collection. This considerably reduces the code we write in each
    template and in addition makes them more readable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您注意到我们**<h1>购物车</h1>**下面正好绑定了模板。我们使用`foreach`参数将模板与数组绑定。通过这种绑定，Knockout会为购物车中的每个元素渲染`cart-item`模板。这样可以大大减少我们在每个模板中编写的代码，而且使它们更易读。
- en: We have once again used the `cart-widget` template to show the total items and
    the total amount. This is one of the good features of templates, we can reuse
    content over and over.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`cart-widget`模板显示总商品数量和总金额。这是模板的一个很好的特点，我们可以反复使用内容。
- en: 'Observe that we have put a button at the top-right of the cart to close it
    when we don''t need to see the details of our cart, and the other one to confirm
    the order when we are done. The code in our view-model should be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在购物车的右上方放置了一个按钮，当我们不需要查看购物车的详细信息时，可以关闭购物车，并且另一个按钮是在完成时确认订单。我们的view-model中的代码应该如下：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, to show and hide elements we use jQuery and CSS classes from
    the Bootstrap framework. The hidden class just adds the `display: none` style
    to the elements. We just need to toggle this class to show or hide elements in
    our view. Expose these two methods in the `return` statement of your view-model.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您所见，我们使用jQuery和Bootstrap框架的CSS类来显示和隐藏元素。隐藏类只是给元素添加了`display: none`样式。我们只需要切换这个类来在视图中显示或隐藏元素。将这两个方法暴露在您的view-model的`return`语句中。'
- en: We will come back to this when we need to display the `order` template.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要显示`order`模板时我们将回来。
- en: 'This is the result once we have our catalog and our cart:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们有了我们的目录和购物车后的结果：
- en: '![The cart template](img/7074OS_02_03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![购物车模板](img/7074OS_02_03.jpg)'
- en: The order template
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单模板
- en: Once we have clicked on the **Confirm Order** button, the order should be shown
    to us, to review and confirm if we agree.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们单击**确认订单**按钮，订单应该显示给我们，以便审查和确认我们是否同意。
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here we have a read-only table with all cart lines and two buttons. One is
    to confirm, which will show the modal dialog saying the order is completed, and
    the other gives us the option to go back to the catalog and keep on shopping.
    There is some code we need to add to our view-model and expose to the user:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个只读表格，显示所有购物车条目和两个按钮。其中一个是确认按钮，将显示模态对话框，显示订单完成，另一个让我们有选择返回目录继续购物。有些代码需要添加到我们的view-model中并向用户公开：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we have done in previous methods, we add and remove the hidden class from
    the elements we want to show and hide. The `finishOrder` method removes all the
    items of the cart because our order is complete; hides the cart and shows the
    catalog. It also displays a modal that gives confirmation to the user that the
    order is done.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在先前的方法中所做的，我们给想要显示和隐藏的元素添加和删除隐藏类。`finishOrder`方法移除购物车中的所有商品，因为我们的订单已完成；隐藏购物车并显示目录。它还显示一个模态框，向用户确认订单已完成。
- en: '![The order template](img/7074OS_02_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![订单模板](img/7074OS_02_04.jpg)'
- en: Order details template
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 订单详情模板
- en: The finish-order-modal template
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`finish-order-modal`模板'
- en: 'The last template is the modal that tells the user that the order is complete:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个模板是告诉用户订单已完成的模态框：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot displays the output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![The finish-order-modal template](img/7074OS_02_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![完成订单模板](img/7074OS_02_05.jpg)'
- en: Handling templates with if and ifnot bindings
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 if 和 ifnot 绑定处理模板
- en: You have learned how to show and hide templates with the power of jQuery and
    Bootstrap. This is quite good because you can use this technique with any framework
    you want. The problem with this type of code is that since jQuery is a DOM manipulation
    library, you need to reference elements to manipulate them. This means you need
    to know over which element you want to apply the action. Knockout gives us some
    bindings to hide and show elements depending on the values of our view-model.
    Let's update the `show` and `hide` methods and the templates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会如何使用jQuery和Bootstrap的强大功能来显示和隐藏模板。这非常好，因为你可以在任何你想要的框架中使用这个技术。这种类型的代码的问题在于，由于jQuery是一个DOM操作库，你需要引用要操作的元素。这意味着你需要知道想要应用操作的元素。Knockout给我们一些绑定来根据我们视图模型的值来隐藏和显示元素。让我们更新`show`和`hide`方法以及模板。
- en: Add both the control variables to your view-model and expose them in the `return`
    statement.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个控制变量添加到你的视图模型中，并在`return`语句中公开它们。
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now update the `show` and `hide` methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新`show`和`hide`方法：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can appreciate how the code becomes more readable and meaningful. Now, update
    the `cart` template, the `catalog` template, and the `order` template.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以欣赏到代码变得更易读和有意义。现在，更新`cart`模板、`catalog`模板和`order`模板。
- en: 'In `index.html`, consider this line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`中，考虑这一行：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Replace it with the following line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下行替换它：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then consider the following line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后考虑以下行：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace it with this one:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个来替换它：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It is important to know that the if binding and the template binding can''t
    share the same `data-bind` attribute. This is why we go from one element to two
    nested elements in this template. In other words, this example is not allowed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，if 绑定和模板绑定不能共享相同的`data-bind`属性。这就是为什么在这个模板中我们从一个元素转向两个嵌套元素。换句话说，这个例子是不允许的：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, consider this line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑这一行：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace it with this one:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个来替换它：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With the changes we have made, showing or hiding elements now depends on our
    data and not on our CSS. This is much better because now we can show and hide
    any element we want using the `if` and `ifnot` binding.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们所做的更改，显示或隐藏元素现在取决于我们的数据而不是我们的 CSS。这样做要好得多，因为现在我们可以使用`if`和`ifnot`绑定来显示和隐藏任何我们想要的元素。
- en: 'Let''s review, roughly speaking, how our files are now:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们粗略地回顾一下我们现在的文件：
- en: 'We have our `index.html` file that has the main container, templates, and libraries:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的`index.html`文件，其中包含主容器、模板和库：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also have our `viewmodel.js` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有我们的`viewmodel.js`文件：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is useful to debug to globalize the view-model. It is not good practice in
    production environments, but it is good when you are debugging your application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时将视图模型全局化是很有用的。在生产环境中这样做并不是好的实践，但在调试应用程序时是很好的。
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now you have easy access to your view-model from the browser debugger or from
    your IDE debugger.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以从浏览器调试器或IDE调试器轻松访问你的视图模型。
- en: 'In addition to the product model that we coded in the [Chapter 1](ch01.html
    "Chapter 1. Refreshing the UI Automatically with KnockoutJS"), *Refreshing the
    UI Automatically with KnockoutJS*, we have created a new model called `CartProduct`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[第1章](ch01.html "第1章。使用KnockoutJS实现自动刷新UI")中编写的产品模型之外，我们还创建了一个名为`CartProduct`的新模型：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You have learned how to manage templates with Knockout, but maybe you have noticed
    that having all templates in the `index.html` file is not the best approach. We
    are going to talk about two mechanisms. The first one is more home-made and the
    second one is an external library used by lots of Knockout developers, created
    by Jim Cowart, called *Knockout.js-External-Template-Engine* ([https://github.com/ifandelse/Knockout.js-External-Template-Engine](https://github.com/ifandelse/Knockout.js-External-Template-Engine)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何使用Knockout管理模板，但也许你已经注意到，在`index.html`文件中拥有所有模板并不是最佳的方法。我们将讨论两种机制。第一种更像是自制的，而第二种是许多Knockout开发者使用的外部库，由Jim
    Cowart创建，名为*Knockout.js-External-Template-Engine*（[https://github.com/ifandelse/Knockout.js-External-Template-Engine](https://github.com/ifandelse/Knockout.js-External-Template-Engine)）。
- en: Managing templates with jQuery
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery管理模板
- en: 'Since we want to load templates from different files, let''s move all our templates
    to a folder called `views` and make one file per template. Each file will have
    the same name the template has as an ID. So if the template has the ID, `cart-item`,
    the file should be called `cart-item.html` and will contain the full `cart-item`
    template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望从不同的文件加载模板，让我们将所有的模板移到一个名为`views`的文件夹中，并且每个模板都用一个文件表示。每个文件的名称将与模板的ID相同。因此，如果模板的ID是`cart-item`，那么文件应该被称为`cart-item.html`，并且将包含完整的`cart-item`模板：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Managing templates with jQuery](img/7074OS_02_06.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![使用jQuery管理模板](img/7074OS_02_06.jpg)'
- en: The views folder with all templates
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有模板的views文件夹
- en: 'Now in the `viewmodel.js` file, remove the last line (`ko.applyBindings(vm)`)
    and add this code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`viewmodel.js`文件中，删除最后一行（`ko.applyBindings(vm)`）并添加此代码：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code gets all the templates we need and appends them to the body. Once
    all the templates are loaded, we call the `applyBindings` method. We should do
    it this way because we are loading templates asynchronously and we need to make
    sure that we bind our view-model when all templates are loaded.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码获取我们需要的所有模板并将它们附加到body。一旦所有模板都加载完成，我们就调用`applyBindings`方法。我们应该这样做，因为我们是异步加载模板，我们需要确保当所有模板加载完成时绑定我们的视图模型。
- en: This is good enough to make our code more maintainable and readable, but is
    still problematic if we need to handle lots of templates. Further more, if we
    have nested folders, it becomes a headache listing all our templates in one array.
    There should be a better approach.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做已足以使我们的代码更易维护和易读，但如果我们需要处理大量的模板，仍然存在问题。而且，如果我们有嵌套文件夹，列出所有模板就会变成一个头疼的事情。应该有更好的方法。
- en: Managing templates with koExternalTemplateEngine
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`koExternalTemplateEngine`管理模板
- en: We have seen two ways of loading templates, both of them are good enough to
    manage a low number of templates, but when lines of code begin to grow, we need
    something that allows us to forget about template management. We just want to
    call a template and get the content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种加载模板的方式，它们都足以管理少量的模板，但当代码行数开始增长时，我们需要一些允许我们忘记模板管理的东西。我们只想调用一个模板并获取内容。
- en: For this purpose, Jim Cowart's library, `koExternalTemplateEngine`, is perfect.
    This project was abandoned by the author in 2014, but it is still a good library
    that we can use when we develop simple projects. In the next chapters, you will
    learn more about asynchronous loading and module patterns and we will see other
    libraries that are currently maintained.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为此目的，Jim Cowart的库`koExternalTemplateEngine`非常完美。这个项目在2014年被作者放弃，但它仍然是一个我们在开发简单项目时可以使用的好库。在接下来的章节中，您将学习更多关于异步加载和模块模式的知识，我们将看到其他目前正在维护的库。
- en: We just need to download the library in the `js/vendors` folder and then link
    it in our `index.html` file just below the Knockout library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在`js/vendors`文件夹中下载库，然后在我们的`index.html`文件中链接它，放在Knockout库的下面即可。
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now you should configure it in the `viewmodel.js` file. Remove the templates
    array and the `foreach` statement, and add these three lines of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在`viewmodel.js`文件中进行配置。删除模板数组和`foreach`语句，并添加以下三行代码：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `infuser` is a global variable that we use to configure the template engine.
    We should indicate which suffix will have our templates and in which folder they
    will be.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`infuser`是一个我们用来配置模板引擎的全局变量。我们应该指示我们的模板将具有哪个后缀名，以及它们将在哪个文件夹中。
- en: We don't need the `<script type="text/html" id="template-id"></script>` tags
    any more, so we should remove them from each file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要`<script type="text/html" id="template-id"></script>`标签，所以我们应该从每个文件中删除它们。
- en: So now everything should be working, and the code we needed to succeed was not
    much.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切应该都正常了，我们成功所需的代码并不多。
- en: KnockoutJS has its own template engine, but you can see that adding new ones
    is not difficult. If you have experience with other template engines such as jQuery
    Templates, Underscore, or Handlebars, just load them in your `index.html` file
    and use them, there is no problem with that. This is why Knockout is beautiful,
    you can use any tool you like with it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: KnockoutJS有自己的模板引擎，但是您可以看到添加新的引擎并不困难。如果您有其他模板引擎的经验，如jQuery Templates、Underscore或Handlebars，只需将它们加载到您的`index.html`文件中并使用它们，没有任何问题。这就是Knockout的美丽之处，您可以使用任何您喜欢的工具。
- en: You have learned a lot of things in this chapter, haven't you?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章学到了很多东西，对吧？
- en: Knockout gives us the CSS binding to activate and deactivate CSS classes according
    to an expression.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knockout给了我们CSS绑定，根据表达式激活和停用CSS类。
- en: We can use the style binding to add CSS rules to elements.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用style绑定向元素添加CSS规则。
- en: The template binding helps us to manage templates that are already loaded in
    the DOM.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板绑定帮助我们管理已在DOM中加载的模板。
- en: We can iterate along collections with the `foreach` binding.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`foreach`绑定可以在集合上进行迭代。
- en: Inside a `foreach`, Knockout gives us some magic variables such as `$parent`,
    `$parents`, `$index`, `$data`, and `$root`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`foreach`内部，Knockout给了我们一些魔术变量，如`$parent`、`$parents`、`$index`、`$data`和`$root`。
- en: We can use the binding `as` along with the `foreach` binding to get an alias
    for each element.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在`foreach`绑定中使用`as`绑定来为每个元素获取别名。
- en: We can show and hide content using just jQuery and CSS.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以只使用jQuery和CSS来显示和隐藏内容。
- en: 'We can show and hide content using the bindings: `if`, `ifnot`, and `visible`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`if`、`ifnot`和`visible`绑定来显示和隐藏内容。
- en: jQuery helps us to load Knockout templates asynchronously.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery帮助我们异步加载Knockout模板。
- en: You can use the `koExternalTemplateEngine` plugin to manage templates in a more
    efficient way. The project is abandoned but it is still a good solution.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`koExternalTemplateEngine`插件以更有效的方式管理模板。这个项目已经被放弃了，但它仍然是一个很好的解决方案。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to split an application using templates
    that share the same view-model. Now that we know the basics, it would be interesting
    to extend the application. Maybe we can try to create a detailed view of the product,
    or maybe we can give the user the option to register where to send the order.
    You will learn how to do these things in the coming chapters, but it would be
    interesting to experiment just with the knowledge we have now.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用共享相同视图模型的模板来拆分应用程序。现在我们知道了基础知识，扩展应用程序会很有趣。也许我们可以尝试创建产品的详细视图，或者给用户选择订单发送位置的选项。您将在接下来的章节中学习如何做这些事情，但是只使用我们现在拥有的知识进行实验会很有趣。
- en: In the next chapter, we are going to learn how to extend Knockout behaviors.
    This will be useful to format data and to create code that we can reuse over and
    over. You will learn what custom bindings and components are and how they help
    us write reusable and elegant code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何扩展Knockout行为。这将有助于格式化数据并创建可重用的代码。您将学习自定义绑定和组件是什么，以及它们如何帮助我们编写可重用和优雅的代码。
- en: 'The code of this chapter is on GitHub:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码在GitHub上：
- en: '[https://github.com/jorgeferrando/knockout-cart/archive/chapter2.zip](https://github.com/jorgeferrando/knockout-cart/archive/chapter2.zip)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jorgeferrando/knockout-cart/archive/chapter2.zip](https://github.com/jorgeferrando/knockout-cart/archive/chapter2.zip)'
