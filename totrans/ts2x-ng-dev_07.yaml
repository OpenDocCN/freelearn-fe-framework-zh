- en: Separating Concerns with Typed Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型化服务分离关注点
- en: 'This chapter builds on the previous chapter, with more techniques showing how
    communication occurs within your application''s building blocks. You will learn
    the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在上一章的基础上构建，展示了更多技术，说明了如何在应用程序的构建块之间进行通信。在本章中，你将学习以下主题：
- en: Services and Dependency Injection (DI) concepts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务和依赖注入（DI）概念
- en: Component communication with services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件与服务之间的通信
- en: Writing data logic with services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务编写数据逻辑
- en: To understand services better, you need to understand at least the basic concepts
    of Dependency Injection.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解服务，你需要至少了解依赖注入的基本概念。
- en: Dependency injection
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Writing Angular in TypeScript demands that your building blocks (components,
    directives, services, and so on) are written in classes. They are just building
    blocks, which means that they need to be intertwined with each other before they
    can become functional, thus making a full-blown application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript编写Angular要求你的构建块（组件、指令、服务等）是用类编写的。它们只是构建块，这意味着在它们变得功能之前，它们需要相互交织，从而形成一个完整的应用程序。
- en: 'This intertwining process can be pretty daunting. For this reason, let''s understand
    the problem first. Take the following TypeScript class, for instance:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交织过程可能相当令人望而生畏。因此，让我们首先了解这个问题。以以下TypeScript类为例：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The implementation of the `Person` and `Skill` classes is as simple as the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`人物`和`技能`类的实现就像以下这样：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding sample is very functional and valid code until you starting having
    more developer types that need to be created using this class. There is no way
    to actually create another type of developer because all the implementation details
    are tied to a class; hence, the process isn't flexible. We need to make the class
    a lot more generic before it can be used to create more types of developer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建更多需要使用此类的新开发者类型之前，前面的示例是非常功能性和有效的代码。实际上，没有方法可以创建另一种类型的开发者，因为所有实现细节都绑定到一个类上；因此，这个过程不够灵活。在能够用来创建更多类型的开发者之前，我们需要使这个类更加通用。
- en: 'Let''s try improving the `Developer` class, so it receives all the values needed
    to create a class from the constructor rather than setting it in the class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试改进`开发者`类，使其通过构造函数接收创建类所需的所有值，而不是在类中设置：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So much improvement in so few lines! We are now using the constructor to make
    the code a lot more flexible. With this update, you can use the `Developer` class
    to create as many types of developer as you need.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么少的代码行中就有如此多的改进！我们现在使用构造函数使代码变得更加灵活。通过这次更新，你可以使用`开发者`类创建所需的所有类型的开发者。
- en: 'Although this solution seems like it will save the day, there is still a tight
    coupling issue going on in the system. What happens when the constructors in the `Person` and `Skill` classes
    change? The implication is that you will have to come back and update the call
    to this constructor in the `Developer` class. Here is an example of such a change
    in `Skill`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案看起来可以解决问题，但系统中仍然存在紧密耦合的问题。当`Person`和`Skill`类的构造函数发生变化时会发生什么？其含义是，你将不得不回到`Developer`类中更新对这个构造函数的调用。以下是在`Skill`中此类变化的一个示例：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We added another field to the `yearsOfExperience` class, which is of the number
    type and represents how long a developer has been practicing a claimed skill.
    For this to actually work in `Developer`, we have to update the `Developer` class
    as well:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`yearsOfExperience`类添加了另一个字段，它是数字类型，表示开发者练习声称的技能有多长时间。为了在`Developer`中实际工作，我们必须更新`Developer`类：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Updating this class every time a dependency changes is what we''re are striving
    to avoid. A common practice is to elevate the constructors of the dependencies
    to the constructor of the class itself:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当依赖项发生变化时更新此类，这是我们力求避免的。一种常见的做法是将依赖项的构造函数提升到类的构造函数本身：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This way, the `Developer` is less aware of the implementation details of `Skill`
    and `Person`. Therefore, if they change internally, `Developer` won't care; it
    just stays as is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`开发者`对`技能`和`人物`的实现细节了解较少。因此，如果它们内部发生变化，`开发者`不会关心；它只是保持原样。
- en: 'In fact, TypeScript provides a productivity shorthand:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，TypeScript提供了一个生产力快捷方式：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This shorthand will implicitly declare the properties and assign them as dependencies
    via the constructor as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个快捷方式将隐式声明属性，并通过构造函数将它们作为依赖项分配。
- en: That's not all; elevating these dependencies introduces another challenge. How
    do we manage all the dependencies in our application without losing track of where
    things are meant to be? This is where Dependency Injection comes in. It's not
    an Angular thing, but a popular pattern implemented in Angular.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部；提升这些依赖关系引入了另一个挑战。我们如何在应用中管理所有依赖关系，而不会失去对事物预期位置的跟踪？这就是依赖注入发挥作用的地方。它不是
    Angular 的事情，但这是一个在 Angular 中实现的流行模式。
- en: Let's start seeing DI in action right in an Angular app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Angular 应用中直接看到依赖注入（DI）的实际应用。
- en: Data in components
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件中的数据
- en: 'To better understand the importance of services and DI, let''s create a simple
    app with a component that shows a list of user comments. Once you have an app
    created, you can run the following command to generate the required component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解服务和依赖注入的重要性，让我们创建一个简单的应用，其中包含一个显示用户评论列表的组件。一旦创建好应用，你可以运行以下命令来生成所需的组件：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the component''s code with the following snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更新组件的代码如下片段：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The component has a `comments` array, which is populated with hardcoded data
    once the component is initialized via the `ngOnInit` lifecycle. Now we need to
    iterate over the list of arrays and print on the DOM:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 组件有一个 `comments` 数组，一旦通过 `ngOnInit` 生命周期初始化组件，就会用硬编码的数据填充。现在我们需要遍历数组并在 DOM 上打印：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You need to include the component in your entry (app) component for it to show
    up:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将组件包含在你的入口（app）组件中，才能使其显示：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your app should look like the following (remember to include Bootstrap as seen
    in [Chapter 2](1388eb32-f9cf-4efd-86fe-dc3f201ed039.xhtml), *Getting Started with
    TypeScript*):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用应该看起来像下面这样（记得包括第 2 章[1388eb32-f9cf-4efd-86fe-dc3f201ed039.xhtml]中提到的 Bootstrap，*使用
    TypeScript 入门*）：
- en: '![](img/d857dd7f-3771-4c0f-b578-17ce88a96779.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d857dd7f-3771-4c0f-b578-17ce88a96779.png)'
- en: This example works, but the devil lies in the detail. When another component
    needs a list of comments or a portion of the list, we end up recreating the comments.
    This is the problem with having data in components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是可行的，但魔鬼藏在细节中。当另一个组件需要一个评论列表或列表的一部分时，我们最终会重新创建评论。这就是组件中存在数据的问题。
- en: Data class services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类服务
- en: For the sake of reusability and maintainability, we need to abstract the logic
    concerns out of the component and let the component just serve as a presentation
    layer. This is one of those use cases where TypeScript services in Angular come
    into play.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可重用性和可维护性，我们需要将逻辑关注点从组件中抽象出来，让组件仅作为表示层。这就是 TypeScript 在 Angular 中的服务发挥作用的情况之一。
- en: 'You first need to create a service with the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要使用以下命令创建一个服务：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This creates your service class, `./src/app/comment.service.ts`, with a scaffold
    content. Update the content with the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建你的服务类 `./src/app/comment.service.ts`，并带有脚手架内容。更新内容如下：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The class now does whatever our component was supposed to do with the data,
    and the data is fetched using the `getComments` method, which simply returns an
    array of comments. The `CommentService` class is also decorated; this is not required
    unless the class has dependencies to be resolved. Nonetheless, good practice demands
    that we always decorate with `Injectable` to know that a class is meant to be
    a service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个类现在做的是我们的组件本应使用数据做的事情，数据是通过 `getComments` 方法获取的，该方法简单地返回一个评论数组。`CommentService`
    类也被装饰了；除非类有需要解析的依赖关系，否则这不是必需的。尽管如此，良好的实践要求我们始终使用 `Injectable` 装饰，以了解一个类是否意味着要成为一个服务。
- en: 'Back with our list component, we just import the class, resolve the dependency
    from the constructor to create an instance of the service class, and then populate
    the property with the `getComments` return value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的列表组件，我们只需导入类，从构造函数中解析依赖关系以创建服务类的一个实例，然后使用 `getComments` 返回值填充属性：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s attempt to run the app with these current changes in our browser and
    see whether things still work as expected:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在浏览器中运行这些当前更改，看看是否仍然按预期工作：
- en: '![](img/8e3c6caa-3823-455d-9791-2546bf4e64f0.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e3c6caa-3823-455d-9791-2546bf4e64f0.png)'
- en: Hell, no! It just blew up. What could have gone wrong? The error message reads
    No provider for CommentService!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 见鬼，它爆炸了。出了什么问题？错误信息显示没有为 CommentService 提供提供者！
- en: 'Remember that, when we scaffold components with the `ng` CLI command, the CLI
    not only creates a component but also adds it to our declaration array in the
    decorator of `ngModule`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们使用 `ng` CLI 命令搭建组件时，CLI 不仅创建了一个组件，还将它添加到 `ngModule` 装饰器的声明数组中：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Modules need to know which components and services belong to them as members.
    This is why the component is added automatically for you. This is not the same
    for services because the CLI doesn''t automatically update the module (it warns
    you during the scaffold) when you create service classes via the CLI tool. We
    need to add the service manually via the `providers` array:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 模块需要知道哪些组件和服务属于它们作为成员。这就是为什么组件会自动为你添加。对于服务来说，情况并不相同，因为CLI不会自动更新模块（在脚手架期间会警告你），当你通过CLI工具创建服务类时。我们需要通过`providers`数组手动添加服务：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, run the app once more to see how our service now powers the app with no
    more errors in the console:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行应用程序，看看我们的服务现在如何使应用程序运行，且控制台没有更多错误：
- en: '![](img/b6d2e1c8-27d6-4690-ad1e-ba2f1c79e877.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6d2e1c8-27d6-4690-ad1e-ba2f1c79e877.png)'
- en: If there is a need to manipulate the data, it must be done in the service and
    not in the component. Assuming you want to delete a comment by double-clicking
    on each item in the list, it's fine to receive the event with the component but
    the actual deletion should be handled by the service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要操作数据，必须在服务中而不是在组件中完成。假设你想通过双击列表中的每个项目来删除评论，接收组件上的事件是可以的，但实际的删除应该由服务处理。
- en: 'Start by adding an event listener to the list items:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为列表项添加一个事件监听器：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `dblclick` event is triggered by double-clicking the items. When this happens,
    we call the `removeComment` method while passing the comment we want to remove
    from the item.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`dblclick`事件是在双击项目时触发的。当发生这种情况时，我们会调用`removeComment`方法，并传递要从项目中删除的评论。'
- en: 'Here is what `removeComment` looks like in the component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是组件中`removeComment`的样子：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, it doesn''t do anything more than calling a method on our service,
    which is also called `removeComment`. This is the method that has the actual responsibility
    of removing items from the array of comments:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它所做的不仅仅是调用我们的服务上的一个方法，这个方法也被称为`removeComment`。这是负责从评论数组中删除项的实际责任方法：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Component interaction with services
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件与服务之间的交互
- en: This is a very handy use case for services. In [chapter 6](70f76e99-3d5b-43d6-90ad-5ea049aa622c.xhtml), *Component
    Composition with* TypeScript, we discussed how components interact with each other
    and showed different ways of doing it. One of those ways was left out--using a
    service as an event hub/communication platform for different components.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对服务的一个非常有用的用例。在[第6章](70f76e99-3d5b-43d6-90ad-5ea049aa622c.xhtml)，“使用TypeScript进行组件组合”，我们讨论了组件如何相互交互，并展示了不同的实现方式。其中一种方式被省略了——使用服务作为不同组件的事件中心/通信平台。
- en: 'Let''s assume again that, when an item in the list is clicked, we use a sibling
    component to the comment list component to show a detailed view of the selected
    comment. First, we need to create this component:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当列表中的一个项目被点击时，我们使用与评论列表组件相邻的组件来显示选中的评论的详细视图。首先，我们需要创建这个组件：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, you can update the `app.component.html` file to show the added component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以更新`app.component.html`文件以显示添加的组件：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we need to define what our component does, because it''s empty right now.
    But before that, let''s update the comment service to also serve as a hub between
    the list component and the sibling detail component:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们的组件要做什么，因为它现在还是空的。但在那之前，让我们更新评论服务，使其同时作为列表组件和相邻的详细组件之间的枢纽：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The service now uses an Rx subject to create a stream and a listener, which
    the selected comment is pushed through and fetched from. The `commentSelectedSource` object
    is responsible for adding a comment to the stream when the comment is clicked.
    The `commetSelected$` object is an observable that we can subscribe to and act
    on when this comment is clicked.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务使用Rx subject创建一个流和一个监听器，选中的评论会通过这个流推送并获取。当评论被点击时，`commentSelectedSource`对象负责将评论添加到流中。`commetSelected$`对象是一个可观察对象，我们可以在评论被点击时订阅并对其操作。
- en: 'Now, head right back to your component and add a click event to select the
    comment item:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直接回到你的组件中，添加一个点击事件以选择评论项：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The click event triggers a `showComment` method on the component, which, in
    turn, calls `showComment` on the service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 点击事件会在组件上触发一个`showComment`方法，该方法反过来会调用服务中的`showComment`方法：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We still have to update the comment detail component, so it subscribes to the
    observable we created in the class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要更新评论详情组件，使其订阅我们在类中创建的可观察对象：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the `ngOnInit` lifecycle hook, we are able to create a subscription to
    the observable once the component is ready. There is a comment property that will
    be bound to the view, and this property is updated via the subscription every
    time a comment item is clicked. Here is the template for the component showing
    the selected comment:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngOnInit`生命周期钩子，一旦组件准备就绪，我们就可以创建对可观察对象的订阅。有一个评论属性将被绑定到视图上，并且每次点击评论项时，该属性都会通过订阅进行更新。以下是显示所选评论的组件模板：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can start the app again and try selecting a comment. You should see the
    following behavior:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次启动应用程序并尝试选择一条评论。你应该看到以下行为：
- en: '![](img/48b9955d-ace1-4e62-9f8a-3a88ab63ddef.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48b9955d-ace1-4e62-9f8a-3a88ab63ddef.png)'
- en: Services as utilities
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务作为实用工具
- en: 'Apart from managing state and component interaction, services are also known
    for handling utility operations. Let''s say that we want to start collecting new
    comments in our comment app. We don''t know much about forms yet, so we can use
    the browser''s prompt. We expect the user to pass both the username and the content
    via the same textbox in the prompt, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理状态和组件交互外，服务还以处理实用操作而闻名。假设我们想在我们的评论应用中开始收集新的评论。我们对表单了解不多，因此可以使用浏览器的提示。我们期望用户通过提示中的同一个文本框传递用户名和内容，如下所示：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Therefore, we need a utility method to extract these bits from the textbox
    into a comment object with the author and content properties. Let''s start with
    collecting the information from the comment list component:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个实用方法来从文本框中提取这些信息到一个具有作者和内容属性的评论对象中。让我们从收集评论列表组件的信息开始：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `showPrompt()` method is used to collect the user input, and the input
    is passed to the `parseComment` method on the service. This method is an example
    of a utility method, and we will implement it soon. We will also implement the
    `addComment` method, which is called with the parsed comment to update the list
    of comments. Next, add a button to the view with a click event listener that triggers
    `showPrompt`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`showPrompt()`方法用于收集用户输入，并将输入传递到服务的`parseComment`方法。这是一个实用方法的例子，我们很快就会实现它。我们还将实现`addComment`方法，该方法使用解析后的评论来更新评论列表。接下来，向视图中添加一个按钮，并添加一个点击事件监听器，该监听器触发`showPrompt`：'
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add these two methods to the comment service:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两种方法添加到评论服务中：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `parseComment` method takes a string, splits the string, and gets the author
    and content of the comment. Then, it returns the comment. The addComment method
    takes a comment and adds it to the list of existing comments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseComment`方法接受一个字符串，分割该字符串，并获取评论的作者和内容。然后，它返回评论。`addComment`方法接受一个评论并将其添加到现有评论列表中。'
- en: 'Now, you can start adding new comments, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始添加新的评论，如下面的截图所示：
- en: '![](img/31cc7b09-e373-4aa9-9fa7-f4ef30bd706d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31cc7b09-e373-4aa9-9fa7-f4ef30bd706d.png)'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter exposed a lot of interesting concepts in data abstraction, while
    utilizing the power of dependency injection. You learned how components interact
    with each other using a service as a hub, how data and logic are abstracted from
    a component to services, and how reusable utility code is handled in a service
    to keep your application clean. In the next chapter, you'll learn a practical
    approach to forms in Angular and DOM events.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章揭示了数据抽象中的许多有趣概念，同时利用了依赖注入的力量。你学习了组件如何通过服务作为中心进行交互，数据逻辑如何从组件抽象到服务，以及如何在服务中处理可重用的实用代码以保持应用程序的整洁。在下一章中，你将学习Angular中表单的实用方法以及DOM事件。
