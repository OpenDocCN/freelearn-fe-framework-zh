- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Server-Side Rendering with Next.js or Remix
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Next.js 或 Remix 进行服务器端渲染
- en: Not all of our applications are rendered on the client side. Using frameworks
    that leverage **server-side rendering** (**SSR**) is common nowadays. These frameworks
    have helped improve application performance, and their adoption is growing daily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有我们的应用程序都在客户端渲染。如今，使用利用 **服务器端渲染**（**SSR**）的框架是很常见的。这些框架有助于提高应用程序的性能，并且它们的采用率每天都在增长。
- en: 'Now, when using these frameworks, most of the time, we tend to perform data
    fetching or mutations on the server side, which leads to the question:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用这些框架时，大多数情况下，我们倾向于在服务器端执行数据获取或突变，这引发了一个问题：
- en: Do I still need React Query with an SSR framework?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我在使用 SSR 框架时还需要 React Query 吗？
- en: In this chapter, you’ll understand how React Query fits with frameworks such
    as `initialData` and `hydrate`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 React Query 如何与 `initialData` 和 `hydrate` 等框架相结合。
- en: Once you are familiar with these patterns, you will see how to apply them to
    your Next.js and Remix applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您熟悉了这些模式，您将了解如何将它们应用到您的 Next.js 和 Remix 应用程序中。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why should I use React Query with server-side rendering frameworks?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我应该使用 React Query 与服务器端渲染框架一起使用？
- en: Using the `initialData` pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `initialData` 模式
- en: Using the `hydrate` pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `hydrate` 模式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_7)。
- en: Why should I use React Query with server-side rendering frameworks?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我应该使用 React Query 与服务器端渲染框架一起使用？
- en: SSR has proven to be a good ally to web developers. With an increase in the
    popularity of full-stack frameworks such as Next.js and, most recently, Remix,
    the React ecosystem has changed, leading to new patterns being applied.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SSR 已经被证明是网络开发者的好帮手。随着全栈框架如 Next.js 和最近出现的 Remix 的流行，React 生态系统已经发生了变化，导致新的模式被应用。
- en: What is server-side rendering (SSR)?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是服务器端渲染（SSR）？
- en: SSR is a process that allows you to render your application on the server instead
    of the browser. During this process, the server sends the rendered page to the
    client. The client then makes the page fully interactive through a process called
    hydration.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SSR 是一个允许你在服务器上而不是在浏览器上渲染应用程序的过程。在这个过程中，服务器将渲染的页面发送到客户端。然后客户端通过一个称为“水合”的过程使页面完全交互式。
- en: Owing to the possibility of using SSR, one of the things that might make sense
    to do is fetch your data on the server. This has many advantages, but one of the
    best is giving your users their pages with the initial data already loaded. Now,
    just because you are loading data on the server side doesn’t invalidate the scenarios
    in which you might need to fetch your data on the client side. If your page contains
    frequently updated data on the client side, React Query continues to be your best
    friend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以使用 SSR，可能值得做的事情之一是在服务器上获取数据。这有许多优点，但其中最好的是向用户提供已经加载了初始数据的页面。现在，仅仅因为你在服务器端加载数据，并不意味着你不需要在客户端获取数据的情况。如果你的页面包含客户端上频繁更新的数据，React
    Query 仍然是你最好的朋友。
- en: But how does React Query fit within our code using frameworks such as Next.js
    or Remix? Will we fetch data on the server and then on the client again?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但 React Query 是如何与 Next.js 或 Remix 等框架结合到我们的代码中的？我们会在服务器上获取数据，然后再在客户端获取吗？
- en: The short answer is no. If we did that, we would just be wasting memory on the
    server and not leveraging the advantages of SSR. What we can do instead is prefetch
    our data on the server side and feed it to React Query so that it can manage it
    on the client side. That way, when the user gets the page, the page will already
    have the data the user needs, and from that point on, React Query takes care of
    everything.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是不。如果我们那样做，我们只是在服务器上浪费内存，而没有利用 SSR 的优势。我们可以做的是在服务器端预取数据，并将其提供给 React Query，以便它在客户端管理。这样，当用户获取页面时，页面已经包含了用户所需的数据，从那时起，React
    Query 就会负责一切。
- en: 'We can apply two patterns to prefetch data on the server and send it to React
    Query on the client side. They are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将两种模式应用于服务器上的预取数据，并将其发送到客户端的 React Query。它们如下：
- en: The `initialData` pattern
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialData` 模式'
- en: The `hydrate` pattern
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hydrate` 模式'
- en: 'In the next section, we will learn how to leverage the `initialData` pattern
    and apply it to the frameworks mentioned: Next.js and Remix.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何利用`initialData`模式并将其应用到所提到的框架中：Next.js和Remix。
- en: Using the initialData pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用initialData模式
- en: The `initialData` pattern is an option you can set in your `useQuery` hook.
    With this option, you can feed `useQuery` with the data that it will use to initialize
    a specific query.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialData`模式是你可以在`useQuery`钩子中设置的选项。使用这个选项，你可以向`useQuery`提供它将用于初始化特定查询的数据。'
- en: 'This is the process of how to leverage the best of your server-side framework
    and React Query with the `initialData` option:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何利用服务器端框架的最佳功能和React Query的`initialData`选项的过程：
- en: The first thing you do is prefetch your data on the server side and send it
    to your component.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先在服务器端预先获取你的数据并将其发送到你的组件。
- en: Inside your component, you render your query using the `useQuery` hook.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的组件内部，你使用`useQuery`钩子渲染你的查询。
- en: Inside this hook, you add the `initialData` option and pass the data you prefetched
    on the server to it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个钩子内部，你添加`initialData`选项，并将你在服务器端预先获取的数据传递给它。
- en: Let’s now see how to use this pattern in Next.js.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在Next.js中使用这个模式。
- en: Applying the initialData pattern in Next.js
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Next.js中应用initialData模式
- en: 'In the following snippet, we will fetch some data on the server using Next.js
    `getServerSideProps` and then leverage the `initialData` pattern to feed the data
    to React Query:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将使用Next.js的`getServerSideProps`在服务器上获取一些数据，然后利用`initialData`模式将数据传递给React
    Query：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding snippet, we apply the `initialData` pattern to a Next.js application.
    Here, we have a component that will be server-side-generated. This is what we
    are doing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将`initialData`模式应用到Next.js应用程序中。这里，我们有一个将服务器端生成的组件。这就是我们在这里所做的事情：
- en: We do the necessary imports for this component. In this scenario, it’s `axios`
    and our `useQuery` hook.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个组件做必要的导入。在这个场景中，是`axios`和我们的`useQuery`钩子。
- en: We create our query function. In this function, we get access to our query key
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的查询函数。在这个函数中，我们获取到我们的查询键，并从查询键中解构出用户名以执行我们的`GET`请求。然后我们返回我们的查询数据。
- en: Since we want this page to be server-side-rendered, we include the `getServerSideProps`
    function in it. This function will run on the server side, and in it, we call
    our `fetchData` function to get our server state data and return it as props,
    which will be sent to our `InitialData` component.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望这个页面是服务器端渲染的，所以我们将其中的`getServerSideProps`函数包含在内。这个函数将在服务器端运行，在其中，我们调用我们的`fetchData`函数来获取我们的服务器状态数据并将其作为props返回，这些props将被发送到我们的`InitialData`组件。
- en: In our `InitialData` component, we get access to our `props`. In these `props`,
    we can access the data returned from our `getServerSideProps` function. We then
    pass this data to our created `useQuery` instance as the `initialData` option.
    This means this hook will have the data we fetched at build time as its initial
    data before refetching it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`InitialData`组件中，我们获取到我们的`props`。在这些`props`中，我们可以访问从我们的`getServerSideProps`函数返回的数据。然后我们将这些数据传递给我们的创建的`useQuery`实例作为`initialData`选项。这意味着这个钩子在重新获取之前将具有我们在构建时获取的数据作为其初始数据。
- en: Now that you know how to apply this pattern in Next.js, let us do it in Remix.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在Next.js中应用这个模式，让我们在Remix中做同样的事情。
- en: Applying the initialData pattern in Remix
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Remix中应用initialData模式
- en: 'In the following snippet, we will fetch some data on the server using the Remix
    `loader` and then leverage the `initialData` pattern to feed the data to React
    Query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将使用Remix的`loader`在服务器上获取一些数据，然后利用`initialData`模式将数据传递给React Query：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding snippet, we apply the `initialData` pattern to a Remix application.
    This is what we are doing here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将`initialData`模式应用到Remix应用程序中。这就是我们在这里所做的事情：
- en: We do the necessary imports for this component. In this scenario, it’s `axios`,
    our `useQuery` hook, Remix’s `useLoaderData` hook, and a `json` function.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个组件做必要的导入。在这个场景中，是`axios`、我们的`useQuery`钩子、Remix的`useLoaderData`钩子和一个`json`函数。
- en: We create our query function. In this function, we get access to our query key
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的查询函数。在这个函数中，我们获取到我们的查询键，并从查询键中解构出用户名以执行我们的`GET`请求。然后我们返回我们的查询数据。
- en: We then create our `loader` function. This is the function Remix uses to allow
    you to load the data on the server side that will be needed in your components.
    Inside it, we fetch our data and then use the `json` function to send an `HTTP`
    response with `application/json content-type` as the header and our data included
    in it.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来创建我们的 `loader` 函数。这是 Remix 用来允许你在服务器端加载将在你的组件中需要的数据的函数。在其内部，我们获取我们的数据，然后使用
    `json` 函数发送一个带有 `application/json` 内容类型头和包含数据的 `HTTP` 响应。
- en: In our `InitialData` component, we leverage `useLoaderData` to get access to
    the data returned by `loader`. We then pass this data to our created `useQuery`
    instance as the `initialData` option. This means this hook will have the data
    we fetched at build time as its initial data before refetching it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `InitialData` 组件中，我们利用 `useLoaderData` 来获取 `loader` 返回的数据。然后我们将这些数据传递给我们的
    `useQuery` 实例作为 `initialData` 选项。这意味着这个钩子在重新获取之前将构建时获取的数据作为其初始数据。
- en: 'By now, you should be able to use the `initialData` pattern. There are a couple
    of things you need to be aware of to use it more effectively:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够使用 `initialData` 模式。为了更有效地使用它，你需要注意以下几点：
- en: If you have multiple instances of the same query in different places, you must
    always pass `initialData` to them. This means that even if you leverage your query
    at the top level and on a child component, you will have to prop-drill your `initialData`
    until it reaches the desired component that needs the data.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在不同位置有相同查询的多个实例，你必须始终向它们传递 `initialData`。这意味着即使你在顶层和子组件中利用查询，你也必须通过 prop-drill
    将 `initialData` 传递到需要数据的期望组件。
- en: Since you fetch the data on the server and pass it to your hook, React Query
    will base the information it needs to identify when your query was rendered on
    the initial page load instead of the time at which it was fetched on the server.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你在服务器上获取数据并将其传递到你的 hook，React Query 将基于初始页面加载时而不是服务器上获取数据的时间来识别你的查询何时被渲染。
- en: 'Let us now see the second pattern you can leverage when using React Query with
    server-side-rendered frameworks: the `hydrate` pattern.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你使用支持服务器端渲染的框架与 React Query 结合时可以利用的第二种模式：`hydrate` 模式。
- en: Using the hydrate pattern
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 hydrate 模式
- en: With the `hydrate` pattern, you can dehydrate your `QueryClient` with a previously
    prefetched query and send it to your client. On the client side, as soon as the
    page loads and JavaScript is available, React Query will hydrate your `QueryClient`
    with the existing data. After this process, React Query will also ensure your
    queries are up to date.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `hydrate` 模式，你可以使用之前预取的查询来脱水你的 `QueryClient` 并将其发送到客户端。在客户端，一旦页面加载并且 JavaScript
    可用，React Query 将使用现有数据来 hydrate 你的 `QueryClient`。在此过程之后，React Query 也会确保你的查询是最新的。
- en: 'This is the process of how to leverage the best of your server-side framework
    and React Query with the `hydrate` pattern:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何利用 `hydrate` 模式结合你的服务器端框架和 React Query 的最佳实践的过程：
- en: The first thing you do is create a `QueryClient` instance.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先要做的是创建一个 `QueryClient` 实例。
- en: Using the previously created `QueryClient` instance, you leverage its `prefetchQuery`
    method to prefetch the data for that given query key.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前创建的 `QueryClient` 实例，你利用其 `prefetchQuery` 方法来预取给定查询键的数据。
- en: You dehydrate your `QueryClient` and send it to the client side.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将你的 `QueryClient` 脱水并发送到客户端。
- en: Your client receives the dehydrated state, hydrates it, and merges it with the
    `QueryClient` in use.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的客户端接收脱水状态，将其 hydrate 并与正在使用的 `QueryClient` 合并。
- en: Inside your component, you render your query using the `useQuery` hook with
    the same query key you added in *step 2*. Your query will already have its data.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的组件内部，你使用 `useQuery` 钩子以与你在 *步骤 2* 中添加的相同查询键渲染你的查询。你的查询将已经包含其数据。
- en: 'In the next section, we will learn how to leverage the `hydrate` pattern and
    apply it to the frameworks mentioned: Next.js and Remix.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何利用 `hydrate` 模式并将其应用于所提到的框架：Next.js 和 Remix。
- en: Applying the hydrate pattern in Next.js
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Next.js 中应用 hydrate 模式
- en: Next.js uses the `_app` component to initialize all your pages and allows you
    to keep some shared state or persist layouts between page changes. Due to this,
    we can leverage it to wrap all our components with `Hydrate`. The `Hydrate` wrapper
    is responsible for receiving `dehydratedState` and hydrating it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js 使用 `_app` 组件来初始化所有页面，并允许你在页面变化之间保持一些共享状态或持久化布局。由于这个原因，我们可以利用它来用 `Hydrate`
    包装所有我们的组件。`Hydrate` 包装器负责接收 `dehydratedState` 并将其 hydrate。
- en: 'Let us now see how to apply this wrapper:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何应用这个包装器：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们执行以下操作：
- en: We do all the necessary imports to set up our components. In this scenario,
    we get the `useState` function from React and `Hydrate`, `QueryClient`, and `QueryClientProvider`
    from React Query.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行所有必要的导入以设置我们的组件。在这个场景中，我们从 React 获取 `useState` 函数，并从 React Query 获取 `Hydrate`、`QueryClient`
    和 `QueryClientProvider`。
- en: 'Inside our `App` component, we do the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `App` 组件内部，我们执行以下操作：
- en: We start by creating a new `QueryClient` instance and assigning it as a `state`
    variable by using the `useState` hook. This is because we need to make sure this
    data is not shared by different users of our application and requests. This will
    also make sure we only create `QueryClient` once.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的 `QueryClient` 实例，并使用 `useState` 钩子将其分配为 `state` 变量。这是因为我们需要确保这些数据不会被我们应用程序的不同用户和请求共享。这将确保我们只创建一次
    `QueryClient`。
- en: We then pass our `queryClient` to `QueryClientProvider` to initiate it and allow
    it to be accessed by our React Query hooks. `QueryClientProvider` will also wrap
    our `Component`.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后将我们的 `queryClient` 传递给 `QueryClientProvider` 以初始化它，并允许它被我们的 React Query
    钩子访问。`QueryClientProvider` 还将包裹我们的 `Component`。
- en: Finally, we also wrap our `Component` with `Hydrate`. Since `Hydrate` needs
    to receive `dehydratedState` whenever it exists, we get `pageProps` from our `App`
    and pass it to our `Hydrate` state property. This means that for every component
    that receives `dehydratedState` as `props`, these `props` will be passed to our
    `Hydrate` wrapper.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还用 `Hydrate` 包裹了我们的 `Component`。由于 `Hydrate` 需要接收 `dehydratedState`，无论它是否存在，我们从我们的
    `App` 中获取 `pageProps` 并将其传递给我们的 `Hydrate` 状态属性。这意味着对于每个接收 `dehydratedState` 作为
    `props` 的组件，这些 `props` 将被传递给我们的 `Hydrate` 包装器。
- en: 'Now, we are all set to start dehydrating data. Let us see how we can do it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始脱水数据。让我们看看我们如何做到这一点：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we prefetch some data, which will be dehydrated and
    then hydrated by React Query. Here is what we are doing:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们预取了一些数据，这些数据将被 React Query 脱水和再水化。以下是我们的操作：
- en: We do the necessary imports for this component. In this scenario, it’s `axios`,
    and from the React Query side, the `dehydrate` function, `QueryClient`, and the
    `useQuery` hook.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为此组件进行必要的导入。在这个场景中，它是 `axios`，并且从 React Query 方面，是 `dehydrate` 函数、`QueryClient`
    和 `useQuery` 钩子。
- en: We create our query function. In this function, we get access to our query key,
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的查询函数。在这个函数中，我们获取对查询键的访问权限，并从查询键中解构 `username` 以执行我们的 `GET` 请求。然后我们返回我们的查询数据。
- en: 'In `getServerSideProps`, we do the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `getServerSideProps` 中，我们执行以下操作：
- en: We create a new `QueryClient` instance.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的 `QueryClient` 实例。
- en: 'We then leverage the previously created instance to prefetch a query that will
    be cached under the `[{ queryIdentifier: "api", username: "danieljcafonso" }]`
    query key and use `fetchData` as the query function.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，我们利用之前创建的实例来预取一个查询，该查询将在 `[{ queryIdentifier: "api", username: "danieljcafonso"
    }]` 查询键下缓存，并使用 `fetchData` 作为查询函数。'
- en: We use `dehydrate` on `queryClient` and return it as `props` so it can be picked
    up in our `App` component.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `queryClient` 上使用 `dehydrate` 并将其作为 `props` 返回，以便它可以在我们的 `App` 组件中被捕获。
- en: 'In our `SSR` component, we create a `useQuery` hook with `[{ queryIdentifier:
    "api", username: "danieljcafonso" }]` as the query key and `fetchData` as the
    query function.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在我们的 `SSR` 组件中，我们使用 `[{ queryIdentifier: "api", username: "danieljcafonso"
    }]` 作为查询键和 `fetchData` 作为查询函数创建了一个 `useQuery` 钩子。'
- en: Given that we returned `dehydratedState` from our `getServerSideProps` function,
    this will be passed as `pageProps` and picked up by the `Hydrate` wrapper wrapping
    our component. This means that React Query will pick up our dehydrated state,
    hydrate it, and merge this new data with the current data in `QueryClient`. This
    means that when the hook inside `SSR` first runs, it will already have the data
    prefetched from `getServerSidePros`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从 `getServerSideProps` 函数中返回了 `dehydratedState`，这将作为 `pageProps` 传递并被 `Hydrate`
    包装器捕获，包裹我们的组件。这意味着 React Query 将捕获我们的脱水状态，对其进行水化，并将这些新数据与 `QueryClient` 中的当前数据合并。这意味着当
    `SSR` 内部的钩子第一次运行时，它将已经从 `getServerSidePros` 预取了数据。
- en: Now that you know how to apply this pattern to Next.js, let us do it in Remix.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何将此模式应用于 Next.js，让我们在 Remix 中这样做。
- en: Applying the hydrate pattern in Remix
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Remix 中应用 hydrate 模式
- en: Remix uses the `root` component to define the root layout of all your pages
    and to allow you to keep some shared state between page changes. The way this
    is done is by using the `Outlet` component. Due to this component and `Outlet`
    at the root level, we can leverage it to wrap all our components with `Hydrate`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 使用 `root` 组件来定义所有页面的根布局，并允许你在页面变化之间保持一些共享状态。这是通过使用 `Outlet` 组件来实现的。由于这个组件和根级别的
    `Outlet`，我们可以利用它来用 `Hydrate` 包装所有我们的组件。
- en: Now, unlike Next.js, there is no way to access `pageProps` to access `dehydratedState`
    at the root level. Therefore, we need to install a third-party package called
    `use-dehydrated-state`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与 Next.js 不同，没有方法可以访问 `pageProps` 来在根级别访问 `dehydratedState`。因此，我们需要安装一个名为
    `use-dehydrated-state` 的第三方包。
- en: 'Here is how to add `use-dehydrated-state` to your project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是向你的项目添加 `use-dehydrated-state` 的方法：
- en: 'If you are running npm in your project, run the following command:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在你的项目中运行 npm，请运行以下命令：
- en: '[PRE4]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are using Yarn, run the following command:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Yarn，请运行以下命令：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are using pnpm, run the following command:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 pnpm，请运行以下命令：
- en: '[PRE6]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`use-dehydrated-state` allows us to access our dehydrated state at our root-level
    component.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`use-dehydrated-state` 允许我们在根级组件中访问我们的脱水状态。'
- en: 'Now, we can do the necessary setup to leverage the `Hydrate` and `QueryClientProvider`
    wrappers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进行必要的设置以利用 `Hydrate` 和 `QueryClientProvider` 包装器：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们执行以下操作：
- en: 'We do all the necessary imports to set up our components. In this scenario,
    we get the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行所有必要的导入以设置我们的组件。在这个场景中，我们得到以下内容：
- en: Remix’s `Outlet`
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Remix 的 `Outlet`
- en: The `useState` function from React
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 React 的 `useState` 函数
- en: '`Hydrate`, `QueryClient`, and `QueryClientProvider` from React Query'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 React Query 的 `Hydrate`、`QueryClient` 和 `QueryClientProvider`
- en: The `useDehydratedState` hook from `use-dehydrated-state`
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 `use-dehydrated-state` 的 `useDehydratedState` 钩子
- en: 'Inside our `App` component, we do the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `App` 组件内部，我们执行以下操作：
- en: We start by creating a new `QueryClient` instance and assigning it as a `state`
    variable by using the `useState` hook. This is because we need to make sure this
    data is not shared by different users of our application and requests. This will
    also make sure we only create `QueryClient` once.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的 `QueryClient` 实例，并使用 `useState` 钩子将其分配为 `state` 变量。这是因为我们需要确保这些数据不会被我们的应用程序的不同用户和请求共享。这将确保我们只创建一次
    `QueryClient`。
- en: We then pass our `queryClient` to `QueryClientProvider` to initiate it and allow
    it to be accessed by our React Query hooks. `QueryClientProvider` will also wrap
    the component rendered by `Outlet`.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `queryClient` 传递给 `QueryClientProvider` 以启动它，并允许它被我们的 React Query 钩子访问。`QueryClientProvider`
    还会包装由 `Outlet` 渲染的组件。
- en: Finally, we also wrap `Outlet` with `Hydrate`. Since `Hydrate` needs to receive
    `dehydratedState` whenever it is received from the server, we get it from the
    `useDehydratedState` hook. This means that for every component that receives `dehydratedState`
    from its `loader`, this data will be passed to our `Hydrate` wrapper.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还将 `Outlet` 用 `Hydrate` 包装起来。由于 `Hydrate` 需要在从服务器接收到 `dehydratedState`
    时接收它，我们从 `useDehydratedState` 钩子中获取它。这意味着对于从其 `loader` 接收 `dehydratedState` 的每个组件，这些数据将被传递给我们的
    `Hydrate` 包装器。
- en: 'Now, we are all set to start dehydrating data. Let us see how to do it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始脱水数据。让我们看看如何操作：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding snippet, we are prefetching some data, which will be dehydrated
    and then hydrated by React Query. Here is what we are doing:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在预取一些数据，这些数据将被 React Query 脱水和再水化。以下是我们的操作：
- en: 'We do the necessary imports for this component. In this scenario, they are
    as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个组件进行必要的导入。在这个场景中，它们如下所示：
- en: The `axios` client
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`axios` 客户端'
- en: The `dehydrate` function, `QueryClient`, and the `useQuery` hook from the React
    Query side
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自 React Query 的 `dehydrate` 函数、`QueryClient` 和 `useQuery` 钩子
- en: The `json` function from Remix
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Remix 的 `json` 函数
- en: We create our query function. In this function, we get access to our query key
    and destructure our username from the query key to perform our `GET` request.
    We then return our query data.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的查询函数。在这个函数中，我们获取查询键的访问权限，并从查询键中解构用户名以执行我们的 `GET` 请求。然后我们返回我们的查询数据。
- en: 'In `loader`, we do the following:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `loader` 中，我们执行以下操作：
- en: We create a new `QueryClient` instance.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的 `QueryClient` 实例。
- en: 'We then leverage the previously created instance to prefetch a query that will
    be cached under the `[{ queryIdentifier: "api", username: "danieljcafonso" }]`
    query key and use `fetchData` as the query function.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们随后利用先前创建的实例来预取一个查询，该查询将在`[{ queryIdentifier: "api", username: "danieljcafonso"
    }]`查询键下缓存，并使用`fetchData`作为查询函数。'
- en: We then use `dehydrate` for `queryClient` and return it as an `HTTP` response.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`dehydrate`对`queryClient`进行操作，并将其作为`HTTP`响应返回。
- en: 'In our `Index` component, we create a `useQuery` hook with `[{ queryIdentifier:
    "api", username: "danieljcafonso" }]` as the query key and `fetchData` as the
    query function.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在我们的`Index`组件中，我们使用`[{ queryIdentifier: "api", username: "danieljcafonso" }]`作为查询键，并使用`fetchData`作为查询函数创建一个`useQuery`钩子。'
- en: Given that we returned `dehydratedState` from our `loader` function, this will
    be picked up by `useDehydratedState` and passed to our `Hydrate` wrapper, wrapping
    our component. This means that React Query will pick up `dehydratedState`, hydrate
    it, and merge this new data with the current data in `QueryClient`. Due to this
    process, when the hook inside `Index` first runs, it will already have the data
    that we prefetched from `loader`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`loader`函数中返回了`dehydratedState`，这将由`useDehydratedState`捕获并传递给我们的`Hydrate`包装器，包裹我们的组件。这意味着React
    Query将捕获`dehydratedState`，对其进行解冻，并将这些新数据与`QueryClient`中当前的数据合并。由于这个过程，当`Index`内部的钩子第一次运行时，它已经拥有了从`loader`中预取的数据。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us how React Query can complement our server-side-rendered
    applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教会了我们如何使用React Query补充我们的服务器端渲染应用程序。
- en: You learned how React Query enables you to prefetch data on the server and send
    it to React Query on the client side. To do this, you got to know two patterns,
    `initialData` and `hydrate`. In the `initialData` pattern, you prefetch the data
    on the server and pass it to the `initialData` option in the `useQuery` hook on
    the client side. In the `hydrate` pattern, you prefetch your query on the server,
    dehydrate the query cache, and hydrate it on the client side.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用React Query在服务器端预取数据并将其发送到客户端的React Query。为此，你需要了解两种模式，`initialData`和`hydrate`。在`initialData`模式中，你在服务器端预取数据并将其传递到客户端`useQuery`钩子的`initialData`选项中。在`hydrate`模式中，你在服务器端预取查询，解冻查询缓存，并在客户端进行解冻。
- en: 'In [*Chapter 8*](B18501_08.xhtml#_idTextAnchor184), *Testing React Query Hooks
    and Components*, we will focus on one of the things that will help you sleep better
    at night: testing. You will get to know how you can test your component, that
    is, using React Query, as well as some custom hooks for improving your developer
    experience.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18501_08.xhtml#_idTextAnchor184) *测试React Query钩子和组件*中，我们将关注帮助你夜晚睡得更好的事情之一：测试。你将了解如何测试你的组件，即使用React
    Query，以及一些自定义钩子来提高你的开发者体验。
