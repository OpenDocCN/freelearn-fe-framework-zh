<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer028">
<h1 class="chapterNumber">5</h1>
<h1 class="chapterTitle" id="_idParaDest-86">Writing Code for the Browser </h1>
<p class="normal">There are some specific operations we can conduct when we work with React and the browser. For example, we can ask our users to enter some information using forms. In this chapter, we will look at how we can apply different techniques to deal with forms. We can implement <strong class="keyWord">uncontrolled components</strong> and let the fields keep their internal states, or we can use controlled ones where we have full control over the state of the fields.</p>
<p class="normal">In this chapter, we will also look at how events in React work and how the library implements some advanced techniques to give us a consistent interface across different browsers. We will look at some interesting solutions that the React team has implemented to make the event system very performant.</p>
<p class="normal">After events, we will jump into <strong class="keyWord">refs</strong> to look at how we can access the underlying <strong class="keyWord">DOM</strong> nodes in our React components. This represents a powerful feature, but it should be used carefully because it breaks some of the conventions that make React easy to work with.</p>
<p class="normal">After refs, we will look at how we can implement animations easily with the React add-ons. Finally, we will learn how easy it is to work with <strong class="keyWord">Scalable Vector Graphics</strong> (<strong class="keyWord">SVG</strong>) in React, and how we can create dynamically configurable icons for our applications.</p>
<p class="normal">In this chapter, we will go through the following topics:</p>
<ul>
<li class="bulletList">Using different techniques to create forms with React</li>
<li class="bulletList">Listening to DOM events and implementing custom handlers</li>
<li class="bulletList">A way of performing imperative operations on DOM nodes using refs</li>
<li class="bulletList">Creating simple animations that work across different browsers</li>
<li class="bulletList">The React way of generating SVG</li>
</ul>
<h1 class="heading-1" id="_idParaDest-87">Technical requirements</h1>
<p class="normal">To complete this chapter, you will need the following:</p>
<ul>
<li class="bulletList">Node.js 19+</li>
<li class="bulletList">Visual Studio Code</li>
</ul>
<p class="normal">You can find the code for this chapter in the book’s GitHub repository: <a href="https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05"><span class="url">https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter05</span></a>. </p>
<h1 class="heading-1" id="_idParaDest-88">Understanding and implementing forms</h1>
<p class="normal">In this section, we are going to learn how to implement forms with React. As soon as we start building a real application with React, we need to interact with the users. If we want to ask for information from our users within the browser, forms are the most common <a id="_idIndexMarker167"/>solution. Due to the way the library works and its declarative nature, dealing with input fields and other form elements is non-trivial with React, but as soon as we understand its logic, it will become clear. In the next sections, we are going to learn how to use uncontrolled and controlled components.</p>
<h2 class="heading-2" id="_idParaDest-89">Uncontrolled components</h2>
<p class="normal"><strong class="keyWord">Uncontrolled components</strong> are like regular HTML form inputs for which you will not be able to manage the <a id="_idIndexMarker168"/>value yourself but instead, the DOM will take care of handling the value and you can get this value by using a React ref. Let’s start with a basic example—displaying a form with an input field and a <code class="inlineCode">Submit</code> button.</p>
<p class="normal">The code is pretty straightforward:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-variable">FC</span>, useState, <span class="hljs-title">ChangeEvent</span>, <span class="hljs-title">MouseEvent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'</span><span class="hljs-string">react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">Uncontrolled</span>: <span class="hljs-variable">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> [value, setValue] = useState&lt;string&gt;(<span class="hljs-string">''</span>)
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> /&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
  )
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Uncontrolled</span>
</code></pre>
<p class="normal">If we run the preceding snippet in the browser, we will see exactly what we expect—an input field in which we can write something and a clickable button. This is an example of an uncontrolled component, where we do not set the value of the input field, but we let the component manage its own internal state.</p>
<p class="normal">Most likely, we want to <a id="_idIndexMarker169"/>do something with the value of the element when the <code class="inlineCode">Submit</code> button is clicked. For example, we may want to send the data to an API endpoint.</p>
<p class="normal">We can do this easily by adding an <code class="inlineCode">onChange</code> listener (we will talk more about event listeners later in this chapter). Let’s look at what it means to add a listener.</p>
<p class="normal">We need to create the <code class="inlineCode">handleChange</code> function:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleChange</span> = (<span class="hljs-params">e: ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
}
</code></pre>
<p class="normal">The event listener is receiving an event object, where the target represents the field that generated the event, and we are interested in its value. We start by just logging it because it is important to proceed with small steps, but we will store the value into the state soon.</p>
<p class="normal">Finally, we render the form:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">If we render the component inside the browser and type the word <code class="inlineCode">React</code> into the form field, we will see something like the following inside the console:</p>
<pre class="programlisting con"><code class="hljs-con">R
Re
Rea
Reac
React
</code></pre>
<p class="normal">The <code class="inlineCode">handleChange</code> listener is fired every time the value of the input changes. Therefore, our function is called once for each typed character. The next step is to store the value that’s entered by the user and make it available when the user clicks the <code class="inlineCode">Submit</code> button.</p>
<p class="normal">We just have to change the implementation of the handler to store it in the state instead of logging it, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleChange</span> = (<span class="hljs-params">e: ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; {
  <span class="hljs-title">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)
}
</code></pre>
<p class="normal">Getting notified of when the form is submitted is very similar to listening to the change event of the input<a id="_idIndexMarker170"/> field; they are both events that are called by the browser when something happens.</p>
<p class="normal">Let’s define the <code class="inlineCode">handleSubmit</code> function, where we just log the value. In a real-world scenario, you could send the data to an API endpoint or pass it to another component:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleSubmit</span> = (<span class="hljs-params">e: MouseEvent&lt;HTMLButtonElement&gt;</span>) =&gt; {
  e.<span class="hljs-title">preventDefault</span>()
  
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(value) <span class="hljs-comment">// Here we are logging the value state</span>
}
</code></pre>
<p class="normal">This handler is pretty straightforward; we just log the value currently stored in the state. We also want to overcome the default behavior of the browser when the form is submitted, to perform a custom action. This seems reasonable, and it works very well for a single field. The question now is, <em class="italic">what if we have multiple fields? Suppose we have tens of different fields?</em></p>
<p class="normal">Let’s start with a basic example, where we create each field and handler manually and look at how we can improve it by applying different levels of optimization.</p>
<p class="normal">Let’s create a new form with first and last name fields. We can reuse the <code class="inlineCode">Uncontrolled</code> component and add some new states:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [firstName, setFirstName] = <span class="hljs-title">useState</span>(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> [lastName, setLastName] = <span class="hljs-title">useState</span>(<span class="hljs-string">''</span>)
</code></pre>
<p class="normal">We initialize the two fields inside the state, and we define an event handler for each one of the fields as well. As you may have noticed, this does not scale very well when there are lots of fields, but it is important to understand the problem clearly before moving to a <a id="_idIndexMarker171"/>more flexible solution.</p>
<p class="normal">Now, we implement the new handlers:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleChangeFirstName</span> = (<span class="hljs-params">{ target: { value } }</span>) =&gt; {
  <span class="hljs-title">setFirstName</span>(value)
}
  
<span class="hljs-keyword">const</span> <span class="hljs-title">handleChangeLastName</span> = (<span class="hljs-params">{ target: { value } }</span>) =&gt; {
  <span class="hljs-title">setLastName</span>(value)
}
</code></pre>
<p class="normal">We also have to change the submit handler a little bit so that it displays the first and the last name when it gets clicked:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleSubmit</span> = (<span class="hljs-params">e: MouseEvent&lt;HTMLButtonElement&gt;</span>) =&gt; {
  e.<span class="hljs-title">preventDefault</span>()
  
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">`</span><span class="hljs-subst">${firstName}</span><span class="hljs-string"> </span><span class="hljs-subst">${lastName}</span><span class="hljs-string">`</span>) <span class="hljs-comment">// Logging the firstName and lastName states</span>
}
</code></pre>
<p class="normal">Finally, we render the form:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag"> </span><span class="hljs-attr">onSubmit</span><span class="hljs-tag">=</span><span class="hljs-string">{handleSubmit}</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChangeFirstName}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChangeLastName}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">We are ready to go: if we run the preceding component in the browser, we will see two fields, and if we type <code class="inlineCode">Carlos</code> into the first one and <code class="inlineCode">Santana</code> into the second one, we will see the full name displayed in the browser console when the form is submitted.</p>
<p class="normal">Again, this works fine, and we can do some interesting things this way, but it does not handle complex scenarios without requiring us to write a lot of boilerplate code.</p>
<p class="normal">Let’s look at how we can optimize it a little bit. Our goal is to use a single change handler so that we can add an arbitrary number of fields without creating new listeners.</p>
<p class="normal">Let’s go back to the component and let’s change our states:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [values, setValues] = <span class="hljs-title">useState</span>({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">''</span> })
</code></pre>
<p class="normal">We may still want to initialize the values, and later in this section, we will look at how to provide prefilled <a id="_idIndexMarker172"/>values for the form.</p>
<p class="normal">Now, the interesting bit is the way in which we can modify the <code class="inlineCode">onChange</code> handler implementation to make it work in different fields:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleChange</span> = (<span class="hljs-params">{ target: { name, value } }</span>) =&gt; {   
  <span class="hljs-title">setValues</span>({
    ...values,
    [name]: value
  })
}
</code></pre>
<p class="normal">As we have seen previously, the <code class="inlineCode">target</code> property of the event we receive represents the input field that has fired the event, so we can use the name of the field and its value as variables.</p>
<p class="normal">We then have to set the name for each field:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag"> </span><span class="hljs-attr">onSubmit</span><span class="hljs-tag">=</span><span class="hljs-string">{handleSubmit}</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">      </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">text"</span>
<span class="hljs-tag">      </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"firstName"</span>
<span class="hljs-tag">      </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span>
<span class="hljs-tag">    /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">      </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span>
<span class="hljs-tag">      </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">lastName"</span>
<span class="hljs-tag">      </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span>
<span class="hljs-tag">    /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">That’s it! We can now add as many fields as we want without creating additional handlers.</p>
<h2 class="heading-2" id="_idParaDest-90">Controlled components</h2>
<p class="normal">A controlled component is a React component that controls the values of input elements in a form by using<a id="_idIndexMarker173"/> the component state.</p>
<p class="normal">Here we are going to look at how we can prefill the form fields with some values, which we may receive from the server or as props from the parent. To understand this concept fully, we will start again from a very simple stateless function component, and we will improve it step by step.</p>
<p class="normal">The first example shows a predefined value inside the input field:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Controlled</span> = () =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">"Hello React"</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">If we run this component inside the browser, we realize that it shows the default value as expected, but it does not let us change the value or type anything else inside it.</p>
<p class="normal">The reason it does this is that in React, we declare what we want to see on the screen, and setting a fixed-value attribute always results in rendering that value, no matter what other actions are taken. This is unlikely to be a behavior we want in a real-world application.</p>
<p class="normal">If we open the console, we get the following error message. React itself is telling us that we are doing something wrong:</p>
<pre class="programlisting con"><code class="hljs-con">You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field.
</code></pre>
<p class="normal">Now, if we just want the input field to have a default value and we want to be able to change it by typing, we can use the <code class="inlineCode">defaultValue</code> property:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">Controlled</span> = () =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">text"</span><span class="hljs-tag"> </span><span class="hljs-attr">defaultValue</span><span class="hljs-tag">=</span><span class="hljs-string">"Hello React"</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
  )
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Controlled</span>
</code></pre>
<p class="normal">In this way, the field is going to show <code class="inlineCode">Hello React</code> when it is rendered, but then the user can type <a id="_idIndexMarker174"/>anything inside it and change its value. Now let’s add some states:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> [values, setValues] = <span class="hljs-title">useState</span>({ <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Carlos'</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Santana'</span> })
</code></pre>
<p class="normal">The handlers are the same as the previous ones:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleChange</span> = (<span class="hljs-params">{ target: { name, value } }</span>) =&gt; {
  <span class="hljs-title">setValues</span>({
    [name]: value
  })
}
  
<span class="hljs-keyword">const</span> <span class="hljs-title">handleSubmit</span> = (<span class="hljs-params">e</span>) =&gt; {
  e.<span class="hljs-title">preventDefault</span>()
  
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">`</span><span class="hljs-subst">${values.firstName}</span><span class="hljs-string"> </span><span class="hljs-subst">${values.lastName}</span><span class="hljs-string">`</span>)
}
</code></pre>
<p class="normal">In fact, we will use the value attributes of the input fields to set their initial values, as well as the updated one:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag"> </span><span class="hljs-attr">onSubmit</span><span class="hljs-tag">=</span><span class="hljs-string">{handleSubmit}</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">        </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span>
<span class="hljs-tag">        </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"firstName"</span>
<span class="hljs-tag">        </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{values.firstName}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span>
<span class="hljs-tag">    /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">        </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span>
<span class="hljs-tag">        </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"lastName"</span>
<span class="hljs-tag">        </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{values.lastName}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">onChange</span><span class="hljs-tag">=</span><span class="hljs-string">{handleChange}</span>
<span class="hljs-tag">    /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>Submit<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">The first time the form is rendered, React uses the initial values from the state as the value of the input fields. When the user types something into the field, the <code class="inlineCode">handleChange</code> function is called and the new value for the field is stored in the state.</p>
<p class="normal">When the state changes, React re-renders the component and uses it again to reflect the current values<a id="_idIndexMarker175"/> of the input fields. We now have full control over the values of the fields, and we call this pattern <strong class="keyWord">controlled components</strong>.</p>
<p class="normal">In the next section, we are going to work with events, which are a fundamental part of React to handle data coming from forms.</p>
<h1 class="heading-1" id="_idParaDest-91">Handling events</h1>
<p class="normal"><code class="inlineCode">Events</code> work in a slightly different way across various browsers. React tries to abstract the way events work <a id="_idIndexMarker176"/>and give developers a consistent interface to deal with. This is a great feature of React because we can forget about the browsers we are targeting and write event handlers and functions that are <em class="italic">vendor-agnostic</em>.</p>
<p class="normal">To offer this feature, React introduced the concept of the synthetic event. A synthetic event is an object that wraps the original event object provided by the browser, and it has the same properties, no matter where it is created.</p>
<p class="normal">To attach an event listener to a node and get the event object when the event is fired, we can use a simple convention that recalls the way events are attached to the DOM nodes. In fact, we can use the word on plus the <code class="inlineCode">camelCased</code> event name (for example, <code class="inlineCode">onKeyDown</code>) to define the callback to be fired when the events happen. A popular convention is to name the event handler functions after the event name and prefix them using <code class="inlineCode">handle</code> (for example, <code class="inlineCode">handleKeyDown</code>).</p>
<p class="normal">We have seen this pattern in action in the previous examples, where we were listening to the <code class="inlineCode">onChange</code> event of the form fields. Let’s reiterate a basic event listener example to see how we can organize multiple events inside the same component in a nicer way. We are going to implement a simple button, and we start, as usual, by creating a component:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Button</span> = () =&gt; {
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Button</span>
</code></pre>
<p class="normal">Then we define the event handler:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = (<span class="hljs-params">syntheticEvent</span>) =&gt; {
      <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(syntheticEvent <span class="hljs-keyword">instanceof</span> <span class="hljs-title">MouseEvent</span>)
      <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(syntheticEvent.<span class="hljs-property">nativeEvent</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title">MouseEvent</span>)
    }
</code></pre>
<p class="normal">As you can see here, we are doing a very simple thing: we just check the type of the event object we receive from React and the type of native event attached to it. We expect the first to <a id="_idIndexMarker177"/>return false and the second to return true.</p>
<p class="normal">You should never need to access the original native event, but it is good to know you can do it if you need to. Finally, we define the button with the <code class="inlineCode">onClick</code> attribute to which we attach our event listener:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>Click me!<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">Now, suppose we want to attach a second handler to the button that listens to the double-click event. One solution would be to create a new separate handler and attach it to the button using the <code class="inlineCode">onDoubleClick</code> attribute, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span>
<span class="hljs-tag">  </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span>
<span class="hljs-tag">  </span><span class="hljs-attr">onDoubleClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleDoubleClick}</span>
<span class="hljs-tag">&gt;</span>
  Click me!
<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">Remember that we always aim to write less boilerplate and avoid duplicating code. For that reason, a common practice is to write a <code class="inlineCode">single event handler</code> for each component, which can trigger different actions according to the event type.</p>
<p class="normal">This technique is described in a collection of patterns by Michael Chan:</p>
<p class="normal"><a href="http://reactpatterns.com/#event-switch"><span class="url">http://reactpatterns.com/#event-switch</span></a></p>
<p class="normal">Let’s implement the generic event handler:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleEvent</span> = (<span class="hljs-params">event</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (event.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'click'</span>:
        <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'clicked'</span>)
      <span class="hljs-keyword">break</span>
  
    <span class="hljs-keyword">case</span> <span class="hljs-string">'dblclick'</span>:
        <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'double clicked'</span>)
      <span class="hljs-keyword">break</span>
  
    <span class="hljs-attr">default</span>:
        <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'unhandled'</span>, event.<span class="hljs-property">type</span>)
  }
}
</code></pre>
<p class="normal">The generic event handler receives the event object and switches on the event type to fire the right <a id="_idIndexMarker178"/>action. This is particularly useful if we want to call a function on each event (for example, analytics) or if some events share the same logic.</p>
<p class="normal">Finally, we attach the new event listener to the <code class="inlineCode">onClick</code> and <code class="inlineCode">onDoubleClick</code> attributes:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span>
<span class="hljs-tag">    </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleEvent}</span>
<span class="hljs-tag">    </span><span class="hljs-attr">onDoubleClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleEvent}</span>
<span class="hljs-tag">  &gt;</span>
    Click me!
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">From this point on, whenever we need to create a new event handler for the same component, instead of creating a new method and binding it, we can just add a new case to the switch.</p>
<p class="normal">A couple more interesting things to know about events in React are that synthetic events are reused <a id="_idIndexMarker179"/>and that there is a <strong class="keyWord">single global handler</strong>. The first concept means that we cannot store a synthetic event and reuse it later because it becomes null right after the action. This technique is very good in terms of performance, but it can be problematic if we want to store the event inside the state of the component for some reason. To solve this problem, React gives us a persist method on the synthetic events, which we can call to make the event persistent so that we can store it and retrieve it later.</p>
<p class="normal">The second very interesting implementation detail is again about performance, and it is to do with the way React attaches the event handlers to the DOM.</p>
<p class="normal">Whenever we use the on attribute, we are describing to React the behavior we want to achieve, but the library does not attach the actual event handler to the underlying DOM nodes.</p>
<p class="normal">What it does instead attaches a single event <a id="_idIndexMarker180"/>handler to the root element, which listens to all the<a id="_idIndexMarker181"/> events, thanks to <strong class="keyWord">event bubbling</strong>. When an event we are interested in is fired by the browser, React calls the handler on the specific components on its behalf. This<a id="_idIndexMarker182"/> technique is called <strong class="keyWord">event delegation</strong> and is used for memory and speed optimization.</p>
<p class="normal">In our next section, we are going to explore React refs and see how we can take advantage of them.</p>
<h1 class="heading-1" id="_idParaDest-92">Exploring refs</h1>
<p class="normal">One of the reasons people love React is that it is declarative. Being declarative means that you just describe what you want to be displayed on the screen at any point in time and React takes care of the communications with the browser. This feature makes React very easy to reason about and very powerful at the same time.</p>
<p class="normal">However, there might be<a id="_idIndexMarker183"/> some cases where you need to access the underlying DOM nodes to perform some imperative operations. This should be avoided because, in most cases, there is a more React-compliant solution to achieve the same result, but it is important to know that we have the option to do it and to know how it works so that we can make the right decision.</p>
<p class="normal">Suppose we want to create a simple form with an input element and a button, and we want it to behave in such a way that when the button is clicked, the input field gets focused. What we want to do is call the focus method on the input node, the actual DOM instance of the input, inside the browser’s window.</p>
<p class="normal">Let’s create a component called <code class="inlineCode">Focus</code>; you need to import <code class="inlineCode">useRef</code> and create an <code class="inlineCode">inputRef</code> constant:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">Focus</span> = () =&gt; {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title">useRef</span>(<span class="hljs-literal">null</span>)
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">Focus</span>
</code></pre>
<p class="normal">Then, we implement the <code class="inlineCode">handleClick</code> method:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = () =&gt; {
  inputRef.<span class="hljs-property">current</span>.<span class="hljs-title">focus</span>()
}
</code></pre>
<p class="normal">As you can see, we are<a id="_idIndexMarker184"/> referencing the current attribute of <code class="inlineCode">inputRef</code> and calling the focus method on it.</p>
<p class="normal">To understand where it comes from, you just have to check the implementation of the render:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> (
  <span class="hljs-tag">&lt;&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span>
<span class="hljs-tag">      </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span>
<span class="hljs-tag">      </span><span class="hljs-attr">ref</span><span class="hljs-tag">=</span><span class="hljs-string">{inputRef}</span>
<span class="hljs-tag">    /&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>Set Focus<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/&gt;</span>
)
</code></pre>
<p class="normal">Here comes the core of the logic. We create a form with an input element inside it and we define a function on its <code class="inlineCode">ref</code> attribute.</p>
<p class="normal">The callback we defined is called when the component gets mounted, and the element parameter represents the DOM instance of the input. It is important to know that, when the component gets unmounted, the same callback is called with a null parameter to free the memory.</p>
<p class="normal">What we are doing in the callback is storing the reference of the element to be able to use it in the future (for example, when the <code class="inlineCode">handleClick</code> method is fired). Then, we have the button with its event handler. Running the preceding code in a browser will show the form with the field and the button, and clicking on the button will focus the input field, as expected.</p>
<p class="normal"><em class="italic">As we mentioned previously, in general, we should try to avoid using refs because they force the code to be more imperative, and they become harder to read and maintain.</em></p>
<h2 class="heading-2" id="_idParaDest-93">Understanding forwardRef</h2>
<p class="normal"><code class="inlineCode">React.forwardRef</code> is a useful feature that allows you to pass a ref (short for “reference”) from a parent<a id="_idIndexMarker185"/> component down to a child component. This article will provide a basic introduction to <code class="inlineCode">React.forwardRef</code> and offer a straightforward example to help you understand its practical usage.</p>
<p class="normal">Refs in React are a <a id="_idIndexMarker186"/>mechanism to access and interact with the DOM elements rendered by a component. They provide a way to modify the DOM or access DOM properties directly.</p>
<p class="normal"><code class="inlineCode">React.forwardRef</code> is a higher-order component that allows you to pass a ref down to a child component. This is useful when you need to access the child component’s DOM element or instance from the parent component.</p>
<p class="normal">To create a component that can accept a forwarded ref, you will use the <code class="inlineCode">React.forwardRef</code> function, which takes a render function as an argument. This render function receives two parameters: the component’s <code class="inlineCode">props</code> and the forwarded ref.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">const</span> <span class="hljs-title">TextInputWithRef</span> = <span class="hljs-title">React</span>.<span class="hljs-title">forwardRef</span>(<span class="hljs-function">(</span><span class="hljs-params">props, ref</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">ref</span><span class="hljs-tag">=</span><span class="hljs-string">{ref}</span><span class="hljs-tag"> </span><span class="hljs-attr">type</span><span class="hljs-tag">=</span><span class="hljs-string">"text"</span><span class="hljs-tag"> {</span><span class="hljs-attr">...props</span><span class="hljs-tag">} /&gt;</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">TextInputWithRef</span>
</code></pre>
<p class="normal">To use the <code class="inlineCode">forwardRef</code> component, you will create a ref using the <code class="inlineCode">useRef()</code> hook and assign it to the <code class="inlineCode">forwardRef</code> component.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title">TextInputWithRef</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TextInputWithRef'</span>
<span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title">useRef</span>()
  <span class="hljs-keyword">const</span> <span class="hljs-title">handleClick</span> = () =&gt; {
    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title">focus</span>()
  }
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">TextInputWithRef</span><span class="hljs-tag"> </span><span class="hljs-attr">ref</span><span class="hljs-tag">=</span><span class="hljs-string">{inputRef}</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{handleClick}</span><span class="hljs-tag">&gt;</span>Focus on input<span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  )
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title">App</span>
</code></pre>
<p class="normal">In this example, we created a <code class="inlineCode">TextInputWithRef</code> component that accepts a forwarded ref. In the <code class="inlineCode">App</code> component, we use the <code class="inlineCode">useRef()</code> hook to create a ref, which we then pass to the <code class="inlineCode">TextInputWithRef</code> component. When the <code class="inlineCode">"Focus on input"</code> button is clicked, the <code class="inlineCode">handleClick</code> function is called, which focuses on the input element.</p>
<p class="normal"><code class="inlineCode">React.forwardRef</code> is a powerful feature that allows you to pass refs from parent components to child components, providing greater control over the child components’ behavior. </p>
<p class="normal">By understanding the basics of refs and <code class="inlineCode">forwardRef</code>, and examining a simple example, you can effectively utilize this feature in your React applications.</p>
<p class="normal">With the nuances of <a id="_idIndexMarker187"/>utilizing <code class="inlineCode">React.forwardRef</code> for superior control over components explored, we can now shift our focus toward another pivotal aspect of enhancing user experiences in React applications: implementing animations.</p>
<h1 class="heading-1" id="_idParaDest-94">Implementing animations</h1>
<p class="normal">When we think about UIs and the browser, we must surely think about animations as well. Animated UIs<a id="_idIndexMarker188"/> are more pleasant for users, and they are a very important tool to show users that something has happened or is about to occur.</p>
<p class="normal">This section does not aim to be an exhaustive guide to creating animations and beautiful UIs; the goal here is to provide you with some basic information about the common solutions we can put in place to animate our React components.</p>
<p class="normal">For a UI library such as React, it is crucial to provide an easy way for developers to create and manage animations. React comes with an add-on, called <code class="inlineCode">react-transition-group</code>, which is a component that helps us build animations in a declarative way. Again, being able to perform operations declaratively is incredibly powerful, and it makes the code much easier to reason about and share with the team.</p>
<p class="normal">The first thing we need to do to start building an animated component is to install the add-on:</p>
<pre class="programlisting con"><code class="hljs-con">npm install --save react-transition-group @types/react-transition-group
</code></pre>
<p class="normal">Once we have done that, we can import the component:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">TransitionGroup</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-transition-group'</span>
</code></pre>
<p class="normal">Then, we just wrap the component to which we want to apply the animation:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Transition</span> = () =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">TransitionGroup</span>
<span class="hljs-tag">    </span><span class="hljs-attr">transitionName</span><span class="hljs-tag">=</span><span class="hljs-string">"fade"</span>
<span class="hljs-tag">    </span><span class="hljs-attr">transitionAppear</span>
<span class="hljs-tag">    </span><span class="hljs-attr">transitionAppearTimeout</span><span class="hljs-tag">=</span><span class="hljs-string">{500}</span>
<span class="hljs-tag">  &gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>Hello React<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">TransitionGroup</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">As you can see, there are some props that need explaining. First, we are declaring the <code class="inlineCode">transitionName</code> prop. <code class="inlineCode">ReactTransitionGroup</code> applies a class with the name of that property to the child element so that we can then use CSS transitions to create our animations.</p>
<p class="normal">With a single class, we cannot easily create a proper animation, and that is why the transition group applies multiple classes according to the state of the animation. In this<a id="_idIndexMarker189"/> case, with the <code class="inlineCode">transitionAppear</code> prop, we are telling the component that we want to animate the children when they appear on the screen.</p>
<p class="normal">So, what the library does is apply the <code class="inlineCode">fade-appear</code> class (where fade is the value of the <code class="inlineCode">transitionName</code> prop) to the component as soon as it gets rendered. On the next tick, the <code class="inlineCode">fade-appear-active</code> class is applied so that we can fire our animation from the initial state to the new one, using CSS.</p>
<p class="normal">We also have to set the <code class="inlineCode">transitionAppearTimeout</code> property to tell React the length of the animation so that it doesn’t remove elements from the DOM before animations are completed.</p>
<p class="normal">The CSS to make an element <code class="inlineCode">fade-in</code> is as follows.</p>
<p class="normal">First, we define the opacity of the element in the initial state:</p>
<pre class="programlisting code"><code class="hljs-code">.<span class="hljs-property">fade</span>-appear {
  <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.01</span>;
}
</code></pre>
<p class="normal">Then, we define our transition using the second class, which starts as soon as it gets applied to the element:</p>
<pre class="programlisting code"><code class="hljs-code">.<span class="hljs-property">fade</span>-appear.<span class="hljs-property">fade</span>-appear-active {
  <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attr">transition</span>: opacity .5s ease-<span class="hljs-keyword">in</span>;
}
</code></pre>
<p class="normal">We are transitioning the opacity from 0.01 to 1 in 500ms using the ease-in function. This is pretty easy, but we can create more complex animations, and we can also animate different states of the component. For example, the <code class="inlineCode">*-enter</code> and <code class="inlineCode">*-enter-active</code> classes are applied when a new element is added as a child of the transition group. A <a id="_idIndexMarker190"/>similar thing applies to remove elements.</p>
<p class="normal">After delving into the dynamic world of animations and understanding how they can dramatically enhance our React components, let’s now turn our attention to another fascinating facet of web design: the exploration of <strong class="keyWord">Scalable Vector Graphics</strong> (<strong class="keyWord">SVG</strong>).</p>
<h1 class="heading-1" id="_idParaDest-95">Exploring SVG</h1>
<p class="normal">Finally, one of the most interesting techniques we can apply in the browser to draw icons and graphs is SVG.</p>
<p class="normal">SVG is great because it is a <a id="_idIndexMarker191"/>declarative way of describing vectors and it fits perfectly with the purposes of React. We used to use icon fonts to create icons, but they have well-known problems, with the first being that they are not accessible. It is also pretty hard to position icon fonts with CSS, and they do not always look beautiful in all browsers. These are the reasons we should prefer SVG for our web applications.</p>
<p class="normal">From a React point of view, it does not make any difference if we output a div or an SVG element from the render method, and this is what makes it so powerful. We also tend to choose SVG because we can easily modify them at runtime using CSS and JavaScript, which makes them an excellent candidate for the functional approach of React.</p>
<p class="normal">So, if we think about our components as a function of their props, we can easily imagine how we can create self-contained SVG icons that we can manipulate by passing different props to them. A common way to create SVG in a web app with React is to wrap our vectors into a React component and use the props to define their dynamic values.</p>
<p class="normal">Let’s look at a simple example where we draw a blue circle, thus creating a React component that wraps an SVG element:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Circle</span> = (<span class="hljs-params">{ x, y, radius, fill }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">svg</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">circle</span><span class="hljs-tag"> </span><span class="hljs-attr">cx</span><span class="hljs-tag">=</span><span class="hljs-string">{x}</span><span class="hljs-tag"> </span><span class="hljs-attr">cy</span><span class="hljs-tag">=</span><span class="hljs-string">{y}</span><span class="hljs-tag"> </span><span class="hljs-attr">r</span><span class="hljs-tag">=</span><span class="hljs-string">{radius}</span><span class="hljs-tag"> </span><span class="hljs-attr">fill</span><span class="hljs-tag">=</span><span class="hljs-string">{fill}</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">svg</span><span class="hljs-tag">&gt;</span>
)
</code></pre>
<p class="normal">As you can see, we can easily use a stateless functional component that wraps the SVG markup, and it <a id="_idIndexMarker192"/>accepts the same props as SVG does.</p>
<p class="normal">An example usage is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">&lt;<span class="hljs-title">Circle</span> x={<span class="hljs-number">20</span>} y={<span class="hljs-number">20</span>} radius={<span class="hljs-number">20</span>} fill=<span class="hljs-string">"blue"</span> /&gt;
</code></pre>
<p class="normal">We can obviously use the full power of React and set some default parameters so that, if the circle icon is rendered without props, we still show something.</p>
<p class="normal">For example, we can define the default color:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">Circle</span> = (<span class="hljs-params">{ x, y, radius, fill = </span><span class="hljs-string">'red'</span><span class="hljs-params"> }</span>) =&gt; (...)
</code></pre>
<p class="normal">This is pretty powerful when we build UIs, especially in a team where we share our icon set and we want to have some default values in it, but we also want to let other teams decide their settings without having to recreate the same SVG shapes.</p>
<p class="normal">However, in some cases, we prefer to be stricter and fix some values to keep consistency. With React, this is a super simple task.</p>
<p class="normal">For example, we can wrap the base circle component into <code class="inlineCode">RedCircle</code>, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">RedCircle</span> = (<span class="hljs-params">{ x, y, radius }</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">Circle</span><span class="hljs-tag"> </span><span class="hljs-attr">x</span><span class="hljs-tag">=</span><span class="hljs-string">{x}</span><span class="hljs-tag"> </span><span class="hljs-attr">y</span><span class="hljs-tag">=</span><span class="hljs-string">{y}</span><span class="hljs-tag"> </span><span class="hljs-attr">radius</span><span class="hljs-tag">=</span><span class="hljs-string">{radius}</span><span class="hljs-tag"> </span><span class="hljs-attr">fill</span><span class="hljs-tag">=</span><span class="hljs-string">"red"</span><span class="hljs-tag"> /&gt;</span>
)
</code></pre>
<p class="normal">Here, the color is set by default, and it cannot be changed, while the other props are transparently passed to the original circle.</p>
<p class="normal">The following screenshot shows two circles, blue and red, that are generated by React using SVG:</p>
<figure class="mediaobject"><img alt="Icon  Description automatically generated" height="182" src="../Images/B18414_05_01.png" width="825"/></figure>
<p class="packt_figref">Figure 5.1: Two circles, blue and red SVGs</p>
<p class="normal">We can apply this<a id="_idIndexMarker193"/> technique and create different variations of the circle, such as <code class="inlineCode">SmallCircle</code> and <code class="inlineCode">RightCircle</code>, and everything else we need to build our UIs.</p>
<h1 class="heading-1" id="_idParaDest-96">Summary</h1>
<p class="normal">In this chapter, we explored the different capabilities of React when targeting the browser, from creating forms and handling events to animating SVGs. We also learned about the new <code class="inlineCode">useRef</code> Hook, which provides a simple way to access DOM nodes. React’s declarative approach simplifies the management of complex web applications. Additionally, React provides a way to access the DOM nodes, allowing for imperative operations if needed, making it easier to integrate React with existing libraries. </p>
<p class="normal">In the next chapter, we will delve into CSS and inline styles, and explore the concept of writing CSS in JavaScript.</p>
</div>
</div></body></html>