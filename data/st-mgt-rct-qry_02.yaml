- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Server State versus Client State
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器状态与客户端状态的比较
- en: Global state is the most common way we look at state. It is the state that is
    shared globally in our application by one or more components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 全局状态是我们看待状态最常见的方式。它是通过一个或多个组件在我们的应用程序中全局共享的状态。
- en: What we don’t often know is that in our day-to-day development, our global state
    ends up being split between the state that persists outside of our application
    and the state that only exists within our application. The first type of state
    is called **server state**, while the second one is called **client state**. Both
    of these types of states have their specific challenges and require different
    tools to help manage them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不知道的是，在我们的日常开发中，我们的全局状态最终会在我们的应用程序外部持久化的状态和仅存在于我们应用程序内的状态之间分割。第一种类型的状态被称为**服务器状态**，而第二种类型的状态被称为**客户端状态**。这两种类型的状态都有它们特定的挑战，并需要不同的工具来帮助管理它们。
- en: In this chapter, we will understand why we refer mostly to our state as global
    state and why we should adjust our mental models to include client and server
    states instead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解为什么我们主要将状态称为全局状态，以及为什么我们应该调整我们的思维模型以包括客户端和服务器状态。
- en: We’ll also review what each type of state is responsible for and how to differentiate
    them in an application and understand the challenges that led to the creation
    of React Query.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将回顾每种类型的状态负责什么，如何在应用程序中区分它们，以及理解导致React Query创建的挑战。
- en: By the end of this chapter, you’ll be able to fully split global state into
    the client state and the server state by applying the mental models you will have
    just learned.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够通过应用你刚刚学到的思维模型，将全局状态完全分割成客户端状态和服务器状态。
- en: You will also understand all the challenges created by having a server state
    in your application and prepare to overcome them with React Query.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将了解在应用程序中拥有服务器状态所创造的所有挑战，并准备好用React Query克服它们。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is global state?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: What is client state?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是客户端状态？
- en: What is server state?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是服务器状态？
- en: Understanding common challenges with server state
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与服务器状态相关的常见挑战
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2)。
- en: What is global state?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是全局状态？
- en: When starting with state management in the React world, we are often not familiar
    with the different concepts of state.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在React世界中开始状态管理时，我们通常不熟悉不同的概念。
- en: Often, we just look at state by thinking about the amount of `useState` or `useReducer`
    hooks we have in our components. Then, when the `useState` or `useReducer` pattern
    stops working and we need to share state between more components, we either lift
    our state to the nearest parent when this state is needed only by the children
    of that component, or find a common place where this state can exist and be accessible
    everywhere by all the components we want. This state is often called global state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只是通过思考我们在组件中拥有的`useState`或`useReducer`钩子的数量来查看状态。然后，当`useState`或`useReducer`模式停止工作，我们需要在更多组件之间共享状态时，我们要么将状态提升到最近的父组件，当这个状态只需要该组件的子组件时，要么找到一个共同的地方，这个状态可以存在，并且所有我们想要的组件都可以访问它。这种状态通常被称为全局状态。
- en: 'Let’s look at an example of what global state can look like in an application.
    Here, we have a store responsible for managing theme selection, fetching data,
    and tracking the loading state of this fetching request:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个应用程序中全局状态可能是什么样子的例子。在这里，我们有一个负责管理主题选择、获取数据和跟踪此获取请求加载状态的商店：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This snippet shows an example of what some typical global state can look like.
    By using React Context, we are creating a store that has the following things
    inside it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了某些典型全局状态的一个示例。通过使用React Context，我们创建了一个包含以下内容的商店：
- en: A state variable called `selectedTheme` to manage the selected theme
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`selectedTheme`的状态变量，用于管理所选主题
- en: A state variable called `serverData` to display the data that was returned from
    our API request
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`serverData`的状态变量，用于显示从我们的API请求返回的数据
- en: A state variable called `isLoadingData` to display whether the current loading
    state of our API request is still loading
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`isLoadingData`的状态变量，用于显示我们的API请求当前加载状态是否仍在加载。
- en: A function called `toggleTheme` to allow us to toggle between light and dark
    modes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`toggleTheme`的函数，允许我们在浅色和深色模式之间切换。
- en: A `fetchData` function to allow us to fetch the given data and set our loading
    state as `true` or `false` depending on the state of the request
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`fetchData`函数，允许我们获取给定数据并设置我们的加载状态为`true`或`false`，这取决于请求的状态。
- en: A `useEffect` hook that will trigger the initial data fetching to provision
    our `serverData` state
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`useEffect`钩子，它将触发初始数据获取以提供我们的`serverData`状态。
- en: What is useEffect?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: useEffect是什么？
- en: '`useEffect` is a React hook that allows you to perform side effects in your
    components.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`是一个React钩子，允许你在组件中执行副作用。'
- en: All these are returned from our store so that the consumers of this context
    can access them from all over our application as long as they subscribe to our
    context.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是从我们的存储中返回的，以便上下文的消费者可以在整个应用程序中访问它们，只要他们订阅我们的上下文。
- en: Now, from a first look, there seems to be nothing wrong with this state, and
    it might be enough for most applications. The thing is, most of the time, this
    state will end up growing due to new development needs. This will lead to increasing
    the size of our state most of the time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一眼看来，这个状态似乎没有问题，并且可能对大多数应用程序来说已经足够了。问题是，大多数时候，这个状态会因为新的开发需求而增长。这通常会导致我们的状态大小增加。
- en: 'Let’s now picture that we need a secondary theme, and we need to add another
    state variable called `secondaryTheme`. Our code would look a lot like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设想我们需要一个次要主题，并且需要添加另一个名为`secondaryTheme`的状态变量。我们的代码看起来会像这样：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, in this snippet, we added our `secondaryTheme` state variable, and it works
    very much like `selectedTheme`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个片段中，我们添加了我们的`secondaryTheme`状态变量，它的工作方式非常类似于`selectedTheme`。
- en: Now, we are using context here; this means that every time we trigger a state
    update, any component that consumes this state will be forced to re-render to
    receive the new state updates. What does this mean to us?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在这里使用上下文；这意味着每次我们触发状态更新时，任何消费这个状态的组件都将被迫重新渲染以接收新的状态更新。这对我们意味着什么？
- en: Let’s imagine we have two components (let’s call them *Component A* and *Component
    B*) consuming this context, but *Component B* only destructures the `selectedTheme`
    state while *Component A* destructures everything. If *Component A* triggers a
    state update on `secondaryTheme`, then *Component B* will also re-render because
    React noticed an update inside the context that both of them share.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想我们有两个组件（让我们称它们为*组件A*和*组件B*）正在消费这个上下文，但*组件B*只解构`selectedTheme`状态，而*组件A*解构一切。如果*组件A*在`secondaryTheme`上触发状态更新，那么*组件B*也将重新渲染，因为React注意到了它们共享的上下文中的更新。
- en: This is how React Context works, and we can’t change this. We could argue that
    we could either split the context, split the subscribing component into two components
    and wrap the second one with `memo`, or just wrap our return with the `useMemo`
    hook. Sure, this would probably fix our issue, but we are only dealing with the
    changes in one type of state that creates the global state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是React Context的工作方式，我们无法改变这一点。我们可以争论，我们可以要么分割上下文，要么将订阅的组件分割成两个组件，并将第二个组件包裹在`memo`中，或者只是将我们的返回包裹在`useMemo`钩子中。当然，这可能会解决我们的问题，但我们只是在处理一种创建全局状态的状态类型的变化。
- en: What are memo and useMemo?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: memo和useMemo是什么？
- en: '`memo` is a function that you can wrap your component in to define a memoized
    version of it. This will guarantee that your component doesn’t re-render unless
    its props have changed.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo`是一个你可以将其包裹在组件中来定义其记忆化版本的函数。这将保证你的组件只有在它的属性发生变化时才会重新渲染。'
- en: '`useMemo` is a React hook that allows you to memoize a value. Usually, the
    value we want to memoize is the result of an expensive calculation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo`是一个React钩子，允许你记忆化一个值。通常，我们想要记忆化的值是昂贵计算的结果。'
- en: Now, imagine we needed to add another API request context. Once again, the context
    grows and we end up with the same issue we had with the themes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们需要添加另一个API请求上下文。同样，上下文增长，我们最终会遇到与主题相同的问题。
- en: As you may already understand by now, state organization can be a nightmare
    sometimes. We could resort to a third-party library to help us with this but,
    once again, this is only a small part of our issues with our state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经理解的那样，状态组织有时可能是一个噩梦。我们可以求助于第三方库来帮助我们，但，再次强调，这仅仅是我们状态问题的一小部分。
- en: So far, we have only been dealing with the organization of state, but now imagine
    we need to cache the data that we got from our API request. This can lead us to
    madness.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理状态的组织，但现在想象一下，我们需要缓存我们从API请求中获得的数据。这可能会让我们陷入疯狂。
- en: From these issues we have just noticed, we can see that inside our global state,
    we tend to have different challenges, and a solution that works for one thing
    might not work for another. This is why it is important to split our global state.
    Our global state is often a mix between client state and server state. In the
    upcoming sections, you will understand what each one of these states is, and we’ll
    focus on server state to finally understand why React Query has become so popular
    and made our lives so much easier as a developer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚刚注意到的问题中，我们可以看到，在我们的全局状态中，我们往往面临不同的挑战，一个解决方案可能对某件事有效，但对另一件事可能无效。这就是为什么分割我们的全局状态很重要。我们的全局状态通常是客户端状态和服务器状态的混合。在接下来的章节中，你将了解这些状态中的每一个是什么，我们将专注于服务器状态，最终理解为什么React
    Query如此受欢迎，并使我们的开发者生活变得更加容易。
- en: What is client state?
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端状态是什么？
- en: I know, by now, you must be thinking, when is this book going to start React
    Querying? We are almost there, I promise you. I just need you to fully understand
    why I love React Query so much and to do so, it is important to understand the
    main problem it solves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，到现在为止，你一定在想，这本书什么时候会开始介绍React Query？我们几乎到了，我向你保证。我只是需要你完全理解为什么我如此热爱React
    Query，而要做到这一点，了解它解决的主要问题非常重要。
- en: Now, client state is not one of the problems it solves, but you must be able
    to identify client state in your day-to-day life as a developer so that you fully
    understand what should be managed by React Query and what should be managed by
    other state management tools.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端状态不是它解决的问题之一，但你必须能够在作为开发者的日常工作中识别客户端状态，以便你完全理解应该由React Query管理什么，应该由其他状态管理工具管理什么。
- en: Client state is the state that is owned by your application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端状态是应用程序拥有的状态。
- en: 'Here are a couple of things that help define your client state:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有助于定义你的客户端状态的东西：
- en: This state is synchronous, which means you can access it without any waiting
    time and by using synchronous APIs.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种状态是同步的，这意味着你可以无需等待时间，通过使用同步API来访问它。
- en: It is local; therefore, it only exists in your application.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是局部的；因此，它只存在于你的应用程序中。
- en: It is temporary, so it may get lost upon a page reload and is generally non-persistent
    between sessions.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是临时的，所以页面刷新时可能会丢失，并且在会话之间通常是非持久的。
- en: With this knowledge in mind, if you were to look back at `GlobalStore`, what
    would you identify as belonging to client state?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，如果你回顾一下`GlobalStore`，你会把什么识别为属于客户端状态？
- en: Probably only `selectedTheme`, right?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可能只有`selectedTheme`，对吧？
- en: 'Let us apply our learning from the previous bullet points:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用从上一个要点中学到的知识：
- en: Do we need to wait to get its value? *No*, so that means it is synchronous.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要等待获取它的值吗？*不*，这意味着它是同步的。
- en: Does the `selectedTheme` only exist in our application? *Yes*.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selectedTheme`只存在于我们的应用程序中吗？*是的*。'
- en: Will it be lost on a page reload? *Yes*, if we don’t persist it in local storage
    or check the browser preferences, then its value will be lost between page reloads.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会在页面刷新时丢失吗？*是的*，如果我们不在本地存储中持久化它或检查浏览器首选项，那么它的值将在页面刷新之间丢失。
- en: With this in mind, we can definitely say that `selectedTheme` belongs in our
    client state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以肯定地说`selectedTheme`属于我们的客户端状态。
- en: To manage this type of state, we can use anything from React Context to third-party
    libraries such as Redux, Zustand, or MobX when things start to become harder to
    organize and maintain.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这种类型的状态，我们可以使用从React Context到Redux、Zustand或MobX等第三方库的任何东西，当事情开始变得难以组织和维护时。
- en: If we ask the same questions for our `serverData` state variable, would it work
    the same?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对`serverData`状态变量提出相同的问题，它会产生相同的效果吗？
- en: Does the data only exist in our application? *No*, it exists on a database somewhere.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据只存在于我们的应用程序中吗？*不*，它存在于某个地方的数据库中。
- en: Will it be lost on page reload? *No*, the database still keeps the data, so
    when we reload, it will be fetched once again.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会在页面刷新时丢失吗？*不*，数据库仍然保留着数据，所以当我们重新加载时，它将再次被检索。
- en: Do we need to wait to get it? *Yes*, we need to trigger a fetching request to
    get this data.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要等待获取它吗？*是的*，我们需要触发一个获取此数据的请求。
- en: This means that our `serverData` state variable doesn’t belong in our client
    state. This is something that we would classify as part of server state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`serverData`状态变量不属于我们的客户端状态。这是我们将其归类为服务器状态的一部分。
- en: Let us now get into the thing that brought you to this book and made React Query
    necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈让你来到这本书并使React Query变得必要的那个东西。
- en: What is server state?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器状态是什么？
- en: We have always had server state in our applications. The main issue was that
    we tried to tie it in with our client state management solutions. A common example
    of trying to tie our server state with our client state management solutions is
    using either **Redux Saga** or **Redux Thunk**. Both of them made it easier to
    do data fetching and store your server state. The main issue starts when we have
    to deal with some of the challenges server state brings us, but let’s not get
    ahead of ourselves; you will understand these challenges in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用程序中始终有服务器状态。主要问题是，我们试图将其与我们的客户端状态管理解决方案结合起来。试图将我们的服务器状态与我们的客户端状态管理解决方案结合的一个常见例子是使用**Redux
    Saga**或**Redux Thunk**。它们都使得进行数据获取和存储服务器状态变得更容易。主要问题开始于我们必须处理服务器状态带来的挑战，但让我们不要走得太远；你将在下一节中了解这些挑战。
- en: Now, what is server state, you might be wondering?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道，服务器状态是什么？
- en: 'Well, as the name says, server state is the type of state that is stored on
    your server. Here are a couple of things that help identify your server state:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如其名所示，服务器状态是存储在您的服务器上的状态类型。以下是一些有助于识别您的服务器状态的事情：
- en: This state is asynchronous, which means you need to use asynchronous APIs for
    fetching and updating it.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个状态是异步的，这意味着你需要使用异步API来获取和更新它。
- en: It is persisted remotely – most of the time on a database or external place
    you don’t own or control.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被远程持久化——大多数情况下是在数据库或您不拥有或控制的外部位置。
- en: There are no guarantees that this state is up to date in your application because
    most often, you have shared ownership of it, and it might be changed by others
    that are consuming it as well.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序中，这个状态不一定是最新的，因为大多数情况下，你拥有它的共享所有权，它可能被其他人改变，他们也在消费它。
- en: 'With this knowledge in mind, let us look back at `GlobalStore` and our `serverData`
    state variable and apply these rules to identify our server state:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，让我们回顾一下`GlobalStore`和我们的`serverData`状态变量，并应用这些规则来识别我们的服务器状态：
- en: Do we need asynchronous APIs to access this state? We do! We need to send a
    fetch request to the server and wait for it to send the data back.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要异步API来访问这个状态吗？我们需要！我们需要向服务器发送一个获取请求并等待它发送数据回来。
- en: Is it persisted remotely? It sure is. Like I just said in the previous bullet
    item, we need to ask our server for it.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否被远程持久化？当然是的。就像我在上一个要点中说的那样，我们需要向我们的服务器请求它。
- en: Will this state always be up to date in our application? We don’t know. We don’t
    control the state. This means that if anyone that is consuming the same API decides
    to update it, then our `serverData` state variable will immediately be outdated.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个状态在我们应用程序中总是最新的吗？我们不知道。我们无法控制状态。这意味着如果任何消费相同API的人决定更新它，那么我们的`serverData`状态变量将立即过时。
- en: 'Now, you might be looking back at `GlobalStore` and asking the following: if
    `selectedTheme` is client state and `data` is server state, then what is the `isLoadingData`
    state variable?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能正在回顾`GlobalStore`并思考以下问题：如果`selectedTheme`是客户端状态，而`data`是服务器状态，那么`isLoadingData`状态变量是什么呢？
- en: Well, this is a derived state variable. This means that its state will always
    depend on the current status of our `serverData` fetching request. If we fetch
    data, then `isLoadingData` will be `true`; once we are done fetching data, then
    `isLoadingData` will go back to `false`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个派生状态变量。这意味着它的状态将始终取决于我们当前`serverData`获取请求的状态。如果我们获取数据，那么`isLoadingData`将是`true`；一旦我们完成数据获取，那么`isLoadingData`将回到`false`。
- en: Now, imagine needing one of these derived state variables for every type of
    server state variable you have in your application. I’m also going to ask you
    to picture a scenario in which you needed to handle errors when a fetch request
    fails. You would probably create another state variable for errors, right? But
    wouldn’t you end up with the same issue as your loading state?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，在你的应用程序中，每种服务器状态变量都需要一个这样的派生状态变量。我还要让你想象一个场景，在这个场景中，你需要处理获取请求失败时的错误。你可能为错误创建另一个状态变量，对吧？但你不最终会遇到和加载状态相同的问题吗？
- en: The previously mentioned scenario is just the very small tip of the iceberg
    of challenges that the server state brings to your application. Imagine that one
    of your team technical leads arrives at the office one day and tells you that
    now you need to start caching your data; oh God, another challenge that we didn’t
    think about. As you can see, the server state has many challenges, and in the
    next section, we will see a couple of them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的场景只是服务器状态带给你的应用程序挑战的冰山一角。想象一下，你的团队技术负责人有一天来到办公室告诉你，现在你需要开始缓存数据；哦，上帝，我们还没有考虑到的另一个挑战。正如你所见，服务器状态有许多挑战，在下一节中，我们将看到其中的一些。
- en: Understanding common challenges with server state
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务器状态中的常见挑战
- en: By now, you have probably figured out that the server state comes with quite
    its fair share of challenges. These challenges made React Query stand out even
    more when it came out because it solved them in such a simple way for developers
    that it seemed too good to be true.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经意识到服务器状态带来了相当多的问题。这些挑战使得React Query在发布时更加突出，因为它以如此简单的方式解决了这些问题，以至于看起来太好了而不像是真的。
- en: Now, what are these challenges, and why are they so complex to solve most of
    the time?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些挑战是什么，为什么它们大多数时候都如此复杂难以解决？
- en: In this section, we will see all the common challenges that we have with the
    server state and understand a bit of the hard work we had to do as developers
    to solve them ourselves before we had React Query.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到我们与服务器状态相关的所有常见挑战，并了解我们在React Query出现之前作为开发者必须自己解决的一些难题。
- en: Caching
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: This is probably one of the hardest challenges we face in server state management.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们在服务器状态管理中面临的最具挑战性的问题之一。
- en: To improve your page performance and make your site more responsive, very often,
    you will need to cache your data. This means being able to reuse data that you
    previously fetched to avoid refetching it from the server once again.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高页面性能并使你的网站更具响应性，你通常需要缓存你的数据。这意味着能够重用你之前获取的数据，以避免再次从服务器获取。
- en: 'Now, you might be thinking that this sounds simple, but consider the following
    things:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能认为这听起来很简单，但考虑以下事项：
- en: While keeping your application responsive, you need to update your cache in
    the background.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在保持应用程序响应的同时，你需要在后台更新你的缓存。
- en: You need to be able to evaluate when your cache data has become stale and needs
    to be updated.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要能够评估你的缓存数据何时变得过时并需要更新。
- en: Once data has not been accessed for a while, you must garbage-collect this data.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦数据有一段时间未被访问，你必须回收这些数据。
- en: You might want to initialize your cache with some template data before data
    is fetched.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取数据之前，你可能希望用一些模板数据初始化你的缓存。
- en: As you can see, caching comes with its fair share of issues, and imagine having
    to solve all of these by yourself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，缓存带来了它应有的问题，想象一下你必须自己解决所有这些问题。
- en: Optimistic updates
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乐观更新
- en: When performing mutations, you often want to make your user experience better.
    A mutation is a request that will either create or update your server state. Sometimes,
    you want to make your user experience better. We all hate filling out a form and
    ending up watching a loading spinner while our application in the background performs
    the mutation, refetches the data, and updates the UI.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行变更时，你通常希望提升用户体验。变更是一个请求，它将创建或更新你的服务器状态。有时，你希望提升用户体验。我们都讨厌填写表格，然后看着加载指示器，同时我们的应用程序在后台执行变更、重新获取数据并更新用户界面。
- en: To make the user experience better, we can resort to optimistic updates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升用户体验，我们可以求助于乐观更新。
- en: An optimistic update is when during an ongoing mutation, we update our UI to
    show how it will look after that mutation is complete, although that mutation
    is still not confirmed as complete. Basically, we are optimistic that this data
    will change and be what we are expecting it to be after the mutation, so we save
    our users some time and give them a UI that they will end up seeing earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 乐观更新是指在变更进行中时，我们更新我们的用户界面以显示变更完成后将如何显示，尽管那个变更尚未被确认完成。基本上，我们是乐观的，认为这些数据将改变，并在变更后成为我们期望的样子，这样我们就可以为用户节省一些时间，并给他们一个他们最终会看到的用户界面。
- en: Now, imagine implementing this. While doing a mutation, you would need to update
    the server state in your application with the way we expect it to be after the
    mutation is successful. This would make the UI more responsive for the user and
    they can start interacting with it earlier. After the mutation is successful,
    you need to retrigger a manual refetch for the server state so that you actually
    have the updated state in your application. Now, picture a scenario in which the
    mutation fails. You would need to manually roll back your state to the previous
    version before your optimistic update.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下实现这一点。在进行变更时，你需要以我们期望变更成功后的方式更新应用程序中的服务器状态。这将使UI对用户更加响应，他们可以更早地与之交互。变更成功后，你需要重新触发手动重新获取服务器状态，以便你实际上在应用程序中拥有更新的状态。现在，想象一个变更失败的场景。你需要手动将状态回滚到乐观更新之前的版本。
- en: Optimistic updates give an amazing user experience to your users but having
    to manage all the success and error scenarios, plus keeping your server date updated,
    can be a hard thing to do.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 乐观更新为用户提供了一个惊人的用户体验，但管理所有成功和错误场景，以及保持服务器数据更新，可能是一件困难的事情。
- en: Deduping requests
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去重请求
- en: Let’s paint the following scenario.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描绘以下场景。
- en: You have a button in your UI that, when clicked on by the user, triggers a fetch
    request to partially update your server state. When the fetch is being performed,
    the button is disabled.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你在UI中有一个按钮，当用户点击时，会触发一个获取请求以部分更新你的服务器状态。在获取操作进行时，按钮被禁用。
- en: This might seem okay and not troublesome at all but imagine that before your
    loading state updates and your button ends up being disabled, the user can click
    on the button 10 more times. What do you get? Ten more unexpected requests for
    the same data in your application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来没问题，一点也不麻烦，但想象一下，在你加载状态更新和你的按钮最终被禁用之前，用户可以点击按钮10次。你得到了什么？应用程序中针对相同数据的10次额外的意外请求。
- en: This is why deduping requests is important. When fetching for the exact same
    type of data, if we trigger multiple requests for the same data, we want only
    one of those requests to be sent and avoid polluting our user network with unnecessary
    requests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么去重请求很重要。当获取相同类型的数据时，如果我们触发了针对相同数据的多个请求，我们只想发送其中一个请求，并避免用不必要的请求污染用户的网络。
- en: Now, imagine having to implement this by yourself. You would need to be aware
    of all the requests currently being done in your application. When one of those
    requests exactly matches another one, then you would need to cancel that second,
    third, or fourth request.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你需要自己实现这一点。你需要了解应用程序中当前正在进行的所有请求。当其中一个请求与另一个请求完全匹配时，你需要取消第二个、第三个或第四个请求。
- en: Performance optimization
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能优化
- en: Sometimes, you need some extra performance optimization in your server state.
    Here are some common patterns that you might need for specific optimization of
    your server state management.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要在服务器状态中做一些额外的性能优化。以下是一些你可能需要用于特定服务器状态管理的优化模式。
- en: '**Lazy loading**: You might only want a specific data fetching request to be
    done once a certain condition is met.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟加载**：你可能只想在满足特定条件时执行一次特定的数据获取请求。'
- en: '**Infinite scrolling**: When dealing with huge lists, infinite scrolling is
    a very common pattern where you just progressively load more data into your server
    state.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限滚动**：当处理大量列表时，无限滚动是一种非常常见的模式，你只是逐渐将更多数据加载到你的服务器状态中。'
- en: '**Paginated data**: To help structure large datasets, you can opt to paginate
    your data. This means that whenever a user decides to move from page 1 to page
    2, you will need to fetch the corresponding data for this page.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页数据**：为了帮助结构化大型数据集，你可以选择分页你的数据。这意味着每当用户决定从第1页移动到第2页时，你需要获取该页面对应的数据。'
- en: As you can see, there are several challenges that we need to solve in order
    to have what we can consider the best experience dealing with server state in
    our application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们需要解决几个挑战，才能在我们的应用程序中拥有我们认为是处理服务器状态的最佳体验。
- en: The issue is that deciding to take care of these challenges ourselves as developers
    can take quite a while, and the code we end up creating is often prone to bugs.
    Most of the time, these implementations end up affecting a lot of our code readability
    and significantly increasing the complexity it takes to understand our projects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，作为开发者，决定自己处理这些挑战可能需要相当长的时间，而我们最终创建的代码往往容易出错。大多数情况下，这些实现最终会影响我们代码的可读性，并显著增加理解我们项目所需的复杂性。
- en: What if I told you that there was something that could take care of all of these
    challenges and many others in the background for you while giving you a super-clean
    and simple API that will make your code more readable, easier to understand, and
    make you feel like a true master of server state?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你，有一种东西可以在后台为你处理所有这些挑战，同时给你一个超级干净、简单的API，这将使你的代码更易于阅读、理解，并让你感觉自己是一位真正的服务器状态大师，你会怎么想？
- en: If you are reading this book, then you probably already know the answer. Yes,
    I’m talking about React Query.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读这本书，那么你可能已经知道了答案。是的，我正在谈论React Query。
- en: So, pack up your server state knowledge, and prepare your projects because starting
    with the next chapter, we will change the way you handle server state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打包好你的服务器状态知识，准备好你的项目，因为从下一章开始，我们将改变你处理服务器状态的方式。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we fully understood the concept of global state. By now, you
    should be able to understand why often our state is called global state and how
    much harder it can be to maintain it if we don’t split it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完全理解了全局状态的概念。到现在为止，你应该能够理解为什么我们的状态经常被称为全局状态，以及如果我们不将其拆分，维护它可能会变得多么困难。
- en: You learned how to split your state into client and server states and understand
    how each of these types of states is important for your application and how you
    can identify them in your code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何将你的状态分为客户端和服务器端状态，并理解了每种类型的状态对于你的应用的重要性，以及如何在你的代码中识别它们。
- en: Finally, you were familiarized with the challenges that server state can bring
    to your application and understood that if you were to address them all by yourself,
    then your code complexity would increase significantly and you’d probably lose
    some much-needed sleeping hours.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你已经熟悉了服务器状态可能给你的应用带来的挑战，并理解了如果你要自己解决所有这些问题，那么你的代码复杂性将会显著增加，你可能会失去一些非常需要的睡眠时间。
- en: In [*Chapter 3*](B18501_03.xhtml#_idTextAnchor062), *React Query – Introducing,
    Installing, and Configuring It*, you will start getting hands-on with React Query.
    You will understand what it is and how it saves you from all the headaches that
    server state brings to your applications. You will learn how to install and configure
    it for your application and how you can add dedicated React Query developer tools
    to make your life even easier as a developer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B18501_03.xhtml#_idTextAnchor062)《React Query – 介绍、安装和配置》中，你将开始亲身体验React
    Query。你将了解它是什么，以及它是如何帮助你摆脱服务器状态给应用带来的所有烦恼。你将学习如何为你的应用安装和配置它，以及如何添加专门的React Query开发者工具，使你的开发生活更加轻松。
