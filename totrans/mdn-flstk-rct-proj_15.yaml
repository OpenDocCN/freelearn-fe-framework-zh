- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Interfacing with GraphQL on the Frontend Using Apollo Client
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Apollo 客户端在前端与 GraphQL 交互
- en: After successfully implementing a GraphQL backend using Apollo Server in the
    previous chapter, we are now going to interface with our new GraphQL API on the
    frontend using Apollo Client. Apollo Client is a library that makes it easier
    and more convenient to interact with GraphQL APIs. We’ll start by replacing the
    fetching of the post list with GraphQL queries, then resolve the author usernames
    without needing extra queries, showing the power of GraphQL. Next, we’ll add variables
    to the query to allow setting filters and sorting options. Finally, we’ll learn
    how to use mutations on the frontend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章成功实现使用 Apollo Server 的 GraphQL 后端之后，我们现在将使用 Apollo 客户端在前端与新的 GraphQL API
    进行交互。Apollo 客户端是一个库，使得与 GraphQL API 交互变得更加容易和方便。我们将首先用 GraphQL 查询替换获取帖子列表的操作，然后无需额外的查询即可解析作者用户名，展示
    GraphQL 的强大功能。接下来，我们将向查询中添加变量以允许设置过滤和排序选项。最后，我们将学习如何在前端使用突变。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up Apollo Client and making our first query
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Apollo 客户端并执行我们的第一个查询
- en: Using variables in GraphQL queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GraphQL 查询中使用变量
- en: Using mutations on the frontend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前端使用突变
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing For Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请从 [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) *为全栈开发做准备* 和 [*第 2 章*](B19385_02.xhtml#_idTextAnchor028)
    *了解 Node.js 和 MongoDB* 中安装所有要求。
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If there is an issue with the code and steps provided
    in this book, please try using the versions mentioned in *Chapters 1* and *2.*
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那些章节中列出的版本是书中使用的版本。虽然安装较新版本通常不会有问题，但请注意，某些步骤在较新版本上可能有所不同。如果本书中提供的代码和步骤存在问题，请尝试使用第
    *1* 章和 *2* 章中提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch12](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch12).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch12](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch12)。
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/Gl_5i9DR_xA](https://youtu.be/Gl_5i9DR_xA).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址找到：[https://youtu.be/Gl_5i9DR_xA](https://youtu.be/Gl_5i9DR_xA)。
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git` `init` in the
    root of the corresponding chapter folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你克隆了本书的完整仓库，Husky 在运行 `npm install` 时可能找不到 `.git` 目录。在这种情况下，只需在相应章节文件夹的根目录中运行
    `git init`。
- en: Setting up Apollo Client and making our first query
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Apollo 客户端并执行我们的第一个查询
- en: Before we can get started making GraphQL queries on the frontend, we first need
    to set up Apollo Client. `POST` request to the `/graphql` endpoint), Apollo Client
    makes interacting with GraphQL much easier and more convenient. It also includes
    additional features, such as caching, out of the box.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在前端进行 GraphQL 查询之前，我们首先需要设置 Apollo 客户端。`POST` 请求到 `/graphql` 端点），Apollo
    客户端使得与 GraphQL 交互变得更加容易和方便。它还包括一些额外的功能，如开箱即用的缓存。
- en: 'Follow these steps to set up Apollo Client:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置 Apollo 客户端：
- en: 'Copy the existing **ch11** folder to a new **ch12** folder, as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 **ch11** 文件夹复制到新的 **ch12** 文件夹，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the **ch12** folder in VS Code.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 **ch12** 文件夹。
- en: 'Install the **@apollo/client** and **graphql** dependencies:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 **@apollo/client** 和 **graphql** 依赖项：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Edit **.env** and add a new environment variable, pointing to the endpoint
    for our GraphQL server:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **.env** 并添加一个新的环境变量，指向我们的 GraphQL 服务器端点：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Edit **src/App.jsx** and import **ApolloClient**, **InMemoryCache**, and **ApolloProvider**
    from the **@****apollo/client** package:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/App.jsx** 并从 **@apollo/client** 包中导入 **ApolloClient**、**InMemoryCache**
    和 **ApolloProvider**：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the time of writing, there is an issue with ESM imports in Apollo Client,
    so we need to import directly from the `index.js` files.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在撰写本文时，Apollo 客户端中存在 ESM 导入问题，因此我们需要直接从 `index.js` 文件中导入。
- en: 'Create a new instance of Apollo Client, pointing to the GraphQL endpoint and
    using **InMemoryCache**:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个指向 GraphQL 端点并使用 **InMemoryCache** 的新实例的 Apollo Client：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Adjust the **App** component to add **ApolloProvider**, providing the Apollo
    Client context to our whole app:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 **App** 组件以添加 **ApolloProvider**，为我们的整个应用提供 Apollo Client 上下文：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are also going to create a GraphQL config file now so that the VS Code GraphQL
    extension can autocomplete and validate queries for us. Create a new **graphql.config.json**
    file in the root of the project, with the following contents:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在还将创建一个 GraphQL 配置文件，以便 VS Code GraphQL 扩展可以为我们自动完成和验证查询。在项目的根目录中创建一个新的 **graphql.config.json**
    文件，内容如下：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `schema` defines the URL to the GraphQL endpoint, and `documents` defines
    where to find files that contain GraphQL queries. We are going to put the GraphQL
    queries in the `src/api/graphql/` folder later.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`schema` 定义了 GraphQL 端点的 URL，而 `documents` 定义了包含 GraphQL 查询的文件的位置。我们稍后将在 `src/api/graphql/`
    文件夹中放置 GraphQL 查询。'
- en: 'Make sure Docker and the database container are running, then start the backend,
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Docker 和数据库容器正在运行，然后按照以下方式启动后端：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Keep the backend running throughout this chapter, so that the GraphQL extension
    can access the GraphQL endpoint.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中保持后端运行，以便 GraphQL 扩展可以访问 GraphQL 端点。
- en: Restart the VS Code GraphQL extension. You can do so by accessing the VS Code
    command palette (*Ctrl* + *Shift* + *P* on Windows/Linux and *Cmd* + *Shift* +
    *P* on macOS) and typing in **GraphQL:** **Manual Restart**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动 VS Code GraphQL 扩展。您可以通过访问 VS Code 命令面板（在 Windows/Linux 上为 *Ctrl* + *Shift*
    + *P*，在 macOS 上为 *Cmd* + *Shift* + *P*）并输入 **GraphQL:** **Manual Restart** 来这样做。
- en: Querying posts from the frontend using GraphQL
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GraphQL 从前端查询帖子
- en: 'Now that Apollo Client is set up and ready to be used, let’s define our first
    GraphQL query: a simple query to fetch all posts.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Apollo Client 已设置并准备好使用，让我们定义我们的第一个 GraphQL 查询：一个简单的查询来获取所有帖子。
- en: 'Follow these steps to define the query and use it in our app:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤定义查询并在我们的应用中使用它：
- en: Create a new **src/api/graphql/** folder, where we will put our GraphQL queries.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/api/graphql/** 文件夹中创建一个新的文件夹，我们将在这里放置我们的 GraphQL 查询。
- en: Inside this folder, create a new **src/api/graphql/posts.js** file.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，创建一个新的 **src/api/graphql/posts.js** 文件。
- en: 'In the **src/api/graphql/posts.js** file, import the **gql** function from
    **@apollo/client**:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **src/api/graphql/posts.js** 文件中，从 **@apollo/client** 导入 **gql** 函数：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a new **GET_POSTS** query, which retrieves all the relevant properties
    for a post (except the author, which will come later):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的 **GET_POSTS** 查询，它检索帖子的所有相关属性（除了作者，稍后添加）：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should see that the GraphQL extension is offering us autocomplete options
    for the types we defined in our backend! If we enter the wrong field name, it
    will also warn us that this field does not exist on the type.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该会看到 GraphQL 扩展为我们提供了我们定义在后端的类型的自动完成选项！如果我们输入错误的字段名，它也会警告我们该字段在类型上不存在。
- en: 'Edit **src/pages/Blog.jsx** and import the **useQuery** hook from **@apollo/client**:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/Blog.jsx** 并从 **@apollo/client** 导入 **useQuery** 钩子：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We renamed the `useQuery` hook from Apollo Client to `useGraphQLQuery` to avoid
    confusion with the `useQuery` hook from TanStack React Query.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 Apollo Client 的 `useQuery` 钩子重命名为 `useGraphQLQuery` 以避免与 TanStack React
    Query 的 `useQuery` 钩子混淆。
- en: 'Import the previously defined **GET_POSTS** query:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入之前定义的 **GET_POSTS** 查询：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Remove* the imports to **useQuery** and **getPosts**:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*移除* 用于 **useQuery** 和 **getPosts** 的导入：'
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Remove* the existing **useQuery** hook:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*移除* 现有的 **useQuery** 钩子：'
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Replace* it with the following hook:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 为以下钩子：'
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Make sure you are in the root of the project, then run the frontend as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您位于项目的根目录中，然后按照以下方式运行前端：
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, open the frontend on `http://localhost:5173/` and you will see that the
    post titles are properly shown. However, the links to posts do not work and there
    is an error in the console. There is a slight difference in the results from GraphQL
    and the REST API: the REST API returns the ID of posts as an `_id` property, while
    GraphQL returns them as an `id` property.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `http://localhost:5173/` 上打开前端，你会看到帖子标题被正确显示。然而，帖子链接不起作用，控制台中有错误。GraphQL
    和 REST API 的结果略有不同：REST API 将帖子的 ID 作为 `_id` 属性返回，而 GraphQL 将它们作为 `id` 属性返回。
- en: 'Let’s adjust our code to accommodate this change now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整我们的代码以适应这个变化：
- en: 'Edit **src/components/Post.jsx** and change the **_id** prop to **id**:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/components/Post.jsx** 并将 **_id** 属性更改为 **id**：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, update the variable name where it is used:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，更新使用的地方的变量名：
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Make sure to update **propTypes** as well:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保更新 **propTypes**：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the prop is changed, edit **src/pages/ViewPost.jsx** and pass in the
    new prop, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在属性已更改，编辑 **src/pages/ViewPost.jsx** 并按照以下方式传递新属性：
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After saving all files, the frontend should refresh and properly render the
    list of all posts with working links. Now all that’s left to do to restore the
    original functionality is to show the author usernames.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有文件后，前端应该刷新并正确渲染所有帖子列表，并带有正常工作的链接。现在要恢复原始功能，只剩下显示作者用户名。
- en: Resolving author usernames in a single query
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单个查询中解析作者用户名
- en: 'Instead of resolving each author username separately, we can now get them all
    at once in a single query, thanks to the power of GraphQL! Let’s make use of this
    power to refactor our code a bit to make it simpler and improve the performance:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GraphQL 的强大功能，我们现在可以一次性在单个查询中获取所有作者的用户名，而不是分别解析每个作者的用户名！让我们利用这个功能来重构我们的代码，使其更简单并提高性能：
- en: 'Start by editing the GraphQL query in **src/api/graphql/posts.js**, adding
    the **author.****username** field, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑 **src/api/graphql/posts.js** 中的 GraphQL 查询，添加 **author.username** 字段，如下所示：
- en: '[PRE20]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, edit the **src/components/User.jsx** component. *Replace* the whole component
    with the following, simpler component:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编辑 **src/components/User.jsx** 组件。*替换*整个组件为以下更简单的组件：
- en: '[PRE21]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is not necessary to fetch the user info here anymore, as we can directly
    display the username from the GraphQL response.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在在这里获取用户信息不再必要，因为我们可以直接从 GraphQL 响应中显示用户名。
- en: 'Next, edit **src/components/Post.jsx** and pass the whole **author** object
    to the **User** component, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑 **src/components/Post.jsx** 并按照以下方式将整个 **author** 对象传递给 **User** 组件：
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also need to adjust **propTypes** now to accept a full **author** object
    for the **Post** component, instead of a user ID:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要调整 **propTypes** 以接受 **Post** 组件的完整 **author** 对象，而不是用户 ID：
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Edit **src/pages/ViewPost.jsx** and pass the whole **author** object to the
    **Post** component:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/ViewPost.jsx** 并将整个 **author** 对象传递给 **Post** 组件：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: import { useQuery } from '@tanstack/react-query'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 `{ useQuery }` 从 `@tanstack/react-query`
- en: import { getUserInfo } from '../api/users.js'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 `{ getUserInfo }` 从 `../api/users.js`
- en: '[PRE25]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, adjust the component to get the user ID from the token (the **sub** field
    of the JWT) and make a query for the user info:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整组件以从令牌（JWT 的 **sub** 字段）中获取用户 ID 并对用户信息进行查询：
- en: '[PRE26]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, we check whether we were able to resolve the query for user info (instead
    of just checking for **token**). If so, we pass the user info to the **User**
    component:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们检查是否能够解析用户信息查询（而不是仅仅检查 **token**）。如果是这样，我们将用户信息传递给 **User** 组件：
- en: '[PRE27]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We also removed the token decoding here, like we already did earlier.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还像之前一样移除了令牌解码。
- en: Now we are using GraphQL to fetch the list of posts and resolve the author usernames
    in one single request! However, the filters and sorting do not work anymore, as
    we are not passing this information to the GraphQL query yet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用 GraphQL 来获取帖子列表并在单个请求中解析作者用户名！然而，过滤和排序不再工作，因为我们还没有将此信息传递给 GraphQL 查询。
- en: In the next section, we are going to introduce variables for filtering and sorting
    our GraphQL queries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍用于过滤和排序 GraphQL 查询的变量。
- en: Using variables in GraphQL queries
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GraphQL 查询中使用变量
- en: To add support for filters and sorting, we need to add variables to our GraphQL
    query. We can then fill in these variables when executing the query.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加对过滤和排序的支持，我们需要在我们的 GraphQL 查询中添加变量。然后，在执行查询时我们可以填写这些变量。
- en: 'Follow these steps to add variables to the query:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤向查询中添加变量：
- en: 'Edit **src/api/graphql/posts.js** and adjust the query to accept an **$****options**
    variable:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/api/graphql/posts.js** 并调整查询以接受一个 **$options** 变量：
- en: '[PRE28]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, pass the **$options** variable to the **posts** resolver, for which we
    already implemented an **options** argument in the previous chapter:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 **$options** 变量传递给 **posts** 解析器，因为我们已经在上一章中实现了 **options** 参数：
- en: '[PRE29]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we just need to pass the options when executing the query. Edit **src/pages/Blog.jsx**
    and pass the variable, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需在执行查询时传递这些选项。编辑 **src/pages/Blog.jsx** 并按照以下方式传递变量：
- en: '[PRE30]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Go to the blog frontend and change the sort order to ascending to see the variable
    in action!
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往博客前端并将排序顺序更改为升序，以查看变量的实际效果！
- en: Using fragments to reuse parts of queries
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用片段重用查询的部分
- en: 'Now that sorting is working, we just need to add filtering by author. To do
    this, we need to add a second query for `postsByAuthor`. As you can imagine, this
    query should return the same fields as the `posts` query. We can make use of a
    fragment to reuse the fields for both queries, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在排序功能已经正常工作，我们只需要添加按作者过滤的功能。为此，我们需要为 `postsByAuthor` 添加第二个查询。正如你所想象的那样，这个查询应该返回与
    `posts` 查询相同的字段。我们可以利用片段来重用这两个查询的字段，如下所示：
- en: 'Edit **src/api/graphql/posts.js** and define a new fragment in GraphQL that
    contains all the fields that we need from a post:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/api/graphql/posts.js** 并在 GraphQL 中定义一个新的片段，其中包含我们从帖子中需要的所有字段：
- en: '[PRE31]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The fragment is defined by giving it a name (`PostFields`) and specifying which
    type it can be used on (`on Post`). Then, all fields from the specified type can
    be queried in the fragment.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该片段通过给它一个名称（`PostFields`）并指定它可以用于哪种类型（`on Post`）来定义。然后，可以在片段中查询指定类型的所有字段。
- en: 'To use the fragment, we first have to include its definition in the **GET_POSTS**
    query:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用片段，我们首先必须将其定义包含在 **GET_POSTS** 查询中：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, instead of listing all fields manually, we can use the fragment:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不再需要手动列出所有字段，我们可以使用片段：
- en: '[PRE33]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The syntax for using a fragment is like object destructuring in JavaScript,
    where all properties defined in an object are spread into another object.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用片段的语法类似于 JavaScript 中的对象解构，其中对象中定义的所有属性都会扩展到另一个对象中。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes the VS Code GraphQL extension needs to be restarted to be able to
    detect fragments properly. You can do so by accessing the VS Code command palette
    (*Ctrl* + *Shift* + *P* on Windows/Linux and *Cmd* + *Shift* + *P* on macOS) and
    typing in **GraphQL:** **Manual Restart**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要重新启动 VS Code GraphQL 扩展才能正确检测片段。您可以通过访问 VS Code 命令面板（在 Windows/Linux 上为
    *Ctrl* + *Shift* + *P*，在 macOS 上为 *Cmd* + *Shift* + *P*）并输入 **GraphQL:** **Manual
    Restart** 来这样做。
- en: 'Next, we define a second query, where we query posts by author, and get all
    necessary fields with the fragment:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义第二个查询，通过作者查询帖子，并使用片段获取所有必要的字段：
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We defined the `$author` variable as required for this query (by using an exclamation
    mark after the type). We need to do this because the `postsByAuthor` field also
    requires the first argument (`username`) to be set.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将 `$author` 变量定义为该查询所必需的（通过在类型后使用感叹号）。我们需要这样做，因为 `postsByAuthor` 字段也要求设置第一个参数（`username`）。
- en: 'Edit **src/pages/Blog.jsx** and import the newly defined query:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/Blog.jsx** 并导入新定义的查询：
- en: '[PRE35]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, adjust the hook to use the **GET_POSTS_BY_AUTHOR** query if **author**
    is defined:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调整钩子以使用 **GET_POSTS_BY_AUTHOR** 查询，如果 **author** 已定义：
- en: '[PRE36]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Pass the **author** variable to the query:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **author** 变量传递给查询：
- en: '[PRE37]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, we need to adjust how we select the results because the **postsByAuthor**
    field from the **GET_POSTS_BY_AUTHOR** query will return the results in **data.postsByAuthor**,
    while the **GET_POSTS** query uses the **posts** field, which returns results
    in **data.posts**. As there is no case where both fields are returned at once,
    we can simply do the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要调整选择结果的方式，因为 **GET_POSTS_BY_AUTHOR** 查询中的 **postsByAuthor** 字段将结果返回在
    **data.postsByAuthor** 中，而 **GET_POSTS** 查询使用 **posts** 字段，结果返回在 **data.posts**
    中。由于没有同时返回这两个字段的情况，我们可以简单地这样做：
- en: '[PRE38]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Go to the frontend and try filtering by author. The filter works again now!
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往前端尝试按作者过滤。现在过滤器又正常工作了！
- en: As we can see, fragments are very useful for reusing the same fields for multiple
    queries! Now that our post list is fully refactored to use GraphQL, let’s move
    on to using mutations on the frontend, allowing us to migrate the signup, login,
    and create post functionalities to GraphQL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，片段对于重复使用相同字段进行多个查询非常有用！现在我们的帖子列表已经完全重构为使用 GraphQL，让我们继续在前端使用突变，这样我们就可以将注册、登录和创建帖子功能迁移到
    GraphQL。
- en: Using mutations on the frontend
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前端使用突变
- en: As we learned in the previous chapter, mutations in GraphQL are used to change
    the state of the backend (similar to `POST` requests in REST). We are now going
    to implement mutations for signing up and logging in to our app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章所学，GraphQL 中的突变用于更改后端的状态（类似于 REST 中的 `POST` 请求）。我们现在将实现注册和登录的突变。
- en: 'Follow these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Create a new **src/api/graphql/users.js** file and import **gql**:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **src/api/graphql/users.js** 文件并导入 **gql**：
- en: '[PRE39]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, define a new **SIGNUP_USER** mutation, which takes a username and a password
    and calls the **signupUser** mutation field:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个新的 **SIGNUP_USER** 突变，它接受用户名和密码并调用 **signupUser** 突变字段：
- en: '[PRE40]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Edit **src/pages/Signup.jsx** and *replace* the current **useMutation** hook
    from TanStack React Query with the one from Apollo Client. As we did before for
    **useQuery**, we are also going to rename this hook to **useGraphQLMutation**
    to avoid confusion:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/Signup.jsx** 并将当前来自 TanStack React Query 的 **useMutation** hook
    替换为来自 Apollo Client 的一个。正如我们之前为 **useQuery** 所做的那样，我们也将把这个 hook 重命名为 **useGraphQLMutation**
    以避免混淆：
- en: '[PRE41]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Additionally, *replace* the import of the **signup** function with an import
    of the **SIGNUP_USER** mutation:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，*替换* **signup** 函数的导入为 **SIGNUP_USER** mutation 的导入：
- en: '[PRE42]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Replace* the existing mutation hook with the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 现有的 mutation hook 为以下内容：'
- en: '[PRE43]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As can be seen, the Apollo Client mutation hook has a slightly different API
    than the TanStack React Query mutation hook. It returns an array with a function
    to call the mutation, and an object with the loading state, error state, and data.
    Similar to the `useGraphQLQuery` hook, it also accepts the mutation as the first
    argument and an object with variables as the second argument. Moreover, the `onSuccess`
    function is called `onCompleted` in Apollo Client.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如所见，Apollo Client 的 mutation hook 与 TanStack React Query 的 mutation hook 有略微不同的
    API。它返回一个包含调用 mutation 的函数以及包含加载状态、错误状态和数据的对象的数组。类似于 `useGraphQLQuery` hook，它也接受
    mutation 作为第一个参数，以及包含变量的对象作为第二个参数。此外，Apollo Client 中的 `onSuccess` 函数被命名为 `onCompleted`。
- en: 'Change the **handleSubmit** function as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式更改 **handleSubmit** 函数：
- en: '[PRE44]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Lastly, change the submit button as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按如下方式更改提交按钮：
- en: '[PRE45]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now the signup functionality is successfully migrated to GraphQL. Next, let’s
    migrate the login functionality.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注册功能已成功迁移到 GraphQL。接下来，让我们迁移登录功能。
- en: Migrating login to GraphQL
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将登录迁移到 GraphQL
- en: 'Refactoring the login functionality to GraphQL is very similar to the signup
    functionality, so let’s quickly go through the steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将登录功能重构为 GraphQL 与注册功能非常相似，所以让我们快速浏览一下步骤：
- en: 'Edit **src/api/graphql/users.js** and define a mutation for logging in:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/api/graphql/users.js** 并为登录定义一个 mutation：
- en: '[PRE46]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Edit **src/pages/Login.jsx** and *replace* the imports to TanStack React Query
    and the **login** function with the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **src/pages/Login.jsx** 并将导入 TanStack React Query 和 **login** 函数替换为以下内容：
- en: '[PRE47]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update the hook as well:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 hook：
- en: '[PRE48]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the **handleSubmit** function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 **handleSubmit** 函数：
- en: '[PRE49]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, update the submit button:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新提交按钮：
- en: '[PRE50]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that signup and login are using GraphQL mutations, let’s move on to migrating
    the create post functionality to GraphQL.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注册和登录都使用 GraphQL mutation，让我们继续迁移创建帖子功能到 GraphQL。
- en: Migrating create post to GraphQL
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将创建帖子迁移到 GraphQL
- en: The create post functionality is a bit trickier to implement, as it requires
    us to be logged in (which means that we need to send the JWT header), and invalidate
    the post list queries, so that the list gets updated after creating a new post.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帖子功能实现起来有点复杂，因为它要求我们登录（这意味着我们需要发送 JWT 标头），并使帖子列表查询失效，以便在创建新帖子后更新列表。
- en: 'Now let’s get started on implementing this with Apollo Client:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始使用 Apollo Client 来实现这个功能：
- en: 'First, let’s define the mutation. Edit **src/api/graphql/posts.js** and add
    the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义 mutation。编辑 **src/api/graphql/posts.js** 并添加以下代码：
- en: '[PRE51]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For this mutation, we are going to use the response to get the `id` and `title`
    of the created post. We are going to make use of this data to show a link to the
    post upon successful creation.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个 mutation，我们将使用响应来获取创建的帖子的 `id` 和 `title`。我们将利用这些数据在成功创建后显示帖子的链接。
- en: 'Then, edit **src/components/CreatePost.jsx** and *replace* the TanStack React
    Query import with an import of the mutation hook:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编辑 **src/components/CreatePost.jsx** 并将 TanStack React Query 的导入替换为 mutation
    hook 的导入：
- en: '[PRE52]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Also, import the **Link** component and **slug** function to show a link to
    the created post:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，导入 **Link** 组件和 **slug** 函数以显示创建的帖子链接：
- en: '[PRE53]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Replace* the import of the **createPost** function with imports of the **CREATE_POST**
    mutation and the **GET_POSTS** and **GET_POSTS_BY_AUTHOR** queries. We are going
    to use these query definitions to make Apollo Client re-fetch them for us later:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* **createPost** 函数的导入为 **CREATE_POST** mutation 和 **GET_POSTS** 以及 **GET_POSTS_BY_AUTHOR**
    查询的导入。我们将使用这些查询定义让 Apollo Client 在稍后为我们重新获取它们：'
- en: '[PRE54]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Replace* the existing query client and mutation hooks with the following GraphQL
    mutation, where we pass the **title** and **contents** variables:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 现有的查询客户端和 mutation hook 为以下 GraphQL mutation，其中我们传递 **title** 和 **contents**
    变量：'
- en: '[PRE55]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we provide the JWT header as **context** to the mutation:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 JWT 标头作为 **context** 传递给 mutation：
- en: '[PRE56]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we provide a **refetchQueries** option to the mutation, telling Apollo
    Client to re-fetch certain queries after the mutation was called:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 **refetchQueries** 选项提供给突变，告诉 Apollo Client 在调用突变后重新获取某些查询：
- en: '[PRE57]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As re-fetching after a mutation is a common operation, Apollo Client provides
    a simple way to do this in the mutation hook. Simply pass all queries that should
    be re-fetched there, and Apollo Client will take care of it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于突变后的重新获取是一个常见的操作，Apollo Client 提供了一种简单的方法在突变钩子中执行此操作。只需将所有应重新获取的查询传递到那里，Apollo
    Client 将负责处理。
- en: 'Adjust the **handleSubmit** function:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 **handleSubmit** 函数：
- en: '[PRE58]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Adjust the submit button:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整提交按钮：
- en: '[PRE59]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Lastly, we are going to change the success message, showing a link to the created
    post:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将更改成功消息，显示创建的帖子的链接：
- en: '[PRE60]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Because of the way types and resolvers work in GraphQL, it easily allows us
    to access fields from the result of a mutation, the same way as if we were fetching
    a single post. For example, we could even tell GraphQL to fetch the username of
    the author of the created post here!
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 GraphQL 中类型和解析器的工作方式，它使我们能够轻松地访问突变结果的字段，就像我们正在获取单个帖子一样。例如，我们甚至可以告诉 GraphQL
    获取创建的帖子的作者的用户名！
- en: Try creating a new post, and you will see that the success message now shows
    a link to the created post, and the post list automatically re-fetches for us!
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个新的帖子，你会看到成功消息现在显示了创建的帖子的链接，帖子列表也会自动为我们重新获取！
- en: 'The following screenshot shows a new post being successfully created, showing
    the link to the new post in the success message, and the new post in the post
    list (automatically re-fetched by Apollo Client):'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了一个新帖子成功创建，成功消息中显示了新帖子的链接，以及帖子列表中的新帖子（由 Apollo Client 自动重新获取）：
- en: '![Figure 12.1: Creating a post using GraphQL mutations, with a re-fetching
    post list](img/B19385_12_1.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：使用 GraphQL 突变创建帖子，并重新获取帖子列表](img/B19385_12_1.jpg)'
- en: 'Figure 12.1: Creating a post using GraphQL mutations, with a re-fetching post
    list'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：使用 GraphQL 突变创建帖子，并重新获取帖子列表
- en: Now that we have successfully implemented creating posts with GraphQL, our blog
    app is fully connected to our GraphQL server.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功实现了使用 GraphQL 创建帖子，我们的博客应用已经完全连接到我们的 GraphQL 服务器。
- en: There are many more advanced concepts in GraphQL that we have not covered yet
    in this book, such as advanced re-fetching, subscriptions (getting real-time updates
    from the GraphQL server), error handling, suspense, pagination, and caching. The
    GraphQL chapters in this book only serve as an introduction to GraphQL.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们还没有涵盖 GraphQL 的许多更高级的概念，例如高级重新获取、订阅（从 GraphQL 服务器获取实时更新）、错误处理、suspense、分页和缓存。本书中的
    GraphQL 章节仅作为 GraphQL 的入门介绍。
- en: If you wish to learn more about GraphQL and Apollo, I recommend checking out
    the extensive Apollo docs ([https://www.apollographql.com/docs/](https://www.apollographql.com/docs/)),
    which contain detailed information and hands-on examples about using Apollo Server
    and Apollo Client.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望了解更多关于 GraphQL 和 Apollo 的信息，我建议查看广泛的 Apollo 文档（[https://www.apollographql.com/docs/](https://www.apollographql.com/docs/)），其中包含有关使用
    Apollo Server 和 Apollo Client 的详细信息和实践示例。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we connected our previously created GraphQL backend to the
    frontend using Apollo Client. We started by setting up Apollo Client and making
    a GraphQL query to fetch all posts. Then, we improved the performance of the post
    list by fetching author usernames in a single request, leveraging the power of
    GraphQL.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Apollo Client 将之前创建的 GraphQL 后端连接到前端。我们首先设置 Apollo Client 并执行一个 GraphQL
    查询以获取所有帖子。然后，我们通过在单个请求中获取作者用户名来提高帖子列表的性能，利用 GraphQL 的强大功能。
- en: Next, we introduced variables in our query and re-implemented sorting and filtering
    by author. We also introduced fragments in our queries to reuse the same fields.
    Lastly, we implemented GraphQL mutations in the frontend to sign up, log in, and
    create posts. We also learned about re-fetching queries in Apollo Client along
    the way and briefly mentioned advanced concepts of GraphQL and Apollo.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在查询中引入了变量，并重新实现了按作者排序和过滤。我们还引入了查询中的片段以重用相同的字段。最后，我们在前端实现了 GraphQL 突变以注册、登录和创建帖子。我们还沿途了解了
    Apollo Client 中的查询重新获取，并简要介绍了 GraphQL 和 Apollo 的高级概念。
- en: 'In the next chapter, [*Chapter 13*](B19385_13.xhtml#_idTextAnchor245), *Building
    a Backend Based on Event-Driven Architecture Using Express and Socket.IO*, we
    are going to depart from traditional full-stack architectures and build a new
    app using a special kind of full-stack architecture: an event-based application.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第13章*](B19385_13.xhtml#_idTextAnchor245)，*使用Express和Socket.IO构建基于事件驱动的后端*，我们将从传统的全栈架构中跳出来，并使用一种特殊类型的全栈架构：基于事件的程序来构建一个新应用。
