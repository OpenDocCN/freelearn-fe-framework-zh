- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: TypeScript Patterns for Angular
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript Patterns for Angular
- en: Since version 2 of the framework, Angular is based on TypeScript for its development,
    both internally and for those who use it to build applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自框架的第 2 版以来，Angular 无论是内部开发还是用于构建应用程序的用户，都基于 TypeScript 进行开发。
- en: This was a controversial decision at the time, as this JavaScript superset,
    created by Microsoft, was new. Nowadays, most web frameworks, such as React, Vue.js,
    and Svelte, support TypeScript, and some web frameworks actively recommend TypeScript
    as the language to use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当时这是一个有争议的决定，因为这个由微软创建的 JavaScript 超集是新的。如今，大多数 Web 框架，如 React、Vue.js 和 Svelte，都支持
    TypeScript，一些 Web 框架甚至积极推荐使用 TypeScript 作为编程语言。
- en: In this chapter, we will study the best practices and patterns for using TypeScript
    with Angular and beyond; these techniques can be applied to Node.js backend development
    and even other web frameworks, such as React and Vue.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将研究使用 TypeScript 与 Angular 以及其他技术的最佳实践和模式；这些技术可以应用于 Node.js 后端开发，甚至其他
    Web 框架，如 React 和 Vue.js。
- en: We’ll learn how to better declare our application’s methods and functions and
    how to leverage TypeScript’s type inference mechanism to make our classes less
    verbose.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何更好地声明我们的应用程序的方法和函数，以及如何利用 TypeScript 的类型推断机制来使我们的类更加简洁。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating classes and types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类和类型
- en: Creating methods and functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建方法和函数
- en: 'Decreasing verbosity: type inference'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少冗余：类型推断
- en: 'Validating types: type guards'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证类型：类型守卫
- en: Using a better alternative to the `any` type
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `any` 类型的更好替代方案
- en: By the end of the chapter, you will be able to better apply TypeScript resources
    in your projects, improving the quality of your code and the productivity of your
    team.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够更好地在你的项目中应用 TypeScript 资源，提高代码质量和团队的生产力。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，你需要以下内容：
- en: '**Visual Studio Code** (**VS** **Code**) ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code** (**VS** **Code**) ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))'
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch3)
    找到。
- en: Creating classes and types
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类和类型
- en: The basis of application development using Angular is object-oriented programming,
    so it is important for us to delve into how to create classes and instantiate
    objects. Using TypeScript instead of pure JavaScript, we have another powerful
    element in our toolbox of types.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 进行应用程序开发的基础是面向对象编程，因此深入了解如何创建类和实例化对象对我们来说非常重要。使用 TypeScript 而不是纯
    JavaScript，我们在类型工具箱中又多了一个强大的元素。
- en: By typifying variables and objects, the TypeScript transpiler is able to carry
    out checks and alerts, preventing errors that could occur at runtime during development
    if this process did not exist.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型化变量和对象，TypeScript 编译器能够执行检查和警告，防止在开发过程中由于这个过程不存在而可能发生的运行时错误。
- en: Bear in mind that after transpiling (a process that transforms TypeScript code
    into JavaScript), the code delivered to the client’s browser is pure JavaScript,
    including some optimizations; that is, code written in TypeScript is no less performant
    than code written directly in JavaScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在将 TypeScript 代码转换为 JavaScript（这是一个转换过程）之后，发送到客户端浏览器的代码是纯 JavaScript，包括一些优化；也就是说，用
    TypeScript 编写的代码在性能上并不逊色于直接用 JavaScript 编写的代码。
- en: To start with the fundamentals, let’s explore primitive and basic types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从基础知识开始，让我们来探索原始和基本类型。
- en: Primitive and basic types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始和基本类型
- en: 'JavaScript, despite not being a strongly typed language, has three types called
    primitives:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript不是强类型语言，但它有三个称为原始类型：
- en: '`boolean`: Represents the two binary values `false` and `true`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`：表示两个二进制值 `false` 和 `true`'
- en: '`string`: Represents a set of characters such as words'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：表示一组字符，如单词'
- en: '`number`: Represents numerical values'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number`：表示数值'
- en: For each of these primitive types, TypeScript already has a datatype that represents
    them, namely, `Boolean`, `String`, and `Number`, respectively.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些原始类型中的每一个，TypeScript已经有一个表示它们的内置数据类型，分别是`Boolean`、`String`和`Number`。
- en: Important
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: The first letter of the primitive types in TypeScript is in uppercase to differentiate
    it from the primitive JavaScript types. If you want to check a type at runtime
    using the `typeof` function, use the names of the primitives in lowercase.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript中原始类型的第一个字母是大写的，以区分它们与原始JavaScript类型的区别。如果您想使用`typeof`函数在运行时检查类型，请使用原始类型的小写名称。
- en: 'To declare the variables of these types, just use the `:` symbol in front of
    the variable declaration, as in the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明这些类型的变量，只需在变量声明前使用`:`符号，如下面的示例所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we declare the `name`, `age`, and `isAlive` variables
    as `string`, `number`, and `boolean`, respectively. Note that we can use JavaScript
    type names in TypeScript because TypeScript allows both forms for these primitive
    types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将`name`、`age`和`isAlive`变量分别声明为`string`、`number`和`boolean`。请注意，我们可以在TypeScript中使用JavaScript类型名称，因为TypeScript允许这些原始类型使用两种形式。
- en: 'In JavaScript, it is very common to use the array data structure. This structure
    allows us to store and manipulate a list of values for our applications. TypeScript
    has a type for this structure called `Array`, where it is possible not only to
    create a variable with that type but also to typify what kind of values the array
    will contain:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，使用数组数据结构非常常见。这种结构允许我们存储和操作应用程序中的值列表。TypeScript有一个名为`Array`的类型，其中不仅可以创建具有该类型的变量，还可以指明数组将包含哪种类型的值：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this function, we declare the `names` array using the `Array` type and declare
    that it is a `string` list because we are informing it between square braquets..
    In the `surnames` array declaration, we make the same declaration but use a TypeScript
    syntax sugar using `[]` after the `string` type. This way of declaring has the
    same effect; it’s just more succinct.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用`Array`类型声明`names`数组，并声明它是一个字符串列表，因为我们是在方括号内通知它的。在`surnames`数组声明中，我们进行相同的声明，但使用TypeScript的语法糖，在`string`类型后面使用`[]`。这种声明方式具有相同的效果；它只是更简洁。
- en: 'At the end of the example, we use `Array`’s `foreach` method to print the elements
    of the array. Finally, another basic type that is widely used is the `any` type.
    This type tells the TypeScript transpiler not to perform any type checking on
    it, and its content can be type-changed anywhere in the code, as in the following
    example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的末尾，我们使用`Array`的`forEach`方法来打印数组的元素。最后，另一个广泛使用的类型是`any`类型。此类型告诉TypeScript编译器不要对此类型执行任何类型检查，并且其内容可以在代码的任何地方更改类型，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `information` variable is declared as `any` and then we put the `Mario`
    `string` in it. We subsequently redefine the variable with the value `5`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`information`变量被声明为`any`，然后我们将`Mario`字符串放入其中。随后，我们用值`5`重新定义了变量。'
- en: By default, in TypeScript, every variable that does not have its type declared,
    or that has its value defined in its declaration, is of type `any`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在TypeScript中，每个没有声明类型的变量，或者在其声明中定义了值的变量，都是`any`类型。
- en: This language rule allows, for example, a project with JavaScript code to be
    incrementally converted to TypeScript by initially declaring all variables of
    the `any` type. Another use of the `any` type is when your code needs the flexibility
    of JavaScript for some more general algorithm types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言规则允许，例如，一个包含JavaScript代码的项目可以通过最初将所有变量声明为`any`类型来逐步转换为TypeScript。`any`类型的另一个用途是当您的代码需要JavaScript的灵活性以处理一些更通用的算法类型时。
- en: However, it is recommended that Angular developers avoid using `any` because
    it partially disables the checks that TypeScript performs in your code, without
    taking advantage of its power.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，建议Angular开发者避免使用`any`，因为它部分地禁用了TypeScript在您的代码中执行的检查，而没有充分利用其功能。
- en: We’ll see alternatives throughout the chapter, should you need the flexibility
    of the `any` type, without sacrificing type checking and TypeScript inference.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要`any`类型的灵活性，而又不想牺牲类型检查和TypeScript推断，本章将展示一些替代方案。
- en: Classes
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Building on our knowledge of basic types, let’s now create more complex data
    types. The first one we’re going to explore is **classes**. An essential element
    of object-oriented programming, the class represents a model, which can be real,
    such as a person or vehicle, or abstract, such as a text box on a web page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解基本类型的基础上，现在让我们创建更复杂的数据类型。我们将要探索的第一个是 **类**。面向对象编程的一个基本元素，类代表一个模型，可以是真实的，如人或车辆，也可以是抽象的，如网页上的文本框。
- en: 'From the class, we create the objects that are the elements that our systems
    will manipulate to execute a business rule, as in the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在课程中，我们创建了对象，这些对象是我们系统将用来执行业务规则的基本元素，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we declare the `Person` class with the `name` and `age` properties by
    typing the properties, and then we create a method for the class called `constructor`.
    This method is special because it defines the rule for how the object will be
    instantiated from this class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过键入属性声明 `Person` 类，具有 `name` 和 `age` 属性，然后我们为该类创建一个名为 `constructor` 的方法。这个方法很特殊，因为它定义了从该类实例化对象时的规则。
- en: In the `basic_class` function, we instantiate an object called `client`, which
    is of the `Person` type with the `new` keyword. To retrieve the properties of
    this instantiated object, we use the notation `client.name` and `client.age`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `basic_class` 函数中，我们使用 `new` 关键字实例化了一个名为 `client` 的对象，它是 `Person` 类型的。为了检索这个实例化对象的属性，我们使用
    `client.name` 和 `client.age` 的表示法。
- en: This declaration and use of class in TypeScript is almost the same as JavaScript
    except for typing the attributes of the class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中类的声明和使用几乎与 JavaScript 相同，只是对类的属性进行类型化。
- en: 'The same example in pure JavaScript would be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 JavaScript 中的相同示例如下：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the process of declaring the class and instantiating an object from
    it changes very little from TypeScript. However, as we will see in the following
    code block, TypeScript provides more resources for the use of the class in our
    projects.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，声明类和从它实例化对象的过程在 TypeScript 中变化很小。然而，正如我们将在下面的代码块中看到的，TypeScript 为我们在项目中使用类提供了更多的资源。
- en: 'In addition to attributes, classes also define methods, which are functions
    that an object can perform. In the example we are working on, we are now going
    to add a method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性之外，类还定义了方法，这些是对象可以执行的功能。在我们正在工作的示例中，我们现在将添加一个方法：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `toString` method returns a `string` that represents the object, so it accesses
    the attribute of the object instance using the reserved JavaScript word `this`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString` 方法返回一个表示对象的 `string`，因此它使用保留的 JavaScript 关键字 `this` 访问对象实例的属性。'
- en: There is a concept in object-oriented programming called the **encapsulation
    of attributes**. This consists of defining which attributes are accessible to
    the function that instantiates a given object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中有一个称为 **属性封装** 的概念。这包括定义哪些属性可供实例化给定对象的函数访问。
- en: 'This concept, important for the correct use of some design patterns, does not
    exist in its entirety in JavaScript. Every class attribute is public, but in TypeScript
    it is implemented and validated by the transpiler, as in the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念对于正确使用某些设计模式非常重要，但在 JavaScript 中并不完整存在。每个类属性都是公开的，但在 TypeScript 中，它通过编译器实现和验证，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we create a property called `id` that is generated when the object is
    instantiated, and we use the reserved word `private`, indicating that it should
    not be accessed from outside the class. Note that in class methods, this attribute
    is accessed normally.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `id` 的属性，该属性在对象实例化时生成，我们使用保留字 `private` 来表示它不应从类外部访问。请注意，在类方法中，此属性可以正常访问。
- en: 'Let’s try to force access from outside as in the following example to see what
    happens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从外部强制访问，如下面的示例所示，看看会发生什么：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this function, we instantiate a `client` object of the `Person` class and
    then we try to modify the `id` attribute. When trying to run the code, the TypeScript
    will indicate the following error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们实例化了一个 `Person` 类的 `client` 对象，然后我们尝试修改 `id` 属性。当尝试运行代码时，TypeScript
    将显示以下错误：
- en: '![Figure 3.1 – Error message when accessing a private attribute](img/B19562_03_1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 访问私有属性时的错误信息](img/B19562_03_1.jpg)'
- en: Figure 3.1 – Error message when accessing a private attribute
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 访问私有属性时的错误信息
- en: Another object-oriented programming concept is inheritance. It defines an *is
    a* relationship between classes, as in, *a customer is* *a person*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个面向对象编程的概念是继承。它定义了类之间的 *is a* 关系，例如，*一个客户是* *一个人*。
- en: 'In practice, it makes a class have all the attributes and methods of the extended
    class, as in the following example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，它使一个类具有扩展类的所有属性和方法，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are creating the `Client` class, which extends from the `Person` class.
    We add an attribute called `address` and create the constructor. As it is a class
    derived from `Person`, it is necessary to call the `super` method, which is the
    way we access the methods and attributes of the original class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个 `Client` 类，它从 `Person` 类扩展而来。我们添加一个名为 `address` 的属性并创建构造函数。由于它是一个从
    `Person` 继承而来的类，因此必须调用 `super` 方法，这是我们访问原始类的方法和属性的方式。
- en: When using inheritance, we can optionally rewrite a method of the original class
    as we do with the `toString` method. This concept exists in JavaScript, but with
    TypeScript, the rules for the constructor and method rewrite are checked at compile
    time, giving us more confidence in our development.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用继承时，我们可以选择性地重写原始类的方法，就像我们重写 `toString` 方法一样。这个概念在 JavaScript 中也存在，但 TypeScript
    会检查构造函数和方法重写的规则，在编译时进行检查，这增加了我们对开发的信心。
- en: Interfaces
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'In TypeScript, we have another way of typifying the structure of an object
    called an **interface**. The following example demonstrates its use:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们还有一种方式来指定对象的结构，称为 **接口**。以下示例演示了其用法：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To declare an interface, we use the reserved word `interface` and declare its
    properties as a class as we saw earlier.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个接口，我们使用保留字 `interface` 并像之前看到的那样将其属性声明为一个类。
- en: 'To use `interface`, we can proceed as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `interface`，我们可以这样做：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that to use a class, we just type the variable and declare its values,
    without using the reserved word `new`. This happens because the interface is not
    a JavaScript element and is only used by the TypeScript transpiler to check whether
    the object contains the defined properties.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使用一个类，我们只需输入变量并声明其值，而不使用保留字 `new`。这是因为接口不是 JavaScript 元素，它仅由 TypeScript
    编译器用于检查对象是否包含定义的属性。
- en: To prove that the interface does not exist, if we transpile the `interface`
    file, a blank file will be generated by TypeScript!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明接口不存在，如果我们编译 `interface` 文件，TypeScript 将生成一个空文件！
- en: 'We can also make use of interfaces to create contracts for classes, should
    a class require certain methods and attributes. Let’s see the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用接口为类创建合约，如果类需要某些方法和属性的话。让我们看看以下示例：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To define that a certain class follows the `DoSound` contract, we use the reserved
    word `implements`. TypeScript then requires that a method called `doASound` be
    defined and that this method returns a string.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个类遵循 `DoSound` 合约，我们使用保留字 `implements`。TypeScript 然后要求定义一个名为 `doASound`
    的方法，并且该方法返回一个字符串。
- en: 'This feature of the interface facilitates the use of a very important capability
    of the object-oriented language, which is **polymorphism**. Let’s see the example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接口这一特性促进了面向对象语言非常重要的能力——多态性的使用。让我们看看以下示例：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We create the `makeSound` function, which receives an animal that implements
    the `DoSound` contract. The function is not concerned with the type of animal
    or its attributes; it just needs to follow the `DoSound` interface contract, as
    it will invoke one of its methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `makeSound` 函数，它接收一个实现了 `DoSound` 合约的动物。该函数不关心动物的类型或其属性；它只需要遵循 `DoSound`
    接口合约，因为它将调用其方法之一。
- en: 'Angular uses this characteristic of TypeScript interfaces a lot, as we can
    see in the declaration of a component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 大量使用 TypeScript 接口的这一特性，正如我们可以在组件声明中看到的那样：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we inform Angular that the component implements the `OnInit` interface,
    it will execute the `ngOnInit` method required at the beginning of the component’s
    lifecycle (we will study this in more detail in [*Chapter 4*](B19562_04.xhtml#_idTextAnchor141),
    *Components* *and Pages*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通知 Angular 组件实现了 `OnInit` 接口时，它将在组件生命周期的开始执行所需的 `ngOnInit` 方法（我们将在 [*第 4
    章*](B19562_04.xhtml#_idTextAnchor141)，*组件* 和 *页面*）中更详细地研究这一点）。
- en: Type aliases
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'The last way to type a variable that we will see in this chapter is the simplest
    one, which is to create **type aliases**. Like interfaces, type aliases only exist
    in TypeScript, and we can use them as in the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将看到的最后一种类型化变量的方式是最简单的一种，即创建**类型别名**。与接口一样，类型别名仅存在于TypeScript中，我们可以在以下示例中使用它们：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we create the `Machine` type, describing the object we want to
    represent, and in the `basic_type` function, we instantiate a variable with that
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个`Machine`类型，描述了我们想要表示的对象，并在`basic_type`函数中，我们使用该类型实例化了一个变量。
- en: Note that we use the attributes of this variable just like the previous examples.
    This demonstrates how much TypeScript maintains the flexibility of JavaScript
    while giving more possibilities to the developer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用这个变量的属性就像之前的例子一样。这展示了TypeScript在保持JavaScript的灵活性同时，为开发者提供了更多可能性。
- en: 'A well-used feature of type aliases is the creation of a type from other types.
    One of the most common is the union of types, as we can see in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名的常用特性之一是从其他类型创建一个类型。其中最常见的是类型的联合，正如我们可以在以下代码中看到：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are creating a type called `id`, which can be `string` or `number`.
    For this, we use the `|` symbol, which is the same as used in JavaScript to indicate
    the conditional *OR*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在创建一个名为`id`的类型，它可以是一个`string`或`number`。为此，我们使用`|`符号，这与JavaScript中用来表示条件*OR*的符号相同。
- en: This feature was important for the use of more advanced techniques, such as
    the `guard` type, which we will see in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性对于使用更高级的技术非常重要，例如`guard`类型，我们将在本章中看到。
- en: When to use classes, interfaces, or types
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用类、接口或类型
- en: 'With all these ways of creating typed objects, you must be wondering in which
    situations we should use each one. Based on the characteristics of each form,
    we can categorize the use of each one:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些创建类型化对象的方式中，你可能会想知道在哪些情况下我们应该使用哪一种。基于每种形式的特性，我们可以对每种使用进行分类：
- en: '**Type alias**: The simplest form of creation, recommended for typing input
    parameters and function returns.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型别名**：创建的最简单形式，推荐用于类型化输入参数和函数返回值。'
- en: '`implements` keyword.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`implements`关键字。'
- en: '**Classes**: The basis of object orientation, also present in JavaScript. We
    should use it whenever we need an object with methods and attributes. In Angular,
    all components and services are ultimately objects created from classes.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：面向对象的基础，也存在于JavaScript中。当我们需要具有方法和属性的对象时，我们应该使用它。在Angular中，所有组件和服务最终都是通过类创建的对象。'
- en: Remember that in TypeScript, it is possible to create an `alias` type that behaves
    as an interface, as well as indicate an interface as a parameter and return of
    a function, but the recommendations here advise you to use the best for each type
    of situation and also explain how they are normally used in Angular apps.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在TypeScript中，你可以创建一个表现得像接口的`alias`类型，以及将接口作为函数的参数和返回值，但这里的建议是针对每种情况使用最佳实践，并解释它们通常如何在Angular应用程序中使用。
- en: Now that we have a good understanding of the different ways of creating more
    complex variables as objects, let’s get to know how to create functions and methods
    with TypeScript.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了创建更复杂变量作为对象的不同方式，让我们来了解如何使用TypeScript创建函数和方法。
- en: Creating methods and functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方法和函数
- en: One of the best ways used by TypeScript to improve the developer experience
    in Angular application development is through the ability to type parameters and
    return functions and methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript用来改善Angular应用程序开发中开发者体验的最好方法之一是通过能够类型化参数和函数及方法。
- en: Both for developers who create libraries and frameworks and for those who consume
    these software components, knowing what a function expects and what the expected
    return is allows us to reduce the time spent reading and looking for documentation,
    especially the runtime bugs that our system may encounter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建库和框架的开发者以及使用这些软件组件的开发者来说，了解函数期望什么以及预期的返回值可以让我们减少阅读和查找文档的时间，特别是我们系统可能遇到的运行时错误。
- en: 'To carry out the typing of the parameters and the return of a function, let’s
    consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要对函数的参数和返回值进行类型化，让我们考虑以下示例：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we start by defining an interface that represents an invoice
    item and then we create a type that will represent an invoice, which in this simplification
    is an array of items.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义一个表示发票项目的接口，然后创建一个表示发票的类型，在这个简化中，它是一个项目的数组。
- en: This demonstrates how we can use interfaces and types to better express our
    TypeScript code. Soon after, we create a function that returns the total value
    of the invoice; as an input parameter, we receive a value with the invoice type,
    and the return of the function will be a `number`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了我们如何使用接口和类型更好地表达我们的 TypeScript 代码。不久之后，我们创建了一个返回发票总价值的函数；作为输入参数，我们接收一个具有发票类型的值，函数的返回值将是
    `number`。
- en: 'Finally, we create an example function to use the `getTotalInvoice` function.
    Here, in addition to type checking, if we use an editor with TypeScript support
    such as VS Code, we have basic documentation and autocomplete, as shown in the
    following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个示例函数来使用 `getTotalInvoice` 函数。在这里，除了类型检查之外，如果我们使用具有 TypeScript 支持的编辑器，如
    VS Code，我们将获得基本的文档和自动完成功能，如下面的截图所示：
- en: '![Figure 3.2 – Documentation generated by TypeScript and visualized by VS Code](img/B19562_03_2.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 由 TypeScript 生成并由 VS Code 可视化的文档](img/B19562_03_2.jpg)'
- en: Figure 3.2 – Documentation generated by TypeScript and visualized by VS Code
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 由 TypeScript 生成并由 VS Code 可视化的文档
- en: In addition to primitive types and objects, functions must also be prepared
    to handle null data or undefined variables. In the next section, we will explore
    how to implement this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始类型和对象之外，函数还必须准备好处理 null 数据或未定义变量。在下一节中，我们将探讨如何实现这一点。
- en: Working with null values
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 null 值
- en: In TypeScript, by default, all function and method parameters are required and
    checked by the transpiler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，默认情况下，所有函数和方法参数都是必需的，并且由编译器进行检查。
- en: 'If any parameter is optional, we can define it in the type it represents, as
    in the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何参数是可选的，我们可以在它所代表的类型中定义它，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Within this function of applying a discount to the invoice, we created an optional
    parameter that allows the user of the function to determine a product to apply
    the discount. If the parameter is not defined, the discount is applied to the
    entire invoice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用折扣到发票的函数中，我们创建了一个可选参数，允许函数用户确定要应用折扣的产品。如果该参数未定义，折扣将应用于整个发票。
- en: 'To define an optional parameter, we use the `?` character. In TypeScript, optional
    parameters must be the last to be defined in a function. If we change the position
    of the function parameters the following error is thrown by the transpiler:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个可选参数，我们使用 `?` 字符。在 TypeScript 中，可选参数必须是函数中最后定义的。如果我们更改函数参数的位置，编译器将抛出以下错误：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Additionally, TypeScript allows you to define a default value for the parameter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，TypeScript 允许您为参数定义一个默认值：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When assigning a value in the parameter declaration, if the function user does
    not use the parameter, a 10% discount will be applied to the invoice items.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数声明中赋值时，如果函数用户没有使用该参数，将对发票项目应用10%的折扣。
- en: We’ve seen how we can use TypeScript to typify function parameters and returns.
    Now let’s discuss type inference and how we can use it to reduce the verbosity
    of our code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 TypeScript 来类型化函数参数和返回值。现在让我们讨论类型推断以及我们如何使用它来减少代码的冗余。
- en: Decreasing verbosity – type inference
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少冗余 – 类型推断
- en: In this chapter, we saw the best TypeScript capabilities that help in the development
    of our Angular projects. We were typing all the variables and relying on the TypeScript
    transpiler to avoid errors that would otherwise occur in our user’s runtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了 TypeScript 的最佳功能，这些功能有助于我们开发 Angular 项目。我们输入所有变量，并依赖 TypeScript 编译器来避免在用户运行时可能发生的错误。
- en: 'Let’s now explore TypeScript’s powerful inference mechanisms. Through it, TypeScript
    identifies the types of variables by content, not requiring you to define the
    type explicitly. Let’s observe the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索 TypeScript 强大的推断机制。通过它，TypeScript 通过内容识别变量的类型，而不需要您显式地定义类型。让我们观察以下示例：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This example is the same as in *Primitive and basic types*, but we directly
    inform the values in the variables. This way of declaring the variable has the
    same effect as the explicit method. If you change the value of a variable to another
    type, TypeScript will perform the validation as in the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与 *原始和基本类型* 中的例子相同，但我们直接在变量中告知值。这种声明变量的方式与显式方法具有相同的效果。如果您更改变量的值为另一种类型，TypeScript
    将执行如下示例中的验证：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: TypeScript can also infer complex types, such as arrays and function returns.
    A good practice here is to use the inference capability to write less code and
    type only objects from interfaces, for example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 也可以推断复杂类型，如数组和函数返回值。在这里的一个好做法是使用推断能力来编写更少的代码，并且只从接口中类型化对象，例如。
- en: Validating types – type guards
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证类型 – 类型守卫
- en: 'Now that we know the TypeScript inference mechanism, we can understand another
    feature present in it, **type guards**. Let’s consider these in the following
    example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 TypeScript 的推断机制，我们可以理解其中另一个特性，**类型守卫**。让我们在以下示例中考虑这些内容：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this function, we can receive a value that can be of the primitive types
    `string` or `number`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们可以接收一个可以是原始类型 `string` 或 `number` 的值。
- en: As they are primitive types, we can use the `typeof` function to define whether
    the variable is numeric; otherwise, it is a string and we must convert it to numeric.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是原始类型，我们可以使用 `typeof` 函数来定义变量是否为数值型；否则，它是一个 `string`，我们必须将其转换为数值型。
- en: The TypeScript transpiler can interpret the context of this conditional and
    within each one, it treats the value as a `number` or `string`, including in VS
    Code’s autocomplete.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 转译器可以解释这个条件语句的上下文，并在其中将值视为 `number` 或 `string`，包括在 VS Code 的自动完成中。
- en: '![Figure 3.3 – Inside the conditional TypeScript, which recognizes the variable
    as a number](img/B19562_03_3.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – TypeScript 中的条件部分，识别变量为数字](img/B19562_03_3.jpg)'
- en: Figure 3.3 – Inside the conditional TypeScript, which recognizes the variable
    as a number
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – TypeScript 中的条件部分，识别变量为数字
- en: The VS Code plugin in the figure is running the transpiler in the background
    and identifies that the variable inside the `if` statement can only be a `number`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的 VS Code 插件在后台运行转译器，并识别出 `if` 语句内部的变量只能是一个 `number`。
- en: '![Figure 3.4 – Inside the conditional else TypeScript, which recognizes the
    variable as a string](img/B19562_03_4.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – TypeScript 中的条件 else 部分，识别变量为字符串](img/B19562_03_4.jpg)'
- en: Figure 3.4 – Inside the conditional else TypeScript, which recognizes the variable
    as a string
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – TypeScript 中的条件 else 部分，识别变量为字符串
- en: As they are primitive types, we can use the `typeof` function to define whether
    the variable is numeric; otherwise, it is a `string`, and we must convert it to
    numeric.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是原始类型，我们可以使用 `typeof` 函数来定义变量是否为数值型；否则，它是一个 `string`，我们必须将其转换为数值型。
- en: 'For more complex data types such as objects, this guard using the `typeof`
    function is not possible because it will always recognize the variable of the
    `object` type. However, we can create our own custom type guard functions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的数据类型，如对象，使用 `typeof` 函数的这种守卫是不可能的，因为它总是会识别变量为 `object` 类型。然而，我们可以创建自己的自定义类型守卫函数：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we have two interfaces, `Person` and `Company`, and we create a type called
    `Client`. For each type of object that follows the interfaces, we have an `id`
    type `socialSecurityNumber` for people and `corporateNumber` for companies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个接口，`Person` 和 `Company`，我们创建了一个名为 `Client` 的类型。对于遵循接口的每种对象类型，我们都有一个
    `id` 类型，对于个人是 `socialSecurityNumber`，对于公司是 `corporateNumber`。
- en: To carry out the `guard` type, we created the `isPerson` function. The difference
    regarding this function is that we put the `client is Person` expression in the
    definition of the return of the function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行 `guard` 类型，我们创建了 `isPerson` 函数。关于这个函数的不同之处在于，我们将 `client is Person` 表达式放在了函数返回值的定义中。
- en: In it, we define the rule to consider an object as a person and use it in the
    `getID` function. Not only do we have a function that checks the object at runtime,
    but in this way, the TypeScript transpiler checks at compile time whether the
    operation has reported an error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们定义了将对象视为人的规则，并在 `getID` 函数中使用它。我们不仅有一个在运行时检查对象的函数，而且以这种方式，TypeScript 转译器在编译时检查操作是否报告了错误。
- en: Using a better alternative to the any type
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 better alternative 到 any 类型
- en: In the development of TypeScript applications, we may have situations where
    we do not know which type of parameter we are going to receive, such as the return
    of an API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 应用程序的开发过程中，我们可能会遇到不知道将要接收哪种类型参数的情况，例如 API 的返回值。
- en: What is trafficked can be defined by creating an interface that represents the
    data, (for more details, see [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163)*,
    Angular Services and the Singleton Pattern*). It is not possible to guarantee
    this because pure text is trafficked on the internet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建表示数据的接口可以定义传输的内容，（更多详情，见 [*第 5 章*](B19562_05.xhtml#_idTextAnchor163)*，Angular
    服务和单例模式*）。由于纯文本在互联网上传输，因此无法保证这一点。
- en: In these cases, we can use the `any` type, which prevents TypeScript from doing
    the type checking.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以使用 `any` 类型，这可以防止 TypeScript 进行类型检查。
- en: 'In this example, we can see the use of `any`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到 `any` 的使用：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code sample, we create an interface that represents a product
    and a type that represents a list of products. We then create a function that
    receives an `id` of the `any` type and searches the `Array`, returning an item
    from the list of products.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个表示产品的接口和一个表示产品列表的类型。然后我们创建了一个接收 `any` 类型 `id` 的函数，并在 `Array`
    中搜索，从产品列表中返回一个项。
- en: 'In these simple examples, we can assume that there is no bug, but let’s create
    a function that will use this snippet and see what happens:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些简单的例子中，我们可以假设没有错误，但让我们创建一个将使用此片段的函数，看看会发生什么：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the item was not found because the variable we passed was a
    `string`. This could happen if the data we are passing to the function came from
    an API or external call, and the data was not properly formatted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，项目未找到是因为我们传递的变量是一个 `string`。这可能发生在我们传递给函数的数据来自 API 或外部调用，并且数据格式不正确。
- en: 'Running the code, we get the following result:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，我们得到以下结果：
- en: '![Figure 3.5 – Function returned No product found due to the id variable typing](img/B19562_03_5.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 由于 id 变量类型错误，函数返回“未找到产品”](img/B19562_03_5.jpg)'
- en: Figure 3.5 – Function returned No product found due to the id variable typing
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 由于 id 变量类型错误，函数返回“未找到产品”
- en: When we use the `any` type, we give up the advantage of type checking and this
    type of bug can occur in our application. But how can we have the flexibility
    of the `any` type without losing TypeScript’s type checking?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `any` 类型时，我们放弃了类型检查的优势，这种类型的错误可能会出现在我们的应用程序中。但如何在不失去 TypeScript 类型检查的情况下拥有
    `any` 类型的灵活性？
- en: 'In these cases, we use the `unknown` type. This type has the same flexibility
    as the `any` type, but with one detail: TypeScript forces you to perform type
    guarding before using the variable.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们使用 `unknown` 类型。这种类型与 `any` 类型具有相同的灵活性，但有一个细节：TypeScript 强制你在使用变量之前执行类型守卫。
- en: 'Let’s refactor our example function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的示例函数：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we declare that `id` will be of an `unknown` type and, right after that,
    we make a `guard` type in this variable, dealing with the possible scenario of
    the variable being numerical.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明 `id` 将是 `unknown` 类型，紧接着我们在该变量中创建一个 `guard` 类型，处理变量可能是数字的可能情况。
- en: The `any` type will still be used in your application, but consider using the
    `unknown` type to ensure correct type handling when you are not sure who will
    call your function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 类型仍将在你的应用程序中使用，但考虑使用 `unknown` 类型以确保当你不确定谁会调用你的函数时，可以正确处理类型。'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we can use TypeScript to create better-quality code
    with less effort, increasing our productivity. We learned about basic TypeScript
    types, such as `number`, `string`, and `Array`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到了如何使用 TypeScript 以更少的努力创建更高质量的代码，从而提高我们的生产力。我们学习了基本 TypeScript 类型，如
    `number`、`string` 和 `Array`。
- en: We also studied creating classes, interfaces, and type aliases, and how we can
    choose and mix these types of structures to make our code cleaner and more maintainable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了创建类、接口和类型别名，以及我们如何选择和混合这些结构类型，使我们的代码更简洁、更易于维护。
- en: Finally, we learned about TypeScript’s type inference mechanism and how we can
    use the concept of type guards to further improve the type-checking mechanism.
    With these concepts, we also became familiar with the `unknown` type, which provides
    a better alternative to the `any` type.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了 TypeScript 的类型推断机制以及我们如何使用类型守卫的概念来进一步改进类型检查机制。通过这些概念，我们还熟悉了 `unknown`
    类型，它为 `any` 类型提供了一个更好的替代方案。
- en: In the next chapter we will learn about the basics of the interfaces of an Angular
    project, that is, the Components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 Angular 项目接口的基础知识，即组件。
