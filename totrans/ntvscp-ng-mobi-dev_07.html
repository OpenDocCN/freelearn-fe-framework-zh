<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building the Multitrack Player</h1>
                
            
            <article>
                
<p class="mce-root">We've made it to the keystone of NativeScript development: Direct access to Objective-C/Swift APIs on iOS and Java APIs on Android via TypeScript.</p>
<p class="mce-root">This is, by far, one of the most unique aspects of NativeScript and opens up many opportunities to you as a mobile developer. In particular, our app is going to need to take advantage of rich native audio APIs on both iOS and Android to achieve its core competency of delivering a compelling multitrack recording/mixing experience to our users.</p>
<p class="mce-root">Understanding how to code against these APIs will be essential to unlocking your mobile app's full potential. Additionally, learning how to integrate existing NativeScript plugins, which may already provide consistent APIs on both iOS and Android, can help you reach your goals even faster. Leveraging the best performance each platform can deliver will be the focus of our journey in Part 3. </p>
<p class="mce-root">In this chapter, we will cover the following:</p>
<ul class="calibre13">
<li class="calibre14">Integrating the Nativescript-audio plugin </li>
<li class="calibre14">Creating a model for our track player for future scalability</li>
<li class="calibre14">Working with RxJS observables</li>
<li class="calibre14">Understanding Angular's NgZone with third-party libraries and view bindings</li>
<li class="calibre14">Handling audio playback sync with multiple audio sources</li>
<li class="calibre14">Taking advantage of Angular's bindings, as well as NativeScript's native event bindings, to achieve the exact usability we're after</li>
<li class="calibre14">Building a custom shuttle slider for our player controls using Angular platform-specific directives</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing our multitrack player via the nativescript-audio plugin</h1>
                
            
            <article>
                
<p class="mce-root">Luckily, the NativeScript community has published a plugin that provides us with a consistent API to use across both iOS and Android to get going with an audio player. Feel free to browse <a href="http://plugins.nativescript.org" class="calibre3">http://plugins.nativescript.org</a>, <em class="calibre21">the official source for NativeScript plugins,</em> before implementing features, in order to determine if an existing plugin may work for your project.</p>
<p class="mce-root">In this case, the <strong class="calibre1">nativescript-audio</strong> plugin found at <a href="http://plugins.nativescript.org/plugin/nativescript-audio" class="calibre3">http://plugins.nativescript.org/plugin/nativescript- audio</a> contains what we need to start integrating the player portion of our app's features, and it works on both iOS and Android. <em class="calibre21">It even provides a recorder we may be able to use</em>. Let's start by installing it:</p>
<pre class="calibre22"><strong class="calibre1">npm install nativescript-audio --save</strong></pre>
<p class="mce-root">The NativeScript framework allows you to integrate with any npm module, opening up a dizzying array of integration possibilities, including NativeScript specific plugins. In fact, if you ever run into a situation where an npm module is giving you trouble (perhaps, because it relies on a node API not compatible in the NativeScript environment), there's even a plugin to help you deal with that at <a href="https://www.npmjs.com/package/nativescript-nodeify" class="calibre3">https://www.npmjs.com/package/nativescript-nodeify</a>. It is described in detail at <a href="https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript" class="calibre3">https://www.nativescript.org/blog/how-to-use-any-npm-module-with-nativescript</a>.</p>
<div class="packt_tip">Whenever integrating with a NativeScript plugin, create a model or Angular service around its integration to provide isolation around that integration point.</div>
<p class="mce-root"><strong class="calibre1">Try to isolate third-party plugin integration points by creating a reusable model or Angular service around that plugin</strong>. This will not only provide your app with nice scalability into the future, but will give you more flexibility down the road if you need to swap that plugin out with something different and/or provide different implementations on iOS or Android.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building the TrackPlayerModel for our multitrack player</h1>
                
            
            <article>
                
<p class="mce-root">We need each track to have its own instance of an audio player, as well as to expose an API to load the track's audio file. This will also provide a good place to expose the track's duration once the audio file is loaded.</p>
<p class="mce-root">Since this model will likely be shared across the entire app (foreseeably with recording playback in the future as well), we will create this with our other models in <kbd class="calibre11">app/modules/shared/models/track-player.model.ts</kbd>:</p>
<pre class="calibre22">// libs<br class="title-page-name"/>import { TNSPlayer } from 'nativescript-audio';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack } from 

'./track.model';<br class="title-page-name"/><br class="title-page-name"/>interface ITrackPlayer {<br class="title-page-name"/>  trackId: number;<br class="title-page-name"/>  duration: number;<br class="title-page-name"/>  readonly 

player: TNSPlayer;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>export class TrackPlayerModel implements ITrackPlayer {<br class="title-page-name"/>  public trackId: 

number;<br class="title-page-name"/>  public duration: number;<br class="title-page-name"/><br class="title-page-name"/>  private _player: TNSPlayer;<br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>    

this._player = new TNSPlayer();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public load(track: ITrack): Promise&lt;number&gt; {<br class="title-page-name"/>    return 

new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>      this.trackId = track.id;<br class="title-page-name"/><br class="title-page-name"/>      this._player.initFromFile({<br class="title-page-name"/>        audioFile: track.filepath,<br class="title-page-name"/>        loop: false<br class="title-page-name"/>      }).then(() =&gt; {<br class="title-page-name"/><br class="title-page-name"/>        

this._player.getAudioTrackDuration()<br class="title-page-name"/>          .then((duration) =&gt; {<br class="title-page-name"/>            this.duration = +duration;<br class="title-page-name"/>            resolve();<br class="title-page-name"/>          });<br class="title-page-name"/>      });<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public get player(): 

TNSPlayer {<br class="title-page-name"/>    return this._player;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We start by importing the sweet NativeScript community audio player <kbd class="calibre11">TNSPlayer</kbd> from the <kbd class="calibre11">nativescript- audio</kbd> plugin. We then define a simple interface to implement for our model which, will reference <kbd class="calibre11">trackId</kbd>, its <kbd class="calibre11">duration</kbd>, and a <kbd class="calibre11">readonly</kbd> getter for the <kbd class="calibre11">player</kbd> instance. Then, we include that interface to use with our implementation, which constructs an instance of <kbd class="calibre11">TNSPlayer</kbd> with itself. Since we want a flexible model that can load its track file at any time, we provide a <kbd class="calibre11">load</kbd> method taking <kbd class="calibre11">ITrack</kbd> that utilizes the <kbd class="calibre11">initFromFile</kbd> method. This, in turn, asynchronously fetches the track's total duration (returned as a string, so we use <kbd class="calibre11">+duration</kbd>) to store the number on the model before resolving the track's initialization completes.</p>
<p class="mce-root">For consistency and standards, just be sure to also export this new model from <kbd class="calibre11">app/modules/shared/models/index.ts</kbd>:</p>
<pre class="calibre22">export * from './composition.model';<br class="title-page-name"/><strong class="calibre1">export * from './track-player.model';</strong><br class="title-page-name"/>export * from 

'./track.model';</pre>
<p class="mce-root">Lastly, we provide a getter for the player instance that <kbd class="calibre11">PlayerService</kbd> will use. This brings us to our next step: open <kbd class="calibre11">app/modules/player/services/player.service.ts</kbd>. We are going to change up our initial implementation a bit with our latest developments; have a look at this in totality and we will explain afterward:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/><strong class="calibre1">import { Subject } 

from 'rxjs/Subject';</strong><br class="title-page-name"/><strong class="calibre1">import { Observable } from 'rxjs/Observable';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack, CompositionModel, <strong class="calibre1">TrackPlayerModel</strong> } from '../../shared/models';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/><br class="title-page-name"/>  // observable state<br class="title-page-name"/>  <strong class="calibre1">public playing$: 

Subject&lt;boolean&gt; = new Subject();</strong><br class="title-page-name"/><strong class="calibre1">  public duration$: Subject&lt;number&gt; = new Subject

();</strong><br class="title-page-name"/><strong class="calibre1">  public currentTime$: Observable&lt;number&gt;;</strong><br class="title-page-name"/><br class="title-page-name"/>  // active composition<br class="title-page-name"/>  <strong class="calibre1">private _composition: CompositionModel;</strong><br class="title-page-name"/>  // internal state <br class="title-page-name"/>  <strong class="calibre1">private _playing: 

boolean;</strong><br class="title-page-name"/>  // collection of track players<br class="title-page-name"/>  <strong class="calibre1">private _trackPlayers: Array&lt;TrackPlayerModel&gt; 

= [];</strong><br class="title-page-name"/>  // used to report currentTime from<br class="title-page-name"/>  <strong class="calibre1">private _longestTrack: 

TrackPlayerModel;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>    // observe currentTime changes every 1 seconds<br class="title-page-name"/>    

<strong class="calibre1">this.currentTime$ = Observable.interval(1000)</strong><br class="title-page-name"/><strong class="calibre1">      .map(_ =&gt; 

</strong><strong class="calibre1">this._longestTrack ?</strong><br class="title-page-name"/><strong class="calibre1">          this._longestTrack.player.currentTime</strong><br class="title-page-name"/><strong class="calibre1">          : 0</strong><strong class="calibre1">);</strong><br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public set playing(value: boolean) 

{</strong><br class="title-page-name"/><strong class="calibre1">    this._playing = value;</strong><br class="title-page-name"/><strong class="calibre1">    this.playing$.next(value);</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public get playing(): boolean {</strong><br class="title-page-name"/><strong class="calibre1">    return 

this._playing;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  public get composition(): CompositionModel 

{</strong><br class="title-page-name"/><strong class="calibre1">    return this._composition;</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public set 

composition(comp: CompositionModel) {</strong><br class="title-page-name"/><strong class="calibre1">    this._composition = comp;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">    

// clear any previous players</strong><br class="title-page-name"/><strong class="calibre1">    this._resetTrackPlayers();</strong><br class="title-page-name"/><strong class="calibre1">    // setup 

player instances for each track</strong><br class="title-page-name"/><strong class="calibre1">    let initTrackPlayer = (index: number) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">      let track = this._composition.tracks[index];</strong><br class="title-page-name"/><strong class="calibre1">      let trackPlayer = new 

TrackPlayerModel();</strong><br class="title-page-name"/><strong class="calibre1">      trackPlayer.load(track).then(_ =&gt; {</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        

this._trackPlayers.push(trackPlayer);</strong><br class="title-page-name"/><strong class="calibre1">        index++;</strong><br class="title-page-name"/><strong class="calibre1">        if (index &lt; 

this._composition.tracks.length) {</strong><br class="title-page-name"/><strong class="calibre1">          initTrackPlayer(index);</strong><br class="title-page-name"/><strong class="calibre1">        } 

else {</strong><br class="title-page-name"/><strong class="calibre1">          // report total duration of composition</strong><br class="title-page-name"/><strong class="calibre1">          

this._updateTotalDuration();</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">      });</strong><br class="title-page-name"/><strong class="calibre1">    

};</strong><br class="title-page-name"/><strong class="calibre1">    // kick off multi-track player initialization</strong><br class="title-page-name"/><strong class="calibre1">    initTrackPlayer

(0);</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  public togglePlay() {</strong><br class="title-page-name"/><strong class="calibre1">    this.playing = 

!this.playing;</strong><br class="title-page-name"/><strong class="calibre1">    if (this.playing) {</strong><br class="title-page-name"/><strong class="calibre1">      this.play();</strong><br class="title-page-name"/><strong class="calibre1">    } else {</strong><br class="title-page-name"/><strong class="calibre1">      this.pause();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }

</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public play() {</strong><br class="title-page-name"/><strong class="calibre1">    for (let t of this._trackPlayers) {</strong><br class="title-page-name"/><strong class="calibre1">      t.player.play();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  public 

pause() {</strong><br class="title-page-name"/><strong class="calibre1">    for (let t of this._trackPlayers) {</strong><br class="title-page-name"/><strong class="calibre1">      t.player.pause

();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  ...<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private 

_updateTotalDuration() {</strong><br class="title-page-name"/><strong class="calibre1">    // report longest track as the total duration of the mix</strong><br class="title-page-name"/><strong class="calibre1">    let totalDuration = Math.max(</strong><br class="title-page-name"/><strong class="calibre1">      ...this._trackPlayers.map(t =&gt; 

t.duration));</strong><br class="title-page-name"/><strong class="calibre1">    // update trackPlayer to reflect longest track </strong><br class="title-page-name"/><strong class="calibre1">    for (let 

t of this._trackPlayers) {</strong><br class="title-page-name"/><strong class="calibre1">      if (t.duration === totalDuration) {</strong><br class="title-page-name"/><strong class="calibre1">        

this._longestTrack = t;</strong><br class="title-page-name"/><strong class="calibre1">        break;</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    }

</strong><br class="title-page-name"/><strong class="calibre1">    this.duration$.next(totalDuration);</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  

private _resetTrackPlayers() {</strong><br class="title-page-name"/><strong class="calibre1">    for (let t of this._trackPlayers) {</strong><br class="title-page-name"/><strong class="calibre1">      

t.cleanup();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">    this._trackPlayers = [];</strong><br class="title-page-name"/><strong class="calibre1">  }

</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">The cornerstone of <kbd class="calibre11">PlayerService</kbd> at this point is to not only manage the hard work of playing multiple tracks in the mix, but to provide a state, which our views can observe to reflect the composition's state. Hence, we have the following:</p>
<pre class="calibre22">...<br class="title-page-name"/>// observable state<br class="title-page-name"/>public playing$: Subject&lt;boolean&gt; = new Subject();<br class="title-page-name"/>public duration$: 

Subject&lt;number&gt; = new Subject();<br class="title-page-name"/>public currentTime$: Observable&lt;number&gt;;<br class="title-page-name"/><br class="title-page-name"/>// active 

composition<br class="title-page-name"/>private _composition: CompositionModel;<br class="title-page-name"/>// internal state <br class="title-page-name"/>private _playing: boolean;<br class="title-page-name"/>// 

collection of track players<br class="title-page-name"/>private _trackPlayers: Array&lt;TrackPlayerModel&gt; = [];<br class="title-page-name"/>// used to report 

currentTime from<br class="title-page-name"/>private _longestTrack: TrackPlayerModel;<br class="title-page-name"/><br class="title-page-name"/>constructor() {<br class="title-page-name"/>  // observe currentTime 

changes every 1 seconds<br class="title-page-name"/>  this.currentTime$ = Observable.interval(1000)<br class="title-page-name"/>    .map(_ =&gt; this._longestTrack ?<br class="title-page-name"/>      this._longestTrack.player.currentTime<br class="title-page-name"/>      : 0);<br class="title-page-name"/>  }<br class="title-page-name"/>  ...</pre>
<p class="mce-root">Our view will need to know the playing state as well as <kbd class="calibre11">duration</kbd> and <kbd class="calibre11">currentTime</kbd>. Using <kbd class="calibre11">Subject</kbd> for the <kbd class="calibre11">playing$</kbd> and <kbd class="calibre11">duration$</kbd> states will work well, since they are as follows:</p>
<ul class="calibre13">
<li class="calibre14">They can emit values directly</li>
<li class="calibre14">They don't need to emit an initial value</li>
<li class="calibre14">They don't need any observable composition</li>
</ul>
<p class="mce-root">On the other hand, <kbd class="calibre11">currentTime$</kbd> is going to be set up with some composition in mind, since its value will be dependent on an intermittent state that may develop over time (more on this shortly!). In other words, the <kbd class="calibre11">playing$</kbd> state is a value we control and emit directly via play actions made by the user (or internally based on player state) and the <kbd class="calibre11">duration$</kbd> state is a value we emit directly as a result of all our track's players becoming initialized and ready<strong class="calibre1">. </strong> </p>
<p class="mce-root"><kbd class="calibre11">currentTime</kbd> is a value that the player does not emit automatically via a player event but rather a value we must check for intermittently. Therefore, we compose <kbd class="calibre11">Observable.interval(1000)</kbd> that will auto emit our mapped value representing the longest track's player instance's actual <kbd class="calibre11">currentTime</kbd> every 1 second upon its subscription. </p>
<p class="mce-root">The other <kbd class="calibre11">private</kbd> references help maintain the internal state for the service's use. Most interestingly, we will keep a reference to <kbd class="calibre11">_longestTrack</kbd>, since our composition's total duration will always be based on the longest track and, hence, will also be used to track <kbd class="calibre11">currentTime</kbd>.</p>
<p class="mce-root">This set up will provide the essentials of what our view will need to suffice proper user interaction.</p>
<p class="mce-root"><em class="calibre21">RxJS does not include any operators by default. Therefore, <kbd class="calibre11">Observable.interval(1000)</kbd> and <kbd class="calibre11">.map</kbd> will crash your app right now if you are to run it!</em></p>
<div class="packt_tip">The minute you start working more with RxJS, it's a good idea to create an <kbd class="calibre29">operators.ts</kbd> file to import all your RxJS operators into. Then, import that file in your root <kbd class="calibre29">AppComponent</kbd>, so you don't end up with those operator imports scattered everywhere throughout your codebase.</div>
<p class="mce-root">Create <kbd class="calibre11">app/operators.ts</kbd> with the following:</p>
<pre class="calibre22">import 'rxjs/add/operator/map';<br class="title-page-name"/>import 'rxjs/add/observable/interval';</pre>
<p class="mce-root">Then, open <kbd class="calibre11">app/app.component.ts</kbd> and import that file on the very first line:</p>
<pre class="calibre22">import './operators';<br class="title-page-name"/>...</pre>
<p class="mce-root">Now, we are free to use map, interval, and any other <kbd class="calibre11">rxjs</kbd> operators we need anywhere in our code, provided we import them into that single file.</p>
<p class="mce-root">The next bit of our service is rather self-explanatory:</p>
<pre class="calibre22">public set playing(value: boolean) {<br class="title-page-name"/>  this._playing = value;<br class="title-page-name"/>  this.playing$.next(value);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public get playing(): boolean {<br class="title-page-name"/>  return this._playing;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public get composition(): CompositionModel 

{<br class="title-page-name"/>  return this._composition;<br class="title-page-name"/>}</pre>
<p class="mce-root">Our <kbd class="calibre11">playing</kbd> setter ensures that the internal state, <kbd class="calibre11">_playing</kbd>, is updated, as well as our <kbd class="calibre11">playing$</kbd> subject's value emitted for any subscribers needing to react to this state change. Convenient getters are also added for good measure. The next setter for our composition gets rather interesting, as this is where we interact with our new <kbd class="calibre11">TrackPlayerModel</kbd>:</p>
<pre class="calibre22">public set composition(comp: CompositionModel) {<br class="title-page-name"/>  this._composition = comp;<br class="title-page-name"/><br class="title-page-name"/>  // clear any previous 

players<br class="title-page-name"/>  this._resetTrackPlayers();<br class="title-page-name"/>  // setup player instances for each track<br class="title-page-name"/>  let initTrackPlayer = 

(index: number) =&gt; {<br class="title-page-name"/>    let track = this._composition.tracks[index];<br class="title-page-name"/>    let trackPlayer = new 

TrackPlayerModel();<br class="title-page-name"/>    trackPlayer.load(track).then(_ =&gt; {<br class="title-page-name"/><br class="title-page-name"/>      this._trackPlayers.push

(trackPlayer);<br class="title-page-name"/>      index++;<br class="title-page-name"/>      if (index &lt; this._composition.tracks.length) {<br class="title-page-name"/>        

initTrackPlayer(index);<br class="title-page-name"/>      } else {<br class="title-page-name"/>        // report total duration of composition<br class="title-page-name"/>        

this._updateTotalDuration();<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/>  };<br class="title-page-name"/>  // kick off multi-track player initialization<br class="title-page-name"/> 

 initTrackPlayer(0);<br class="title-page-name"/>}<br class="title-page-name"/>...<br class="title-page-name"/>private _resetTrackPlayers() {<br class="title-page-name"/>  for (let t of this._trackPlayers) {<br class="title-page-name"/>   

 t.cleanup();<br class="title-page-name"/>  }<br class="title-page-name"/>  this._trackPlayers = [];<br class="title-page-name"/>}</pre>
<p class="mce-root">Whenever we set the active composition, we first ensure our service's internal <kbd class="calibre11">_trackPlayers</kbd> reference is properly cleaned up and cleared with <kbd class="calibre11">this._resetTrackPlayers()</kbd>. We then set up a local method <kbd class="calibre11">initTrackPlayer</kbd> that can be called iteratively, given the async nature of each player's <kbd class="calibre11">load</kbd> method to ensure each track's player is properly loaded with the audio file, including its duration. After each successful load, we add to our collection of <kbd class="calibre11">_trackPlayers</kbd>, iterate, and continue until all the audio files are loaded. When complete, we call <kbd class="calibre11">this._updateTotalDuration()</kbd> to determine the final duration of our composition of tracks:</p>
<pre class="calibre22">private _updateTotalDuration() {<br class="title-page-name"/>  // report longest track as the total duration of the mix<br class="title-page-name"/>  let 

totalDuration = Math.max(<br class="title-page-name"/>    ...this._trackPlayers.map(t =&gt; t.duration));<br class="title-page-name"/>  // update trackPlayer to reflect 

longest track <br class="title-page-name"/>  for (let t of this._trackPlayers) {<br class="title-page-name"/>    if (t.duration === totalDuration) {<br class="title-page-name"/>      

this._longestTrack = t;<br class="title-page-name"/>      break;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  this.duration$.next(totalDuration);<br class="title-page-name"/>}</pre>
<p class="mce-root">Since the track with the longest duration should always be used to determine the total duration of the entire composition, we use <kbd class="calibre11">Math.max</kbd> to determine what the longest duration is and then store a reference to the track. Because multiple tracks could have the same duration, it doesn't really matter which track is used, just as long as one matches the longest duration. This <kbd class="calibre11">_longestTrack</kbd> will be our <em class="calibre21">pace setter</em> if you will, as it will be used to determine <kbd class="calibre11">currentTime</kbd> of the entire composition. Lastly, we emit the longest duration as <kbd class="calibre11">totalDuration</kbd> via our <kbd class="calibre11">duration$</kbd> subject for any subscribing observers.</p>
<p class="mce-root">The next couple of methods provide the basis of our composition's overall playback control:</p>
<pre class="calibre22">public togglePlay() {<br class="title-page-name"/>  this.playing = !this.playing;<br class="title-page-name"/>  if (this.playing) {<br class="title-page-name"/>    this.play();<br class="title-page-name"/>  } 

else {<br class="title-page-name"/>    this.pause();<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public play() {<br class="title-page-name"/>  for (let t of this._trackPlayers) {<br class="title-page-name"/>   

 t.player.play();<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public pause() {<br class="title-page-name"/>  for (let t of this._trackPlayers) {<br class="title-page-name"/>    

t.player.pause();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">Our primary play button in our UI will use the <kbd class="calibre11">togglePlay</kbd> method to control playback and, hence, is used to toggle the internal state as well as engage all the track player's play or pause methods. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let the music play!  </h1>
                
            
            <article>
                
<p class="mce-root">To try all this out, let's add three sample audio files from a jazz track composed by the exquisite <em class="calibre21">Jesper Buhl Trio</em> called <em class="calibre21">What Is This Thing Called Love</em>. The tracks are already separated by drums, bass, and piano. We can add these <kbd class="calibre11">.mp3</kbd> files to an <kbd class="calibre11">app/audio</kbd> folder.</p>
<p class="mce-root">Let's modify our demo composition's tracks in <kbd class="calibre11">MixerService</kbd> to provide references to these new real audio files. Open <kbd class="calibre11">app/modules/mixer/services/mixer.service.ts</kbd> and make the following modifications:</p>
<pre class="calibre22">private _demoComposition(): Array&lt;IComposition&gt; {<br class="title-page-name"/>  // starter composition for user to demo on first 

launch<br class="title-page-name"/>  return [<br class="title-page-name"/>    {<br class="title-page-name"/>      id: 1,<br class="title-page-name"/>      name: 'Demo',<br class="title-page-name"/>      created: Date.now(),<br class="title-page-name"/>      

order: 0,<br class="title-page-name"/>      <strong class="calibre1">tracks: [</strong><br class="title-page-name"/><strong class="calibre1">        {</strong><br class="title-page-name"/><strong class="calibre1">          id: 1,</strong><br class="title-page-name"/><strong class="calibre1">          name: 'Drums',</strong><br class="title-page-name"/><strong class="calibre1">          order: 0,</strong><br class="title-page-name"/><strong class="calibre1">          filepath: 

'~/audio/drums.mp3'</strong><br class="title-page-name"/><strong class="calibre1">        },</strong><br class="title-page-name"/><strong class="calibre1">        {</strong><br class="title-page-name"/><strong class="calibre1">          

id: 2,</strong><br class="title-page-name"/><strong class="calibre1">          name: 'Bass',</strong><br class="title-page-name"/><strong class="calibre1">          order: 1,</strong><br class="title-page-name"/><strong class="calibre1">       

   filepath: '~/audio/bass.mp3'</strong><br class="title-page-name"/><strong class="calibre1">        },</strong><br class="title-page-name"/><strong class="calibre1">        {</strong><br class="title-page-name"/><strong class="calibre1">          id: 3,</strong><br class="title-page-name"/><strong class="calibre1">          name: 'Piano',</strong><br class="title-page-name"/><strong class="calibre1">          order: 

2,</strong><br class="title-page-name"/><strong class="calibre1">          filepath: '~/audio/piano.mp3'</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">      ]</strong><br class="title-page-name"/>    }<br class="title-page-name"/>  ];<br class="title-page-name"/>}</pre>
<p class="mce-root">Let's now provide an input to our player controls, which will take our selected composition. Open <kbd class="calibre11">app/modules/mixer/components/mixer.component.html</kbd>, and make the following highlighted modification:</p>
<pre class="calibre22">&lt;action-bar [title]="composition.name"&gt;&lt;/action-bar&gt;<br class="title-page-name"/>&lt;GridLayout rows="*, auto" columns="*" 

class="page"&gt;<br class="title-page-name"/>  &lt;track-list [tracks]="composition.tracks" row="0" col="0"&gt; <br class="title-page-name"/>  &lt;/track-list&gt;<br class="title-page-name"/>  

&lt;player-controls <strong class="calibre1">[composition]="composition"</strong><br class="title-page-name"/>    row="1" col="0"&gt;&lt;/player-controls&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">Then, in <kbd class="calibre11">PlayerControlsComponent</kbd> at <kbd class="calibre11">app/modules/player/components/player- controls/player-controls.component.ts</kbd>, we can now observe the state of <kbd class="calibre11">PlayerService</kbd> via its various observables:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, <strong class="calibre1">Input</strong> } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// libs<br class="title-page-name"/><strong class="calibre1">import { Subscription } from 'rxjs/Subscription';</strong><br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { ITrack, 

CompositionModel } from '../../../shared/models';<br class="title-page-name"/>import { PlayerService } from '../../services';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'player-controls',<br class="title-page-name"/>  templateUrl: 'player-

controls.component.html'<br class="title-page-name"/>})<br class="title-page-name"/>export class PlayerControlsComponent {<br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">@Input() composition: 

CompositionModel;</strong><br class="title-page-name"/> <br class="title-page-name"/>  // ui state<br class="title-page-name"/>  public playStatus: string = 'Play';<br class="title-page-name"/>  public duration: 

number = 0;<br class="title-page-name"/>  public currentTime: number = 0;<br class="title-page-name"/><br class="title-page-name"/>  // manage subscriptions<br class="title-page-name"/>  <strong class="calibre1">private _subPlaying: 

Subscription;</strong><br class="title-page-name"/><strong class="calibre1">  private _subDuration: Subscription;</strong><br class="title-page-name"/><strong class="calibre1">  private _subCurrentTime: 

Subscription;</strong><br class="title-page-name"/><br class="title-page-name"/>  constructor(<br class="title-page-name"/>    private playerService: PlayerService<br class="title-page-name"/>  ) { }<br class="title-page-name"/><br class="title-page-name"/>  

<strong class="calibre1">public togglePlay() {</strong><br class="title-page-name"/><strong class="calibre1">    this.playerService.togglePlay();</strong><br class="title-page-name"/><strong class="calibre1">  }

</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">ngOnInit() {</strong><br class="title-page-name"/>    // init audio player for composition<br class="title-page-name"/>    

<strong class="calibre1">this.playerService.composition = this.composition;</strong><br class="title-page-name"/>    // react to play state<br class="title-page-name"/>    

<strong class="calibre1">this._subPlaying = this.playerService.playing$</strong><br class="title-page-name"/><strong class="calibre1">      .subscribe((playing: boolean) =&gt; 

{</strong><br class="title-page-name"/>        // update button state<br class="title-page-name"/><strong class="calibre1">        this._updateStatus(playing); </strong><br class="title-page-name"/>        // 

update slider state<br class="title-page-name"/><strong class="calibre1">        if (playing) {</strong><br class="title-page-name"/><strong class="calibre1">          this._subCurrentTime = 

this.playerService</strong><br class="title-page-name"/><strong class="calibre1">            .currentTime$</strong><br class="title-page-name"/><strong class="calibre1">            .subscribe

((currentTime: number) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">              this.currentTime = currentTime;</strong><br class="title-page-name"/><strong class="calibre1">   

         });</strong><br class="title-page-name"/><strong class="calibre1">        } else if (this._subCurrentTime) {</strong><br class="title-page-name"/><strong class="calibre1">          

this._subCurrentTime.unsubscribe();</strong><br class="title-page-name"/><strong class="calibre1">        }</strong><br class="title-page-name"/><strong class="calibre1">      });</strong><br class="title-page-name"/>    // 

update duration state for slider<br class="title-page-name"/>    <strong class="calibre1">this._subDuration = this.playerService.duration$</strong><br class="title-page-name"/><strong class="calibre1">   

   .subscribe((duration: number) =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">        this.duration = duration;</strong><br class="title-page-name"/><strong class="calibre1">     

 });</strong><br class="title-page-name"/>  <strong class="calibre1">}</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">ngOnDestroy() {<br class="title-page-name"/></strong>    // cleanup<br class="title-page-name"/>    

<strong class="calibre1">if (this._subPlaying)</strong><br class="title-page-name"/><strong class="calibre1">      this._subPlaying.unsubscribe(); </strong><br class="title-page-name"/><strong class="calibre1">    if 

(this._subDuration)</strong><br class="title-page-name"/><strong class="calibre1">      this._subDuration.unsubscribe(); </strong><br class="title-page-name"/><strong class="calibre1">    if 

(this._subCurrentTime)</strong><br class="title-page-name"/><strong class="calibre1">      this._subCurrentTime.unsubscribe();</strong><br class="title-page-name"/>  <strong class="calibre1">}

</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">private _updateStatus(playing: boolean) {</strong><br class="title-page-name"/><strong class="calibre1">    this.playStatus = 

playing ? 'Stop' : 'Play';</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>}</pre>
<p class="mce-root">The cornerstone of <kbd class="calibre11">PlayerControlComponent</kbd> is now its ability to set the active composition via <kbd class="calibre11">this.playerService.composition = this.composition</kbd> inside <kbd class="calibre11">ngOnInit</kbd>, which is when the composition input is ready, as well as subscribe to the various states provided by <kbd class="calibre11">PlayerService</kbd> to update our UI. Most interesting here is the <kbd class="calibre11">playing$</kbd> subscription that manages the <kbd class="calibre11">currentTime$</kbd> subscription based on whether it's playing or not. If you recall, our <kbd class="calibre11">currentTime$</kbd> observable started with <kbd class="calibre11">Observable.interval(1000)</kbd>, meaning every one second, it will emit the longest track's <kbd class="calibre11">currentTime</kbd>, shown here again for reference:</p>
<pre class="calibre22">this.currentTime$ = Observable.interval(1000)<br class="title-page-name"/>  .map(_ =&gt; this._longestTrack ?<br class="title-page-name"/>    

this._longestTrack.player.currentTime<br class="title-page-name"/>    : 0);</pre>
<p class="mce-root">We only want to update <kbd class="calibre11">currentTime</kbd> of <span><kbd class="calibre11">Slider</kbd> </span>when playback is engaged; hence, the subscription when the <kbd class="calibre11">playing$</kbd> subject emit is <kbd class="calibre11">true</kbd>, which will allow our component to receive the player's <kbd class="calibre11">currentTime</kbd> every second. When <kbd class="calibre11">playing$</kbd> emit is <kbd class="calibre11">false</kbd>, we unsubscribe, to no longer receive the <kbd class="calibre11">currentTime</kbd> updates. Excellent.</p>
<p class="mce-root">We also subscribe to our <kbd class="calibre11">duration$</kbd> subject to update the Slider's maxValue. Lastly, we ensure all subscriptions are cleaned up via their <kbd class="calibre11">Subscription</kbd> references inside <kbd class="calibre11">ngOnDestroy</kbd>.</p>
<p class="mce-root">Let's take a look at our view bindings now for <kbd class="calibre11">PlayerControlsComponent</kbd> at <kbd class="calibre11">app/modules/player/components/player-controls/player-controls.component.html</kbd>:</p>
<pre class="calibre22">&lt;GridLayout rows="100" columns="100,*"<br class="title-page-name"/>  row="1" col="0" class="p-x-10"&gt;<br class="title-page-name"/>  &lt;Button [text]

="playStatus" <strong class="calibre1">(tap)="togglePlay()"</strong><br class="title-page-name"/>    row="0" col="0" class="btn btn-primary w-

100"&gt;&lt;/Button&gt;<br class="title-page-name"/>  &lt;Slider <strong class="calibre1">[maxValue]="duration" </strong><strong class="calibre1">[value]="currentTime" <br class="title-page-name"/></strong>    minValue="0" row="0" col="1" class="slider"&gt;  <br class="title-page-name"/>  &lt;/Slider&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">If you run the app, you can now select the <span>Demo</span> composition and play music on both iOS and Android.</p>
<p class="mce-root"><em class="calibre21">MUSIC TO OUR EARS! This is pretty awesome. In fact, it's friggin' sweet!!</em></p>
<p class="mce-root">There are a couple things you may notice or desire at this point:</p>
<ul class="calibre13">
<li class="calibre14">After choosing the Play button, it properly changes to Stop, but when playback reaches the end, it does not return to its original Play text.</li>
<li class="calibre14"><kbd class="calibre11">Slider</kbd> should also return to position 0 to reset playback.</li>
<li class="calibre14">The total <kbd class="calibre11">duration</kbd> and <kbd class="calibre11">currentTime</kbd> on iOS uses seconds; however, Android uses milliseconds.</li>
<li class="calibre14">On iOS, you may notice a very subtle playback sync issue on all the tracks if you choose to play/pause many times during the playback of the composition's demo tracks.</li>
<li class="calibre14">The current time and duration labels are needed.</li>
<li class="calibre14"><strong class="calibre1">Playback seeking</strong> would be nice to be able to shuttle our slider to control the position of playback.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Polishing the implementation</h1>
                
            
            <article>
                
<p class="mce-root">We're missing a few important pieces in our model and service to really polish off our implementation. Let's start with handling completion and error conditions with our track player instances. Open <kbd class="calibre11">TrackPlayerModel</kbd> at <kbd class="calibre11">app/modules/shared/models/track-player.model.ts</kbd> and add the following:</p>
<pre class="calibre22">...<strong class="calibre1"><br class="title-page-name"/>export interface IPlayerError {</strong><br class="title-page-name"/><strong class="calibre1">  trackId: number;</strong><br class="title-page-name"/><strong class="calibre1">  

error: any;</strong><br class="title-page-name"/><strong class="calibre1">}</strong><br class="title-page-name"/><br class="title-page-name"/>export class TrackPlayerModel implements ITrackPlayer {<br class="title-page-name"/>  <br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">private _completeHandler: (number) =&gt; void;</strong><br class="title-page-name"/><strong class="calibre1">  private _errorHandler: 

(IPlayerError) =&gt; void;</strong><br class="title-page-name"/><br class="title-page-name"/>  ...<br class="title-page-name"/><br class="title-page-name"/>  public load(<br class="title-page-name"/>    track: ITrack, <br class="title-page-name"/>    

<strong class="calibre1">complete: (number) =&gt; void, </strong><br class="title-page-name"/><strong class="calibre1">    error: (IPlayerError) =&gt; void</strong><br class="title-page-name"/>  ): 

Promise&lt;number&gt; {<br class="title-page-name"/>    return new Promise((resolve, reject) =&gt; {<br class="title-page-name"/>      ...<br class="title-page-name"/>      

<strong class="calibre1">this._completeHandler = complete;</strong><br class="title-page-name"/><strong class="calibre1">      this._errorHandler = error;</strong><br class="title-page-name"/><br class="title-page-name"/>      

this._player.initFromFile({<br class="title-page-name"/>        audioFile: track.filepath,<br class="title-page-name"/>        loop: false,<br class="title-page-name"/>        

<strong class="calibre1">completeCallback: this._trackComplete.bind(this),</strong><br class="title-page-name"/><strong class="calibre1">        errorCallback: 

this._trackError.bind(this)<br class="title-page-name"/>  </strong>...<strong class="calibre1"><br class="title-page-name"/><br class="title-page-name"/>  private _trackComplete(args: any) {<br class="title-page-name"/>    // TODO: 

works well for multi-tracks with same length<br class="title-page-name"/>    // may need to change in future with varied lengths<br class="title-page-name"/>    

this.player.seekTo(0);<br class="title-page-name"/>    console.log('trackComplete:', this.trackId);<br class="title-page-name"/>    if (this._completeHandler)<br class="title-page-name"/>      

this._completeHandler(this.trackId); <br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _trackError(args: any) {<br class="title-page-name"/>    let error = 

args.error;<br class="title-page-name"/>    console.log('trackError:', error);<br class="title-page-name"/>    if (this._errorHandler)<br class="title-page-name"/>      this._errorHandler({ 

trackId: this.trackId, error }); <br class="title-page-name"/> }</strong></pre>
<p class="mce-root">We start by defining the shape of each track error with <kbd class="calibre11">IPlayerError</kbd>. Then, we define references to the <kbd class="calibre11">_completeHandler</kbd> and <kbd class="calibre11">_errorHandler</kbd> functions captured via the <kbd class="calibre11">load</kbd> arguments, which now require complete and error callbacks. We assign those both before assigning the model's internal <kbd class="calibre11">this._trackComplete</kbd><strong class="calibre1"> </strong>and <kbd class="calibre11">this._trackError</kbd> (<em class="calibre21">using the <kbd class="calibre11">.bind(this)</kbd> syntax to ensure the function scope is locked to itself</em>)<strong class="calibre1"> </strong>to <kbd class="calibre11">completeCallback</kbd> and <kbd class="calibre11">errorCallback</kbd> of <kbd class="calibre11">TNSPlayer</kbd>.</p>
<p class="mce-root"><kbd class="calibre11">completeCallback</kbd> and<strong class="calibre1"> </strong><kbd class="calibre11">errorCallback</kbd> will fire outside the zone. This is why we inject <kbd class="calibre11">NgZone</kbd> and use <kbd class="calibre11">ngZone.run()</kbd> later in the chapter. We can avoid that by creating a callback with the <kbd class="calibre11">zonedCallback</kbd> function. It will make sure that the callback will be executed in the same zone as the code that creates the callback. For example:</p>
<pre class="calibre22">this._player.initFromFile({<br class="title-page-name"/>  audioFile: track.filepath,<br class="title-page-name"/>  loop: false,<br class="title-page-name"/>  completeCallback: 

<strong class="calibre1">zonedCallback(</strong>this._trackComplete.bind(this)<strong class="calibre1">)</strong>,<br class="title-page-name"/>  errorCallback: 

<strong class="calibre1">zonedCallback(</strong>this._trackError.bind(this)<strong class="calibre1">)<br class="title-page-name"/></strong>  ...</pre>
<p class="mce-root">This provides us the ability to internally handle each condition before dispatching out those conditions. </p>
<p class="mce-root">One such internal condition is resetting each audio player back to zero when it completes playing, so we simply call the <kbd class="calibre11">seekTo</kbd> method of <kbd class="calibre11">TNSPlayer</kbd><strong class="calibre1"> </strong>to reset it. We mark a <em class="calibre21">TODO,</em> because although this works well when all the tracks are the same length (<em class="calibre21">as is the case with our Demo tracks</em>), this will most certainly become potentially problematic in the future when we start recording our own varied multitracks with different lengths. Imagine we have two tracks in a composition: track 1 with a duration of 1 minute and track 2 a duration of 30 seconds. If we play the composition to 45 seconds and hit pause, track 2 would have called its completion handler already and reset back to 0. We then hit play to resume. Track 1 resumes from 45 seconds but track 2 is back at 0. <em class="calibre21">We will address that when we get there, so don't fret about it!</em> At this point, we are polishing our first phase implementation.</p>
<p class="mce-root">Lastly, we call out to the assigned <kbd class="calibre11">completeHandler</kbd> to let the caller know which trackId has completed. For <kbd class="calibre11">trackError</kbd>, we simply call out passing along <kbd class="calibre11">trackId</kbd> and <kbd class="calibre11">error</kbd>.</p>
<p class="mce-root">Now, let's go back to <kbd class="calibre11">PlayerService</kbd> and wire this in. Open <kbd class="calibre11">app/modules/player/services/player.service.ts</kbd> and make the following modifications:</p>
<pre class="calibre22">// app<br class="title-page-name"/>import { ITrack, CompositionModel, TrackPlayerModel, <strong class="calibre1">IPlayerError</strong> } from 

'../../shared/models';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/><br class="title-page-name"/>  // observable state<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">public complete$: Subject&lt;number&gt; = new Subject();<br class="title-page-name"/>  ...<br class="title-page-name"/>  </strong>public set 

composition(comp: CompositionModel) {<strong class="calibre1"><br class="title-page-name"/>    </strong>...<strong class="calibre1"><br class="title-page-name"/>    </strong>let initTrackPlayer = (index: 

number) =&gt; {<strong class="calibre1"><br class="title-page-name"/>      </strong>...<strong class="calibre1"><br class="title-page-name"/>      </strong>trackPlayer.load(<br class="title-page-name"/>        track,<br class="title-page-name"/>     

   <strong class="calibre1">this._trackComplete.bind(this),</strong><br class="title-page-name"/>        <strong class="calibre1">this._trackError.bind(this)<br class="title-page-name"/><br class="title-page-name"/>  ...<br class="title-page-name"/> 

 private _trackComplete(trackId: number) {<br class="title-page-name"/>    console.log('track complete:', trackId);<br class="title-page-name"/>    this.playing = 

false;<br class="title-page-name"/>    this.complete$.next(trackId);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _trackError(playerError: IPlayerError) {<br class="title-page-name"/>  

  console.log(`trackId ${playerError.trackId} error:`,<br class="title-page-name"/>      playerError.error);<br class="title-page-name"/>  }<br class="title-page-name"/> </strong> ...</pre>
<p class="mce-root">We've added another subject, <kbd class="calibre11">complete$</kbd>, to allow view components to subscribe to when the track playback completes. Additionally, we have added two callback handlers, <kbd class="calibre11">_trackComplete</kbd> and <kbd class="calibre11">_trackError</kbd>, which we pass along to our <kbd class="calibre11">load</kbd> method of <kbd class="calibre11"><span>TrackPlayerModel</span></kbd>.</p>
<p class="mce-root">However, if we were to try and update view bindings as a result of the <kbd class="calibre11">complete$</kbd> subscriptions firing in any view component, you would notice something puzzling. <strong class="calibre1">The view would not update!</strong></p>
<div class="packt_tip">Anytime you integrate with third-party libraries, take note of callback handlers coming from the library, which you may intend to update a view binding. Inject NgZone and wrap with <kbd class="calibre29">this.ngZone.run(() =&gt; ...</kbd> where needed. </div>
<p class="mce-root">Third-party libraries that provide callbacks may often need to run through Angular's NgZone. The great folks at Thoughtram published a great article on Zones if you'd like to learn more, at <a href="https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html" class="calibre3">https://blog.thoughtram.io/angular/2016/02/01/zones-in-angular-2.html</a>.</p>
<p class="mce-root">The third-party library <strong class="calibre1">nativescript-audio</strong> integrates with the iOS and Android native audio players and provides callbacks you can wire up to handle completion and error conditions. These callbacks are executed asynchronously within the context of the native audio players and, because they are not handled within the context of user events like a tap, or a result of a network request, or a timer like <kbd class="calibre11">setTimeout</kbd>, we need to ensure the result and the subsequent code execution take place within Angular's NgZone if we intend them to result in updating view bindings.</p>
<p class="mce-root">Since we intend for the <kbd class="calibre11">complete$</kbd> subject to result in view binding updates (<em class="calibre21">specifically, resetting our slider</em>), we will inject NgZone and wrap our callback handling. Back in <kbd class="calibre11">app/modules/player/services/player.service.ts</kbd>, let's make the following adjustment:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Injectable, <strong class="calibre1">NgZone</strong> } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Injectable()

<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/><br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">constructor(private ngZone: NgZone) {}</strong><br class="title-page-name"/>  

...<br class="title-page-name"/>  private _trackComplete(trackId: number) {<br class="title-page-name"/>    console.log('track complete:', trackId);<br class="title-page-name"/>    

<strong class="calibre1">this.ngZone.run(() =&gt; {</strong><br class="title-page-name"/>      this.playing = false;<br class="title-page-name"/>      this.complete$.next(trackId);<br class="title-page-name"/> 

   <strong class="calibre1">});</strong><br class="title-page-name"/>  }<br class="title-page-name"/>  ...</pre>
<p class="mce-root">Now, we will be clear when using this new <kbd class="calibre11">complete$</kbd> subject to react to our service's state in our view components. Let's adjust <kbd class="calibre11">PlayerControlsComponent</kbd> at <kbd class="calibre11">app/modules/player/components/player- controls/player-controls.component.ts</kbd> to observe the <kbd class="calibre11">complete$</kbd> subject to reset our <kbd class="calibre11">currentTime</kbd> binding:</p>
<pre class="calibre22">export class PlayerControlsComponent {<br class="title-page-name"/><br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">private _subComplete: Subscription;</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>  ngOnInit() {<br class="title-page-name"/>    ...<br class="title-page-name"/>    // completion should reset currentTime<br class="title-page-name"/>    <strong class="calibre1">this._subComplete 

= this.playerService.complete$.subscribe(_ =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">      this.currentTime = 0;</strong><br class="title-page-name"/><strong class="calibre1"> 

   });</strong><br class="title-page-name"/>  }<br class="title-page-name"/>  ngOnDestroy() {<br class="title-page-name"/>    ...<br class="title-page-name"/>    <strong class="calibre1">if (this._subComplete) 

</strong><strong class="calibre1">this._subComplete.unsubscribe(); </strong><br class="title-page-name"/>  }<br class="title-page-name"/>  ...</pre>
<div class="packt_infobox">iOS Audio Player reports <kbd class="calibre29">duration</kbd> and <kbd class="calibre29">currentTime</kbd> in seconds, whereas Android reports in milliseconds. We need to standardize that!</div>
<p class="mce-root">Let's add a method to <kbd class="calibre11">PlayerService</kbd> to standardize the time, so we can rely on both the platforms providing time in seconds:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">// nativescript</strong><br class="title-page-name"/><strong class="calibre1">import { isIOS } from 'platform';</strong><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>@Injectable()<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/><br class="title-page-name"/> constructor() {<br class="title-page-name"/>   // observe currentTime changes 

every 1 seconds<br class="title-page-name"/>   this.currentTime$ = Observable.interval(1000)<br class="title-page-name"/>     .map(_ =&gt; this._longestTrack ?<br class="title-page-name"/>     

  <strong class="calibre1">this._standardizeTime(</strong><br class="title-page-name"/><strong class="calibre1">         this._longestTrack.player.currentTime)</strong><br class="title-page-name"/>       

: 0;<br class="title-page-name"/>     );<br class="title-page-name"/> }<br class="title-page-name"/> ...<br class="title-page-name"/> private _updateTotalDuration() {<br class="title-page-name"/>   ...<br class="title-page-name"/>   <strong class="calibre1">// iOS: reports 

duration in seconds</strong><br class="title-page-name"/><strong class="calibre1">   // Android: reports duration in milliseconds</strong><br class="title-page-name"/><strong class="calibre1">   // 

standardize to seconds</strong><br class="title-page-name"/>   totalDuration = <strong class="calibre1">this._standardizeTime(totalDuration);</strong><br class="title-page-name"/>   

console.log('totalDuration of mix:', totalDuration);<br class="title-page-name"/>   this.duration$.next(totalDuration);<br class="title-page-name"/> }<br class="title-page-name"/> ...<br class="title-page-name"/> 

<strong class="calibre1">private _standardizeTime(time: number) {</strong><br class="title-page-name"/><strong class="calibre1">   return isIOS ? time : time * .001;</strong><br class="title-page-name"/><strong class="calibre1"> }</strong><br class="title-page-name"/> ...</pre>
<p class="mce-root">We are able to take advantage of the <kbd class="calibre11">isIOS</kbd> Boolean provided by the <kbd class="calibre11">platform</kbd> module from NativeScript to conditionally adjust our time for Android's milliseconds to seconds conversion.</p>
<div class="packt_tip">Using the <kbd class="calibre29">isIOS</kbd> and/or <kbd class="calibre29">isAndroid</kbd> Boolean from NativeScript's <kbd class="calibre29">platform</kbd> module is a very effective way to make platform adjustments across your codebase where needed.</div>
<p class="mce-root"><strong class="calibre1">So what about that subtle playback sync issue with multiple tracks on iOS ?</strong></p>
<div class="packt_infobox">On iOS, you may notice a very subtle playback sync issue on all the tracks if you choose play/pause many times during the 14 seconds of playback on the composition's demo tracks. We could surmise this could also happen on Android at some point.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using NativeScript's strengths by tapping directly into the native API of the underlying iOS AVAudioPlayer instance from the nativescript-audio plugin</h1>
                
            
            <article>
                
<p class="mce-root">Let's insert some safeguards into our play/pause logic to help ensure our tracks stay in sync to the best of our programming abilities. The <strong class="calibre1">nativescript-audio</strong> plugin offers an iOS-only method called <kbd class="calibre11">playAtTime</kbd>. It works in tandem with the special <kbd class="calibre11">deviceCurrentTime</kbd> property, as described in Apple's documentation for this very purpose at <a href="https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime?language=objc" class="calibre3">https://developer.apple.com/reference/avfoundation/avaudioplayer/1387462-devicecurrenttime? language=objc</a>.</p>
<p class="mce-root">Since <kbd class="calibre11">deviceCurrentTime</kbd> is not exposed by the nativescript-audio plugin, we can access the native property directly via the <kbd class="calibre11">ios</kbd> getter. Let's adjust the <kbd class="calibre11">play</kbd> method of <kbd class="calibre11">PlayerService</kbd><strong class="calibre1"> </strong>to use it:</p>
<pre class="calibre22">public play() {<br class="title-page-name"/>  // for iOS playback sync<br class="title-page-name"/><strong class="calibre1">  let shortStartDelay = .01;</strong><br class="title-page-name"/><strong class="calibre1">  let 

now = 0;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  for (let i = 0; i &lt; this._trackPlayers.length; i++) {</strong><br class="title-page-name"/><strong class="calibre1">    

let track = this._trackPlayers[i];</strong><br class="title-page-name"/><strong class="calibre1">    if (isIOS) {</strong><br class="title-page-name"/><strong class="calibre1">      if (i == 0) now = 

track.player.ios</strong><strong class="calibre1">.deviceCurrentTime;</strong><br class="title-page-name"/><strong class="calibre1">      (&lt;any&gt;track.player).playAtTime

(</strong><strong class="calibre1">now + shortStartDelay);</strong><br class="title-page-name"/><strong class="calibre1">    } else {</strong><br class="title-page-name"/><strong class="calibre1">      track.player.play

();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">  } </strong> <br class="title-page-name"/>}</pre>
<p class="mce-root">Since <kbd class="calibre11">track.player</kbd> is our instance of <kbd class="calibre11">TNSPlayer</kbd>, we can access the underlying native platform player instance (for iOS, it's <kbd class="calibre11">AVAudioPlayer</kbd>) via its <strong class="calibre1">ios</strong> getter to access <kbd class="calibre11">deviceCurrentTime</kbd> directly. We provide a very short start delay for good measure, add that into the first track's <kbd class="calibre11">deviceCurrentTime</kbd>, and use that to start all of our tracks at precisely the same time, which works wonderfully! Because <kbd class="calibre11">playAtTime</kbd> is not published via the TypeScript definitions with the nativescript-audio plugin, we simply type-cast the player instance (<kbd class="calibre11">&lt;any&gt;track.player</kbd>) before calling the method to suffice the tsc compiler. Since there is no equivalent on Android, we will just use the standard media player's play method, which works well for Android.</p>
<p class="mce-root">Let's now adjust our pause method with a similar safeguard:</p>
<pre class="calibre22">public pause() {<br class="title-page-name"/>  <strong class="calibre1">let currentTime = 0;</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">  for (let i = 0; i &lt; 

this._trackPlayers.length; i++) {</strong><br class="title-page-name"/><strong class="calibre1">    let track = this._trackPlayers[i];</strong><br class="title-page-name"/><strong class="calibre1">    if 

(i == 0) currentTime = track.player.currentTime;</strong><br class="title-page-name"/>    track.player.pause();<br class="title-page-name"/>    // ensure tracks pause 

and remain paused at the same time<br class="title-page-name"/>    <strong class="calibre1">track.player.seekTo(currentTime);</strong><br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">By using the first track's <kbd class="calibre11">currentTime</kbd> as the <strong class="calibre1">pace setter</strong>, we pause each track in our mix and ensure they remain at exactly the same time by seeking to the same <kbd class="calibre11">currentTime</kbd> immediately after pausing. This helps ensure that, when we resume play, they all start from the same point in time. Let's put all this to use in the next section when we build a custom shuttle slider.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a custom ShuttleSliderComponent</h1>
                
            
            <article>
                
<p class="mce-root">We can't have a multitrack studio experience without the ability to shuttle back and forth through our mix! Let's double down on <kbd class="calibre11">Slider</kbd> and enhance its capabilities by combining the best of all the options NativeScript and Angular provide us. In the process, our player controls will start to become much more useful.</p>
<p class="mce-root">Starting at the high level, open <kbd class="calibre11">app/modules/player/components/player-controls/player-controls.component.html</kbd> and replace it with the following:</p>
<pre class="calibre22">&lt;<strong class="calibre1">StackLayout</strong> row="1" col="0" class="controls"&gt;<br class="title-page-name"/>  <strong class="calibre1">&lt;shuttle-slider [currentTime]

="currentTime" </strong><br class="title-page-name"/><strong class="calibre1">    [duration]="duration"&gt;&lt;/shuttle-slider&gt;</strong><br class="title-page-name"/>  &lt;Button 

[text]="playStatus" (tap)="togglePlay()"<br class="title-page-name"/>    class="btn btn-primary w-100"&gt;&lt;/Button&gt;<br class="title-page-name"/>&lt;/<strong class="calibre1">StackLayout</strong>&gt;</pre>
<p class="mce-root">We are replacing <kbd class="calibre11">GridLayout</kbd> with <kbd class="calibre11">StackLayout</kbd> to change up our player control's layout a bit. Let's go with a full-width slider stacked on top of our play/pause button. What we're after is similar to the Apple Music app on an iPhone, where the slider is full width with the current time and duration displayed underneath. Now, let's build our custom <kbd class="calibre11">shuttle-slider</kbd> component and create <kbd class="calibre11">app/modules/player/components/player-controls/shuttle- slider.component.html</kbd> with the following:</p>
<pre class="calibre22">&lt;GridLayout #sliderArea rows="auto, auto" columns="auto,*,auto" <br class="title-page-name"/>  class="slider-area"&gt;<br class="title-page-name"/>  &lt;Slider 

#slider slim-slider minValue="0" [maxValue]="duration"<br class="title-page-name"/>      colSpan="3" class="slider"&gt;&lt;/Slider&gt;<br class="title-page-name"/>  

&lt;Label #currentTimeDisplay text="00:00" class="h4 m-x-5" row="1" col="0"&gt;<br class="title-page-name"/>  &lt;/Label&gt;<br class="title-page-name"/>  &lt;Label 

[text]="durationDisplay" class="h4 text-right m-x-5"<br class="title-page-name"/>    row="1" col="2"&gt;&lt;/Label&gt;<br class="title-page-name"/>&lt;/GridLayout&gt;</pre>
<p class="mce-root">Here's where things are going to get very interesting. We are going to combine Angular bindings where useful, like these bindings: <kbd class="calibre11">[maxValue]="duration"</kbd> and <kbd class="calibre11">[text]="durationDisplay"</kbd> . However for the rest of our usability wiring we will want more fine grained and manual control. For instance, our containing <kbd class="calibre11">GridLayout</kbd> via <kbd class="calibre11">#sliderArea</kbd> is going to be the area the user is going to be able to touch to shuttle back/forth instead of the <kbd class="calibre11">Slider</kbd> component itself, and we are going to completely disable user interaction with the Slider itself (hence, the <kbd class="calibre11">slim-slider</kbd> directive attribute, you see). The slider is going to instead be used just for its visual representation of time.</p>
<p class="mce-root">The reason we will be doing this is because we want this interaction to kick off several programmatic actions:</p>
<ul class="calibre13">
<li class="calibre14">Pause playback (if playing) while shuttling</li>
<li class="calibre14">Update the current time display label as we move back/forth</li>
<li class="calibre14">Kick off the <kbd class="calibre11">seekTo</kbd> commands to our track player's instances in a controlled manner; hence, reducing extraneous seek commands</li>
<li class="calibre14">Resume playback when no longer shuttling if it was playing before attempting to shuttle</li>
</ul>
<p class="mce-root">If we used <kbd class="calibre11">Slider</kbd> with an Angular binding to <kbd class="calibre11">currentTime</kbd> via the <kbd class="calibre11">currentTime$</kbd> observable, which in turn was being controlled by our interaction with it in addition to the state of our track's players, things would be coupled too tightly to achieve the fine grain control we need.</p>
<p class="mce-root">The beauty of what we are about to do here serves as an exemplary testament to how flexible the combination of Angular with NativeScript really is. Let's start programming our interactions in <kbd class="calibre11">app/modules/player/components/player-controls/shuttle-slider.component.ts</kbd>; here's the complete setup for you to view in full, which we will break down in a moment:</p>
<pre class="calibre22">// angular<br class="title-page-name"/>import { Component, Input, ViewChild, ElementRef } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>// 

nativescript<br class="title-page-name"/>import { GestureTypes } from 'ui/gestures';<br class="title-page-name"/>import { View } from 'ui/core/view';<br class="title-page-name"/>import { Label 

} from 'ui/label';<br class="title-page-name"/>import { Slider } from 'ui/slider';<br class="title-page-name"/>import { Observable } from 'data/observable';<br class="title-page-name"/>import 

{ isIOS, screen } from 'platform';<br class="title-page-name"/><br class="title-page-name"/>// app<br class="title-page-name"/>import { PlayerService } from '../../services';<br class="title-page-name"/><br class="title-page-name"/>@Component({<br class="title-page-name"/>  moduleId: module.id,<br class="title-page-name"/>  selector: 'shuttle-slider',<br class="title-page-name"/>  templateUrl: 'shuttle-

slider.component.html',<br class="title-page-name"/>  styles: [`<br class="title-page-name"/>    .slider-area {<br class="title-page-name"/>      margin: 10 10 0 10;<br class="title-page-name"/>    }<br class="title-page-name"/>    

.slider {<br class="title-page-name"/>      padding:0;<br class="title-page-name"/>      margin:0 0 5 0;<br class="title-page-name"/>      height:5;<br class="title-page-name"/>    }<br class="title-page-name"/>  `]<br class="title-page-name"/>})<br class="title-page-name"/>export 

class ShuttleSliderComponent {<br class="title-page-name"/><br class="title-page-name"/>  @Input() currentTime: number; <br class="title-page-name"/>  @Input() duration: number; <br class="title-page-name"/> 

 @ViewChild('sliderArea') sliderArea: ElementRef;<br class="title-page-name"/>  @ViewChild('slider') slider: ElementRef;<br class="title-page-name"/>  

@ViewChild('currentTimeDisplay') currentTimeDisplay: ElementRef;<br class="title-page-name"/><br class="title-page-name"/>  public durationDisplay: string;<br class="title-page-name"/><br class="title-page-name"/>  private _sliderArea: View;<br class="title-page-name"/>  private _currentTimeDisplay: Label;<br class="title-page-name"/>  private _slider: Slider;<br class="title-page-name"/>  private 

_screenWidth: number;<br class="title-page-name"/>  private _seekDelay: number;<br class="title-page-name"/><br class="title-page-name"/>  constructor(private playerService: PlayerService) { 

}<br class="title-page-name"/><br class="title-page-name"/>  ngOnChanges() {<br class="title-page-name"/>    if (typeof this.currentTime == 'number')   {<br class="title-page-name"/>      this._updateSlider

(this.currentTime);<br class="title-page-name"/>    }<br class="title-page-name"/>    if (this.duration) {<br class="title-page-name"/>      this.durationDisplay = <br class="title-page-name"/>        

this._timeDisplay(this.duration);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  ngAfterViewInit() {<br class="title-page-name"/>    this._screenWidth = 

screen.mainScreen.widthDIPs;<br class="title-page-name"/>    this._sliderArea = &lt;View&gt;this.sliderArea<br class="title-page-name"/>                         

.nativeElement;<br class="title-page-name"/>    this._slider = &lt;Slider&gt;this.slider.nativeElement;<br class="title-page-name"/>    this._currentTimeDisplay = 

&lt;Label&gt;this.currentTimeDisplay<br class="title-page-name"/>                                 .nativeElement;<br class="title-page-name"/>    

this._setupEventHandlers();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _updateSlider(time: number) {<br class="title-page-name"/>    if (this._slider) 

this._slider.value = time;<br class="title-page-name"/>    if (this._currentTimeDisplay)<br class="title-page-name"/>      this._currentTimeDisplay<br class="title-page-name"/>        .text = 

this._timeDisplay(time);<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private _setupEventHandlers() {<br class="title-page-name"/>    this._sliderArea.on

(GestureTypes.touch, (args: any) =&gt; {<br class="title-page-name"/>      this.playerService.seeking = true;<br class="title-page-name"/>      let x = args.getX();<br class="title-page-name"/><br class="title-page-name"/>      if (x &gt;= 0) {<br class="title-page-name"/>        let percent = x / this._screenWidth;<br class="title-page-name"/>        if (percent &gt; .5) {<br class="title-page-name"/>  

        percent += .05;<br class="title-page-name"/>        }<br class="title-page-name"/>        let seekTo = this.duration * percent;<br class="title-page-name"/>        this._updateSlider

(seekTo);<br class="title-page-name"/><br class="title-page-name"/>        if (this._seekDelay) clearTimeout(this._seekDelay);<br class="title-page-name"/>        this._seekDelay = setTimeout

(() =&gt; {<br class="title-page-name"/>          // android requires milliseconds<br class="title-page-name"/>          this.playerService<br class="title-page-name"/>            .seekTo

(isIOS ? seekTo : (seekTo*1000));<br class="title-page-name"/>        }, 600);<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private 

_timeDisplay(seconds: number): string {<br class="title-page-name"/>    let hr: any = Math.floor(seconds / 3600);<br class="title-page-name"/>    let min: any = 

Math.floor((seconds - (hr * 3600))/60);<br class="title-page-name"/>    let sec: any = Math.floor(seconds - (hr * 3600) <br class="title-page-name"/>                     

- (min * 60));<br class="title-page-name"/>    if (min &lt; 10) { <br class="title-page-name"/>      min = '0' + min; <br class="title-page-name"/>    }<br class="title-page-name"/>    if (sec &lt; 10){ <br class="title-page-name"/>      

sec = '0' + sec;<br class="title-page-name"/>    }<br class="title-page-name"/>    return min + ':' + sec;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">For a rather small component footprint, there's a ton of great stuff going on here! Let's break it down. </p>
<p class="mce-root">Let's look at those property decorators, starting with <kbd class="calibre11">@Input</kbd>:</p>
<pre class="calibre22">@Input() <strong class="calibre1">currentTime</strong>: number; <br class="title-page-name"/>@Input() <strong class="calibre1">duration</strong>: number; <br class="title-page-name"/><br class="title-page-name"/>// allows these property bindings to flow into our view:<br class="title-page-name"/>&lt;shuttle-slider <br class="title-page-name"/><strong class="calibre1">  [currentTime]

="currentTime"</strong> <br class="title-page-name"/>  <strong class="calibre1">[duration]="duration"</strong>&gt;<br class="title-page-name"/>&lt;/shuttle-slider&gt;</pre>
<p class="mce-root">Then, we have our <kbd class="calibre11">@ViewChild</kbd> references:</p>
<pre class="calibre22">@ViewChild('<strong class="calibre1">sliderArea</strong>') sliderArea: ElementRef;<br class="title-page-name"/>@ViewChild('<strong class="calibre1">slider</strong>') 

slider: ElementRef;<br class="title-page-name"/>@ViewChild('<strong class="calibre1">currentTimeDisplay</strong>') currentTimeDisplay: ElementRef;<br class="title-page-name"/><br class="title-page-name"/>private _sliderArea: StackLayout;<br class="title-page-name"/>private _currentTimeDisplay: Label;<br class="title-page-name"/>private _slider: Slider;<strong class="calibre1"><br class="title-page-name"/><br class="title-page-name"/></strong>// provides us with references to these view components<strong class="calibre1"><br class="title-page-name"/></strong>&lt;StackLayout 

<strong class="calibre1">#sliderArea</strong> class="slider-area"&gt;<br class="title-page-name"/>  &lt;Slider <strong class="calibre1">#slider</strong> slim-slider<br class="title-page-name"/>    

minValue="0 [maxValue]="duration" class="slider"&gt;<br class="title-page-name"/>  &lt;/Slider&gt;<br class="title-page-name"/>  &lt;GridLayout rows="auto" 

columns="auto,*,auto"<br class="title-page-name"/>    class="m-x-5"&gt;<br class="title-page-name"/>    &lt;Label <strong class="calibre1">#currentTimeDisplay</strong> text="00:00" 

class="h4"<br class="title-page-name"/>      row="0" col="0"&gt;&lt;/Label&gt;<br class="title-page-name"/>    &lt;Label [text]="durationDisplay" class="h4 text-right" 

<br class="title-page-name"/>      row="0" col="2"&gt;&lt;/Label&gt;<br class="title-page-name"/>  &lt;/GridLayout&gt;<br class="title-page-name"/>&lt;/StackLayout&gt;<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="mce-root">We can then access those <kbd class="calibre11">ElementRef</kbd> instances in our component to programmatically work with them; however, not right away. Since <kbd class="calibre11">ElementRef</kbd> is a proxy wrapper to the view component, its underlying <kbd class="calibre11">nativeElement</kbd> (our actual NativeScript component) is only accessible once Angular's component lifecycle hook <kbd class="calibre11">ngAfterViewInit</kbd> fires.</p>
<div class="packt_tip">Learn all about Angular's component lifecycle hooks here:<br class="calibre24"/>
<a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html" class="calibre35">https://angular.io/docs/ts/latest/guide/lifecycle- hooks.html.</a></div>
<p class="mce-root">Therefore, we assign private references to our actual NativeScript components here:</p>
<pre class="calibre22">ngAfterViewInit() {<br class="title-page-name"/>  <em class="calibre21">this._screenWidth = screen.mainScreen.widthDIPs;</em><br class="title-page-name"/>  <strong class="calibre1">this._sliderArea = 

&lt;StackLayout&gt;this.sliderArea</strong><br class="title-page-name"/><strong class="calibre1">                                      .nativeElement;</strong><br class="title-page-name"/><strong class="calibre1">  this._slider = &lt;Slider&gt;this.slider.nativeElement;</strong><br class="title-page-name"/><strong class="calibre1">  this._currentTimeDisplay = 

&lt;Label&gt;this.currentTimeDisplay</strong><br class="title-page-name"/><strong class="calibre1">                                        

.nativeElement;</strong><br class="title-page-name"/>  <em class="calibre21">this._setupEventHandlers();</em><br class="title-page-name"/>}</pre>
<p class="mce-root">We also take this opportunity to reference the overall screen width using the <strong class="calibre1">density-independent pixel</strong> (<strong class="calibre1">dip</strong>) units via the <kbd class="calibre11">screen</kbd> utility from the <kbd class="calibre11">platform</kbd> module. This will allow us to do some calculations using our user's finger position on our <kbd class="calibre11">sliderArea</kbd> StackLayout to adjust the actual value of <kbd class="calibre11"><span>Slider</span></kbd>. We then make a call to set up our essential event handlers.</p>
<p class="mce-root">Using our <kbd class="calibre11">_sliderArea</kbd> reference to the containing StackLayout, we add a <kbd class="calibre11">touch</kbd> gesture listener to capture any touches the user makes to our slider area:</p>
<pre class="calibre22">private _setupEventHandlers() {<br class="title-page-name"/>  this._sliderArea.on(GestureTypes.touch, (args: any) =&gt; {<br class="title-page-name"/>    

<em class="calibre21">this.playerService.seeking = true; // TODO</em><br class="title-page-name"/> <br class="title-page-name"/>    let x = args.getX();<br class="title-page-name"/>    if (x &gt;= 0) {<br class="title-page-name"/>    

  // x percentage of screen left to right<br class="title-page-name"/>      let percent = x / this._screenWidth;<br class="title-page-name"/>      if (percent &gt; .5) 

{<br class="title-page-name"/>        percent += .05; // non-precise adjustment<br class="title-page-name"/>      }<br class="title-page-name"/>      let seekTo = this.duration * percent;<br class="title-page-name"/>      this._updateSlider(seekTo);<br class="title-page-name"/><br class="title-page-name"/>      if (this._seekDelay) clearTimeout(this._seekDelay);<br class="title-page-name"/>      

this._seekDelay = setTimeout(() =&gt; {<br class="title-page-name"/>        // android requires milliseconds<br class="title-page-name"/>        

this.playerService.seekTo(<br class="title-page-name"/>          isIOS ? seekTo : (seekTo*1000));<br class="title-page-name"/>      }, 600);<br class="title-page-name"/>    }<br class="title-page-name"/>  });<br class="title-page-name"/>}</pre>
<p class="mce-root">This allows us to grab the <kbd class="calibre11">X</kbd> position of their finger via <kbd class="calibre11">args.getX()</kbd>. We use that to divide into the user's device screen width to determine a percentage from the left to the right. Since our calculation is not exactly precise, we make a small adjustment when the user passes the 50% mark. This usability works well for our use case right now, but we will reserve the option to improve that later; however, it's perfectly fine for now.</p>
<p class="mce-root">We then multiply the duration by this percentage to get our <kbd class="calibre11">seekTo</kbd> mark to update our value of  <kbd class="calibre11"><span>Slider</span></kbd> in order to get immediate UI updates using manual precision:</p>
<pre class="calibre22">private _updateSlider(time: number) {<br class="title-page-name"/>  if (this._slider) this._slider.value = time;<br class="title-page-name"/>  if 

(this._currentTimeDisplay)<br class="title-page-name"/>    this._currentTimeDisplay.text = this._timeDisplay(time);<br class="title-page-name"/>}</pre>
<p class="mce-root">Here, we are actually using our NativeScript components directly without Angular's bindings or NgZone in the mix. This can be very handy in cases where you need fine grained and performance control of your UI. Since we want the <kbd class="calibre11">Slider</kbd> track to move immediately with the user's finger, as well as the time display label formatted with standard musical timecode to represent real time as they interact, we set their values directly at the appropriate time.</p>
<p class="mce-root">We then use a seek delay timeout to ensure we don't make extraneous seek commands to our multitrack player. Each movement by the user will further delay making an actual seek command until they rest where they want it. We also use our <kbd class="calibre11">isIOS</kbd> Boolean to convert the time as appropriately needed by each platform audio player (seconds for iOS and milliseconds for Android).</p>
<p class="mce-root">Most interesting might be our <kbd class="calibre11">ngOnChanges</kbd> lifecycle hook:</p>
<pre class="calibre22">ngOnChanges() {<br class="title-page-name"/>  if (typeof this.currentTime == 'number') {<br class="title-page-name"/>    this._updateSlider(this.currentTime);<br class="title-page-name"/> 

 }<br class="title-page-name"/>  if (this.duration) {<br class="title-page-name"/>    this.durationDisplay = this._timeDisplay(this.duration);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<div class="packt_quote"><span>Angular calls its <kbd class="calibre11">ngOnChanges()</kbd> </span><span>method whenever it detects changes to the</span> <strong class="calibre1"><em class="calibre21">input properties</em></strong> <span>of the component (or directive).</span></div>
<p class="mce-root">This is a wonderful way for <kbd class="calibre11">ShuttleSliderComponent</kbd> to react to its <kbd class="calibre11">Input</kbd> property changes, <kbd class="calibre11">currentTime</kbd>, and <kbd class="calibre11">duration</kbd>. Here, we simply update our slider and the current time display label manually via <kbd class="calibre11">this._updateSlider(this.currentTime)</kbd> only when it does fire with a valid number. Lastly, we also ensure we update our duration display label. This method will fire every second the PlayerService's <kbd class="calibre11">currentTime$</kbd> observable fires while an active subscription exists. <strong class="calibre1">Nice!</strong> Oh, and don't forget to add <kbd class="calibre11">ShuttleSliderComponent</kbd> to the <kbd class="calibre11">COMPONENTS</kbd> array to be included with the module.</p>
<p class="mce-root">We now need to actually implement this:</p>
<pre class="calibre22"><em class="calibre21">this.playerService.seeking = true; // TODO</em></pre>
<p class="mce-root">We are going to use a couple more nifty observable tricks with our seeking state. Let's open our PlayerService in <kbd class="calibre11">app/modules/player/services/player.service.ts</kbd> and add the following:</p>
<pre class="calibre22">...<br class="title-page-name"/>export class PlayerService {<br class="title-page-name"/><br class="title-page-name"/>  ...<br class="title-page-name"/>  // internal state <br class="title-page-name"/>  private _playing: boolean;<br class="title-page-name"/>  <strong class="calibre1">private _seeking: boolean;</strong><br class="title-page-name"/><strong class="calibre1">  private _seekPaused: boolean;</strong><br class="title-page-name"/><strong class="calibre1">  

private _seekTimeout: number;</strong><br class="title-page-name"/>  ...<br class="title-page-name"/>  constructor(private ngZone: NgZone) {<br class="title-page-name"/>    this.currentTime$ = 

Observable.interval(1000)<br class="title-page-name"/>      .<strong class="calibre1">switchMap</strong>(_ =&gt; {<br class="title-page-name"/>        <strong class="calibre1">if (this._seeking) 

{</strong><br class="title-page-name"/><strong class="calibre1">          return Observable.never();</strong><br class="title-page-name"/><strong class="calibre1">        }</strong> else if 

(this._longestTrack) {<br class="title-page-name"/>          return Observable.of(<br class="title-page-name"/>            this._standardizeTime(<br class="title-page-name"/>              

this._longestTrack.player.currentTime));<br class="title-page-name"/>        } else {<br class="title-page-name"/>          return Observable.of(0);<br class="title-page-name"/>        }<br class="title-page-name"/> 

   });<br class="title-page-name"/>  }<br class="title-page-name"/>  ...<br class="title-page-name"/>  <strong class="calibre1">public set seeking(value: boolean) {</strong><br class="title-page-name"/><strong class="calibre1">    this._seeking = 

value;</strong><br class="title-page-name"/><strong class="calibre1">    if (this._playing &amp;&amp; !this._seekPaused) {</strong><br class="title-page-name"/><strong class="calibre1">      // pause 

while seeking</strong><br class="title-page-name"/><strong class="calibre1">      this._seekPaused = true;</strong><br class="title-page-name"/><strong class="calibre1">      this.pause();</strong><br class="title-page-name"/><strong class="calibre1">    }</strong><br class="title-page-name"/><strong class="calibre1">    if (this._seekTimeout) clearTimeout(this._seekTimeout);</strong><br class="title-page-name"/><strong class="calibre1">    

this._seekTimeout = setTimeout(() =&gt; {</strong><br class="title-page-name"/><strong class="calibre1">      this._seeking = false;</strong><br class="title-page-name"/><strong class="calibre1">      if 

(this._seekPaused) {</strong><br class="title-page-name"/><strong class="calibre1">        // resume play</strong><br class="title-page-name"/><strong class="calibre1">        this._seekPaused = 

false;</strong><br class="title-page-name"/><strong class="calibre1">        this.play();</strong><br class="title-page-name"/><strong class="calibre1">      }</strong><br class="title-page-name"/><strong class="calibre1">    }, 

1000);</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/><br class="title-page-name"/>  <strong class="calibre1">public seekTo(time: number) {</strong><br class="title-page-name"/><strong class="calibre1">    for 

(let track of this._trackPlayers) {</strong><br class="title-page-name"/><strong class="calibre1">      track.player.seekTo(time);</strong><br class="title-page-name"/><strong class="calibre1">    }

</strong><br class="title-page-name"/><strong class="calibre1">  }</strong><br class="title-page-name"/>  ...</pre>
<p class="mce-root">We are introducing three new observable operators <kbd class="calibre11">switchMap</kbd>, <kbd class="calibre11">never</kbd>, and <kbd class="calibre11">of</kbd>, which we need to ensure are also imported in our <kbd class="calibre11">app/operators.ts</kbd> file:</p>
<pre class="calibre22">import 'rxjs/add/operator/map';<br class="title-page-name"/><strong class="calibre1">import 'rxjs/add/operator/switchMap';</strong><br class="title-page-name"/>import 

'rxjs/add/observable/interval';<br class="title-page-name"/><strong class="calibre1">import 'rxjs/add/observable/never';</strong><br class="title-page-name"/><strong class="calibre1">import 

'rxjs/add/observable/of';</strong></pre>
<p class="mce-root"><kbd class="calibre11">switchMap</kbd> allows our observable to switch streams based on several conditions, helping us to manage whether <kbd class="calibre11">currentTime</kbd> needs to emit updates or not. Clearly, when seeking, we don't need to react to the <kbd class="calibre11">currentTime</kbd> changes. Therefore, we switch our Observable stream to <kbd class="calibre11">Observable.never()</kbd> while <kbd class="calibre11">this._seeking</kbd> is true, ensuring our observer is never called.</p>
<p class="mce-root">In our <kbd class="calibre11">seeking</kbd> setter, we adjust the internal state reference (<kbd class="calibre11">this._seeking</kbd>) ,and if it was currently <kbd class="calibre11">this._playing</kbd> and had not yet been paused due to seeking (hence, <kbd class="calibre11">!this._seekPaused</kbd>), we immediately pause playback (only once). We then set up another timeout to delay resuming playback an additional 400 milliseconds after <kbd class="calibre11">seekTo</kbd> has been fired from the component if it was playing when seek started (hence, the check on <kbd class="calibre11">this._seekPaused</kbd>).</p>
<p class="mce-root">This way, the user is free to move their finger across our shuttle slider as much as they'd like and as quickly as they'd like. They will see immediate UI updates to the <kbd class="calibre11">Slider</kbd> track as well as the current time display label in real time; all the while we are avoiding extraneous <kbd class="calibre11">seekTo</kbd> commands being sent to our multitrack player until they come to rest, providing a really nice user experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating SlimSliderDirective for iOS and Android native API modifications</h1>
                
            
            <article>
                
<p class="mce-root">We still have a directive to create for that <kbd class="calibre11">slim-slider</kbd> attribute we had on <kbd class="calibre11">Slider</kbd>:</p>
<pre class="calibre22">&lt;Slider #slider<strong class="calibre1"> slim-slider</strong> minValue="0" [maxValue]="duration" 

class="slider"&gt;&lt;/Slider&gt;</pre>
<p class="mce-root">We are going to create platform-specific directives, since we will tap into the slider's actual native API on iOS and Android to disable user interaction and hide the thumb for a seamless appearance.</p>
<p class="mce-root">For iOS, create <kbd class="calibre11">app/modules/player/directives/slider.directive.ios.ts</kbd> with the following:</p>
<pre class="calibre22">import { Directive, ElementRef } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Directive({<br class="title-page-name"/> selector: '[slim-

slider]'<br class="title-page-name"/>})<br class="title-page-name"/>export class SlimSliderDirective {<br class="title-page-name"/><br class="title-page-name"/>  constructor(private el: ElementRef) { } <br class="title-page-name"/><br class="title-page-name"/>  

ngOnInit() {<br class="title-page-name"/>    let uiSlider = &lt;UISlider&gt;this.el.nativeElement.ios;<br class="title-page-name"/>    uiSlider.userInteractionEnabled = 

false;<br class="title-page-name"/>    uiSlider.setThumbImageForState(<br class="title-page-name"/>      UIImage.new(), UIControlState.Normal);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="mce-root">We gain access to the underlying native iOS <kbd class="calibre11">UISlider</kbd> instance via NativeScript's <kbd class="calibre11">ios</kbd> getter off the <kbd class="calibre11">Slider</kbd> component itself. We use Apple's API reference documentation (<a href="https://developer.apple.com/reference/uikit/uislider" class="calibre3">https://developer.apple.com/reference/uikit/uislider</a>) to locate an appropriate API to disable interaction via the <kbd class="calibre11">userInteractionEnabled</kbd> flag and hide the thumb by setting a blank as the thumb. Perfect.</p>
<p class="mce-root">For Android, create <kbd class="calibre11">app/modules/player/directives/slider.directive.android.ts</kbd> with the following:</p>
<pre class="calibre22">import { Directive, ElementRef } from '@angular/core';<br class="title-page-name"/><br class="title-page-name"/>@Directive({<br class="title-page-name"/>  selector: '[slim-

slider]'<br class="title-page-name"/>})<br class="title-page-name"/>export class SlimSliderDirective {<br class="title-page-name"/><br class="title-page-name"/>  constructor(private el: ElementRef) { } <br class="title-page-name"/><br class="title-page-name"/>  

ngOnInit() {<br class="title-page-name"/>    let seekBar = &lt;android.widget.SeekBar&gt;this.el<br class="title-page-name"/>                  .nativeElement.android;<br class="title-page-name"/>    seekBar.setOnTouchListener(<br class="title-page-name"/>      new android.view.View.OnTouchListener({<br class="title-page-name"/>        onTouch(view, event) {<br class="title-page-name"/>          return true;<br class="title-page-name"/>        }<br class="title-page-name"/>      })<br class="title-page-name"/>    );<br class="title-page-name"/>    seekBar.getThumb().mutate().setAlpha(0);<br class="title-page-name"/>  

}<br class="title-page-name"/>}</pre>
<p class="mce-root">We gain access to the native <kbd class="calibre11">android.widget.SeekBar</kbd> instance via the <kbd class="calibre11">android</kbd> getter on the <kbd class="calibre11">Slider</kbd> component. We use Android's API reference documentation (<a href="https://developer.android.com/reference/android/widget/SeekBar.html" class="calibre3">https://developer.android.com/reference/android/ widget/SeekBar.html</a>) to locate the SeekBar's API and disable user interaction by overriding <kbd class="calibre11">OnTouchListener</kbd>, and we hide the thumb by setting its Drawable alpha to 0.</p>
<p class="mce-root">Now, create <kbd class="calibre11">app/modules/player/directives/slider.directive.d.ts</kbd>:</p>
<pre class="calibre22">export declare class SlimSliderDirective { }</pre>
<p class="mce-root">This will allow us to import and use our <kbd class="calibre11">SlimSlider</kbd> class as a standard ES6 module; Create <kbd class="calibre11">app/modules/player/directives/index.ts</kbd>:</p>
<pre class="calibre22">import { SlimSliderDirective } from './slider.directive';<br class="title-page-name"/><br class="title-page-name"/>export const DIRECTIVES: any[] = [<br class="title-page-name"/>  

SlimSliderDirective<br class="title-page-name"/>];</pre>
<p class="mce-root">At runtime, NativeScript will only build the appropriate platform-specific files into the target platform, completely excluding nonapplicable code. This is a very powerful way to create platform-specific functionality in your codebase.</p>
<p class="mce-root">To finish up, let's just ensure our directives are declared in <kbd class="calibre11">PlayerModule</kbd> at <kbd class="calibre11">app/modules/player/player.module.ts</kbd> with the following changes:</p>
<pre class="calibre22">...<br class="title-page-name"/><strong class="calibre1">import { DIRECTIVES } from './directives';</strong><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>@NgModule({<br class="title-page-name"/>  ...<br class="title-page-name"/>  declarations: [<br class="title-page-name"/>    ...COMPONENTS,<br class="title-page-name"/>    <strong class="calibre1">...DIRECTIVES</strong><br class="title-page-name"/>  ],<br class="title-page-name"/>  ...<br class="title-page-name"/>})<br class="title-page-name"/>export class PlayerModule { }</pre>
<p class="mce-root">We should now see this on iOS with our playback paused at 6 seconds:</p>
<div class="mce-root1"><img class="image-border25" src="../images/00034.jpeg"/></div>
<p class="mce-root">For Android, it will be as follows:</p>
<div class="mce-root1"><img class="image-border26" src="../images/00035.jpeg"/></div>
<p class="mce-root">You can now observe the following:</p>
<ul class="calibre13">
<li class="calibre14">All the three tracks play together in a perfect mix</li>
<li class="calibre14">Playback can be shuttled via the slider whether it's playing or not</li>
<li class="calibre14">The play/pause toggle</li>
<li class="calibre14">When playback reaches the end, our controls properly reset</li>
</ul>
<p class="mce-root">And it all works on iOS and Android. An amazing feat, without question.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="mce-root">We are now fully immersed in the rich world of NativeScript, having introduced plugin integration as well as direct access to native APIs on iOS and Android. To top it off, we have a really neat multitrack player with full playback control, including shuttling through the mix!</p>
<p class="mce-root">The exciting combination of Angular, including its RxJS observable underpinnings, is really starting to shine through, where we've been able to take advantage of view bindings where needed and react to service event streams with powerful observable compositions, all while still retaining the ability to manually control our UI with fine grain control. Whether our view needs an Angular directive to enrich its capabilities or manual touch gesture control via raw NativeScript capabilities, we have it all at our fingertips now. </p>
<p class="mce-root">The fact that all along we are building a fully native iOS and Android app is truly mind blowing.</p>
<p class="mce-root">In the next chapter, we will continue to dig further into native APIs and plugins as we bring recording into our app's abilities to deliver on the core requirements of our multi-track recording studio mobile app. </p>


            </article>

            
        </section>
    </body></html>