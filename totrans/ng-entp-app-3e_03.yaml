- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Architecting an Enterprise App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构企业应用
- en: In *Chapter 2*, *Forms, Observables, Signals, and Subjects*, we used the LocalCast
    Weather app to demonstrate various features of Angular to learn as well as experiment
    with and inform us if these features are suitable for more complex enterprise
    applications. Building enterprise applications is as much about the people building
    them as it is the technology used to build them. An over-eager approach to consuming
    and rolling out unproven tech is guaranteed to create the **sinkhole effect**
    in your project. If you’re unfamiliar with sinkholes, they are a natural phenomenon
    that occurs due to the dissolution of underlying ground material. At some point,
    usually suddenly, the ground collapses to devastating effect, revealing a giant
    hole in the ground.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 2 章*，*表单、Observables、Signals 和 Subjects* 中，我们使用 LocalCast Weather 应用来展示
    Angular 的各种特性，以便学习和实验，并告知我们这些特性是否适合更复杂的企业应用。构建企业应用与构建它们的团队一样重要，也与构建它们的技术一样重要。对未经证实的技术的过度热情和快速推广肯定会让你项目中的技术“黑洞”效应。如果你不熟悉“黑洞”，它们是由于地下材料溶解而发生的自然现象。在某个时候，通常突然，地面会塌陷，产生毁灭性的影响，露出地下的巨大空洞。
- en: In this book, I’ve done my best only to include tried and true, mature, and
    well-supported technologies and practices. LocalCast Weather includes all the
    cutting-edge features of Angular, like a root-level standalone project with standalone
    components, signals, and control flow syntax. With standalone components, we shed
    the concept of shared modules, helping resolve circular dependency issues and
    unnecessary bloat due to overstuffed shared modules. However, frustrations exist.
    Standalone projects require libraries to support providers instead of modules;
    when a provider is missing, applying a library to a project with feature modules
    becomes tedious guesswork.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我尽力只包括经过验证、成熟且得到良好支持的技伎和实践。LocalCast Weather 包含了 Angular 的所有前沿特性，如根级别的独立项目、独立组件、信号和控制流语法。通过独立组件，我们摒弃了共享模块的概念，有助于解决循环依赖问题和由于共享模块过于臃肿而产生的冗余。然而，也存在一些挫折。独立项目需要库来支持提供者而不是模块；当缺少提供者时，将库应用于具有功能模块的项目变得繁琐且充满猜测。
- en: Control flow syntax, in preview, produces easier-to-read templates and removes
    the need to import structural directives, which reduces boilerplate. Meanwhile,
    Angular Signals, in partial preview, won’t bring major value until signal-based
    components are rolled out. Regardless, Angular Signals draws from new JavaScript
    primitives, covered later, in the *Minimalist JavaScript solutions* section, you
    should know and learn to use outside of Angular. Before diving into specifics,
    let’s consider the bigger picture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语法在预览中产生易于阅读的模板，并消除了导入结构指令的需要，从而减少了样板代码。同时，Angular 信号在部分预览中，直到基于信号的组件推出之前，不会带来重大价值。无论如何，Angular
    信号借鉴了后面将要介绍的新的 JavaScript 基本类型，在 *Minimalist JavaScript solutions* 部分中，你应该了解并学会在
    Angular 之外使用它们。在深入具体细节之前，让我们先考虑更大的图景。
- en: The most common type of app built in an enterprise is a **Line-of-Business**
    (**LOB**) application. LOB apps are the bread and butter of the software development
    world. As Wikipedia defines it, LOB is a general term that refers to a product
    or a set of related products that serve a particular customer transaction or business
    need. LOB apps present an excellent opportunity to demonstrate various features
    and functionality without getting into the contorted or specialized scenarios
    that large enterprise applications usually need to address.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业中构建的最常见类型的应用是**业务线**（**LOB**）应用。LOB 应用是软件开发世界的基石。正如维基百科所定义的，LOB 是一个通用术语，指的是服务于特定客户交易或业务需求的产品或一系列相关产品。LOB
    应用提供了展示各种功能和特性的绝佳机会，而无需涉及大型企业应用通常需要解决的扭曲或专业场景。
- en: The Pareto principle, also known as the 80-20 rule, states that we can accomplish
    80% of our goals with 20% of the overall effort. We will apply the 80-20 rule
    to the design and architecture of our LOB app. Given the common use cases LOB
    apps cover, they are perfect for the 80-20 learning experience. With only 20%
    of the effort, you can learn about 80% of what you need to deliver high-quality
    experiences to your users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 帕累托原则，也称为 80-20 规则，表明我们可以用 20% 的总体努力完成 80% 的目标。我们将把 80-20 规则应用于我们的 LOB 应用设计和架构。鉴于
    LOB 应用覆盖的常见用例，它们非常适合 80-20 学习体验。只需 20% 的努力，你就可以了解 80% 你需要知道的内容，以便为用户提供高质量体验。
- en: LOB apps have a curious property to them. If you build a semi-useful app, its
    demand grows uncontrollably, and you quickly become the victim of your success.
    It’s challenging to balance the architectural needs of a project; you want to
    avoid potentially devastating under-engineering and, on the flip side, avoid costly
    over-engineering for an app that will never need it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: LOB应用有一个奇特的特点。如果你构建了一个半有用的应用，其需求会无控制地增长，你很快就会成为你成功的受害者。平衡项目的架构需求具有挑战性；你想要避免潜在的毁灭性低工程，同时，在另一方面，避免为那些永远不会需要它的应用进行昂贵的过度工程。
- en: In this chapter, I’m going to introduce you to ingredients that will allow you
    to be successful in your enterprise, things you should consider as an architect,
    various tools you should consider when building a performant app, how to design
    a large app using router-first architecture, and the 80-20 design solution to
    address the challenges of delivering a modern web application incrementally and
    iteratively.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你介绍一些要素，这些要素将帮助你在你企业中取得成功，作为架构师你应该考虑的事项，在构建高性能应用时应考虑的各种工具，如何使用路由优先架构设计大型应用，以及80-20设计解决方案来解决交付现代Web应用时增量迭代所面临的挑战。
- en: As you read in *Chapter 1*, *Angular’s Architecture and Concepts*, software
    architecture doesn’t stay static. It’s essential to experiment with new ideas
    by using coding katas, proof-of-concept apps, and reference projects to practice
    getting better at creating more flexible architectures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*第一章*，*Angular的架构和概念*中阅读的那样，软件架构不会保持静态。通过使用编码kata、概念验证应用和参考项目来实践，使用新想法进行实验是至关重要的，这有助于你更好地创建更灵活的架构。
- en: In this and the remaining chapters of the book, we’ll set up a new application
    with rich features that can meet the demands of an LOB application with scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there’s demand. We will follow the **Router-First
    Architecture**, a design pattern relying on reusable components to create a grocery
    store LOB application named **LemonMart**. We’ll discuss designing around major
    data entities and the importance of completing high-level mock-ups for your application
    before implementing various conditional navigation elements, which may change
    significantly during the design phase.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的本章和剩余章节中，我们将设置一个具有丰富功能的新应用，它可以满足具有可扩展架构和工程最佳实践的LOB应用的需求。我们将遵循**路由优先架构**，这是一种依赖于可重用组件来创建名为**LemonMart**的杂货店LOB应用的设计模式。我们将讨论围绕主要数据实体进行设计，以及在实现各种条件导航元素之前完成应用的高级原型的重要性，这些元素在设计阶段可能会发生重大变化。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Succeeding as a technical lead or architect
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为一个技术领导或架构师
- en: Ingredients for succeeding in your enterprise
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的企业中取得成功的要素
- en: Kanban planning using GitHub projects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub项目进行看板规划
- en: Tools for building high-performance apps
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建高性能应用的工具
- en: Applying the 80-20 solution to software development
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将80-20法则应用于软件开发
- en: Learning how to build router-first apps
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何构建路由优先应用
- en: Let’s start by covering non-technical aspects of a project that you must have
    a grasp of, so you can set up your team for success.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从你必须掌握的项目非技术方面开始，这样你就可以为团队的成功奠定基础。
- en: Succeeding as a technical lead or architect
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为一个技术领导或架构师
- en: I will be using the terms **technical lead** and **architect** interchangeably.
    Depending on the size of your organization, this may be two separate roles or
    one. But no matter which specific role you fulfill, in these roles, it is up to
    you to ensure the success of your project and, most importantly, the well-being
    of your team members.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我将交替使用**技术领导**和**架构师**这两个术语。根据你所在组织的规模，这可能是两个不同的角色，也可能是一个。但无论你担任哪个具体角色，在这些角色中，确保你项目成功以及最重要的是确保团队成员的幸福，都取决于你。
- en: Understand the business impact
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解业务影响
- en: 'Your first task should be to understand the business impact of your project.
    Some questions to ask are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个任务应该是理解你项目的业务影响。以下是一些需要提出的问题：
- en: How critical is the success of this project to the business?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个项目的成功对业务有多重要？
- en: What are the consequences of failure?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败的后果是什么？
- en: What does it mean to fail?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败意味着什么？
- en: Which features will deliver the most value?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些功能将带来最大的价值？
- en: What are the parameters you must operate under?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须操作哪些参数？
- en: What’s negotiable and what’s not?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么可以协商，什么不可以？
- en: The answers you get to these questions will vary how your project should operate
    significantly. If the survival or reputation of the business is at stake, you
    must amplify the aspects of the project that’ll ensure the business survives or
    its reputation isn’t tarnished. If a certain feature set will bring the most value,
    then focus all attention on getting performant and high-quality UX in that section
    and simplify the rest for the initial release. If certain personnel or technology
    is being dictated, weigh that against other factors. Expend all your energy and
    capital ensuring that the technology picked by your **Chief Technology Officer**
    (**CTO**) is a good fit for a project that will be a sink or swim moment for the
    company. Don’t fight unnecessary battles.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你对这些问题的回答将显著影响你的项目应该如何运作。如果企业的生存或声誉受到威胁，你必须放大确保企业生存或声誉不受损害的项目方面。如果某些功能集将带来最大价值，那么集中所有注意力在该部分获得高性能和高品质的用户体验，并将其他部分简化为初始发布。如果某些人员或技术被指定，权衡这些因素与其他因素。确保你选择的**首席技术官**（**CTO**）选择的技术适合公司生死存亡的项目。不要进行不必要的斗争。
- en: Set parameters of success
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设定成功的参数
- en: As a general principle, it’s advisable to leverage the strengths and passions
    of your team members. This is critical if resources or time is tight. People will
    work harder to invest in your project if they’re also investing their time in
    a technology that they’re passionate about. But don’t do this at the cost of failure
    – going back to my point on over-eager use of new tech at the beginning of the
    chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项基本原则，利用团队成员的优势和激情是明智的。如果资源或时间紧张，这一点尤为重要。如果人们也在他们热爱的技术中投入时间，他们将会更努力地投资于你的项目。但不要以失败为代价——回到我在本章开头关于过度热衷于使用新技术的那一点。
- en: It is important to establish clear parameters for success for your team. This
    will only be possible if you *yourself* have a clear understanding of the business
    impact. You and your team members are on a journey. You’re all walking on a path.
    Falling off the path means peril, either for individual team members or the project’s
    success. It is up to you to vary how wide or narrow this path is. If you leave
    it too narrow, your team members will suffocate and be frustrated due to the lack
    of freedom or intense scrutiny. On the contrary, if you leave it too wide, you’ll
    have more experimentation than any real work to do. You must set guard rails on
    the path at just the right amount to match the team and project needs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的团队设定明确的成功参数非常重要。这只有在你自己清楚业务影响的情况下才可能实现。你和你的团队成员都在一条旅程上。你们都在一条道路上行走。偏离道路意味着危险，无论是对于个人团队成员还是项目的成功。这取决于你如何调整这条道路的宽窄。如果你让它太窄，你的团队成员会因为缺乏自由或过于严格的审查而窒息和沮丧。相反，如果你让它太宽，你将会有比实际工作更多的实验。你必须根据团队和项目的需求，在道路上设置适量的护栏。
- en: Elastic leadership
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性领导
- en: Your leadership style can’t be static. It must be *elastic*. All teams and projects
    have a lifecycle. They can go through periods of survival, learning, or self-organizing.
    Depending on deadlines or outside factors, teams can be forced from one state
    to another.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的领导风格不能是静态的。它必须是**弹性的**。所有团队和项目都有生命周期。它们可能经历生存、学习或自我组织的阶段。根据截止日期或外部因素，团队可能被迫从一个状态转变为另一个状态。
- en: Check out Roy Osherove’s excellent content on elastic leadership at [https://www.elasticleadership.com](https://www.elasticleadership.com).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Roy Osherove在[https://www.elasticleadership.com](https://www.elasticleadership.com)上关于弹性领导的优秀内容。
- en: Understand what state your team is in and vary your leadership style accordingly.
    Survival mode requires a dictator- or protector-style leader, where you’re heavily
    involved with all team activities and are directing individual tasks and actions.
    Your goal should be to move teams in this state to learning mode. This is where
    you become a coach, where you are not as involved in daily activities but instead
    focus on what team members should learn and how they should grow. The next step
    up would be a team in *self-organizing* mode. These teams are resilient, they
    grow on their own, and they can take general direction and strategy and execute
    them. At this point, you need to be a facilitator or a servant leader. If you
    dictate to a mature team, you’ll quickly lose that team.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的团队处于何种状态，并相应地调整你的领导风格。生存模式需要独裁者或保护者风格的领导者，你将深度参与所有团队活动，并指导个别任务和行动。你的目标应该是将处于这种状态的团队转移到学习模式。这就是你成为教练的时候，你不再那么参与日常活动，而是专注于团队成员应该学习什么以及他们应该如何成长。下一步将是处于*自我组织*模式的团队。这些团队具有弹性，他们可以自我成长，并且可以接受一般方向和战略并执行它们。在这个阶段，你需要成为一个促进者或仆人式领导者。如果你对一个成熟的团队发号施令，你很快就会失去这个团队。
- en: Google’s **DevOps Research and Assessment** (**DORA**) program contains 30 capabilities
    across technical, process, and cultural topics that your team and organization
    can master to become a high-performing team. The research program has been running
    since 2014, considering input from 33,000 professionals from various industries
    and governments. Learn more about the program at [https://dora.dev](https://dora.dev).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的**DevOps研究和评估**（**DORA**）计划包含30个涵盖技术、流程和文化主题的能力，你的团队和组织可以掌握这些能力，成为一个高绩效团队。该研究项目自2014年起运行，考虑了来自各行各业和政府的33,000名专业人士的意见。了解更多关于该计划的信息，请访问[https://dora.dev](https://dora.dev)。
- en: If you don’t understand these concepts, you’re likely to put your team members
    in situations where they’ll burn out, working overtime and with low morale, which
    could also impact family life and cause stress and high turnover. In that case,
    you may need to look in the mirror, with so many people standing there. All factors
    lead to a vicious cycle that is not good for running a healthy organization. As
    the saying goes, it’s not a sprint but a marathon. It’s as much about the journey
    as reaching the end goal. Don’t fail your team.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不懂这些概念，你可能会让你的团队成员处于他们将会筋疲力尽的情况，加班工作且士气低落，这可能会影响家庭生活，造成压力和高流失率。在这种情况下，你可能需要照照镜子，因为有这么多人站在那里。所有因素都会导致一个不利于健康组织运行的恶性循环。正如俗话所说，这不是短跑，而是马拉松。它不仅关乎达到终点，也关乎旅程。不要让你的团队失败。
- en: Ingredients of a successful project
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功项目的要素
- en: You understand the business impact of your project and you have a team eager
    to start; now what? You must have a plan, of course. As the German field marshal
    Moltke the Elder put it (or at least the modern paraphrase of it), *“No plan survives
    first contact with the enemy.”*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你理解你项目的商业影响，并且你有一个渴望开始的团队；现在怎么办？当然，你必须有一个计划。正如德国陆军元帅莫尔特克所说（或者至少是现代对它的诠释），*“没有计划能在与敌人的第一次接触中存活。”*
- en: Half a century later, Winston Churchill and Dwight D. Eisenhower added, *“Plans
    are of little importance [or are worthless], but planning is essential [or indispensable].”*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 五十年后，温斯顿·丘吉尔和德怀特·D·艾森豪威尔补充说，*“计划的重要性很小[或者毫无价值]，但规划是必不可少的[或者不可或缺的]。”*
- en: Agile software development
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷软件开发
- en: Over the past decade, Agile software management has taken over the world, replacing
    waterfall project execution with Scrum and Gantt charts with Kanban boards and
    iterative and incremental delivery every two weeks instead of multi-year development
    cycles with long lead times and expensive **Quality Assurance** (**QA**) and support
    cycles. Statistics show that Agile projects have a higher success rate than waterfall
    projects. This intuitively makes sense because iterative and incremental delivery
    ensures success happens as soon as possible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，敏捷软件开发管理已经接管了世界，用Scrum取代了瀑布式项目执行，用看板板取代了甘特图，每两周进行一次迭代和增量交付，而不是多年开发周期、长周期和昂贵的**质量保证**（**QA**）和支持周期。统计数据显示，敏捷项目比瀑布项目有更高的成功率。这从直觉上是有道理的，因为迭代和增量交付确保成功尽可能快地发生。
- en: 'The Agile Manifesto, located at [http://agilemanifesto.org](http://agilemanifesto.org),
    published in 2001, highlights the key ingredients for becoming Agile:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年发布的位于[http://agilemanifesto.org](http://agilemanifesto.org)的敏捷宣言，强调了成为敏捷的关键要素：
- en: Individuals and interactions over processes and tools
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 个人和交互而非流程和工具
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Working software over comprehensive documentation
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 工作软件而非全面文档
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Customer collaboration over contract negotiation
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 客户协作而非合同谈判
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Responding to change over following a plan
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 针对变化而非遵循计划
- en: Most individuals are introduced to Agile when they join a Scrum team, and because
    of this most people conflate Agile and Scrum. Scrum is a management framework.
    Concepts like sprints, planning meetings, retrospectives, and other optional elements
    like user stories and story points have nothing to do with Agile. It is possible
    to execute Scrum and abuse every Agile value possible.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人在加入Scrum团队时接触到敏捷，因此大多数人混淆了敏捷和Scrum。Scrum是一个管理框架。像冲刺、规划会议、回顾和其他可选元素，如用户故事和故事点，与敏捷无关。执行Scrum并滥用所有可能的敏捷价值观是可能的。
- en: 'At the *deliver:Agile 2018* conference in Austin, Texas, I listened to a talk
    by Ron Jeffries (a signatory of the 2001 Agile Manifesto) and Chet Hendrickson
    (a guy with an incredible sense of humor who rightly picked on me for having all
    sorts of JavaScript stickers on the lid of my MacBook) about Agile development.
    They focused on the “working software” component of the Agile Manifesto to drive
    home an important point. No amount of process, management oversight, or meetings
    will result in software delivery. As I aptly put it in my 2018 talk titled, Ship
    It or It Never Happened:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在德克萨斯州奥斯汀的*交付：敏捷2018*会议上，我听了Ron Jeffries（2001年敏捷宣言的签署者）和Chet Hendrickson（一个幽默感极强的人，正确地批评我在MacBook的盖子上贴满了各种JavaScript贴纸）关于敏捷开发的演讲。他们聚焦于敏捷宣言的“工作软件”部分，以强调一个重要观点。无论多少流程、管理监督或会议都不会导致软件交付。正如我在2018年的演讲《交付或从未发生》中恰如其分地所说：
- en: ”It’s not up to them [the managers]
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “这不是他们的责任[经理们]
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: it’s up to us [the developers].”
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是我们[开发者]的责任。”
- en: It’s not about creating pretty diagrams with endless iterations over imaginary
    architecture. It’s not about delivering story points, checking boxes, and moving
    cards from one column to another. In short, don’t be a process monkey. Focus on
    delivering working code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是关于创建漂亮的图表，对虚构的架构进行无休止的迭代。这也不是关于交付故事点、勾选框和将卡片从一个列移动到另一个列。简而言之，不要成为流程猴子。专注于交付可工作的代码。
- en: Agile engineering best practices
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷工程最佳实践
- en: 'The best way to accomplish this is by delivering and adhering to Agile engineering
    best practices:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的最佳方式是通过交付和遵守敏捷工程最佳实践：
- en: '**Test-Driven Development** (**TDD**): Writing tests before writing actual
    code to ensure code meets requirements.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）：在编写实际代码之前编写测试，以确保代码满足要求。'
- en: '**Continuous Integration** (**CI**): Running automated builds and tests on
    code commits frequently to catch issues early.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）：频繁地对代码提交运行自动构建和测试，以尽早发现问题。'
- en: '**Continuous Delivery** (**CD**): Ensure every product iteration is in a releasable
    state.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续交付**（**CD**）：确保每个产品迭代都处于可发布状态。'
- en: '**Pair programming**: Team members learn from each other as they work on tasks
    together.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结对编程**：团队成员在共同完成任务时相互学习。'
- en: '**Refactoring**: Continuously improve the codebase as part of daily work.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构**：作为日常工作的一部分，持续改进代码库。'
- en: '**Simple and evolutionary design**: Designs should be as simple as possible
    to achieve current requirements without over-engineering and be flexible or open-ended
    enough that they can evolve over time.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单且演进式设计**：设计应尽可能简单，以满足当前需求，避免过度设计，并且足够灵活或开放，以便随着时间的推移而演进。'
- en: '**Behavior-Driven Development** (**BDD**): Use tests based on the expected
    behavior of software, backed with concrete examples, in a syntax like Gherkin
    (`Given`, `When`, `Then` format) so technical and non-technical people can collaborate.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）：使用基于软件预期行为的测试，辅以具体示例，采用类似于Gherkin（`Given`、`When`、`Then`格式）的语法，以便技术和非技术人员可以协作。'
- en: '**Frequent releases**: Deliver software in small batches frequently.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**频繁发布**：频繁以小批量交付软件。'
- en: '**High cohesion and low coupling**: Modules or components focus on a single
    task, while these modules or components have minimal dependencies on each other.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高内聚低耦合**：模块或组件专注于单一任务，同时这些模块或组件之间相互依赖最小。'
- en: 'Adhere to SOLID principles:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循SOLID原则：
- en: '**Single responsibility principle**: A function or class should only be responsible
    for one task.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单一职责原则**：函数或类只应负责一项任务。'
- en: '**Open/closed principle**: Code should be open for extension (i.e., extensible)
    but closed for modification (i.e., extensible without having to rewrite the algorithm).'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开放/封闭原则**：代码应该对扩展开放（即，可扩展）但对修改封闭（即，无需重写算法即可扩展）。'
- en: '**Liskov substitution principle**: Inheriting from a super/base class shouldn’t
    result in unexpected behavior.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Liskov替换原则**：从超类/基类继承不应该导致意外行为。'
- en: '**Interface segregation principle**: Expose the most minimal interface required.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：暴露所需的最小接口。'
- en: '**Dependency inversion principle**: Modules/components should depend on abstractions
    instead of concrete implementations.'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**：模块/组件应该依赖于抽象而不是具体实现。'
- en: '**DRY principle**: Don’t repeat yourself. Applying DRY helps make code easier
    to maintain. If you need to change something, you only have to change it in one
    place instead of many places. However, taking DRY too far can sometimes overcomplicate
    code, so use judgment to find the right balance. The principle is about sensibly
    reducing duplication, not eliminating it entirely.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DRY原则**：不要重复自己。应用DRY原则有助于使代码更容易维护。如果你需要更改某些内容，你只需在一个地方更改，而不是多个地方。然而，过度应用DRY有时可能会使代码过于复杂，因此需要判断以找到正确的平衡。该原则是关于合理减少重复，而不是完全消除重复。'
- en: Engineering excellence and craftsmanship
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工程卓越和工艺
- en: Adhering to these principles requires engineering excellence and a craftsmanship
    mindset. People on your team need to care about their work, be proud of the code
    they write, and be satisfied with the results they produce.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些原则需要工程卓越和工艺心态。你的团队成员需要关心他们的工作，为他们的代码感到自豪，并对他们产生的结果感到满意。
- en: Translating requirements and designs to working code is not easy. Doing it iteratively
    and incrementally requires a deep understanding of technology, tools, and business
    requirements. However, being able to write code simultaneously without over-engineering
    it while also keeping it flexible is not only possible, but it should also be
    the goal of every engineer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将需求和设计转换为工作代码并不容易。以迭代和增量方式完成它需要深入了解技术、工具和业务需求。然而，同时编写代码而不过度设计，同时保持其灵活性不仅是可能的，而且应该是每个工程师的目标。
- en: Oh, and pick a component library and stick to it, but also avoid vendor lock-in.
    Good luck!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，选择一个组件库并坚持下去，但也避免供应商锁定。祝你好运！
- en: Angular in an enterprise
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业中的Angular
- en: Angular is not appropriate for use on every project. However, Angular is preferred
    in an enterprise because of the advanced concepts supported by the framework,
    such as **Dependency Injection** (**DI**), native TypeScript support, a modular
    architecture, robust packaging, testing, accessibility tools, and a commitment
    to release new versions regularly. The amalgamation of these tools helps applications
    scale beyond small apps to truly large-scale applications with 1,000+ views.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular并不适合用于每个项目。然而，由于框架支持的高级概念，如**依赖注入**（**DI**）、原生TypeScript支持、模块化架构、强大的打包、测试、可访问性工具，以及对定期发布新版本的承诺，Angular在企业中被优先考虑。这些工具的结合有助于应用从小型应用扩展到真正的大规模应用，拥有1,000+视图。
- en: 'For **Content Management System** (**CMS**) style use cases and simple applications,
    you should consider using Analog. Analog is a meta-framework for building apps
    and websites with Angular: [https://analogjs.org](https://analogjs.org). Analog
    comes pre-configured with **Server-Side Rendering** (**SSR**), **Static Site Generation**
    (**SSG**), Vite ([https://vitejs.dev](https://vitejs.dev)) tooling, and convention-based
    routing and API routes for a no-frills, all-excitement development experience.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**内容管理系统**（**CMS**）风格的使用案例和简单应用，你应该考虑使用Analog。Analog是一个用于使用Angular构建应用和网站的元框架：[https://analogjs.org](https://analogjs.org)。Analog预配置了**服务器端渲染**（**SSR**）、**静态站点生成**（**SSG**）、Vite（[https://vitejs.dev](https://vitejs.dev)）工具、基于约定的路由和API路由，以提供无烦恼、充满激情的开发体验。
- en: In fact, [https://AngularForEnterprise.com](https://AngularForEnterprise.com)
    was created using Analog.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，[https://AngularForEnterprise.com](https://AngularForEnterprise.com)就是使用Analog创建的。
- en: Diverse coding paradigm support
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多种编程范式支持
- en: Angular allows for different styles of programming. You can choose between imperative
    and reactive coding, leverage OOP concepts or completely ignore them, have inline
    and compact single-file components, or use up to four files to contain the same
    code. This variety is a strength when supporting a diverse population of developers,
    but it can also be a weakness by allowing multiple implementation styles within
    the same project. It is important to control this by establishing team norms around
    which programming style and paradigm to use. Linting and code-style tools like
    ESLint can help keep the code’s appearance uniform but are ineffective at detecting
    or preventing paradigm shifts in code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 允许不同的编程风格。您可以选择命令式和响应式编程，利用面向对象的概念，或者完全忽略它们，拥有内联和紧凑的单文件组件，或者使用多达四个文件来包含相同的代码。这种多样性在支持多样化的开发者群体时是一种优势，但也可能因为允许同一项目内存在多种实现风格而成为一种弱点。通过建立关于使用哪种编程风格和范式的团队规范来控制这一点是很重要的。像
    ESLint 这样的代码风格工具可以帮助保持代码外观的一致性，但在检测或防止代码中的范式转变方面并不有效。
- en: Community support
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区支持
- en: Angular has a great and engaged community filled with brilliant, respectful,
    and positive individuals who collaborate to build tools around Angular and evangelize
    it across the tech community. Google also supports Angular with the Google Developer
    Expert program, which I’ve been lucky to have been a part of, where the Angular
    team meets with active community members, gives them early access, listens to
    their feedback, and encourages collaboration. This means that when your enterprise
    needs support, there’s a trustworthy community of individuals out there that you
    can tap into for advice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 拥有一个伟大且积极参与的社区，其中充满了聪明、尊重和积极的人，他们共同构建围绕 Angular 的工具并在技术社区中传播 Angular。谷歌也通过
    Google Developer Expert 计划支持 Angular，我有幸成为其中的一员，Angular 团队会与活跃的社区成员会面，给他们提供早期访问，听取他们的反馈，并鼓励合作。这意味着当您的企业需要支持时，有一个值得信赖的社区个人群体，您可以从中获取建议。
- en: As discussed in the introduction and *Future of Angular* sections of *Chapter
    1*, *Angular’s Architecture and Concepts*, as the size of a web application grows,
    performance issues begin cropping up in rendering the application, the tooling
    struggles to support the number of contributors to the project, and the architecture
    becomes inadequate in handling the complexity and variety of requirements. More
    on architecture when we discuss the 80-20 solution and router-first architecture
    later in the chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 1 章中“引言”和“Angular 的架构和概念”部分所讨论的，随着 Web 应用程序规模的扩大，性能问题开始出现在应用程序的渲染中，工具难以支持项目中的贡献者数量，架构在处理复杂性和多样化的需求时变得不足。关于架构的更多内容，我们将在本章后面讨论
    80-20 解决方案和路由优先架构。
- en: You can find and contribute to a community-curated list of tools for building
    enterprise applications using Angular at [https://angularforenterprise.com/enterprise-tools](https://angularforenterprise.com/enterprise-tools).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://angularforenterprise.com/enterprise-tools](https://angularforenterprise.com/enterprise-tools)
    找到并贡献一个社区整理的、用于构建企业应用程序的 Angular 工具列表。
- en: Next, let’s dive into tools that can support building high-performance apps
    with good UX and DevEx.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解可以支持构建具有良好 UX 和 DevEx 的高性能应用程序的工具。
- en: Tools and techniques for high-performance apps
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高性能应用程序的工具和技术
- en: 'In this section, we will cover topics related to building high-performance
    apps. While some of these tools are specific to Angular, the general sentiment
    and advice apply to all web applications. This means that a complicated and large
    application should still be able to:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与构建高性能应用程序相关的话题。虽然其中一些工具是针对 Angular 的，但总体观点和建议适用于所有 Web 应用程序。这意味着一个复杂的大型应用程序仍然能够：
- en: Hit a smooth 60 FPS rendering target
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 达到平滑的 60 FPS 渲染目标
- en: Respond to user clicks within 340 ms
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 340 毫秒内响应用户点击
- en: Provide fast feedback loops to developers
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为开发者提供快速的反馈循环
- en: Run builds and automated tests as quickly as possible
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能快地运行构建和自动化测试
- en: Let’s first talk about runtime performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈运行时的性能。
- en: Runtime performance
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时性能
- en: Bad performance has real consequences for a business. In 2008, it was reported
    that a latency increase of 100 ms reduced Amazon’s sales by 1%. In 2006, Google
    observed that an additional 0.5 seconds in generating a search page led to a 20%
    decrease in traffic. These are astounding numbers at Amazon and Google’s scales,
    where milliseconds translate to millions of dollars. This may mean thousands or
    hundreds of thousands of dollars at your organization’s scale. Considering performance
    trends over time, these smaller numbers can still multiply to millions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的性能对业务有真实的影响。2008年，有报道称延迟增加100毫秒使亚马逊的销售额减少了1%。2006年，谷歌观察到生成搜索页面额外增加0.5秒导致流量下降了20%。在亚马逊和谷歌这样的规模下，这些数字令人震惊，因为毫秒可以转化为数百万美元。这可能意味着在您的组织规模下，数千或数十万美元。考虑到随时间推移的性能趋势，这些较小的数字仍然可以累积到数百万。
- en: The browser is a complicated runtime environment, and the frameworks we use
    to develop web applications obfuscate the runtime in exchange for rich features
    and easier-to-maintain code. This obfuscation introduces performance issues specific
    to framework code on top of native browser-related optimization requirements.
    And in 2024, the frameworks we use have become incredibly complicated.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器是一个复杂的运行环境，我们用来开发Web应用的框架通过牺牲丰富的特性和易于维护的代码来模糊运行时。这种模糊化在满足原生浏览器相关优化要求的基础上，引入了特定于框架代码的性能问题。到了2024年，我们使用的框架已经变得极其复杂。
- en: 'Let’s understand what kind of indicators we can use to understand the runtime
    performance of a web application:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们可以使用哪些指标来理解Web应用的运行时性能：
- en: '**First Contentful Paint** (**FCP**): Measures the time from page start to
    the first visual content displayed'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首次内容绘制**（**FCP**）：衡量从页面开始到首次显示可视内容的时间'
- en: '**Time to Interactive** (**TTI**): Measures a page’s load responsiveness and
    helps identify where a page looks interactive but isn’t'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互时间**（**TTI**）：衡量页面加载的响应性，并有助于识别页面看起来是交互式的但实际上不是的情况'
- en: '**Latency**: The delay between a user’s action and its response'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：用户操作与其响应之间的延迟'
- en: '**Frame drops**: Occurrences when frames can’t be generated fast enough to
    render a UI smoothly'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧率下降**：当帧无法快速生成以平滑渲染UI时发生的情况'
- en: 'We can use the profiling tools in our browser’s DevTools to discover these
    issues. Below is an annotated example of a **flame chart** (often referred to
    as a flame graph) created by Michael Hladky, which highlights the various stages
    of the bootstrap process of an Angular app:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用浏览器DevTools中的分析工具来发现这些问题。下面是一个由Michael Hladky创建的**火焰图**（通常称为火焰图）的注释示例，它突出了Angular应用引导过程的各个阶段：
- en: '![](img/B18047_03_01.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18047_03_01.png)'
- en: 'Figure 3.1: Flame chart of Angular Bootstrap phase. Credit Michael Hladky'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：Angular引导阶段的火焰图。版权所有Michael Hladky
- en: The x axis of the chart shows times, and the y-axis shows the stack of function
    calls. A wide bar indicates a function taking a long time to execute or being
    called frequently. A tall stack includes a deep chain of function calls. You may
    use these visual clues to zoom into the chart and investigate performance issues.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的x轴显示时间，y轴显示函数调用堆栈。一个宽条表示一个执行时间较长或被频繁调用的函数。一个高的堆栈包括一个深层次的函数调用链。您可以使用这些视觉线索放大图表并调查性能问题。
- en: If you’re unfamiliar with using Chrome’s profiling features, please refer to
    [https://developer.chrome.com/docs/devtools/performance/reference](https://developer.chrome.com/docs/devtools/performance/reference).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉使用Chrome的分析功能，请参阅[https://developer.chrome.com/docs/devtools/performance/reference](https://developer.chrome.com/docs/devtools/performance/reference)。
- en: Root cause of performance bottlenecks
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能瓶颈的根本原因
- en: 'What’s slowing us down? During the bootstrap process of an application or when
    loading a new page, several things happen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 什么在拖慢我们的进度？在应用的引导过程中或加载新页面时，会发生几件事情：
- en: '**Downloading JavaScript**: This includes application, framework, and third-party
    library code. The larger the size, the slower it is.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**下载JavaScript**：这包括应用、框架和第三方库代码。大小越大，速度越慢。'
- en: '**Executing JavaScript**: Code needs to be unzipped and loaded into memory,
    then parsed by the JavaScript engine for just-in-time execution; DOM elements
    and framework hooks need to be scaffolded.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行JavaScript**：代码需要解压缩并加载到内存中，然后由JavaScript引擎进行即时执行；DOM元素和框架钩子需要构建。'
- en: '**Hydrating app code**: The framework must compute the application’s state
    (visual and data), connect event listeners to the DOM, and render.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用代码的初始化**：框架必须计算应用程序的状态（视觉和数据），将事件监听器连接到DOM，并渲染。'
- en: '**Change detection**: The framework must traverse the component tree to determine
    if the UI should be updated due to a state change.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变更检测**：框架必须遍历组件树以确定UI是否应该因为状态变化而更新。'
- en: Executing these steps sequentially, presuming your application or API code is
    free of major issues, is the main root cause of performance issues with large
    web applications. In the current state of SPA frameworks, these issues are inescapable
    and/or very expensive to overcome.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序执行这些步骤，假设您的应用程序或API代码没有重大问题，是大型网络应用程序性能问题的根本原因。在当前的单页应用（SPA）框架状态下，这些问题是无法避免的，或者解决起来非常昂贵。
- en: An example of an inescapable issue would be rendering too many interactive components
    on the screen. A very expensive solution to this might be to patch every single
    component with custom code to circumvent the normal lifecycle of the framework
    and coerce it to behave in a way that could only benefit the application you’re
    building.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法避免的问题的例子就是在屏幕上渲染过多的交互式组件。解决这个问题的一个非常昂贵的方案可能是用自定义代码修补每一个组件，以绕过框架的正常生命周期，并强制它以只能对您正在构建的应用程序有益的方式行事。
- en: Minimalist JavaScript solutions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最简主义的JavaScript解决方案
- en: ECMAScript 2022, widely supported by all major browsers, has built-in fundamentals
    that allow us to build performant and reactive web applications from scratch.
    For only 1-2 kb of “framework” code, we can vastly improve the DevEx and create
    modern and fast websites.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2022，被所有主流浏览器广泛支持，具有内置的基本功能，使我们能够从头开始构建性能良好且响应式的网络应用程序。仅用1-2 kb的“框架”代码，我们就可以极大地提高开发体验，并创建现代且快速的网站。
- en: ArrowJS
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArrowJS
- en: 'At the Frontrunners 2023 conference in Washington DC, I attended a talk by
    Justin Schroeder about his frontend library named ArrowJS, Reactivity without
    the framework. More information can be found at [https://www.arrow-js.com](https://www.arrow-js.com).
    In his talk, Justin covered the fundamentals that made his library possible:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在2023年弗罗里达州华盛顿特区的Frontrunners 2023会议上，我参加了一场由Justin Schroeder关于他的前端库ArrowJS（无框架的响应性）的演讲。更多信息可以在[https://www.arrow-js.com](https://www.arrow-js.com)找到。在他的演讲中，Justin介绍了使他的库成为可能的基本原理：
- en: '**WeakMap**: A WeakMap is a collection of key-value pairs where the keys are
    objects with arbitrary values. The keys are weakly referenced, meaning they can
    be garbage collected if no other references exist. Normally the map itself would
    count as a reference and thus remain in memory.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱映射**：弱映射是一个键值对的集合，其中键是具有任意值的对象。键是弱引用的，这意味着如果没有其他引用存在，它们可以被垃圾回收。通常，映射本身会作为引用而保留在内存中。'
- en: '**Proxy**: A proxy is an object that wraps another object or function and allows
    you to intercept and define custom behavior for fundamental operations. They are
    like middleware for your objects. Signals use a proxy under the covers. They are
    also useful in form validation.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：代理是一个包装另一个对象或函数的对象，允许您拦截并定义基本操作的自定义行为。它们是您对象的中介。信号在幕后使用代理。它们在表单验证中也很有用。'
- en: '**Set**: A set is a collection of values where each value must be unique, meaning
    the same value cannot appear more than once. They are useful for tracking dependencies.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：集合是一组值，其中每个值必须是唯一的，这意味着相同的值不能出现多次。它们对于跟踪依赖项很有用。'
- en: '**Tagged** template literals: These allow parsing template literals with a
    function, enabling custom string interpolation and processing. They are like middleware
    for strings. They are useful for parsing templated HTML code as a function.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签模板字面量**：这些允许使用函数解析模板字面量，实现自定义字符串插值和处理。它们是字符串的中介。它们用于将模板HTML代码作为函数解析很有用。'
- en: 'When all these concepts are put together, observe how you can replicate a to-do
    list app in ArrowJS:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些概念放在一起时，观察您如何在ArrowJS中复制一个待办事项列表应用程序：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code doesn’t require any compilation or further processing. The next solution,
    however, leverages similar technologies under the covers but also tackles all
    the big problems.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不需要任何编译或进一步处理。下一个解决方案，然而，在幕后利用类似的技术，但同时也解决了所有大问题。
- en: Qwik.js
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qwik.js
- en: The father of Angular, Miško Hevery, along with industry veteran Adam Bradley
    (jQuery Mobile, Ionic, Stencil.js) and whizbang coder Manu Almeida, created Qwik.js
    as a response to address the fundamental issues baked into popular SPA frameworks
    like Angular, React, and Vue. You can check out this framework at [https://qwik.builder.io](https://qwik.builder.io).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的创始人 Miško Hevery，以及行业老将 Adam Bradley（jQuery Mobile、Ionic、Stencil.js）和天才程序员
    Manu Almeida，共同创建了 Qwik.js，作为对 Angular、React 和 Vue 等流行 SPA 框架中固有的基本问题的回应。你可以在这个框架的网站上查看
    [https://qwik.builder.io](https://qwik.builder.io)。
- en: 'Feeling adventurous? Execute:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 想要冒险吗？执行：
- en: '[PRE1]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Qwik.js was built from the ground up to enforce a reactive coding paradigm,
    leveraging the signal primitive and resumability as a built-in feature to ensure
    that apps of any size or scale always do a full-page load under 1 second and perform
    5-10x faster overall. All with a library that is ~1 kb in size.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik.js 是从头开始构建的，以强制执行响应式编程范式，利用信号原语和可恢复性作为内置功能，确保任何大小或规模的 app 总能在 1 秒内完成全页加载，并且整体性能快
    5-10 倍。所有这些都在一个大小约为 1 kb 的库中实现。
- en: 'Qwik ships “batteries included” with rich user controls, a Vite dev server,
    testing with Vitest and Playwright, extendable styling, and server-side rendering,
    and it doesn’t require hydration. To understand the difference between hydration
    and resumability, see the following graphic:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Qwik 随带丰富的用户控件、Vite 开发服务器、Vitest 和 Playwright 进行测试、可扩展的样式和服务器端渲染，并且不需要激活。要了解激活和可恢复性之间的区别，请参阅以下图形：
- en: '![](img/B18047_03_02.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18047_03_02.png)'
- en: 'Figure 3.2: Hydration vs resumability. Adapted from Miško Hevery'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：激活与可恢复性。改编自 Miško Hevery
- en: At the top, you can see the hydration steps to load a traditional SPA. Each
    individual box takes longer the more your application grows. However, a resumable
    app is downloaded as a ready-to-render HTML payload, with its state embedded,
    bringing the complexity from O(![](img/B20960_03_001.png)) down to O(1).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，你可以看到加载传统 SPA 的激活步骤。随着应用程序的增长，每个单独的框所需的时间会更长。然而，一个可恢复的应用程序作为准备好渲染的 HTML
    有效载荷下载，其状态嵌入其中，将复杂度从 O(![图片](img/B20960_03_001.png)) 降低到 O(1)。
- en: If you find O(![](img/B20960_03_002.png)) intimidating, don’t worry. It’s meant
    to be a joke.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得 ![图片](img/B20960_03_002.png) 令人畏惧，别担心。这只是一个玩笑。
- en: After the initial load, Qwik pre-fetches only the required amount of JavaScript
    to enable interactivity. This can mean downloading individual functions at a time.
    Qwik is also aggressive about lazily executing code. So, only the elements that
    the user interacts with come alive, keeping performance concerns in check. Naturally,
    there are some smart pre-fetching algorithms working in the background to make
    this a seamless experience.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始加载后，Qwik 仅预取所需的 JavaScript 量以启用交互性。这可能意味着一次下载一个函数。Qwik 在懒加载代码方面也非常积极。因此，只有用户与之交互的元素才会活跃，从而保持性能问题的控制。自然地，有一些智能的预取算法在后台工作，以确保这是一个无缝的体验。
- en: If you would like to learn more about Qwik, check out my talk on YouTube at
    [https://www.youtube.com/watch?v=QDqp_qTa4Ww&t=40s](https://www.youtube.com/watch?v=QDqp_qTa4Ww&t=40s)
    and the slides at [https://slides.com/doguhanuluca/intro-to-qwik](https://slides.com/doguhanuluca/intro-to-qwik).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 Qwik 的信息，请查看我在 YouTube 上的演讲 [https://www.youtube.com/watch?v=QDqp_qTa4Ww&t=40s](https://www.youtube.com/watch?v=QDqp_qTa4Ww&t=40s)
    以及幻灯片 [https://slides.com/doguhanuluca/intro-to-qwik](https://slides.com/doguhanuluca/intro-to-qwik)。
- en: Next, let’s see what tools we can use to address these issues in Angular.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们可以使用哪些工具来解决 Angular 中的这些问题。
- en: Angular performance solutions
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 性能解决方案
- en: There are two categories of issues at play, one regarding the initial load of
    the application and the second ensuring smooth rendering by keeping change detection
    in check.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有两类问题在发挥作用，一类是关于应用程序的初始加载，另一类是通过保持变更检测来确保平滑渲染。
- en: Let’s start with **Server-Side Rendering** (**SSR**).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 **服务器端渲染** （**SSR**） 开始。
- en: Server-side rendering and hydration
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端渲染和激活
- en: '**Angular server-side rendering** enables rendering the SPA, an otherwise client-side
    technology with code executing in the browser on a server. The server can pre-bake
    the initial state of a view as simple HTML and JavaScript that the browser doesn’t
    have to spend a lot of time interpreting. As a result, the downloaded content
    renders very quickly, solving delays caused by downloading and executing large
    amounts of JavaScript. This is especially critical in mobile or outdated devices
    with limited processing and bandwidth. The server can perform this task consistently
    regardless of user hardware.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular服务器端渲染**使得渲染SPA成为可能，否则这是一个在浏览器中执行的客户端技术。服务器可以预先烘焙视图的初始状态，作为浏览器不需要花费太多时间解释的简单HTML和JavaScript。因此，下载的内容渲染非常快，解决了由于下载和执行大量JavaScript而造成的延迟。这在移动设备或处理能力和带宽有限的旧设备中尤为重要。服务器可以不受用户硬件限制地持续执行此任务。'
- en: Another benefit of SSR is to facilitate web crawlers to enable **Search Engine
    Optimization** (**SEO**) on your website.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SSR的另一个好处是便于网络爬虫，从而在你的网站上实现**搜索引擎优化**（**SEO**）。
- en: While the user is gawking at your landing page – since it is largely static
    at this point, they can only look, but not touch – Angular uses **web workers**
    to load the rest of the application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户正在凝视你的着陆页——由于此时它主要是静态的，他们只能看，不能触摸——Angular使用**web workers**来加载应用程序的其余部分。
- en: The most logical way to incorporate SSR into your project is at the very beginning,
    so you can tackle and test for configuration issues incrementally.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将SSR集成到项目中的最合理方式是在一开始就进行，这样你可以逐步解决和测试配置问题。
- en: 'To create a new project with SSR, execute:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的具有SSR的项目，请执行：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Woke up in a good mood? Try adding SSR to your existing project:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 早上醒来心情不错吗？尝试将SSR添加到你的现有项目中：
- en: '[PRE4]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After all the assets are loaded, and your SPA is ready to be fully interactive,
    the app must transition from a static state to a dynamic one. This transition
    can be jarring. As we learned when covering Qwik, hydration is essential to seamlessly
    transition from a static to a dynamic state.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有资产加载完毕，你的SPA准备好完全交互时，应用必须从静态状态过渡到动态状态。这种过渡可能会很突然。正如我们在介绍Qwik时学到的，水合对于无缝地从静态状态过渡到动态状态是至关重要的。
- en: If you’re using `FlexLayout`, use `FlexLayoutServerModule` to enable the framework
    in an SSR configuration. More details can be found at [https://github.com/angular/flex-layout/wiki/Using-SSR-with-Flex-Layout](https://github.com/angular/flex-layout/wiki/Using-SSR-with-Flex-Layout).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`FlexLayout`，请使用`FlexLayoutServerModule`在SSR配置中启用框架。更多详细信息可以在[https://github.com/angular/flex-layout/wiki/Using-SSR-with-Flex-Layout](https://github.com/angular/flex-layout/wiki/Using-SSR-with-Flex-Layout)找到。
- en: 'Enter stage left **client hydration**. You can enable client hydration by using
    its provider in your `AppComponent`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到**客户端水合**登场。你可以在`AppComponent`中使用其提供者来启用客户端水合：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With client hydration, your SPA can reuse already rendered server-side DOM structures,
    application state, downloaded data, and other processes for a smooth transition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端水合，你的SPA可以重用已经渲染的服务器端DOM结构、应用程序状态、下载的数据和其他过程，以实现平滑的过渡。
- en: You can read more about using Angular SSR at [https://angular.dev/guide/ssr](https://angular.dev/guide/ssr)
    and Angular hydration at [https://angular.dev/guide/hydration](https://angular.dev/guide/hydration).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://angular.dev/guide/ssr](https://angular.dev/guide/ssr)了解更多关于使用Angular
    SSR的信息，以及在[https://angular.dev/guide/hydration](https://angular.dev/guide/hydration)了解更多关于Angular水合的信息。
- en: App shell
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用外壳
- en: An app shell is like SSR conceptually, but instead of the server rendering your
    page, you can pre-render a route or a page at build time. This way, you can craft
    a static landing experience on the landing page or when lazy loading a large feature
    module and then have Angular transition to an interactive state when ready.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，应用外壳类似于SSR，但不是服务器渲染你的页面，你可以在构建时预先渲染一个路由或页面。这样，你可以在着陆页或懒加载大型功能模块时创建一个静态的着陆体验，然后当准备好时，Angular将过渡到交互状态。
- en: Pre-rendering is conceptually and mechanically easier to handle. However, you
    may have to simplify certain aspects of your landing pages for them to work with
    prerendering.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预渲染在概念上和机械上更容易处理。然而，你可能需要简化着陆页的某些方面，以便它们能够与预渲染一起工作。
- en: 'Are you about to miss your project delivery deadline but still need a solution
    for loading issues? Try adding an app shell:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否即将错过项目的交付截止日期，但仍需要解决加载问题的解决方案？尝试添加一个应用外壳：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the saying goes, try it, but your mileage may vary. Learn more about app
    shell at [https://angular.dev/ecosystem/service-workers/app-shell](https://angular.dev/guide/hydration).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如俗话所说，试试看，但效果可能因人而异。了解更多关于应用壳的信息，请访问[https://angular.dev/ecosystem/service-workers/app-shell](https://angular.dev/guide/hydration)。
- en: App shells are also useful in offline apps. Next, let’s see how service workers
    can help with performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用壳在离线应用中也很有用。接下来，让我们看看服务工作者如何帮助提高性能。
- en: Service workers
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务工作者
- en: You can also leverage service workers to make your web application feel like
    a native application. Service workers enable **Progressive Web Application** (**PWA**)
    features, like offline support, push notifications, and background data syncing
    for web applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用服务工作者让你的Web应用感觉像原生应用。服务工作者使**渐进式Web应用**（**PWA**）功能成为可能，如离线支持、推送通知和Web应用的背景数据同步。
- en: Running these tasks in a background thread frees up the main thread to perform
    tasks related to rendering and user interactivity. This is low-hanging fruit to
    improve the performance of your application. Read more about service workers at
    [https://angular.dev/ecosystem/service-workers](https://angular.dev/ecosystem/service-workers).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台线程中运行这些任务可以释放主线程来执行与渲染和用户交互相关的任务。这是提高你应用性能的显而易见的方法。更多关于服务工作者信息，请参阅[https://angular.dev/ecosystem/service-workers](https://angular.dev/ecosystem/service-workers)。
- en: 'You know you want to do it. Add PWA support today:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你想要这么做。今天添加PWA支持：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The technical reviewer of this book, Jurgen Van de Moere, also recommends Workbox
    by Google, a set of production-ready service worker libraries and tools regularly
    used in enterprises for complex scenarios.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的技术审稿人Jurgen Van de Moere还推荐了Google的Workbox，这是一套用于复杂场景的生产就绪服务工作者库和工具，在企业中经常使用。
- en: Read more about Workbox at [https://developer.chrome.com/docs/workbox](https://developer.chrome.com/docs/workbox).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于Workbox的信息，请访问[https://developer.chrome.com/docs/workbox](https://developer.chrome.com/docs/workbox)。
- en: Alas, it is finally time to peel to the core of the onion, change detection.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，终于到了剥洋葱核心的时候了，变更检测。
- en: RxAngular
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RxAngular
- en: Michael Hladky and co. created RxAngular to overcome performance issues with
    large Angular applications. RxAngular “offers a comprehensive toolset for handling
    fully reactive Angular applications, focusing mainly on runtime performance and
    template rendering.”
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Hladky及其团队创建了RxAngular以克服大型Angular应用中的性能问题。RxAngular“提供了一套全面的工具集，用于处理完全响应式的Angular应用，主要关注运行时性能和模板渲染。”
- en: 'The following diagram details the lifecycle of an Angular change detection
    event:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表详细说明了Angular变更检测事件的周期：
- en: '![](img/B18047_03_03.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18047_03_03.png)'
- en: 'Figure 3.3: Default change detection in Angular. Adapted from Michael Hladky'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：Angular中的默认变更检测。改编自Michael Hladky
- en: 'Allow me to go over it step by step:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我一步步地解释：
- en: First, user interaction triggers an event.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，用户交互触发一个事件。
- en: Angular then marks the element for a dirty check.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Angular将元素标记为需要进行脏检查。
- en: Zone.js is utilized to transition between the Angular app state and DOM.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Zone.js用于在Angular应用状态和DOM之间进行转换。
- en: The Angular engine “ticks,” triggering the execution of pending tasks.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular引擎“滴答”作响，触发挂起任务的执行。
- en: The change detection algorithm avoids branches that are not dirty.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变更检测算法避免了不脏的分支。
- en: The algorithm identifies the topmost level component that must be re-rendered
    to react to the event triggered in *step 1*.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法识别必须重新渲染以响应在*步骤1*中触发的事件的最高级别组件。
- en: Angular’s default change detection process is a computationally expensive process
    that can force the re-rendering of larger-than-necessary portions of the application.
    Angular also offers an `OnPush` change detection strategy.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的默认变更检测过程是一个计算成本高昂的过程，可能会强制重新渲染应用中比必要更大的部分。Angular还提供了一个`OnPush`变更检测策略。
- en: '![A diagram of a diagram  Description automatically generated](img/B18047_03_04.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![一个图表的图表  自动生成的描述](img/B18047_03_04.png)'
- en: 'Figure 3.4: OnPush change detection in Angular. Adapted from Michael Hladky'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：Angular中的OnPush变更检测。改编自Michael Hladky
- en: '`OnPush` disables automatic change detection until manually reactivated. We
    can use this strategy only to activate component sub-trees that the user interacts
    with, limiting the amount and scope of change detection Angular must perform.
    You can read more about this at [https://angular.dev/best-practices/skipping-subtrees](https://angular.dev/best-practices/skipping-subtrees).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPush` 禁用自动变更检测，直到手动重新激活。我们只能使用此策略来激活用户交互的组件子树，限制 Angular 必须执行变更检测的数量和范围。你可以在
    [https://angular.dev/best-practices/skipping-subtrees](https://angular.dev/best-practices/skipping-subtrees)
    上了解更多信息。'
- en: Finally, using RxAngular’s directives and pipes, like `RxLet`, `RxFor`, and
    `RxIf`, we can trick the Angular engine to only detect changes when observables
    tied to these directives change.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 RxAngular 的指令和管道，如 `RxLet`、`RxFor` 和 `RxIf`，我们可以欺骗 Angular 引擎，只有在与这些指令关联的可观察对象发生变化时才检测变更。
- en: '![A diagram of a diagram  Description automatically generated](img/B18047_03_05.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![一个图表的图表  自动生成的描述](img/B18047_03_05.png)'
- en: 'Figure 3.5: Change detection using RxAngular’s directives. Adapted from Michael
    Hladky'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：使用 RxAngular 指令进行变更检测。改编自 Michael Hladky
- en: As shown in the figure above, we can ensure only the element that needs to change
    is updated without going through an expensive change detection process. If you
    already have a large Angular application where a rewrite is not an option, RxAngular
    may be your only option to resolve performance issues.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，我们可以确保只更新需要更改的元素，而无需经过昂贵的变更检测过程。如果你已经有一个大型 Angular 应用程序，重写不是一个选择，RxAngular
    可能是你解决性能问题的唯一选择。
- en: 'Dive deeper into Angular performance at scale with Michael’s talk at Angular
    DC: [https://www.youtube.com/watch?v=HTU4WYWGTIk](https://www.youtube.com/watch?v=HTU4WYWGTIk).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular DC 上，Michael 的演讲深入探讨了 Angular 的性能：[https://www.youtube.com/watch?v=HTU4WYWGTIk](https://www.youtube.com/watch?v=HTU4WYWGTIk)。
- en: Learn more about RxAngular at [https://www.rx-angular.io](https://www.rx-angular.io).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://www.rx-angular.io](https://www.rx-angular.io) 上了解更多关于 RxAngular 的信息。
- en: Angular Signals
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular 信号
- en: Angular Signals can deliver the same kind of fine-grained change detection as
    shown in *Figure 3.5* in the *RxAngular* section. As you can imagine, this can
    potentially solve Angular’s most egregious performance and scaling issues. However,
    as of Angular 17, signals are still in partial preview, and signal-based components
    are expected to be delivered and become stable around Angular 19\. When this happens,
    we’ll still need to rewrite significant portions of our applications to take advantage
    of the performance benefits.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 信号可以提供与 *图 3.5* 中在 *RxAngular* 部分所示相同的细粒度变更检测。正如你可以想象的那样，这有可能解决 Angular
    最严重的性能和扩展问题。然而，截至 Angular 17，信号仍然处于部分预览状态，基于信号的组件预计将在 Angular 19 左右交付并变得稳定。当这种情况发生时，我们仍然需要重写我们应用程序的很大一部分以利用性能优势。
- en: A pure signals-based application won’t require heavy RxJS use to enable reactivity.
    I predict its use will be rare, as most service and API calls can be converted
    into async/await-enabled promise-based calls. This would be revolutionary in making
    Angular very easy to learn.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 基于纯信号的应用程序不需要使用重 RxJS 来启用响应性。我预测其使用将很少，因为大多数服务和 API 调用都可以转换为启用 async/await 的基于
    promise 的调用。这将使 Angular 非常容易学习。
- en: In the *Rewriting Angular Apps with NgRx/SignalStore* section of *Chapter 9*,
    *Recipes – Master/Detail, Data Tables, and NgRx*, I demonstrate how far you can
    go with signals with Angular 17.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 9 章* 的 *使用 NgRx/SignalStore 重写 Angular 应用程序* 部分，*配方 – 主/详细，数据表和 NgRx*，我展示了使用
    Angular 17 可以用信号走多远。
- en: Next, let’s talk about build issues that large applications can create.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈大型应用程序可能产生的构建问题。
- en: Build performance
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建性能
- en: Like runtime performance issues, the codebase size can play a major role in
    the quality of DevEx. When more code is present in a project, building the code
    and running tests on it becomes slower. This lengthens the developer feedback
    cycle. A slow feedback cycle results in a slow development process with more bugs
    and fewer quality features delivered.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行时性能问题一样，代码库的大小可以在 DevEx 的质量中发挥重要作用。当项目中有更多代码时，构建代码和运行测试会变慢。这延长了开发者的反馈周期。缓慢的反馈周期会导致开发过程缓慢，错误更多，交付的质量特性更少。
- en: While minimalist solutions like ArrowJS or Qwik.js handle this by requiring
    none to minimalist state-of-the-art tooling, existing SPA frameworks can’t do
    this easily, given a large install base and complicated requirements. But this
    doesn’t mean there aren’t great solutions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像ArrowJS或Qwik.js这样的极简解决方案通过要求使用最先进的工具来处理这个问题，但考虑到现有的SPA框架有一个庞大的安装基础和复杂的需求，它们并不能轻易做到这一点。但这并不意味着没有优秀的解决方案。
- en: The tools described in the following sections can speed up your development
    process and improve DevEx.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下文所述的工具可以加快你的开发过程并提高DevEx。
- en: Nx
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nx
- en: '**Nx** is a next-generation build system with first-class monorepo support
    and powerful integrations. Nx allows you to break up your application code into
    libraries and utilize build caching only to re-build portions of the app that
    need it. So, a small change doesn’t have to trigger a full build, but instead
    a short 30-second build and only re-running tests that are impacted. The great
    thing about this is that the cache can be shared remotely across servers and dev
    machines.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nx**是一个下一代构建系统，具有一流的monorepo支持和强大的集成。Nx允许你将应用程序代码分解成库，并仅对需要重新构建的应用程序部分使用构建缓存。因此，小的更改不需要触发完整的构建，而是进行一个短暂的30秒构建，并且只重新运行受影响的测试。这一点的好处是缓存可以在远程服务器和开发机器之间共享。'
- en: Nx also offers an opinionated architecture, which is welcome for very large
    teams and enterprises. Nx also automates dependency updates, a critical and time-consuming
    maintenance task for all modern web projects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Nx还提供了一种有见地的架构，这对于非常大的团队和企业来说是非常受欢迎的。Nx还自动更新依赖项，这对于所有现代Web项目来说是一个关键且耗时的工作。
- en: 'You can create a new Nx application by running:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令创建一个新的Nx应用程序：
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or you can migrate your existing apps to Nx by running:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过运行以下命令将现有的应用程序迁移到Nx：
- en: '[PRE9]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can learn more about Nx at [https://nx.dev/](https://nx.dev/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://nx.dev/](https://nx.dev/)上了解更多关于Nx的信息。
- en: esbuild
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: esbuild
- en: '**esbuild** is an extremely fast bundler for the web. It runs 40x faster than
    webpack 5, which Angular currently relies on to pack up the SPA, contributing
    significantly to slow build times.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**esbuild**是一个针对Web的极快打包器。它的运行速度比webpack 5快40倍，而Angular目前依赖于它来打包SPA，这极大地影响了构建时间。'
- en: As of Angular 17, the esbuild-based **ES Module** (**ESM**) build system is
    the default builder. You can read more about it at [https://angular.dev/tools/cli/esbuild](https://angular.dev/tools/cli/esbuild).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Angular 17，基于esbuild的**ES模块（ESM）**构建系统是默认的构建器。你可以在[https://angular.dev/tools/cli/esbuild](https://angular.dev/tools/cli/esbuild)上了解更多。
- en: The webpack-based legacy build system is still considered stable and fully supported.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 基于webpack的遗留构建系统仍然被认为是稳定且完全受支持的。
- en: To migrate to the new build system, follow the instructions at [https://angular.dev/tools/cli/esbuild#using-the-browser-esbuild-builder](https://angular.dev/tools/cli/esbuild#using-the-browser-esbuild-builder).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要迁移到新的构建系统，请遵循[https://angular.dev/tools/cli/esbuild#using-the-browser-esbuild-builder](https://angular.dev/tools/cli/esbuild#using-the-browser-esbuild-builder)中的说明。
- en: The new esbuild-based build system also enables next-generation frontend tooling
    with Vite. Learn more about Vite at [https://vitejs.dev/](https://vitejs.dev/).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 新的基于esbuild的构建系统还使下一代前端工具Vite成为可能。更多关于Vite的信息可以在[https://vitejs.dev/](https://vitejs.dev/)上找到。
- en: You can learn more about esbuild at [https://esbuild.github.io/](https://esbuild.github.io/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://esbuild.github.io/](https://esbuild.github.io/)上了解更多关于esbuild的信息。
- en: Test automation
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自动化
- en: The Karma and Jasmine tools are showing their age. Karma was never built with
    headless unit tests in mind. The original **end-to-end (e2e)** testing tool for
    Angular, Protractor, has already been deprecated and replaced by Cypress. This
    is covered in depth in *Chapter 4*, *Creating a Router-First Line-of-Business
    App*. Cypress is great to work with and a great replacement for Protractor.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Karma和Jasmine工具正显示出它们的年代感。Karma从未考虑过无头单元测试。Angular的原始**端到端（e2e）**测试工具Protractor已经被弃用并替换为Cypress。这在*第4章*，*创建以路由为首要业务应用*中有详细说明。Cypress易于使用，是Protractor的绝佳替代品。
- en: 'Let’s go over a few alternatives to Karma and Jasmine for faster unit testing:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看几个Karma和Jasmine的替代方案，以实现更快的单元测试：
- en: Jest, [https://jestjs.io](https://jestjs.io), is a near drop-in replacement
    for Jasmine with a built-in test runner. I’ve had a great experience leveraging
    Jest with my CLI tools; however, Jest was never built with supporting ES modules.
    This results in significant compatibility issues when using CommonJS modules and
    ES modules together, which is often the case in any existing application. The
    issues were so opaque and significant I had to abandon an effort to upgrade the
    sample code for the book to Jest.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest（[https://jestjs.io](https://jestjs.io)）是一个几乎可以无缝替换Jasmine的内置测试运行器。我在利用Jest与我的CLI工具方面有很好的体验；然而，Jest从未被构建为支持ES模块。这导致在使用CommonJS模块和ES模块时出现重大兼容性问题，这在任何现有应用程序中通常是情况。问题如此模糊且严重，以至于我不得不放弃升级书中示例代码到Jest的努力。
- en: As of the time of publication, Angular supports Jest in preview. However, I
    don’t recommend that you use it.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 截至出版时，Angular支持预览中的Jest。然而，我不建议你使用它。
- en: Vitest, [https://vitest.dev/](https://vitest.dev/), powered by Vite, is a blazing-fast
    unit test framework and represents an acceptable future state. However, to seamlessly
    leverage Vitest, you should also use the esbuild-based build configuration that
    also comes with Vite.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Vite驱动的Vitest（[https://vitest.dev/](https://vitest.dev/)）是一个闪电般的单元测试框架，代表了可接受的未来状态。然而，为了无缝利用Vitest，你还应该使用Vite附带基于esbuild的构建配置。
- en: Cypress, [https://www.cypress.io/](https://www.cypress.io/), is generally known
    for its e2e testing capabilities. However, you can also write component tests
    with Cypress. Once you configure Cypress for an Angular project, any time you
    generate a new component, a new Cypress component test file will also be added.
    Cypress’s black-box approach to component testing makes it easier to write new
    tests, but they can’t be referred to as unit tests.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress（[https://www.cypress.io/](https://www.cypress.io/)）通常以其端到端测试能力而闻名。然而，你也可以使用Cypress编写组件测试。一旦你为Angular项目配置了Cypress，每次你生成一个新组件时，也会添加一个新的Cypress组件测试文件。Cypress对组件测试的黑盒方法使得编写新测试变得更容易，但它们不能被称为单元测试。
- en: Once (and if) all the half-dozen or more in-preview pieces of tech graduate
    to Angular production status, the heavy-hitting SPA framework will be ready for
    the future. In the meantime, don’t discount alternatives like Qwik.js for extremely
    performance-sensitive applications.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦（如果）所有这些预览中的六分之一或更多的技术毕业到Angular生产状态，这个强大的SPA框架将准备好迎接未来。与此同时，不要低估像Qwik.js这样的替代方案，对于极端性能敏感的应用程序来说。
- en: Now that you know where the monsters are hiding, you’re ready to tackle the
    execution of your project. But wait, don’t start coding just yet. Having a plan
    in place is indispensable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道怪物藏在哪里了，你准备好着手执行你的项目了。但是等等，不要急于开始编码。有一个计划在位是必不可少的。
- en: Planning using Kanban and GitHub projects
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用看板和GitHub项目进行规划
- en: Having a roadmap before getting on the road is critical in reaching your destination.
    Similarly, building a rough plan of action before you start coding is crucial
    in ensuring project success. Building a plan early on enables your colleagues
    or clients to be aware of what you’re planning to accomplish. However, any initial
    plan is guaranteed to change over time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上路之前有一个路线图对于到达目的地至关重要。同样，在开始编码之前制定一个粗略的行动计划对于确保项目成功至关重要。尽早制定计划可以让你的同事或客户了解你打算完成什么。然而，任何初始计划都注定会随着时间的推移而改变。
- en: Agile software development aims to account for changing priorities and features
    over time. Kanban and Scrum are the two most popular methodologies that you can
    use to manage your project. Each methodology has a concept of a backlog and lists
    that capture planned, in progress, and completed work. A backlog, which contains
    a prioritized list of tasks, establishes a shared understanding of what needs
    to be worked on next. Lists that capture the status of each task act as information
    radiators, where stakeholders can get updates without interrupting your workflow.
    Whether you’re building an app for yourself or someone else, keeping a live backlog
    and tracking the progress of tasks pays dividends and keeps the focus on the goal
    you’re trying to achieve.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发旨在随着时间的推移适应不断变化的需求和功能。看板（Kanban）和Scrum是两种最受欢迎的项目管理方法，你可以使用它们来管理你的项目。每种方法都有一个待办事项的概念，以及列出计划、进行中和已完成的工作。包含优先级任务列表的待办事项，确立了关于接下来需要做什么的共享理解。列出每个任务状态的列表充当信息发射器，利益相关者可以在不打扰你工作流程的情况下获取更新。无论你是为自己还是为他人开发应用程序，保持一个活跃的待办事项并跟踪任务进度都能带来回报，并保持对你要实现的目标的关注。
- en: You can leverage a GitHub project to act as a Kanban board. In an enterprise,
    you can use ticketing systems or tools to keep a backlog, implement the Scrum
    methodology, and display Kanban boards. In GitHub, issues represent your backlog.
    You can leverage the built-in **Projects** tab to define a scope of work representing
    a release or a sprint to establish a Kanban board. A GitHub project directly integrates
    with your GitHub repository’s issues and keeps track of the status of issues via
    labels. This way, you can keep using the tool of your choice to interact with
    your repository and still effortlessly radiate information.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用GitHub项目作为看板。在企业中，你可以使用票务系统或工具来维护待办事项列表，实施Scrum方法，并显示看板。在GitHub中，问题代表你的待办事项。你可以利用内置的**项目**标签来定义代表发布或迭代的任务范围，以建立看板。GitHub项目直接集成到你的GitHub仓库的问题中，并通过标签跟踪问题的状态。这样，你就可以继续使用你选择的工具与你的仓库交互，同时轻松地发射信息。
- en: An **information radiator** is a dynamic tool used in agile project management
    and software development to display critical project information in a highly visible
    area. Designed to promote transparency and facilitate passive communication, it
    ensures that team members are continuously and effortlessly informed about key
    aspects of the project, such as progress, goals, deadlines, and potential issues.
    Typically placed in a common workspace, an information radiator might take the
    form of a large whiteboard or digital display, showing easy-to-understand visuals
    like charts, graphs, or Kanban boards. Its primary function is to keep the information
    current and relevant, providing a real-time snapshot of the project’s status.
    By doing so, it enhances collaboration, helps in identifying bottlenecks quickly,
    and allows for prompt decision-making. The information radiator, therefore, serves
    as both a focal point for team interaction and a catalyst for a more engaged and
    informed team dynamic.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息发射器**是一种在敏捷项目管理与软件开发中使用的动态工具，用于在高度可见的区域展示关键项目信息。它旨在促进透明度和便利的被动沟通，确保团队成员能够持续且轻松地了解项目的关键方面，如进度、目标、截止日期和潜在问题。通常放置在公共工作区，信息发射器可能以大型白板或数字显示屏的形式出现，展示易于理解的图表、图形或看板。其主要功能是保持信息的时效性和相关性，提供项目状态的实时快照。通过这样做，它增强了协作，有助于快速识别瓶颈，并允许及时做出决策。因此，信息发射器既是团队互动的焦点，也是促进更投入、更了解团队动态的催化剂。'
- en: In the next section, you will set up a project to achieve this goal.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将设置一个项目以实现这一目标。
- en: Setting up a GitHub project
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置GitHub项目
- en: 'Let’s set up a GitHub project:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个GitHub项目：
- en: Navigate to your GitHub repository in your browser.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到你的GitHub仓库。
- en: Switch over to the **Projects** tab.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**项目**标签。
- en: Select **New project**.![A screenshot of a computer  Description automatically
    generated](img/B18047_03_06.png)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新建项目**。![计算机屏幕截图  自动生成的描述](img/B18047_03_06.png)
- en: 'Figure 3.6: Creating a new project in GitHub'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.6：在GitHub中创建新项目
- en: Provide a name in the **Project name** box.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目名称**框中提供名称。
- en: Select the project template named **Team backlog**.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择名为**团队待办事项**的项目模板。
- en: Click on **Create**.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**。
- en: 'We just created a Kanban board, a lightweight methodology to organize your
    work you might choose over other methodologies like Scrum. Observe your Kanban
    board, which should appear as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个看板，这是一种轻量级的工作组织方法，你可能选择它而不是其他如Scrum的方法。观察你的看板，它应该如下所示：
- en: '![A screenshot of a computer  Description automatically generated](img/B18047_03_07.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B18047_03_07.png)'
- en: 'Figure 3.7: The Kanban board for your project'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：你的项目看板
- en: 'The default configuration of the board includes the following columns:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 画板默认配置包括以下列：
- en: '**New**: Should be used for adding new issues'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新建**：用于添加新问题'
- en: '**Backlog**: A prioritized list of tasks to work on'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待办事项**：要工作的优先级任务列表'
- en: '**Ready**: Tasks that meet the definition of ready and can be immediately worked
    on'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**就绪**：符合就绪定义且可以立即工作的任务'
- en: '**In progress**: Tasks that are in progress; using the triple-dot menu, you
    can set an item limit, enforcing a **Work-in-Progress** (**WIP**) limit'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行中**：正在进行的任务；使用三点菜单，你可以设置项目数量限制，强制执行**工作在进度中**（**WIP**）限制'
- en: '**In review**: Work that’s under code review, QA testing, and **Product Owner**
    (**PO**) approval'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待审阅**：处于代码审查、质量测试和**产品负责人**（**PO**）批准中的工作'
- en: '**Done**: Work that meets the definition of done'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成**：符合完成定义的工作'
- en: 'The Definition of Ready defines *“criteria to know when a Backlog item is refined
    enough to start working on it”* and the Definition of Done defines *“criteria
    to know when a Backlog item is completed.”* It is critical to define these criteria
    as part of team norms. To learn more about running successful Kanban projects,
    check out this article by my colleague Nicole Spence-Goon: [https://www.excella.com/insights/successful-agile-project-with-transient-teams](https://www.excella.com/insights/successful-agile-project-with-transient-teams).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**就绪定义**定义了“知道何时将待办事项项细化到足以开始工作的标准”和**完成定义**定义了“知道何时将待办事项项完成的标准”。定义这些标准作为团队规范的一部分是至关重要的。要了解更多关于成功运行看板项目的信息，请查看我的同事Nicole
    Spence-Goon的文章：[https://www.excella.com/insights/successful-agile-project-with-transient-teams](https://www.excella.com/insights/successful-agile-project-with-transient-teams)。'
- en: If you have existing GitHub issues or pull requests in your repository, you
    can add them to your project individually or in bulk using the **+ Add item**
    button. You can also combine issues from different repositories.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在您的存储库中已有GitHub问题或拉取请求，您可以使用**+ 添加项目**按钮单独或批量将它们添加到您的项目中。您还可以将来自不同存储库的问题组合在一起。
- en: Customizing the Kanban board
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义看板板
- en: Your board is configured as a Kanban board with all the necessary columns out
    of the box. By default, issues created and **Pull Requests** (**PRs**) opened
    in your project will be automatically added to the board.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您的板默认配置为看板板，带有所有必要的列。默认情况下，在您的项目中创建的问题和打开的**拉取请求**（**PR**）将自动添加到板上。
- en: 'You can do this by opening the **Workflows** screen from the triple-dot menu
    marked as **1** in the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开以下截图中的三明治菜单标记为**1**的**工作流程**屏幕来完成此操作：
- en: '![A screenshot of a computer  Description automatically generated](img/B18047_03_08.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B18047_03_08.png)'
- en: 'Figure 3.8: Kanban board workflows'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：看板板工作流程
- en: Number **2** shows a list of the default workflows listed. You can select one
    and use the **Edit** button, marked with **3**, to change the automated behavior.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**2**号显示了默认工作流程列表。您可以选择一个，并使用标记为**3**的**编辑**按钮来更改自动行为。'
- en: GitHub projects also have a concept of milestones. You can create milestones
    and assign them to issues or PRs to set up a sprint or a release and track percentage
    completion or other stats via the **Insights** screen, accessed next to the triple-dot
    menu, marked with number **1**.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub项目还有一个里程碑的概念。您可以为问题或PR创建里程碑，并设置冲刺或发布，通过三明治菜单旁边的**洞察**屏幕跟踪完成百分比或其他统计数据，该屏幕标记为数字**1**。
- en: 'You may also add a roadmap using the on **+ New View** button to get a different
    view. The most powerful feature of GitHub projects is the integration with developer
    workflows. See the following PR:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过点击**+ 新视图**按钮添加路线图以获得不同的视图。GitHub项目的最强大功能是与其开发者工作流程的集成。请参阅以下PR：
- en: '![A screenshot of a computer  Description automatically generated](img/B18047_03_09.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B18047_03_09.png)'
- en: 'Figure 3.9: Pull request with project integration'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：与项目集成的拉取请求
- en: Number **1** shows that the PR is in the **In progress** column of the **LemonMart**
    project. Developers get glanceable information and the ability to manipulate project
    files within the PR. At number **2**, we can see the PR is assigned to the **3rd
    Edition** milestone, where we can see a progress bar showing percentage completion.
    And finally, number **3** shows one or more issues that this PR can resolve.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**号显示PR位于**LemonMart**项目的**进行中**列。开发者可以获取可快速查看的信息，并在PR内操作项目文件。在**2**号中，我们可以看到PR被分配给**第3版**里程碑，其中我们可以看到一个显示完成百分比的进度条。最后，**3**号显示了PR可以解决的一个或多个问题。'
- en: Creating a prioritized backlog for your app
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的应用创建优先级待办事项
- en: Get together with your team and create a backlog of issues to keep track of
    your progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与您的团队一起，创建一个待办事项列表来跟踪您实现应用程序设计时的进度。在创建问题时，您应该专注于交付具有用户价值的功能性迭代。
- en: Refrain from creating purely technical tasks. The technical hurdles you must
    clear to achieve those results are of no interest to your users or clients. Bug
    tickets are okay because they impact your users. However, technical tasks become
    part of the functional problem you’re trying to solve, so address them within
    that context. This way, you’ll always be ready to translate the work being done
    into value being delivered when approached by business leaders at your organization.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 避免创建纯粹的技术任务。您必须克服以实现这些结果的技术障碍对您的用户或客户没有兴趣。错误报告是可以的，因为它们会影响您的用户。然而，技术任务成为您试图解决的函数问题的一部分，因此请在此背景下解决它们。这样，当您的组织中的业务领导向您提出要求时，您总能准备好将正在进行的工作转化为交付的价值。
- en: As you add items to the backlog, be sure to prioritize them. The first items
    to be worked on go to the top and descend in order of importance. New items go
    into the **New** column and are only added to the backlog in a grooming session
    so their necessity and priority can be properly assessed. With a prioritized backlog,
    you have your roadmap in hand, and your team is ready to start work.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将项目添加到待办事项列表时，请确保对其进行优先排序。首先要工作的项目将排在最上面，并按重要性顺序下降。新项目进入**新**列，并且仅在梳理会议中添加到待办事项列表，以便对其必要性和优先级进行适当的评估。有了优先排序的待办事项列表，您就掌握了路线图，您的团队也准备好开始工作了。
- en: Ultimately, GitHub projects provide an easy-to-use GUI so that non-technical
    people can easily interact with GitHub issues. By allowing non-technical people
    to participate in the development process on GitHub, you unlock the benefits of
    GitHub becoming the single source of information for your entire project. Questions,
    answers, and discussions about features and issues are tracked as part of GitHub
    issues instead of being lost in emails. You can also store wiki-type documentation
    on GitHub. So, by centralizing all project-related information, data, conversations,
    and artifacts on GitHub, you are greatly simplifying the potentially complicated
    interaction of multiple systems that require continued maintenance at a high cost.
    GitHub has a very reasonable cost for private repositories and on-premises enterprise
    installations. If you’re sticking with open source, as we are in this chapter,
    all these tools are free.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，GitHub项目提供了一个易于使用的图形用户界面，以便非技术人员可以轻松地与GitHub问题进行交互。通过允许非技术人员参与GitHub上的开发过程，您可以解锁GitHub成为您整个项目单一信息源的好处。关于功能和问题的疑问、答案和讨论都被跟踪为GitHub问题的一部分，而不是在电子邮件中丢失。您还可以在GitHub上存储类似维基的文档。因此，通过在GitHub上集中所有项目相关的信息、数据、对话和工件，您可以极大地简化需要持续维护且成本高昂的多个系统之间的复杂交互。GitHub为私有仓库和本地企业安装提供了非常合理的费用。如果您坚持开源，就像我们在本章中所做的那样，所有这些工具都是免费的。
- en: With a roadmap in place, let’s investigate the philosophy of how to prioritize
    work and execute the design and architecture of our apps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在制定路线图后，让我们探讨如何优先处理工作和执行我们应用的设计和架构的哲学。
- en: The 80-20 solution
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 80-20解决方案
- en: 'Whether we develop apps at home, for passion projects, or at the office, for
    work, we must remain mindful of our purpose: to deliver value. If we don’t deliver
    value with our passion projects, we won’t feel fulfilled or happy. If we fail
    to deliver value at work, we may not get paid.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在家中开发应用、出于激情的项目，还是在办公室为工作开发应用，我们都必须牢记我们的目的：提供价值。如果我们不能通过我们的激情项目提供价值，我们不会感到满足或快乐。如果我们无法在工作场所提供价值，我们可能得不到报酬。
- en: 'Delivering a modern web application is difficult. There are numerous challenges
    that we need to overcome to be successful:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 提供现代网络应用是困难的。我们需要克服许多挑战才能取得成功：
- en: Deliver iteratively and incrementally
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代和增量交付
- en: Be scalable
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可扩展性
- en: Serve dozens of screens and input types
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务数十个屏幕和输入类型
- en: Be usable
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Be accessible
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问性
- en: Manage a team
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理团队
- en: Groom a prioritized backlog
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梳理优先排序的待办事项列表
- en: Ensure acceptance criteria are clear, concise, and concrete
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保验收标准清晰、简洁、具体
- en: If you’ve ever led a project or tried to implement and deliver a project on
    your own, you’ll have realized that there’s never enough time and resources to
    cover the wide variety of stakeholder, team, and technical needs on any given
    project. Remember that the Pareto principle, also known as the 80-20 rule, implies
    that we can accomplish 80% of our goals with 20% of the overall effort.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经领导过一个项目或尝试过独立实施和交付一个项目，您会意识到在任何特定项目中，时间和资源永远都不够用来覆盖广泛的利益相关者、团队和技术需求。记住帕累托原则，也称为80-20法则，意味着我们可以用总体努力的20%完成80%的目标。
- en: If we apply the 80-20 rule to our work, we can maximize our output, quality,
    and happiness. Line-of-business applications are the bread and butter of our industry.
    Applying the 80-20 rule, we can surmise that most of us will earn most of our
    income by delivering such applications. Therefore, we should keep our engineering
    overhead to a minimum and reduce the delivery risk of our project. By limiting
    experimentation in production code, we create a predictable environment for our
    team members and only introduce changes that we had a chance to vet in proof-of-concept
    or small apps.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将80-20法则应用于我们的工作，我们可以最大化我们的产出、质量和幸福感。业务线应用是我们行业的基石。应用80-20法则，我们可以推断出我们中的大多数人将通过提供此类应用来赚取大部分收入。因此，我们应该将我们的工程开销保持在最低，并减少我们项目的交付风险。通过限制生产代码中的实验，我们为团队成员创造了一个可预测的环境，并且只引入我们在概念验证或小型应用中已有机会审查过的变化。
- en: Our 80-20 strategy, combined with discipline, can help us deliver the same project
    at the same time with more features and better quality. By treating your career
    as a marathon and not a series of sprints, you can find yourself in a position
    to deliver high-quality solutions, project after project, without feeling burned
    out.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的80-20策略，结合纪律，可以帮助我们在同一时间以更多功能和更好的质量交付相同的项目。将你的职业生涯视为一场马拉松而不是一系列冲刺，你可以发现自己处于能够项目接项目地交付高质量解决方案的位置，而不会感到疲惫不堪。
- en: Understanding line-of-business apps
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解业务线应用
- en: 'According to Wikipedia, line-of-business applications are a *“set of critical
    computer applications perceived as vital to running an enterprise.”* LOB apps
    are what most developers end up developing, even though we may think we develop
    small apps or large enterprise apps. Consider the following illustration, which
    demonstrates the kinds of apps we might develop, placed on an axis relative to
    their size and scope:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，业务线应用是一套*“被认为对企业运营至关重要的关键计算机应用。”* 业务线应用是大多数开发者最终会开发的应用，即使我们可能认为我们开发的是小型应用或大型企业应用。考虑以下插图，它展示了我们可能开发的应用类型，并放置在一个相对于其大小和范围的轴上：
- en: '![](img/B18047_03_10.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18047_03_10.png)'
- en: 'Figure 3.10: Relative size and scope of four kinds of apps'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：四种类型应用的大小和范围
- en: 'From my perspective, we think about four kinds of apps when we begin developing
    software:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，当我们开始开发软件时，我们会考虑四种类型的应用：
- en: Small apps
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型应用
- en: LOB apps
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务线应用
- en: Large enterprise apps
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型企业应用
- en: Billion-user-scale apps
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亿级用户规模的应用
- en: Billion-user-scale apps are completely niche implementations that rarely have
    needs that align with most apps out there. For this reason, we must classify these
    apps as outliers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 亿级用户规模的应用是完全的利基实现，很少需要与大多数现有应用相匹配的需求。因此，我们必须将这些应用归类为异常值。
- en: Small apps start small. Architecturally, they’re likely to be initially under-engineered.
    As you add features and team members to work on a small app, at some point, you’re
    going to run into trouble. As your team size and feature set grow, or the overall
    complexity of the app increases, the architectural needs of the application grow
    exponentially.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 小型应用从小开始。在架构上，它们很可能是最初设计不足的。随着你向小型应用添加功能和团队成员，在某个时候，你将遇到麻烦。随着你的团队规模和功能集的增长，或者应用的整体复杂性增加，应用的架构需求呈指数增长。
- en: 'Once you cross the inflection point of the complexity your architecture can
    bear, you’re left with a costly reengineering effort to get back on track. See
    the following graph illustrating this idea:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你超过了你的架构可以承受的复杂性拐点，你将面临代价高昂的重构努力以回到正轨。请看以下图表说明这一概念：
- en: '![](img/B18047_03_11.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18047_03_11.png)'
- en: 'Figure 3.11: Architectural journey of a small app'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：小型应用的架构之旅
- en: 'The area under the feature line represents under-engineering, which introduces
    risk to your project. The area above the feature line shows the required engineering
    overhead to support the features needed. In comparison, large enterprise apps
    start with a massive over-engineering effort, as shown in the following diagram:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 特性线以下的区域代表设计不足，这会给你的项目带来风险。特性线以上的区域显示了支持所需功能所需的工程开销。相比之下，大型企业应用从大规模的过度设计努力开始，如下面的图所示：
- en: '![](img/B18047_03_12.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18047_03_12.png)'
- en: 'Figure 3.12: Architectural journey of a large enterprise app'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：大型企业应用的架构之旅
- en: As time goes on and the system’s overall complexity increases, large enterprise
    apps can also face a similar inflection point, where the original architecture
    can become inadequate. With careful planning and management, you can avoid trouble
    and protect the significant initial investment made. Such large enterprise apps
    require hundreds of developers, with multiple levels of managers and architects,
    to execute successfully. Like billion-user-scale apps, these apps can also have
    niche architectural needs. In between the small apps and the large enterprise
    apps that we develop lie LOB apps.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移和系统整体复杂性的增加，大型企业应用也可能面临类似的拐点，原始架构可能变得不足。通过谨慎规划和管理工作，你可以避免麻烦并保护所做的重要初始投资。这样的大型企业应用需要数百名开发者，多个级别的经理和架构师才能成功执行。像亿级用户规模的应用一样，这些应用也可能有特定的架构需求。在我们开发的小型应用和大型企业应用之间，存在着LOB应用。
- en: '![](img/B18047_03_13.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18047_03_13.png)'
- en: 'Figure 3.13: Dynamic nature of software evolution'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：软件演化的动态性质
- en: As shown in the preceding diagram, small apps can grow and morph into LOB apps,
    and large enterprise apps can become under-utilized as users ignore the features
    they never need but keep the app to serve a singular purpose as a LOB app. In
    either case, despite our best efforts, we ultimately deliver an inefficient solution
    for the problem we’re solving. None of us have a crystal ball to see the future,
    and planning and engineering can only do so much for us in an unpredictable business
    setting; we need to rely on the 80-20 rule to come up with an architecture that
    is flexible to change, but adequate to meet most business requirements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，小型应用可以成长并转变为LOB应用，而大型企业应用由于用户忽略了他们从未需要的功能，却保留应用以单一目的作为LOB应用，可能会变得利用率低下。在任何情况下，尽管我们尽了最大努力，但我们最终为解决我们正在解决的问题提供了一个低效的解决方案。我们都没有水晶球来预见未来，在不可预测的商业环境中，规划和工程只能为我们做这么多；我们需要依靠80-20法则来制定一个灵活变通、但足以满足大多数商业需求的架构。
- en: Router-first architecture, covered in a later section, aims to maintain optimal
    architectural overhead so that costly re-engineering or late-stage crunch can
    be avoided in the rush to deliver all required features. Let’s see how.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中介绍的“路由优先架构”旨在保持最佳架构开销，以避免在交付所有必需功能时的昂贵重工程或后期冲刺。让我们看看如何做到这一点。
- en: 'I coined the term router-first architecture in 2018 with the first edition
    of this book. Since then, I’ve spoken about it at a dozen conferences and executed
    it on multi-million dollar projects successfully. Here’s my first presentation
    at the Angular DC meetup in June 2018: [https://www.youtube.com/watch?v=XKuFNiV-TWg](https://www.youtube.com/watch?v=XKuFNiV-TWg).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2018年这本书的第一版中提出了“路由优先架构”这个术语。从那时起，我在十几个会议上讨论过它，并在数百万美元的项目中成功实施了它。以下是我在2018年6月Angular
    DC聚会上的第一次演讲：[https://www.youtube.com/watch?v=XKuFNiV-TWg](https://www.youtube.com/watch?v=XKuFNiV-TWg)。
- en: Disciplined and balanced approach
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严谨和平衡的方法
- en: We covered the *what* of software development, but we must also consider the
    *why*, *when*, *where*, and *who* before we can get to the *how*. We usually under-engineer
    our projects when we develop apps for learning or passion projects. If your passion
    project somehow becomes an overnight success, it becomes costly to maintain or
    keep adding features to your app. In this case, you will have to bear the ongoing
    maintenance cost or face a rewrite of your application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了软件开发中的“什么”，但在我们能够到达“如何”之前，我们必须考虑“为什么”、“何时”、“何地”和“谁”。当我们为学习或激情项目开发应用时，我们通常会低估我们的项目。如果你的激情项目意外地一夜成名，维护或继续添加功能到你的应用将变得昂贵。在这种情况下，你将不得不承担持续维护成本或面临应用程序的重写。
- en: When we develop apps for work, we tend to be more conservative and will likely
    over-engineer our solution. However, if you only code for work, you will likely
    experiment with production-bound code. It is dangerous to experiment in a codebase
    with other team members. You may be introducing a new pattern without your team
    understanding the consequences of your choices. You’re also less likely to know
    the mid-to-long-term risks or benefits of the technologies you introduce.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为工作开发应用时，我们往往更加保守，可能会过度设计我们的解决方案。然而，如果你只为工作编码，你可能会在面向生产的代码上进行实验。在与其他团队成员的代码库中实验是危险的。你可能会引入一个新模式，而你的团队不了解你选择的结果。你也可能不太了解你引入的技术的中长期风险或收益。
- en: Reckless experimentation can also have a severe negative impact on your team
    members. In a team of senior and experienced software engineers, you can likely
    get away with experimenting in a moving car. However, we will likely have team
    members of varying backgrounds and learning styles on our teams. Some of us have
    computer science degrees, some of us are lone wolves, and some of us depend a
    bit too much on Stack Overflow. Some of us work at companies that are great at
    supporting professional growth, but some of us work at places that won’t give
    us a day to learn something new. So, when experimenting, we must consider our
    environment; otherwise, we can cause our colleagues to work overtime or feel helpless
    and frustrated.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 草率实验也可能对你的团队成员产生严重的负面影响。在一个由资深和经验丰富的软件工程师组成的团队中，你可能在移动车辆中进行实验。然而，我们团队中可能会有不同背景和学习风格的成员。我们中的一些人有计算机科学学位，一些人是独行侠，还有一些人过度依赖Stack
    Overflow。我们中的一些人在支持职业发展的公司工作，但也有一些人在不会给我们一天时间学习新东西的地方工作。因此，在实验时，我们必须考虑我们的环境；否则，我们可能会让我们的同事加班或感到无助和沮丧。
- en: 'With a disciplined and balanced approach, we can reduce the number of bugs
    delivered, avoid costly rework, and work with a group of people moving in the
    same direction. We also need the right architecture, tools, and patterns/practices
    to deliver successfully. In summary, our approach must consider the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 采用有纪律和平衡的方法，我们可以减少交付的bug数量，避免昂贵的返工，并与一个朝着同一方向前进的团队一起工作。我们还需要正确的架构、工具和模式/实践来成功交付。总之，我们的方法必须考虑以下方面：
- en: The size of our app
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用的大小
- en: The reason we are developing the app
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开发应用的原因
- en: The skill level of developers
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者的技能水平
- en: Iterative and incremental delivery
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代和增量交付
- en: The constant forward flow of features
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性不断向前流动
- en: Cloud architecture, operational costs, and cybersecurity
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云架构、运营成本和网络安全
- en: 'Ideally, we need to maintain optimal engineering overhead. Our architecture
    should support our short-term needs while being extensible, so we can pivot in
    different directions if our mid- or long-term needs change without having to rewrite
    large swathes of code. Consider the following diagram, in contrast to the ones
    about small and large enterprise apps in the previous section:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们需要保持最佳工程开销。我们的架构应该支持我们的短期需求，同时具有可扩展性，这样我们就可以在短期或长期需求改变时转向不同的方向，而无需重写大量代码。考虑以下图表，与上一节中关于小型和大型企业应用的图表形成对比：
- en: '![](img/B18047_03_14.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18047_03_14.png)'
- en: 'Figure 3.14: Ideal architectural journey of an LOB app'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：LOB应用的理想架构之旅
- en: Router-first architecture aims to help you find the balance between your codebase’s
    engineering overhead, feature delivery, and flexibility. However, you are responsible
    for managing the discipline side of things.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 路由优先架构旨在帮助你找到代码库的工程开销、特性交付和灵活性之间的平衡。然而，你负责管理事物的纪律方面。
- en: Shu Ha Ri is a concept that can help bring discipline to your work. It is a
    way of thinking that instructs you first to master the basics without worrying
    about the underlying theory, then master the theory, and finally be able to adapt
    what you mastered to your needs. However, if you skip steps 1 or 2, you will find
    yourself adapting the wrong thing incorrectly.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Shu Ha Ri 是一个可以帮助你将纪律带入工作的概念。它是一种思维方式，指导你首先掌握基础知识，而不必担心底层理论，然后掌握理论，最后能够将你掌握的内容适应到你的需求中。然而，如果你跳过了步骤1或2，你可能会发现自己错误地适应了错误的事物。
- en: Having covered the *what*, *why*, *when*, *where*, and *who*, let’s jump into
    the *how* in the next section.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了*什么*、*为什么*、*何时*、*何地*和*谁*之后，让我们在下一节中跳入*如何*。
- en: Router-first architecture
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由优先架构
- en: 'Router-first architecture is a way to:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 路由优先架构是一种方法：
- en: '**Enforce** high-level thinking'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制**高级思维'
- en: '**Ensure** consensus on features *before* you start coding'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在开始编码之前**确保对特性达成共识'
- en: '**Plan** for your codebase/team to grow'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规划**你的代码库/团队的增长'
- en: '**Introduce** little engineering overhead'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引入**小的工程开销'
- en: 'There are seven steps to implementing the router-first architecture:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 实施路由优先架构有七个步骤：
- en: Develop a roadmap and scope (*Chapter 4*).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制定路线图和范围（*第4章*）。
- en: Design with lazy loading in mind (*Chapter 4*).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑懒加载进行设计（*第4章*）。
- en: Implement a walking-skeleton navigation experience (*Chapter 4*).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施步行骨架导航体验（*第4章*）。
- en: Achieve a stateless, data-driven design (*Chapters 4*-*5*).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现无状态、数据驱动的架构（*第4-5章*）。
- en: Enforce a decoupled component architecture (*Chapters 6-9*).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制实施解耦组件架构（*第6-9章*）。
- en: Differentiate between user controls and components (*Chapter 8*).
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件（*第8章*）。
- en: Maximize code reuse with TypeScript and ES features (*Chapters 5-9*).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用TypeScript和ES特性最大化代码重用（*第5-9章*）。
- en: As noted previously, each step will be covered in more detail in this and coming
    chapters. Before we go over these steps at a high level, let’s first cover feature
    modules in Angular, which are important fundamental technical concepts.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个步骤将在本章节和接下来的章节中更详细地介绍。在我们从高层次概述这些步骤之前，让我们首先介绍Angular中的功能模块，这是重要的基本技术概念。
- en: Feature modules
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能模块
- en: 'In *Chapter 1*, *Angular’s Architecture and Concepts*, we covered Angular’s
    architecture at a high level and introduced the concepts of lazy loading and routing.
    Feature modules are a key component in implementing lazy loading. There are two
    kinds of modules: the root module and the feature module. Modules are implemented
    by the class `NgModule`. `NgModule` contains all the necessary metadata to render
    components and inject services. Before the introduction of standalone components,
    a component without a module couldn’t do much. But now, a standalone component
    can import its dependent modules, components, and providers without needing a
    module.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Angular的架构和概念*中，我们以高层次概述了Angular的架构，并介绍了懒加载和路由的概念。功能模块是实现懒加载的关键组件。有两种类型的模块：根模块和功能模块。模块是通过`NgModule`类实现的。`NgModule`包含渲染组件和注入服务所需的所有必要元数据。在独立组件引入之前，没有模块的组件无法做很多事情。但现在，一个独立组件可以导入其依赖的模块、组件和提供者，而无需模块。
- en: 'An Angular application is defined by `NgModule` that sits at the root of the
    application. This is called the root module. Starting with Angular 17, standalone
    projects are enabled by default. So, instead of a root module, an `AppConfig`
    object is created, which fulfills a similar role to the root module during the
    bootstrap process. The root module renders what appears in the `<app-root>` element
    in your `index.html` file. Locate the root module, which is interchangeable with
    `AppConfig`, in the following diagram:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用由位于应用程序根部的`NgModule`定义。这被称为根模块。从Angular 17开始，独立项目默认启用。因此，而不是根模块，会创建一个`AppConfig`对象，它在引导过程中扮演与根模块相似的角色。根模块渲染在`index.html`文件中的`<app-root>`元素中显示的内容。在以下图中定位根模块，它与`AppConfig`可互换：
- en: '![A picture containing text, diagram, plan, line  Description automatically
    generated](img/B18047_03_15.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、图表、计划、行描述自动生成](img/B18047_03_15.png)'
- en: 'Figure 3.15: Major architectural components of Angular'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：Angular的主要架构组件
- en: '`NgModule` can contain many other `NgModules`. An Angular app can only have
    one root module or none. This means `NgModule` you implement is a feature module.
    In the preceding diagram, you can see that you can organize a group of components
    (**Cmp**) and services (**Svc**) into feature modules. Grouping functionality
    into modules allows us to organize our code into chunks, which can be separated
    from the initial bundle of our application.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgModule`可以包含许多其他的`NgModules`。一个Angular应用只能有一个根模块或者没有。这意味着你实现的`NgModule`是一个功能模块。在先前的图中，你可以看到你可以将一组组件（**Cmp**）和服务（**Svc**）组织到功能模块中。将功能分组到模块中允许我们将代码组织成块，这些块可以与应用程序的初始包分离。'
- en: This idea of root and feature modules represents a parent/child relationship,
    which is a concept that extends to other functionality and frameworks. For example,
    note that the preceding diagram injects a root router into the root module. A
    root router can have child routes. Child routes can be configured to load feature
    modules. Similarly, NgRx has root and feature module-level stores to organize
    the state data of your application.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块和功能模块的这个概念代表了一种父子关系，这个概念扩展到其他功能和框架。例如，注意先前的图中将根路由注入到根模块中。根路由可以有子路由。子路由可以配置为加载功能模块。同样，NgRx有根模块和功能模块级别的存储来组织应用程序的状态数据。
- en: 'Any mention of a sub-module, child module, or feature module in this book refers
    to the same thing: a module that is not the root module.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中提到的任何关于子模块、子模块或功能模块的提及，都指的是同一件事：一个不是根模块的模块。
- en: Feature modules and child routes allow for a separation of concerns between
    major components of your application. Two teams can work on two different modules
    without interfering with each other. This separation means that any dependency
    required by a feature module must be explicitly added to the imports, declarations,
    or providers of that module. In the case of standalone components, these imports
    and providers must be added to every single component. This can seem repetitive
    and annoying, but it is a necessary evil.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块和子路由允许将应用程序的主要组件之间的关注点分离。两个团队可以在不相互干扰的情况下分别工作在不同的模块上。这种分离意味着任何功能模块所需的依赖都必须明确添加到该模块的导入、声明或提供者中。对于独立组件，这些导入和提供者必须添加到每个组件中。这可能会显得重复且令人烦恼，但这是必要的恶行。
- en: 'As explained in *Chapter 2*, *Forms, Observables, Signals, and Subjects*, services,
    by default, are singletons – one instance per module. However, you can remove
    the `providedIn: ''root''` property from the `@Injectable` annotation and use
    the service within different injection contexts. You can provide copies of a service
    at the feature module or component level. When doing this, be aware that if you
    provide the same service in multiple contexts within the same inheritance chain,
    e.g., in the root and a feature module or a component, you will end up having
    multiple instances of that service that could be injected, which breaks the expectations
    of the dependency injection system.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '如同在*第二章*，*形式、可观察量、信号和主题*中所述，服务默认是单例的——每个模块一个实例。然而，你可以从`@Injectable`注解中移除`providedIn:
    ''root''`属性，并在不同的注入上下文中使用该服务。你可以在功能模块或组件级别提供服务的副本。当你这样做时，请注意，如果在同一继承链中的多个上下文中提供相同的服务，例如在根模块和一个功能模块或组件中，你最终会有多个可能被注入的服务实例，这会破坏依赖注入系统的预期。'
- en: As you can appreciate, modules introduce a complicated and often unnecessary
    abstraction layer in most scenarios. This is the main reason Angular now generates
    standalone projects by default.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在大多数情况下，模块引入了一个复杂且通常不必要的抽象层。这是Angular现在默认生成独立项目的主要原因。
- en: Now, let’s review the seven steps of router-first architecture at a high level.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从高层次上回顾一下路由优先架构的七个步骤。
- en: Developing a roadmap and scope
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定路线图和范围
- en: Developing a roadmap and establishing the scope of your project early on is
    critical to getting the high-level architecture right. Creating a backlog, wireframes,
    mock-ups, and interactive prototypes will help you define the map before getting
    on the road and capture the vision concretely. It is important to remember to
    use tools only when necessary. Don’t start with Photoshop when a piece of paper
    and a pencil will do. If stakeholders and team members understand what is being
    developed, it will be possible to deliver your solution iteratively and incrementally.
    However, don’t fall into the perfection trap. Save the tweaking and furniture
    rearranging until after the fundamentals are in place and agreed upon.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目早期就制定路线图和确定范围对于确保高级架构的正确性至关重要。创建待办事项列表、线框图、原型和交互式原型将帮助你确定路线图，在踏上道路之前捕捉到具体的愿景。重要的是要记住，只有在必要时才使用工具。如果一张纸和一支铅笔就能解决问题，就不要从Photoshop开始。如果利益相关者和团队成员理解正在开发的内容，就能够在迭代和增量交付解决方案。然而，不要陷入完美的陷阱。在基本要素到位并获得一致同意之后，再进行微调和家具调整。
- en: Document every artifact you create. *Chapter 4*, *Creating a Router-First Line-Of-Business
    App*, we cover how to leverage GitHub wikis to store your artifacts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你创建的每个工件。在*第四章*，*创建路由优先的业务线应用程序*中，我们介绍了如何利用GitHub维基来存储你的工件。
- en: Later in this chapter, we will go over how to develop a roadmap and a technique
    to define your scope, building on the roadmap-building techniques covered in the
    *Planning using Kanban and GitHub projects* section.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将介绍如何制定路线图和定义范围的技术，这些技术是在*使用看板和GitHub项目进行规划*部分中介绍的路线图构建技术的基础上。
- en: Designing with lazy loading in mind
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑懒加载进行设计
- en: Your first paint matters a lot! According to Google Analytics data from the
    Angular team in 2018, 53% of mobile users abandoned a website when load times
    exceeded 3 seconds. During the same period, most websites were consumed on mobile
    devices – around 70% in the US and 90% in China. UI libraries and static assets
    can add significant size to your application. Since most content is consumed on
    mobile, it’s very important to defer the loading of non-critical assets.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一幅画非常重要！根据2018年Google Analytics团队的数据，当加载时间超过3秒时，53%的移动用户放弃了网站。在同一时期，大多数网站都是在移动设备上被消费的——在美国约占70%，在中国约占90%。UI库和静态资产可以显著增加您应用程序的大小。由于大多数内容都是在移动设备上被消费的，因此推迟非关键资产的加载非常重要。
- en: We defer the loading of assets by divvying up the parts of our Angular application
    into feature modules. This way, Angular can load only the assets necessary to
    render the current screen and dynamically download further resources as needed.
    You can start thinking about ways to divide your application into feature modules
    by defining the various user roles your application may use. User roles normally
    indicate a user’s job function, such as a manager or data-entry specialist. In
    technical terms, they can be thought of as a group of actions a particular user
    role can execute. After all, a data-entry specialist won’t ever see most of the
    screens a manager can, so why deliver those assets to those users and slow down
    their experience?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将Angular应用程序的部分划分为功能模块来推迟资产的加载。这样，Angular可以只加载渲染当前屏幕所需的资产，并在需要时动态下载进一步的资源。您可以通过定义应用程序可能使用的各种用户角色来开始考虑如何将应用程序划分为功能模块。用户角色通常表示用户的职能，如经理或数据录入专员。从技术角度来说，它们可以被视为特定用户角色可以执行的一组操作。毕竟，数据录入专员永远不会看到经理可以看到的大多数屏幕，那么为什么要把这些资产提供给这些用户并减慢他们的体验呢？
- en: A more definitive strategy to divide your application would be by business function.
    You can think of each job function as a sub-module of your application. Following
    the principle of low coupling and high cohesion, you would want to group related
    functionality into modules that can be lazily loaded. This way, as users execute
    a task within a business function, they’re not interrupted by delays. However,
    as the user switches from one business function to another, we can load the new
    module, and a slight delay would be acceptable.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序按业务功能划分的更明确策略是。您可以将每个工作职能视为应用程序的一个子模块。遵循低耦合和高内聚的原则，您会希望将相关的功能分组到可以懒加载的模块中。这样，当用户在业务功能内执行任务时，他们不会因为延迟而受到干扰。然而，当用户从一个业务功能切换到另一个业务功能时，我们可以加载新的模块，轻微的延迟是可以接受的。
- en: You can set a preloading strategy to eagerly load all modules in the background
    as the user interacts with your app. This would eliminate any transition delay.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置预加载策略，在用户与您的应用程序交互时在后台急切地加载所有模块。这将消除任何过渡延迟。
- en: For more information, see [https://angular.dev/guide/ngmodules/lazy-loading#preloading](https://angular.dev/guide/ngmodules/lazy-loading#preloadingv=HTU4WYWGTIk).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅[https://angular.dev/guide/ngmodules/lazy-loading#preloading](https://angular.dev/guide/ngmodules/lazy-loading#preloadingv=HTU4WYWGTIk)。
- en: Lazy loading is critical in creating a scalable application architecture, allowing
    you to deliver high-quality and efficient products. Lazy loading is a low-hanging
    fruit we will tackle as a baseline design goal. It can be costly to implement
    lazy loading after the fact.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载对于创建可扩展的应用程序架构至关重要，它允许您提供高质量和高效的产品。懒加载是我们将作为一个基本设计目标解决的问题。在事后实现懒加载可能会很昂贵。
- en: It is also possible to lazy load individual standalone components. Standalone
    components do not require all the bootstrapping that an Angular application requires.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能对单个独立组件进行懒加载。独立组件不需要Angular应用程序所需的全部引导。
- en: You can read more about these components in detail at [https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component](https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component](https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component)详细了解这些组件。
- en: Later in this chapter, you will learn how to implement lazy loading using feature
    modules.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，您将学习如何使用功能模块实现懒加载。
- en: Implementing a walking skeleton
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个行走骨架
- en: Configuring lazy loading can be tricky, so it is essential to nail down a walking-skeleton
    navigation experience early on. Implementing a clickable version of your app will
    help you gather feedback from users early on. That way, you’ll be able to work
    out fundamental workflow and integration issues quickly. Additionally, you’ll
    be able to establish a concrete representation of the scope of your current development
    effort. Developers and stakeholders alike will be able to visualize better how
    the product will look.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 配置懒加载可能很棘手，因此早期确定走廊骨架导航体验至关重要。实现应用的点击版本将帮助您在早期收集用户反馈。这样，您将能够快速解决基本的工作流程和集成问题。此外，您将能够确立当前开发工作的具体范围。开发人员和利益相关者都将能够更好地可视化产品的外观。
- en: A walking skeleton also sets the stage for multiple teams to work together.
    Multiple people can start developing different feature modules or components simultaneously
    without worrying about how the puzzle pieces will come together later. By the
    end of this chapter, you will have completed implementing the walking skeleton
    of the sample app LemonMart.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 走廊骨架也为多个团队协作奠定了基础。多个人可以同时开始开发不同的功能模块或组件，而不必担心这些拼图碎片如何最终拼合在一起。到本章结束时，您将完成实现示例应用LemonMart的走廊骨架。
- en: Achieve a stateless, data-driven design
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现无状态、数据驱动的设计
- en: As highlighted in *Chapter 5*, *Designing Authentication and Authorization*,
    stateless design in full-stack architecture is critical to implementing a maintainable
    application. As covered in *Chapter 1*, *Angular’s Architecture and Concepts*,
    and later in *Chapter 9*, *Recipes – Master/Detail, Data Tables, and NgRx*, the
    flux pattern and NgRx make it possible to achieve an immutable state for your
    application. However, the flux pattern is likely to be overkill for most applications.
    NgRx itself leverages a lot of the core technologies present in RxJS.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第5章*，*设计身份验证和授权*中强调的，在全栈架构中实现无状态设计对于构建可维护的应用至关重要。正如*第1章*，*Angular的架构和概念*以及随后的*第9章*，*食谱
    – 主/详细信息，数据表和NgRx*中所述，Flux模式与NgRx使得为您的应用实现不可变状态成为可能。然而，Flux模式对于大多数应用来说可能过于复杂。NgRx本身利用了RxJS中的许多核心技术。
- en: We will use RxJS and the reactive programming paradigm to implement a minimal,
    stateless, and data-driven pattern for our application. Identifying major data
    entities, such as invoices or people, that your users will work with will help
    you avoid over-engineering your application. Designing around major data entities
    will inform API design early on and help define the `BehaviorSubject` data anchors
    you will use to achieve a stateless, data-driven design. That design will, in
    turn, ensure a decoupled component architecture, as detailed in *Chapter 2*, *Forms,
    Observables, Signals, and Subjects*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用RxJS和响应式编程范式来实现应用的最小化、无状态和数据驱动模式。识别用户将与之交互的主要数据实体，例如发票或人员，将帮助您避免过度设计您的应用。围绕主要数据实体进行设计将有助于早期确定API设计，并帮助定义您将用于实现无状态、数据驱动设计的`BehaviorSubject`数据锚点。该设计反过来将确保解耦的组件架构，正如*第2章*，*表单、可观察对象、信号和主题*中详细描述的。
- en: By defining observable data anchors, you can ensure that data across various
    components will be kept in sync. We can implement immutable data streams by writing
    functional reactive code, leveraging RxJS features, and not storing state in components.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义可观察的数据锚点，您可以确保各个组件之间的数据保持同步。我们可以通过编写函数式响应式代码，利用RxJS特性，并在组件中不存储状态来实现不可变数据流。
- en: We will cover how to design the data models for your application in *Chapter
    5*, *Designing Authentication and Authorization*, and will continue using these
    models in the following chapters.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第5章*，*设计身份验证和授权*中介绍如何为您的应用设计数据模型，并在接下来的章节中继续使用这些模型。
- en: Enforce a decoupled component architecture
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行解耦的组件架构
- en: As discussed in *Chapter 1*, *Angular’s Architecture and Concepts*, decoupling
    components of your architecture is critical in ensuring a maintainable codebase.
    You can decouple components in Angular by leveraging `@Input` and `@Output` bindings
    and router orchestration.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*第1章*，*Angular的架构和概念*中讨论的，解耦架构中的组件对于确保代码库的可维护性至关重要。您可以通过利用`@Input`和`@Output`绑定以及路由编排来在Angular中解耦组件。
- en: Bindings will help you maintain a simple hierarchy of components and avoid using
    dynamic templates in situations where static designs are more effective, such
    as creating multi-page forms.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定可以帮助你维护一个简单的组件层次结构，并避免在静态设计更有效的情况下使用动态模板，例如创建多页表单。
- en: Router outlets and auxiliary paths allow you to compose your view using the
    router. Resolvers can help load data by consuming router parameters. Auth guards
    can help control access to various modules and components. Using router links,
    you can dynamically customize elements that a user will see in an immutable and
    predictable way, like the way we designed and developed data anchors in the previous
    step.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 路由出口和辅助路径允许你使用路由组合视图。解析器可以通过消耗路由参数来帮助加载数据。身份验证守卫可以帮助控制对各种模块和组件的访问。使用路由链接，你可以以不可变和可预测的方式动态定制用户将看到的元素，就像我们在上一步中设计和开发数据锚点的方式一样。
- en: If you ensure every component is responsible for loading its data, then you
    can compose components via URLs. However, overusing the router can become an anti-pattern.
    If a parent component logically owns a child component, then the effort to decouple
    them will be wasted.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确保每个组件都负责加载其数据，那么你可以通过URL组合组件。然而，过度使用路由可能会成为一种反模式。如果一个父组件在逻辑上拥有一个子组件，那么将它们解耦的努力将是徒劳的。
- en: In *Chapter 2*, *Forms, Observables, Signals, and Subjects*, you learned how
    to enable component interactions using `BehaviorSubject` and `Signals`. In *Chapter
    8*, *Recipes – Reusability, Forms, and Caching*, you will learn how to implement
    `@Input` and `@Output` bindings, and in the upcoming chapters, you will learn
    how to implement router features.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*表单、Observables、Signals和Subjects*中，你学习了如何使用`BehaviorSubject`和`Signals`启用组件交互。在*第八章*，*食谱
    - 可重用性、表单和缓存*中，你将学习如何实现`@Input`和`@Output`绑定，在接下来的章节中，你将学习如何实现路由功能。
- en: Differentiate between user controls and components
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分用户控件和组件
- en: Another important idea is differentiating user controls from components. A user
    control is like a custom date input or star rater. It is often highly interactive
    and dynamic code that is highly coupled, convoluted, and complicated. Such controls
    may utilize rarely used Angular APIs, like `NgZone`, `Renderer2`, `ViewContainerRef`,
    or `DynamicComponentLoaders`. These highly specialized and specific APIs are out
    of the scope of this book.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的观点是区分用户控件和组件。用户控件就像是一个定制的日期输入或星级评分器。它通常是高度交互性和动态的代码，高度耦合、复杂且复杂。这些控件可能使用很少使用的Angular
    API，如`NgZone`、`Renderer2`、`ViewContainerRef`或`DynamicComponentLoaders`。这些高度专业化和具体的API超出了本书的范围。
- en: A component is more like a form with fields, which may contain simple date inputs
    or a star rater. Because forms encapsulate business functionality, their code
    must be easily read and understood. Your code should stick to Angular fundamentals
    so it is stable and easy to maintain, like most of the code in this book.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 组件更像是带有字段的表单，可能包含简单的日期输入或星级评分器。由于表单封装了业务功能，其代码必须易于阅读和理解。你的代码应坚持Angular的基本原则，以便它稳定且易于维护，就像本书中的大多数代码一样。
- en: By differentiating between user controls and components, you can make better
    decisions when deciding what kind of reusable code you want to make. Creating
    reusable code is costly. If you create the right reusable code, you can save time
    and resources. If you create the wrong reusable code, then you can waste a lot
    of time and resources.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过区分用户控件和组件，你可以在决定想要创建哪种可重用代码时做出更好的决策。创建可重用代码是昂贵的。如果你创建了正确的可重用代码，你可以节省时间和资源。如果你创建了错误的可重用代码，那么你可能会浪费大量的时间和资源。
- en: Wireframing allows you to identify reusable elements early on. User controls
    will help keep user interaction code separate from business logic. Well-crafted
    component reuse will enable you to encapsulate domain-specific behavior and share
    it later.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计允许你早期识别可重用元素。用户控件将帮助将用户交互代码与业务逻辑分开。精心设计的组件重用将使你能够封装特定领域的功能并在以后共享它。
- en: It’s important to identify self-contained user controls that encapsulate unique
    behaviors you wish to create for your app. User controls will likely be created
    as directives or components with data-binding properties and tightly coupled controller
    logic and templates.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 识别封装你希望为你的应用程序创建的独特行为的自包含用户控件是很重要的。用户控件可能会作为指令或具有数据绑定属性和紧密耦合的控制器逻辑和模板的组件来创建。
- en: Conversely, components leverage router lifecycle events to parse parameters
    and perform CRUD operations on data. Identifying these component reuses early
    on will create more flexible components that can be reused in multiple contexts
    (as orchestrated by the router), maximizing code reuse.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，组件利用路由生命周期事件来解析参数并在数据上执行 CRUD 操作。尽早识别这些组件的复用将创建出更多灵活的组件，这些组件可以在多个上下文中复用（由路由器编排），从而最大化代码复用。
- en: We will cover creating reusable components and user controls in *Chapter 8*,
    *Recipes – Reusability, Forms, and Caching*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 8 章 *配方 – 可复用性、表单和缓存* 中介绍创建可复用组件和用户控件。
- en: Maximize code reuse with TypeScript and ES
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TypeScript 和 ES 最大化代码复用
- en: It’s essential to remember the underlying features of the language you work
    with before considering the features offered by Angular, RxJS, and all the libraries
    you use. There are decades of software engineering fundamentals that you can leverage
    to write readable and maintainable code.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 Angular、RxJS 以及你使用的所有库提供的功能之前，记住你所使用的语言的底层特性是至关重要的。有数十年的软件工程基础，你可以利用这些基础来编写可读性和可维护的代码。
- en: 'First and foremost is the DRY principle, which stands for don’t repeat yourself.
    So, don’t copy-paste code. Don’t just change a variable or two. Proactively refactor
    your code to make your functions stateless and reusable. In a few words: don’t
    repeat yourself, don’t repeat yourself, and don’t repeat yourself.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 首先最重要的是 DRY 原则，即不要重复自己。所以，不要复制粘贴代码。不要只是更改一个或两个变量。积极重构你的代码，使你的函数无状态和可复用。简而言之：不要重复自己，不要重复自己，不要重复自己。
- en: Leverage object-oriented design. Move behavior to classes; if the `person` class
    has a `fullName` property, don’t re-implement the logic of assembling a full name
    in a dozen different places. Implement it once in the `person` class.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 利用面向对象设计。将行为移动到类中；如果 `person` 类有一个 `fullName` 属性，不要在十几个不同的地方重新实现组装全名的逻辑。在 `person`
    类中只实现一次。
- en: This means you will need to become familiar with hydration, essentially injecting
    a JSON object into a newly instantiated class and serialization using `toJSON`.
    It is important not to abuse OOP. You should remain stateless and functional by
    avoiding storing state in class parameters.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要熟悉数据填充，即在新的实例化类中注入 JSON 对象和使用 `toJSON` 进行序列化。重要的是不要过度使用面向对象编程。你应该通过避免在类参数中存储状态来保持无状态和函数式。
- en: You can unleash the power of object-oriented design by leveraging generics,
    inheritance, and abstract classes. We will go over concrete examples of these
    techniques later in the book.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用泛型、继承和抽象类，你可以释放面向对象设计的力量。我们将在本书的后面部分介绍这些技术的具体示例。
- en: TypeScript introduces the concept of interfaces to JavaScript. Interfaces are
    a concept mostly reserved for statically typed languages. An interface represents
    an abstract notion of what an object can do without specifying implementation
    details. Furthermore, an interface can be used to document the shape of data.
    For example, you can write a partial interface of a third-party API to document
    the fields you’re interested in consuming. When other developers read your code,
    they understand the structure of the data they’re consuming without having to
    read the documentation on another website.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 为 JavaScript 引入了接口的概念。接口主要是一个静态类型语言的保留概念。接口代表了一个对象可以做什么的抽象概念，而不指定实现细节。此外，接口可以用来记录数据的形状。例如，你可以编写第三方
    API 的部分接口来记录你感兴趣消费的字段。当其他开发者阅读你的代码时，他们可以理解他们消费的数据结构，而无需阅读另一个网站上的文档。
- en: Interfaces also allow you to morph the shape of your data in a well-defined
    manner. So, you can write a transform function to transform the shape of external
    data into internal data. TypeScript will catch any errors you may make. Taking
    this concept further, you can also use interfaces to flatten data. If the data
    you receive has a multi-entity relational structure, you can flatten the relationship
    to decouple the data design from your UI code.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接口还允许你以定义良好的方式改变数据形状。因此，你可以编写一个转换函数来将外部数据的形状转换为内部数据。TypeScript 将捕获你可能犯的任何错误。进一步来说，你也可以使用接口来简化数据。如果你接收到的数据具有多实体关系结构，你可以简化关系，将数据设计从你的
    UI 代码中解耦。
- en: Don’t overly flatten your data. Arrays and simple shapes for common objects
    are okay, such as a `name` object (with `first`, `middle`, `last`, `prefix`, and
    `suffix` properties) or commonly used domain-specific objects.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度扁平化你的数据。对于常见对象，数组和简单形状是合适的，例如一个具有`first`、`middle`、`last`、`prefix`和`suffix`属性的`name`对象，或者常用的特定领域对象。
- en: You should also avoid using string literals in your code. Writing business logic
    where you compare `'apples' !== 'Oranges'` results in unmaintainable code. You
    should leverage `enums` in TypeScript, so your code isn’t subject to the spelling
    mistakes of coders or changing business requirements. So, `'``oranges' === Fruit.Oranges`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该避免在代码中使用字符串字面量。在比较 `'apples' !== 'Oranges'` 的业务逻辑中编写代码会导致难以维护的代码。您应该在 TypeScript
    中利用 `enums`，这样您的代码就不会受到程序员拼写错误或变化业务需求的影响。因此，`'oranges' === Fruit.Oranges`。
- en: Beyond TypeScript and ECMAScript, Angular also offers helpful functions to reuse
    logic. Angular validators, pipes, route resolvers, and route guards allow you
    to share code across components and templates.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 TypeScript 和 ECMAScript，Angular 还提供了有助于重用逻辑的功能。Angular 验证器、管道、路由解析器和路由守卫允许你在组件和模板之间共享代码。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught you what it takes to succeed as a technical lead or an architect.
    You learned about the ingredients of running a successful project. We went over
    why Angular is a great fit for an enterprise. Then we dove into various tools
    and features to consider for building a high-performance solution. You learned
    how to create a Kanban board and became familiar with the 80-20 rule and the router-first
    architecture method to tackle complicated projects.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了成为一名技术领导或架构师所需具备的条件。您学习了成功运行项目的要素。我们探讨了为什么 Angular 对于企业来说是一个很好的选择。然后我们深入探讨了构建高性能解决方案时需要考虑的各种工具和功能。您学习了如何创建看板，并熟悉了80-20规则和路由优先的架构方法来处理复杂项目。
- en: In the next chapter, you will be creating a far more complicated **LOB** application,
    using a router-first approach to designing and architecting scalable Angular applications
    with first-class authentication and authorization, user experience, and numerous
    recipes that cover a vast majority of requirements that you may find in LOB applications.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将创建一个更为复杂的**LOB**应用程序，使用路由优先的方法设计和构建具有一流身份验证和授权、用户体验以及覆盖大量可能出现在LOB应用程序中的需求的可扩展
    Angular 应用程序。
- en: Further reading
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Analog, the full-stack Angular meta-framework: [https://analogjs.org/](https://analogjs.org/)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全栈 Angular 元框架：[https://analogjs.org/](https://analogjs.org/)
- en: 'Manifesto for Agile Software Development: [https://agilemanifesto.org](https://agilemanifesto.org)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷软件开发宣言：[https://agilemanifesto.org](https://agilemanifesto.org)
- en: 'DevOps Research and Assessment (DORA) research program: [https://dora.dev/](https://dora.dev/)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps 研究与评估（DORA）研究计划：[https://dora.dev/](https://dora.dev/)
- en: 'DORA capability catalog: [https://dora.dev/devops-capabilities](https://dora.dev/devops-capabilities)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DORA 能力目录：[https://dora.dev/devops-capabilities](https://dora.dev/devops-capabilities)
- en: 'What is Scrum and how to get started, Atlassian, 2023: [https://www.atlassian.com/agile/scrum](https://www.atlassian.com/agile/scrum)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Scrum 以及如何开始，Atlassian，2023年：[https://www.atlassian.com/agile/scrum](https://www.atlassian.com/agile/scrum)
- en: 'How to Have a Successful Agile Project with Transient Teams, Nicole Spence-Goon,
    December 14, 2021: [https://www.excella.com/insights/successful-agile-project-with-transient-teams](https://www.excella.com/insights/successful-agile-project-with-transient-teams)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用临时团队成功进行敏捷项目，Nicole Spence-Goon，2021年12月14日：[https://www.excella.com/insights/successful-agile-project-with-transient-teams](https://www.excella.com/insights/successful-agile-project-with-transient-teams)
- en: '*Ha, Not Ready to Ri: The Shu Ha Ri Approach to Agile Development*, Brian Sjoberg
    and Ken Furlong, July 29, 2015: [https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈，尚未准备好：敏捷开发的 Shu Ha Ri 方法*，Brian Sjoberg 和 Ken Furlong，2015年7月29日：[https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development)'
- en: '*Nx: Smart, Fast Extensible Build System:* [https://nx.dev](https://nx.dev)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Nx：智能、快速、可扩展的构建系统:* [https://nx.dev](https://nx.dev)'
- en: '*RxAngular: Performance & DX:* [https://www.rx-angular.io](https://www.rx-angular.io)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RxAngular：性能与开发体验:* [https://www.rx-angular.io](https://www.rx-angular.io)'
- en: 'Webpack module bundler: [https://webpack.js.org/](https://webpack.js.org/)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 模块打包器：[https://webpack.js.org/](https://webpack.js.org/)
- en: Questions
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地回答以下问题，以确保你已理解本章的关键概念，而无需使用谷歌搜索。你知道你是否回答了所有问题吗？访问 [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    获取更多信息：
- en: What three things should you do to succeed as a technical lead or architect?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为技术负责人或架构师，为了成功，你应该做哪三件事？
- en: What are the ingredients of a successful project?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功项目的要素有哪些？
- en: Why should you use Angular in your enterprise?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你应该在企业中使用 Angular？
- en: What are the most important considerations for building Angular apps for your
    enterprise?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为企业构建 Angular 应用时最重要的考虑因素是什么？
- en: What causes performance issues in web applications?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络应用程序性能问题是由什么引起的？
- en: How can we solve performance issues in large web applications?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何解决大型网络应用程序中的性能问题？
- en: What is an LOB app?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是LOB应用程序？
- en: What is the Pareto principle?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帕累托原理是什么？
- en: What are the main goals of the router-first architecture?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由优先架构的主要目标是什么？
- en: Join our community on Discord
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/AngularEnterpise3e](Chapter_3.xhtml)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularEnterpise3e](Chapter_3.xhtml)'
- en: '![](img/QR_Code1116411172100421421.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1116411172100421421.png)'
