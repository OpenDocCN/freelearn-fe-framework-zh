- en: '*Chapter 5*: Reusable React Components and React Hooks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：可重用React组件和React Hooks'
- en: We have done a lot to reach this point in the book, including saving, requesting,
    inserting, and updating data through the use of Apollo Client, in connection with
    our GraphQL **application programming interface** (**API**). Much of the code
    that we have written will also have to be reviewed many times. This is especially
    important because we are building an application so quickly. Everything is working
    for now, but we have not done a great job here; there are some best practices
    and tactics that need to be observed in order to write good React applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到本书的这一阶段，我们已经做了很多工作，包括使用Apollo Client保存、请求、插入和更新数据，与我们的GraphQL **应用程序编程接口**（**API**）相结合。我们编写的许多代码也将需要多次审查。这尤其重要，因为我们正在快速构建一个应用程序。目前一切正常，但我们在这里做得还不够；为了编写好的React应用程序，我们需要遵循一些最佳实践和策略。
- en: 'This chapter will cover everything you need to know to write efficient and
    reusable React components. It will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖你需要了解的一切，以便编写高效且可重用的React组件。它将涵盖以下主题：
- en: Introducing React patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍React模式
- en: Structuring our React application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的React应用程序结构
- en: Extending Graphbook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Graphbook
- en: Documenting React applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录React应用程序
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter05)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter05)'
- en: Introducing React patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍React模式
- en: With any programming language, framework, or library that you use, there are
    always common tactics that you should follow. They present an understandable,
    efficient way to write applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何编程语言、框架或库时，你都应该遵循一些常见的策略。它们提供了一种可理解且高效的方式来编写应用程序。
- en: In [*Chapter 4*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085), *Hooking
    Apollo into React*, we tackled some patterns, such as rendering arrays, the spread
    operator, and destructuring objects. Nevertheless, there are some further patterns
    that you should know about.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085)“将Apollo Hook集成到React中”，我们探讨了某些模式，例如渲染数组、展开运算符和对象解构。尽管如此，还有一些其他模式你应该了解。
- en: 'We will go over the most commonly used patterns that React offers, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍React提供的最常用的模式，如下所示：
- en: Controlled components
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受控组件
- en: Functional components
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件
- en: Conditional rendering
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件渲染
- en: Rendering children
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染子组件
- en: Many (but not all) of the examples here only represent illustrations of what
    each method looks like. Some of them will not be taken over to our real application
    code, so if you are not interested in learning the essential aspects of patterns
    or if you already know most of them, you can skip the examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的许多示例（但并非全部）只是展示了每种方法的形态。其中一些示例可能不会被应用到我们的实际应用代码中，所以如果你对学习模式的基本方面不感兴趣，或者你已经了解了很多，你可以跳过这些示例。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Beyond the short explanation that I will provide, there is more extensive documentation
    on this topic. The official React documentation is always a good starting point,
    but you can find all React patterns, including those that we have already used,
    at [https://reactpatterns.com/](https://reactpatterns.com/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我将提供的简要解释之外，还有更多关于这个主题的详细文档。官方React文档始终是一个好的起点，但你可以在[https://reactpatterns.com/](https://reactpatterns.com/)找到所有React模式，包括我们已使用的那些。
- en: Controlled components
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受控组件
- en: When we wrote our post form to submit new posts or the message inputs inside
    chat in the previous chapters, we used controlled input by incident. To provide
    a better understanding, I am going to quickly explain the difference between controlled
    and uncontrolled components, and when to use each of them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，当我们编写提交新帖子或聊天中的消息输入表单时，我们意外地使用了受控输入。为了提供更好的理解，我将快速解释受控和非受控组件之间的区别，以及何时使用每个组件。
- en: Let's start with uncontrolled input.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从非受控输入开始。
- en: By definition, a component is uncontrolled whenever the value is not set by
    a property through React, but only saved and taken from the real browser **Document
    Object Model** (**DOM**). The value of an input is then retrieved from a reference
    to the DOM Node and is not managed and taken from React's component state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，当值不是通过 React 的属性设置，而是仅从真实的浏览器 **文档对象模型** (**DOM**) 保存和获取时，组件就是不受控制的。因此，输入值的检索是从
    DOM 节点的引用中获取的，并且不是由 React 组件的状态管理和获取。
- en: 'The following code snippet shows the post form where the user will be able
    to submit new posts. I have excluded the rendering logic for the complete feed,
    as it is not a part of the pattern that I want to show you:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了用户将能够提交新帖子的表单。我已经排除了完整源列表的渲染逻辑，因为它不是我想向您展示的模式的一部分：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, you can see that we no longer have the `useState` Hook, since
    the `textarea` value is stored within the real DOM Node, and not the application
    state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到我们不再有 `useState` 钩子，因为 `textarea` 的值存储在真实的 DOM 节点中，而不是应用程序状态中。
- en: We run the `useRef` Hook provided by React. It prepares the variable to accept
    the DOM Node as a property. If you are using class-based React components, you
    can use the `createRef` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行 React 提供的 `useRef` 钩子。它准备变量以接受 DOM 节点作为属性。如果您使用基于类的 React 组件，您可以使用 `createRef`
    函数。
- en: In the `return` statement for rendering the component, the `ref` property fills
    in the reference that we just created with the DOM element.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染组件的 `return` 语句中，`ref` 属性填充了我们刚刚用 DOM 元素创建的引用。
- en: Accessing the value of the DOM Node works by using the normal JavaScript DOM
    API. You can see this behavior when sending the `submit` event of our form. The
    value is extracted from the `textArea.current.value` field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用正常的 JavaScript DOM API 来访问 DOM 节点的值。您可以在发送我们表单的 `submit` 事件时看到这种行为。值是从 `textArea.current.value`
    字段中提取的。
- en: Everything that an uncontrolled component needs is already shown here; there
    is no more to it. You can compare this approach to our current implementation
    of the post form. In our implementation, we set up the state, listen for change
    events, and save and read the value directly from the component state, not from
    the DOM element.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不受控制组件所需的一切已经在这里展示；没有更多了。您可以比较这种方法与我们的当前帖子表单实现。在我们的实现中，我们设置了状态，监听变化事件，并直接从组件状态而不是从
    DOM 元素中保存和读取值。
- en: When using uncontrolled components and working directly with DOM elements, the
    problem is that you leave the normal React workflow. You are no longer able to
    handle conditions and, therefore, trigger other events inside of React.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不受控制组件并直接与 DOM 元素工作时，问题是您离开了正常的 React 工作流程。您不再能够处理条件，因此无法在 React 内部触发其他事件。
- en: Nevertheless, the DOM reference can make it easier to use third-party plugins
    that were not written for the React ecosystem. There are thousands of great jQuery
    plugins, for example. I always recommend using the default approach of a controlled
    component. For 99% of cases, this works without leaving the React workflow.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，DOM 引用可以使得使用为 React 生态系统之外编写的第三方插件变得更加容易。例如，有数千个优秀的 jQuery 插件。我总是推荐使用受控组件的默认方法。在
    99% 的情况下，这可以在不离开 React 工作流程的情况下工作。
- en: Tip
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need a deeper understanding of which approach is a better solution for
    your specific case, take a look at [https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更深入地了解哪种方法更适合您的特定情况，请查看[https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/)。
- en: Functional components
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组件
- en: One fundamental and efficient solution for writing well-structured and reusable
    React components is the use of functional components. We have already used them
    throughout the book at every location.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编写结构良好且可重用 React 组件的一个基本且有效的方法是使用函数组件。我们在整本书的每个地方都已经使用了它们。
- en: Before the existence of functional components, there were stateless functions.
    As you might expect, stateless functions are functions, not React components.
    They are not able to store any states; only properties can be used to pass and
    render data. Property updates are directly rerendered inside the stateless functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数组件出现之前，存在无状态函数。正如您可能预料的，无状态函数是函数，而不是 React 组件。它们无法存储任何状态；只能使用属性来传递和渲染数据。属性更新将直接在无状态函数内部重新渲染。
- en: Since newer versions of React, those stateless functions no longer exist as
    there are React Hooks that allow us to use state in those functions, which makes
    them fully functional components. This is why they are now called functional components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React的新版本，那些无状态函数不再存在，因为有React Hooks允许我们在这些函数中使用状态，这使得它们成为完全功能性的组件。这就是为什么它们现在被称为函数组件。
- en: We have written a lot of code where more functional components can help us provide
    more structured and understandable code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了很多代码，其中更多的函数组件可以帮助我们提供更结构化和易于理解的代码。
- en: 'Beginning with the file structure, we will create a new folder for our new
    components, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件结构开始，我们将为我们的新组件创建一个新的文件夹，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Many parts of our application need to be reworked. Create a new file for our
    first functional component, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中的许多部分都需要重新设计。为我们的第一个功能组件创建一个新文件，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Currently, we display a dull and boring `loading.js` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们显示了一个单调乏味的`loading.js`文件：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we are using a simple function in `color` and
    `size` fields from the properties that our function receives.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在使用从我们的函数接收的属性中的`color`和`size`字段中的简单函数。
- en: We are building a default `style` object that represents the basic styling for
    a loading spinner. You can pass the `color` and `size` values separately, to adjust
    those settings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个默认的`style`对象，它代表加载旋转器的基样式。您可以单独传递`color`和`size`值，以调整这些设置。
- en: Lastly, we are returning a simple `div` tag with the `bouncer` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回一个带有`bouncer`类的简单`div`标签。
- en: 'What''s missing here is the CSS styling. The code should look like this; we''ll
    just add it to our `style.css` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里缺少的是CSS样式。代码应该看起来像这样；我们只需将其添加到我们的`style.css`文件中：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As in the previous examples, we use CSS animations to display our loading spinner
    correctly and to let it animate as pulsating.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们使用CSS动画正确显示我们的加载旋转器，并让它以脉冲的方式动画化。
- en: We have now finished the functional component. You should place it into the
    existing code, wherever a loading state exists.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了功能组件。您应该将其放置到现有代码中，任何存在加载状态的地方。
- en: 'First, import the new loading spinner to the top of your files, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将新的加载旋转器导入到文件顶部，如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can then render the functional component, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以按照以下方式渲染函数组件：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start the server with `npm run server` and the frontend with `npm run client`.
    You should now see a pulsating blue bubble where you inserted it. I have tested
    this inside of my posts feed, and it looks pretty good.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm run server`启动服务器，使用`npm run client`启动前端。现在您应该看到您插入位置处的脉冲蓝色气泡。我在我的帖子源中测试过，看起来相当不错。
- en: The advantage of functional components is that they are minimal and efficient
    functions, rendering smaller parts of our application. The approach perfectly
    integrates with React, and we can improve upon the code that we have written.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件的优势在于它们是最小化和高效的函数，渲染我们应用程序的较小部分。这种方法与React完美集成，我们可以改进我们编写的代码。
- en: Conditional rendering
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件渲染
- en: One important ability of React is rendering components or data conditionally.
    We will use this intensively in the next main features that we are going to implement.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: React的一个重要能力是条件渲染组件或数据。我们将在接下来要实现的主要功能中大量使用它。
- en: 'Generally, you can accomplish conditional rendering by using the curly brace
    syntax. An example of an `if` statement is provided here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以通过使用花括号语法来实现条件渲染。这里提供了一个`if`语句的示例：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code is the simplest example of conditional rendering. We have the `shouldRender`
    variable from the component state, and we use this as our condition. When the
    condition is `true`, the second part—which is our `Successful conditional rendering!`
    text—will also render. That is because we are using the `&&` characters. The text
    does not render if the condition is `false`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是条件渲染的最简单示例。我们有来自组件状态的`shouldRender`变量，并使用它作为条件。当条件为`true`时，第二部分——即我们的`Successful
    conditional rendering!`文本——也将被渲染。这是因为我们使用了`&&`字符。如果条件为`false`，则文本不会渲染。
- en: You can replace the preceding condition with anything that you have in mind.
    It can be a complex condition, such as a function returning a Boolean value, or
    just as in the preceding code, it can be a state variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用您想象中的任何内容替换前面的条件。它可以是一个复杂的条件，例如返回布尔值的函数，或者就像前面的代码一样，它可以是状态变量。
- en: You will see further examples in later steps and chapters of this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本书的后续步骤和章节中看到更多示例。
- en: Rendering child components
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染子组件
- en: In all of the code that we have written so far, we have directly written the
    markup as though it is rendered to real **HyperText Markup Language** (**HTML**).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止编写的所有代码中，我们直接编写了标记，就像它是渲染到真实的 **超文本标记语言**（**HTML**）一样。
- en: A great feature that React offers is the ability to pass children to other components.
    The parent component decides what is done with its children.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供的一个很棒的功能是能够将子组件传递给其他组件。父组件决定如何处理其子组件。
- en: Something that we are still missing is a good error message for our users. So,
    we will use this pattern to solve the issue.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少的是为我们的用户提供一个好的错误信息。因此，我们将使用这个模式来解决这个问题。
- en: 'Create an `error.js` file next to the `loading.js` file in the `components`
    folder, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `components` 文件夹中，在 `loading.js` 文件旁边创建一个 `error.js` 文件，如下所示：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When passing children to another component, a new property, called `children`,
    is added to the properties of the component. You specify `children` by writing
    normal React markup.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当将子组件传递给另一个组件时，会在组件的属性中添加一个新的属性，称为 `children`。你通过编写正常的 React 标记来指定 `children`。
- en: If you wanted to, you could perform actions, such as looping through each child.
    In our example, we render the children as usual, by using curly braces and putting
    the `children` variable inside.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想的话，你可以执行一些操作，比如遍历每个子组件。在我们的例子中，我们通过使用花括号并将 `children` 变量放在其中来按常规渲染子组件。
- en: 'To start using the new `Error` component, you can simply import it. The markup
    for the new component is shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用新的 `Error` 组件，你可以简单地导入它。新组件的标记如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add some CSS, and everything should be finished, as shown in the following
    code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些 CSS，一切应该就完成了，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A working result might look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作结果可能看起来像这样：
- en: '![Figure 5.1 – Error message'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 错误信息'
- en: '](img/Figure_5.01_B17337.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Figure_5.01_B17337.jpg)'
- en: Figure 5.1 – Error message
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 错误信息
- en: You can apply the stateless function pattern and the children pattern to many
    other use cases. Which one you use will depend on your specific scenario. In this
    case, you could also use a stateless function, rather than a React component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将无状态函数模式和子组件模式应用到许多其他用例中。你使用哪一个将取决于你的具体场景。在这种情况下，你也可以使用一个无状态函数，而不是 React
    组件。
- en: Next, we are going to have a look at how we can improve our code structure,
    together with the fundamentals that React is following.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何改进我们的代码结构，以及 React 遵循的基本原则。
- en: Structuring our React application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化我们的 React 应用程序
- en: We have already improved some things by using React patterns. You should do
    some homework and introduce those patterns wherever possible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用 React 模式改进了一些事情。你应该做一些作业，并在可能的地方引入这些模式。
- en: When writing applications, one key objective is to keep them modular and readable
    but also as understandable as possible. It is always hard to tell when splitting
    code up is useful and when it overcomplicates things. This is something that you
    will learn more and more about by writing as many applications and as much code
    as possible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写应用程序时，一个关键目标是保持它们模块化和可读性，同时尽可能易于理解。总是很难判断拆分代码是有用的还是使事情过于复杂。这是通过尽可能多地编写应用程序和代码，你会越来越多地了解的事情。
- en: Let's begin to structure our application further.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步结构化我们的应用程序。
- en: The React file structure
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 文件结构
- en: We have already saved our `Loading` and `Error` components in the `components`
    folder. Still, there are many parts of our components that we did not save in
    separate files to improve the readability of this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `Loading` 和 `Error` 组件保存在 `components` 文件夹中。然而，我们为了提高本书的可读性，并没有将组件的许多部分单独保存到不同的文件中。
- en: I will explain the most important solution for unreadable React code in one
    example. You can implement this on your own later for all other parts of our application,
    as you should not read duplicate code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过一个例子来解释不可读 React 代码的最重要解决方案。你可以在稍后自己实现这个解决方案，应用到我们应用的其它部分，因为你不应该阅读重复的代码。
- en: Currently, we render the posts in our feed by mapping through all posts from
    the GraphQL response. There, we directly render the corresponding markup for all
    post items. Therefore, it is one big render function that does everything at once.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们通过映射 GraphQL 响应中的所有帖子来在我们的动态中渲染帖子。在那里，我们直接渲染所有帖子项的相应标记。因此，这是一个一次性完成所有事情的庞大渲染函数。
- en: To make this a bit more intuitive, we should create a new `Post` component.
    Separating the components hugely improves the readability of our posts feed. Then,
    we can replace the return value from the loop with a new component, instead of
    real markup.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更加直观，我们应该创建一个新的`Post`组件。将组件分离极大地提高了我们帖子流的可读性。然后，我们可以用一个新的组件替换循环中的返回值，而不是真正的标记。
- en: 'Instead of creating a `post.js` file in our `components` folder, we should
    first create another `post` folder, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该在我们的`components`文件夹中创建一个`post.js`文件，而应该首先创建另一个`post`文件夹，如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Post` component consists of multiple tiny, nested components. A post is
    also a standalone GraphQL entity, making it logical to have a separate folder.
    We will store all related components in this folder.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`组件由多个小的嵌套组件组成。帖子也是一个独立的GraphQL实体，因此有一个单独的文件夹是合理的。我们将把所有相关的组件存储在这个文件夹中。'
- en: 'Let''s create those components. We will start with the post header, where the
    top part of a post item is defined. Create a new `header.js` file in the `components/post`
    folder, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这些组件。我们将从帖子头部开始，定义帖子项的顶部部分。在`components/post`文件夹中创建一个新的`header.js`文件，如下所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `header` component is just a functional component. As you can see, we are
    using a React pattern from the earlier pages of this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`header`组件只是一个函数组件。正如您所看到的，我们正在使用本章早期页面上的React模式。'
- en: 'Up next is the post content, which represents the body of a post item. Add
    the following code inside of a new file, called `content.js`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是帖子内容，它代表帖子项的主体。在名为`content.js`的新文件中添加以下代码：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code is pretty much the same as that of the post header. At later points,
    you will be free to introduce real React components or extended markup to those
    two files. It is entirely open to your implementation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与帖子头部的代码几乎相同。在后面的点，您将可以自由地在这两个文件中引入真实的React组件或扩展标记。这完全取决于您的实现。
- en: 'The main file is a new `index.js` file in the new `post` folder. It should
    look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主要文件是位于新`post`文件夹中的新`index.js`文件。它应该看起来像这样：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code represents a very basic component, but instead of directly
    using markup to render a complete post item (as we did before), we are using two
    further components for this, with `PostHeader` and `PostContent`. Both of the
    components receive `post` as a property.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码代表一个非常基本的组件，但与之前直接使用标记来渲染完整的帖子项目不同，我们在这里使用了两个进一步的组件，即`PostHeader`和`PostContent`。这两个组件都接收`post`作为属性。
- en: 'You can now use the new `Post` component in the feed list with ease. First,
    import the component, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以轻松地在帖子列表中使用新的`Post`组件。首先，按照以下方式导入组件：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The good thing when having an `index.js` file is that you can reduce the path
    by directly pointing to the folder and the `index.js` file will be picked up automatically.
    Then, just replace the old code inside the loop, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个`index.js`文件时，您可以减少路径，直接指向文件夹，`index.js`文件将被自动选中。然后，只需替换循环中的旧代码，如下所示：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The improvement is that all three of the components give you a clear overview
    at first glance. Inside of the loop, we return a post item. A post item consists
    of a header and body content.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 改进之处在于，所有三个组件在第一眼就能给您一个清晰的概述。在循环内部，我们返回一个帖子项。帖子项由标题和正文内容组成。
- en: Still, there is room for enhancement, because the posts feed list is cluttered.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍有改进的空间，因为帖子流列表很杂乱。
- en: Efficient Apollo React components
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效的Apollo React组件
- en: We have successfully replaced the post items in our feed with a React component,
    instead of raw markup.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将我们的帖子中的项目替换为React组件，而不是原始标记。
- en: A major part, which I dislike very much, is the way we define and pass the actual
    GraphQL query or mutation to the `useQuery` or `useMutation` Hook within the components.
    It would be good to define those GraphQL requests once and use them everywhere
    they are needed so that we can use them across different components.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常不喜欢的一个主要部分是我们定义和传递实际的GraphQL查询或突变到组件内的`useQuery`或`useMutation`钩子。如果能够一次性定义这些GraphQL请求并在需要的地方使用它们，那么我们就可以在不同的组件之间使用它们。
- en: Furthermore, not only should the pure GraphQL requests be reusable but the `update`
    function or the `optimisticResponse` object should also be reusable across different
    components.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不仅纯GraphQL请求应该是可重用的，而且`update`函数或`optimisticResponse`对象也应该可以在不同的组件之间重用。
- en: As an example, we will fix those issues for `Feed.js` in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将在下一节中解决`Feed.js`中的这些问题。
- en: Using fragments with Apollo
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Apollo的片段
- en: A GraphQL fragment is a functionality that allows you to share common queries
    or pieces of them between different bigger GraphQL queries. For example, if you
    have different GraphQL queries that request a `user` object and the data structure
    for this user is always the same, you can define a user fragment to reuse the
    same attributes across multiple different GraphQL requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL片段是一种功能，允许你在不同的更大的GraphQL查询之间共享常见的查询或其部分。例如，如果你有多个请求`user`对象的GraphQL查询，并且这个用户的数据结构始终相同，你可以定义一个用户片段，以便在多个不同的GraphQL请求中重用相同的属性。
- en: 'We will implement this for our `GET_POSTS` query. Follow the next instructions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`GET_POSTS`查询实现这一点。按照以下说明操作：
- en: 'Create a new `queries` folder and a `fragments` folder inside of the `apollo`
    folder, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`apollo`文件夹内创建一个新的`queries`文件夹和一个`fragments`文件夹，如下所示：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a file called `userAttributes.js` inside the `fragments` folder and
    fill in the following lines of code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`fragments`文件夹内创建一个名为`userAttributes.js`的文件，并填写以下代码行：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For all `user` objects that we have requested so far, we have always returned
    the username and the avatar image, as we always display the name in the user profile
    image. In the preceding code snippet, we implemented the matching GraphQL fragment,
    which we can now use in any other query where we want to request exactly this
    data.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们迄今为止请求的所有`user`对象，我们始终返回用户名和头像图片，因为我们总是在用户个人资料图片中显示名称。在前面的代码片段中，我们实现了匹配的GraphQL片段，我们现在可以在任何其他查询中使用它，以便请求确切的数据。
- en: 'Create a file called `getPosts.js` inside the `queries` folder. Add the following
    content to it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`queries`文件夹内创建一个名为`getPosts.js`的文件。向其中添加以下内容：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, we are making use of our newly created GraphQL
    fragment. Firstly, we of course import it at the top of the file. Inside the GraphQL
    query, we use the `…userAttributes` syntax, which is similar to the normal JavaScript
    destructuring assignment and spreads the fragment with the same name up to inject
    those properties at the specified location in the GraphQL query. The last step
    is to add a fragment below the actual query to be able to make use of it.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在使用我们新创建的GraphQL片段。首先，我们当然在文件顶部导入它。在GraphQL查询内部，我们使用`…userAttributes`语法，这与正常的JavaScript解构赋值类似，并将具有相同名称的片段展开，以便在GraphQL查询的指定位置注入这些属性。最后一步是在实际查询下方添加一个片段，以便能够使用它。
- en: 'The last step is to simply replace the old `GET_POSTS` variable that we have
    manually parsed inside the `Feed.js` file with this `import` statement:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将`Feed.js`文件中我们手动解析的旧`GET_POSTS`变量替换为这个`import`语句：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, we are successfully using the fragment within our main `GET_POSTS`
    query, which we also can reuse just by importing it into any other component.
    You can repeat this for all the other requests and, by doing so, reach a cleaner
    code structure and more reusability.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在主`GET_POSTS`查询中成功使用了片段，我们也可以通过将其导入任何其他组件来重用它。你可以对其他所有请求重复此操作，通过这样做，可以达到更清晰的代码结构和更高的可重用性。
- en: Reusing Apollo Hooks
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用Apollo Hooks
- en: We did a good job extracting the GraphQL query from our component into separate
    reusable files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功地从组件中提取了GraphQL查询到单独的可重用文件中。
- en: Still, we have some amount of logic in our component where we define how the
    `update` function and `optimisticResponse` object for the GraphQL mutations are
    handled. We can also extract these to further improve reusability and clear the
    code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们组件中仍有一些逻辑，用于定义如何处理GraphQL变异的`update`函数和`optimisticResponse`对象。我们也可以将这些提取出来，以进一步提高可重用性并清理代码。
- en: One problem with the use of the Apollo or React Hooks is that they need to be
    executed within the functional component. Still, we can save the biggest amount
    of the Hook configuration outside of the component to make them reusable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Apollo或React Hooks的一个问题是它们需要在功能组件内执行。尽管如此，我们可以将Hook配置的最大部分保存在组件外部，以便它们可重用。
- en: 'Follow the next instructions to accomplish this for the `addPost` mutation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明完成`addPost`变异：
- en: 'Create a new `mutations` folder inside the `apollo` folder, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`apollo`文件夹内创建一个新的`mutations`文件夹，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file called `addPost.js` and insert the following code into it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`addPost.js`的文件，并将以下代码插入其中：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The great thing is that we can reuse the fragment we have created before here,
    so we do not need to define it again.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 令人高兴的是，我们可以重用之前在这里创建的片段，因此我们不需要再次定义它。
- en: 'We can use this `ADD_POST` variable in the `Feed.js` file for our mutation.
    Replace the actual parsed GraphQL query with the following `import` statement:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`Feed.js`文件中使用这个`ADD_POST`变量来进行我们的突变。用以下`import`语句替换实际的解析GraphQL查询：
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We still have the `update` function and the `optimisticResponse` object within
    our `useMutation` Hook. It''s easiest to also move them to the `addPost.js` file,
    as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`useMutation`钩子中仍然有`update`函数和`optimisticResponse`对象。最简单的方法是将它们移动到`addPost.js`文件中，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are returning a function on import so that we can pass all required parameters.
    The only expected parameter is the `postContent` state variable, which is required
    for the `optimisticResponse` object.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在导入时返回一个函数，这样我们就可以传递所有必需的参数。唯一预期的参数是`postContent`状态变量，它是`optimisticResponse`对象所必需的。
- en: 'Update the `import` statement inside the `Feed.js` file again to also import
    the `getAddPostConfig` function, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次更新`Feed.js`文件中的`import`语句，同时导入`getAddPostConfig`函数，如下所示：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final `useState` Hook should then look like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的`useState`钩子应该看起来像这样：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We execute `getAddPostConfig` as the second parameter of the `useMutation` Hook.
    It will be filled with the returned object but will still have the `postContent`
    value inside the `optimisticResponse` object, as every time the value changes,
    the `getAddPostConfig` function will also be run.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`getAddPostConfig`作为`useMutation`钩子的第二个参数执行。它将被返回的对象填充，但仍然会在`optimisticResponse`对象中保留`postContent`值，因为每次值发生变化时，`getAddPostConfig`函数也会被运行。
- en: 'We can go even further. Add the following line of code to the `addPost.js`
    file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步。将以下代码行添加到`addPost.js`文件中：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will replace the plain `useMutation` Hook in our component and instead build
    a small wrapper around it. It will accept the `postContent` value to pass it further
    to the `getAddPostConfig` function. The advantage will be that we can just import
    the `useAddPostMutation` function and, after executing it, all default configurations
    are applied and we are able to use that inside any component without having to
    import the query, the configuration, and the `useMutation` Hook separately.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在我们的组件中替换普通的`useMutation`钩子，并围绕它构建一个小包装器。它将接受`postContent`值，并将其传递给`getAddPostConfig`函数。优势在于我们只需导入`useAddPostMutation`函数，执行它之后，所有默认配置都会应用，我们可以在任何组件中使用它，而无需单独导入查询、配置和`useMutation`钩子。
- en: 'Change the import of the `addPost.js` file inside the `Feed.js` file, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式更改`Feed.js`文件中`addPost.js`文件的导入：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Replace the `useMutation` Hook with the following line of code and remove the
    `useMutation` import while doing so:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码行替换`useMutation`钩子，并在这样做的同时删除`useMutation`导入：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We only need to import one function to get the full-fledged `addPost` mutation
    running in any component we want it to be in. This concept will work with any
    query or mutations we have used so far.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需要导入一个函数，就可以在任何我们想要的组件中运行完整的`addPost`突变。这个概念可以与迄今为止我们使用的任何查询或突变一起工作。
- en: We cleaned up the functional component from most of the GraphQL request logic
    and have it in separate files now. We can use the query or the mutation at any
    location where we need them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清理了功能组件的大部分GraphQL请求逻辑，现在它已经在单独的文件中。我们可以在需要查询或突变的地方使用它们。
- en: I recommend that you repeat the same for all other locations so that you have
    a nicely filled set of GraphQL requests that we are able to reuse anywhere we
    want. This would be a good homework exercise to learn that concept.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你为所有其他位置重复相同的操作，这样你就有了一个很好地填充的GraphQL请求集，我们可以在任何需要的地方重用。这将是一个很好的家庭作业练习，以学习这个概念。
- en: Next, we will have a look at how we can extend Graphbook.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何扩展Graphbook。
- en: Extending Graphbook
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Graphbook
- en: Our social network is still a bit rough. Aside from the fact that we are still
    missing authentication, all of the features are pretty basic; writing and reading
    the posts and messages is nothing exceptional.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的社会网络仍然有点粗糙。除了我们仍然缺少身份验证之外，所有功能都很基础；撰写和阅读帖子及消息并不特别。
- en: 'If you compare it to Facebook, there are many things that we need to do. Of
    course, we cannot rebuild Facebook in its totality, but the usual features should
    be there. From my point of view, we should cover the following features:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与Facebook进行比较，我们还有很多事情要做。当然，我们不可能完全重建Facebook，但通常的功能应该都有。从我的观点来看，我们应该涵盖以下功能：
- en: Adding a drop-down menu to the posts to allow deletion of posts.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在帖子中添加下拉菜单以允许删除帖子。
- en: Creating a global `user` object with the React Context API.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Context API 创建一个全局的 `user` 对象。
- en: Using Apollo cache as an alternative to the React Context API.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo 缓存作为 React Context API 的替代方案。
- en: Implementing a top bar as the first component rendered above all of the views.
    We can search for users in our database from a search bar, and we can show the
    logged-in user from the global `user` object.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现顶部栏作为第一个渲染在所有视图之上的组件。我们可以从搜索栏中搜索数据库中的用户，并且我们可以从全局 `user` 对象中显示已登录用户。
- en: We will begin by looking at the first feature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看第一个功能。
- en: The React context menu
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 上下文菜单
- en: You should be able to write the React context menu pretty much on your own.
    All the required React patterns have been explained, and implementing the mutations
    should be clear by now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够几乎独立地编写 React 上下文菜单。所有必需的 React 模式都已解释，并且实现突变现在应该很清晰。
- en: 'Before we begin, we will lay out the plan that we want to follow. We''ll aim
    to do this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将制定我们想要遵循的计划。我们的目标是：
- en: Render a simple icon with Font Awesome
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Font Awesome 渲染简单的图标
- en: Build React helper components
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 React 辅助组件
- en: Handle the `onClick` event and set the correct component state
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `onClick` 事件并设置正确的组件状态
- en: Use the conditional rendering pattern to show the drop-down menu, if the component
    state is set correctly
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件渲染模式来显示下拉菜单，如果组件状态设置正确
- en: Add buttons to the menu and bind mutations to them
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向菜单中添加按钮并将突变绑定到它们上
- en: Continue reading to find out how to get the job done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读以了解如何完成任务。
- en: 'The following is a preview screenshot, showing how the final implemented feature
    should look:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个预览截图，显示了最终实现的功能应该看起来像什么：
- en: '![Figure 5.2 – Drop-down with context'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.2 – Drop-down with context'
- en: '](img/Figure_5.02_B17337.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.02_B17337.jpg](img/Figure_5.02_B17337.jpg)'
- en: Figure 5.2 – Drop-down with context
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 带上下文的下拉菜单
- en: We will now start with the first task of setting up Font Awesome for our project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始第一个任务，为我们的项目设置 Font Awesome。
- en: Font Awesome in React
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React 中的 Font Awesome
- en: 'As you may have noticed, we have not installed Font Awesome yet. Let''s fix
    this with `npm`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，我们尚未安装 Font Awesome。让我们用 `npm` 来解决这个问题，如下所示：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Graphbook relies on the preceding four packages to import the Font Awesome icons
    into our frontend code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Graphbook 依赖于前面的四个包将 Font Awesome 图标导入到我们的前端代码中。
- en: Important Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Font Awesome provides multiple configurations for use with React. The best,
    most production-ready approach is to import only the icons that we are explicitly
    going to use. For your next project or prototype, it might make sense to get started
    with the simplest approach. You can find all of the information on the official
    page, at [https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react](https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 为与 React 一起使用提供了多种配置。最佳、最适用于生产的方案是仅导入我们明确将要使用的图标。对于您的下一个项目或原型，从最简单的方法开始可能是有意义的。您可以在官方页面找到所有信息，链接为
    [https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react](https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react)。
- en: 'Creating a separate file for Font Awesome will help us to have a clean import.
    Save the following code under the `fontawesome.js` file, inside of the `components`
    folder:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Font Awesome 创建一个单独的文件将帮助我们有一个干净的导入。将以下代码保存到 `fontawesome.js` 文件中，位于 `components`
    文件夹内：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we import the `library` object from the Font Awesome core package. For
    our specific use case, we only need one arrow image, called `angle-down`. Using
    the `library.add` function, we register this icon for later use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 Font Awesome 核心包中导入 `library` 对象。对于我们的特定用例，我们只需要一个箭头图像，称为 `angle-down`。使用
    `library.add` 函数，我们将此图标注册以供以后使用。
- en: Important Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are many versions of Font Awesome. In this book, we are using Font Awesome
    5, with free icons only. More premium icons can be bought on the official Font
    Awesome web page. You can find an overview of all of the icons, and a detailed
    description of each, in the icon gallery at [https://fontawesome.com/icons?d=gallery](https://fontawesome.com/icons?d=gallery).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 有许多版本。在这本书中，我们使用 Font Awesome 5，仅包含免费图标。更多高级图标可以在官方 Font Awesome
    网页上购买。您可以在图标库中找到所有图标的概述，以及每个图标的详细描述，链接为 [https://fontawesome.com/icons?d=gallery](https://fontawesome.com/icons?d=gallery)。
- en: 'The only place where we need this file is within our root `App.js` file. It
    ensures that all of our custom React components can display the imported icons.
    Add the following `import` statement to the top of the file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在根`App.js`文件中放置这个文件。这确保了所有自定义的React组件都可以显示导入的图标。请将以下`import`语句添加到文件顶部：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: No variable is required to save the exported methods since there won't be any.
    We want to execute this file in our application only once.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不会有任何变量来保存导出的方法，因此不需要任何变量。我们只想在我们的应用程序中执行这个文件一次。
- en: When you reach a point where your application needs a complete set of icons,
    you can get all the icons grouped directly from the `@fortawesome/free-brands-svg-icons`
    package, which we also installed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序需要一套完整的图标时，你可以直接从`@fortawesome/free-brands-svg-icons`包中获取所有图标，这个包我们也已经安装了。
- en: Next, we are going to create a `Dropdown` helper component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`Dropdown`辅助组件。
- en: React helper components
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React辅助组件
- en: Production-ready applications need to be as polished as possible. Implementing
    reusable React components is one of the most important things to do.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于生产的应用程序需要尽可能完美。实现可重用的React组件是必须做的事情之一。
- en: You should notice that drop-down menus are a common topic when building client-side
    applications. They are global parts of the frontend and appear everywhere throughout
    our components.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，当构建客户端应用程序时，下拉菜单是一个常见的话题。它们是前端的全局部分，出现在我们的组件的各个地方。
- en: It would be best to separate the actual menu markup that we want to display
    from the code, which handles the event-binding and shows the menu.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将我们想要显示的实际菜单标记代码与处理事件绑定和显示菜单的代码分开。
- en: I always call this kind of code in React **helper components**. They are not
    implementing any business logic but give us the opportunity to reuse drop-down
    menus or other features wherever we want.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是将这类代码称为React中的**辅助组件**。它们不实现任何业务逻辑，但给我们提供了在需要的地方重用下拉菜单或其他功能的机会。
- en: 'Logically, the first step is to create a new folder to store all of the helper
    components, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，第一步是创建一个新的文件夹来存储所有辅助组件，如下所示：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new file, called `dropdown.js`, as the helper component, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`dropdown.js`的新文件，作为辅助组件，如下所示：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We do not require much code to write a drop-down component. It is also pretty
    efficient since this works with nearly every scenario that you can think of.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 编写下拉组件不需要很多代码。它也非常高效，因为它几乎适用于你能想到的每一种场景。
- en: We use basic event handling in the preceding code snippet. When the trigger
    `div` tag is clicked, we update the `show state` variable. Inside of the `div`
    trigger, we also render a property called `trigger`. A `trigger` property can
    be anything from regular text or an HTML tag to a React component. It can be passed
    through the parent components in order to customize the look of the drop-down
    component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了基本的的事件处理。当触发`div`标签被点击时，我们更新`显示状态`变量。在`div`触发器内部，我们还渲染了一个名为`trigger`的属性。`trigger`属性可以是普通文本、HTML标签，甚至是React组件。它可以通过父组件传递，以便自定义下拉组件的外观。
- en: 'In addition to the `trigger` property, we are using two well-known React patterns,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`trigger`属性外，我们还使用了两个著名的React模式，如下所示：
- en: Conditional rendering when the `show` variable is `true`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`show`变量为`true`时的条件渲染
- en: Rendering children given by the parent component
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染由父组件提供的子元素
- en: This solution allows us to fill in the menu items that we want to render directly
    as children of the `Dropdown` component, which, as mentioned previously, is displayed
    after clicking on the trigger. In this case, the `show` state variable is `true`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案允许我们直接将我们想要渲染的菜单项作为`Dropdown`组件的子元素填充，正如之前提到的，这是在点击触发器后显示的。在这种情况下，`show`状态变量为`true`。
- en: However, one thing is still not completely correct here. If you test the drop-down
    component by providing simple text or an icon as a trigger and other text as the
    content, you should see that the `Dropdown` component only closes when clicking
    on the trigger again; it does not close when clicking anywhere else in our browser,
    outside of the drop-down menu.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里仍有一件事不完全正确。如果你通过提供简单的文本或图标作为触发器，以及其他文本作为内容来测试下拉组件，你应该会看到`Dropdown`组件只有在再次点击触发器时才会关闭；点击浏览器中的其他地方（下拉菜单之外）时不会关闭。
- en: This is one scenario where the React approach encounters problems. There is
    no DOM Node event such as `useOutsideClick`, so we cannot directly listen to the
    outside click events of any DOM Node, such as our drop-down menu. The conventional
    approach is to bind an event listener to the complete document. Clicking anywhere
    in our browser closes the drop-down menu.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种React方法遇到问题的场景。没有DOM节点事件，例如`useOutsideClick`，因此我们无法直接监听任何DOM节点的外部点击事件，例如我们的下拉菜单。传统的方法是将事件监听器绑定到整个文档上。在我们的浏览器中点击任何地方都会关闭下拉菜单。
- en: The `useOutSideClick` Hook just checks if the clicked element matches the reference
    that we set up through the `useRef` Hook.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`useOutSideClick`钩子仅检查点击的元素是否与我们通过`useRef`钩子设置的引用匹配。'
- en: When clicking on the trigger button, we add the click event listener to the
    whole document with the `addEventListener` function of JavaScript.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击触发按钮时，我们使用JavaScript的`addEventListener`函数将点击事件监听器添加到整个文档中。
- en: Important Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are many cases where it might make sense to leave the React approach and
    use the DOM directly, through the standard JavaScript interface.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，可能有必要放弃React方法，直接通过标准的JavaScript接口使用DOM。
- en: 'Read this article on *Medium* to get a better understanding: [https://medium.com/@garrettmac/reactjs-how-to-safely-manipulate-the-dom-when-reactjs-cant-the-right-way-8a20928e8a6](https://medium.com/@garrettmac/reactjs-how-to-safely-manipulate-the-dom-when-reactjs-cant-the-right-way-8a20928e8a6).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这篇关于*Medium*的文章，以获得更好的理解：[https://medium.com/@garrettmac/reactjs-how-to-safely-manipulate-the-dom-when-reactjs-cant-the-right-way-8a20928e8a6](https://medium.com/@garrettmac/reactjs-how-to-safely-manipulate-the-dom-when-reactjs-cant-the-right-way-8a20928e8a6)。
- en: The `useEffect` Hook is executed only on first rendering of the component. You
    can execute any kind of logic there. If the return value is a function too, this
    function will be executed on unmount of the component. By doing that, we do not
    forget to remove all the manually created event listeners whenever the component
    is unmounted and removed from the DOM. Forgetting this can lead to many errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子仅在组件首次渲染时执行。你可以在那里执行任何类型的逻辑。如果返回值也是一个函数，那么这个函数将在组件卸载时执行。通过这样做，我们不会忘记在组件卸载和从DOM中移除时移除所有手动创建的事件监听器。忘记这一点可能会导致许多错误。'
- en: As mentioned previously, this is the part where React fails at least a little
    bit, although it is not the fault of React. The DOM and JavaScript do not have
    the right abilities.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是React至少有点失败的地方，尽管这不是React的错。DOM和JavaScript没有正确的功能。
- en: We can finally use our helper component and display the context menus for posts,
    but first, we need to prepare all of the menu items and components that we want
    to render.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以使用我们的辅助组件并显示帖子的上下文菜单，但首先，我们需要准备所有我们想要渲染的菜单项和组件。
- en: The Apollo deletePost mutation
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apollo的`deletePost`突变
- en: A mutation is always located at two points in our code. One part is written
    inside of our GraphQL API in the backend, and the other one is written in our
    frontend code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 突变始终位于我们的代码的两个位置。一部分是在后端的GraphQL API中编写的，另一部分是在我们的前端代码中编写的。
- en: 'We should start with the implementation on the backend side, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从后端实现开始，如下所示：
- en: 'Edit the GraphQL schema. The `deletePost` mutation needs to go inside of the
    `RootMutation` object. The new `Response` type serves as a return value, as deleted
    posts cannot be returned because they do not exist. Note in the following code
    snippet that we only need the `postId` parameter and do not send the complete
    post:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑GraphQL模式。`deletePost`突变需要放在`RootMutation`对象内部。新的`Response`类型作为返回值，因为已删除的帖子无法返回，因为它们不存在。注意以下代码片段中我们只需要`postId`参数，不需要发送完整的帖子：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the missing GraphQL resolver function. The `destroy` function of Sequelize
    only returns a number that represents the number of deleted rows. We return an
    object with the `success` field. This field indicates whether our frontend should
    throw an error. The code is illustrated in the following snippet:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加缺失的GraphQL解析器函数。Sequelize的`destroy`函数仅返回一个表示已删除行数的数字。我们返回一个包含`success`字段的对象。该字段指示我们的前端是否应该抛出错误。代码在以下片段中说明：
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The only special thing here is that we need to specify which posts we want to
    delete. This is done by having the `where` property inside of the function call.
    Because we currently do not have authentication implemented yet, we cannot verify
    the user deleting the post, but for our example, this is no problem.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里唯一特殊的事情是我们需要指定我们想要删除哪些帖子。这是通过在函数调用中包含`where`属性来完成的。因为我们目前还没有实现身份验证，所以我们无法验证删除帖子的用户，但在我们的例子中，这没有问题。
- en: In short, our GraphQL API is now able to accept the `deletePost` mutation. We
    do not verify which user sends this mutation, so for our example, posts can be
    deleted by anyone.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们的GraphQL API现在能够接受`deletePost`突变。我们不验证发送此突变的用户，所以在我们这个例子中，任何人都可以删除帖子。
- en: We can now focus on the frontend again.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以再次专注于前端了。
- en: Recall how we implemented the previous mutations; we always created reusable
    functions and configurations for them. We should do the same for the `delete`
    mutation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们如何实现之前的突变；我们总是为它们创建可重用的函数和配置。我们也应该为`delete`突变做同样的事情。
- en: 'Let''s start by implementing the `deletePost` mutation for the client, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为客户端实现`deletePost`突变开始，如下所示：
- en: Create a new file, called `deletePost.js`, inside of the `mutations` folder.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mutations`文件夹内创建一个名为`deletePost.js`的新文件。
- en: 'Import all the dependencies, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下说明导入所有依赖项：
- en: '[PRE37]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the new `deletePost` mutation, as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的`deletePost`突变，如下所示：
- en: '[PRE38]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add a new function to handle the configuration of the mutation, as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的函数来处理突变的配置，如下所示：
- en: '[PRE39]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To remove an item, we need to clean the array from the post with the given `postId`
    value. The easiest way to do that is to return the complete object of `postsFeed`,
    and while doing so, we let the normal JavaScript `filter` function return only
    those posts not having the `postId` value inside. To read the `readField` function
    given by Apollo.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要删除一个项目，我们需要从具有给定`postId`值的帖子中清理数组。最简单的方法是返回`postsFeed`的完整对象，同时在这个过程中，我们让正常的JavaScript
    `filter`函数只返回那些没有`postId`值的帖子。为了读取Apollo提供的`readField`函数。
- en: 'Lastly, insert the wrapper function for the `useMutation` Hook, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，插入`useMutation` Hook的包装函数，如下所示：
- en: '[PRE40]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I have removed the `optimisticResponse` update for the **user interface** (**UI**)
    since it is not intuitive if the request fails because then the UI would first
    show an optimistic update, but under failure, put the post back again as the API
    call failed. This would make your post disappear and reappear again.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经移除了`optimisticResponse`更新，因为如果请求失败，它不直观，因为那时UI会首先显示乐观更新，但在失败的情况下，帖子会再次出现，因为API调用失败了。这会使你的帖子消失然后再次出现。
- en: 'We need to add our drop-down menu to the post header with a new item so that
    we can call the `deletePost` mutation. Follow these instructions to add it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在帖子标题中添加一个新的下拉菜单项，以便我们可以调用`deletePost`突变。按照以下说明添加它：
- en: 'Open the `header.js` file and import the drop-down component, `fontawesome`,
    and the mutation, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`header.js`文件并导入下拉组件、`fontawesome`和突变，如下所示：
- en: '[PRE41]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the `useDeletePostMutation` Hook before the `return` statement, as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return`语句之前运行`useDeletePostMutation` Hook，如下所示：
- en: '[PRE42]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the new button to our header beneath the `div` tag with the username, like
    this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新按钮添加到包含用户名的`div`标签下的标题中，如下所示：
- en: '[PRE43]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The overall solution is very simple. We have a wrapping drop-down component.
    All children will be only rendered if the `show` state variable is changed. This
    includes our `deletePost` mutation and triggers on click. The mutation itself
    is separated from the actual code to render the view.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 整体解决方案非常简单。我们有一个包装的下拉组件。所有子组件只有在`show`状态变量改变时才会渲染。这包括我们的`deletePost`突变和点击触发。突变本身与实际渲染视图的代码是分开的。
- en: You can get the correct CSS from the GitHub repository.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub仓库中获取正确的CSS。
- en: We have now covered the retrieval and deletion of posts. The update of posts
    is more or less the same—instead of adding or removing, you need to update the
    post not only via its ID in the database but also in the Apollo cache. The approach
    is the same, though.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了帖子的检索和删除。帖子的更新基本上是相同的——而不是添加或删除，你需要通过数据库中的ID以及Apollo缓存来更新帖子。方法是一样的。
- en: I expect that you are now prepared for advanced scenarios, where communication
    between multiple components on different layers is required. Consequently, when
    starting the server and client, you should be presented with the preview image
    that I gave you when starting this section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计你现在已经准备好处理高级场景了，在这些场景中，需要在不同层之间进行多个组件的通信。因此，当启动服务器和客户端时，你应该看到我在这部分开始时给你提供的预览图像。
- en: To get some more practice, we will repeat this for another use case in the next
    section.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更多的实践，我们将在下一节中为另一个用例重复这个过程。
- en: The React application bar
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 应用程序栏
- en: In contrast with Facebook, we do not have an outstanding application bar. The
    plan is to implement something similar. It is fixed to always stay at the top
    of the browser window, above all parts of the Graphbook. You will be able to search
    for other users, see notifications, and see the logged-in user inside the application
    bar, after going through this section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Facebook 相比，我们没有一个突出的应用程序栏。计划是实现类似的功能。它固定在浏览器窗口的顶部，始终位于 Graphbook 的所有部分之上。在完成本节后，你将能够在应用程序栏中搜索其他用户、查看通知以及查看已登录用户。
- en: The first thing that we will implement is a simple search for users because
    it is complex.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现一个简单的用户搜索功能，因为它很复杂。
- en: 'The following screenshot shows a preview of what we are going to build:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将要构建的预览：
- en: '![Figure 5.3 – Search results'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.3 – Search results]'
- en: '](img/Figure_5.03_B17337.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.03_B17337.jpg]'
- en: Figure 5.3 – Search results
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.3 – Search results]'
- en: It looks basic, but what we are doing here is binding the `onChange` event of
    an input and refetching the query every time the value changes. Logically, this
    rerenders the search list in accordance with the responses from our GraphQL API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很基础，但我们在这里所做的是绑定输入的 `onChange` 事件，并在每次值变化时重新获取查询。从逻辑上讲，这将根据我们 GraphQL API
    的响应重新渲染搜索列表。
- en: Starting with the API, we need to introduce a new entity.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 开始，我们需要引入一个新的实体。
- en: Just as with our `postsFeed` query, we will set up pagination from the beginning,
    because later, we might want to offer more advanced functionalities, such as loading
    more items while scrolling through the search list.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 `postsFeed` 查询一样，我们从一开始就设置分页，因为以后我们可能想要提供更高级的功能，例如在滚动搜索列表时加载更多项目。
- en: 'Edit the GraphQL schema and fill in the new `RootQuery` property and type,
    as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 GraphQL 模式，并填写新的 `RootQuery` 属性和类型，如下所示：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `UsersSearch` type expects one special parameter, which is the search text.
    Without the text parameter, the request would not make much sense. You should
    remember the `page` and `limit` parameters from the `postsFeed` pagination.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersSearch` 类型期望一个特殊参数，即搜索文本。没有文本参数，请求就没有太多意义。你应该记得从 `postsFeed` 分页中来的 `page`
    和 `limit` 参数。'
- en: 'Furthermore, the `resolver` function looks pretty much the same as the `postsFeed`
    resolver function. You can add the following code straight into the `resolvers.js`
    file in the `RootQuery` property, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`resolver` 函数看起来几乎与 `postsFeed` resolver 函数相同。你可以直接将以下代码添加到 `resolvers.js`
    文件中的 `RootQuery` 属性，如下所示：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You should note that the first condition asks whether the provided text is larger
    than three characters. We do this to avoid sending too many unnecessary queries
    to our database. Searching for every user where the username consists of just
    one or two characters would result in providing us with nearly every user. Of
    course, this could have been done on the frontend, too, but various clients could
    use our API, so we need to make sure that the backend makes this small improvement
    as well.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，第一个条件询问提供文本是否大于三个字符。我们这样做是为了避免向我们的数据库发送过多的不必要查询。搜索仅由一个或两个字符组成的用户名会导致我们几乎提供所有用户的信息。当然，这也可以在前端完成，但由于各种客户端可能会使用我们的API，所以我们需要确保后端也进行这项小的改进。
- en: 'We send the `query` object to our database through Sequelize. The code works
    pretty much like the `postsFeed` resolver function from before, except that we
    are using a Sequelize operator. We want to find every user where the username
    includes the entered text, without specifying whether it is at the start, middle,
    or end of the name. Consequently, we will use the `Op.like` operator, which Sequelize
    parses into a pure `LIKE` query, giving us the results we want. The `%` operator
    is used in MySQL to represent an unspecified number of characters. To enable this
    operator, we must import the `sequelize` package and extract the `Op` object from
    it, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Sequelize将`query`对象发送到我们的数据库。代码基本上与之前的`postsFeed`解析函数类似，只是我们在这里使用了一个Sequelize运算符。我们想要找到每个用户名中包含输入文本的用户，而不指定它是在名称的开始、中间还是末尾。因此，我们将使用`Op.like`运算符，Sequelize将其解析为一个纯`LIKE`查询，从而得到我们想要的结果。`%`运算符在MySQL中用于表示任意数量的字符。为了启用此运算符，我们必须导入`sequelize`包并从中提取`Op`对象，如下所示：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Going further, we can implement the client-side code, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们可以实现客户端代码，如下所示：
- en: 'Create a file called `searchQuery.js` within the `queries` folder and insert
    the following code into it:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`queries`文件夹内创建一个名为`searchQuery.js`的文件，并将以下代码插入其中：
- en: '[PRE47]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only required parameter is the `text` parameter that we want to pass to
    our search. If the `text` parameter is shorter than three characters, we are passing
    a `skip` property either with `true` or `false` to not execute the GraphQL request.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一必需的参数是我们想要传递给搜索的`text`参数。如果`text`参数的长度少于三个字符，我们将传递一个带有`true`或`false`的`skip`属性，以不执行GraphQL请求。
- en: 'Continuing with our plan, we will create an application bar in a separate file.
    Create a new folder, called `bar`, below the `components` folder and the `index.js`
    file. Fill it in with the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照我们的计划，我们将在单独的文件中创建一个应用程序栏。在`components`文件夹和`index.js`文件下方创建一个新的文件夹，命名为`bar`。用以下代码填充它：
- en: '[PRE48]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This file works as a wrapper for all of the components we want to render in
    the application bar; it does not implement any custom logic. We have already imported
    the `SearchBar` component that we must create.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件作为我们想要在应用程序栏中渲染的所有组件的包装器；它不实现任何自定义逻辑。我们已导入必须创建的`SearchBar`组件。
- en: 'The `SearchBar` component lives inside of a separate file. Just create a `search.js`
    file in the `bar` folder, as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SearchBar`组件位于一个单独的文件中。只需在`bar`文件夹中创建一个`search.js`文件，如下所示：'
- en: '[PRE49]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are storing the current input value inside of a state variable, called `text`.
    Every time the text is changed, the `useUserSearchQuery` Hook is executed again
    with the new `text` parameter. Inside of the query Hook, the value is merged into
    the variables and sent with a GraphQL request. The result is then handed over
    to the `SearchList` component inside the `data` property if the request is not
    loading and did not have any error.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将当前输入值存储在名为`text`的状态变量中。每次文本更改时，`useUserSearchQuery`钩子都会再次执行，并带有新的`text`参数。在查询钩子内部，该值合并到变量中，并通过GraphQL请求发送。如果请求未加载且没有错误，则将结果传递给`SearchList`组件的`data`属性。
- en: 'Next, we will implement the `SearchList` component. This behaves like the posts
    feed, but only renders something if a response is given with at least one user.
    The list is displayed as a drop-down menu and is hidden whenever the browser window
    is clicked on. Create a file called `searchList.js` inside of the `bar` folder,
    with the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`SearchList`组件。这个组件的行为类似于帖子源，但只有当响应至少包含一个用户时才渲染内容。列表以下拉菜单的形式显示，并在点击浏览器窗口时隐藏。在`bar`文件夹内创建一个名为`searchList.js`的文件，并插入以下代码：
- en: '[PRE50]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We are using the `useEffect` Hook here with the dependency on `users`, which
    is executed whenever the parent component sets new properties on the current one.
    In this case, we check whether the properties include at least one user, and then
    set the state accordingly, in order to make the drop-down menu visible. The drop-down
    menu is hidden when clicked on or when an empty result is given. The approach
    is very similar to the drop-down for the post.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用带有`users`依赖项的`useEffect`钩子，它会在父组件对当前组件设置新属性时执行。在这种情况下，我们检查属性是否至少包含一个用户，然后相应地设置状态，以便使下拉菜单可见。当点击或提供空结果时，下拉菜单会被隐藏。这种方法与帖子下拉菜单非常相似。
- en: 'There are just two things to do now, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需做两件事，如下所示：
- en: You should copy the CSS from the official GitHub repository of this chapter
    in order to get the correct styling, or you can do it on your own.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该复制本章官方 GitHub 仓库中的 CSS，以获取正确的样式，或者您可以自己完成。
- en: You need to import the bar wrapper component inside of the `App` class and render
    it between React Helmet and the news feed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要在 `App` 类内部导入 bar 包装组件，并在 React Helmet 和新闻源之间渲染它。
- en: The first feature of our application bar is now complete.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序栏的第一个功能现在已经完成。
- en: Let's continue and take a look at React's Context API, the Apollo Consumer feature,
    and how to store data globally in our React frontend.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看 React 的 Context API、Apollo Consumer 功能以及如何在我们的 React 前端中全局存储数据。
- en: The React Context API versus Apollo Consumer
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React Context API 与 Apollo Consumer 对比
- en: There are two ways to handle global variables in the stack that we are using
    at the moment. These are through the new React Context API and the Apollo Consumer
    functionality.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们目前使用的堆栈中处理全局变量的两种方法是：通过新的 React Context API 和 Apollo Consumer 功能。
- en: Important Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are further ways to handle global state management. One of the most famous
    libraries is Redux, but there are many more. As an explanation of Redux would
    outreach the topic of this book, we are only focusing on the tools provided by
    React and Apollo.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 处理全局状态管理还有其他方法。其中最著名的库是 Redux，但还有更多。由于 Redux 的解释会超出本书的主题，我们只关注 React 和 Apollo
    提供的工具。
- en: 'If you want to check other ways, have a look at Redux''s website: [https://redux.js.org/](https://redux.js.org/).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查其他方法，请查看 Redux 的网站：[https://redux.js.org/](https://redux.js.org/)。
- en: From version 16.3 of React, there is a Context API that allows you to define
    global providers offering data through deeply nested components. These components
    do not require your application to hand over the data through many components,
    from the top to the bottom of the React tree. Instead, it uses so-called consumers
    and providers. These are useful when you set up the `user` object at a global
    point of your application, and you can access it from anywhere. In earlier versions
    of React, you needed to pass the property down from component to component to
    get it to the correct component at the bottom of the React component tree. This
    passing of properties through multiple layers of components is also called "prop
    drilling."
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从 React 的 16.3 版本开始，有一个 Context API 允许您定义全局提供者，通过深度嵌套的组件提供数据。这些组件不需要您的应用程序通过多个组件从上到下传递数据。相反，它使用所谓的消费者和提供者。当您在应用程序的全球位置设置
    `user` 对象时，这些非常有用，您可以从任何地方访问它。在 React 的早期版本中，您需要从组件到组件传递属性，以便将其传递到 React 组件树底部的正确组件。通过多个组件层传递属性也称为“属性钻取”。
- en: An alternative approach to the React Context API is the Apollo Consumer feature,
    which is a specific implementation for Apollo. The React Context API is a general
    way of doing things, for Apollo or anything else that you can imagine.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: React Context API 的另一种方法是 Apollo Consumer 功能，这是 Apollo 的特定实现。React Context API
    是一种通用的做事方式，适用于 Apollo 或您能想到的任何其他东西。
- en: The great thing about the Apollo Consumer component is that it enables you to
    access the Apollo cache and use it as data storage. Using the Apollo Consumer
    component saves you from handling all the data, and you are also not required
    to implement the provider itself; you can consume the data wherever you want.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Consumer 组件的伟大之处在于，它使您能够访问 Apollo 缓存并将其用作数据存储。使用 Apollo Consumer 组件可以节省您处理所有数据，并且您也不需要实现提供者本身；您可以在任何想要的地方消费数据。
- en: 'Both approaches will result in the following output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会产生以下输出：
- en: '![Figure 5.4 – User profile in the top bar'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.4 – 顶部栏中的用户资料'
- en: '](img/Figure_5.04_B17337.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.04_B17337.jpg]'
- en: Figure 5.4 – User profile in the top bar
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 顶部栏中的用户资料
- en: The best option is to show you the two alternatives right away so that you can
    identify your preferred method.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的办法是立即向您展示这两种替代方案，以便您可以确定您首选的方法。
- en: The React Context API
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React Context API
- en: We will start with the React method for storing and accessing global data in
    your frontend.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 React 方法开始，介绍如何在您的前端存储和访问全局数据。
- en: 'Here is a short explanation of this method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对这种方法的一个简短说明：
- en: '**Context**: This is a React approach for sharing data between components,
    without having to pass it through the complete tree.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这是一种 React 方法，用于在组件之间共享数据，而无需通过整个树传递。'
- en: '**Provider**: This is a global component, mostly used at just one point in
    your code. It enables you to access the specific context data.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：这是一个全局组件，通常只在代码中的一个位置使用。它使您能够访问特定的上下文数据。'
- en: '**Consumer**: This is a component that can be used at many different points
    in your application, reading the data behind the context that you are referring
    to.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：这是一个可以在应用程序的许多不同位置使用的组件，可以读取您所引用的上下文背后的数据。'
- en: To get started, create a folder called `context` below the `components` folder.
    In that folder, create a `user.js` file, where we can set up the Context API.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，在 `components` 文件夹下创建一个名为 `context` 的文件夹。在那个文件夹中，创建一个 `user.js` 文件，我们可以设置
    Context API。
- en: 'We will go over every step, one by one, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个步骤进行，如下所示：
- en: 'As always, we need to import all of the dependencies. Furthermore, we will
    set up a new empty context. The `createContext` function will return one provider
    and consumer to use throughout the application, as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要导入所有依赖项。此外，我们将设置一个新的空上下文。`createContext` 函数将返回一个提供者和消费者，在整个应用程序中使用，如下所示：
- en: '[PRE51]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we want to use the provider. The best option here is to create a special
    `UserProvider` component. Later, when we have authentication, we can adjust it
    to do the GraphQL query, and then share the resultant data in our frontend. For
    now, we will stick with fake data. Insert the following code:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要使用提供者。这里最好的选择是创建一个特殊的 `UserProvider` 组件。稍后，当我们有身份验证时，我们可以调整它以执行 GraphQL
    查询，然后在我们的前端共享结果数据。现在，我们将坚持使用假数据。插入以下代码：
- en: '[PRE52]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding code snippet, we render the `Provider` component from Apollo
    and wrap all the children in it. There is a `Consumer` component that reads from
    the `Provider`. We will set up a special `UserConsumer` component that takes care
    of passing the data to the underlying components by cloning them with React''s
    `cloneElement` function, as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从 Apollo 渲染 `Provider` 组件，并将所有子组件包裹在其中。有一个 `Consumer` 组件从 `Provider`
    中读取。我们将设置一个特殊的 `UserConsumer` 组件，通过使用 React 的 `cloneElement` 函数克隆它们，将数据传递给底层组件，如下所示：
- en: '[PRE53]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We will export both classes directly under their names.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接按其名称导出这两个类。
- en: 'We need to introduce the provider at an early point in our code base. The best
    approach is to import the `UserProvider` component into the `App.js` file, as
    follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在代码库的早期引入提供者。最佳方法是将 `UserProvider` 组件导入到 `App.js` 文件中，如下所示：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Use the provider as follows, and wrap it around all essential components:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式使用提供者，并将其包裹在所有基本组件周围：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Everywhere in the `Bar`, `Feed`, and `Chats` components, we can now read from
    the provider.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Bar`、`Feed` 和 `Chats` 组件的任何地方，我们现在都可以从提供者中读取。
- en: As stated previously, we want to show the logged-in user, with their name, inside
    the application.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们想在应用程序中显示已登录用户，包括他们的名字。
- en: 'The component using the data is the `UserBar` component. We need to create
    a `user.js` file inside of the `bar` folder. Insert the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据的组件是 `UserBar` 组件。我们需要在 `bar` 文件夹内创建一个 `user.js` 文件。插入以下代码：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For the moment, we render a simple user container inside of the application
    bar, from the data of the `user` object.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在应用程序栏内渲染一个简单的用户容器，从 `user` 对象的数据中获取。
- en: To get the user data into the `UserBar` component, we need to use the `UserConsumer`
    component, of course.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户数据传递给 `UserBar` 组件，我们需要使用 `UserConsumer` 组件，当然。
- en: 'Open the `index.js` file for the top bar and add the following code to the
    `return` statement, beneath the `SearchBar` component:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 打开顶部栏的 `index.js` 文件，并在 `SearchBar` 组件下方的 `return` 语句中添加以下代码：
- en: '[PRE57]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Obviously, you need to import both of the components at the top of the file,
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您需要在文件顶部导入这两个组件，如下所示：
- en: '[PRE58]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You have now successfully configured and used the React Context API to save
    and read data globally.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已成功配置并使用 React Context API 来全局保存和读取数据。
- en: The solution that we have is a general approach that will work for all scenarios
    that you can think of, including Apollo. If you view the browser now, you will
    be able to see the logged-in user or at least the fake data we added in the top
    bar.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的解决方案是一个通用的方法，适用于您能想到的所有场景，包括 Apollo。如果您现在查看浏览器，您将能够看到已登录的用户或至少我们在顶部栏中添加的假数据。
- en: Nevertheless, we should cover the solution offered by Apollo itself.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该涵盖 Apollo 本身提供的解决方案。
- en: Apollo Consumer
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apollo 消费者
- en: Nearly all of the code that we have written can stay as it was in the previous
    section. We just need to remove the `UserProvider` component from the `App` class
    because it is not needed anymore for the Apollo Consumer component.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎我们之前章节中编写的所有代码都可以保持不变。我们只需要从`App`类中移除`UserProvider`组件，因为对于Apollo消费者组件来说它不再需要了。
- en: 'Open up the `user.js` file in the `context` folder and replace the contents
    with the following code:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`context`文件夹中的`user.js`文件，并用以下代码替换其内容：
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, we import the `ApolloConsumer` component from the `@apollo-client`
    package. This package enables us to get access to the Apollo Client that we set
    up in [*Chapter 4*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085), *Hooking
    Apollo into React*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们从`@apollo-client`包中导入了`ApolloConsumer`组件。这个包使我们能够访问我们在[*第4章*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085)“将Apollo集成到React”中设置的Apollo客户端。
- en: The problem we have here is that we do not have a `CurrentUser` query that would
    respond with the logged-in user from the GraphQL, so we are not able to run the
    `readQuery` function. You would typically run the query against the internal cache
    of Apollo and be able to get the `user` object easily. Once we have implemented
    authentication, we will fix this problem.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里遇到的问题是，我们没有`CurrentUser`查询，该查询会从GraphQL响应登录用户，所以我们无法运行`readQuery`函数。您通常会针对Apollo的内部缓存运行查询，并能够轻松地获取`user`对象。一旦我们实现了身份验证，我们将解决这个问题。
- en: For now, we will return the same fake object as we did with the React Context
    API. The Apollo Client replaces the `Provider` component that we used with the
    React Context API.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将返回与React Context API相同的假对象。Apollo客户端取代了我们使用React Context API的`Provider`组件。
- en: I hope that you can understand the difference between these two solutions. In
    the next chapter, you will see the `ApolloConsumer` component in full action,
    when the user query is established and can be read through the client of its cache.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您能理解这两种解决方案之间的区别。在下一章中，您将看到`ApolloConsumer`组件的全功能展示，当用户查询建立并且可以通过其缓存的客户端读取时。
- en: Documenting React applications
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录React应用程序
- en: We have put a lot of work and code into our React application. To be honest,
    we can improve upon our code base by documenting it. We did not comment on our
    code, we did not add React component property-type definitions, and we have no
    automated documentation tool. Of course, we did not write any comments because
    you learned all of the techniques and libraries from the book, so no comments
    were needed. However, be sure to always comment your code outside of this book.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的React应用程序中投入了大量的工作和代码。说实话，我们可以通过记录代码来改进我们的代码库。我们没有对代码进行注释，我们没有添加React组件属性类型定义，并且我们没有自动化的文档工具。当然，我们没有写任何注释，因为您已经从这本书中学到了所有的技术和库，所以不需要注释。然而，请务必始终在本书之外对代码进行注释。
- en: In the JavaScript ecosystem, many different approaches and tools exist to document
    your application. For this book, we will use a tool called **React Styleguidist**.
    It was made especially for React. You cannot document other frameworks or code
    with it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript生态系统中，存在许多不同的方法和工具来记录您的应用程序。对于这本书，我们将使用一个名为**React Styleguidist**的工具。它是专门为React制作的。您不能用它来记录其他框架或代码。
- en: Important Note
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Generally speaking, this is an area that you can put months of work into without
    coming to a real end. If you are searching for a general approach for any framework
    or backend and frontend, I can recommend JSDoc, but there are many more.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，这是一个您可以投入数月工作而不会真正结束的领域。如果您正在寻找任何框架或后端和前端的通用方法，我可以推荐JSDoc，但还有更多。
- en: 'Beyond that, there are many different React documentation tools. If you want
    to check other tools, have a look here: [https://blog.bitsrc.io/6-tools-for-documenting-your-react-components-like-a-pro-5027cdfb40c6](https://blog.bitsrc.io/6-tools-for-documenting-your-react-components-like-a-pro-5027cdfb40c6).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有许多不同的React文档工具。如果您想查看其他工具，请查看此处：[https://blog.bitsrc.io/6-tools-for-documenting-your-react-components-like-a-pro-5027cdfb40c6](https://blog.bitsrc.io/6-tools-for-documenting-your-react-components-like-a-pro-5027cdfb40c6)。
- en: Let's get started with the configuration for React Styleguidist.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从React Styleguidist的配置开始。
- en: Setting up React Styleguidist
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置React Styleguidist
- en: 'React Styleguidist and our application rely on `webpack`. Just follow these
    instructions to get a working copy of it:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: React Styleguidist和我们的应用程序依赖于`webpack`。只需按照以下说明操作，即可获取其工作副本：
- en: 'Install React Styleguidist using `npm`, as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm`安装React Styleguidist，如下所示：
- en: '[PRE60]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Usually, the folder structure is expected to be `src/components`, but we have
    a `client` folder between the `src` and `components` folders, so we must configure
    React Styleguidist to let it understand our folder structure. Create a `styleguide.config.js`
    file in the root folder of the project to configure it, as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，文件夹结构预期为 `src/components`，但我们有一个 `client` 文件夹位于 `src` 和 `components` 文件夹之间，因此我们必须配置
    React Styleguidist 以使其理解我们的文件夹结构。在项目的根目录中创建一个 `styleguide.config.js` 文件来配置它，如下所示：
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We export an object containing all the information needed for React Styleguidist.
    In addition to specifying the `components` path, we also require our main CSS
    style file. You will see why this can be useful later in this chapter. We must
    define the `webpackConfig` option because our `config` file has a custom name
    that is not found automatically.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出一个包含所有必要信息的对象，用于 React Styleguidist。除了指定 `components` 路径外，我们还需要我们的主要 CSS
    样式文件。你将在本章后面的内容中看到这为什么有用。我们必须定义 `webpackConfig` 选项，因为我们的 `config` 文件有一个自定义名称，无法自动找到。
- en: 'Styleguidist provides two ways to view the documentation. One is to build the
    documentation statically, in production mode, with this command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Styleguidist 提供了两种查看文档的方式。一种是在生产模式下静态构建文档，使用以下命令：
- en: '[PRE62]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This command creates a `styleguide` folder, and inside the folder there are
    HTML files for our documentation. It is an excellent method when releasing new
    versions of your application so that you can save and back up those files with
    each version.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会创建一个 `styleguide` 文件夹，在该文件夹内包含我们文档的 HTML 文件。当发布应用的新版本时，这是一个极好的方法，这样你可以保存并备份每个版本的文件。
- en: Note
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you see an error while running `npx styleguidist`, you have to apply a short-term
    workaround.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行 `npx styleguidist` 时看到错误，你必须应用一个临时的解决方案。
- en: 'Install yarn by running `npm install -g yarn` and then add the following lines
    to the root level of your `package.json` object:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `npm install -g yarn` 安装 yarn，然后将以下行添加到 `package.json` 对象的根级别：
- en: '**"resolutions": {**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**"resolutions": {**'
- en: '**"react-dev-utils": "12.0.0-next.47"**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**"react-dev-utils": "12.0.0-next.47"**'
- en: '**}**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: You can then run `yarn install`. This will update an internal dependency of
    `styleguidist` to a newer version that does not have the problem.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以运行 `yarn install`。这将更新 `styleguidist` 的一个内部依赖项到一个没有问题的较新版本。
- en: You can then run `npx styleguidist build` again. Just remember that in case
    you run `npm install`, it will overwrite this dependency with the old one and
    you will have to run `yarn install` again to get it working.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以再次运行 `npx styleguidist build`。只需记住，如果你运行 `npm install`，它将用旧版本覆盖这个依赖项，你将不得不再次运行
    `yarn install` 来使其工作。
- en: 'The second method, for development cases, lets Styleguidist run and create
    documentation on the fly using `webpack`. Here''s the command you need for this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法，适用于开发情况，允许 Styleguidist 使用 `webpack` 动态运行并创建文档。以下是执行此操作的命令：
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can view the results under `http://localhost:6060`. The documentation should
    look like this:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `http://localhost:6060` 下查看结果。文档应该看起来像这样：
- en: '![Figure 5.5 – React Styleguidist documentation'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – React Styleguidist 文档'
- en: '](img/Figure_5.05_B17337.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.05_B17337.jpg)'
- en: Figure 5.5 – React Styleguidist documentation
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – React Styleguidist 文档
- en: In the left-hand panel, all of the components are listed in the order of our
    folder structure. You will always have an excellent overview of the existing components
    this way.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧面板中，所有组件都按照我们的文件夹结构顺序列出。这样，你将始终有一个对现有组件的极佳概览。
- en: In the main panel, each component is explained in detail. You may have noticed
    that the components are missing further information. We will change that next.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在主面板中，每个组件都进行了详细说明。你可能已经注意到组件缺少进一步的信息。我们将在下一节中改变这一点。
- en: React PropTypes
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React PropTypes
- en: An essential feature of React is passing the properties to the child components.
    These can be anything from basic strings to numbers, but also complete components.
    We have already seen all of the scenarios in our application.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: React 的一个基本特性是将属性传递给子组件。这些可以是基本字符串、数字，也可以是完整的组件。我们已经在我们的应用中看到了所有这些场景。
- en: Developers that are new to your code base need to read through all of the components
    and identify which properties they can accept.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新加入你的代码库的开发者来说，他们需要阅读所有组件并识别它们可以接受的属性。
- en: React offers a way to describe properties from within each component. Documenting
    the properties of your components makes it easier for other developers to understand
    your React components.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一种从每个组件内部描述属性的方法。记录你组件的属性使得其他开发者更容易理解你的 React 组件。
- en: We will take a look at how to do this with an example in our `Post` component.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`Post`组件中的示例来查看如何实现这一点。
- en: 'There are two React features that we haven''t covered yet, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍的两个React特性如下：
- en: If your components have optional parameters, it can make sense to have default
    properties in the first place. To do this, you can specify `defaultProps` as a
    static property, in the same way as with the state initializers.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的组件有可选参数，最初有默认属性是有意义的。为此，你可以指定`defaultProps`作为一个静态属性，就像使用状态初始化器一样。
- en: The important part is the `propTypes` field, which you can fill in for all of
    your components with the custom properties that they accept.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是`propTypes`字段，你可以为所有组件填充它们接受的自定义属性。
- en: 'A new package is required to define the property types, as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个新的包来定义属性类型，如下所示：
- en: '[PRE64]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This package includes everything that we need to set up our property definitions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包包含了我们设置属性定义所需的一切。
- en: 'Now, open your `Post` component''s `index.js` file. We need to import the new
    package at the top of this file, as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的`Post`组件的`index.js`文件。我们需要在这个文件的顶部导入新的包，如下所示：
- en: '[PRE65]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we will add the new field to our component, before the `export` statement,
    like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`export`语句之前将新字段添加到我们的组件中，如下所示：
- en: '[PRE66]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code should help everyone to understand your component a bit better.
    Every developer should know that a `post` object is required for this component
    to work.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应该有助于每个人更好地理解你的组件。每个开发者都应该知道，这个组件要正常工作需要一个`post`对象。
- en: The `PropTypes` package offers various types that we can use. You can access
    each type with `PropTypes.X`. If it is a required property, you can append `isRequired`
    in the same way as in the preceding code.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropTypes`包提供了我们可以使用的各种类型。你可以使用`PropTypes.X`访问每个类型。如果是一个必需的属性，你可以像前面的代码一样附加`isRequired`。'
- en: 'Not only does React now throw an error inside of our console when the property
    does not exist, but React Styleguidist is also able to show which properties are
    needed, as you can see in the following screenshot:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅React现在会在控制台抛出一个错误，当属性不存在时，React Styleguidist还能够显示哪些属性是必需的，正如你在下面的截图中所看到的：
- en: '![Figure 5.6 – Basic property documentation'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 属性基本文档](img/Figure_5.6_B17337.jpg)'
- en: '](img/Figure_5.06_B17337.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.06 – 属性基本文档](img/Figure_5.06_B17337.jpg)'
- en: Figure 5.6 – Basic property documentation
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 属性基本文档
- en: However, what is a `post` object? What kind of fields does it include?
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，什么是`post`对象？它包含哪些字段？
- en: 'The best way to document a `post` object is to define which properties a post
    should include, at least for this specific component. Replace the property definition,
    as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 记录`post`对象的最佳方式是定义一个帖子应该包含哪些属性，至少对于这个特定的组件来说是这样。替换属性定义，如下所示：
- en: '[PRE67]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we use the `shape` function. This allows you to hand over a list of fields
    that the object contains. Each of those is given a type from the `PropTypes` package.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`shape`函数。这允许你传递一个包含对象字段的列表。这些字段中的每一个都会从`PropTypes`包中获取一个类型。
- en: 'The output from React Styleguidist now looks like this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: React Styleguidist的输出现在看起来是这样的：
- en: '![Figure 5.7 – Detailed property documentation'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 属性详细文档](img/Figure_5.7_B17337.jpg)'
- en: '](img/Figure_5.07_B17337.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.07 – 属性详细文档](img/Figure_5.07_B17337.jpg)'
- en: Figure 5.7 – Detailed property documentation
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 属性详细文档
- en: All the fields that we specified are listed separately. At the time of writing
    this book, React Styleguidist does not offer a recursive view of all properties.
    As you can see, the `user` object inside of the `post` object is not listed with
    its properties, but it is only listed as a second shape. If you need this feature,
    you can, of course, implement it yourself and send a `pull` request on the official
    GitHub repository, or switch to another tool.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定的所有字段都分别列出。在撰写这本书的时候，React Styleguidist还没有提供所有属性的递归视图。正如你所看到的，`post`对象内部的`user`对象及其属性没有列出，但它只作为一个第二形状列出。如果你需要这个功能，你当然可以自己实现它，并在官方GitHub仓库上发送一个`pull`请求，或者切换到另一个工具。
- en: Important Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: React offers way more property types and functions that you can use to document
    all of the components and their properties. To learn a bit more about this, visit
    the official documentation at [https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了更多属性类型和函数，你可以使用它们来记录所有组件及其属性。要了解更多信息，请访问官方文档[https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html)。
- en: One last great feature of React Styleguidist is that you can enter examples
    for every component. You can also use markdown to add some more descriptions.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: React Styleguidist 的最后一个伟大功能是你可以为每个组件输入示例。你还可以使用 Markdown 添加更多描述。
- en: 'For our `Post` component, we need to create an `index.md` file, next to the
    `index.js` file in the `post` folder. React Styleguidist proposes creating either
    a `Readme.md` or a `Post.md` file, but those did not work for me. The `index.md`
    file should look like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `Post` 组件，我们需要在 `post` 文件夹中 `index.js` 文件旁边创建一个 `index.md` 文件。React Styleguidist
    建议创建一个 `Readme.md` 或 `Post.md` 文件，但那些对我来说不起作用。`index.md` 文件应该看起来像这样：
- en: '[PRE68]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Sadly, you will not be able to see the output of that markup directly. The reason
    is that the `Post` component relies on Apollo. If you just render the plain `Post`
    component in the way React Styleguidist does, the Apollo Client will not be there.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，你将无法直接看到该标记的输出。原因是 `Post` 组件依赖于 Apollo。如果你只是像 React Styleguidist 那样渲染普通的
    `Post` 组件，Apollo 客户端将不会存在。
- en: 'To fix this issue, we can overwrite the default way React Styleguidist renders
    any component. Follow these instructions to get it working:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以覆盖 React Styleguidist 渲染任何组件的默认方式。按照以下说明操作以使其工作：
- en: 'Create a new folder where we can save all special React Styleguidist components,
    as follows:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，我们可以在这里保存所有特殊的 React Styleguidist 组件，如下所示：
- en: '[PRE69]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a file called `Wrapper.js` with the following content:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Wrapper.js` 的文件，内容如下：
- en: '[PRE70]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will be the standard `Wrapper` component for all components that React
    Styleguidist runs. This way, we ensure that we always have the Apollo Client in
    the context.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将是 React Styleguidist 运行的所有组件的标准 `Wrapper` 组件。这样，我们确保我们始终在上下文中拥有 Apollo 客户端。
- en: 'The last thing we need to do is to add the following property to the `styleguide.config.js`
    file:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的是将以下属性添加到 `styleguide.config.js` 文件中：
- en: '[PRE71]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: React Styleguidist will now use this `Wrapper` component.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: React Styleguidist 将现在使用这个 `Wrapper` 组件。
- en: 'If you restart React Styleguidist, it will render the documentation and generate
    the following output:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新启动 React Styleguidist，它将渲染文档并生成以下输出：
- en: '![Figure 5.8 – React Styleguidist example'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8 – React Styleguidist 示例](img/Figure_5.08_B17337.jpg)'
- en: '](img/Figure_5.08_B17337.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 5.8 – React Styleguidist example
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – React Styleguidist 示例
- en: Now, you can see why it was useful to use the CSS style. Not only can React
    Styleguidist document the code, but it can also execute it within the documentation.
    As in the preceding code, providing the correct properties inside of the `post`
    object enables us to see how the component should look, including the correct
    styling.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到为什么使用 CSS 样式很有用。不仅 React Styleguidist 可以记录代码，它还可以在文档中执行代码。正如前面的代码所示，在
    `post` 对象内部提供正确的属性使我们能够看到组件应该如何看起来，包括正确的样式。
- en: This example shows how reusable our `Post` component is since it is usable without
    having to run the Apollo query.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们的 `Post` 组件是多么的可重用，因为它可以在不运行 Apollo 查询的情况下使用。
- en: The basics should be clear by now. Continue to read up on this topic because
    there are more things to learn.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识现在应该很清晰了。继续阅读这个主题，因为还有更多东西要学习。
- en: Summary
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through this chapter, you have gained a lot of experience in writing a React
    application. You have applied multiple React patterns to different use cases,
    such as children passing through a pattern and conditional rendering. Furthermore,
    you now know how to document your code correctly.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你在编写 React 应用程序方面获得了大量的经验。你已经将多个 React 模式应用于不同的用例，例如通过模式传递子组件和条件渲染。此外，你现在知道如何正确地记录你的代码。
- en: You also learned how to use the React Context API, in comparison with the Apollo
    Consumer feature, to retrieve the currently logged-in user in our application.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何使用 React Context API，与 Apollo Consumer 功能相比，在我们的应用程序中检索当前登录的用户。
- en: In the next chapter, you will learn how to implement authentication in your
    backend and use it in the frontend.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在后端实现身份验证并在前端使用它。
