- en: '*Chapter 5*: Reusable React Components and React Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have done a lot to reach this point in the book, including saving, requesting,
    inserting, and updating data through the use of Apollo Client, in connection with
    our GraphQL **application programming interface** (**API**). Much of the code
    that we have written will also have to be reviewed many times. This is especially
    important because we are building an application so quickly. Everything is working
    for now, but we have not done a great job here; there are some best practices
    and tactics that need to be observed in order to write good React applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover everything you need to know to write efficient and
    reusable React components. It will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring our React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Graphbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any programming language, framework, or library that you use, there are
    always common tactics that you should follow. They present an understandable,
    efficient way to write applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085), *Hooking
    Apollo into React*, we tackled some patterns, such as rendering arrays, the spread
    operator, and destructuring objects. Nevertheless, there are some further patterns
    that you should know about.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go over the most commonly used patterns that React offers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlled components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many (but not all) of the examples here only represent illustrations of what
    each method looks like. Some of them will not be taken over to our real application
    code, so if you are not interested in learning the essential aspects of patterns
    or if you already know most of them, you can skip the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the short explanation that I will provide, there is more extensive documentation
    on this topic. The official React documentation is always a good starting point,
    but you can find all React patterns, including those that we have already used,
    at [https://reactpatterns.com/](https://reactpatterns.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Controlled components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we wrote our post form to submit new posts or the message inputs inside
    chat in the previous chapters, we used controlled input by incident. To provide
    a better understanding, I am going to quickly explain the difference between controlled
    and uncontrolled components, and when to use each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with uncontrolled input.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, a component is uncontrolled whenever the value is not set by
    a property through React, but only saved and taken from the real browser **Document
    Object Model** (**DOM**). The value of an input is then retrieved from a reference
    to the DOM Node and is not managed and taken from React's component state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the post form where the user will be able
    to submit new posts. I have excluded the rendering logic for the complete feed,
    as it is not a part of the pattern that I want to show you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that we no longer have the `useState` Hook, since
    the `textarea` value is stored within the real DOM Node, and not the application
    state.
  prefs: []
  type: TYPE_NORMAL
- en: We run the `useRef` Hook provided by React. It prepares the variable to accept
    the DOM Node as a property. If you are using class-based React components, you
    can use the `createRef` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the `return` statement for rendering the component, the `ref` property fills
    in the reference that we just created with the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the value of the DOM Node works by using the normal JavaScript DOM
    API. You can see this behavior when sending the `submit` event of our form. The
    value is extracted from the `textArea.current.value` field.
  prefs: []
  type: TYPE_NORMAL
- en: Everything that an uncontrolled component needs is already shown here; there
    is no more to it. You can compare this approach to our current implementation
    of the post form. In our implementation, we set up the state, listen for change
    events, and save and read the value directly from the component state, not from
    the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: When using uncontrolled components and working directly with DOM elements, the
    problem is that you leave the normal React workflow. You are no longer able to
    handle conditions and, therefore, trigger other events inside of React.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the DOM reference can make it easier to use third-party plugins
    that were not written for the React ecosystem. There are thousands of great jQuery
    plugins, for example. I always recommend using the default approach of a controlled
    component. For 99% of cases, this works without leaving the React workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you need a deeper understanding of which approach is a better solution for
    your specific case, take a look at [https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/](https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/).
  prefs: []
  type: TYPE_NORMAL
- en: Functional components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One fundamental and efficient solution for writing well-structured and reusable
    React components is the use of functional components. We have already used them
    throughout the book at every location.
  prefs: []
  type: TYPE_NORMAL
- en: Before the existence of functional components, there were stateless functions.
    As you might expect, stateless functions are functions, not React components.
    They are not able to store any states; only properties can be used to pass and
    render data. Property updates are directly rerendered inside the stateless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Since newer versions of React, those stateless functions no longer exist as
    there are React Hooks that allow us to use state in those functions, which makes
    them fully functional components. This is why they are now called functional components.
  prefs: []
  type: TYPE_NORMAL
- en: We have written a lot of code where more functional components can help us provide
    more structured and understandable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beginning with the file structure, we will create a new folder for our new
    components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Many parts of our application need to be reworked. Create a new file for our
    first functional component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, we display a dull and boring `loading.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we are using a simple function in `color` and
    `size` fields from the properties that our function receives.
  prefs: []
  type: TYPE_NORMAL
- en: We are building a default `style` object that represents the basic styling for
    a loading spinner. You can pass the `color` and `size` values separately, to adjust
    those settings.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we are returning a simple `div` tag with the `bouncer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s missing here is the CSS styling. The code should look like this; we''ll
    just add it to our `style.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous examples, we use CSS animations to display our loading spinner
    correctly and to let it animate as pulsating.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished the functional component. You should place it into the
    existing code, wherever a loading state exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the new loading spinner to the top of your files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then render the functional component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Start the server with `npm run server` and the frontend with `npm run client`.
    You should now see a pulsating blue bubble where you inserted it. I have tested
    this inside of my posts feed, and it looks pretty good.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of functional components is that they are minimal and efficient
    functions, rendering smaller parts of our application. The approach perfectly
    integrates with React, and we can improve upon the code that we have written.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important ability of React is rendering components or data conditionally.
    We will use this intensively in the next main features that we are going to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, you can accomplish conditional rendering by using the curly brace
    syntax. An example of an `if` statement is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code is the simplest example of conditional rendering. We have the `shouldRender`
    variable from the component state, and we use this as our condition. When the
    condition is `true`, the second part—which is our `Successful conditional rendering!`
    text—will also render. That is because we are using the `&&` characters. The text
    does not render if the condition is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: You can replace the preceding condition with anything that you have in mind.
    It can be a complex condition, such as a function returning a Boolean value, or
    just as in the preceding code, it can be a state variable.
  prefs: []
  type: TYPE_NORMAL
- en: You will see further examples in later steps and chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering child components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all of the code that we have written so far, we have directly written the
    markup as though it is rendered to real **HyperText Markup Language** (**HTML**).
  prefs: []
  type: TYPE_NORMAL
- en: A great feature that React offers is the ability to pass children to other components.
    The parent component decides what is done with its children.
  prefs: []
  type: TYPE_NORMAL
- en: Something that we are still missing is a good error message for our users. So,
    we will use this pattern to solve the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `error.js` file next to the `loading.js` file in the `components`
    folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When passing children to another component, a new property, called `children`,
    is added to the properties of the component. You specify `children` by writing
    normal React markup.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to, you could perform actions, such as looping through each child.
    In our example, we render the children as usual, by using curly braces and putting
    the `children` variable inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the new `Error` component, you can simply import it. The markup
    for the new component is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some CSS, and everything should be finished, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A working result might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Error message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Error message
  prefs: []
  type: TYPE_NORMAL
- en: You can apply the stateless function pattern and the children pattern to many
    other use cases. Which one you use will depend on your specific scenario. In this
    case, you could also use a stateless function, rather than a React component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to have a look at how we can improve our code structure,
    together with the fundamentals that React is following.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already improved some things by using React patterns. You should do
    some homework and introduce those patterns wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: When writing applications, one key objective is to keep them modular and readable
    but also as understandable as possible. It is always hard to tell when splitting
    code up is useful and when it overcomplicates things. This is something that you
    will learn more and more about by writing as many applications and as much code
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin to structure our application further.
  prefs: []
  type: TYPE_NORMAL
- en: The React file structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already saved our `Loading` and `Error` components in the `components`
    folder. Still, there are many parts of our components that we did not save in
    separate files to improve the readability of this book.
  prefs: []
  type: TYPE_NORMAL
- en: I will explain the most important solution for unreadable React code in one
    example. You can implement this on your own later for all other parts of our application,
    as you should not read duplicate code.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we render the posts in our feed by mapping through all posts from
    the GraphQL response. There, we directly render the corresponding markup for all
    post items. Therefore, it is one big render function that does everything at once.
  prefs: []
  type: TYPE_NORMAL
- en: To make this a bit more intuitive, we should create a new `Post` component.
    Separating the components hugely improves the readability of our posts feed. Then,
    we can replace the return value from the loop with a new component, instead of
    real markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating a `post.js` file in our `components` folder, we should
    first create another `post` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Post` component consists of multiple tiny, nested components. A post is
    also a standalone GraphQL entity, making it logical to have a separate folder.
    We will store all related components in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create those components. We will start with the post header, where the
    top part of a post item is defined. Create a new `header.js` file in the `components/post`
    folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `header` component is just a functional component. As you can see, we are
    using a React pattern from the earlier pages of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up next is the post content, which represents the body of a post item. Add
    the following code inside of a new file, called `content.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code is pretty much the same as that of the post header. At later points,
    you will be free to introduce real React components or extended markup to those
    two files. It is entirely open to your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main file is a new `index.js` file in the new `post` folder. It should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code represents a very basic component, but instead of directly
    using markup to render a complete post item (as we did before), we are using two
    further components for this, with `PostHeader` and `PostContent`. Both of the
    components receive `post` as a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use the new `Post` component in the feed list with ease. First,
    import the component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The good thing when having an `index.js` file is that you can reduce the path
    by directly pointing to the folder and the `index.js` file will be picked up automatically.
    Then, just replace the old code inside the loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The improvement is that all three of the components give you a clear overview
    at first glance. Inside of the loop, we return a post item. A post item consists
    of a header and body content.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there is room for enhancement, because the posts feed list is cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient Apollo React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully replaced the post items in our feed with a React component,
    instead of raw markup.
  prefs: []
  type: TYPE_NORMAL
- en: A major part, which I dislike very much, is the way we define and pass the actual
    GraphQL query or mutation to the `useQuery` or `useMutation` Hook within the components.
    It would be good to define those GraphQL requests once and use them everywhere
    they are needed so that we can use them across different components.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, not only should the pure GraphQL requests be reusable but the `update`
    function or the `optimisticResponse` object should also be reusable across different
    components.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will fix those issues for `Feed.js` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using fragments with Apollo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A GraphQL fragment is a functionality that allows you to share common queries
    or pieces of them between different bigger GraphQL queries. For example, if you
    have different GraphQL queries that request a `user` object and the data structure
    for this user is always the same, you can define a user fragment to reuse the
    same attributes across multiple different GraphQL requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement this for our `GET_POSTS` query. Follow the next instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `queries` folder and a `fragments` folder inside of the `apollo`
    folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `userAttributes.js` inside the `fragments` folder and
    fill in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For all `user` objects that we have requested so far, we have always returned
    the username and the avatar image, as we always display the name in the user profile
    image. In the preceding code snippet, we implemented the matching GraphQL fragment,
    which we can now use in any other query where we want to request exactly this
    data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a file called `getPosts.js` inside the `queries` folder. Add the following
    content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we are making use of our newly created GraphQL
    fragment. Firstly, we of course import it at the top of the file. Inside the GraphQL
    query, we use the `…userAttributes` syntax, which is similar to the normal JavaScript
    destructuring assignment and spreads the fragment with the same name up to inject
    those properties at the specified location in the GraphQL query. The last step
    is to add a fragment below the actual query to be able to make use of it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to simply replace the old `GET_POSTS` variable that we have
    manually parsed inside the `Feed.js` file with this `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we are successfully using the fragment within our main `GET_POSTS`
    query, which we also can reuse just by importing it into any other component.
    You can repeat this for all the other requests and, by doing so, reach a cleaner
    code structure and more reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing Apollo Hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We did a good job extracting the GraphQL query from our component into separate
    reusable files.
  prefs: []
  type: TYPE_NORMAL
- en: Still, we have some amount of logic in our component where we define how the
    `update` function and `optimisticResponse` object for the GraphQL mutations are
    handled. We can also extract these to further improve reusability and clear the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the use of the Apollo or React Hooks is that they need to be
    executed within the functional component. Still, we can save the biggest amount
    of the Hook configuration outside of the component to make them reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the next instructions to accomplish this for the `addPost` mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `mutations` folder inside the `apollo` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `addPost.js` and insert the following code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The great thing is that we can reuse the fragment we have created before here,
    so we do not need to define it again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use this `ADD_POST` variable in the `Feed.js` file for our mutation.
    Replace the actual parsed GraphQL query with the following `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We still have the `update` function and the `optimisticResponse` object within
    our `useMutation` Hook. It''s easiest to also move them to the `addPost.js` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are returning a function on import so that we can pass all required parameters.
    The only expected parameter is the `postContent` state variable, which is required
    for the `optimisticResponse` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `import` statement inside the `Feed.js` file again to also import
    the `getAddPostConfig` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final `useState` Hook should then look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We execute `getAddPostConfig` as the second parameter of the `useMutation` Hook.
    It will be filled with the returned object but will still have the `postContent`
    value inside the `optimisticResponse` object, as every time the value changes,
    the `getAddPostConfig` function will also be run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can go even further. Add the following line of code to the `addPost.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will replace the plain `useMutation` Hook in our component and instead build
    a small wrapper around it. It will accept the `postContent` value to pass it further
    to the `getAddPostConfig` function. The advantage will be that we can just import
    the `useAddPostMutation` function and, after executing it, all default configurations
    are applied and we are able to use that inside any component without having to
    import the query, the configuration, and the `useMutation` Hook separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the import of the `addPost.js` file inside the `Feed.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `useMutation` Hook with the following line of code and remove the
    `useMutation` import while doing so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We only need to import one function to get the full-fledged `addPost` mutation
    running in any component we want it to be in. This concept will work with any
    query or mutations we have used so far.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We cleaned up the functional component from most of the GraphQL request logic
    and have it in separate files now. We can use the query or the mutation at any
    location where we need them.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you repeat the same for all other locations so that you have
    a nicely filled set of GraphQL requests that we are able to reuse anywhere we
    want. This would be a good homework exercise to learn that concept.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will have a look at how we can extend Graphbook.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Graphbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our social network is still a bit rough. Aside from the fact that we are still
    missing authentication, all of the features are pretty basic; writing and reading
    the posts and messages is nothing exceptional.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare it to Facebook, there are many things that we need to do. Of
    course, we cannot rebuild Facebook in its totality, but the usual features should
    be there. From my point of view, we should cover the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a drop-down menu to the posts to allow deletion of posts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a global `user` object with the React Context API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Apollo cache as an alternative to the React Context API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a top bar as the first component rendered above all of the views.
    We can search for users in our database from a search bar, and we can show the
    logged-in user from the global `user` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will begin by looking at the first feature.
  prefs: []
  type: TYPE_NORMAL
- en: The React context menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be able to write the React context menu pretty much on your own.
    All the required React patterns have been explained, and implementing the mutations
    should be clear by now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, we will lay out the plan that we want to follow. We''ll aim
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Render a simple icon with Font Awesome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build React helper components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle the `onClick` event and set the correct component state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the conditional rendering pattern to show the drop-down menu, if the component
    state is set correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add buttons to the menu and bind mutations to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue reading to find out how to get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a preview screenshot, showing how the final implemented feature
    should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Drop-down with context'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Drop-down with context
  prefs: []
  type: TYPE_NORMAL
- en: We will now start with the first task of setting up Font Awesome for our project.
  prefs: []
  type: TYPE_NORMAL
- en: Font Awesome in React
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you may have noticed, we have not installed Font Awesome yet. Let''s fix
    this with `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Graphbook relies on the preceding four packages to import the Font Awesome icons
    into our frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Font Awesome provides multiple configurations for use with React. The best,
    most production-ready approach is to import only the icons that we are explicitly
    going to use. For your next project or prototype, it might make sense to get started
    with the simplest approach. You can find all of the information on the official
    page, at [https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react](https://fontawesome.com/v5.15/how-to-use/on-the-web/using-with/react).
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a separate file for Font Awesome will help us to have a clean import.
    Save the following code under the `fontawesome.js` file, inside of the `components`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `library` object from the Font Awesome core package. For
    our specific use case, we only need one arrow image, called `angle-down`. Using
    the `library.add` function, we register this icon for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many versions of Font Awesome. In this book, we are using Font Awesome
    5, with free icons only. More premium icons can be bought on the official Font
    Awesome web page. You can find an overview of all of the icons, and a detailed
    description of each, in the icon gallery at [https://fontawesome.com/icons?d=gallery](https://fontawesome.com/icons?d=gallery).
  prefs: []
  type: TYPE_NORMAL
- en: 'The only place where we need this file is within our root `App.js` file. It
    ensures that all of our custom React components can display the imported icons.
    Add the following `import` statement to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: No variable is required to save the exported methods since there won't be any.
    We want to execute this file in our application only once.
  prefs: []
  type: TYPE_NORMAL
- en: When you reach a point where your application needs a complete set of icons,
    you can get all the icons grouped directly from the `@fortawesome/free-brands-svg-icons`
    package, which we also installed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to create a `Dropdown` helper component.
  prefs: []
  type: TYPE_NORMAL
- en: React helper components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Production-ready applications need to be as polished as possible. Implementing
    reusable React components is one of the most important things to do.
  prefs: []
  type: TYPE_NORMAL
- en: You should notice that drop-down menus are a common topic when building client-side
    applications. They are global parts of the frontend and appear everywhere throughout
    our components.
  prefs: []
  type: TYPE_NORMAL
- en: It would be best to separate the actual menu markup that we want to display
    from the code, which handles the event-binding and shows the menu.
  prefs: []
  type: TYPE_NORMAL
- en: I always call this kind of code in React **helper components**. They are not
    implementing any business logic but give us the opportunity to reuse drop-down
    menus or other features wherever we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically, the first step is to create a new folder to store all of the helper
    components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file, called `dropdown.js`, as the helper component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We do not require much code to write a drop-down component. It is also pretty
    efficient since this works with nearly every scenario that you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: We use basic event handling in the preceding code snippet. When the trigger
    `div` tag is clicked, we update the `show state` variable. Inside of the `div`
    trigger, we also render a property called `trigger`. A `trigger` property can
    be anything from regular text or an HTML tag to a React component. It can be passed
    through the parent components in order to customize the look of the drop-down
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `trigger` property, we are using two well-known React patterns,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering when the `show` variable is `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering children given by the parent component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This solution allows us to fill in the menu items that we want to render directly
    as children of the `Dropdown` component, which, as mentioned previously, is displayed
    after clicking on the trigger. In this case, the `show` state variable is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: However, one thing is still not completely correct here. If you test the drop-down
    component by providing simple text or an icon as a trigger and other text as the
    content, you should see that the `Dropdown` component only closes when clicking
    on the trigger again; it does not close when clicking anywhere else in our browser,
    outside of the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: This is one scenario where the React approach encounters problems. There is
    no DOM Node event such as `useOutsideClick`, so we cannot directly listen to the
    outside click events of any DOM Node, such as our drop-down menu. The conventional
    approach is to bind an event listener to the complete document. Clicking anywhere
    in our browser closes the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: The `useOutSideClick` Hook just checks if the clicked element matches the reference
    that we set up through the `useRef` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: When clicking on the trigger button, we add the click event listener to the
    whole document with the `addEventListener` function of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: There are many cases where it might make sense to leave the React approach and
    use the DOM directly, through the standard JavaScript interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read this article on *Medium* to get a better understanding: [https://medium.com/@garrettmac/reactjs-how-to-safely-manipulate-the-dom-when-reactjs-cant-the-right-way-8a20928e8a6](https://medium.com/@garrettmac/reactjs-how-to-safely-manipulate-the-dom-when-reactjs-cant-the-right-way-8a20928e8a6).'
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` Hook is executed only on first rendering of the component. You
    can execute any kind of logic there. If the return value is a function too, this
    function will be executed on unmount of the component. By doing that, we do not
    forget to remove all the manually created event listeners whenever the component
    is unmounted and removed from the DOM. Forgetting this can lead to many errors.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, this is the part where React fails at least a little
    bit, although it is not the fault of React. The DOM and JavaScript do not have
    the right abilities.
  prefs: []
  type: TYPE_NORMAL
- en: We can finally use our helper component and display the context menus for posts,
    but first, we need to prepare all of the menu items and components that we want
    to render.
  prefs: []
  type: TYPE_NORMAL
- en: The Apollo deletePost mutation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A mutation is always located at two points in our code. One part is written
    inside of our GraphQL API in the backend, and the other one is written in our
    frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should start with the implementation on the backend side, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the GraphQL schema. The `deletePost` mutation needs to go inside of the
    `RootMutation` object. The new `Response` type serves as a return value, as deleted
    posts cannot be returned because they do not exist. Note in the following code
    snippet that we only need the `postId` parameter and do not send the complete
    post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the missing GraphQL resolver function. The `destroy` function of Sequelize
    only returns a number that represents the number of deleted rows. We return an
    object with the `success` field. This field indicates whether our frontend should
    throw an error. The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only special thing here is that we need to specify which posts we want to
    delete. This is done by having the `where` property inside of the function call.
    Because we currently do not have authentication implemented yet, we cannot verify
    the user deleting the post, but for our example, this is no problem.
  prefs: []
  type: TYPE_NORMAL
- en: In short, our GraphQL API is now able to accept the `deletePost` mutation. We
    do not verify which user sends this mutation, so for our example, posts can be
    deleted by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: We can now focus on the frontend again.
  prefs: []
  type: TYPE_NORMAL
- en: Recall how we implemented the previous mutations; we always created reusable
    functions and configurations for them. We should do the same for the `delete`
    mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the `deletePost` mutation for the client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, called `deletePost.js`, inside of the `mutations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import all the dependencies, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new `deletePost` mutation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new function to handle the configuration of the mutation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To remove an item, we need to clean the array from the post with the given `postId`
    value. The easiest way to do that is to return the complete object of `postsFeed`,
    and while doing so, we let the normal JavaScript `filter` function return only
    those posts not having the `postId` value inside. To read the `readField` function
    given by Apollo.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lastly, insert the wrapper function for the `useMutation` Hook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I have removed the `optimisticResponse` update for the **user interface** (**UI**)
    since it is not intuitive if the request fails because then the UI would first
    show an optimistic update, but under failure, put the post back again as the API
    call failed. This would make your post disappear and reappear again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add our drop-down menu to the post header with a new item so that
    we can call the `deletePost` mutation. Follow these instructions to add it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `header.js` file and import the drop-down component, `fontawesome`,
    and the mutation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `useDeletePostMutation` Hook before the `return` statement, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the new button to our header beneath the `div` tag with the username, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The overall solution is very simple. We have a wrapping drop-down component.
    All children will be only rendered if the `show` state variable is changed. This
    includes our `deletePost` mutation and triggers on click. The mutation itself
    is separated from the actual code to render the view.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the correct CSS from the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered the retrieval and deletion of posts. The update of posts
    is more or less the same—instead of adding or removing, you need to update the
    post not only via its ID in the database but also in the Apollo cache. The approach
    is the same, though.
  prefs: []
  type: TYPE_NORMAL
- en: I expect that you are now prepared for advanced scenarios, where communication
    between multiple components on different layers is required. Consequently, when
    starting the server and client, you should be presented with the preview image
    that I gave you when starting this section.
  prefs: []
  type: TYPE_NORMAL
- en: To get some more practice, we will repeat this for another use case in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The React application bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast with Facebook, we do not have an outstanding application bar. The
    plan is to implement something similar. It is fixed to always stay at the top
    of the browser window, above all parts of the Graphbook. You will be able to search
    for other users, see notifications, and see the logged-in user inside the application
    bar, after going through this section.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that we will implement is a simple search for users because
    it is complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a preview of what we are going to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Search results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Search results
  prefs: []
  type: TYPE_NORMAL
- en: It looks basic, but what we are doing here is binding the `onChange` event of
    an input and refetching the query every time the value changes. Logically, this
    rerenders the search list in accordance with the responses from our GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the API, we need to introduce a new entity.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with our `postsFeed` query, we will set up pagination from the beginning,
    because later, we might want to offer more advanced functionalities, such as loading
    more items while scrolling through the search list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the GraphQL schema and fill in the new `RootQuery` property and type,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `UsersSearch` type expects one special parameter, which is the search text.
    Without the text parameter, the request would not make much sense. You should
    remember the `page` and `limit` parameters from the `postsFeed` pagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `resolver` function looks pretty much the same as the `postsFeed`
    resolver function. You can add the following code straight into the `resolvers.js`
    file in the `RootQuery` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You should note that the first condition asks whether the provided text is larger
    than three characters. We do this to avoid sending too many unnecessary queries
    to our database. Searching for every user where the username consists of just
    one or two characters would result in providing us with nearly every user. Of
    course, this could have been done on the frontend, too, but various clients could
    use our API, so we need to make sure that the backend makes this small improvement
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We send the `query` object to our database through Sequelize. The code works
    pretty much like the `postsFeed` resolver function from before, except that we
    are using a Sequelize operator. We want to find every user where the username
    includes the entered text, without specifying whether it is at the start, middle,
    or end of the name. Consequently, we will use the `Op.like` operator, which Sequelize
    parses into a pure `LIKE` query, giving us the results we want. The `%` operator
    is used in MySQL to represent an unspecified number of characters. To enable this
    operator, we must import the `sequelize` package and extract the `Op` object from
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Going further, we can implement the client-side code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `searchQuery.js` within the `queries` folder and insert
    the following code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only required parameter is the `text` parameter that we want to pass to
    our search. If the `text` parameter is shorter than three characters, we are passing
    a `skip` property either with `true` or `false` to not execute the GraphQL request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continuing with our plan, we will create an application bar in a separate file.
    Create a new folder, called `bar`, below the `components` folder and the `index.js`
    file. Fill it in with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file works as a wrapper for all of the components we want to render in
    the application bar; it does not implement any custom logic. We have already imported
    the `SearchBar` component that we must create.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `SearchBar` component lives inside of a separate file. Just create a `search.js`
    file in the `bar` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are storing the current input value inside of a state variable, called `text`.
    Every time the text is changed, the `useUserSearchQuery` Hook is executed again
    with the new `text` parameter. Inside of the query Hook, the value is merged into
    the variables and sent with a GraphQL request. The result is then handed over
    to the `SearchList` component inside the `data` property if the request is not
    loading and did not have any error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will implement the `SearchList` component. This behaves like the posts
    feed, but only renders something if a response is given with at least one user.
    The list is displayed as a drop-down menu and is hidden whenever the browser window
    is clicked on. Create a file called `searchList.js` inside of the `bar` folder,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using the `useEffect` Hook here with the dependency on `users`, which
    is executed whenever the parent component sets new properties on the current one.
    In this case, we check whether the properties include at least one user, and then
    set the state accordingly, in order to make the drop-down menu visible. The drop-down
    menu is hidden when clicked on or when an empty result is given. The approach
    is very similar to the drop-down for the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are just two things to do now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You should copy the CSS from the official GitHub repository of this chapter
    in order to get the correct styling, or you can do it on your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to import the bar wrapper component inside of the `App` class and render
    it between React Helmet and the news feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first feature of our application bar is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue and take a look at React's Context API, the Apollo Consumer feature,
    and how to store data globally in our React frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The React Context API versus Apollo Consumer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to handle global variables in the stack that we are using
    at the moment. These are through the new React Context API and the Apollo Consumer
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: There are further ways to handle global state management. One of the most famous
    libraries is Redux, but there are many more. As an explanation of Redux would
    outreach the topic of this book, we are only focusing on the tools provided by
    React and Apollo.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check other ways, have a look at Redux''s website: [https://redux.js.org/](https://redux.js.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: From version 16.3 of React, there is a Context API that allows you to define
    global providers offering data through deeply nested components. These components
    do not require your application to hand over the data through many components,
    from the top to the bottom of the React tree. Instead, it uses so-called consumers
    and providers. These are useful when you set up the `user` object at a global
    point of your application, and you can access it from anywhere. In earlier versions
    of React, you needed to pass the property down from component to component to
    get it to the correct component at the bottom of the React component tree. This
    passing of properties through multiple layers of components is also called "prop
    drilling."
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach to the React Context API is the Apollo Consumer feature,
    which is a specific implementation for Apollo. The React Context API is a general
    way of doing things, for Apollo or anything else that you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about the Apollo Consumer component is that it enables you to
    access the Apollo cache and use it as data storage. Using the Apollo Consumer
    component saves you from handling all the data, and you are also not required
    to implement the provider itself; you can consume the data wherever you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both approaches will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – User profile in the top bar'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – User profile in the top bar
  prefs: []
  type: TYPE_NORMAL
- en: The best option is to show you the two alternatives right away so that you can
    identify your preferred method.
  prefs: []
  type: TYPE_NORMAL
- en: The React Context API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start with the React method for storing and accessing global data in
    your frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short explanation of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**: This is a React approach for sharing data between components,
    without having to pass it through the complete tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provider**: This is a global component, mostly used at just one point in
    your code. It enables you to access the specific context data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer**: This is a component that can be used at many different points
    in your application, reading the data behind the context that you are referring
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, create a folder called `context` below the `components` folder.
    In that folder, create a `user.js` file, where we can set up the Context API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go over every step, one by one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we need to import all of the dependencies. Furthermore, we will
    set up a new empty context. The `createContext` function will return one provider
    and consumer to use throughout the application, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we want to use the provider. The best option here is to create a special
    `UserProvider` component. Later, when we have authentication, we can adjust it
    to do the GraphQL query, and then share the resultant data in our frontend. For
    now, we will stick with fake data. Insert the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code snippet, we render the `Provider` component from Apollo
    and wrap all the children in it. There is a `Consumer` component that reads from
    the `Provider`. We will set up a special `UserConsumer` component that takes care
    of passing the data to the underlying components by cloning them with React''s
    `cloneElement` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will export both classes directly under their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to introduce the provider at an early point in our code base. The best
    approach is to import the `UserProvider` component into the `App.js` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the provider as follows, and wrap it around all essential components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Everywhere in the `Bar`, `Feed`, and `Chats` components, we can now read from
    the provider.
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, we want to show the logged-in user, with their name, inside
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component using the data is the `UserBar` component. We need to create
    a `user.js` file inside of the `bar` folder. Insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: For the moment, we render a simple user container inside of the application
    bar, from the data of the `user` object.
  prefs: []
  type: TYPE_NORMAL
- en: To get the user data into the `UserBar` component, we need to use the `UserConsumer`
    component, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.js` file for the top bar and add the following code to the
    `return` statement, beneath the `SearchBar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, you need to import both of the components at the top of the file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You have now successfully configured and used the React Context API to save
    and read data globally.
  prefs: []
  type: TYPE_NORMAL
- en: The solution that we have is a general approach that will work for all scenarios
    that you can think of, including Apollo. If you view the browser now, you will
    be able to see the logged-in user or at least the fake data we added in the top
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we should cover the solution offered by Apollo itself.
  prefs: []
  type: TYPE_NORMAL
- en: Apollo Consumer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nearly all of the code that we have written can stay as it was in the previous
    section. We just need to remove the `UserProvider` component from the `App` class
    because it is not needed anymore for the Apollo Consumer component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `user.js` file in the `context` folder and replace the contents
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we import the `ApolloConsumer` component from the `@apollo-client`
    package. This package enables us to get access to the Apollo Client that we set
    up in [*Chapter 4*](B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085), *Hooking
    Apollo into React*.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have here is that we do not have a `CurrentUser` query that would
    respond with the logged-in user from the GraphQL, so we are not able to run the
    `readQuery` function. You would typically run the query against the internal cache
    of Apollo and be able to get the `user` object easily. Once we have implemented
    authentication, we will fix this problem.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will return the same fake object as we did with the React Context
    API. The Apollo Client replaces the `Provider` component that we used with the
    React Context API.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you can understand the difference between these two solutions. In
    the next chapter, you will see the `ApolloConsumer` component in full action,
    when the user query is established and can be read through the client of its cache.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting React applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have put a lot of work and code into our React application. To be honest,
    we can improve upon our code base by documenting it. We did not comment on our
    code, we did not add React component property-type definitions, and we have no
    automated documentation tool. Of course, we did not write any comments because
    you learned all of the techniques and libraries from the book, so no comments
    were needed. However, be sure to always comment your code outside of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript ecosystem, many different approaches and tools exist to document
    your application. For this book, we will use a tool called **React Styleguidist**.
    It was made especially for React. You cannot document other frameworks or code
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, this is an area that you can put months of work into without
    coming to a real end. If you are searching for a general approach for any framework
    or backend and frontend, I can recommend JSDoc, but there are many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond that, there are many different React documentation tools. If you want
    to check other tools, have a look here: [https://blog.bitsrc.io/6-tools-for-documenting-your-react-components-like-a-pro-5027cdfb40c6](https://blog.bitsrc.io/6-tools-for-documenting-your-react-components-like-a-pro-5027cdfb40c6).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the configuration for React Styleguidist.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up React Styleguidist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Styleguidist and our application rely on `webpack`. Just follow these
    instructions to get a working copy of it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install React Styleguidist using `npm`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Usually, the folder structure is expected to be `src/components`, but we have
    a `client` folder between the `src` and `components` folders, so we must configure
    React Styleguidist to let it understand our folder structure. Create a `styleguide.config.js`
    file in the root folder of the project to configure it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We export an object containing all the information needed for React Styleguidist.
    In addition to specifying the `components` path, we also require our main CSS
    style file. You will see why this can be useful later in this chapter. We must
    define the `webpackConfig` option because our `config` file has a custom name
    that is not found automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Styleguidist provides two ways to view the documentation. One is to build the
    documentation statically, in production mode, with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a `styleguide` folder, and inside the folder there are
    HTML files for our documentation. It is an excellent method when releasing new
    versions of your application so that you can save and back up those files with
    each version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you see an error while running `npx styleguidist`, you have to apply a short-term
    workaround.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install yarn by running `npm install -g yarn` and then add the following lines
    to the root level of your `package.json` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"resolutions": {**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"react-dev-utils": "12.0.0-next.47"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: You can then run `yarn install`. This will update an internal dependency of
    `styleguidist` to a newer version that does not have the problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can then run `npx styleguidist build` again. Just remember that in case
    you run `npm install`, it will overwrite this dependency with the old one and
    you will have to run `yarn install` again to get it working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method, for development cases, lets Styleguidist run and create
    documentation on the fly using `webpack`. Here''s the command you need for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the results under `http://localhost:6060`. The documentation should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – React Styleguidist documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – React Styleguidist documentation
  prefs: []
  type: TYPE_NORMAL
- en: In the left-hand panel, all of the components are listed in the order of our
    folder structure. You will always have an excellent overview of the existing components
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: In the main panel, each component is explained in detail. You may have noticed
    that the components are missing further information. We will change that next.
  prefs: []
  type: TYPE_NORMAL
- en: React PropTypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An essential feature of React is passing the properties to the child components.
    These can be anything from basic strings to numbers, but also complete components.
    We have already seen all of the scenarios in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Developers that are new to your code base need to read through all of the components
    and identify which properties they can accept.
  prefs: []
  type: TYPE_NORMAL
- en: React offers a way to describe properties from within each component. Documenting
    the properties of your components makes it easier for other developers to understand
    your React components.
  prefs: []
  type: TYPE_NORMAL
- en: We will take a look at how to do this with an example in our `Post` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two React features that we haven''t covered yet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If your components have optional parameters, it can make sense to have default
    properties in the first place. To do this, you can specify `defaultProps` as a
    static property, in the same way as with the state initializers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The important part is the `propTypes` field, which you can fill in for all of
    your components with the custom properties that they accept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A new package is required to define the property types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This package includes everything that we need to set up our property definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open your `Post` component''s `index.js` file. We need to import the new
    package at the top of this file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the new field to our component, before the `export` statement,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should help everyone to understand your component a bit better.
    Every developer should know that a `post` object is required for this component
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: The `PropTypes` package offers various types that we can use. You can access
    each type with `PropTypes.X`. If it is a required property, you can append `isRequired`
    in the same way as in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does React now throw an error inside of our console when the property
    does not exist, but React Styleguidist is also able to show which properties are
    needed, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Basic property documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Basic property documentation
  prefs: []
  type: TYPE_NORMAL
- en: However, what is a `post` object? What kind of fields does it include?
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to document a `post` object is to define which properties a post
    should include, at least for this specific component. Replace the property definition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `shape` function. This allows you to hand over a list of fields
    that the object contains. Each of those is given a type from the `PropTypes` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from React Styleguidist now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Detailed property documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Detailed property documentation
  prefs: []
  type: TYPE_NORMAL
- en: All the fields that we specified are listed separately. At the time of writing
    this book, React Styleguidist does not offer a recursive view of all properties.
    As you can see, the `user` object inside of the `post` object is not listed with
    its properties, but it is only listed as a second shape. If you need this feature,
    you can, of course, implement it yourself and send a `pull` request on the official
    GitHub repository, or switch to another tool.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: React offers way more property types and functions that you can use to document
    all of the components and their properties. To learn a bit more about this, visit
    the official documentation at [https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: One last great feature of React Styleguidist is that you can enter examples
    for every component. You can also use markdown to add some more descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `Post` component, we need to create an `index.md` file, next to the
    `index.js` file in the `post` folder. React Styleguidist proposes creating either
    a `Readme.md` or a `Post.md` file, but those did not work for me. The `index.md`
    file should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, you will not be able to see the output of that markup directly. The reason
    is that the `Post` component relies on Apollo. If you just render the plain `Post`
    component in the way React Styleguidist does, the Apollo Client will not be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this issue, we can overwrite the default way React Styleguidist renders
    any component. Follow these instructions to get it working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder where we can save all special React Styleguidist components,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `Wrapper.js` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be the standard `Wrapper` component for all components that React
    Styleguidist runs. This way, we ensure that we always have the Apollo Client in
    the context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last thing we need to do is to add the following property to the `styleguide.config.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: React Styleguidist will now use this `Wrapper` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you restart React Styleguidist, it will render the documentation and generate
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – React Styleguidist example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B17337.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – React Styleguidist example
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can see why it was useful to use the CSS style. Not only can React
    Styleguidist document the code, but it can also execute it within the documentation.
    As in the preceding code, providing the correct properties inside of the `post`
    object enables us to see how the component should look, including the correct
    styling.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how reusable our `Post` component is since it is usable without
    having to run the Apollo query.
  prefs: []
  type: TYPE_NORMAL
- en: The basics should be clear by now. Continue to read up on this topic because
    there are more things to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, you have gained a lot of experience in writing a React
    application. You have applied multiple React patterns to different use cases,
    such as children passing through a pattern and conditional rendering. Furthermore,
    you now know how to document your code correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to use the React Context API, in comparison with the Apollo
    Consumer feature, to retrieve the currently logged-in user in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to implement authentication in your
    backend and use it in the frontend.
  prefs: []
  type: TYPE_NORMAL
