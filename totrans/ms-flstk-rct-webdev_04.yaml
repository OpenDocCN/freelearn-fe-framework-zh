- en: Advanced Redux and Falcor on the Client Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端的高级Redux和Falcor
- en: Redux is our app's state container which keeps the information about how the
    React view layer shall render in the browser. On the other hand, Falcor differs
    from Redux, because it is the full-stack toolset that replaces the outdated approach
    of API endpoints data communication. In the next pages, we will  work with Falcor
    on the client side, but you need to remember that Factor is a full-stack library.
    That means, we need to use it on both sides (where on backend we use an additional
    library called Falcor-Router). Starting from [Chapter 5](part0140.html#45GEO0-7870c13caa1244daa9bd53ca5c1e1a42),
    *Falcor Advanced Concepts*, we will work with full-stack Falcor. While in the
    current chapter, we will focus only on the client side.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是我们应用程序的状态容器，它保存有关React视图层如何在浏览器中渲染的信息。另一方面，Falcor与Redux不同，因为它是一个全栈工具集，它取代了过时的API端点数据通信方法。在下一页中，我们将从客户端使用Falcor，但你需要记住Factor是一个全栈库。这意味着，我们需要在两端使用它（在后端我们使用一个名为Falcor-Router的附加库）。从[第5章](part0140.html#45GEO0-7870c13caa1244daa9bd53ca5c1e1a42)，“Falcor高级概念”开始，我们将使用全栈Falcor。而在当前章节中，我们将只关注客户端。
- en: Focusing on the app's frontend
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专注于应用程序的前端
- en: Currently, our app is a simple starter kit, which is a skeleton for its further
    development. We need to focus more on the customer-facing frontend because it's
    important to have a good-looking frontend in the current age. Thanks to Material
    UI, we can reuse many things to make our app look prettier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序是一个简单的入门套件，它是进一步开发的骨架。我们需要更多地关注面向客户的客户端前端，因为在这个时代拥有一个好看的客户端前端非常重要。多亏了Material
    UI，我们可以重用许多东西来使我们的应用程序看起来更漂亮。
- en: It's important to note that responsive web design is not in the scope of this
    book at this point (and overall), so you need to find out how all the styles can
    be improved for mobile. The app we are going to work on will look fine on tablets,
    but small mobile screens may not look so good.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，响应式网页设计目前（以及总体上）不在此书的范围内，因此你需要找出如何改进所有样式以适应移动设备。我们将要工作的应用程序在平板电脑上看起来很好，但小屏幕手机可能看起来不那么好。
- en: 'In this chapter, we will focus our efforts on the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将集中精力做以下工作：
- en: Unmocking `fetchServerSide.js`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消模拟`fetchServerSide.js`
- en: Adding a new `ArticleCard` component, which will make our main page more professional
    for our users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的`ArticleCard`组件，这将使我们的主页对用户来说更加专业
- en: Improving the general look of our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进我们应用程序的一般外观
- en: Implementing the ability to logout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现登出功能
- en: Adding a WYSIWYG editor in `Draft.js` which is a rich text-editor framework
    for React created by the Facebook team
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Draft.js`中添加一个所见即所得（WYSIWYG）编辑器，这是一个由Facebook团队为React创建的富文本编辑器框架
- en: Adding the ability to create new articles in our Redux frontend application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Redux前端应用程序中添加创建新文章的功能
- en: Backend wrap-up before frontend improvement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前端改进之前完成后端工作
- en: In the previous chapter, we performed a server-side rendering that will affect
    our users such that they will see their articles quicker and will improve our
    website's SEO as the whole HTML markup is being rendered on the server side.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们执行了服务器端渲染，这将影响我们的用户，使他们能够更快地看到他们的文章，并且由于整个HTML标记都在服务器端渲染，这将提高我们网站的SEO。
- en: 'The last thing to make our server-side rendering work 100% is to unmock the
    server-side article fetching in `/server/fetchServerSide.js`. The new code for
    fetching is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的服务器端渲染工作达到100%，最后一步是取消模拟`/server/fetchServerSide.js`中的服务器端文章获取。获取的新代码如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Improving handleServerSideRender
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`handleServerSideRender`
- en: 'The next step is to tweak the `handleServerSideRender` function, which is currently
    kept in the `/server/server.js` file. The current function is as shown in the
    following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对`handleServerSideRender`函数进行微调，该函数目前保存在`/server/server.js`文件中。当前的函数如下代码片段所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to replace it with this improved one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用这个改进版本来替换它：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is new in our improved `handleServerSideRender`? As you can see, we have
    added `async await`. Recall that it is helping us make our code less painful with
    asynchronous calls such as queries to the database (synchronous-looking generator-style
    code). This ES7 feature helps us write asynchronous calls as if they're synchronous
    ones--under the hood, `async await` is much more complicated (after it's transpiled
    into ES5 so that it can be run in any modern browser), but we won't get into details
    of how `async await` works because it's not in the scope of this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改进的`handleServerSideRender`有什么新内容？如您所见，我们添加了`async await`。回想一下，它帮助我们使代码在异步调用（如对数据库的查询）上不那么痛苦（看起来同步的生成器风格代码）。这个ES7特性使我们能够将异步调用写成同步的样子——在底层，`async
    await`要复杂得多（在它被转换为ES5之后，以便可以在任何现代浏览器中运行），但我们将不会深入探讨`async await`是如何工作的，因为这不在这个章节的范围内。
- en: Changing routes in Falcor (frontend and backend)
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Falcor中更改路由（前端和后端）
- en: You also need to change the two ID variable names to `_id` (`_id` is a default
    name for the ID of a document in a Mongo collection).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将两个ID变量名更改为`_id`（`_id`是Mongo集合中文档ID的默认名称）。
- en: 'Look in `server/routes.js` for this old code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server/routes.js`中查找以下旧代码：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Change it into the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The only change is that we will return `_id` instead of `id`. We need to fetch
    the `_id` value in `src/layouts/PublishingApp.js`, so find the following code
    snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是我们将返回`_id`而不是`id`。我们需要在`src/layouts/PublishingApp.js`中获取`_id`值，所以找到以下代码片段：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change it into the new one with `_id`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为带有`_id`的新路由：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our website header and articles list need improvements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的网站页眉和文章列表需要改进
- en: Since we've finished wrapping up the server-side rendering and fetching articles
    from the DB, let's start with the frontend.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了服务器端渲染和从数据库中获取文章的封装，让我们从前端开始。
- en: 'First, delete the following header from `server/server.js`; we don''t need
    it anymore:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`server/server.js`中删除以下标题；我们不再需要它了：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also delete this header in `src/layouts/PublishingApp.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在`src/layouts/PublishingApp.js`中删除这个标题：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Delete the `h1` markup in the registration and login view (`src/LoginView.js`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册和登录视图（`src/LoginView.js`）中删除`h1`标记：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Delete registration in `src/RegisterView.js`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/RegisterView.js`中删除注册：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All these `h1` lines are not needed as we want to have a nice-looking design
    instead of an outdated one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`h1`行都不需要，因为我们想要一个看起来更美观的设计，而不是过时的设计。
- en: 'After this, go to `src/CoreLayout.js` and import a new `AppBar` component and
    two button components from the Material UI:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`src/CoreLayout.js`并从Material UI导入一个新的`AppBar`组件和两个按钮组件：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add this `AppBar` together with inline styles into `render`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将此`AppBar`连同内联样式一起添加到`render`中：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have added the inline styles for `buttonStyle` and `homeIconStyle`. The
    `menuLinksJSX` and `homePageButtonJSX`''s visual output will improve. This is
    how your app will be looking after those `AppBar` changes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`buttonStyle`和`homeIconStyle`添加了内联样式。`menuLinksJSX`和`homePageButtonJSX`的视觉输出将会得到改善。这就是在那些`AppBar`更改之后您的应用将呈现的样子：
- en: '![](img/00030.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: New ArticleCard component
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的ArticleCard组件
- en: 'The next step in order to improve the look of our home page is to make article
    cards based on the Material Design CSS as well. Let''s create a component''s file
    first:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进主页的外观，下一步是使文章卡片基于Material Design CSS。让我们首先创建一个组件文件：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in the `ArticleCard.js` file, let''s initialize the `ArticleCard` component
    with the following content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ArticleCard.js`文件中，让我们使用以下内容初始化`ArticleCard`组件：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can find in the preceding code, we have imported the required components
    from material-ui/card that will help our home page''s articles list look nice.
    The next step is to improve our article card''s `render` function with the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中可以看到，我们已从material-ui/card导入所需的组件，这将帮助我们的主页文章列表看起来更美观。下一步是使用以下内容改进文章卡片的`render`函数：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can find in the preceding code, we have created an article card, and
    there are some inline styles for the `Paper` component and left and right `div`.
    Feel free to change the styles if you want.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中可以看到，我们创建了一个文章卡片，并为`Paper`组件以及左右`div`添加了一些内联样式。如果您想的话，可以随意更改这些样式。
- en: 'In general, we are missing two static images in the previous `render` function,
    which are `src= ''/static/placeholder.png''` and `avatar=''/static/avatar.png''`.
    Let''s add them using the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在之前的`render`函数中缺少两张静态图片，分别是`src= '/static/placeholder.png'`和`avatar='/static/avatar.png'`。让我们按照以下步骤添加它们：
- en: 'Make a PNG file with the name `placeholder.png` in the `dist` directory. In
    my case, this is what my `placeholder.png` file looks like:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dist` 目录中创建一个名为 `placeholder.png` 的 PNG 文件。在我的情况下，我的 `placeholder.png` 文件如下所示：
- en: '![](img/00031.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: Also create an `avatar.png` file in the `dist` directory that will be exposed
    in `/static/avatar.png`. I am not providing the screenshot here, as it has my
    personal photo in it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在 `dist` 目录中创建一个 `avatar.png` 文件，它将在 `/static/avatar.png` 中公开。这里不提供截图，因为它包含我的个人照片。
- en: The `/static/` file in `express.js` is exposed in the `/server/server.js` file
    with `codeapp.use('/static', express.static('dist'));` (you will already have
    it in there as we have added this in the previous chapter).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.js` 中的 `/static/` 文件在 `/server/server.js` 文件中使用 `codeapp.use(''/static'',
    express.static(''dist''));` 公开（您已经在其中添加了它，因为我们已经在上一章中添加了它）。'
- en: The last thing is that you need to import `ArticleCard` and modify the render
    of `layouts/PublishingApp.js` from the old simple view to the new one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要导入 `ArticleCard` 并修改 `layouts/PublishingApp.js` 的渲染，从旧的单视图修改为新视图。
- en: 'Add `import` to the top of the file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加 `import`：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, replace the render with this new one:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用这个新视图替换渲染：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding new code only differs in this new `ArticleCard` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述新代码仅在此新的 `ArticleCard` 组件中有所不同：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also have added some styles to `div style={{height: ''100%'', width: ''75%'',
    margin: ''auto''}}`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还在 `div style={{height: ''100%'', width: ''75%'', margin: ''auto''}}` 中添加了一些样式。'
- en: 'On following all these steps exactly in terms of styles, this is what you will
    see:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全按照这些步骤执行样式的情况下，您将看到以下内容：
- en: '![](img/00032.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'This is the register user view:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是注册用户视图：
- en: '![](img/00033.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: 'This is the login user view:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是登录用户视图：
- en: '![](img/00034.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: Dashboard - adding an article button, logout, and header improvements
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板 - 添加文章按钮、注销和页眉改进
- en: Our plan for now is to create a logout mechanism, make our header aware whether
    a user is logged in or not, and based on that information show different buttons
    in the header (Login/Register when a user is not logged in and Dashboard/Logout
    when a user is logged in) We will create an Add Article button in our dashboard
    and create a mocked view with a mocked WYSIWYG (we will unmock it later).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前的计划是创建一个注销机制，让我们的页眉知道用户是否已登录，并基于此信息在页眉中显示不同的按钮（当用户未登录时显示“登录/注册”，当用户登录时显示“仪表板/注销”）。我们将在仪表板中创建一个“添加文章”按钮，并创建一个带有模拟
    WYSIWYG 的模拟视图（我们稍后会取消模拟）。
- en: '**WYSIWYG** stands for **what you see is what you get**, of course.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**WYSIWYG** 代表 **所见即所得**，当然。'
- en: 'The WYSIWYG mockup will be located in `src/components/articles/WYSIWYGeditor.js`,
    so you need to create a new directory and file in `components` with the following
    commands:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: WYSIWYG 模拟将位于 `src/components/articles/WYSIWYGeditor.js`，因此您需要在 `components`
    中创建一个新的目录和文件，以下是一些命令：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then our `WYSIWYGeditor.js` mock content will be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的 `WYSIWYGeditor.js` 模拟内容将如下所示：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to create a logout view at `src/views/LogoutView.js`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在 `src/views/LogoutView.js` 中创建一个注销视图：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `src/views/LogoutView.js` file''s content is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/views/LogoutView.js` 文件的内容如下：'
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `logout` view mentioned here is a simple view without a connecting function
    to Redux (in comparison with `LoginView.js`). We are using some styling to make
    it nice, with the `Paper` component from Material UI.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的 `logout` 视图是一个没有连接到 Redux 的简单视图（与 `LoginView.js` 相比）。我们使用一些样式使其看起来更美观，使用了
    Material UI 的 `Paper` 组件。
- en: The `componentWillMount` function is deleted from the `localStorage` information
    when the user lands on the logout page. As you can see, it also checks whether
    there is `localStorage` with `**if(typeof localStorage !== 'undefined' && localStorage.token)
    **` because, as you can imagine, when you perform server-side rendering, `localStorage`
    is undefined (the server side doesn't have `localStorage` and `window` like the
    client side).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问注销页面时，`componentWillMount` 函数将从 `localStorage` 信息中删除。如您所见，它还检查是否存在带有 `**if(typeof
    localStorage !== 'undefined' && localStorage.token) **` 的 `localStorage`，因为正如您所想象的那样，当您执行服务器端渲染时，`localStorage`
    是未定义的（服务器端没有 `localStorage` 和 `window`，就像客户端一样）。
- en: Important note before creating a frontend add article feature
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在创建前端添加文章功能之前的重要注意事项
- en: We've come to the point where you need to delete all documents from your articles
    collection, or you may have some trouble performing the next steps as we are going
    to use a draft-js library and some other stuff that will need a new schema on
    the backend. We will create that backend's schema in the next chapter as this
    chapter is focused on the frontend.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了需要从你的MongoDB文章集合中删除所有文档的点，否则在执行下一步之前你可能会有一些麻烦，因为我们将要使用draft-js库和一些其他东西，它们在服务器端需要一个新的模式。我们将在下一章创建该后端模式，因为本章专注于前端。
- en: Delete all documents in your MongoDB articles collection right now, but keep
    the user collection as it was (don't delete users from the database).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在立即删除你的MongoDB文章集合中的所有文档，但保留用户集合不变（不要从数据库中删除用户）。
- en: The AddArticleView component
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddArticleView组件
- en: 'After creating the `LogoutView` and the `WYSIWYGeditor` components, let''s
    create the final missing component in our process: the `src/views/articles/AddArticleView.js`
    file. So let''s create a directory and file now:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了`LogoutView`和`WYSIWYGeditor`组件之后，让我们创建我们流程中缺失的最后一个组件：`src/views/articles/AddArticleView.js`文件。现在让我们创建一个目录和文件：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As a result, you''ll have that file in your `views/articles` directory. We
    need to put content into it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将在`views/articles`目录中找到该文件。我们需要将其内容放入其中：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see here, it's a simple React view, and it imports the `WYSIWYGeditor`
    component that we created a moment ago (`import WYSIWYGeditor from '../../components/articles/WYSIWYGeditor.js'`).
    We have some inline styles in order to make the view look nicer for our user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，这是一个简单的React视图，它导入了我们刚才创建的`WYSIWYGeditor`组件（`import WYSIWYGeditor from
    '../../components/articles/WYSIWYGeditor.js'`）。我们有一些内联样式，以便让视图对用户看起来更美观。
- en: 'Let''s create two new routes for a logout and for an add article feature by
    modifying the `routes` file at the `**src/routes/index.js*` location:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改位于`**src/routes/index.js*`位置的`routes`文件来创建两个新的路由，一个用于登出，另一个用于添加文章功能：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As explained in our `src/routes/index.js` file, we have added two routes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在`src/routes/index.js`文件中解释的那样，我们添加了两个路由：
- en: '`<Route component={LogoutView} path=''logout'' name=''logout'' />`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Route component={LogoutView} path=''logout'' name=''logout'' />`'
- en: '`<Route component={AddArticleView} path=''add-article'' name=''add-article''
    />`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Route component={AddArticleView} path=''add-article'' name=''add-article''
    />`'
- en: 'Don''t forget to import those two views'' components with the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用以下方式导入这两个视图的组件：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we have created the views and created routes into that view. The last piece
    is to show links into those two routes in our app.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了视图并创建了进入该视图的路由。最后一步是在我们的应用中显示这两个路由的链接。
- en: 'First let''s create the `src/layouts/CoreLayout.js` component so it will have
    a login/logout-type login so that a logged-in user will see different buttons
    than a user who isn''t. Modify the `render` function in the `CoreLayout` component
    to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建`src/layouts/CoreLayout.js`组件，以便它将有一个登录/登出类型的登录，这样登录用户将看到与未登录用户不同的按钮。修改`CoreLayout`组件中的`render`函数如下：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can see that the new part in the preceding code is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，前面代码中的新部分如下：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have added `let userIsLoggedIn = typeof localStorage !== 'undefined' && localStorage.token
    && this.props.routes[1].name !== 'logout';`. The `userIsLoggedIn` variable is
    found if we are not on the server side (then it doesn't have `localStorage` as
    mentioned earlier). Then, it checks whether `localStorage.token` is `yes`, and
    also checks whether a user didn't click on the logout button with the `this.props.routes[1].name
    !== 'logout'` expression. The `this.props.routes[1].name` value/information is
    provided by the `redux-simple-router` and `react-router`. This is always the name
    of our current route on the client side, so we can render the proper buttons based
    on that information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`let userIsLoggedIn = typeof localStorage !== 'undefined' && localStorage.token
    && this.props.routes[1].name !== 'logout';`。如果不在服务器端（如前所述，它没有`localStorage`），则找到`userIsLoggedIn`变量。然后，它检查`localStorage.token`是否为`yes`，并使用`this.props.routes[1].name
    !== 'logout'`表达式检查用户是否没有点击登出按钮。`this.props.routes[1].name`值/信息由`redux-simple-router`和`react-router`提供。这始终是客户端当前路由的名称，因此我们可以根据该信息渲染适当的按钮。
- en: Modifying DashboardView
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改DashboardView
- en: As you will find, we have added the `if (userIsLoggedIn)` statement, and the
    new part is the dashboard and logout `RaisedButton` entities with links to the
    correct routes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将发现的，我们添加了`if (userIsLoggedIn)`语句，新部分是包含到正确路由的仪表板和登出`RaisedButton`实体。
- en: 'The last piece to finish at this stage is to modify the `src/views/DashboardView.js`
    component. Add link to the `/add-article` route using the `{Link}` component imported
    from react-router. Also, we need to import new Material UI components in order
    to make `DashboardView` nicer:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，最后要完成的部分是修改 `src/views/DashboardView.js` 组件。使用从 react-router 导入的 `{Link}`
    组件添加到 `/add-article` 路由的链接。此外，我们需要导入新的 Material UI 组件，以便使 `DashboardView` 更美观：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After you have imported all this in your `src/views/DashboardView.js` file,
    then we need to start work on improving the `render` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将所有这些导入到您的 `src/views/DashboardView.js` 文件之后，然后我们需要开始改进 `render` 函数：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we have our new `render` function for `DashboardView`. We are using the
    `ListItem` component to make our nice lists. We have also added the link and button
    to the `/add-article` routes. There are some inline styles, but feel free to style
    this app on your own.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `DashboardView` 创建了新的 `render` 函数。我们使用 `ListItem` 组件来制作我们漂亮的项目列表。我们还添加了链接和按钮到
    `/add-article` 路由。有一些内联样式，但请随意根据您的喜好来设计这个应用。
- en: 'Let''s look at a few screenshots of how the app looks after all these changes
    after adding the CREATE AN ARTICLE button with a new view of articles:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在添加了创建文章按钮并添加了文章的新视图之后，应用的所有这些变化后的截图：
- en: '![](img/00035.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: 'After having mocked WYSIWYG on the `/add-article` view:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟了 `/add-article` 视图中的 WYSIWYG 之后：
- en: '![](img/00036.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.jpeg)'
- en: 'Our new logout view page will look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的注销视图页面看起来是这样的：
- en: '![](img/00037.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: Starting work on our WYSIWYG
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始我们的 WYSIWYG 工作吧
- en: Let's install a draft-js library, which is "a framework for building rich text
    editors in React, powered by an immutable model and abstracting over cross-browser
    differences," as stated on their website.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装一个 draft-js 库，它是一个“在 React 中构建富文本编辑器的框架，由不可变模型驱动，并抽象了跨浏览器的差异”，正如他们在网站上所描述的。
- en: In general, draft-js is made by friends from Facebook, and it helps us make
    powerful WYSIWYG tools. It will be useful in our publishing app as we want to
    provide good tools for our editors in order to create interesting articles on
    our platform.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，draft-js 是由 Facebook 的朋友们制作的，它帮助我们创建强大的 WYSIWYG 工具。在我们的发布应用中，这将很有用，因为我们希望为我们的编辑提供良好的工具，以便在我们的平台上创建有趣的文章。
- en: 'Let''s install it first:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装它：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will use version 0.5.0 of draft-js in our book. Before we start coding,
    let''s install one more dependency that will be helpful later in fetching the
    articles from the DB via Falcor. Execute the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中使用 draft-js 的 0.5.0 版本。在我们开始编码之前，让我们安装一个额外的依赖项，这将有助于我们稍后通过 Falcor 从数据库中获取文章。执行以下命令：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In general, the `falcor-json-graph@1.1.7` syntax provides us with the ability
    to use different sentinels provided via the Falcor helper library (which will
    be described in detail in the next chapter).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`falcor-json-graph@1.1.7` 语法为我们提供了使用通过 Falcor 辅助库提供的不同哨兵的能力（这将在下一章中详细描述）。
- en: Stylesheet for the draft-js WYSIWYG
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: draft-js WYSIWYG 的样式表
- en: 'In order to style draft-js editor, we need to create a new CSS file in the
    `dist` folder located at `dist/styles-draft-js.css`. It''s the only place where
    we will put a CSS stylesheet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了样式化 draft-js 编辑器，我们需要在 `dist` 文件夹中创建一个新的 CSS 文件，位于 `dist/styles-draft-js.css`。这是我们唯一放置
    CSS 样式表的地方：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After you have created this file at `dist/styles-draft-js.css`, we need to
    import it to `server/server.js`, where we have been creating the HTML header,
    so the following code is already present in the `server.js` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在 `dist/styles-draft-js.css` 创建了这个文件之后，我们需要将其导入到 `server/server.js` 中，在那里我们一直在创建
    HTML 头部，所以以下代码已经存在于 `server.js` 文件中：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then you need to include the link to the stylesheet with this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要包含样式表的链接，如下所示：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Nothing fancy so far. After we are done with the styles for our rich text WYSIWYG
    editor, let's have some fun.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有什么特别之处。在我们完成我们的富文本 WYSIWYG 编辑器的样式之后，让我们享受一些乐趣。
- en: Coding a draft-js skeleton
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码 draft-js 骨架
- en: Let's get back to the `src/components/articles/WYSIWYGeditor.js` file. It's
    currently mocked, but we will improve it now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `src/components/articles/WYSIWYGeditor.js` 文件。它目前是模拟的，但我们将现在对其进行改进。
- en: Just to make you aware, we will make a skeleton of the WYSIWYG right now. We
    will improve it later in the book. At this point, the WYSIWYG won't have any functionalities
    such as making text bold or creating lists with OL and UL elements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提醒一下，我们现在将创建一个 WYSIWYG 的骨架。我们将在本书的后续章节中对其进行改进。到目前为止，WYSIWYG 不会有任何功能，例如使文本加粗或使用
    OL 和 UL 元素创建列表。
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have created only a constructor of our new draft-js file's WYSIWYG.
    The `let initialEditorFromProps = EditorState.createWithContent(ContentState.createFromText(''));`
    expression is simply creating an empty WYSIWYG container. Later, we will improve
    it so we are able to receive `ContentState` from the database when we would like
    to edit our WYSIWYG.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只创建了我们的新draft-js文件的WYSIWYG的构造函数。`let initialEditorFromProps = EditorState.createWithContent(ContentState.createFromText(''));`这个表达式只是创建了一个空的WYSIWYG容器。稍后，我们将对其进行改进，以便我们能够在想要编辑WYSIWYG时从数据库接收`ContentState`。
- en: 'The `editorState: initialEditorFromProps` is our current state. Our `**this.onChange
    = (editorState) => { **` line is firing on each change, so our view component
    at `src/views/articles/AddArticleView.js` will know about any changes in the WYSIWYG.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`editorState: initialEditorFromProps`是我们当前的状态。我们的`**this.onChange = (editorState)
    => { **`这一行会在每次更改时触发，因此我们的`src/views/articles/AddArticleView.js`视图组件将知道WYSIWYG中的任何更改。'
- en: Anyway, you can check the documentation of draft-js at [https://facebook.github.io/draft-js/](https://facebook.github.io/draft-js/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你可以在[https://facebook.github.io/draft-js/](https://facebook.github.io/draft-js/)查看draft-js的文档。
- en: 'This is just the beginning; the next step is to add two new functions under
    `onChange`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是开始；下一步是在`onChange`下添加两个新功能：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And add a new function in our `WYSIWYGeditor` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`WYSIWYGeditor`类中添加一个新函数：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After all these changes, this is how your construction of the `WYSIWYGeditor`
    class should look:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更改之后，你的`WYSIWYGeditor`类的构建应该看起来像这样：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And the rest of this class is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的其余部分如下：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to improve the `render` function with the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下代码改进`render`函数：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, what we have done is simply use the draft-js API in order to make a simple
    rich editor; later, we will make it more functional, but for now, let's focus
    on something simple.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们所做的是简单地使用draft-js API来制作一个简单的富文本编辑器；稍后，我们将使其更加功能化，但现在让我们专注于简单的事情。
- en: Improving the views/articles/AddArticleView component
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进`views/articles/AddArticleView`组件
- en: 'Before we move forward with adding all the WYSIWYG features, such as bolding,
    we need to improve the `views/articles/AddArticleView.js` component with a few
    things. Install a library that will convert the draft-js state into plain HTML
    with the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加所有WYSIWYG功能（如加粗）之前，我们需要通过以下方式使用一些东西来改进`views/articles/AddArticleView.js`组件：安装一个库，该库将convert
    draft-js状态转换为纯HTML：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will use this library to save read-only plain HTML for our regular readers.
    Next, import this into `src/views/articles/AddArticleView.js`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个库来保存只读的纯HTML，供我们的普通读者使用。接下来，将其导入到`src/views/articles/AddArticleView.js`：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Improve `AddArticleView` by changing a constructor and adding a new function
    called `_onDraftJSChange`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改构造函数并添加一个名为`_onDraftJSChange`的新函数来改进`AddArticleView`：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We need to save on each change a state of `this.setState({contentJSON, htmlContent});`.
    This is because `contentJSON` will be saved into the database in order to have
    immutable information about our WYSIWYG and `htmlContent` will be the server for
    our readers. Both `htmlContent` and `contentJSON` variables will be kept in the
    articles collection. The last thing in the `AddArticleView` class is to modify
    `render` to new code, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次更改时保存`this.setState({contentJSON, htmlContent});`的状态。这是因为`contentJSON`将被保存到数据库中，以便我们有关于我们的WYSIWYG不可变信息的记录，而`htmlContent`将是我们的读者服务器。`htmlContent`和`contentJSON`变量都将保存在文章集合中。`AddArticleView`类中的最后一件事是修改`render`到新代码，如下所示：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After all these changes, the new view that you will see is this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更改之后，你将看到的新视图如下：
- en: '![](img/00038.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Adding more formatting features to our WYSIWYG
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的WYSIWYG添加更多格式化功能
- en: 'Let''s start working on version two of our WYSIWYG, with more options, as in
    the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的WYSIWYG的第二版开始工作，它提供了更多选项，如下所示：
- en: '![](img/00039.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: After you follow the steps mentioned here, you will be able to format your text
    as follows and extract the HTML markup from it as well so that we can save both
    the JSON state of our WYSIWYG and plain HTML in our MongoDB articles collection.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循这里提到的步骤之后，你将能够按照以下方式格式化文本，并从中提取HTML标记，这样我们就可以在我们的MongoDB文章集合中保存WYSIWYG的JSON状态和纯HTML。
- en: 'In the following new file, called `WYSIWYGbuttons.js`, we will export two different
    classes, and we will import them into `components/articles/WYSWIWYGeditor.js`
    using the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下新文件中，称为`WYSIWYGbuttons.js`，我们将导出两个不同的类，并且我们将使用以下方式将它们导入到`components/articles/WYSWIWYGeditor.js`：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In general, that new file will have three different React components, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个新文件将包含三个不同的React组件，如下所示：
- en: '`StyleButton`: This will be a generic-style button that will be used in both
    `BlockStyleControls` and `InlineStyleControls`. Don''t get confused by the fact
    that in the `WYSIWYGbuttons` file, you are creating the `StyleButton` React component
    first.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StyleButton`：这将是用于`BlockStyleControls`和`InlineStyleControls`的通用样式按钮。不要因为`WYSIWYGbuttons`文件中首先创建`StyleButton`
    React组件而感到困惑。'
- en: '`BlockStyleControls`: This is an exported component, which will be used for
    block controls such as `H1`, `H2`, `Blockquote`, `UL`, and `OL`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockStyleControls`：这是一个导出的组件，将用于块控件，如`H1`、`H2`、`Blockquote`、`UL`和`OL`。'
- en: '`InlineStyleControls`: This component is used for bold, italics, and underline.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InlineStyleControls`：此组件用于粗体、斜体和下划线。'
- en: Now we are aware that in the new file, you will create three separate React
    components.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道在新文件中，您将创建三个独立的React组件。
- en: 'First, we need to create the WYSWIG buttons in the `src/components/articles/wysiwyg/WYSIWYGbuttons.js`
    location:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`src/components/articles/wysiwyg/WYSIWYGbuttons.js`位置创建WYSWYG按钮：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The content of this file will be the buttons component:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的内容将是按钮组件：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code is giving us a reusable button with a certain label at `this.props.label`.
    As mentioned before, don't get confused with `WYSIWYGbuttons`; it's a generic
    button component that will be reused in the inline and block type button controls.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为我们提供了一个具有特定标签`this.props.label`的可重用按钮。如前所述，不要与`WYSIWYGbuttons`混淆；它是一个通用的按钮组件，将在内联和块类型按钮控件中重用。
- en: 'Next, under that component, you can put the following object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在该组件下，您可以放置以下对象：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This object is block type, which we can create in our draft-js WYSIWYG. It
    is used in the following component:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象是块类型，我们可以在我们的draft-js WYSWYG中创建它。它用于以下组件：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding code is a whole bunch of buttons for block-style formatting. We
    will import them into `WYSIWYGeditor` in a while. As you can see, we are exporting
    it with `export const BlockStyleControls = (props) => {`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一系列用于块样式格式的按钮。我们将在稍后将其导入`WYSIWYGeditor`。如您所见，我们使用`export const BlockStyleControls
    = (props) => {`导出它。
- en: 'Put the next object under the `BlockStyleControls` component, but this time,
    for inline styles such as `Bold`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BlockStyleControls`组件下放置下一个对象，但这次是为了内联样式，如`Bold`：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, in our WYSIWYG, an editor will be able to use bold, italics,
    and underline.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在我们的WYSWYG中，编辑器将能够使用粗体、斜体和下划线。
- en: 'The last component for those inline styles that you can put under all this
    is the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些内联样式，您可以放置的最后一个组件如下：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, this is very simple. We are mapping the defined styles in the
    blocks and inline styles each time, and based on each iteration, we are creating
    `StyleButton`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这非常简单。我们每次都在映射块和内联样式定义的样式，并根据每次迭代创建`StyleButton`。
- en: 'The next step is to import both `InlineStyleControls` and `BlockStyleControls`
    in our `WYSIWYGeditor` component (`src/components/articles/WYSIWYGeditor.js`):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`InlineStyleControls`和`BlockStyleControls`导入我们的`WYSIWYGeditor`组件（`src/components/articles/WYSIWYGeditor.js`）：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, in the `WYSIWYGeditor` constructor, include the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`WYSIWYGeditor`构造函数中，包含以下代码：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Bind to `toggleInlineStyle` and `toggleBlockType` two arrow functions, which
    will be the callbacks when someone chooses the toggle in order to use inline or
    block type in our `WYSIWYGeditor` (we will create those functions in a moment).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`toggleInlineStyle`和`toggleBlockType`两个箭头函数，这些函数将作为有人选择切换以在`WYSIWYGeditor`中使用内联或块类型时的回调（我们将在稍后创建这些函数）。
- en: 'Create these two new functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这两个新函数：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, both functions are using the draft-js `RichUtils` in order to set flags
    inside our WYSIWYG. We are using certain formatting options from `BLOCK_TYPES`
    and `INLINE_STYLES` that we have defined in the `import { BlockStyleControls,
    InlineStyleControls }` from `'./wysiwg/WYSIWGbuttons';`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个函数都使用draft-js的`RichUtils`来设置我们WYSWYG内部的标志。我们使用从`import { BlockStyleControls,
    InlineStyleControls }` from `'./wysiwg/WYSIWYGbuttons';`中定义的`BLOCK_TYPES`和`INLINE_STYLES`中的某些格式化选项。
- en: 'After we are done improving our `WYSIWYGeditor` construction and the `_toggleBlockType`
    and `_toggleInlineStyle` functions, then we can start improving our `render` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成改进`WYSIWYGeditor`构造和`_toggleBlockType`和`_toggleInlineStyle`函数后，然后我们可以开始改进我们的`render`函数：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you may notice, in the preceding code, we have only added the `BlockStyleControls`
    and `InlineStyleControls` component. Also notice that we are using callbacks with
    `onToggle={this.toggleBlockType}` and `onToggle={this.toggleInlineStyle}`; this
    is for communicating between our `WYSIWYGbuttons` and the draft-js `RichUtils`
    about what a user has clicked on and in which mode they are currently using (such
    as bold, header1, and UL or OL).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，在前面的代码中，我们只添加了`BlockStyleControls`和`InlineStyleControls`组件。同时请注意，我们正在使用`onToggle={this.toggleBlockType}`和`onToggle={this.toggleInlineStyle}`回调；这是为了在我们`WYSIWYGbuttons`和draft-js
    `RichUtils`之间通信，了解用户点击了什么以及他们当前使用的是哪种模式（例如粗体、标题1、UL或OL）。
- en: Pushing a new article into article reducer
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新文章推入文章reducer
- en: 'We need to create a new action called `pushNewArticle` in the `src/actions/article.js`
    location:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`src/actions/article.js`位置创建一个名为`pushNewArticle`的新操作：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next step is to improve the `src/components/ArticleCard.js` component by
    improving the `render` function in it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进`src/components/ArticleCard.js`组件，通过改进其中的`render`函数：
- en: '[PRE58]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, we have replaced the old `{content}` variable (which was receiving a
    plain text value in the content''s variable) to a new one that shows all of the
    HTML using `dangerouslySetInnerHTML` in the article card:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将旧的`{content}`变量（它接收内容变量中的纯文本值）替换为一个新的变量，该变量在文章卡片中使用`dangerouslySetInnerHTML`显示所有HTML：
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will help us show our readers the HTML code generated by our WYSIWYG.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们向读者展示我们WYSIWYG生成的HTML代码。
- en: MapHelpers for improving our reducers
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MapHelpers用于改进我们的reducers
- en: 'In general, all reducers *must* return a new reference to an object when it
    has changed. In our first example, we used `Object.assign`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有reducers *必须*在发生变化时返回对象的新引用。在我们的第一个例子中，我们使用了`Object.assign`：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will replace this `Object.assign` approach with a new one, with ES6''s Maps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用ES6的Maps替换这个`Object.assign`方法。
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code, you can find a new `ARTICLES_LIST_ADD` with `mapHelpers.addMultipleItems(state,
    articlesList)`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以找到一个新的`ARTICLES_LIST_ADD`，使用`mapHelpers.addMultipleItems(state, articlesList)`。
- en: 'In order to make our map helpers, we need to create a new directory called
    `utils` and a file called `mapHelpers.js(src/utils/mapHelpers.js)`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作我们的地图助手，我们需要创建一个名为`utils`的新目录和一个名为`mapHelpers.js(src/utils/mapHelpers.js)`的文件：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And then, you can enter this first function into that `src/utils/mapHelpers.js`
    file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将这个第一个函数输入到那个`src/utils/mapHelpers.js`文件中：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The duplicate simply creates a new reference in memory in order to make our
    immutability a requirement in Redux applications. We also are checking, with `if(key
    === item['_id'])`, whether there is an edge case that the key is different from
    our object ID (the `_` in `_id` is intentional as this is how Mongoose marks the
    ID from our DB).The `addMultipleItems` function adds items to the new duplicated
    map (for example, after a successful fetch of articles).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重复项只是在内存中创建一个新的引用，以便使我们的不可变性成为Redux应用程序的要求。我们还通过`if(key === item['_id'])`检查是否存在一个边缘情况，即键与我们的对象ID（`_id`中的`_`）不同（`_`在这里是故意的，因为这是Mongoose标记我们数据库中的ID的方式）。`addMultipleItems`函数将项目添加到新的重复映射中（例如，在文章成功获取后）。
- en: 'The next code change that we require is in the same file at `src/utils/mapHelpers.js`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个代码更改是在同一文件`src/utils/mapHelpers.js`中：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, we have added an `add` function and `delete` function for a
    single item. After that, we are exporting all that from `src/utils/mapHelpers.js`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们为单个项目添加了`add`函数和`delete`函数。之后，我们将所有这些从`src/utils/mapHelpers.js`导出。
- en: 'The next step is that we need to improve the `src/reducers/article.js` reducer
    in order to use the map utilities in it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是改进`src/reducers/article.js` reducer，以便在其中使用地图工具：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What's new in the `src/reducers/article.js` file? As you can see, we have improved
    `ARTICLES_LIST_ADD` (already discussed). We have added a new `PUSH_NEW_ARTICLE`;
    case; this will push a new object into our reducer's state tree. It's similar
    to pushing an item to an array, but we use our reducer and maps instead.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/reducers/article.js`文件中的新内容是什么？如您所见，我们改进了`ARTICLES_LIST_ADD`（已讨论）。我们添加了一个新的`PUSH_NEW_ARTICLE`；情况；这将把一个新的对象推入我们的reducer状态树。它与将项目推入数组类似，但我们使用我们的reducer和maps。'
- en: The CoreLayout improvements
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreLayout改进
- en: 'Because we are switching to the ES6''s Map in the frontend, we also need to
    make sure that after we receive an object with server-side rendering, it is also
    a Map (not a plain JS object). Check out the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在将前端切换到ES6的Map，所以我们也需要确保在从服务器端渲染接收对象后，它也是一个Map（而不是一个纯JS对象）。查看以下代码：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Above the `CoreLayout` component, we have added the Redux tools, so we will
    have a state tree and the actions available in the `CoreLayout` component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the `CoreLayout` component, add the `componentWillMount` function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This function is responsible for checking whether an article's properties are
    an ES6 Map or not. If not, then we send an action to `articlesList` that makes
    the job done, and after that, we have maps in `this.props.article`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing is to improve `export` in the `CoreLayout` component:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code helps us connect to the Redux single-state tree and the actions
    it allows.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Why Maps over a JS object?
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, an ES6 Map has some features for easy data manipulation---functions
    such as `.get` and `.set` which make programming more pleasurable. It also helps
    to have a simpler code to be able to keep our immutability as required by Redux.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Map methods are much easier to use than `slice/c-oncat/Object.assign`. I am
    sure that there are always some cons/pros to each approach, but in our app, we
    will use an ES6 Map-wise approach in order to keep things simpler after we are
    completely set up with it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Improving PublishingApp and DashboardView
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src/layouts/PublishingApp.js` file, we need to improve our `render`
    function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see in the preceding code, we switched the old `for(let articleKey
    in this.props.article) {` code into `this.props.article.forEach` because we have
    switched from objects to using Maps.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to do the same in the `src/views/DashboardView.js` file''s `render`
    function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For the same reason as in the `PublishingApp` component, we switched to using
    ES6''s new Map, and we will be also using the new ES6 `forEach` method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Tweaks to AddArticleView
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After we are finished preparing our app to save a new article into the article''s
    reducer, we need to tweak the `src/views/articles/AddArticleView.js` component.
    New imports in the `AddArticleView.js` are as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see in the preceding code, we are importing `RaisedButton` and `Link`,
    which will be useful for redirecting an editor to the dashboard's view after a
    successful article addition. Then, we import `articleActions` because we need
    to make the `this.props.articleActions.pushNewArticle(newArticle);` action on
    article submit. The `bindActionCreators` will already be imported in your `AddArticleView`
    if you followed instructions from previous chapters.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `bindActionCreators` in order to have `articleActions` in the `AddArticleView`
    component by replacing this code snippet:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is the new `bindActionCreators` code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following is an updated constructor of the `AddArticleView` component:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `_articleSubmit` method will be required after an editor wants to add an
    article. We have also added some default states for our title, `contentJSON` (we
    will keep the draft-js article state there), `htmlContent`, and the `newArticleID`.
    The next step is to create the `_articleSubmit` function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As you can see here, we get the state of our current writing with `this.state.title`,
    `this.state.htmlContent`, and `this.state.contentJSON`, and based on that, we
    then create a `newArticle` model:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then we mock the new article''s ID (later, we will save it to the DB) with
    `newArticle[''_id''] = newArticleID;` and push it into our article''s reducer
    with `this.props.articleActions.pushNewArticle(newArticle);`. The only thing is
    to set up `newarticleID` with `this.setState({ newArticleID: newArticleID});`.
    The last step is to update our `render` method in the `AddArticleView` component:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here in the `render` method, we have one statement that checks whether an article's
    editor has already created an article (clicked on the Submit Article button) with
    `if(this.state.newArticleID)`. If yes, then the editor will see his new article's
    ID and a button that links to the dashboard (link is `to='/dashboard'`).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The second return is in case an editor is in edit mode; if yes, then he can
    submit it by clicking on the `RaisedButton` component with the `onClick` method's
    called `_articleSubmit`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The ability to edit an article (the EditArticleView component)
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can add an article, but we can't edit it yet. Let's implement that feature.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to create a route in `src/routes/index.js`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then edit the routes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As you can see, we have added the `EditArticleViews` route with `path='/edit-article/:articleID'`;
    as you should know already, the `articleID` will be sent to us with props as `this.props.params.articleID`
    (this is a default feature of `redux-router`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `src/views/articles/EditArticleView.js` component,
    which is a new component (mocked for now):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, you can find a standard view component with a `render` function that returns
    a mock (we will improve it later). We have already put all the required imports
    in place (we will use all of them in the next iteration of the `EditArticleView`
    component).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a dashboard link to an article's edition
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make a small tweak in `src/views/DashboardView.js`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, we have two things that need to be changed: adding a `Link` attribute
    to `to={/edit-article/${articleDetails[''_id'']}`. This will redirect a user to
    the article''s edition view after clicking on `ListItem`. We also need to give
    a `Link` element a unique key property.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new action and reducer
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify the `src/actions/article.js` file and add this new action called `EDIT_ARTICLE`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The next step is to improve our reducer at `src/reducers/article.js`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can find here, we have added a new `switch` case for `EDIT_ARTICLE`.
    We use our `mapHelpers.addItem`; in general, if `_id` does exist in Map, then
    it replaces a value (this works great for editing actions).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Edit mode in src/components/articles/WYSIWYGeditor.js
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now implement the ability to use the edit mode in our `WYSIWYGeditor`
    components by improving our construction in the `WYSIWYGeditor.js` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here you can find out how your constructor will look after making changes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到修改后构造函数的样子。
- en: As you already know, draft-js is required to be an object, so we check in the
    first `if` statement whether it is one. Then, if not, we put an empty WYSIWYG
    as default (check `if(typeof props.initialValue === 'undefined' || typeof props.initialValue
    !== 'object'))`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，draft-js必须是一个对象，所以我们首先在第一个`if`语句中检查它是否是一个对象。然后，如果不是，我们将默认使用一个空的WYSIWYG（检查`if(typeof
    props.initialValue === 'undefined' || typeof props.initialValue !== 'object'))`）。
- en: 'In the `else` statement, we put the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`语句中，我们放置以下内容：
- en: '[PRE87]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here we check whether we have a valid draft-js JSON object; if not, we need
    to throw a critical error and return, because otherwise, the error can crash the
    whole browser (we need to handle that edge case with `withif(isInvalidObject))`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查是否有一个有效的draft-js JSON对象；如果没有，我们需要抛出一个关键错误并返回，因为否则错误可能会崩溃整个浏览器（我们需要使用`withif(isInvalidObject)`来处理这个边缘情况）。
- en: After we have a valid object, we recover the state of our WYSIWYG editor with
    the use of the `convertFromRaw`, `ContentState.createFromBlockArray`, and `EditorState.createWithContent`
    functions provided by the draft-js library.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们得到一个有效的对象后，我们使用draft-js库提供的`convertFromRaw`、`ContentState.createFromBlockArray`和`EditorState.createWithContent`函数来恢复我们的WYSIWYG编辑器的状态。
- en: Improvements in EditArticleView
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EditArticleView的改进
- en: 'The last improvement before finishing the article edit mode is improving `src/views/articles/EditArticleView.js`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成文章编辑模式之前，最后一个改进是提高`src/views/articles/EditArticleView.js`：
- en: '[PRE88]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This is our constructor; we will have some states variables such as `articleFetchError`,
    `articleEditSuccess`, `editedArticleID`, `articleDetails`, `title`, `contentJSON`,
    and `htmlContent`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的构造函数；我们将有一些状态变量，例如`articleFetchError`、`articleEditSuccess`、`editedArticleID`、`articleDetails`、`title`、`contentJSON`和`htmlContent`。
- en: In general, all these variables are self-explanatory. Regarding the `articleDetails`
    variable here, we will keep the whole object fetched from a `reducer/mongoDB`.
    Things such as `title`, `contentHTML`, and `contentJSON` are kept in the `articleDetails`
    state (as you will find in a moment).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有这些变量都是自解释的。关于这里的`articleDetails`变量，我们将保留从`reducer/mongoDB`获取的整个对象。例如`title`、`contentHTML`和`contentJSON`等数据都保存在`articleDetails`状态中（你很快就会看到）。
- en: 'After you are done with the `EditArticleView` constructor, add some new functions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`EditArticleView`构造函数后，添加一些新函数：
- en: '[PRE89]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'On `componentWillMount`, we will fetch data about the article with `_fetchArticleData`.
    The `_fetchArticleData` is getting the article''s ID from props via `react-redux`
    (`let articleID = this.props.params.articleID;`). Then, we check whether we are
    not on the server side with `if(typeof window !== ''undefined'' && articleID)`.
    After this, we use the `.get` Map function in order to get details from a reducer
    (`let articleDetails = this.props.article.get(articleID);`), and based on the
    case, we set the state of our component with the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`componentWillMount`中，我们将使用`_fetchArticleData`获取文章的相关数据。`_fetchArticleData`通过`react-redux`从props中获取文章的ID（`let
    articleID = this.props.params.articleID;`）。然后，我们检查是否不在服务器端`if(typeof window !==
    'undefined' && articleID)`。之后，我们使用`.get` Map函数从reducer获取详细信息（`let articleDetails
    = this.props.article.get(articleID);`），并根据情况设置组件的状态如下：
- en: '[PRE90]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here you can find that in the `articleDetails` variable, we keep all data fetched
    from reducer/DB. In general, now we only have the frontend side because a backend
    side fetching an edited article will be introduced later in this book.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在`articleDetails`变量中，我们保留了从reducer/DB获取的所有数据。一般来说，现在我们只有前端部分，因为本书后面将介绍如何从后端获取已编辑的文章。
- en: The `_onDraftJSChange` function is similar to the one in the `AddArticleView`
    component.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`_onDraftJSChange`函数与`AddArticleView`组件中的类似。'
- en: 'The `_articleEditSubmit` is quite standard, so I will leave it to you to read
    the code. I will only mention that `_id: currentArticleID` is very important,
    because it''s used later in our `reducer/mapUtils` in order to update the article
    correctly in the article''s reducer.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`_articleEditSubmit`相当标准，所以我会留给你去阅读代码。我只提一下`_id: currentArticleID`非常重要，因为它在后面的`reducer/mapUtils`中用于正确更新文章。'
- en: EditArticleView's render improvements
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EditArticleView的渲染改进
- en: 'The last part is to improve our `render` function in the `EditArticleView`
    component:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是改进`EditArticleView`组件中的`render`函数：
- en: '[PRE91]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We are managing different states of our component with `if(this.state.articleFetchError)`,
    `else if(!this.state.editedArticleID)`, and `else if(this.state.articleEditSuccess)`,
    as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this part, the major change is adding a new property called `initialValue`,
    which is passed down to the `WYSIWYGeditor`, the draft-js JSON object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an article's feature implementation
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new action for deletion at `src/actions/article.js`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Next, let''s add a `DELETE_ARTICLE` switch case into `src/reducers/article.js`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The last step in implementing a delete button is to modify `src/views/articles/EditArticleView.js
    component.Import PopOver` (it will ask a second time whether you are sure about
    deleting an article):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The new things here are `_handleDeleteTap`, `_handleDeletion`, `_handleClosePopover`,
    and `state (htmlContent, openDelete, deleteAnchorEl)`. Then, add three new functions
    to `EditArticleView`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Improve the return in the `render` function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Regarding `render`, new things are all under the new `hr` tag: `<h1>: Delete
    permanently this article<h1>`. `RaisedButton: DeletePopover` is a component from
    Material-UI. You can find more documentation of this component at [http://www.material-ui.com/v0.15.0-alpha.1/#/components/popover](http://www.material-ui.com/v0.15.0-alpha.1/#/components/popover).
    You can find in the following screenshots how it should look in the `browserRaisedButton:
    Permanent delete, click here` label. The `AddArticleView` component:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: 'The `AddArticleView` component after a `SUBMIT ARTICLE` button has been hit:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'The dashboard component:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'The `EditArticleView` component:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'A DELETE button on the `EditArticleView` component:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: 'A DELETE button on the `EditArticleView` component after first click (popover
    component):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'A `PublishingApp` component (main page):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we have made a lot of progress on the frontend using Redux to store
    the state of our application in its single-state tree. The important drawback
    is that after you hit refresh, all the data disappears.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start implementing the backend in order to store
    the articles in our database.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, Falcor is our glue that replaces the old popular RESTful
    approach; you will master stuff related to Falcor very soon. You will also learn
    what the differences between Relay/GraphQL and Falcor are. Both are trying to
    solve similar problems, but in very different ways.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Let's go even more in depth into our full-stack Falcor application. We will
    make it even more awesome for our end users.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
