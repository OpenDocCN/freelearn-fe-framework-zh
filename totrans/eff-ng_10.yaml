- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization, Localization, and Accessibility of Angular Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing applications, you’re often targeting users from many different
    countries; because of that, it’s essential to add internationalization and localization
    to your Angular applications. **Internationalization** is the process of making
    your applications translatable so people who speak different languages can use
    your application without any issues. With **localization**, you tailor the content
    of your website to a specific location. For example, users from the USA expect
    dollar signs, whereas users from the EU use a euro sign in front of currency values.
    Besides people from different countries, your applications will also be used by
    people with different abilities. Some users might not be able to use a keyboard
    or read the screen like other users. In a world where we rely more on applications,
    it’s important to develop your applications in a way that ensures users of all
    abilities can use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to develop Angular applications that can
    serve as many people as possible. First, we will dive into and implement internationalization
    within the Nx monorepo. After making your content translatable, you will learn
    about and implement localization to correctly display your dates, currencies,
    and other values depending on the user. Lastly, we will dive into the topic of
    developing accessible frontend applications that can be used by users of all abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding translatable content in Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localization for Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your Angular applications accessible to everyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding translatable content in Angular applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive into internationalization, commonly referred to
    as **i18n** (i18n is the abbreviation for internationalization, where “i” and
    “n” are the first and last letters of the word, and 18 stands for the number of
    letters in between the “i” and the “n”). Internationalization is developing usable
    applications for people who speak different languages. Simply put, when you implement
    i18n, you make your application content translatable. About 75% of the world doesn’t
    speak English at all, so if you only display your application content in English
    (or exclusively use another language), you are missing out on a lot of potential
    users.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular framework has built-in functionalities to support translatable content,
    but we will not be using the built-in i18n solution to support translatable content.
    The first reason is that the built-in solution used XML content in the translation
    files. Most developers don’t like XML, and JSON is a much more readable and flexible
    alternative. The second reason we will not use the built-in i18n solution for
    translatable content is that it’s predominately focused on compiling time translations.
    With compile-time translations, the translation keys are replaced during the compilation
    process; because of that, you must create and deploy a specific build for each
    language you want to support. There is also some support for runtime translations,
    meaning the translations can change when the application is deployed and running,
    but there is little documentation, and the solution is rarely used because there
    are much better options developed and maintained by the Angular community.
  prefs: []
  type: TYPE_NORMAL
- en: The two most commonly used i18n libraries that support translatable content
    in Angular applications are **Transloco** and **ngx-translate**. We will use Transloco,
    as it has better support for standalone components, is more actively maintained,
    has better documentation, supports server-side rendering, and has more configuration
    options and features overall. We will implement Transloco step by step into the
    *expenses-registration* *application* in the Nx monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can still dive into Transloco’s documentation at this website: [https://jsverse.github.io/transloco/](https://jsverse.github.io/transloco/).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Transloco in your Nx monorepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can support translatable content in your HTML templates and TypeScript
    files, you need to install Transloco in your Nx monorepo and add it to the applications
    where you want to use it. So, let’s start at the beginning and install the NPM
    package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the package, you need to add Transloco to your project, open
    the terminal at the `business-tools-monorepo\apps\finance\expenses-registration`
    folder path, and run the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this command, you will be asked two questions inside the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`en` to add English and `nl` to add Dutch as my default languages. You can
    provide your own languages, but please add `en` for English, as we will use that
    one in the book. You can always extend upon these languages if you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Are you working with server-side rendering?**: False–this is the default,
    so you can just hit *Enter*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After answering the questions, the command will add the necessary configuration
    to add Transloco to the *expenses-registration application*. You can also add
    the configurations manually, but using the terminal command is faster and ensures
    that everything is added correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look closer at the files Transloco generated for you that have been
    added to the Nx monorepo and *expenses-registration application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file we will look at is `transloco-loader.ts`. Inside this file,
    Transloco created an Angular service that is responsible for loading the translation
    files based on a provided language. The following code is generated for you in
    the `transloco-loader.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `TranslocoHttpLoader` service does
    fetch a JSON file from your assets folder. The fetched JSON file will contain
    translation keys and values for a specific language. You need to provide the `getTranslation()`
    function with a language key that correlates with the naming of your translation
    file. For example, if you have an `en.json` file inside the `i18n` folder containing
    your English translations, you would call the `getTranslation()` function with
    `en` as a parameter to fetch the English translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I like to ensure better typing for the function parameter of the
    `getTranslation()` function and only allow specific string values instead of any
    string. In my case, I have `en` and `nl` as my language files, so I would adjust
    the function parameter to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can adjust the function parameter type to the languages you support.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that when you deploy your Angular application and Transloco
    isn’t able to load your language files, it might be because you need to provide
    a relative path, but generally speaking, this is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see how you can use the `getTranslation()` method with a relative
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you’ll find an example of a relative path, but you only
    have to provide a relative path if Transloco can’t load your translations with
    the regular setup.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the `transloco-loader.ts` file and what it is used for,
    let’s look at what else Transloco created for you.
  prefs: []
  type: TYPE_NORMAL
- en: For each language you provided when you ran the command in the terminal, Transloco
    created a translation file for you. Inside your assets folder, an `i18n` folder
    was created, and inside the `i18n` folder, you’ll find a JSON file for each of
    the languages you provided. So, in my case, I provided `en` and `nl`, so Transloco
    created an `en.json` and `nl.json` file for me. You will add your translation
    keys and values to these JSON files. By default, the files contain an empty JSON
    object. After generating the empty translation files, Transloco adjusted the `ApplicationConfig`
    object inside the `app.config.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your `ApplicationConfig`, Transloco added the `provideHttpClient()`
    and `provideTransloco()` configurations inside the providers array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `provideTransloco()` configuration function receives a configuration object
    of its own, configuring the Transloco instance. By default, the configuration
    for Transloco defines the translation loader, the default language, the available
    languages, whether you are in production mode, and whether you support runtime
    language changes within your application. Additionally, you can add other configurations
    such as a fallback language, the number of times Transloco needs to try loading
    a language file before using the fallback language, or if it should log missing
    translation keys.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the generated provideHttpClient() function
  prefs: []
  type: TYPE_NORMAL
- en: Transloco also added the `provideHttpClient()` function inside your providers
    array. Because you already have a `provideHttpClient()` configuration inside the
    providers array in your `ApplicationConfig` object, it’s important to remove this
    configuration added by Transloco. If you do not remove the `provideHttpClient()`
    added by Transloco, it will overwrite your own `provideHttpClient()` configuration,
    which also contains your mock data interceptor configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to adjust one more thing because of the mock data interceptor. Go
    to the `mock.interceptor.ts` file and adjust the first `if` check. We want to
    return the request without modifying it in production (as we already do) or if
    the request URL ends with `.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you now check the network tab of your browser console, you’ll see that a
    request is made and successfully fetches the `en.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what Transloco generated and added to your application, let’s
    move on and learn how you can use Transloco to support content in multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: Translating content using Transloco
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To translate values using Transloco, you create key-value pairs in your translation
    files. You use the same key in each translation file and provide it with the correct
    translation value for the given language file. The keys are all lowercase, and
    words are separated by an underscore. For example, if I wanted to translate `Expenses
    Overview`, I would add the following in the `en.json` translation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the other translation files, you add the same `expenses_overview` key and
    assign it the translation value for that specific language. For example, in my
    `nl.json` file, I would add the same key with the Dutch translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to add translation keys and values to the translation
    files, let’s see how to use these key-value pairs inside your application to translate
    content. You can translate values inside your HTML templates and the TypeScript
    files. We’ll start by looking into the HTML translations, and you will learn about
    translating values inside the TypeScript files after that.
  prefs: []
  type: TYPE_NORMAL
- en: Translating values in the HTML template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside HTML templates, you can translate values with a **structural directive**,
    an **attribute directive**, or a **translation pipe**. It’s recommended to use
    the structural directive. Both the pipe and directives create subscriptions to
    observe when the user changes the selected languages. When using the structural
    directive, you only create a single subscription for the template. In contrast,
    the pipe and attribute directives create a subscription each time you use them
    in a template, which can be multiple times. Also, the structural directive caches
    the translations, so if you’re using the same translation key numerous times in
    a template, the structural directive can return it directly from the cache, improving
    your performance and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the structural directive is the recommended approach, let’s first learn
    how to use that before we look at the pipe and attribute directive. Because we
    use a standalone component, we need to import the directive in the imports array
    of the component before we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the directive, add it to the expenses overview page. When using
    the structural directive, it’s recommended to wrap the entire template in an `ng-container`
    element and add the structural directive on the `ng-container` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <h1>{{ t variable from the directive as a function and provide it with the translation
    key you want to display. In the browser, you’ll see t function provided by the
    *transloco structural directive. But there are also many scenarios where you need
    to translate something and need dynamic values inside the translated value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you want to change the title inside the `h1` tag from
    `Expenses Overview` to `Expenses overview for <user name>`. In that case, you
    need a way to provide the username to the translatable value so it can be inserted
    in the correct place. You also can’t just append the username because the build-up
    of your translatable value might not be the same for each language, or your dynamic
    value has to be inserted somewhere in the middle of your translated value. Luckily,
    there is a simple solution for this—you can add parameters inside your translation
    values and provide a value for these parameters whenever you use the translation
    key connected to the translation value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, start by adding another (or changing the existing) translation
    key inside the translation files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we’ve added a parameter in our translation value by using double
    curly brackets. Now, inside the HTML template, you can provide a value for the
    user translation parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can provide an object to the `t` function as a second parameter.
    The first parameter for the `t` function is the translation key and the second
    parameter is optional and can be used to provide values for the translation parameters.
    In our example, we use a `user` object with a `fullName` property to provide the
    user name to the translation parameter (we currently don’t have this user object
    in our component; it’s just an example, and you can provide the user translation
    parameter with any property or static value you want). Besides parameters and
    simple translation keys, you can also group translation keys inside the translation
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To group translation keys, create a grouping key, for example, `expenses_overview_page`,
    and add nested keys under the group key like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Especially when your translation files grow larger, this helps to locate specific
    translations quickly. Using this approach, you might end up with some duplicate
    translation values. Still, the improved maintainability is a more significant
    win than having a few duplicate translation values, but your approach is up to
    you and your team. When using the grouped approach, you use the following syntax
    inside your HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, you first define the group name followed
    by a dot and then the translation key. As you might imagine, prefixing every translation
    key with the group name might get redundant, so to make things easier, you can
    define this group name inside the `*``transloco` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you define the group name inside the directive, you only have to use the
    inner translation keys inside the `t` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You now know how to declare translation key-value pairs in groups or regularly
    and how to translate them inside your HTML templates using the `*transloco` structural
    directive. Alternatively, you can use the `transloco` attribute directive or pipe
    to do your translations; however, as mentioned, the attribute directive is recommended
    because it creates fewer subscriptions and has caching throughout your HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a full overview of the possibilities, here is an example including
    translation parameters using the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you can use the attribute directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '@Injectable({ providedIn: ''root'' })'
  prefs: []
  type: TYPE_NORMAL
- en: export class TranslationService {
  prefs: []
  type: TYPE_NORMAL
- en: translocoService = inject(TranslocoService);
  prefs: []
  type: TYPE_NORMAL
- en: translationsLoaded = toSignal<boolean>(this.translocoService.events$.pipe(filter(event
    => event.type === ‹translationLoadSuccess›), map(event => !!event)));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: protected readonly translationService = inject(TranslationService);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: translationEventsEffect = effect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: if (this.translationService.translationsLoaded()) {
  prefs: []
  type: TYPE_NORMAL
- en: // Perform your translations here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: this.translationService.translocoService.translate('expenses_overview_page.title')
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'this.translationService.translocoService.translate('' expenses_overview_for_user'',
    {user: user.fullname})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: this.translationService.translocoService.selectTranslate('expenses_overview_page.title').subscribe((title)
    => {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(‹==>›, title);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: '<select #selectList (change)=»languageChange.emit(selectList.value)»>'
  prefs: []
  type: TYPE_NORMAL
- en: <option *ngFor=»let lang of languages()» (click)=»languageChange.emit(lang)»
    [value]=»lang»>{{ lang }}</option>
  prefs: []
  type: TYPE_NORMAL
- en: </select>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: export class NavbarComponent {
  prefs: []
  type: TYPE_NORMAL
- en: 'navbarItems = input([], { transform: addHome });'
  prefs: []
  type: TYPE_NORMAL
- en: languages = input<string[]>([]);
  prefs: []
  type: TYPE_NORMAL
- en: '@Output() languageChange = new EventEmitter();'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: getLanguages() {
  prefs: []
  type: TYPE_NORMAL
- en: return this.translocoService.getAvailableLangs() as string[];
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-navbar …… [languages]="translationService.getLanguages()" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: <bt-libs-navbar …… (languageChange)="translationService.translocoService.setActiveLang($event)"
    />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: npm i @ngneat/transloco-locale
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: provideTranslocoLocale({
  prefs: []
  type: TYPE_NORMAL
- en: 'langToLocaleMapping: { en: ‹en-US›, nl: ‹nl-NL› }'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: this.translocoService.setLocale('en-US');
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: export interface TranslocoLocaleConfig {
  prefs: []
  type: TYPE_NORMAL
- en: 'defaultLocale?: Locale;'
  prefs: []
  type: TYPE_NORMAL
- en: 'defaultCurrency?: Currency;'
  prefs: []
  type: TYPE_NORMAL
- en: 'localeConfig?: LocaleConfig;'
  prefs: []
  type: TYPE_NORMAL
- en: 'langToLocaleMapping?: LangToLocaleMapping;'
  prefs: []
  type: TYPE_NORMAL
- en: 'localeToCurrencyMapping?: LocaleToCurrencyMapping;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: <td>{{ expense.amount.value.toFixed(2) | en to nl inside the navbar (in a production
    environment, the backend should also return different data because of the exchange
    rate between the currencies, or the API can provide the exchange rate so you can
    perform the conversions on the frontend).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can provide the `translocoCurrency` pipe with some additional options for
    further configuring the displayed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display`: This controls what you want to display for the currency unit. The
    options you can choose from are code, symbol, narrowSymbol, and name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numberFormatOptions`: This is an object that controls how the numbers are
    formatted. You can provide the object with `Intl.NumberFormatOptions` properties
    (`Intl.NumberFormatOptions` are native JavaScript format options).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currencyCode`: With this option, you can specify the currency symbol that
    should be used by the pipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locale`: With this option, you can provide a locale option, such as en-US
    or nl-NL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of the `translocoCurrency` pipe including parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The configuration options are optional and will overwrite any default settings
    you configured inside the `provideTranslocoLocale()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the currency pipe, explore the other localization pipes
    Transloco has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing dates using the translocoDate pipe
  prefs: []
  type: TYPE_NORMAL
- en: When localizing dates, you want to ensure the dates are formatted correctly
    depending on the language settings (or localization settings if you have them
    separated) the user has selected. Dates in the EU and USA, for example, are formatted
    differently. For instance, in the USA, dates start with the month. In the EU,
    they begin with the day. So, if you want to display the 20th of January, 2024
    for users from the USA, that would be 1/20/2024, and for EU users, 20-01-2024
    would be the conventional formatting. Also, for English-speaking users, months
    are always capitalized, whereas this is not the case for some EU languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide the best possible user experience, dates in your applications should
    be formatted correctly. The `translocoDate` pipe offers a simple way to achieve
    this. Just import the pipe into your component (if you’re using standalone components).
    Similar to the currency pipe, you can replace the native Angular date pipe with
    the `translocoDate` pipe, and your dates will automatically react when the user
    changes the language (or localization) settings. To demonstrate this, you can
    change the date pipe you used in the `expenses-overview-page.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: <!--1,234,567,890  en-US -->
  prefs: []
  type: TYPE_NORMAL
- en: '<span> {{ 1234567890 | en-US, the large number is separated by commas. If you
    make it a decimal number, the decimal values will be separated by a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the `translocoDate` and `translocoCurrency` pipes, you have some
    additional configuration options for the `translocoDecimal` pipe. The `translocoDecimal`
    pipe can take the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numberFormatOptions`: This is an object containing the `Intl.NumberFormatOptions`
    formatting properties (`Intl.NumberFormatOptions` is a native JavaScript formatting
    object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locale`: With this option, you can provide a locale option, such as en-US
    or nl-NL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve now learned how you can use the different localization pipes of the Transloco
    library and what configuration options you can provide to the pipes to control
    the output. In the next section, you’ll learn how to make your Angular applications
    accessible to everybody.
  prefs: []
  type: TYPE_NORMAL
- en: Making your Angular applications accessible to everyone
  prefs: []
  type: TYPE_NORMAL
- en: In a world that relies more on web applications, ensuring everyone can use your
    application is essential. Making your Angular application accessible to people
    with motor or visual impairments is crucial in ensuring that users of all abilities
    can effectively interact with it. **Accessibility**, often abbreviated as **a11y**,
    involves designing and developing your application to be usable by people with
    diverse needs, including those with disabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I often forget that not everyone can use a keyboard or see
    a screen just like I can. Not only people with permanent disabilities but also
    people who temporarily can’t use their hands or sight should be able to keep interacting
    with your applications. In some countries, it’s even enforced by law that your
    application has to implement specific accessibility standards. A commonly used
    standard for accessibility is the **Web Content Accessibility Guidelines 2.2 (WCAG
    2.2)**. WCAG 2.2 has 13 guidelines to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text alternatives**: Provide text alternatives for non-text content to make
    it accessible to users who cannot see images or hear audio.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Time-based media**: Provide alternatives for time-based media, such as audio
    and video, to ensure accessibility for users who cannot hear or see multimedia
    content.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adaptable**: Create content that can be presented in different ways without
    losing information or structure, ensuring accessibility for users who rely on
    various assistive technologies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Distinguishable**: Ensure sufficient contrast, provide alternatives for audio
    content, and avoid distractions that could hinder accessibility to make it easier
    for users to see and hear content.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Keyboard accessible**: Make all functionality available from a keyboard interface,
    ensuring accessibility for users who cannot use a mouse.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enough time**: Provide users with enough time to read and use content, ensuring
    accessibility for users who may need more time to interact with web pages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Seizures and physical reactions**: Do not design content in a way that is
    known to cause seizures or physical reactions, ensuring accessibility for users
    with photosensitive epilepsy or other conditions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Navigable**: Make web pages navigable and predictable, ensuring accessibility
    for users who rely on navigation aids or have cognitive disabilities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Input modalities**: Ensure compatibility with different input modalities,
    such as touch, speech, and gestures, ensuring accessibility for users with disabilities
    that affect how they interact with web content.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Device independence**: Ensure compatibility with various devices, platforms,
    and assistive technologies, ensuring accessibility for users who use different
    devices to access the web.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Readable**: Make text content readable and understandable, ensuring accessibility
    for users with cognitive disabilities or those who use screen readers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Predictable**: Make web pages operate in predictable ways, ensuring accessibility
    for users who rely on consistent navigation and interaction patterns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Input assistance**: Help users avoid and correct mistakes, ensuring accessibility
    for users who may have difficulty entering information or navigating web forms.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know the 13 guidelines of WCAG 2.2, let’s examine what you can
    do in your Angular applications to adhere to these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: How to make Angular applications accessible
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to adhere to accessibility guidelines is by using a UI library
    that takes these concerns out of your hands. Some good Angular UI libraries include
    Angular Material, PrimeNG, and Ng Zorro. However, not all your application code
    can be developed using a UI library, and sometimes your employer develops its
    own UI components; in these scenarios, you need to apply WCAG yourself. The first
    thing you need to do to ensure you adhere to WCAG is to use semantic HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic HTML is when you use the appropriate HTML element for the element you
    want to visualize on the screen. Often, developers like to use too many `<div>`
    and `<span>` elements; these elements don’t tell a screen reader anything about
    their purpose. Try to use HTML elements such as `<label>`, `<button>`, `<input>`,
    `<header>`, `<footer>`, `<section>`, `<article>`, `<form>`, etc. When using semantic
    HTML elements, screen readers can better explain the page to users who can’t see
    the page. Besides implementing semantic HTML, you should ensure that the user
    can navigate the page using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Using the tabindex attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ensure HTML elements are focusable with the tab key on your keyboard
    by adding a `tabindex` attribute. This default focus behavior is implemented for
    the following elements: `<a>` or `<area>` with an `href` attribute, `<button>`,
    `<iframe>`, `<input>`, `<object>`, `<select>`, `<textarea>`, `<SVG>`, and `<summary>`
    elements that provide a summary for a `<details>` element. Developers don’t need
    to manually add a `tabindex` attribute to these elements unless they want to alter
    their default focus behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, setting a negative `tabindex` value would remove the element from
    the focus navigation order, effectively making it non-focusable. However, it’s
    essential to exercise caution when modifying the default behavior of focusable
    elements to ensure an intuitive and accessible user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `tabindex` attribute, you can make HTML elements keyboard-focusable,
    prevent elements from being keyboard-focusable, and determine the focus order.
    As mentioned before, when you provide a negative integer to the `tabindex` attribute,
    the HTML element becomes non-focusable when using the keyboard. If you provide
    a `0` for the `tabindex` attribute, the element maintains the default tab order
    (from top to bottom, based on the order of the HTML elements). Lastly, you can
    provide positive integers. Elements with a positive integer will be focused before
    the default focus order kicks in, starting at `tabindex 1` and ending at the highest
    `tabindex`. When there are no more tabindex attributes with a positive integer,
    the next focused element is the first HTML element with the default `tabindex`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <button [attr.aria-label]="dynamicValue">…</button>
  prefs: []
  type: TYPE_NORMAL
- en: <button [attr.aria-label]="'translationkey' | translate">…</button>
  prefs: []
  type: TYPE_NORMAL
- en: <button aria-label="static value">…</button>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<button aria-label attribute and provided it with the text Hamburger menu,
    so a screen reader can clearly explain what the element is about. Alternatively,
    you can use the aria-label attribute to provide a better explanation for elements
    that do contain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: <a href="#" <a> tag, designating the role of the HTML element as a button. Commonly,
    <a> tags are used as links, but in this case, we indicate that it is used as a
    button instead.
  prefs: []
  type: TYPE_NORMAL
- en: More information
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `role` and `aria-label` attributes, there are many other ARIA attributes,
    for example `aria-hidden`, `aria-checked`, `aria-disabled`, and `aria-readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a full list of all ARIA attributes and a detailed explanation
    at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes).'
  prefs: []
  type: TYPE_NORMAL
- en: Now you know what the different accessibility guidelines are and how to implement
    them into your Angular applications. You learned why using a semantic HTML structure
    for your pages is important, so tools such as screen readers can better navigate
    and understand your components and pages. You learned how you can make elements
    focusable with the tab key and how you can control the focus order of different
    elements on the page. Lastly, you learned about the ARIA attributes and how they
    can be used to provide additional information for assistive technologies, such
    as screen readers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make your applications more accessible to
    people who speak different languages or are located in various locations. You
    learned about the Transloco library and how it can be used to implement localization
    and internationalization. You created language files to provide translation key-value
    pairs and implemented the translations in your HTML templates. You learned to
    translate values using structural directives, attribute directives, pipes, and
    the `TranslocoService`. After learning about translatable content, you learned
    how to format values for users from different locations. You learned about the
    `translocoCurrency`, `translocoDate`, and `translocoDecimal` pipe. You’ve seen
    how to configure your applications for localization and how to overwrite your
    default settings for specific instances within your code. After internationalizing
    and localizing your website, you learned about accessibility. You got familiar
    with the WCAG and how you can ensure they are implemented within your Angular
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to write unit and end-to-endtests for
    your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
