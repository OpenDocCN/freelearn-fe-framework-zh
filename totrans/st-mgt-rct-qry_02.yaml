- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server State versus Client State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global state is the most common way we look at state. It is the state that is
    shared globally in our application by one or more components.
  prefs: []
  type: TYPE_NORMAL
- en: What we don’t often know is that in our day-to-day development, our global state
    ends up being split between the state that persists outside of our application
    and the state that only exists within our application. The first type of state
    is called **server state**, while the second one is called **client state**. Both
    of these types of states have their specific challenges and require different
    tools to help manage them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand why we refer mostly to our state as global
    state and why we should adjust our mental models to include client and server
    states instead.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also review what each type of state is responsible for and how to differentiate
    them in an application and understand the challenges that led to the creation
    of React Query.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to fully split global state into
    the client state and the server state by applying the mental models you will have
    just learned.
  prefs: []
  type: TYPE_NORMAL
- en: You will also understand all the challenges created by having a server state
    in your application and prepare to overcome them with React Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is global state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is client state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is server state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding common challenges with server state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_2).
  prefs: []
  type: TYPE_NORMAL
- en: What is global state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When starting with state management in the React world, we are often not familiar
    with the different concepts of state.
  prefs: []
  type: TYPE_NORMAL
- en: Often, we just look at state by thinking about the amount of `useState` or `useReducer`
    hooks we have in our components. Then, when the `useState` or `useReducer` pattern
    stops working and we need to share state between more components, we either lift
    our state to the nearest parent when this state is needed only by the children
    of that component, or find a common place where this state can exist and be accessible
    everywhere by all the components we want. This state is often called global state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of what global state can look like in an application.
    Here, we have a store responsible for managing theme selection, fetching data,
    and tracking the loading state of this fetching request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet shows an example of what some typical global state can look like.
    By using React Context, we are creating a store that has the following things
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: A state variable called `selectedTheme` to manage the selected theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A state variable called `serverData` to display the data that was returned from
    our API request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A state variable called `isLoadingData` to display whether the current loading
    state of our API request is still loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function called `toggleTheme` to allow us to toggle between light and dark
    modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `fetchData` function to allow us to fetch the given data and set our loading
    state as `true` or `false` depending on the state of the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `useEffect` hook that will trigger the initial data fetching to provision
    our `serverData` state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is useEffect?
  prefs: []
  type: TYPE_NORMAL
- en: '`useEffect` is a React hook that allows you to perform side effects in your
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: All these are returned from our store so that the consumers of this context
    can access them from all over our application as long as they subscribe to our
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Now, from a first look, there seems to be nothing wrong with this state, and
    it might be enough for most applications. The thing is, most of the time, this
    state will end up growing due to new development needs. This will lead to increasing
    the size of our state most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now picture that we need a secondary theme, and we need to add another
    state variable called `secondaryTheme`. Our code would look a lot like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, in this snippet, we added our `secondaryTheme` state variable, and it works
    very much like `selectedTheme`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are using context here; this means that every time we trigger a state
    update, any component that consumes this state will be forced to re-render to
    receive the new state updates. What does this mean to us?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine we have two components (let’s call them *Component A* and *Component
    B*) consuming this context, but *Component B* only destructures the `selectedTheme`
    state while *Component A* destructures everything. If *Component A* triggers a
    state update on `secondaryTheme`, then *Component B* will also re-render because
    React noticed an update inside the context that both of them share.
  prefs: []
  type: TYPE_NORMAL
- en: This is how React Context works, and we can’t change this. We could argue that
    we could either split the context, split the subscribing component into two components
    and wrap the second one with `memo`, or just wrap our return with the `useMemo`
    hook. Sure, this would probably fix our issue, but we are only dealing with the
    changes in one type of state that creates the global state.
  prefs: []
  type: TYPE_NORMAL
- en: What are memo and useMemo?
  prefs: []
  type: TYPE_NORMAL
- en: '`memo` is a function that you can wrap your component in to define a memoized
    version of it. This will guarantee that your component doesn’t re-render unless
    its props have changed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`useMemo` is a React hook that allows you to memoize a value. Usually, the
    value we want to memoize is the result of an expensive calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine we needed to add another API request context. Once again, the context
    grows and we end up with the same issue we had with the themes.
  prefs: []
  type: TYPE_NORMAL
- en: As you may already understand by now, state organization can be a nightmare
    sometimes. We could resort to a third-party library to help us with this but,
    once again, this is only a small part of our issues with our state.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only been dealing with the organization of state, but now imagine
    we need to cache the data that we got from our API request. This can lead us to
    madness.
  prefs: []
  type: TYPE_NORMAL
- en: From these issues we have just noticed, we can see that inside our global state,
    we tend to have different challenges, and a solution that works for one thing
    might not work for another. This is why it is important to split our global state.
    Our global state is often a mix between client state and server state. In the
    upcoming sections, you will understand what each one of these states is, and we’ll
    focus on server state to finally understand why React Query has become so popular
    and made our lives so much easier as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: What is client state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know, by now, you must be thinking, when is this book going to start React
    Querying? We are almost there, I promise you. I just need you to fully understand
    why I love React Query so much and to do so, it is important to understand the
    main problem it solves.
  prefs: []
  type: TYPE_NORMAL
- en: Now, client state is not one of the problems it solves, but you must be able
    to identify client state in your day-to-day life as a developer so that you fully
    understand what should be managed by React Query and what should be managed by
    other state management tools.
  prefs: []
  type: TYPE_NORMAL
- en: Client state is the state that is owned by your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of things that help define your client state:'
  prefs: []
  type: TYPE_NORMAL
- en: This state is synchronous, which means you can access it without any waiting
    time and by using synchronous APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is local; therefore, it only exists in your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is temporary, so it may get lost upon a page reload and is generally non-persistent
    between sessions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this knowledge in mind, if you were to look back at `GlobalStore`, what
    would you identify as belonging to client state?
  prefs: []
  type: TYPE_NORMAL
- en: Probably only `selectedTheme`, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us apply our learning from the previous bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to wait to get its value? *No*, so that means it is synchronous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the `selectedTheme` only exist in our application? *Yes*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will it be lost on a page reload? *Yes*, if we don’t persist it in local storage
    or check the browser preferences, then its value will be lost between page reloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, we can definitely say that `selectedTheme` belongs in our
    client state.
  prefs: []
  type: TYPE_NORMAL
- en: To manage this type of state, we can use anything from React Context to third-party
    libraries such as Redux, Zustand, or MobX when things start to become harder to
    organize and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: If we ask the same questions for our `serverData` state variable, would it work
    the same?
  prefs: []
  type: TYPE_NORMAL
- en: Does the data only exist in our application? *No*, it exists on a database somewhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will it be lost on page reload? *No*, the database still keeps the data, so
    when we reload, it will be fetched once again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to wait to get it? *Yes*, we need to trigger a fetching request to
    get this data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that our `serverData` state variable doesn’t belong in our client
    state. This is something that we would classify as part of server state.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now get into the thing that brought you to this book and made React Query
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: What is server state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have always had server state in our applications. The main issue was that
    we tried to tie it in with our client state management solutions. A common example
    of trying to tie our server state with our client state management solutions is
    using either **Redux Saga** or **Redux Thunk**. Both of them made it easier to
    do data fetching and store your server state. The main issue starts when we have
    to deal with some of the challenges server state brings us, but let’s not get
    ahead of ourselves; you will understand these challenges in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is server state, you might be wondering?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, as the name says, server state is the type of state that is stored on
    your server. Here are a couple of things that help identify your server state:'
  prefs: []
  type: TYPE_NORMAL
- en: This state is asynchronous, which means you need to use asynchronous APIs for
    fetching and updating it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is persisted remotely – most of the time on a database or external place
    you don’t own or control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no guarantees that this state is up to date in your application because
    most often, you have shared ownership of it, and it might be changed by others
    that are consuming it as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this knowledge in mind, let us look back at `GlobalStore` and our `serverData`
    state variable and apply these rules to identify our server state:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we need asynchronous APIs to access this state? We do! We need to send a
    fetch request to the server and wait for it to send the data back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it persisted remotely? It sure is. Like I just said in the previous bullet
    item, we need to ask our server for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will this state always be up to date in our application? We don’t know. We don’t
    control the state. This means that if anyone that is consuming the same API decides
    to update it, then our `serverData` state variable will immediately be outdated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you might be looking back at `GlobalStore` and asking the following: if
    `selectedTheme` is client state and `data` is server state, then what is the `isLoadingData`
    state variable?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is a derived state variable. This means that its state will always
    depend on the current status of our `serverData` fetching request. If we fetch
    data, then `isLoadingData` will be `true`; once we are done fetching data, then
    `isLoadingData` will go back to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine needing one of these derived state variables for every type of
    server state variable you have in your application. I’m also going to ask you
    to picture a scenario in which you needed to handle errors when a fetch request
    fails. You would probably create another state variable for errors, right? But
    wouldn’t you end up with the same issue as your loading state?
  prefs: []
  type: TYPE_NORMAL
- en: The previously mentioned scenario is just the very small tip of the iceberg
    of challenges that the server state brings to your application. Imagine that one
    of your team technical leads arrives at the office one day and tells you that
    now you need to start caching your data; oh God, another challenge that we didn’t
    think about. As you can see, the server state has many challenges, and in the
    next section, we will see a couple of them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding common challenges with server state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have probably figured out that the server state comes with quite
    its fair share of challenges. These challenges made React Query stand out even
    more when it came out because it solved them in such a simple way for developers
    that it seemed too good to be true.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what are these challenges, and why are they so complex to solve most of
    the time?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see all the common challenges that we have with the
    server state and understand a bit of the hard work we had to do as developers
    to solve them ourselves before we had React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is probably one of the hardest challenges we face in server state management.
  prefs: []
  type: TYPE_NORMAL
- en: To improve your page performance and make your site more responsive, very often,
    you will need to cache your data. This means being able to reuse data that you
    previously fetched to avoid refetching it from the server once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you might be thinking that this sounds simple, but consider the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: While keeping your application responsive, you need to update your cache in
    the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to be able to evaluate when your cache data has become stale and needs
    to be updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once data has not been accessed for a while, you must garbage-collect this data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might want to initialize your cache with some template data before data
    is fetched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, caching comes with its fair share of issues, and imagine having
    to solve all of these by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When performing mutations, you often want to make your user experience better.
    A mutation is a request that will either create or update your server state. Sometimes,
    you want to make your user experience better. We all hate filling out a form and
    ending up watching a loading spinner while our application in the background performs
    the mutation, refetches the data, and updates the UI.
  prefs: []
  type: TYPE_NORMAL
- en: To make the user experience better, we can resort to optimistic updates.
  prefs: []
  type: TYPE_NORMAL
- en: An optimistic update is when during an ongoing mutation, we update our UI to
    show how it will look after that mutation is complete, although that mutation
    is still not confirmed as complete. Basically, we are optimistic that this data
    will change and be what we are expecting it to be after the mutation, so we save
    our users some time and give them a UI that they will end up seeing earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine implementing this. While doing a mutation, you would need to update
    the server state in your application with the way we expect it to be after the
    mutation is successful. This would make the UI more responsive for the user and
    they can start interacting with it earlier. After the mutation is successful,
    you need to retrigger a manual refetch for the server state so that you actually
    have the updated state in your application. Now, picture a scenario in which the
    mutation fails. You would need to manually roll back your state to the previous
    version before your optimistic update.
  prefs: []
  type: TYPE_NORMAL
- en: Optimistic updates give an amazing user experience to your users but having
    to manage all the success and error scenarios, plus keeping your server date updated,
    can be a hard thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: Deduping requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s paint the following scenario.
  prefs: []
  type: TYPE_NORMAL
- en: You have a button in your UI that, when clicked on by the user, triggers a fetch
    request to partially update your server state. When the fetch is being performed,
    the button is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: This might seem okay and not troublesome at all but imagine that before your
    loading state updates and your button ends up being disabled, the user can click
    on the button 10 more times. What do you get? Ten more unexpected requests for
    the same data in your application.
  prefs: []
  type: TYPE_NORMAL
- en: This is why deduping requests is important. When fetching for the exact same
    type of data, if we trigger multiple requests for the same data, we want only
    one of those requests to be sent and avoid polluting our user network with unnecessary
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine having to implement this by yourself. You would need to be aware
    of all the requests currently being done in your application. When one of those
    requests exactly matches another one, then you would need to cancel that second,
    third, or fourth request.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you need some extra performance optimization in your server state.
    Here are some common patterns that you might need for specific optimization of
    your server state management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy loading**: You might only want a specific data fetching request to be
    done once a certain condition is met.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infinite scrolling**: When dealing with huge lists, infinite scrolling is
    a very common pattern where you just progressively load more data into your server
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paginated data**: To help structure large datasets, you can opt to paginate
    your data. This means that whenever a user decides to move from page 1 to page
    2, you will need to fetch the corresponding data for this page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are several challenges that we need to solve in order
    to have what we can consider the best experience dealing with server state in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is that deciding to take care of these challenges ourselves as developers
    can take quite a while, and the code we end up creating is often prone to bugs.
    Most of the time, these implementations end up affecting a lot of our code readability
    and significantly increasing the complexity it takes to understand our projects.
  prefs: []
  type: TYPE_NORMAL
- en: What if I told you that there was something that could take care of all of these
    challenges and many others in the background for you while giving you a super-clean
    and simple API that will make your code more readable, easier to understand, and
    make you feel like a true master of server state?
  prefs: []
  type: TYPE_NORMAL
- en: If you are reading this book, then you probably already know the answer. Yes,
    I’m talking about React Query.
  prefs: []
  type: TYPE_NORMAL
- en: So, pack up your server state knowledge, and prepare your projects because starting
    with the next chapter, we will change the way you handle server state.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we fully understood the concept of global state. By now, you
    should be able to understand why often our state is called global state and how
    much harder it can be to maintain it if we don’t split it.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to split your state into client and server states and understand
    how each of these types of states is important for your application and how you
    can identify them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you were familiarized with the challenges that server state can bring
    to your application and understood that if you were to address them all by yourself,
    then your code complexity would increase significantly and you’d probably lose
    some much-needed sleeping hours.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18501_03.xhtml#_idTextAnchor062), *React Query – Introducing,
    Installing, and Configuring It*, you will start getting hands-on with React Query.
    You will understand what it is and how it saves you from all the headaches that
    server state brings to your applications. You will learn how to install and configure
    it for your application and how you can add dedicated React Query developer tools
    to make your life even easier as a developer.
  prefs: []
  type: TYPE_NORMAL
