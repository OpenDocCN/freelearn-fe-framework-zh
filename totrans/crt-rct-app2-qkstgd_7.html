<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building Progressive Web Applications</h1>
                </header>
            
            <article>
                
<p><span><span>The beauty</span></span> of building a modern web application is being able to take advantage of functionalities such as a <strong>Progressive Web App</strong> (<strong>PWA</strong>)! But they can be a little complicated to work with. As always, the Create React App project makes a lot of this easier for us, but this time carries some significant caveats that we'll need to think about.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Examining PWAs and what they add</li>
<li>Learning how to configure our Create React App project into a custom PWA</li>
<li>Modifying and tuning the <kbd>manifest</kbd> file</li>
<li>Exploring service workers, their life cycle, and how to use them with Create React App</li>
<li>Exploring the caveats of using Create React App to build a PWA</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding and building PWAs</h1>
                </header>
            
            <article>
                
<p>PWAs are one of those features that sounds amazingly cool but it's surprisingly complicated to understand the when, why, and how of building them. Let's spend a little bit of time demystifying them and helping you understand why they are such a powerful (and appreciated) inclusion in our Create React App projects and how we can get started using them!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a PWA?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's talk a little bit about what a PWA is, because there is unfortunately a lot of misinformation and confusion about precisely what a PWA does!</p>
<p class="mce-root">Here's a short, maybe slightly unhelpful, version of what a PWA does; it's simply a website that does the following:</p>
<ul>
<li>Only uses <kbd>HTTPS</kbd></li>
<li><span>Adds a JSON manifest (a web app manifest) file</span></li>
<li><span>Has a Service Worker</span></li>
</ul>
<p class="mce-root">While yes, a PWA must have those behaviors, it's still difficult to understand what a PWA is or what it gives you in the long run. For example, does that tell you anything about what it does in different browsers? With different window sizes? What about how accessible it is, or how it functions when the internet is slow or non-existent?</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How do we define a PWA?</h1>
                </header>
            
            <article>
                
<p class="mce-root">A PWA, for us, is a React application that would be installable/runnable on a mobile device or desktop. Essentially, it's just your app, but with capabilities that make it a little more advanced, a little more effective, and a little more resilient to poor/no internet. A PWA accomplishes these via a few tenets, tricks, and requirements that we'd want to follow:</p>
<ul>
<li class="mce-root">The app must be usable by mobile and desktop-users alike</li>
<li class="mce-root">The app must operate over <kbd>HTTPS</kbd></li>
<li class="mce-root">The app must implement a web app JSON <kbd>manifest</kbd> file</li>
<li class="mce-root">The app must implement a Service Worker</li>
</ul>
<p class="mce-root">Now, the first one is a design question. Did you make your design responsive? If so, congratulations, you built the first step toward having a PWA! The next one is also more of an implementation question that's maybe not as relevant to us here: when you deploy your app to production, did you make it <kbd>HTTPS</kbd> only? I hope the answer to this is yes, of course, but it's still a good question to ask!</p>
<p class="mce-root">The next two, though, are things we can do as part of our Create React App project, and we'll make those the focus of this chapter!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a PWA in Create React App</h1>
                </header>
            
            <article>
                
<p class="mce-root">If we want to start building out a PWA in Create React App, as mentioned earlier, we need to start implementing against those two requirements that we laid out. We'll start off with the simplest problem to solve: implementing a <kbd>manifest</kbd> file for our PWA!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting with our manifest file</h1>
                </header>
            
            <article>
                
<p class="mce-root">Okay, so I identified the two items that we need to build to make this all happen: the JSON <kbd>manifest</kbd> file and the service worker! Easy, right? Actually, it's even easier than that. You see, Create React App will populate a JSON <kbd>manifest</kbd> file for us as part of our project creation by default! That means we have already completed this step! Let's celebrate, go home, and kick off our shoes, because we're all done now, right?</p>
<p class="mce-root">Well, sort of. We should take a look at that default <kbd>manifest</kbd> file because it's very unlikely that we want our fancy <kbd>TodoList</kbd> project to be called <kbd>"Create React App Sample"</kbd>. Let's take a look at the <kbd>manifest</kbd> file, located in <kbd>public/manifest.json</kbd>:</p>
<pre class="mce-root">{<br/> "short_name": "React App",<br/> "name": "Create React App Sample",<br/> "icons": [<br/> {<br/> "src": "favicon.ico",<br/> "sizes": "64x64 32x32 24x24 16x16",<br/> "type": "image/x-icon"<br/> }<br/> ],<br/> "start_url": ".",<br/> "display": "standalone",<br/> "theme_color": "#000000",<br/> "background_color": "#ffffff"<br/>}</pre>
<p class="mce-root">Some of these keys are pretty self-explanatory or at least have a little bit of information that you can infer from them as to what they accomplish. Some of the other keys, though, might be a little stranger. For example, what does <kbd>"start_url"</kbd> mean? What are the different options we can pick for display? What's a <kbd>"theme_color"</kbd> or <kbd>"background_color"</kbd>? Aren't those just decided by the CSS of our application?</p>
<p><span>Not quite. In fact, let's dive super deep into this world of JSON <kbd>manifest</kbd> files and turn it into something more useful!</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Viewing our manifest file in action with Chrome</h1>
                </header>
            
            <article>
                
<p>First, to be able to test this, we should have something where we can verify the results of our changes. We'll start off with Chrome, where if you go into the <span class="packt_screen">Developer tools</span> section, you can navigate to the <span class="packt_screen">Application</span> tab and be brought right to the <span class="packt_screen">Service Workers</span> section! Let's take a look at what it all looks like for our application:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ae72d45d-31f2-44e6-a50a-1e759a59907e.png" style="width:34.83em;height:48.00em;" width="637" height="877"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring the manifest file options</h1>
                </header>
            
            <article>
                
<p class="mce-root">Having a <kbd>manifest</kbd> file with no explanation of what the different keys and options mean is not very helpful, so let's take a deeper dive, key by key, into each of the configuration options available to us and some of the possible values we could use for each.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">name and short_name</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first key we have is <kbd>short_name</kbd>. This is a shorter version of the name that might be displayed when, for example, the title can only display a smaller bit of text than the full app or site name. The counterpart to this is <kbd>name</kbd>, which is the full name of your application. A good example of this might be something like this:</p>
<pre class="mce-root">{<br/> "short_name": "Todos",<br/> "name": "Best Todoifier"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">icons</h1>
                </header>
            
            <article>
                
<p class="mce-root">The next key to look at is the <kbd>"icons"</kbd> key, which is a list of sub-objects, each of which has three keys. This contains a list of icons that the PWA should use, whether it's for display on someone's desktop, someone's phone home screen, or something else. Each <kbd>"icon"</kbd> object should contain an <kbd>"src"</kbd>, which is a link to the image file that will be your icon. Next, you have the <kbd>"type"</kbd> key, which should tell the PWA what type of image file you're working with. For example, if you're using a <kbd>.png</kbd> file, you would list <kbd>"image/png"</kbd> here as the type. Finally, we have the <kbd>"sizes"</kbd> key, which tells the PWA the size of the icon. For best results, you should have at least a <kbd>"512x512"</kbd> and a <kbd>"192x192"</kbd> icon. The PWA will take care of scaling things down where necessary.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">start_url</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>start_url</kbd> key is used to tell the application at what point it should start in your application in relation to your server. While we're not using it for anything as we have a single page, no route app, that might be different in a much larger application, so you might just want the <kbd>start_url</kbd> key to be something indicating where you want them to start off from. Another option would be to add a query string on to the end of <kbd>url</kbd>, such as a tracking link. An example of that would be something like this:</p>
<pre class="mce-root">{<br/> "start_url": "/?source=AB12C"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">background_color</h1>
                </header>
            
            <article>
                
<p class="mce-root">This is the color used when a splash screen is displayed any time the application is first launched. This is similar to when you launch an application from your phone for the first time; that little page that pops up temporarily while the app loads is the splash screen, and this would be the background of that. This can either be a color name, like you'd use in CSS, or it can be a hex value for a color.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">display</h1>
                </header>
            
            <article>
                
<p class="mce-root"><kbd>display</kbd> affects the browser's UI when the application is launched. There are ways to make the application full-screen, to hide some of the UI elements, and so on. Here are the possible options, with their explanations:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 12.9568%"><kbd>Value</kbd></td>
<td style="width: 86.3787%">Description.</td>
</tr>
<tr>
<td style="width: 12.9568%"><kbd><span>browser</span></kbd></td>
<td style="width: 86.3787%"><span>A normal web browser experience.</span></td>
</tr>
<tr>
<td style="width: 12.9568%"><kbd><span>fullscreen</span></kbd></td>
<td style="width: 86.3787%"><span>No browser UI, and takes up the entire display.</span></td>
</tr>
<tr>
<td style="width: 12.9568%"><kbd><span>standalone</span></kbd></td>
<td style="width: 86.3787%"><span>Makes the web app look like a native application. It will run in its own window and hides a lot of the browser UI to make it look and feel more native.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">For our example, we'll be using <kbd>standalone</kbd> as our setting for display!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">orientation</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you want to make your application in the landscape orientation, you would specify it here. Otherwise you would leave this option missing from your <kbd>manifest</kbd>:</p>
<pre class="mce-root">{<br/>  "orientation": "landscape"<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">scope</h1>
                </header>
            
            <article>
                
<p class="mce-root">Scope helps to determine where the PWA in your site lies and where it doesn't. This prevents your PWA from trying to load things outside where your PWA runs. <kbd>start_url</kbd> must be located inside your scope for it to work properly! This is optional, and in our case we'll be leaving it out.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">theme_color</h1>
                </header>
            
            <article>
                
<p class="mce-root">This sets the color of the tool bar, again to make it feel and look a little more native. If we specify a meta theme color, we'd set this to be the same as that specification. Much like background color, this can either be a color name, like you'd use in CSS, or it can be a hex value for a color.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Customizing our manifest file</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we're experts on <kbd>manifest</kbd> files, let's customize our manifest file! We're going to change a few things here and there, but we won't make any major changes. For the purposes of this book, we're not going to worry about working with the images, so we'll leave those be for now. Let's take a look at how we've set up the <kbd>manifest</kbd> file in <kbd>public/manifest.json</kbd>:</p>
<pre class="mce-root">{<br/> "short_name": "Todos",<br/> "name": "Best Todoifier",<br/> "icons": [<br/> {<br/> "src": "favicon.ico",<br/> "sizes": "64x64 32x32 24x24 16x16",<br/> "type": "image/x-icon"<br/> }<br/> ],<br/> "start_url": "/",<br/> "display": "standalone",<br/> "theme_color": "#343a40",<br/> "background_color": "#a5a5f5"<br/>}</pre>
<p class="mce-root">So we've set our <kbd>short_name</kbd> and <kbd>name</kbd> keys to match the actual application. We've left the <kbd>icons</kbd> key alone completely since we don't really need to do much of anything with that anyway.</p>
<p class="mce-root">Next, we've changed <kbd>start_url</kbd> to just be <kbd>"/"</kbd>, since we're working under the assumption that this application is the only thing running on its domain. We've set the <kbd>display</kbd> to <kbd>standalone</kbd>, since we want our application to have the ability to be added to someone's home screen and be recognized as a true PWA.</p>
<p class="mce-root">Finally, we set the theme color to <kbd>#343a40</kbd>, which matches the color of the nav bar and will give a more seamless look and feel to the PWA. We also set the <kbd>background_color</kbd> key, which is for our splash screen, to <kbd>#a5a5f5</kbd>, which is the color of our normal <kbd>Todo</kbd> items!</p>
<p class="mce-root">If you think back to the explanation of keys, you'll remember we also need to change our meta theme tag in our <kbd>public/index.html</kbd> file, so we'll open that up and quickly make that change:</p>
<pre class="mce-root">&lt;meta name="theme-color" content="#343a40" /&gt;</pre>
<p class="mce-root">And that's it! Our <kbd>manifest</kbd> file has been customized! If we did it all correctly, we should be able to verify the changes again in our Chrome <span class="packt_screen">Developer tools</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bb4b9aad-125c-4881-a485-016633b4a808.png" style="width:51.58em;height:41.92em;" width="719" height="584"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hooking up Service Workers</h1>
                </header>
            
            <article>
                
<p>The other necessary component to having a working PWA for our application is to build out a Service Worker. Service Workers are another one of those components in PWAs that are not super well-understood, depending on who you ask, and their utility is also not immediately clear. We'll spend a little bit of time exploring and understanding Service Workers, even though the actual amount of work we need to do to implement Service Workers for our PWA is incredibly minimal (maybe even less work than our <kbd>manifest</kbd> file)!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is a Service Worker?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Service Workers are defined as a script that your browser runs behind the scenes, separate from the main browser threads. It can intercept network requests, interact with a cache (either storing or retrieving information from a cache), or listen to and deliver push messages. This carries a couple of caveats, too. It is fully asynchronous, so that means anything that requires synchronous operations, such as <strong><span>XMLHttpRequest</span></strong> (<strong>XHR</strong>) or operating with <strong>localStorage</strong>, cannot be used inside the Service Worker code. It can also do some other neat tricks, such as receiving push messages even when the app itself is not active, allowing you to display notifications to the user even when the app is not open!</p>
<p class="mce-root">Since it can intercept network requests and store/retrieve information from a server, it can also operate when offline, which allows your application to start up and be used immediately, and progressively fetch updates or update periodically in the background from the server!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Service Worker life cycle</h1>
                </header>
            
            <article>
                
<p class="mce-root">The life cycle for a Service Worker is pretty simple. There are three main stages:</p>
<ul>
<li>Registration</li>
<li>Installation</li>
<li>Activation</li>
</ul>
<p>Each of these stages are pretty self-explanatory.</p>
<p><strong>Registration</strong> is the process of letting the browser know where the Service Worker is located and how to install it into the background. The code for registration may look something like this:</p>
<pre class="mce-root">if ('serviceWorker' in navigator) {<br/>  navigator.serviceWorker.register('/service-worker.js')<br/>  .then(registration =&gt; {<br/>    console.log('Service Worker registered!');<br/>   })<br/>  .catch(error =&gt; {<br/>    console.log('Error registering service worker! Error is:', error);<br/>   });<br/>}</pre>
<p class="mce-root"><strong>Installation</strong> is the process that happens after the Service Worker has been registered, and only happens if the Service Worker either hasn't already been installed, or the Service Worker has changed since the last time.</p>
<p class="mce-root">In a <kbd>service-worker.js</kbd> file, you'd add something like this to be able to listen to this <kbd>event</kbd>:</p>
<pre class="mce-root">self.addEventListener('install', event =&gt; {<br/>  // Do something after install<br/>});</pre>
<p class="mce-root">Finally, <strong>Activation</strong> is the step that happens after all of the other steps have completed. The Service Worker has been registered and then installed, so now it's time for the service worker to start doing its thing:</p>
<pre class="mce-root">self.addEventListener('activate', event =&gt; {<br/>  // Do something upon activation<br/>});</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How can we use a Service Worker in our app?</h1>
                </header>
            
            <article>
                
<p class="mce-root">So, how do we use a Service Worker in our application? Well, it's simple to do with Create React App, but there is a major caveat: you can't configure the Create React App default generated <kbd>service-worker.js</kbd> file without ejecting your project, unfortunately! Not all is lost, however; you can still take advantage of some of the highlights of PWAs and service workers by using the default Create React App-generated Service Worker.</p>
<p class="mce-root">To enable this, hop over into <kbd>src/index.js</kbd>, and, at the final line, change the Service Worker <kbd>unregister()</kbd> call to <kbd>register()</kbd> instead:</p>
<pre class="mce-root">serviceWorker.register();</pre>
<p class="mce-root">And now we're opting in to our Service Worker! Next, to actually see the results, you'll need to run the following:</p>
<pre class="mce-root"><strong>$ yarn build</strong></pre>
<p class="mce-root">We'll create a <em>Production</em> build (We'll cover this in greater detail in <a href="f657a8b7-93c3-412c-871d-8f3f56604a58.xhtml">Chapter 8</a>, <em>Getting Your App Ready for Production</em>). You'll see some output that we'll want to follow as part of this:</p>
<pre class="mce-root"><strong>The build folder is ready to be deployed.</strong><br/><strong>You may serve it with a static server:</strong><br/><br/><strong>  yarn global add serve</strong><br/><strong>  serve -s build</strong></pre>
<p class="mce-root"><span><span>As per the instructions, w</span></span>e'll install <strong>serve</strong> globally, and run the command as instructed. When we run this, we should see the following output:</p>
<pre class="mce-root"><strong>$ serve -s build</strong><strong><br/></strong></pre>
<p>We will get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/40e02f22-cc31-4d5b-8d70-19786046e80b.png" style="width:26.83em;height:10.67em;" width="447" height="143"/></p>
<p class="mce-root"/>
<p class="mce-root">Now open up <kbd>http://localhost:5000</kbd> in your local browser and you'll be able to see, again in the Chrome <span class="packt_screen">Developer tools</span>, the Service Worker up and running for your application:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-454 image-border" src="Images/77b20199-b619-49f7-925b-a981b91c24e0.png" style="width:54.08em;height:19.42em;" width="1006" height="361"/></p>
<div class="packt_tip">Note that the rule of requiring <kbd>HTTPS</kbd> for Service Workers and PWAs is not in effect when you're running it on <kbd>localhost</kbd>!</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">Hopefully, we've explored at least enough of Progressive Web Apps that they have at least been partially demystified! A lot of the confusion and trouble with building PWAs tends to stem from the fact that there's not always a good starting point for building one. To get the value out of PWAs, you have to have a PWA, but to build a PWA you typically need to demonstrate the value of them! What a whirlwind!</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Create React App limits us a little bit in how we can implement Service Workers, which admittedly limits the functionality and usefulness of our PWA. It doesn't hamstring us, by any means, but doing fun tricks with pre-caching networks and API responses, and loading up our application instantly, even if the browser doing the loading is offline in the first place. That being said, it's like many other things in Create React App: an amazing stepping stone and a great way to get moving with PWAs in the future!</p>
<p>In the next and final chapter, we'll tie up a few loose ends with our project and talk a little bit about production builds and ejecting out of Create React App! We'll look at how to take our code and get it into production. We'll also discuss importing some other major libraries into our Create React App project, such as Redux!</p>


            </article>

            
        </section>
    </div>



  </body></html>