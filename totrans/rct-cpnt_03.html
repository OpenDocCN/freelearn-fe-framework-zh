<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Saving and Communicating Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Saving and Communicating Data</h1></div></div></div><p>In the previous chapter, we created complex component hierarchies. We created a list of pages and a way to edit those pages. Yet we stopped short of saving and reading any of that data to some kind of storage.</p><p>We could, for instance, send an edit through an Ajax request to be saved in a database server. In fact, that's what often happens in the applications we use these days. They always save our interactions, irrespective of whether we expect them to or not.</p><p>In this chapter, you will learn about local data stores and communicating with them. You'll also learn about event-based architecture and how it promotes the unidirectional flow of data.</p><p>There are many ways to save data. It's a rich and interesting topic that could fill scores of books. I could go so far as to say it is at the core of how businesses and applications work.</p><p>Furthermore, how data is communicated can often be different in a maintainable application and an unmaintainable application. It's up to us to figure out elegant ways of persisting data so that our applications remain maintainable.</p><p>We will only explore local storage in this chapter. You'll be able to see your stored data beyond page reloads, but nobody else will. You cannot build a practical website based on this chapter alone. You will have to wait until we explore React on the server.</p><div class="section" title="Validating properties"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Validating properties</h1></div></div></div><p>Before we look at storing data, there is <a id="id43" class="indexterm"/>another habit I'd like to share with you. The components we created in the last chapter work well together, but our aim is to make each component self-contained. We want others to be able to reuse our components, but they will encounter problems if they don't know which properties our components expect.</p><p>Consider what would happen if we used <code class="literal">PageAdmin</code> like this:</p><div class="informalexample"><pre class="programlisting">ReactDOM.render(
    &lt;PageAdmin <span class="strong"><strong>backend="ajax"</strong></span> /&gt;,
    document.querySelector(".react")
);</pre></div><p>Faced with this component, and no documentation, it might be tempting to substitute a <code class="literal">Backend</code> object with some other configuration data. This looks reasonable to someone unfamiliar with the component. And, without a careful study of all our components, we can't expect others to know what those properties should be.</p><p>We can protect against this situation by adding property validation. Let's add some validation to <code class="literal">PageEd</code><a id="id44" class="indexterm"/>
<code class="literal">itor</code>:</p><div class="informalexample"><pre class="programlisting">PageEditor.propTypes = {
    "id": React.PropTypes.number.isRequired,
    "title": React.PropTypes.string.isRequired,
    "body": React.PropTypes.string.isRequired,
    "onUpdate": React.PropTypes.func.isRequired,
    "onCancel": React.PropTypes.func.isRequired
};</pre></div><p>We have already imported the <code class="literal">React</code> object, which exposes a <code class="literal">PropTypes</code> object. This contains some validators. When we specify a few on <code class="literal">PageEditor.propTypes</code>, React checks the types of properties given to the component as it is rendered. If we give the incorrect property types or omit required properties, React will emit a warning.</p><p>The warnings look like this:</p><div class="mediaobject"><img src="graphics/5268_03_01.jpg" alt="Validating properties"/></div><p>There are many types to choose from, the simple ones being the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">React.PropTypes.array</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">React.PropTypes.bool</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">React.PropTypes.func</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">React.PropTypes.number</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">React.PropTypes.object</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">React.PropTypes.string</code></li></ul></div><p>If you need a property to be required (which is likely in most cases) then you can add <code class="literal">.isRequired</code> at the end. Let's follow this up with validators for <code class="literal">PageView</code>:</p><div class="informalexample"><pre class="programlisting">PageView.propTypes = {
    "title": React.PropTypes.string.isRequired,
    "onEdit": React.PropTypes.func.isRequired,
    "onDelete": React.PropTypes.func.isRequired
};</pre></div><p>This is even simpler, given that <code class="literal">PageView</code> uses fewer properties than <code class="literal">PageEditor</code>. Also, <code class="literal">Page</code> is relatively simple:</p><div class="informalexample"><pre class="programlisting">Page.propTypes = {
    "id": React.PropTypes.number.isRequired,
    "onDelete": React.PropTypes.func.isRequired
};</pre></div><p>We don't need to validate properties passed straight through components. For instance, <code class="literal">PageEditor</code> uses <code class="literal">onUpdate</code>. It's passed through <code class="literal">Page</code>, but <code class="literal">Page</code> doesn't use it, <code class="literal">PageEditor</code> does, so<a id="id45" class="indexterm"/> that's where we use validators for it.</p><p>However, what if we want to validate nested structures or more complex types? We can try the following:</p><div class="informalexample"><pre class="programlisting">PageAdmin.propTypes = {
    "backend": <span class="strong"><strong>function(props, propName, componentName) {</strong></span>
<span class="strong"><strong>        if (props.backend instanceof Backend) {</strong></span>
<span class="strong"><strong>            return;</strong></span>
<span class="strong"><strong>        }</strong></span>

<span class="strong"><strong>        return new Error(</strong></span>
<span class="strong"><strong>            "Required prop `backend` is not a `Backend`."</strong></span>
<span class="strong"><strong>        );</strong></span>
<span class="strong"><strong>    }</strong></span>
};</pre></div><p>We expect the <code class="literal">backend</code> property to be an instance of the <code class="literal">Backend</code> class. If it is anything else, we return an <code class="literal">Error</code> describing why the property is invalid. We can also use <code class="literal">shape</code> to validate nested properties:</p><div class="informalexample"><pre class="programlisting">Component.propTypes = {
    "page": <span class="strong"><strong>React.PropTypes.shape({</strong></span>
<span class="strong"><strong>        "id": React.PropTypes.number.isRequired,</strong></span>
<span class="strong"><strong>        "title": React.PropTypes.string.isRequired,</strong></span>
<span class="strong"><strong>        "body": React.PropTypes.string.isRequired</strong></span>
<span class="strong"><strong>    })</strong></span>
};</pre></div><p>The more specific we are <a id="id46" class="indexterm"/>about properties, the less chance there is for bad properties to break the interface. So, it's good to get in the habit of defining them all the time.</p></div></div>
<div class="section" title="Storing cookies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Storing cookies</h1></div></div></div><p>You must have <a id="id47" class="indexterm"/>heard of cookies before. They're a browser-based storage mechanism as old as the Internet, and they are often comically described in movies. Here's how we use them:</p><div class="informalexample"><pre class="programlisting">document.cookie = "pages=all_the_pages";
document.cookie = "current=current_page_id";</pre></div><p>The <code class="literal">document.cookie</code> parameter works as a temporary string store. You can keep adding new strings, where the key and value are separated by <code class="literal">=</code>, and they will be stored beyond a page reload, that is, until you reach the limit of how many cookies your browser will store per domain. If you set <code class="literal">document.cookie</code> multiple times, multiple cookies will be set.</p><p>You can read the cookies back again, with a function like this:</p><div class="informalexample"><pre class="programlisting">var cookies = {};

function readCookie(name) {
    var chunks = document.cookie.split("; ");

    for (var i = chunks.length - 1; i &gt;= 0; i--) {
        var parts = chunks[i].split("=");
        cookies[parts[0]] = parts[1];
    }

    return cookies[name];
}

export default readCookie;</pre></div><p>The whole cookie string is read and split using semicolons. Then, each cookie is split into equals, leaving the key and value. These are stored in the local <code class="literal">cookies</code> object. Future requests just read the key from the local object. The <code class="literal">cookies</code> object can be inspected at any point to see the<a id="id48" class="indexterm"/> cookies that have been set.</p><p>Try <a class="ulink" href="http://browsercookielimits.squawky.net">http://browsercookielimits.squawky.net</a> to test what your browser can handle. I'm running a modern<a id="id49" class="indexterm"/> version of Chrome, and I can probably store 180 cookies per domain, totaling 4096 bytes. 4096 bytes doesn't sound like a lot...</p><p>Cookies aren't typically used for the kinds of data we want to store. We'll have to look elsewhere.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>If you want to<a id="id50" class="indexterm"/> learn more about how to use cookies, head over to <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie">https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie</a>.</p></div></div></div>
<div class="section" title="Using local storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Using local storage</h1></div></div></div><p>The next type of<a id="id51" class="indexterm"/> storage we will look at is a relatively recent addition to the browser toolset. It's called <span class="emphasis"><em>local storage</em></span>, and it's been around for a while. You can add items to it as follows:</p><div class="informalexample"><pre class="programlisting">localStorage.setItem("pages", "all_the_pages");</pre></div><p>It's simpler than cookies to read items from:</p><div class="informalexample"><pre class="programlisting">localStorage.getItem("pages");</pre></div><p>This will persist the data beyond page reloads or the browser closing. You can store considerably more data than in cookies (anywhere from 3 MB to 10 MB, by default), and the interface is easier to use.</p><p>So, how can we use this to store our pages? Let's abstract local storage a bit:</p><div class="informalexample"><pre class="programlisting">export default {
    "get": function(key, defaultValue) {
        var value = window.localStorage.getItem(key);
        
        var decoded = JSON.parse(value);

        if (decoded) {
            return decoded;
        }

        return defaultValue;
    },

    "set": function(key, value) {
        window.localStorage.setItem(
            key, JSON.stringify(value)
        );
    }
};</pre></div><p>For once, we're exporting an object instead of a class. This object has a couple of methods both of which access <code class="literal">window.localStorage</code>. It's not ideal to reference this directly, but if we use<a id="id52" class="indexterm"/> this abstraction everywhere else, then I think it's OK.</p><p>The <code class="literal">get</code> method pulls a string value out of local storage and parses it as a JSON string. If the value parses to any non-false value, we return it, or else we return a default value.</p><p>The <code class="literal">set</code> method encodes a value as JSON, and stores it.</p><p>Then, we can use the following abstraction in the <code class="literal">Backend</code> class:</p><div class="informalexample"><pre class="programlisting">import LocalStore from "local-store";

class Backend {
    constructor() {
        <span class="strong"><strong>this.pages = LocalStore.get("pages", []);</strong></span>
    }

    getAll() {
        <span class="strong"><strong>return this.pages;</strong></span>
    }

    update(id, property, value) {
        <span class="strong"><strong>this.pages = this.pages.map((page) =&gt; {</strong></span>
<span class="strong"><strong>            if (page.id == id) {</strong></span>
<span class="strong"><strong>                page[property] = value;</strong></span>
<span class="strong"><strong>            }</strong></span>

<span class="strong"><strong>            return page;</strong></span>
<span class="strong"><strong>        });</strong></span>

<span class="strong"><strong>        LocalStore.set("pages", this.pages);</strong></span>
    }

    delete(id) {
        <span class="strong"><strong>this.pages = this.pages.filter(</strong></span>
<span class="strong"><strong>            (page) =&gt; page.id !== id</strong></span>
<span class="strong"><strong>        );</strong></span>

<span class="strong"><strong>        LocalStore.set("pages", this.pages);</strong></span>
    }
}

export default Backend;</pre></div><p>We begin with a constructor that fetches any stored pages from <code class="literal">localStorage</code>. We provide a default empty array in case the <code class="literal">pages</code> key is missing in <code class="literal">localStorage</code>. We store that in <code class="literal">this.pages</code> so we can fetch and modify it later.</p><p>The <code class="literal">getAll</code> method is<a id="id53" class="indexterm"/> much simpler this time around. All it does is returns <code class="literal">this.pages</code>. The <code class="literal">update</code> and <code class="literal">delete</code> methods become more interesting though. The <code class="literal">update</code> method uses the <code class="literal">Array.map</code> method to apply updates to the affected page objects. We have to store the updated <code class="literal">pages</code> array back in local storage so that the changes are persisted.</p><p>Similarly, <code class="literal">delete</code> modifies the <code class="literal">pages</code> array (this time with a short function syntax) and stores the modified array back in local storage. We have to see local storage with some initial data. You can do this in a developer console:</p><div class="informalexample"><pre class="programlisting">localStorage.setItem("pages", JSON.stringify([
    {
       "id": 1,
       "title": "Home",
       "body": "..."
    },
    {
       "id": 2,
       "title": "About Us",
       "body": "..."
    },
    {
       "id": 3,
       "title": "Contact Us",
       "body": "..."
    },
    {
       "id": 4,
       "title": "Products",
       "body": "..."
    }
]));</pre></div><p>If you've made these<a id="id54" class="indexterm"/> changes, and you refresh the page, you should see the new backend code in action!</p></div>
<div class="section" title="Using event emitters"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Using event emitters</h1></div></div></div><p>Until now, our components have communicated with the backend through method calls. That's OK for tiny<a id="id55" class="indexterm"/> applications, but when things start to scale, we will forget to make some of those method calls.</p><p>Look at <code class="literal">onUpdate</code>, for instance:</p><div class="informalexample"><pre class="programlisting">onUpdate(id, field, value) {
    this.props.backend.update(id, field, value);

    this.setState({
        "pages": this.props.backend.getAll()
    });
}</pre></div><p>Every time we change the state of a page, we have to fetch an updated list of pages from the backend. What if multiple components send updates to the backend? How will our <code class="literal">PageAdmin</code> component know when to fetch a new list of pages?</p><p>We can turn to event-based architecture to solve this problem. We've already encountered and used events! Recollect what we did when we created the page edit form. There, we connected to input events so we could update pages when input values changed.</p><p>This kind of architecture moves us closer to a unidirectional flow of data. We can imagine our entire application like a tree of components, beginning with a single root component. When a component needs to update some application's state, we don't need to code the state change in relation to where that component is. In the past, we may have had to reference specific CSS selectors, or depend on the position of sibling elements, when updating state.</p><p>When we start to use events, then any component can trigger a change in the application. Also, multiple components can trigger the same kind of change. We'll explore this idea in more detail in later chapters.</p><p>We can use that<a id="id56" class="indexterm"/> same idea to notify components when the data changes. To begin with, we need to download an event emitter class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save eventemitter3</strong></span>
</pre></div><p>Now, <code class="literal">Backend</code> can extend this, providing the event functionality that we are after:</p><div class="informalexample"><pre class="programlisting">class Backend extends EventEmitter {
    constructor() {
        super();

        this.pages = LocalStore.get("pages", []);
    }

    getAll() {
        return this.pages;
    }

    update(id, property, value) {
        // ...update a page

        this.emit("update", this.pages);
    }

    delete(id) {
        // ...delete a page

        this.emit("update", this.pages);
    }
}</pre></div><p>As each page is updated or deleted, the backend will emit an event on itself. This does nothing until we listen for these events in <code class="literal">PageAdmin</code>:</p><div class="informalexample"><pre class="programlisting">constructor(props) {
    super(props);

    this.bind(
        "onUpdate",
        "onDelete"
    );

    this.state = {
        "pages": this.props.backend.getAll()
    };

    <span class="strong"><strong>this.props.backend.on("update",</strong></span>
<span class="strong"><strong>        (pages) =&gt; this.setState({pages})</strong></span>
<span class="strong"><strong>    );</strong></span>
}

onUpdate(id, field, value) {
    this.props.backend.update(id, field, value);
}

onDelete(id) {
    this.props.backend.delete(id);
}</pre></div><p>Now we can<a id="id57" class="indexterm"/> remove the numerous calls to <code class="literal">this.setState</code> and replace them with a single event listener in the <code class="literal">constructor</code>. We are also doing something interesting with the <code class="literal">setState</code> call. It's <a id="id58" class="indexterm"/>called <span class="emphasis"><em>object destructuring</em></span>, and it allows <code class="literal">{pages}</code> to become <code class="literal">{"pages":pages}</code>.</p><p>Now we can begin to use this backend for many different parts of the interface, and they'll all have accurate, real-time data. Open the page up in a few different windows and watch them all update at once!</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we looked at how to protect our components from faulty properties. We also saw how easy it was to use cookies, although they are limited for what we need. Fortunately, we can use local storage and work it into our existing backend and components.</p><p>Finally, we explored using events to push state changes out to all interested components.</p><p>In the next chapter, we will start prettying up our components. We'll look at ways to style and animate them, bringing our interface to life!</p></div></body></html>