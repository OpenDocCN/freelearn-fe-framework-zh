<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">NgRx – In Depth</h1>
                </header>
            
            <article>
                
<p>This chapter will go into more advanced NgRx topics. As you implement your first applications using NgRx, you will notice that it means creating a lot of boilerplate and you may not feel as fast as when you were NOT using NgRx. For that reason, the entity library exists to help alleviate some of the boilerplate creation—more on that later in this chapter.</p>
<p>The router and its state is another thing that can be interesting to keep track of. The URL of where you are currently, the router parameter, as well as query parameters are all interesting pieces of information that might come in handy. They might come in handy should you be in a situation where you might want to reinstate the app, also called <strong>rehydration</strong>.</p>
<p>Next, we will dive into how to build your own micro implementation of NgRx using RxJS, so you get a feel for what's going on. Hopefully, that will be a real eye-opening moment in understanding the underlying ideas of what makes NgRx and Redux tick.</p>
<p>To round off this chapter and this book, we will explain what schematics is and how it will help you quickly scaffold the various parts that you need to be a really efficient user of NgRx.</p>
<p class="mce-root">In this chapter, you will learn how to:</p>
<ul>
<li>Leverage the entity library and how it makes our life easier using NgRx </li>
<li>Capture the router state as well as customize what gets saved down by writing our own customization code </li>
<li>Build a micro implementation of NgRx</li>
<li>Demystify schematics and see how it can make us an even faster and more efficient user of NgRx</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@ngrx/entity</h1>
                </header>
            
            <article>
                
<p>The demo code for this section can be found in the code repository for this book under <kbd>Chapter10/Entity</kbd>.</p>
<p>The entity library is here to help us manage collections and basically, write less and do more. This means that so far we have been writing a lot of code when creating reducers and selectors that we simply won't need to do when we leverage the full power of the entity library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting it up</h1>
                </header>
            
            <article>
                
<p>We start by downloading the entity library. To do this, we need to run the following command:</p>
<pre><strong>npm install @ngrx/entity</strong></pre>
<p>We then need to perform the following steps:</p>
<ol>
<li>Create a model.</li>
<li>Create an entity state based on the model.</li>
<li>Create an entity adapter.</li>
<li>Create the initial state.</li>
<li>Create the reducer and set up the state in the <kbd>StoreModule.</kbd> </li>
</ol>
<p>Let's start off by creating our model:</p>
<pre>// user.model.ts<br/><br/>export interface User {<br/>  id: number;<br/>  name: string;<br/>}</pre>
<p>The preceding code is just a simple model with fields   <kbd>id</kbd>   and   <kbd>name</kbd>.  We then create our entity state, like so:</p>
<pre>// excerpt from app.module.ts<br/><br/>import<span> { <br/>  <strong>EntityState</strong>, <br/>  createEntityAdapter, <br/>  EntityAdapter <br/>} </span><span>from</span><span> </span><span>"@ngrx/entity"</span><span>;<br/><br/></span>export<span> </span><span>interface</span><span> State </span><span>extends</span><span><strong> EntityState</strong>&lt;<strong>User</strong>&gt; {<br/></span>  selectedUserId<span>:</span><span> number </span><span>|</span><span> null;<br/></span>}<span><br/></span></pre>
<p>This will be the return type our reducer needs to abide by. Type <kbd>EntityState</kbd> looks like the following, if you peek into the NgRx source code:</p>
<pre>// from NGRX source code<br/><br/>export<span> </span><span>interface</span><span> EntityState&lt;T&gt; {<br/></span>  <strong>ids: string[] | number[];<br/>  entities:</strong><span><strong> Dictionary&lt;T&gt;;</strong><br/></span>}<span><br/></span></pre>
<p>By extending the preceding interface <kbd>EntityState,</kbd> when we create type <kbd>State</kbd> we will also get the properties <kbd>ids</kbd> and <kbd>entities</kbd>. We will see later in this section how these properties are populated, once we start using the utility methods the entity library gives us.</p>
<p>The next step is to create our adapter. An instance of the adapter sits on a range of methods, allowing us to write a great deal less code. We create the adapter with the following code:</p>
<pre>// excerpt from app.module.ts<br/><br/>import<span> { <br/>  EntityState, <br/>  createEntityAdapter, <br/>  <strong>EntityAdapter</strong> <br/>} </span><span>from</span><span> </span><span>"@ngrx/entity"</span><span>;<br/><br/></span>const<span> userAdapter</span><span>:</span><span><strong> EntityAdapter</strong>&lt;User&gt; </span><span>=</span><span> createEntityAdapter&lt;User&gt;();</span></pre>
<p>At this point, we are almost ready; we just need to get the initial state from the adapter and provide that to our reducer.</p>
<p>To get the initial state, we need to talk to our adapter, like so:</p>
<pre>// excerpt from app.module.ts<br/><br/>const<span> initialState</span><span>:</span><strong> State </strong><span>=</span><span> {<br/></span>  ids: [],<br/>  entities: {},<br/>  selectedUserId: <span>null<br/></span>};<br/><br/>const<span> </span><span>initial</span><span> </span><span>=</span><span> </span><span>userAdapter<strong>.getInitialState(initialState)</strong>;</span></pre>
<p>What's happening here is that we need to create an object representing the initial state. It needs to be of type <kbd>State</kbd> and therefore it needs to have the properties <kbd>ids</kbd>, <kbd>entities</kbd>, and <kbd>selectedUserId</kbd> defined. Then, we call <kbd>getInitialState()</kbd> on the adapter to produce our initial state. So, what do we need the initial state for? We'll need to set it as the default value of our reducer's state. </p>
<p>Next, we create our reducer and set its default state to our initial state instance, created previously:</p>
<pre>// interfaces.ts<br/><br/>import<span> { Action } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span><br/>export<span> </span><span>interface</span><span> ActionPayload&lt;T&gt; </span><span>extends</span><span> Action {<br/></span>  payload<span>:</span><span> T;<br/></span>}<br/><br/>// excerpt from app.module.ts<br/><br/>function<span> userReducer(state </span><span>=</span><span><strong> initial</strong>, action</span><span>:</span><span> ActionPayload&lt;User&gt;)</span><strong>:</strong><span><strong> State</strong> {<br/></span>  switch<span> (action.type) {<br/></span>    case<span> </span><span>"ADD_USER"</span><span>:<br/></span>      return<span><strong> userAdapter.addOne(action.payload, state);</strong><br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>    }<br/> }<br/>}</pre>
<p>Note here how we call our <kbd>userAdapter</kbd> and invoke the method <kbd>addOne()</kbd>; this means that we don't have to write code that looks like this:</p>
<pre>// example of what a reducer could look like that is NOT using @ngrx/entity<br/><br/>function<span> reducer(state </span><span>=</span><span><strong> []</strong>, action</span><span>:</span><span> ActionPayload&lt;User&gt;)</span><span> {<br/></span>  switch<span> (action.type) {<br/></span>    case<span> </span><span>"ADD_USER"</span><span>:<br/></span>      return<span><strong> [<br/>        ...state.users<br/>        Object.assign({}, action.payload)<br/>      ];</strong><br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>    }<br/> }<br/>}</pre>
<p>The last step to setting everything up is to add the state to the <kbd>StoreModule</kbd> so that NgRx knows about it:</p>
<pre>// excerpt from app.module.ts<br/><br/>@NgModule({<br/>  declarations: [AppComponent, EditUserComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    FormsModule,<br/>    <strong>StoreModule.forRoot({</strong><br/><strong>      users: userReducer</strong><br/><strong>    })</strong><br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export<span> </span><span>class</span><span> AppModule {}</span></pre>
<p>That concludes the required setup. The next steps we want to take in the following sections are how to display the data in a component, and also how to perform a full CRUD and thereby leveraging more of what the <kbd>EntityAdapter</kbd> has to offer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting our data</h1>
                </header>
            
            <article>
                
<p>We have learnt by now that to select data in NgRx, we need to inject the store service and call <kbd>select</kbd> on it, either with a string as an argument or with a function. Let's inject the store service and have a look at the state that comes back:</p>
<pre>// app.component.ts  - a first draft<br/><br/>import<span> { Component } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span><strong>import { AppState } from "./app-state";<br/>import { Store } from "@ngrx/store";</strong><span><br/><br/></span>@Component({<br/>  selector: <span>"app-root"</span><span>,<br/></span>  template: <span>`<br/></span>  User list view<span><br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> AppComponent {<br/></span>  title <span>=</span><span> </span><span>"app"</span><span>;<br/></span>  users$;<br/><br/>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.users$ </span><span>=</span><span> </span><span>this</span><span>.store<br/></span>      <strong>.select(state =&gt;</strong><span><strong> state);</strong><br/><br/></span>    this<span>.users$<br/>      .subscribe(data </span><span>=&gt;</span><span> console.log(</span><span>"users"</span><span>, data));<br/></span>  }<br/>}</pre>
<p>The preceding component won't display the users in a neat list just yet; we will explain why later. In the meantime, we will just focus on what is logged to the console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ecf91d61-2e05-4d72-ac6e-2a5a54a1ae44.png" style=""/></div>
<p>What we see here is the state of our store, which contains a user's property at the highest level, it has <kbd>entities</kbd>, <kbd>ids</kbd> and <kbd>selectedUserId</kbd> as properties. This is to be expected so far. What does surprise us a little is the fact that the entities dictionary is an object and not a list. How do we output that in a list form using <kbd>*ngFor</kbd>?  Well, we can easily solve that with a <kbd>map()</kbd> operator, like so:</p>
<pre>// app.component.ts adding more UI and selecting the correct slice of state<br/><br/>import<span> </span><span>{ Component }</span><span> </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> </span><span>{ AppState }</span><span> </span><span>from</span><span> </span><span>"./app-state"</span><span>;<br/></span>import<span> </span><span>{ Store }</span><span> </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span><strong>import { map } from "rxjs/operators"</strong><span><strong>;</strong><br/><br/></span>@Component({<br/>  selector:<span> </span><span>"app-root"</span><span>,<br/></span>  template:<span> </span><span>`<br/></span>  &lt;<span>div</span><span> </span><span>style</span><span>=</span><span>"border: solid 1px black; padding: 10px;"</span><span> <br/></span><strong>       *ngFor="let user of users$ | async"</strong><span>&gt;<br/></span>  {{ user.name }}<br/>  &lt;/<span>div</span><span>&gt;</span><span><br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> </span><span>AppComponent {<br/></span>  title<span> </span><span>=</span><span> </span><span>"app"</span><span>;<br/></span>  users$;<span><br/></span>  constructor<span>(</span><span>private</span><span> </span><span>store</span><span>:</span><span> </span><span>Store&lt;AppState&gt;) {<br/></span>    this<span>.users$</span><span> </span><span>=</span><span> </span><span>this</span><span>.store<br/>      .select(state</span><span> </span><span>=&gt;</span><span> </span><span><strong>state.users.entities</strong>)<br/></span>      <strong>.pipe(<br/>        map(this.toArray)<br/>      );</strong><br/>    this<span>.users$.subscribe(data</span><span> </span><span>=&gt;</span><span> </span><span>console.log(</span><span>"users"</span><span>, data));<br/></span>  }<br/><br/>  <strong>toArray(obj) {</strong><br/><strong>    const keys = Object.keys(obj);<br/>    return keys.map(key =&gt; obj[key]);<br/>  }</strong><br/>}</pre>
<p>OK, so now we drill down to <kbd>state.users.entities</kbd> to get to our users but we need to add the <kbd>map()</kbd> operation to turn our entities dictionary into a list. So, the console now shows us an empty array as the initial value of <kbd>users$</kbd>, which makes perfect sense. The UI is still empty, as we have an empty array and therefore nothing to show.  In the following section, we will cover how to add, remove, and update the state using the <kbd>EntityAdapter</kbd>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the full CRUD</h1>
                </header>
            
            <article>
                
<p>What we mean by CRUD is the ability to add, edit, read, and delete the data from the store. The point of using the entity library is for it to do most of the heavy lifting. The time has come to revisit our reducer:</p>
<pre>// excerpt from app.module.ts<br/><br/>function<span> userReducer(<br/>  state </span><span>=</span><span> initial, <br/>  action</span><span>:</span><span> ActionPayload&lt;User&gt;)</span><span>:</span><span> State {<br/><br/></span>  switch<span> (action.type) {<br/></span>    case<span> </span><span>"ADD_USER"</span><span>:<br/></span>      return<strong> userAdapter.addOne(action.payload, state);</strong><br/>    default<span>:<br/></span>      return<span> state;<br/></span>    }<br/>}</pre>
<p>Here, we are using the <kbd>userAdapter</kbd> instance to carry out adding one item to the store. There is a lot more the adapter can do for us though—here is a full list of its capabilities:</p>
<pre>// description of the interface for EntityStateAdapter, <br/>// the interface our userAdapter implements<br/><br/>export<span> </span><span>interface</span><span> EntityStateAdapter&lt;T&gt; {<br/></span>  addOne&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(entity</span><span>:</span><span> T, state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  addMany&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(entities</span><span>:</span><span> T[], state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  addAll&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(entities</span><span>:</span><span> T[], state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  removeOne&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(key</span><span>:</span><span> string, state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  removeOne&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(key</span><span>:</span><span> number, state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  removeMany&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(keys</span><span>:</span><span> string[], state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  removeMany&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(keys</span><span>:</span><span> number[], state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  removeAll&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  updateOne&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(update</span><span>:</span><span> Update&lt;T&gt;, state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>  updateMany&lt;S <span>extends</span><span> EntityState&lt;T&gt;&gt;(updates</span><span>:</span><span> Update&lt;T&gt;[], state</span><span>:</span><span> S)</span><span>:</span><span> S;<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating users</h1>
                </header>
            
            <article>
                
<p>As we can see,    <kbd><span>EntityStateAdapter</span></kbd>   has methods for the full CRUD. Let's look at adding the capability to add a user to our component. We need to make the following additions to our component:</p>
<ul>
<li>Add an input field</li>
<li>Dispatch an <kbd>ADD_USER</kbd> action with our new user as payload</li>
</ul>
<p>The required code changes are in bold, as follows:</p>
<pre>// app.component.ts - adding the capability to add users<br/><br/>import<span> { Component } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { AppState } </span><span>from</span><span> </span><span>"./app-state"</span><span>;<br/></span>import<span> { Store } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { map } </span><span>from</span><span> </span><span>"rxjs/operators"</span><span>;<br/><br/></span>@Component({<br/>selector: <span>"app-root"</span><span>,<br/></span>template: <span>`<br/></span>  &lt;<span>div</span><span> </span><span>style</span><span>=</span><span>"border: solid 1px black; padding: 10px;"</span><span> <br/></span><span>       *ngFor</span><span>=</span><span>"let user of users$ | async"</span><span>&gt;<br/></span>    {{ user.name }}<br/>  &lt;/<span>div</span><span>&gt;<br/></span>  <strong>&lt;div&gt;<br/>    &lt;input [(ngModel)]="user" /&gt; &lt;button (click)="add()"&gt;Add&lt;/button&gt;<br/>  &lt;/div</strong><span><strong>&gt;</strong><br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> AppComponent {<br/></span>  title <span>=</span><span> </span><span>"app"</span><span>;<br/></span>  users$;<br/>  <strong>user;</strong><br/><strong>  id = 1</strong><span><strong>;</strong><br/></span><br/>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.users$ </span><span>=</span><span> </span><span>this</span><span>.store<br/>      .select(state </span><span>=&gt;</span><span> state.users.entities)<br/></span>      .pipe(map(this.toArray));<br/>    this<span>.users$.subscribe(data </span><span>=&gt;</span><span> console.log(</span><span>"users"</span><span>, data));<br/></span>  }<br/><br/>  toArray(obj) {<br/>    const<span> keys </span><span>=</span><span> Object.keys(obj); <br/></span>    return<span> keys.map(key </span><span>=&gt;</span><span> obj[key]);<br/></span>  }<br/><br/> <strong> add() {</strong><br/><strong>    const newUser = { id: this.id++, name: this.user };<br/>    this.store.dispatch({<br/>      type: "ADD_USER",<br/>      payload: newUser</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}</pre>
<p>This code demonstrates how we add an input element and <span>connect</span> that to the field   <kbd>user</kbd>   on our class through <kbd>ngModel</kbd>. We also added the <kbd>add()</kbd> <span>method </span><span>that dispatches a user to our reducer. Adding a user should now look like the following in the UI:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/26348501-a729-444c-a0da-2bac9b6bcf29.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating users</h1>
                </header>
            
            <article>
                
<p>There are two things we need to do to support updating users:</p>
<ul>
<li>Add a component that supports updating</li>
<li>Adding a CASE to our reducer that listens to an action and calls the appropriate <kbd>adapter</kbd> method</li>
</ul>
<p>Let's start with our component:</p>
<pre>// edit-user.component.ts<br/><br/>import<span> { <br/>  Component, <br/>  OnInit, <br/>  Output, <br/>  Input, <br/>  EventEmitter <br/>} </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span><br/>@Component({<br/>  selector: <span>"edit-user"</span><span>,<br/></span>  template: <span>`<br/></span>  &lt;<span>div</span><span>&gt;<br/></span>    &lt;<span>input</span><span> </span><span>[(ngModel)]</span><span>=</span><span>"</span><span>user.name</span><span>"</span><span> </span><span>/&gt;<br/></span>    &lt;<span>button</span><span> </span><strong>(click)="save.emit(user)"</strong><span> </span><span>&gt;</span><span>Save</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>  &lt;/<span>div</span><span>&gt;<br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> EditUserComponent </span><span>implements</span><span> OnInit {<br/></span>  private<span> _user;<br/></span><br/>  <strong>@Input()</strong><br/><strong>  get user() {<br/>    return this._user;<br/>  }</strong><br/><br/> <strong> set user(val) {<br/>    this._user = Object.assign({}, val);<br/>  }</strong><br/><br/>  <strong>@Output() save = new</strong><span><strong> EventEmitter();</strong><br/><br/></span>  constructor<span>() {}<br/></span>  ngOnInit() {}<br/>}</pre>
<p>Here, we have a component that takes a <kbd>user</kbd> as input and is able to invoke a <kbd>save</kbd> as output thereby calling the parent component. In short, this component allows us to edit a user.</p>
<p>Now we need to add this component to <kbd>app.module.ts</kbd> so that other components within this module can use it:</p>
<pre>// excerpt from app.module.ts<br/><br/>@NgModule({<br/>  declarations: [AppComponent, <strong>EditUserComponent</strong><span>],<br/></span>  imports: [<br/>    BrowserModule,<br/>    FormsModule,<br/>    StoreModule.forRoot({<br/>      users: userReducer<br/>  })],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})<br/>export<span> </span><span>class</span><span> AppModule {}</span></pre>
<p>Now we are ready to add the component to the parent components template, like so:</p>
<pre>// app.component.ts - adding EditUserComponent to the markup<br/><br/>import<span> { Component } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { AppState } </span><span>from</span><span> </span><span>"./app-state"</span><span>;<br/></span>import<span> { Store } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { map } </span><span>from</span><span> </span><span>"rxjs/operators"</span><span>;<br/><br/></span>@Component({<br/>  selector: <span>"app-root"</span><span>,<br/></span>  template: <span>`<br/></span>    &lt;<span>div</span><span> </span><span>style</span><span>=</span><span>"border: solid 1px black; padding: 10px;"</span><span> <br/></span><span>         *ngFor</span><span>=</span><span>"let user of users$ | async"</span><span>&gt;<br/></span>      {{ user.name }}<br/>      <strong>&lt;edit-user [user]="user" (save)="update($event)" &gt;&lt;/edit-user</strong><span><strong>&gt;</strong><br/></span>    &lt;/<span>div</span><span>&gt;<br/></span>    &lt;<span>div</span><span>&gt;<br/></span>      &lt;<span>input</span><span> </span><span>[(ngModel)]</span><span>=</span><span>"</span><span>user</span><span>"</span><span> </span><span>/&gt;</span><span> </span><span>&lt;</span><span>button</span><span> </span><span>(click)</span><span>=</span><span>"</span><span>add()</span><span>"</span><span>&gt;</span><span>Add</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>    &lt;/<span>div</span><span>&gt;<br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> AppComponent {<br/></span>  title <span>=</span><span> </span><span>"app"</span><span>;<br/></span>  users$;<br/>  user;<br/>  id <span>=</span><span> </span><span>1</span><span>;<br/></span><br/>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.users$ </span><span>=</span><span> </span><span>this</span><span>.store<br/></span>      .select(state <span>=&gt;</span><span> state.users.entities)<br/></span>      .pipe(map(<span>this</span><span>.toArray));<br/></span>    this<span>.users$.subscribe(data </span><span>=&gt;</span><span> console.log(</span><span>"users"</span><span>, data));<br/></span>  }<br/><br/>  toArray(obj) {<br/>    const<span> keys </span><span>=</span><span> Object.keys(obj);<br/></span>    return<span> keys.map(key </span><span>=&gt;</span><span> obj[key]);<br/></span>  }<br/><br/>  add() {<br/>    const<span> newUser </span><span>=</span><span> { id: </span><span>this</span><span>.id</span><span>++</span><span>, name: </span><span>this</span><span>.user };<br/></span>    this<span>.store.dispatch({<br/></span>      type: <span>"ADD_USER"</span><span>,<br/></span>      payload: newUser<br/>    });<br/>  }<br/><br/><strong>  update(user) {</strong><br/><strong>    console.log("updating", user);<br/>    this.store.dispatch({ type: "UPDATE_USER", payload: user });<br/>  }</strong><br/>}</pre>
<p>This code shows us how we add the <kbd>EditUserComponent</kbd> to the markup, as well as us adding the <kbd>update()</kbd> method that, when invoked, dispatches the action <kbd>UPDATE_USER</kbd>. This will lead to our reducer being invoked which leads us to our final piece of the puzzle, the required changes we need to make to the reducer:</p>
<pre>// excerpt from app.module.ts<br/><br/>function<span> userReducer(state </span><span>=</span><span> initial, action</span><span>:</span><span> ActionPayload&lt;User&gt;)</span><span>:</span><span> State {<br/></span>  switch<span> (action.type) {<br/></span>    case<span> </span><span>"ADD_USER"</span><span>:<br/></span>      return<span> userAdapter.addOne(action.payload, state);</span><span><br/></span><strong>    case "UPDATE_USER":<br/>      return userAdapter.updateOne({</strong><br/><strong>        id: action.payload.id,</strong><br/><strong>        changes: action.payload</strong><br/><strong>      },</strong><br/><strong>      state</strong><br/><strong>    );</strong><br/>    default<span>:<br/></span>      return<span> state;<br/></span>   }<br/>}</pre>
<p>We now support the ability to update our users list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting users</h1>
                </header>
            
            <article>
                
<p>The last piece of supporting CRUD is the ability to remove users from the list. This case is very similar to all the other cases:</p>
<ul>
<li>We need to add support for it to <kbd>app.component.ts</kbd></li>
<li>We need to update the reducer, and the reducer needs to call the appropriate adapter method</li>
</ul>
<p>Let's start with the component and add support in the markup, as well as adding a <kbd>remove()</kbd> method  to the component class, like so:</p>
<pre>// app.component.ts - adding remove capability<br/><br/>import<span> { Component } </span><span>from</span><span> </span><span>"@angular/core"</span><span>;<br/></span>import<span> { AppState } </span><span>from</span><span> </span><span>"./app-state"</span><span>;<br/></span>import<span> { Store } </span><span>from</span><span> </span><span>"@ngrx/store"</span><span>;<br/></span>import<span> { map } </span><span>from</span><span> </span><span>"rxjs/operators"</span><span>;<br/><br/></span>@Component({<br/>  selector: <span>"app-root"</span><span>,<br/></span>  template: <span>`<br/></span>  &lt;<span>div</span><span> </span><span>style</span><span>=</span><span>"border: solid 1px black; padding: 10px;"</span><span> <br/></span><span>       *ngFor</span><span>=</span><span>"let user of users$ | async"</span><span>&gt;<br/></span>    {{ user.name }}<br/>   <strong> &lt;button (click)="remove(user.id)" &gt;Remove&lt;/button</strong><span><strong>&gt;</strong><br/></span>    &lt;<span>edit-user</span><span> </span><span>[user]</span><span>=</span><span>"</span><span>user</span><span>"</span><span> </span><span>(save)</span><span>=</span><span>"</span><span>update($event)</span><span>"</span><span> </span><span>&gt;&lt;/</span><span>edit-user</span><span>&gt;<br/></span>  &lt;/<span>div</span><span>&gt;<br/></span>  &lt;<span>div</span><span>&gt;<br/></span>    &lt;<span>input</span><span> </span><span>[(ngModel)]</span><span>=</span><span>"</span><span>user</span><span>"</span><span> </span><span>/&gt;</span><span> </span><span>&lt;</span><span>button</span><span> </span><span>(click)</span><span>=</span><span>"</span><span>add()</span><span>"</span><span>&gt;</span><span>Add</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>  &lt;/<span>div</span><span>&gt;<br/></span>`<br/>})<br/>export<span> </span><span>class</span><span> AppComponent {<br/></span>  title <span>=</span><span> </span><span>"app"</span><span>;<br/></span>  users$;<br/>  user;<br/>  id <span>=</span><span> </span><span>1</span><span>;<br/></span><br/>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.users$ </span><span>=</span><span> </span><span>this</span><span>.store<br/></span>      .select(state <span>=&gt;</span><span> state.users.entities)<br/></span>      .pipe(map(<span>this</span><span>.toArray));<br/></span>    <br/>    this<span>.users$.subscribe(data </span><span>=&gt;</span><span> console.log(</span><span>"users"</span><span>, data));<br/></span>  }<br/><br/>  toArray(obj) {<br/>    const<span> keys </span><span>=</span><span> Object.keys(obj);<br/></span>    return<span> keys.map(key </span><span>=&gt;</span><span> obj[key]);<br/></span>  }<br/><br/>  add() {<br/>    const<span> newUser </span><span>=</span><span> { id: </span><span>this</span><span>.id</span><span>++</span><span>, name: </span><span>this</span><span>.user };<br/></span>    this<span>.store.dispatch({<br/></span>      type: <span>"ADD_USER"</span><span>,<br/></span>      payload: newUser<br/>    });<br/>  }<br/><br/><strong>  remove(id) {</strong><br/><strong>    console.log("removing", id);<br/>    this.store.dispatch({ type: "REMOVE_USER", payload: { id } });<br/>  }</strong><br/><br/>  update(user) {<br/>    console.log(<span>"updating"</span><span>, user);<br/></span>    this<span>.store.dispatch({ type: </span><span>"UPDATE_USER"</span><span>, payload: user });<br/></span>  }<br/>}</pre>
<p>The remaining part is updating our reducer to say the following:</p>
<pre>// excerpt from app.module.ts<br/><br/>function<span> userReducer(state </span><span>=</span><span> initial, action</span><span>:</span><span> ActionPayload&lt;User&gt;)</span><span>:</span><span> State {<br/></span>  switch<span> (action.type) {<br/></span>    case<span> </span><span>"ADD_USER"</span><span>:<br/></span>      return<span> userAdapter.addOne(action.payload, state);<br/></span>    <strong>case "REMOVE_USER":<br/>      return</strong><span><strong> userAdapter.removeOne(action.payload.id, state);</strong><br/></span>    case<span> </span><span>"UPDATE_USER"</span><span>:<br/></span>      return<span> userAdapter.updateOne(<br/></span>       {<br/>          id: action.payload.id,<br/>          changes: action.payload<br/>       },<br/>       state<br/>     );<br/>    default<span>:<br/></span>      return<span> state;\<br/></span>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@ngrx/router-store</h1>
                </header>
            
            <article>
                
<p>We want to be able to trace where we are in the application—<em>where—</em>is represented by our route, route parameters, as well as by query parameters. By saving <span>where we are,</span> down to our store, we are able to easily serialize <span>the stores information</span> to a storage for later retrieval and deserialization, which means we can re-instate the app with not only the state, but also our page location.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation and set up</h1>
                </header>
            
            <article>
                
<p>The router store is in an NPM package and we can therefore type the following to install it:</p>
<pre><strong>npm install @ngrx/router-store --save</strong></pre>
<p>The next thing we need to do is to import the correct modules and set those up in the <kbd>import</kbd> properties of our root module, like so:</p>
<pre>import<span> { BrowserModule } </span><span>from</span><span> </span><span>'@angular/platform-browser'</span><span>;<br/></span>import<span> { NgModule, Injectable } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import<span> { StoreModule, Action } </span><span>from</span><span> </span><span>'@ngrx/store'</span><span>;<br/></span>import<span> { AppComponent } </span><span>from</span><span> </span><span>'./app.component'</span><span>;<br/></span>import<span> { counterReducer } </span><span>from</span><span> </span><span>'./reducer'</span><span>;<br/></span>import<span> { TodoModule } </span><span>from</span><span> </span><span>'./todo/todo.module'</span><span>;<br/></span>import<span> { todosReducer } </span><span>from</span><span> </span><span>'./todo/reducer'</span><span>;<br/></span>import<span> { JediModule } </span><span>from</span><span> </span><span>'./jedi/jedi.module'</span><span>;<br/></span>import<span> { jediListReducer } </span><span>from</span><span> </span><span>'./jedi/list.reducer'</span><span>;<br/></span>import<span> { productsReducer } </span><span>from</span><span> </span><span>'./products/products.reducer'</span><span>;<br/></span><strong>import { StoreDevtoolsModule } from '@ngrx/store-devtools'</strong><span><strong>;</strong><br/></span>import<span> { ProductsModule } </span><span>from</span><span> </span><span>'./products/products.module'</span><span>;<br/></span><strong>import { StoreRouterConnectingModule, routerReducer } from '@ngrx/router-store'</strong><span><strong>;</strong><br/></span>import<span> { RouterModule } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/></span>import<span> { TestingComponent } </span><span>from</span><span> </span><span>'./testing.component'</span><span>;<br/></span>import<span> { Effect, ofType, Actions } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/></span>import<span> { Observable } </span><span>from</span><span> </span><span>'rxjs/Observable'</span><span>;<br/></span>import<span> { switchMap } </span><span>from</span><span> </span><span>'rxjs/operators'</span><span>;<br/></span>import<span> { of } </span><span>from</span><span> </span><span>'rxjs/observable/of'</span><span>;<br/></span>import<span> { EffectsModule } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/><br/></span>@NgModule({<br/>  declarations: [AppComponent, TestingComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({<br/>      count: counterReducer,<br/>      todos: todosReducer,<br/>      jediList: jediListReducer,<br/>      products: productsReducer,<br/>      <strong>router: routerReducer</strong><br/>    }),<br/>    EffectsModule.forRoot([]),<br/>    RouterModule.forRoot([{ path: <span>'testing'</span><span>, component: TestingComponent }]),<br/></span><strong>    StoreRouterConnectingModule.forRoot({</strong><br/><strong>      stateKey: 'router' // name of reducer key<br/>    }),</strong><br/>    StoreDevtoolsModule.instrument({<br/>      maxAge: <span>25</span><span> </span><span>// Retains last 25 states<br/></span>    }),<br/>    TodoModule,<br/>    JediModule,<br/>    ProductsModule<br/>  ],<br/>  bootstrap: [AppComponent]<br/>})<br/>export<span> </span><span>class</span><span> AppModule {}</span></pre>
<p>We don't do a lot here. We call the <kbd>forRoot()</kbd> method on the <kbd>StoreRouterConnectingModule,</kbd> and we also add a new reducer entry in the form of a router that points to <kbd>routerReducer</kbd> as the reducer that will handle any changes to the<span> </span><kbd>router</kbd> property. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Investigating the router state</h1>
                </header>
            
            <article>
                
<p>We have just set up the router store. This means that we automatically write to a property <kbd>router</kbd> in our store every time we navigate. We can prove this is the case by editing the <kbd>app.component.ts</kbd> to subscribe to that slice of state:</p>
<pre>import<span> { Component } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import<span> { Store } </span><span>from</span><span> </span><span>'@ngrx/store'</span><span>;<br/></span>import<span> { Observable } </span><span>from</span><span> </span><span>'rxjs/Observable'</span><span>;<br/></span>import<span> { Increment, Decrement } </span><span>from</span><span> </span><span>'./actions'</span><span>;<br/></span>import<span> { AppState } </span><span>from</span><span> </span><span>'./app-state'</span><span>;<br/></span><br/>@Component({<br/>  selector: <span>'app-root'</span><span>,<br/></span>  template: <span>`<br/></span>    {{ count$ <span>|</span><span> async }}<br/></span>    &lt;<span>button</span><span> </span><span>(click)</span><span>=</span><span>"</span><span>increment()</span><span>"</span><span>&gt;</span><span>Increment</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>    &lt;<span>button</span><span> </span><span>(click)</span><span>=</span><span>"</span><span>decrement()</span><span>"</span><span>&gt;</span><span>Decrement</span><span>&lt;/</span><span>button</span><span>&gt;<br/></span>    &lt;<span>app-todos</span><span>&gt;&lt;/</span><span>app-todos</span><span>&gt;<br/></span>    &lt;<span>jedi-list</span><span>&gt;&lt;/</span><span>jedi-list</span><span>&gt;</span><span><br/></span>    &lt;<span>div</span><span>&gt;<br/></span>      &lt;<span>a</span><span> </span><span>routerLink</span><span>=</span><span>"/testing"</span><span> </span><span>routerLinkActive</span><span>=</span><span>"active"</span><span>&gt;</span><span>Testing</span><span>&lt;/</span><span>a</span><span>&gt;<br/></span>    &lt;/<span>div</span><span>&gt;<br/></span>    &lt;<span>router-outlet</span><span>&gt;&lt;/</span><span>router-outlet</span><span>&gt;</span>`<span>,<br/></span>  styleUrls: [<span>'./app.component.css'</span><span>]<br/></span>})<br/>export<span> </span><span>class</span><span> AppComponent {<br/></span>  count$<span>:</span><span> Observable&lt;number&gt;;<br/></span><br/>  constructor<span>(</span><span>private</span><span> store</span><span>:</span><span> Store&lt;AppState&gt;) {<br/></span>    this<span>.count$ </span><span>=</span><span> store.select(</span><span>'count'</span><span>);<br/></span>    <strong>store</strong><br/><strong>      .select(state =&gt; state.router)<br/>      .subscribe(route =&gt; console.log('router obj'</strong><span><strong>, route));</strong><br/></span>  }<br/><br/>  increment() {<br/>    this<span>.store.dispatch(Increment());<br/></span>  }<br/><br/>  decrement() {<br/>    this<span>.store.dispatch(Decrement());<br/></span>  }<br/>}</pre>
<p>Here, we subscribe to the state router and thereby listen to every time the route changes. We log the said object and it looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6151db2f-b7b4-45af-bd21-0a905f2781a4.png"/></div>
<p>This screenshot shows us the object our router state now contains. We can see the <kbd>url</kbd> property points to <kbd>/</kbd> which means our default route has been loaded. We can also see that this object contains router parameters and query parameters in the <kbd>root</kbd> property. So, there is some interesting information in there. </p>
<p>Let's see what happens when we route somewhere like <kbd>/testing</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ba557ce4-7997-478e-9e72-a55d3c850f25.png" style=""/></div>
<p>Our router state has been updated and we can see that our <kbd>url</kbd> property points to <kbd>/testing</kbd>. </p>
<p>So far, we have subscribed to the router state and listened to when the route is changing. There is a second way. We could be listening to when a specific action is being dispatched. The action being dispatched for routing is the string <kbd>ROUTER_NAVIGATION</kbd>. We can therefore easily build an effect for this so we can carry out side effects when the route changes. We may want to carry out AJAX requests or store things in a local cache. Only you know what you want to do. Let's build that effect. We will return back to an existing file, <kbd>routing.effects.ts</kbd>, and extend it:</p>
<pre>import<span> { Injectable } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import<span> { Effect, Actions, ofType } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/></span>import<span> { Router } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/></span>import<span> { map, tap, switchMap } </span><span>from</span><span> </span><span>'rxjs/operators'</span><span>;<br/></span>import<span> { Action } </span><span>from</span><span> </span><span>'@ngrx/store'</span><span>;<br/></span>import<span> { PRODUCTS, RoutingAction } </span><span>from</span><span> </span><span>'./routing.constants'</span><span>;<br/></span>import<span> { Observable } </span><span>from</span><span> </span><span>'rxjs/Observable'</span><span>;<br/></span><br/>@Injectable()<br/>export<span> </span><span>class</span><span> RoutingEffects {<br/></span>  @Effect({ dispatch: <span>false</span><span> })<br/></span>  gotoProducts$ <span>=</span><span> </span><span>this</span><span>.actions$.ofType(PRODUCTS).pipe(<br/></span>    tap(action <span>=&gt;</span><span> {<br/></span>      this<span>.router.navigate([action.payload.url]);<br/></span>    })<br/>  );<br/><br/>  <strong>@Effect({ dispatch: false })<br/>  locationUpdate$: Observable&lt;Action&gt; = <br/>    this.actions$.ofType('ROUTER_NAVIGATION').pipe(<br/>      tap((action: any) =&gt; {<br/>        console.log('router navigation effect', action);<br/>      })</strong><br/><strong>  );</strong><br/><br/>  constructor<span>(<br/></span><span>    private</span><span> router</span><span>:</span><span> Router, <br/></span><span>    private</span><span> actions$</span><span>:</span><span> Actions&lt;RoutingAction&gt;) {}<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom serialization</h1>
                </header>
            
            <article>
                
<p>The object being stored is a bit verbose though. It contains a lot of information and we may only be interested in parts of it. We can actually solve that by building our own custom serializer. We need to do the following to accomplish that:</p>
<ul>
<li>Create a class that implements the interface <kbd>RouterStateSerializer</kbd> and decide what we want to return</li>
<li>Replace the router key <kbd>RouterStateSerializer</kbd> with our custom implementation</li>
</ul>
<p>Let's begin. We first create a class, like so:</p>
<pre>// my-serializer.ts<br/><br/>import<span> { RouterStateSerializer } </span><span>from</span><span> </span><span>'@ngrx/router-store'</span><span>;<br/></span>import<span> { RouterStateSnapshot } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/><br/></span>interface<span> MyState {<br/></span>  url<span>:</span><span> string;<br/></span>}<br/><br/>export<span> </span><span>class</span><span> MySerializer </span><span>implements</span><span> RouterStateSerializer&lt;MyState&gt; {<br/></span>  serialize(routerState<span>:</span><span> RouterStateSnapshot)</span><span>:</span><span> MyState {<br/></span>    return<span> &lt;MyState&gt;{};<br/></span>    // todo: implement<br/>  }<br/>}</pre>
<p>The <kbd>RouterStateSeralizer</kbd> interface forces us to specify a <kbd>type T</kbd>, which could be anything. <kbd>T</kbd> is what we want to return from the routing object. Remember the reason for doing what we are doing is to grab a subset of interesting information from the routing object. The full routing information is contained within our input parameter <kbd>routerState</kbd> that is of type <kbd>RouterStateSnapshot</kbd>. A comment though is that <kbd>MyState</kbd> is a bit anemic, as it only contains a single property, <kbd>url</kbd>. You can of course extend this according to the needs of your application. You most likely want to grab the <kbd>router</kbd> and <kbd>query</kbd> parameters. We will grab those as well before we are done with this section but let's start with this to showcase how it works. The next step is to grab the data from the <kbd>routerState</kbd> parameter. For now, we dig out the <kbd>url</kbd>—let's update the code to reflect that:</p>
<pre>// my-serializer.ts<br/>import<span> { RouterStateSerializer } </span><span>from</span><span> </span><span>'@ngrx/router-store'</span><span>;<br/></span>import<span> { RouterStateSnapshot } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/><br/></span>interface<span> MyState {<br/></span>  url<span>:</span><span> string;<br/></span>}<br/><br/>export<span> </span><span>class</span><span> MySerializer </span><span>implements</span><span> RouterStateSerializer&lt;MyState&gt; {<br/></span>  serialize(routerState<span>:</span><span> RouterStateSnapshot)</span><span>:</span><span> MyState {<br/></span>    <strong>const { url } = routerState;<br/>    return</strong><span><strong> { url };</strong><br/></span>  }<br/>}</pre>
<p>Let's now tell the provider to use our implementation instead. We need to go to the <kbd>app.module.ts</kbd> file:</p>
<pre>import<span> { BrowserModule } </span><span>from</span><span> </span><span>'@angular/platform-browser'</span><span>;<br/></span>import<span> { NgModule, Injectable } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import<span> { StoreModule, Action } </span><span>from</span><span> </span><span>'@ngrx/store'</span><span>;<br/></span>import<span> { AppComponent } </span><span>from</span><span> </span><span>'./app.component'</span><span>;<br/></span>import<span> { counterReducer } </span><span>from</span><span> </span><span>'./reducer'</span><span>;<br/></span>import<span> { TodoModule } </span><span>from</span><span> </span><span>'./todo/todo.module'</span><span>;<br/></span>import<span> { todosReducer } </span><span>from</span><span> </span><span>'./todo/reducer'</span><span>;<br/></span>import<span> { JediModule } </span><span>from</span><span> </span><span>'./jedi/jedi.module'</span><span>;<br/></span>import<span> { jediListReducer } </span><span>from</span><span> </span><span>'./jedi/list.reducer'</span><span>;<br/></span>import<span> { productsReducer } </span><span>from</span><span> </span><span>'./products/products.reducer'</span><span>;<br/></span>import<span> { StoreDevtoolsModule } </span><span>from</span><span> </span><span>'@ngrx/store-devtools'</span><span>;<br/></span>import<span> { ProductsModule } </span><span>from</span><span> </span><span>'./products/products.module'</span><span>;<br/></span>import<span> { StoreRouterConnectingModule, routerReducer, <strong>RouterStateSerializer</strong> } </span><span>from</span><span> </span><span>'@ngrx/router-store'</span><span>;<br/></span>import<span> { RouterModule } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/></span>import<span> { TestingComponent } </span><span>from</span><span> </span><span>'./testing.component'</span><span>;<br/></span>import<span> { Effect, ofType, Actions } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/></span>import<span> { Observable } </span><span>from</span><span> </span><span>'rxjs/Observable'</span><span>;<br/></span>import<span> { switchMap } </span><span>from</span><span> </span><span>'rxjs/operators'</span><span>;<br/></span>import<span> { of } </span><span>from</span><span> </span><span>'rxjs/observable/of'</span><span>;<br/></span>import<span> { EffectsModule } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/></span>import<span> { RoutingEffects } </span><span>from</span><span> </span><span>'./routing.effects'</span><span>;<br/></span>import<span> { ProductsTestComponent } </span><span>from</span><span> </span><span>'./productstest.component'</span><span>;<br/></span><strong>import { MySerializer } from './my-serializer'</strong><span><strong>;</strong><br/><br/></span>@NgModule({<br/>  declarations: [AppComponent, TestingComponent, ProductsTestComponent],<br/>  imports: [<br/>    BrowserModule,<br/>    StoreModule.forRoot({<br/>      count: counterReducer,<br/>      todos: todosReducer,<br/>      jediList: jediListReducer,<br/>      products: productsReducer,<br/>      router: routerReducer}),<br/>    EffectsModule.forRoot([RoutingEffects]),<br/>    RouterModule.forRoot([<br/>      { path: <span>'testing'</span><span>, component: TestingComponent },<br/></span>      { path: <span>'products'</span><span>, </span>component: ProductsTestComponent }<br/>    ]),<br/>    StoreRouterConnectingModule.forRoot({<br/>      stateKey: <span>'router'</span><span> </span><span>// name of reducer key<br/></span>    }),<br/>    StoreDevtoolsModule.instrument({<br/>      maxAge: <span>25</span><span> </span><span>// Retains last 25 states<br/></span>    }),<br/>    TodoModule,<br/>    JediModule,<br/>    ProductsModule<br/>  ],<br/>  <strong>providers: [{ provide: RouterStateSerializer, useClass: MySerializer }],</strong><br/>  bootstrap: [AppComponent]<br/>})<br/>export<span> </span><span>class</span><span> AppModule {}</span></pre>
<p>We have now imported the <kbd>MySerializer</kbd> class and the <kbd>RouterStateSeralizer</kbd> interface and we are replacing the provider key using the following line:</p>
<pre>providers: [{ provide: RouterStateSerializer, useClass: MySerializer }]</pre>
<p>Now it's time to take this for a spin. So, we fire up the app and see what happens if we navigate around in the app. Here is a quick reminder of what our app looks like right now:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87df3b0a-3fc4-4f79-9a26-abe98e9ddcbf.png" style=""/></div>
<p>Clicking either the <span class="packt_screen">Testing</span> or <span class="packt_screen">Products</span> link will take us to <kbd>/testing</kbd> or <kbd>/products,</kbd> respectively. Let's do just that and see what that looks like. We have a look at the console and lo and, behold! Our router object is considerably smaller:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/72311ccd-62ff-4d7c-95de-5a4b4748fa1a.png" style=""/></div>
<p>Our object now contains pretty much only the <kbd>url</kbd> property. This is what gets stored down in the state of our application. If we want more things stored than that, then we can easily extend the <kbd>MySerializer</kbd> class—suggested additions are router and query parameters. Let's make the following alterations to the <kbd>MySerializer</kbd> class:</p>
<pre>// my-serializer.ts<br/>import<span> { RouterStateSerializer } </span><span>from</span><span> </span><span>'@ngrx/router-store'</span><span>;<br/></span>import<span> { RouterStateSnapshot } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/></span><br/>interface<span> MyState {<br/></span>  url<span>:</span><span> string;<br/></span><strong>  queryParams;</strong><br/>}<br/><br/>export<span> </span><span>class</span><span> MySerializer </span><span>implements</span><span> RouterStateSerializer&lt;MyState&gt; {<br/></span>  serialize(routerState<span>:</span><span> RouterStateSnapshot)</span><span>:</span><span> MyState {</span><span><br/></span>  <strong>  const { url, root: { queryParams } } = routerState;<br/>    return</strong><span><strong> { url, queryParams };</strong><br/></span>  }<br/>}</pre>
<p>Navigating to <kbd>http://localhost:4200/products?page=1</kbd> will now produce the following in the console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77337137-0f5a-4c76-88c0-c6d7ba03b73c.png" style=""/></div>
<p>The difference is now that we have a <kbd>queryParams</kbd> property, which points to an object with content<span> </span><kbd>{ page: 1 }</kbd>. This is what we expected. Digging out the router parameters is equally easy. But for us to have router parameters that are populated in the first place, we need to have a route with a routing parameter. Instead of <kbd>/products,</kbd> we need something such as <kbd>products/:id</kbd>. Let's start by adding that to our list of routes: </p>
<pre>// products/products.module.ts<br/><br/>import<span> { NgModule } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import<span> { BrowserModule } </span><span>from</span><span> </span><span>'@angular/platform-browser'</span><span>;<br/></span>import<span> { EffectsModule } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/></span>import<span> { ProductEffects } </span><span>from</span><span> </span><span>'./products.effect'</span><span>;<br/></span>import<span> { HttpClientModule } </span><span>from</span><span> </span><span>'@angular/common/http'</span><span>;<br/></span>import<span> { ProductsComponent } </span><span>from</span><span> </span><span>'./products.component'</span><span>;<br/></span>import<span> { FormsModule } </span><span>from</span><span> </span><span>'@angular/forms'</span><span>;<br/></span>import<span> { ProductsHttpActions } </span><span>from</span><span> </span><span>'./products-http.actions'</span><span>;<br/></span>import<span> { RouterModule } </span><span>from</span><span> </span><span>'@angular/router'</span><span>;<br/></span><strong>import { ProductsDetailComponent } from './products-detail.component'</strong><span><strong>;</strong><br/><br/></span>@NgModule({<br/>  imports: [<br/>    BrowserModule,<br/>    HttpClientModule,<br/>    FormsModule,<br/>    EffectsModule.forFeature([ProductEffects]),<br/>    RouterModule.forChild([{<br/>      path: <span>'products'</span><span>,<br/></span>      component: ProductsComponent<br/>    }, <strong>{</strong><br/><strong>      path: 'products/:id',<br/>      component: ProductsDetailComponent</strong><br/><strong>    }</strong>])<br/>  ],<br/>  exports: [ProductsComponent],<br/>  declarations: [ProductsComponent, <strong>ProductsDetailComponent</strong>],<br/>  providers: [ProductsHttpActions]<br/>})<br/>export<span> </span><span>class</span><span> ProductsModule {}</span></pre>
<p>And we of course need to add a component. It does nothing special other than exist for our demo purposes. Remember the emphasis is on understanding the serialization process:</p>
<pre>// products-detail.component.ts<br/><br/>import<span> { Component, OnInit } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span><br/>@Component({<br/>selector: <span>'app-products-detail'</span><span>,<br/></span>  template: <span>`<br/></span>  products detail<br/>`<br/>})<br/>export<span> </span><span>class</span><span> ProductsDetailComponent{<br/></span>  constructor<span>() {}<br/></span>}<span><br/></span></pre>
<p>At this point, it's time to return back to our browser and enter the <kbd>url</kbd>,  <kbd>products/1?page=1</kbd>. Let's have a look at the console now:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/69e1890f-dd94-4e31-839f-bf2507ed448c.png" style=""/></div>
<p>Here, we see how our <kbd>params</kbd> property has been added to our custom object. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating through dispatch</h1>
                </header>
            
            <article>
                
<p>Now that we have our router store properly set up, we can actually start thinking in terms of dispatching actions, even for routes. OK, what does that mean? Well, imagine we are thinking more and more in dispatching actions; it makes our world simpler. When you dispatch an action, an HTTP call happens, and, in dispatching an action, the application routes you where you want to go.</p>
<p>This isn't really a feature of the router store, but a way you can look at it. A way to implement this is by writing your own effect that responds to a route action, and, as a result, you call the router service and perform the navigation. Let's summarize what we just said in a bullet list and carry out the resulting steps:</p>
<ol>
<li>Set up some routing constants.</li>
<li>Set up some routing actions.</li>
<li>Write an effect that listens to routing actions and performs routing inside of the effect.</li>
</ol>
<p>Here is Step 1:</p>
<pre>// routing-constants.ts<br/>export const PRODUCTS = 'Navigation products';<br/>export const TODOS = 'Navigation todos';<br/><br/>export interface RoutingAction implements Action {<br/>  type: string;<br/>  payload: { url: string, query: { page: number } ;}<br/>}</pre>
<p>OK, our next step is to define a set of action creators so we can set off a certain behavior when a specific action occurs:</p>
<pre>// router-actions.ts<br/>import { PRODUCTS, TODOS } from './routing-constants';<br/><br/>export const gotoProducts = (pageNo) =&gt; ({ <br/>  type: PRODUCTS, <br/>  payload: { url: '/products', query: { page: pageNo } } <br/>});<br/><br/>export const gotoTodo = (pageNo) =&gt; ({<br/>  type: TODOS,<br/>  payload: { url: '/todos', query: { page: pageNo } }<br/>})</pre>
<p>Our next step is our effect, which would now be able to respond to the preceding actions:</p>
<pre>// routing-effects.ts<br/>import { PRODUCTS, TODOS } from './routing-constants';<br/>import { gotoProducts, gotoTodo }<br/><br/>export class RoutingEffects {<br/>  @Effect({ dispatch: false }) routingProducts$ = this.actions$<br/>  .ofType(PRODUCTS)<br/>  .tap(action =&gt; {<br/>    this.router.navigate('/products')  <br/>  })<br/><br/>  @Effect({ dispatch: false }) routingTodos$ = this.actions$<br/>  .ofType(TODOS)<br/>  .tap(action =&gt; {<br/>    this.router.navigate('/todos');<br/>  }) <br/>    <br/><br/>  constructor(<br/>    private router: Router,<br/>    private actions$: Actions) {<br/>  <br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding NgRx – building our own micro implementation</h1>
                </header>
            
            <article>
                
<p>We have done this experiment once before in <a href="e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml">Chapter 8</a>, <em>Redux</em>. The point was to gain a deeper understanding of what goes on behind the scenes. The difference between implementing Redux and implementing NgRx is the use of a library for publish/ subscribe, which is the way you choose to convey to a listener that a change has occurred. In our Redux implementation in <a href="e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml">Chapter 8</a>, <em>Redux</em>, we gave you the choice between implementing the Gang of Four publish-subscribe pattern without the help of a library, or using <kbd>EventEmitter</kbd> to achieve the same thing. In NgRx, that component is RxJS. So, let's crack on with the implementation. Before doing so, let's describe what we aim to implement:</p>
<ul>
<li>We aim to implement a store that holds a state</li>
<li>It should be possible to dispatch an action to said store so that its inner state changes</li>
<li>Any change to the store should go through a reducer</li>
<li>We will learn to handle side effects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a store</h1>
                </header>
            
            <article>
                
<p>A store at its heart is just a class wrapping a state. A store needs to be able to deal with changes;  the change should come via method dispatch. The following pseudo code represents what the store might look like:</p>
<pre>// NGRX-light/storeI.js<br/><br/>class Store {<br/>  constructor() {<br/>    this.state = {};<br/>  }<br/>  dispatch() {<br/>   // calculate the new state and replace the old one<br/>  }<br/>}</pre>
<p>We mentioned in the beginning of this main section that NgRx uses RxJS at its core. We mentioned that it was so the store could convey changes to its listeners. Let's mention the core concepts of RxJS that might fit the preceding problem description. In RxJS, we have:</p>
<ul>
<li><strong>Observable</strong>: It is able to emit values and you can attach subscribers to it</li>
<li><strong>Observer</strong>: This is the object that is called so that we end up getting the values as a subscriber</li>
<li><strong>Subscriber</strong>: This is a combination of an Observable and an Observer in that it can be subscribed to but it is also possible to add values to it after the subscription has happened.</li>
</ul>
<p>Thinking about the store for a bit, we realize we need to be able to add values to it at any point and we need to be able to subscribe to it. This seems to fit the behavior of the <kbd>Subject</kbd>. Let's continue our pseudo coding of the <kbd>Store</kbd> but let a <kbd>Subject</kbd> be part of it now:</p>
<pre>// NGRX-light/storeII.js<br/><br/>class Store {<br/>  constructor() {<br/>    this.state = {};<br/>  }<br/><br/>  dispatch(newState) {<br/>    <strong>this.state = newState;</strong><br/>  }<br/>}</pre>
<p>We implemented the <kbd>dispatch()</kbd> method with the following code: </p>
<pre>this.innerSubject.next(newState);</pre>
<p>For now, let's care about implementing subscription functionality. Let's imagine the store will be used in the following way:</p>
<pre>const store = new Store();<br/>store.subscribe(data =&gt; {<br/>  console.log('data', data);<br/>})</pre>
<p>For that to be possible, we could just add the <kbd>subscribe()</kbd> method to our store. If we were to do that ourselves, we would have to take care of a list of listeners and ensure listeners are told when a change happens to the state. A better option is to just let our store inherit from <kbd>Subject</kbd>. That would take care of the subscription bit. Let's see what that might look like:</p>
<pre>// NGRX-light/storeIII.js<br/><br/><strong>const Rx = require('rxjs'</strong><span><strong>);</strong><br/></span><br/>class<span> Store </span><strong>extends</strong><span><strong> Rx.Subject</strong> {<br/></span>  constructor<span>() {<br/></span>    super<span>();<br/></span>    this<span>.state </span><span>=</span><span> {};<br/></span>    <strong>this.subscribe(data =&gt; this.state =</strong><span><strong> data);</strong><br/></span>  }<br/><br/>  dispatch(newState) {<br/>    <strong>this</strong><span><strong>.next(newState);</strong><br/></span>  }<br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>store.subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store'</span><span>, data));<br/><br/></span>store.dispatch({});<br/>store.dispatch({ user: <span>'chris'</span><span> });<br/><br/>// store {}<br/>// store { user: 'chris' }</span></pre>
<p>The preceding code reimplements the <kbd>dispatch()</kbd> method and we also set up a subscription in the constructor to ensure our latest state is updated. There is a thing we need to improve here and that is how we add state to our store. With Redux, the incoming state change should be reduced into the old state, like so:</p>
<pre>const store = new Store();<br/>store.subscribe(data =&gt; console.log('store', data));<br/>// desired behavior:  store { name: 'chris' }<br/>// desired behavior: store { name: 'chris', address: 'London' }<br/><br/>store.dispatch({ name : 'chris' });<br/>store.dispatch({ address : 'London' });<br/> </pre>
<p>The way to achieve this is to refactor our code a little and create another <kbd>Subject</kbd> that will be the target of a call to dispatch, like so:</p>
<pre>// NGRX-light/storeIV.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>'rxjs'</span><span>);<br/></span><br/>class<span> Store </span><span>extends</span><span> Rx.Subject {<br/></span>  constructor<span>() {<br/></span>    super<span>();<br/></span>    <strong>this.dispatcher = new</strong><span><strong> Rx.Subject();</strong><br/></span>    this<span>.state </span><span>=</span><span> {};<br/></span>    <strong>this.dispatcher.subscribe(data =&gt; {<br/>      this.state = Object.assign({}, this.state, data);<br/>      this.next(this.state);<br/>    });</strong><br/>  }<br/><br/>  dispatch(newState) {<br/>    <strong>this</strong><span><strong>.dispatcher.next(newState);</strong><br/></span>  }<br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>store.subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store'</span><span>, data));<br/><br/>// store { name: 'chris' }<br/>// store { address: 'London' }<br/><br/></span>store.dispatch({ name: <span>'chris'</span><span> });<br/></span>store.dispatch({ address: <span>'London'</span><span> });</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merging the states in a better way</h1>
                </header>
            
            <article>
                
<p>In the preceding code, we used an <kbd>Object.assign()</kbd> to merge the old state with the new state. We can do this even better by using the <kbd>scan()</kbd> operator on our dispatcher member, like so:</p>
<pre>// NGRX-light/storeV.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>'rxjs'</span><span>);<br/></span><br/>class<span> Store </span><span>extends</span><span> Rx.Subject {<br/></span>  constructor<span>() {<br/></span>    super<span>();<br/></span>    this<span>.dispatcher </span><span>=</span><span> </span><span>new</span><span> Rx.Subject();</span><span><br/></span>    this<span>.dispatcher<br/></span>      <strong>.scan((acc, curr) =&gt; ({ ...acc, ...curr }))<br/>      .subscribe(data =&gt; this.next(data));</strong><br/>  }<br/><br/>  dispatch(newState) {<br/>    this<span>.dispatcher.next(newState);<br/></span>  }<br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>store.subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store'</span><span>, data));<br/><br/></span>store.dispatch({ name: <span>'chris'</span><span> });<br/></span>store.dispatch({ address: <span>'London'</span><span> });</span></pre>
<p>An important thing to note in the preceding code is that we removed the state member from the store. It's simply not needed as we only care about the latest value being emitted anyway. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a reducer and integrating it with the store</h1>
                </header>
            
            <article>
                
<p>An important concept of Redux is to guard who and what can affect your store. The <em>who</em> is reducers. By allowing only reducers to affect your store, we are more in control of what happens. A simple reducer is just a function that takes a state and action as parameters and is able to produce a new state based on the old state and existing state, like so:</p>
<pre>// example reducer<br/><br/>function<span> countReducer(state </span><span>=</span><span> </span><span>0</span><span>, action) {<br/></span>  switch<span>(action.type) {<br/></span>    case<span> </span><span>"INCREMENT"</span><span>:<br/></span>      return<span> state </span><span>+</span><span> </span><span>1</span><span>;<br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}<br/><br/>let state = countReducer(0, { type: "INCREMENT" });<br/>// 1<br/>state = countReducer(state, { type: "INCREMENT" });<br/>// 2<br/><br/></pre>
<p>So, where does a reducer come into the picture in Redux? Well, the state of the store is made up of an object, like so:</p>
<pre>{<br/>  counter: 1<br/>  products : []<br/>}</pre>
<p>The way a store goes about calculating the next state of a store is by creating a function that looks something like this:</p>
<pre>// calculate state<br/>function calcState(state, action) {<br/>  return {<br/>    counter: counterReducer(state.counter, action),<br/>    products: productsReducer(state.products, action)<br/>  }<br/>}</pre>
<p>With the preceding code, we are able to let different reducer functions handle different parts of our state. Let's add such a function to our store along with some reducers:</p>
<pre>// NGRX-light/storeVI.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>'rxjs'</span><span>);<br/></span><br/><strong>function counterReducer(state = 0, action) {<br/>  switch(action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    default:<br/>      return state;<br/>  }</strong><br/><strong>}</strong><br/><br/><strong>function productsReducer(state = [], action) {<br/>  switch(action.type) {<br/>    case 'ADD_PRODUCT':<br/>      return [ ...state, Object.assign({}, action.payload) ]<br/>    default:<br/>      return state;<br/>  }</strong><br/><strong>}</strong><br/><br/>class<span> Store </span><span>extends</span><span> Rx.<strong>BehaviorSubject</strong> {<br/></span>  constructor<span>() {<br/></span>    <strong>super({ counter: 0</strong><span><strong>, products: [] });</strong><br/></span>    this<span>.dispatcher </span><span>=</span><span> </span><span>new</span><span> Rx.Subject();<br/></span>    this<span>.state </span><span>=</span><span> {};<br/></span>    this<span>.dispatcher<br/></span>      .scan((acc, curr) <span>=&gt;</span><span> ({ </span><span>...</span><span>acc, </span><span>...</span><span>curr }))<br/></span>      .subscribe(data <span>=&gt;</span><span> </span><span>this</span><span>.next(data));<br/></span>  }<br/><br/>  <strong>calcState(state, action) {</strong><br/><strong>    return {<br/>      counter: counterReducer(state.counter, action),</strong><br/><strong>      products: productsReducer(state.products, action)</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><br/>  dispatch(<strong>action</strong>) {<br/>    <strong>const newState = this.calcState(this</strong><span><strong>.value, action);</strong><br/></span>    this<span>.dispatcher.next(newState);<br/></span>  }<br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>store.subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store'</span><span>, data));<br/><br/></span>store.dispatch({ type: <span>'INCREMENT'</span><span> });<br/></span>store.dispatch({ type: <span>'INCREMENT'</span><span> });<br/></span>store.dispatch({ type: <span>'ADD_PRODUCT'</span><span>, payload: { id: </span><span>1</span><span>, name: </span><span>'Yoda'</span><span> } });</span><span><br/></span></pre>
<p>We have made quite a few changes to our store at this point:</p>
<ul>
<li>We  have added two reducers</li>
<li>Now we inherit from a <kbd>BehaviorSubject</kbd>; this is so we can remember what the old state was so when we call <kbd>calcState()</kbd> we are able to produce a new state based on the old state + action</li>
<li>We added the method <kbd>calcState()</kbd> that takes the old state and an action</li>
<li>The dispatcher now takes an action instead of a state</li>
<li>The <kbd>super()</kbd> constructor in the constructor now takes an initial value </li>
</ul>
<p>We have set ourselves up quite well for our next step, namely on how to get a part of the state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with slices of state</h1>
                </header>
            
            <article>
                
<p>The reason for wanting only part of the state is that we will use NgRx in a context where there will be many components that only care about rendering a little part of the application's full state. For example, we may have a product list component, a product detail component, and so on. For that reason, we need to implement support for getting a slice of state. Thanks to the fact that our store inherits from a <kbd>BehaviorSubject,</kbd> implementing a slice of state is child's play:</p>
<pre>// NGRX-light/storeVII.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>'rxjs'</span><span>);<br/><br/></span>function<span> counterReducer(state </span><span>=</span><span> </span><span>0</span><span>, action) {<br/></span>  switch<span>(action.type) {<br/></span>    case<span> </span><span>"INCREMENT"</span><span>:<br/></span>      return<span> state </span><span>+</span><span> </span><span>1</span><span>;<br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}<br/><br/>function<span> productsReducer(state </span><span>=</span><span> [], action) {<br/></span>  switch<span>(action.type) {<br/></span>    case<span> </span><span>'ADD_PRODUCT'</span><span>:<br/></span>      return<span> [ </span><span>...</span><span>state, Object.assign({}, action.payload) ]<br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}<br/><br/>class<span> Store </span><span>extends</span><span> Rx.BehaviorSubject {<br/></span>  constructor<span>() {<br/></span>    super<span>({ counter: </span><span>0</span><span>, products: [] });<br/></span>    this<span>.dispatcher </span><span>=</span><span> </span><span>new</span><span> Rx.Subject();<br/></span>    this<span>.state </span><span>=</span><span> {};<br/></span>    this<span>.dispatcher<br/></span>      .scan((acc, curr) <span>=&gt;</span><span> ({ </span><span>...</span><span>acc, </span><span>...</span><span>curr }))<br/></span>      .subscribe(data <span>=&gt;</span><span> </span><span>this</span><span>.next(data));<br/></span>  }<br/><br/>  calcState(state, action) {<br/>    return<span> {<br/></span>      counter: counterReducer(state.counter, action),<br/>      products: productsReducer(state.products, action)<br/>    }<br/>  } <br/><br/>  dispatch(action) {<br/>    const<span> newState </span><span>=</span><span> </span><span>this</span><span>.calcState(</span><span>this</span><span>.value, action);<br/></span>    this<span>.dispatcher.next(newState);<br/></span>  }<br/><br/>  <strong>select(slice) {</strong><br/><strong>    return this.map(state =&gt; state[slice]);<br/>  }</strong><br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>store<br/>  <strong>.select('products'</strong><span><strong>)</strong><br/></span>  .subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store using select'</span><span>, data));<br/><br/>// store using select, []<br/>// store using select, [{ id: 1, name: 'Yoda' }]<br/><br/></span>store.subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store'</span><span>, data));<br/></span>store.dispatch({ type: <span>'INCREMENT'</span><span> });<br/></span>store.dispatch({ type: <span>'INCREMENT'</span><span> });<br/>// store 0<br/>// store 1<br/><br/></span>store.dispatch({ type: <span>'ADD_PRODUCT'</span><span>, payload: { id: </span><span>1</span><span>, name: </span><span>'Yoda'</span><span> } });</span></pre>
<p>Should we want a more advanced <kbd>select</kbd> method, we can let it take a function instead, like so:</p>
<pre>// excerpt from the Store class<br/>select(fn) {<br/>  return this.map(fn);<br/>}<br/><br/>// usage - if there were such a state as 'state.products.list'<br/>store<br/>  .select(state =&gt; state.products.list);<br/><br/></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling side effects</h1>
                </header>
            
            <article>
                
<p>What is a side effect? A side effect is something that isn't part of the normal code flow but something that accesses outside resources, such as filesystems or resources on other networks. In the context of Redux, side effects are most often used for carrying out AJAX calls. Once that call comes back, we most likely need to update the state of the store because something has changed. How would we implement such a function? One is add a method <kbd>effect()</kbd> that would take a function. The said function would take dispatch method as a parameter so that the parameter function can carry out a dispatch, should it have a need for it, once the side effect has run its course. Let's imagine it is being used in the following way:</p>
<pre>// pseudo code<br/><br/>const store = new Store();<br/><br/>store.effect( async(dispatch) =&gt; {<br/>  const products = await getProducts();<br/>  dispatch({ type: 'LOAD_PRODUCTS', payload: products });<br/>})</pre>
<p>The preceding code shows how we in our side effect would want to carry out an AJAX call and fetch our products. Once we are done with our fetch, we want to dispatch the fetched products so they become part of the store's state. Let's attempt to implement the preceding <kbd>effect()</kbd> function:</p>
<pre>// NGRX-light/storeVIII.js<br/><br/>const<span> Rx </span><span>=</span><span> require(</span><span>'rxjs'</span><span>);<br/></span><br/>function<span> counterReducer(state </span><span>=</span><span> </span><span>0</span><span>, action) {<br/></span>  switch<span>(action.type) {<br/></span>    case<span> </span><span>"INCREMENT"</span><span>:<br/></span>      return<span> state </span><span>+</span><span> </span><span>1</span><span>;<br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}<br/><br/>function<span> productsReducer(state </span><span>=</span><span> [], action) {<br/></span>  switch<span>(action.type) {<br/></span>    case<span> </span><span>'ADD_PRODUCT'</span><span>:<br/></span>      return<span> [ </span><span>...</span><span>state, Object.assign({}, action.payload) ];<br/></span>   <strong> case 'LOAD_PRODUCTS':<br/>      return action.payload.map(p =&gt;</strong><span><strong> Object.assign({}, p));</strong><br/></span>    default<span>:<br/></span>      return<span> state;<br/></span>  }<br/>}<br/><br/>class<span> Store </span><span>extends</span><span> Rx.BehaviorSubject {<br/></span>  constructor<span>() {<br/></span>    super<span>({ counter: </span><span>0</span><span>, products: [] });<br/></span>    this<span>.dispatcher </span><span>=</span><span> </span><span>new</span><span> Rx.Subject();<br/></span>    this<span>.state </span><span>=</span><span> {};<br/></span>    this<span>.dispatcher<br/></span>      .scan((acc, curr) <span>=&gt;</span><span> ({ </span><span>...</span><span>acc, </span><span>...</span><span>curr }))<br/></span>      .subscribe(data <span>=&gt;</span><span> </span><span>this</span><span>.next(data));<br/></span>  }<br/><br/>  calcState(state, action) {<br/>    return<span> {<br/></span>      counter: counterReducer(state.counter, action),<br/>      products: productsReducer(state.products, action)<br/>    }<br/>  }<br/><br/>  dispatch(action) {<br/>    const<span> newState </span><span>=</span><span> </span><span>this</span><span>.calcState(</span><span>this</span><span>.value, action);<br/></span>    this<span>.dispatcher.next(newState);<br/></span>  }<br/><br/>  select(slice) {<br/>    return<span> </span><span>this</span><span>.map(state </span><span>=&gt;</span><span> state[slice]);<br/></span>  }<br/><br/>  <strong>effect(fn) {</strong><br/><strong>    fn(this.dispatch.bind(this));<br/>  }</strong><br/>}<br/><br/>const<span> store </span><span>=</span><span> </span><span>new</span><span> Store();<br/></span>store<br/>  .select(<span>'products'</span><span>)<br/></span>  .subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store using select'</span><span>, data));<br/><br/></span>store.subscribe(data <span>=&gt;</span><span> console.log(</span><span>'store'</span><span>, data));<br/></span>store.dispatch({ type: <span>'INCREMENT'</span><span> });<br/></span>store.dispatch({ type: <span>'INCREMENT'</span><span> });<br/></span>store.dispatch({ type: <span>'ADD_PRODUCT'</span><span>, payload: { id: </span><span>1</span><span>, name: </span><span>'Yoda'</span><span> } });<br/><br/></span><strong>const getProducts = () =&gt; {<br/>  return new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve([{ id: 1, name: "Vader" }]);<br/>    }, 3000);<br/>  });</strong><br/><strong>}</strong><br/><br/><strong>store.effect(async(dispatch) =&gt; {<br/>  const products = await getProducts();<br/>  dispatch({ type: 'LOAD_PRODUCTS', payload: products });<br/>});</strong></pre>
<p>The preceding code does the following:</p>
<ul>
<li>Adds a new case <kbd>LOAD_PRODUCTS</kbd> to the <kbd>productsReducer</kbd></li>
<li>Implements the <kbd>effect()</kbd> method on the <kbd>Store</kbd> class</li>
<li>Defines a <kbd>getProducts()</kbd> method to simulate AJAX calls</li>
<li>Demonstrates the use of the effect method by carrying out a call to <kbd>getProducts</kbd> and ends up dispatching the fetched products to the store</li>
</ul>
<p>We have now fully implemented the store and effects libraries for NgRx—we should be proud of ourselves.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">@ngrx/schematics</h1>
                </header>
            
            <article>
                
<p>Schematics is dependent on all of the libraries you can possibly use with NgRx; it's therefore a good idea to start out by installing these libraries before we do anything else. Just type the following:</p>
<pre><strong>npm install @ngrx/effects --save</strong><br/><strong>npm install @ngrx/entity --save</strong><br/><strong>npm install @ngrx/store --save</strong><br/><strong>npm install @ngrx/store-devtools</strong></pre>
<p>Schematics itself is a library that Angular-CLI uses to generate different constructs needed for  Angular development, such as components services, filters, and much more. <kbd>@ngrx/schematics</kbd> provides blueprints to schematics so you can get help generating constructs that you need when working with NgRx, in other words it makes development a lot faster. You can get help with generating the following things:</p>
<ul>
<li>Actions</li>
<li>Container</li>
<li>Effect</li>
<li>Entity</li>
<li>Feature</li>
<li>Reducer</li>
<li>Store</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting it up</h1>
                </header>
            
            <article>
                
<p><kbd>@ngrx/schematics</kbd> is an NPM library and as such can be easily installed by typing:</p>
<pre><strong>npm install @ngrx/schematics --save-dev</strong></pre>
<p>That's it. That's all that was needed to do the set up. To use it, you just need a terminal window and enter the appropriate commands. We will look at that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating constructs</h1>
                </header>
            
            <article>
                
<p>Generating what you need is as simple as typing:</p>
<pre><strong>ng generate &lt;what&gt; &lt;name&gt;</strong></pre>
<p>This will create files in the appropriate place. This is a real time saver, so learn to use it. Almost all of the commands come with a lot of options so it's worth checking out how they can be configured in the official documentation, which can be found here <a href="https://github.com/ngrx/platform/tree/master/docs/schematics">https://github.com/ngrx/platform/tree/master/docs/schematics.</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating actions</h1>
                </header>
            
            <article>
                
<p>Do this by typing the following:</p>
<pre><strong>ng generate action jedis</strong></pre>
<p>It will generate an actions file for us called <kbd>jedi.actions.ts</kbd> with the following content:</p>
<pre>// jedis.actions.ts<br/><br/>import<span> { Action } </span><span>from</span><span> </span><span>'@ngrx/store'</span><span>;<br/><br/></span>export<span> </span><span>enum</span><span> JedisActionTypes {<br/></span>  JedisAction <span>=</span><span> </span><span>'[Jedis] Action'<br/></span>}<br/><br/>export<span> </span><span>class</span><span> Jedis </span><span>implements</span><span> Action {<br/></span>  readonly<span> type </span><span>=</span><span> JediActionTypes.JediAction;<br/></span>}<br/><br/>export<span> </span><span>type</span><span> JediActions </span><span>=</span><span> Jedi;</span></pre>
<p>The preceding code gives us nice scaffolded files with some nice defaults and it creates a <kbd>enum</kbd> type that we can use in conjunction with reducers and selectors. Looking at the preceding code, we realize that we need to extend <kbd>JedisActionTypes</kbd> if we want things such as <kbd>ADD</kbd>, <kbd>CREATE,</kbd> and other CRUD operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a container</h1>
                </header>
            
            <article>
                
<p>This will inject a store into your component and create the component itself—the typical way to call this one is by typing:</p>
<pre><strong>ng generate container jedis</strong></pre>
<p>This will create the following files:</p>
<ul>
<li><kbd>jedis.component.ts</kbd></li>
<li><kbd>jedis.component.html</kbd></li>
<li><kbd>jedis.component.css</kbd></li>
<li><kbd>jedis.component.spec.ts</kbd></li>
</ul>
<p>And in <kbd>jedis.component.ts</kbd> and the store will be injected in the constructor, like so:</p>
<pre>// jedis.component.ts<br/><br/>import<span> { Component, OnInit } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>@Component({<br/>  selector: <span>'app-jedis'</span><span>,<br/></span>  templateUrl: <span>'./jedis.component.html'</span><span>,<br/></span>  styleUrls: [<span>'./jedis.component.css'</span><span>]<br/></span>})<br/>export<span> </span><span>class</span><span> JedisComponent </span><span>implements</span><span> OnInit {<br/></span>  constructor<span>(</span><strong>private store:</strong><span><strong> Store&lt;any&gt;</strong>) { } }<br/></span>  ngOnInit() {}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating an effect</h1>
                </header>
            
            <article>
                
<p>You generate an effect by typing the following:</p>
<pre><strong>ng generate effect jedis</strong></pre>
<p>This will produce the files:</p>
<ul>
<li><kbd>jedis.effect.ts</kbd></li>
<li><kbd>jedis.effect.spec.ts</kbd></li>
</ul>
<p>The <kbd>effects</kbd> file looks like this:</p>
<pre>import<span> { Injectable } </span><span>from</span><span> </span><span>'@angular/core'</span><span>;<br/></span>import<span> { Actions, Effect } </span><span>from</span><span> </span><span>'@ngrx/effects'</span><span>;<br/><br/></span>@Injectable()<br/>export<span> </span><span>class</span><span> JedisEffects {<br/></span>  constructor<span>(</span><span>private</span><span> actions$</span><span>:</span><span> Actions) {}<br/></span>}<span><br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating an entity</h1>
                </header>
            
            <article>
                
<p>This generates a whole bunch of files that you can think of to work with an entity. To run the command, type:</p>
<pre><strong>ng generate entity product</strong></pre>
<p>The following files are generated:</p>
<ul>
<li><kbd>product.actions.ts</kbd></li>
<li><kbd>product.model.ts</kbd></li>
<li><kbd>product.reducer.ts</kbd></li>
<li><kbd>product.reducer.spec.ts</kbd></li>
</ul>
<p>It's worth mentioning that the <kbd>product.reducer.ts</kbd> file not only generates the full reducer function but also creates and initializes the <kbd>EntityAdapter</kbd>. That's a lot of boilerplate that you don't have to write. You also get all the actions and all selectors—a truly powerful command.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a feature</h1>
                </header>
            
            <article>
                
<p>Generating a feature gives you a lot of files. Let's have a look at what the command looks like:</p>
<pre><strong>ng generate feature category</strong></pre>
<p>This generates the following files:</p>
<ul>
<li><kbd>category.actions.ts</kbd></li>
<li><kbd>category.reducer.ts</kbd></li>
<li><kbd>category.reducer.spec.ts</kbd></li>
<li><kbd>category.effects.ts</kbd></li>
<li><kbd>category.effects.spec.ts</kbd></li>
</ul>
<p>This again is a lot of files you don't have to write by hand.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a reducer</h1>
                </header>
            
            <article>
                
<p>This generates a reducer and a test file. If all you want is a reducer then this command is for you. To use it, type the following:</p>
<pre><strong>ng generate reducer travel</strong></pre>
<p>This produces the following files:</p>
<ul>
<li><kbd>travel.reducer.ts</kbd></li>
<li><kbd>travel.reducer.spec.ts</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a store</h1>
                </header>
            
            <article>
                
<p>This command sets you up completely for using the <kbd>@ngrx/store</kbd>. It also allows you to set up feature stores. So, by typing the following two commands, you can generate a whole lot of files:</p>
<pre><strong>ng generate module country</strong><br/><strong>ng generate store country</strong></pre>
<p>The preceding code will generate a module as well as add a feature state. Running the following command will add the set up needed to work with the store, as well as set up the devtools that come with NgRx:</p>
<pre><strong>ng generate store State --root --module app.module.ts</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this, the final chapter of the book, we have looked at how to truly master NgRx and all its accompanying helper libraries. We have also gone through how to build your own micro implementation of NgRx to establish that we really know what is going on behind the scenes. We have looked at various ways to improve our speed and productivity by looking at the entity library and schematics library, respectively. </p>
<p>You, as a reader, have been taken through a long journey of Flux and Redux patterns throughout the course of this book. In addition, Functional programming, Reactive Programming, and deep RxJS knowledge have been added to your tool belt. This has built up to two full chapters covering everything NgRx has to offer. The aim of this book was to give you a broad and deep enough context of the underlying thoughts and paradigms behind NgRx and the library itself. The hope is that after, reading this book, you will feel full of confidence and know how to tackle existing and future projects using Angular and NgRx.</p>
<p>Thank you for taking the time to read this book, and do not hesitate to reach out with queries in any way, shape, or form.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>