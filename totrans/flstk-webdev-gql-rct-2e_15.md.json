["```js\n    npm install --save-dev webpack-node-externals @babel/plugin-transform-runtime\n    ```", "```js\n    const path = require('path');\n    const nodeExternals = require('webpack-node-externals');\n    const buildDirectory = 'dist/server';\n    module.exports = {\n      mode: 'production',\n      entry: [\n        './src/server/index.js'\n      ],\n      output: {\n        path: path.join(__dirname, buildDirectory),\n        filename: 'bundle.js',\n        publicPath: '/server'\n      },\n      module: {\n        rules: [{\n          test: /\\.js$/,\n          use: {\n            loader: 'babel-loader',\n            options: {\n              plugins: [\"@babel/plugin-transform-runtime\"]\n            }\n          },\n        }],\n      },\n      node: {\n        __dirname: false,\n        __filename: false,\n      },\n      target: 'node',\n      externals: [nodeExternals()],\n      plugins: [],\n    };\n    ```", "```js\n    \"build\": \"npm run client:build && npm run server:build\",\n    \"server:build\": \"webpack --config webpack.server.build.config.js\"\n    ```", "```js\n    \"server:production\": \"node dist/server/bundle.js\"\n    ```", "```js\n    \"test\": \"npm run build && mocha --exit test/ --require babel-hook --require @babel/polyfill --recursive\",\n    ```", "```js\n    sudo apt-get update\n    ```", "```js\n    sudo apt-get install docker\n    ```", "```js\n    sudo snap install docker\n    ```", "```js\nFROM node:14\n```", "```js\nWORKDIR /usr/src/app\n```", "```js\nCOPY . .\n```", "```js\n    node_modules\n    ```", "```js\n    RUN command executes npm install inside of the current working directory. The related package.json file and node_modules folder are stored in the filesystem of the Docker image. Those files are directly committed and are included in the final image. Docker's RUN command sends the command that we pass as the first parameter into Bash and executes it. To avoid the problems of spaces in the shell commands, or other syntax problems, you can pass the command as an array of strings, which will be transformed by Docker into valid Bash syntax. Through RUN, you can interact with other system-level tools (such as apt-get or curl).Now that all files and dependencies are in the correct filesystem, we can start Graphbook from our new Docker image. Before doing so, there are two things that we need to do – we have to allow for external access to the container via the IP and define what the container should do when it has started.\n    ```", "```js\n    EXPOSE 8000\n    ```", "```js\n    CMD [ \"npm\", \"run\", \"server\" ]\n    ```", "```js\ndocker build -t sgrebe/graphbook .\n```", "```js\ndocker images\n```", "```js\ndocker run -p 8000:8000 -d --env-file .env sgrebe/graphbook\n```", "```js\nNODE_ENV=development\nJWT_SECRET=YOUR_JWT_SECRET\nAWS_ACCESS_KEY_ID=YOUR_AWS_KEY_ID\nAWS_SECRET_ACCESS_KEY=YOUR_AWS_SECRET_ACCESS_KEY\n```", "```js\ndocker ps\n```", "```js\ndocker logs 08499322a998\n```", "```js\ndocker stop 08499322a998\n```", "```js\ndocker rm 08499322a998\n```", "```js\ndocker rmi fe30bceb0268\n```", "```js\n    FROM node:14 AS build\n    ```", "```js\n    WORKDIR /usr/src/app\n    ```", "```js\n    COPY .babelrc ./\n    COPY package*.json ./\n    COPY webpack.server.build.config.js ./\n    COPY webpack.client.build.config.js ./\n    COPY src src\n    COPY assets assets\n    COPY public public\n    ```", "```js\n    RUN npm install\n    ```", "```js\n    RUN npm run build\n    ```", "```js\n    FROM node:14\n    ```", "```js\n    WORKDIR /usr/src/app\n    ```", "```js\n    ENV NODE_ENV production\n    ENV JWT_SECRET JWT_SECRET\n    ENV username YOUR_USERNAME\n    ENV password YOUR_PASSWORD\n    ENV database YOUR_DATABASE\n    ENV host YOUR_HOST\n    ENV AWS_ACCESS_KEY_ID AWS_ACCESS_KEY_ID\n    ENV AWS_SECRET_ACCESS_KEY AWS_SECRET_ACCESS_KEY\n    ```", "```js\n    COPY --from=build /usr/src/app/package.json package.json\n    COPY --from=build /usr/src/app/dist dist\n    COPY start.sh start.sh\n    COPY src/server src/server\n    ```", "```js\n    npm packages that are really required; npm offers the only parameter, which lets you install only the production packages, as an example. It will exclude all devDependecies of your package.json file. This is really great for keeping your image size low.Then, there are three `npm` packages that are technically not a dependency, which is defined in our `package.json` file, because they are not required to get our application running. Still, they are needed to get our database migrations applied. Add the following `RUN` command to the `Dockerfile`:\n\n    ```", "```js\n\n    ```", "```js\n    EXPOSE 8000\n    CMD [ \"sh\", \"start.sh\" ]\n    ```", "```js\n    sequelize db:migrate --migrations-path src/server/migrations --config src/server/config/index.js --env production\n    npm run server:production\n    ```", "```js\nusername=YOUR_USERNAME\npassword=YOUR_PASSWORD\ndatabase=YOUR_DATABASE\nhost=YOUR_HOST\n```", "```js\nversion: 2.1\njobs:\n  build:\n    docker:\n      - image: circleci/node:14\n    steps:\n      - checkout\n      - run:\n          command: echo \"This is working\"\n```", "```js\n    version: 2.1\n    jobs:\n      test:\n        docker:\n          - image: circleci/node:14\n            auth:\n              username: $DOCKERHUB_USERNAME\n              password: $DOCKERHUB_PASSWORD\n            environment:\n              host: localhost\n              username: admin\n              password: passw0rd\n              database: graphbook\n              JWT_SECRET: 1234\n    ```", "```js\n          - image: circleci/mysql:8.0.4\n            command: [--default-authentication-\n                      plugin=mysql_native_password]\n            auth:\n              username: $DOCKERHUB_USERNAME\n              password: $DOCKERHUB_PASSWORD\n            environment:\n              MYSQL_ROOT_PASSWORD: passw0rd\n              MYSQL_DATABASE: graphbook\n              MYSQL_USER: admin\n              MYSQL_PASSWORD: passw0rd\n    ```", "```js\n        steps:\n          - checkout\n          - run: npm install\n    ```", "```js\n          - run:\n              name: \"Install Sequelize\"\n              command: sudo npm install -g mysql2 \n                       sequelize sequelize-cli\n    ```", "```js\n          - run:\n              name: Waiting for MySQL to be ready\n              command: |\n                for i in 'seq 1 10';\n                  do\n                    nc -z 127.0.0.1 3306 && echo Success \n                      && exit 0\n                    echo -n .\n                    sleep 1\n                  done\n                  echo Failed waiting for MySQL && exit 1\n    ```", "```js\n          - run:\n              name: \"Run migrations for test DB\"\n              command: sequelize db:migrate \n                --migrations-path src/server/migrations \n                --config src/server/config/index.js \n                --env production\n    ```", "```js\n          - run:\n              name: \"Run tests\"\n              command: npm run test\n              environment:\n                NODE_ENV: production\n    ```", "```js\n    workflows:\n      build-and-deploy:\n        jobs:\n          - test\n    ```", "```js\norbs:\n  aws-ecr: circleci/aws-ecr@7.2.0\n```", "```js\n- aws-ecr/build-and-push-image:\n  repo: \"graphbook\"\n  tag: \"${CIRCLE_SHA1}\"\n  requires:\n    - test\n```", "```js\naws-ecs: circleci/aws-ecs@02.2.1\n```", "```js\n  - aws-ecs/deploy-service-update:\n    requires:\n      - aws-ecr/build-and-push-image\n      - test\n    family: \"graphbook-task-definition\"\n    cluster-name: \"graphbook-cluster\"\n    service-name: \"graphbook-service\"\n    container-image-name-updates: \"container=\n      graphbook-container,tag=${CIRCLE_SHA1}\"\n```"]