- en: Chapter 6. Working with the Angular 2 Router and Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用Angular 2路由器和表单
- en: By now, we're already familiar with the core of the framework. We know how to
    define components and directives in order to develop the view of our applications.
    We also know how to encapsulate business-related logic into services and wire
    everything together with the dependency injection mechanism of Angular 2.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了框架的核心。我们知道如何定义组件和指令来开发我们应用程序的视图。我们还知道如何将与业务相关的逻辑封装到服务中，并使用Angular
    2的依赖注入机制将所有内容连接起来。
- en: 'In this chapter, we''ll explain a few more concepts that will help us build
    real-life Angular 2 applications. They are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释一些概念，这些概念将帮助我们构建真实的Angular 2应用程序。它们如下：
- en: The component-based router of the framework.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的基于组件的路由器。
- en: Using Angular 2 forms.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular 2表单。
- en: Developing template-driven forms.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发基于模板的表单。
- en: Developing custom form validators.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自定义表单验证器。
- en: Let's begin!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Developing the "Coders repository" application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发“Coders repository”应用程序
- en: In the process of explaining the concepts mentioned earlier, we'll develop a
    sample application that contains a repository of developers. Before we start coding,
    let's explain the structure of the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释前面提到的概念的过程中，我们将开发一个包含开发人员存储库的示例应用程序。在我们开始编码之前，让我们解释一下应用程序的结构。
- en: The "Coders repository" will allow its users to add developers either by filling
    a form with details about them or by providing the GitHub handle for the developer
    and importing his or her profile from GitHub.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “Coders repository”将允许其用户通过填写有关他们的详细信息的表单或提供开发人员的GitHub句柄并从GitHub导入其个人资料来添加开发人员。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purpose of this chapter, we will store information on the developers
    in memory, which means that after the page is refreshed, we'll lose all the stored
    during the session data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将在内存中存储开发人员的信息，这意味着在刷新页面后，我们将丢失会话期间存储的所有数据。
- en: 'The application will have the following views:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将具有以下视图：
- en: A list of all the developers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有开发人员的列表。
- en: A view that adds or imports new developers.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个添加或导入新开发人员的视图。
- en: 'A view that shows the given developer''s details. This view has two subviews:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示给定开发人员详细信息的视图。此视图有两个子视图：
- en: '**Basic details**: Shows the name of the developer and her or his GitHub avatar
    if available.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本详情**：显示开发人员的姓名及其GitHub头像（如果有）。'
- en: '**Advanced profile**: Shows all the details known for the developer.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级资料**：显示开发人员已知的所有详细信息。'
- en: 'The end result of the home page of the application will look as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序主页的最终结果将如下所示：
- en: '![Developing the "Coders repository" application](../images/00023.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![开发“Coders repository”应用程序](../images/00023.jpeg)'
- en: Fig. 1
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will build only a few of the listed views. The rest of the
    application will be explained in [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Explaining
    Pipes and Communicating with RESTful Services*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只构建列出的视图中的一些。应用程序的其余部分将在[第7章](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "第7章。解释管道和与RESTful服务通信")中解释，*解释管道和与RESTful服务通信*。
- en: 'Each developer will be an instance of the following class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发人员将是以下类的实例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All the developers will reside within the `DeveloperCollection` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发人员将驻留在`DeveloperCollection`类中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The classes mentioned here encapsulate quite a simple logic and don't have anything
    Angular 2-specific, so we won't get into any details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的类封装了非常简单的逻辑，并没有任何特定于Angular 2的内容，因此我们不会深入讨论任何细节。
- en: Now, let's continue with the implementation by exploring the new router.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现，通过探索新的路由器。
- en: Exploring the Angular 2 router
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular 2路由器
- en: As we already know, in order to bootstrap any Angular 2 application, we need
    to develop a root component. The "Coders repository" application is not any different;
    the only addition in this specific case is that we will have multiple pages that
    need to be connected together with the Angular 2 router.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的那样，为了引导任何Angular 2应用程序，我们需要开发一个根组件。 "Coders repository"应用程序并没有什么不同；在这种特定情况下唯一的额外之处是我们将有多个页面需要使用Angular
    2路由连接在一起。
- en: 'Let''s start with the imports required for the router''s configuration and
    define the root component right after this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从路由器配置所需的导入开始，并在此之后定义根组件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding snippet, we imported a couple of things directly from the Angular
    2 router module, which is externalized outside the framework's core.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们直接从Angular 2路由器模块中导入了一些东西，这些东西是在框架的核心之外外部化的。
- en: With `ROUTER_DIRECTIVES`, the router provides a set of commonly used directives
    that we can add to the list of used ones by the root component. This way, we will
    be able to use them in the templates later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ROUTER_DIRECTIVES`，路由器提供了一组常用的指令，我们可以将其添加到根组件使用的指令列表中。这样，我们将能够在模板中使用它们。
- en: The import `ROUTE_PROVIDERS` contains a set of router-related providers, such
    as one for injecting the `RouteParams` token into the components' constructors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`ROUTE_PROVIDERS`包含一组与路由器相关的提供者，例如用于将`RouteParams`令牌注入组件构造函数的提供者。
- en: The `RouteParams` token provides an access to parameters from the route's URL
    in order to parametrize the logic associated with a given page. We'll demonstrate
    a typical use case of this provider later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouteParams`令牌提供了从路由URL中访问参数的能力，以便对给定页面关联的逻辑进行参数化。我们稍后将演示此提供程序的典型用例。'
- en: The import `LocationStrategy` class is an abstract class that defines the common
    logic between `HashLocationStrategy` (used for hash-based routing) and `PathLocationStrategy`
    (used for HTML5-based routing by taking advantage of the history API).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`LocationStrategy`类是一个抽象类，定义了`HashLocationStrategy`（用于基于哈希的路由）和`PathLocationStrategy`（利用历史API用于基于HTML5的路由）之间的公共逻辑。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`HashLocationStrategy` does not support server-side rendering. This is due
    to the fact that the hash of the page does not get sent to the server, so it cannot
    find out the component associated with the given page. All modern browsers except
    IE9 support the HTML5 history API. You can find more about server-side rendering
    in the last chapter of the book.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashLocationStrategy`不支持服务器端渲染。这是因为页面的哈希值不会发送到服务器，因此服务器无法找到与给定页面关联的组件。除了IE9之外，所有现代浏览器都支持HTML5历史API。您可以在书的最后一章中找到有关服务器端渲染的更多信息。'
- en: The last imports we didn't take a look at are `RouteConfig`, which is a decorator
    that allows us to define the routes associated with a given component; and `Route`
    and `Redirect`, which respectively allow us to define the individual routes and
    redirects. With `RouteConfig`, we can define a hierarchy of routes, which means
    that the router of Angular 2 supports nested routing out of the box unlike its
    predecessor in AngularJS 1.x.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到的最后导入是`RouteConfig`，它是一个装饰器，允许我们定义与给定组件关联的路由；以及`Route`和`Redirect`，分别允许我们定义单个路由和重定向。使用`RouteConfig`，我们可以定义一组路由的层次结构，这意味着Angular
    2的路由器支持嵌套路由，这与其前身AngularJS 1.x不同。
- en: Defining the root component and bootstrapping the application
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义根组件并引导应用程序
- en: 'Now, let''s define a root component and configure the application''s initial
    bootstrap:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个根组件并配置应用程序的初始引导：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet, you can notice a syntax we're already familiar with
    from [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives* and [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*. We defined a component with an `app` selector, `template` that we're going
    to take a look at later, and sets of providers and directives.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，您可以注意到一个我们已经熟悉的语法，来自[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。开始使用Angular 2组件和指令")，“开始使用Angular 2组件和指令”和[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "第5章。Angular 2中的依赖注入")，“Angular 2中的依赖注入”。我们定义了一个带有`app`选择器的组件，稍后我们将看一下`template`，以及提供者和指令的集合。
- en: The `App` component uses a single provider called `DeveloperCollection`. This
    is the class that contains all the developers stored by the application. You can
    notice that we added `ROUTER_DIRECTIVES`; it contains an array of all the directives
    defined within the Angular's router. Some of the directives within this array
    allow us to link to the other routes defined within the `@RouteConfig` decorator
    (the `routerLink` directive) and declare the place where the components associated
    with the different routes should be rendered (`router-outlet`). We'll explain
    how we can use them later in this section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件使用了一个名为`DeveloperCollection`的单个提供者。这是一个包含应用程序存储的所有开发人员的类。您可以注意到我们添加了`ROUTER_DIRECTIVES`；它包含了Angular路由中定义的所有指令的数组。在这个数组中的一些指令允许我们链接到`@RouteConfig`装饰器中定义的其他路由（`routerLink`指令），并声明与不同路由相关联的组件应该呈现的位置（`router-outlet`）。我们将在本节后面解释如何使用它们。'
- en: 'Now let''s take a look at the call of the `bootstrap` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`bootstrap`函数的调用：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As the first argument of `bootstrap`, we pass the root component of the application
    as usual. The second argument is a list of providers that will be accessible by
    the entire application. To the set of providers, we add `ROUTER_PROVIDERS` and
    we also configure the provider for the `LocationStrategy` token. The default `LocationStrategy`
    token, which Angular 2 uses, is `PathLocationStrategy` (that is, the HTML5-based
    one). However, in this case, we are going to use the hash-based one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`bootstrap`的第一个参数，我们像往常一样传递应用程序的根组件。第二个参数是整个应用程序都可以访问的提供者列表。在提供者集中，我们添加了`ROUTER_PROVIDERS`，并且还配置了`LocationStrategy`令牌的提供者。Angular
    2使用的默认`LocationStrategy`令牌是`PathLocationStrategy`（即基于HTML5的令牌）。然而，在这种情况下，我们将使用基于哈希的令牌。
- en: The two biggest advantages of the default location strategy are that it is supported
    by the server-rendering module of Angular 2, and the application's URL looks more
    natural to the end user (there's no `#` used). On the other hand, in case we use
    `PathLocationStrategy`, we may need to configure our application server, in order
    to handle the routes properly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认位置策略的两个最大优势是它得到了Angular 2的服务器渲染模块的支持，并且应用程序的URL对最终用户看起来更自然（没有使用`#`）。另一方面，如果我们使用`PathLocationStrategy`，我们可能需要配置我们的应用程序服务器，以便正确处理路由。
- en: Using PathLocationStrategy
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PathLocationStrategy
- en: 'If we want to use `PathLocationStrategy`, we may need to provide `APP_BASE_HREF`.
    For instance, in our case, the `bootstrap` configuration should look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用`PathLocationStrategy`，我们可能需要提供`APP_BASE_HREF`。例如，在我们的情况下，`bootstrap`配置应该如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, the value associated with the `APP_BASE_HREF` token is `/`; it represents
    the base path name inside of the application. For instance, in our case, the "Coders
    repository" will be located under the `/ch6/ts/multi-page-template-driven/` directory
    (that is, `http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，与`APP_BASE_HREF`令牌关联的值是`/`；它表示应用程序内的基本路径名称。例如，在我们的情况下，“Coders repository”将位于`/ch6/ts/multi-page-template-driven/`目录下（即`http://localhost:5555/dist/dev/ch6/ts/multi-page-template-driven/`）。
- en: Configuring routes with @RouteConfig
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用@RouteConfig配置路由
- en: 'As the next step, let''s take a look at the route''s declaration placed in
    the `@RouteConfig` decorator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们来看看放置在`@RouteConfig`装饰器中的路由声明。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the preceding snippet shows, the `@RouteConfig` decorator accepts an array
    of routes as an argument. In the example, we defined two types of routes: using
    the classes `Route` and `Redirect`. They are used respectively to define the routes
    and redirects in the application.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的片段所示，`@RouteConfig`装饰器接受一个路由数组作为参数。在这个例子中，我们定义了两种类型的路由：使用`Route`和`Redirect`类。它们分别用于定义应用程序中的路由和重定向。
- en: 'Each route must define the following properties:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由必须定义以下属性：
- en: '`component`: The component associated with the given route.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：与给定路由相关联的组件。'
- en: '`name`: The name of the route used for referencing it in the templates.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：用于在模板中引用的路由名称。'
- en: '`path`: The path to be used for the route. It will be visible in the browser''s
    location bar.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：用于路由的路径。它将显示在浏览器的位置栏中。'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Route` class also supports a data property whose value can be injected
    in the constructor of its associated component by using the `RouteData` token.
    A sample use case of the data property could be if we want to inject different
    configuration objects based on the type of the parent component that contains
    the `@RouteConfig` declaration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`类还支持一个数据属性，其值可以通过使用`RouteData`令牌注入到其关联组件的构造函数中。数据属性的一个示例用例可能是，如果我们想要根据包含`@RouteConfig`声明的父组件的类型来注入不同的配置对象。'
- en: 'On the other hand, the redirect contains only two properties:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，重定向只包含两个属性：
- en: '`path`: The path to be used for the redirection.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：用于重定向的路径。'
- en: '`redirectTo`: The path the user is redirected to.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirectTo`：用户被重定向到的路径。'
- en: In the previous example, we declared that we want the page opened by the user
    with the path `/add-dev` to be redirected to `['/dev-add']`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明希望用户打开路径`/add-dev`的页面被重定向到`['/dev-add']`。
- en: 'Now, in order to make everything work, we need to define the `AddDeveloper`
    and `Home` components, which are referenced in `@RouteConfig`. Initially, we''re
    going to provide a basic implementation that we''ll incrementally extend over
    time along the chapter. In `ch6/ts/step-0`, create a file called `home.ts` and
    enter the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使一切正常运行，我们需要定义`AddDeveloper`和`Home`组件，这些组件在`@RouteConfig`中被引用。最初，我们将提供一个基本的实现，随着章节的进行逐步扩展。在`ch6/ts/step-0`中，创建一个名为`home.ts`的文件，并输入以下内容：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Do not forget to import the `Home` component in `app.ts`. Now, open the file
    called `add_developer.ts` and enter the following content in it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`app.ts`中导入`Home`组件。现在，打开名为`add_developer.ts`的文件，并输入以下内容：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using routerLink and router-outlet
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用routerLink和router-outlet
- en: We have the route's declaration and all the components associated with the individual
    routes. The only thing left is to define the template of the root `App` component
    in order to link everything together.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了路由和与各个路由相关联的所有组件。唯一剩下的就是定义根`App`组件的模板，以便将所有内容链接在一起。
- en: 'Add the following content to the `template` property inside the `@Component`
    decorator in `ch6/ts/step-0/app.ts`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`ch6/ts/step-0/app.ts`中`@Component`装饰器内的`template`属性中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the template above there are two Angular 2-specific directives:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的模板中有两个特定于Angular 2的指令：
- en: '`routerLink`: This allows us to add a link to a specific route.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routerLink`：这允许我们添加到特定路由的链接。'
- en: '`router-outlet`: This defines the container where the components associated
    with the currently selected route need to be rendered.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router-outlet`：这定义了当前选定路由相关的组件需要被渲染的容器。'
- en: Let's take a look at the `routerLink` directive. As value it accepts an array
    of route names and parameters. In our case we provide only a single route name
    prefixed with slash (since this route is on root level). Notice that the route
    name used by `routerLink` is declared by the `name` property of the route declaration
    inside `@RouteConfig`. Later in this chapter we'll see how we can link to nested
    routes and pass route parameters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`routerLink`指令。它接受一个路由名称和参数的数组作为值。在我们的例子中，我们只提供了一个以斜杠为前缀的单个路由名称（因为这个路由在根级别）。注意，`routerLink`使用的路由名称是在`@RouteConfig`内部的路由声明的`name`属性声明的。在本章的后面，我们将看到如何链接到嵌套路由并传递路由参数。
- en: This directive allows us to declare links independently from `LocationStrategy`
    that we have configured. For instance, imagine we are using `HashLocationStrategy`;
    this means that we need to prefix all the routes in our templates with `#`. In
    case we switch to `PathLocationStrategy`, we'll need to remove all the hash prefixes.
    Another huge benefit of `routerLink` is that it uses the HTML5 history push API
    transparently to us, which saves us from a lot of boilerplates.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令允许我们独立于我们配置的`LocationStrategy`来声明链接。例如，假设我们正在使用`HashLocationStrategy`；这意味着我们需要在模板中的所有路由前加上`#`。如果我们切换到`PathLocationStrategy`，我们就需要移除所有的哈希前缀。`routerLink`的另一个巨大好处是它对我们透明地使用HTML5历史推送API，这样就可以节省我们大量的样板代码。
- en: 'The next directive from the previous template that is new to us is `router-outlet`.
    It has similar responsibility to the `ng-view` directive in AngularJS 1.x. Basically,
    they both have the same role: to point out where the `target` component should
    be rendered. This means that according to the definition, when the user navigates
    to `/`, the `Home` component will be rendered at the position pointed out by `router-outlet`,
    same for the `AddDeveloper` component once the user navigates to `/dev-add`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个模板中的下一个对我们新的指令是`router-outlet`。它的责任类似于AngularJS 1.x中的`ng-view`指令。基本上，它们都有相同的作用：指出`target`组件应该被渲染的位置。这意味着根据定义，当用户导航到`/`时，`Home`组件将在`router-outlet`指出的位置被渲染，当用户导航到`/dev-add`时，`AddDeveloper`组件也是一样。
- en: 'Now we have these two routes up and running! Open `http://localhost:5555/dist/dev/ch6/ts/step-0/`
    and you should see the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有这两条路线已经在运行了！打开`http://localhost:5555/dist/dev/ch6/ts/step-0/`，你应该会看到以下的截图：
- en: '![Using routerLink and router-outlet](../images/00024.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用routerLink和router-outlet](../images/00024.jpeg)'
- en: Fig. 2
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2
- en: If you don't, just take a look at `ch6/ts/step-1` that contains the end result.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，请看一下`ch6/ts/step-1`，里面包含了最终结果。
- en: Lazy-loading with AsyncRoute
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AsyncRoute进行懒加载
- en: AngularJS 1.x modules allow us to group together logically related units in
    the application. However, by default, they need to be available during the initial
    application's `bootstrap` and do not allow deferred loading. This requires downloading
    the entire codebase of the application during the initial page load that, in case
    of large single-page apps, can be an unacceptable performance hit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 1.x模块允许我们将应用程序中逻辑相关的单元分组在一起。然而，默认情况下，它们需要在初始应用程序的`bootstrap`期间可用，并且不允许延迟加载。这要求在初始页面加载期间下载整个应用程序的代码库，对于大型单页应用程序来说，这可能是无法接受的性能损失。
- en: 'In a perfect scenario, we would want to load only the code associated with
    the page the user is currently viewing, or to prefetch bundled modules based on
    heuristics related to the user''s behavior, which is out of the scope of this
    book. For instance, open the application from the first step of our example: `http://localhost:5555/dist/dev/ch6/ts/step-1/`.
    Once the user is at `/`, we only need the `Home` component to be available, and
    once he or she navigates to `/dev-add`, we want to load the `AddDeveloper` component.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的场景中，我们希望只加载与用户当前浏览页面相关的代码，或者根据与用户行为相关的启发式预取捆绑模块，这超出了本书的范围。例如，从我们示例的第一步打开应用程序：`http://localhost:5555/dist/dev/ch6/ts/step-1/`。一旦用户在`/`，我们只需要`Home`组件可用，一旦他或她导航到`/dev-add`，我们希望加载`AddDeveloper`组件。
- en: 'Let''s inspect what is actually going on in Chrome DevTools:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Chrome DevTools中检查实际发生了什么：
- en: '![Lazy-loading with AsyncRoute](../images/00025.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用AsyncRoute进行延迟加载](../images/00025.jpeg)'
- en: Fig. 3
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图3
- en: We can notice that during the initial page load, we downloaded the components
    associated with all the routes, even `AddDeveloper` that is not required. This
    happens because in `app.ts`, we explicitly require both the `Home` and the `AddDeveloper`
    components and use them in the `@RouteConfig` declaration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到在初始页面加载期间，我们下载了与所有路由相关的组件，甚至不需要的`AddDeveloper`。这是因为在`app.ts`中，我们明确要求`Home`和`AddDeveloper`组件，并在`@RouteConfig`声明中使用它们。
- en: In this specific case, loading both the components may not seem like a big problem,
    because at this step, they are pretty simple and do not have any dependencies.
    However, in real-life applications, they will have imports of other directives,
    components, pipes, services, or even third-party libraries. Once any of the components
    is required, its entire dependency graph will be downloaded, even if the component
    is not needed at that point.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，加载这两个组件可能看起来不像是一个大问题，因为在这一步，它们非常简单，没有任何依赖关系。然而，在现实生活中的应用程序中，它们将导入其他指令、组件、管道、服务，甚至第三方库。一旦需要任何组件，它的整个依赖图将被下载，即使在那一点上并不需要该组件。
- en: 'The router of Angular 2 comes with a solution to this problem. All we need
    to do is import the `AsyncRoute` class from the `angular2/router` module and use
    it inside `@RouteConfig` instead of using `Route`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2的路由器提供了解决这个问题的解决方案。我们只需要从`angular2/router`模块中导入`AsyncRoute`类，并在`@RouteConfig`中使用它，而不是使用`Route`：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The constructor of the `AsyncRoute` class accepts as an argument an object
    with the following properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncRoute`类的构造函数接受一个对象作为参数，该对象具有以下属性：'
- en: '`loader`: A function that returns a promise that needs to be resolved with
    the component associated with the given route.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loader`：返回一个需要用与给定路由相关联的组件解析的promise的函数。'
- en: '`name`: The name of the route that can be used to refer to it in the templates
    (usually, inside of the `routerLink` directive).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：路由的名称，可以在模板中使用它（通常在`routerLink`指令内部）。'
- en: '`path`: The path of the route.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：路由的路径。'
- en: Once the user navigates to a route that matches any of the async routes' definitions
    in the `@RouteConfig` decorator, its associated loader will be invoked. When the
    promise returned by the loader is resolved with a value of the target component,
    the component will be cached and rendered. Next time the user navigates to the
    same route, the cached component will be used, so the routing module won't download
    the same component twice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户导航到与`@RouteConfig`装饰器中的任何异步路由定义匹配的路由，其关联的加载程序将被调用。当加载程序返回的promise被解析为目标组件的值时，该组件将被缓存和渲染。下次用户导航到相同的路由时，将使用缓存的组件，因此路由模块不会下载相同的组件两次。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the preceding example uses System, however, Angular's `AsyncRoute`
    implementation is not coupled to any particular module loader. The same result
    could be achieved, for instance, with require.js.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例使用了System，但是Angular的`AsyncRoute`实现并不与任何特定的模块加载器耦合。例如，可以使用require.js实现相同的结果。
- en: Using Angular 2 forms
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular 2表单
- en: Now let's continue with the implementation of the application. For the next
    step, we'll work on the `AddDeveloper` and `Home` components. You can continue
    your implementation by extending what you currently have in `ch6/ts/step-0`, or
    if you haven't reached step 1 yet, you can keep working on the files in `ch6/ts/step-1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续实现应用程序。在下一步中，我们将在`AddDeveloper`和`Home`组件上工作。您可以通过扩展`ch6/ts/step-0`中当前的内容继续实现，或者如果您还没有达到步骤1，您可以继续在`ch6/ts/step-1`中的文件上工作。
- en: 'Angular 2 offers two ways to develop forms with validation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2提供了两种开发带有验证的表单的方式：
- en: '**A template-driven approach**: Provides a declarative API where we declare
    the validations into the template of the component.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模板驱动的方法：提供了一个声明性的API，我们可以在组件的模板中声明验证。
- en: '**A model-driven approach**: Provides an imperative API with `FormBuilder`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模型驱动的方法：使用`FormBuilder`提供了一个命令式的API。
- en: In the next chapter, we'll explore both. Let's start with the template-driven
    approach.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨两种方法。让我们从模板驱动的方法开始。
- en: Developing template-driven forms
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发模板驱动的表单
- en: Forms are essential for each **CRUD** (**Create Retrieve Update and Delete**)
    application. In our case, we want to build a form for entering the details of
    the developers we want to store.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个**CRUD**（**创建检索更新和删除**）应用程序，表单都是必不可少的。在我们的情况下，我们想要为输入我们想要存储的开发者的详细信息构建一个表单。
- en: 'By the end of this section, we''ll have a form that allows us to enter the
    real name of a given developer, to add his or her preferred technology, enter
    an e-mail, and declare whether she or he is popular in the community or not yet.
    The end result will look as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，我们将拥有一个表单，允许我们输入给定开发者的真实姓名，添加他或她喜欢的技术，输入电子邮件，并声明他或她是否在社区中受欢迎。最终结果将如下所示：
- en: '![Developing template-driven forms](../images/00026.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Developing template-driven forms](../images/00026.jpeg)'
- en: Fig. 4
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4
- en: 'Add the following imports to `add_developer.ts`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入添加到`add_developer.ts`：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next thing we need to do is add `FORM_DIRECTIVES` to the list of directives
    used by the `AddDeveloper` component. The `FORM_DIRECTIVES` directives contains
    a set of predefined directives for managing Angular 2 forms, such as the `form`
    and `ngModel` directives.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是将`FORM_DIRECTIVES`添加到`AddDeveloper`组件使用的指令列表中。`FORM_DIRECTIVES`指令包含一组预定义指令，用于管理Angular
    2表单，例如`form`和`ngModel`指令。
- en: The `FORM_PROVIDERS` is an array with a predefined set of providers that we
    can use for injecting the values associated with their tokens in the classes of
    our application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`FORM_PROVIDERS`是一个包含一组预定义提供程序的数组，我们可以在应用程序的类中使用它们的令牌来注入与其关联的值。'
- en: 'Now update the `AddDeveloper` implementation to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`AddDeveloper`的实现更新为以下内容：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `developer` property contains the information associated with the current
    developer that we're adding with the form. The last two properties, `errorMessage`
    and `successMessage`, are going to be used respectively for displaying the current
    form's error or success messages once the developer has been successfully added
    to the developers collection, or an error has occurred.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`developer`属性包含与当前要添加到表单中的开发者相关的信息。最后两个属性，`errorMessage`和`successMessage`，分别用于在成功将开发者成功添加到开发者集合中或发生错误时显示当前表单的错误或成功消息。'
- en: Digging into the template-driven form's markup
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入研究模板驱动表单的标记
- en: 'As the next step, let''s create the template of the `AddDeveloper` component
    (`step-1/add_developer.html`). Add the following content to the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们创建`AddDeveloper`组件的模板（`step-1/add_developer.html`）。将以下内容添加到文件中：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These two elements are intended to display the error and success messages when
    adding a new developer. They are going to be visible when `errorMessage` and `successMessage`
    respectively have non-falsy values (that is, something different from the empty
    string, `false`, `undefined`, `0`, `NaN`, or `null`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素旨在在添加新开发人员时显示错误和成功消息。当`errorMessage`和`successMessage`分别具有非假值时（即，与空字符串、`false`、`undefined`、`0`、`NaN`或`null`不同的值），它们将可见。
- en: 'Now let''s develop the actual form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开发实际的表单：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We declare a new form using the HTML `form` tag. Once Angular 2 finds such tags
    in a template with an included form directive in the parent component, it will
    automatically enhance its functionality in order to be used as an Angular form.
    Once the form is processed by Angular, we can apply form validation and data-bindings.
    After this, using `#f="ngForm"`, we will define a local variable for the template
    called `f`, which allows us to reference to the current form. The last thing left
    from the form element is the submit event handler. We use a syntax that we're
    already familiar with `(ngSubmit)="expr"`, where in this case, the value of the
    expression is the call of the `addDeveloper` method attached to the component's
    controller.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HTML的`form`标签声明一个新的表单。一旦Angular 2在父组件的模板中找到带有包含表单指令的这样的标签，它将自动增强其功能，以便用作Angular表单。一旦表单被Angular处理，我们可以应用表单验证和数据绑定。之后，使用`#f="ngForm"`，我们将为模板定义一个名为`f`的局部变量，这允许我们引用当前的表单。表单元素中剩下的最后一件事是提交事件处理程序。我们使用一个我们已经熟悉的语法`(ngSubmit)="expr"`，在这种情况下，表达式的值是附加到组件控制器的`addDeveloper`方法的调用。
- en: Now, let's take a look at the `div` element with class name `control-group`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下类名为`control-group`的`div`元素。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is not an Angular-specific class; it is a `CSS` class defined
    by Bootstrap that we use in order to provide a better look and feel to the form.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不是一个特定于Angular的类；这是Bootstrap定义的一个`CSS`类，我们使用它来提供表单更好的外观和感觉。
- en: Inside of it, we can find a `label` element that doesn't have any Angular-specific
    markup and an input element that allows us to set the real name of the current
    developer. We set the control to be of a type text and declare its identifier
    to equal `realNameInput`. The required attribute is defined by the HTML5 specification
    and is used for validation. By using it on the element, we declare that it is
    required for this element to have a value. Although this attribute is not Angular-specific
    using the `ngControl` attribute, Angular will extend the semantics of the required
    attribute by including validation behavior. This behavior includes setting specific
    `CSS` classes on the control when its status changes and managing its state that
    the framework keeps internally.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们可以找到一个没有任何Angular特定标记的`label`元素和一个允许我们设置当前开发人员的真实姓名的输入元素。我们将控件设置为文本类型，并声明其标识符等于`realNameInput`。`required`属性由HTML5规范定义，并用于验证。通过在元素上使用它，我们声明这个元素需要有一个值。虽然这个属性不是特定于Angular的，但使用`ngControl`属性，Angular将通过包含验证行为来扩展`required`属性的语义。这种行为包括在控件状态改变时设置特定的`CSS`类，并管理框架内部保持的状态。
- en: The `ngControl` directive is a selector of the `NgControlName` directive. It
    enhances the behavior of the form controls by running validation over them for
    the change of their values, and applying specific classes during the controls'
    life cycle. You might be familiar with this from AngularJS 1.x where the form
    controls are decorated with the `ng-pristine`, `ng-invalid`, and `ng-valid` classes,
    and so on, in specific phases of their lifecycle.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngControl`指令是`NgControlName`指令的选择器。它通过在值更改时对它们运行验证并在控件生命周期期间应用特定类来增强表单控件的行为。您可能熟悉这一点，因为在AngularJS
    1.x中，表单控件在其生命周期的特定阶段装饰有`ng-pristine`、`ng-invalid`和`ng-valid`类等。'
- en: 'The following table summarizes the `CSS` classes that the framework adds to
    the form controls during their lifecycle:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了框架在表单控件生命周期中添加的`CSS`类：
- en: '| Classes | Description |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ng-untouched` | The control hasn''t been visited |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `ng-untouched` | 控件尚未被访问 |'
- en: '| `ng-touched` | The control has been visited |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `ng-touched` | 控件已被访问 |'
- en: '| `ng-pristine` | The control''s value hasn''t been changed |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `ng-pristine` | 控件的值尚未更改 |'
- en: '| `ng-dirty` | The control''s value has been changed |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `ng-dirty` | 控件的值已更改 |'
- en: '| `ng-valid` | All the validators attached to the control have returned `true`
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `ng-valid` | 控件附加的所有验证器都返回`true` |'
- en: '| `ng-invalid` | Any of the validators attached to the control has a `false`
    value |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `ng-invalid` | 控件附加的任何验证器具有`false`值 |'
- en: 'According to this table, we can define that we want all the input controls
    with invalid value to have a red border in the following way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个表，我们可以定义我们希望所有具有无效值的输入控件以以下方式具有红色边框：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The exact semantics behind the preceding `CSS` in the context of Angular 2 is
    to use a red border for all the input elements whose values have been changed
    and are invalid according to the validators attached to them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2的上下文中，前面的`CSS`的确切语义是对所有已更改且根据附加到它们的验证器无效的输入元素使用红色边框。
- en: Now, let's explore how we can attach different validation behavior to our controls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探讨如何将不同的验证行为附加到我们的控件上。
- en: Using the built-in form validators
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置表单验证器
- en: 'We already saw that we can alter validation behavior to any control by using
    the `required` attribute. Angular 2 provides two more built-in validators, as
    follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用`required`属性来改变任何控件的验证行为。Angular 2提供了另外两个内置验证器，如下所示：
- en: '`minlength`: Allows us to specify the minimum length of the value that a given
    control should have.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minlength`：允许我们指定给定控件应具有的值的最小长度。'
- en: '`maxlength`: Allows us to specify the maximum length of the value that a given
    control should have.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxlength`：允许我们指定给定控件应具有的值的最大长度。'
- en: 'These validators are defined with Angular 2 directives and can be used in the
    following way:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证器是用Angular 2指令定义的，可以以以下方式使用：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, we specify that we want the value of the input to be between `2` and
    `30` characters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们指定希望输入的值在`2`和`30`个字符之间。
- en: Defining custom control validators
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义控件验证器
- en: 'Another data property defined in the `Developer` class is the `email` field.
    Let''s add an input field for this property. Above the button in the preceding
    form, add the following markup:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Developer`类中定义的另一个数据属性是`email`字段。让我们为这个属性添加一个输入字段。在前面表单的按钮上方，添加以下标记：'
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can think of the `[(ngModel)]` attribute as an alternative to the `ng-model`
    directive from AngularJS 1.x. We will explain it in detail in the *Two-way data
    binding with Angular 2* section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`[(ngModel)]`属性视为AngularJS 1.x中`ng-model`指令的替代方法。我们将在*使用Angular 2进行双向数据绑定*部分详细解释它。
- en: 'Although Angular 2 provides a set of predefined validators, they are not enough
    for all the various formats our data can live in. Sometimes, we''ll need custom
    validation logic for our application-specific data. For instance, in this case,
    we want to define an e-mail validator. A typical regular expression, which works
    in general cases (but does not cover the entire specification that defines the
    format of the e-mail addresses), looks as follows: `/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Angular 2提供了一组预定义的验证器，但它们并不足以满足我们的数据可能存在的各种格式。有时，我们需要为特定于应用程序的数据定义自定义验证逻辑。例如，在这种情况下，我们想要定义一个电子邮件验证器。一个典型的正则表达式，在一般情况下有效（但并不涵盖定义电子邮件地址格式的整个规范），如下所示：`/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/`。
- en: 'In `ch6/ts/step-1/add_developer.ts`, define a function that accepts an instance
    of Angular 2 control as an argument and returns `null` if the control''s value
    is empty or matches the regular expression mentioned earlier, and `{ ''invalidEmail'':
    true }` otherwise:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在`ch6/ts/step-1/add_developer.ts`中，定义一个函数，该函数接受Angular 2控件的实例作为参数，并在控件的值为空或与前面提到的正则表达式匹配时返回`null`，否则返回`{
    ''invalidEmail'': true }`：'
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, from the modules `angular2/common` and `angular2/core` import `NG_VALIDATORS`
    and `Directive`, and wrap this validation function within the following directive:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从模块`angular2/common`和`angular2/core`导入`NG_VALIDATORS`和`Directive`，并将此验证函数包装在以下指令中：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we defined a single multiprovider for the token `NG_VALIDATORS`.
    Once we inject the value associated with this token, we'll get an array with all
    the validators attached to the given control (for reference, take a look at the
    section for multiproviders in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们为令牌`NG_VALIDATORS`定义了一个多提供者。一旦我们注入与该令牌关联的值，我们将获得一个包含所有附加到给定控件的验证器的数组（有关多提供者的部分，请参阅[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "第5章。Angular 2中的依赖注入"), *Angular 2中的依赖注入*）。
- en: 'The only two steps left in order to make our custom validation work are to
    first add the `email-input` attribute to the e-mail control:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的自定义验证工作的唯一两个步骤是首先将`email-input`属性添加到电子邮件控件中：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, to add the directive to the list used by the component `AddDeveloper`
    directives:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将指令添加到组件`AddDeveloper`指令使用的列表中：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We're using an external template for the `AddDeveloper` control. There's no
    ultimate answer to whether a given template should be externalized or inlined
    within the component with `templateUrl` or `template`, respectively. The best
    practice states that we should inline the short templates and externalize the
    longer ones, but there's no specific definition as to which templates are considered
    short and which are long. The decision on whether the template should be used
    inline or put into an external file depends on the developer's personal preferences
    or common conventions within the organization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`AddDeveloper`控件的外部模板。关于给定模板是否应该被外部化或内联在具有`templateUrl`或`template`的组件中，没有最终答案。最佳实践规定，我们应该内联短模板并外部化较长的模板，但没有具体定义哪些模板被认为是短的，哪些是长的。模板应该内联还是放入外部文件的决定取决于开发人员的个人偏好或组织内的常见惯例。
- en: Using select inputs with Angular
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Angular与选择输入
- en: As the next step, we should allow the user of the application to enter the technology
    into which the input developer has the most proficiency. We can define a list
    of technologies and show them in the form as a select input.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们应该允许应用程序的用户输入开发人员最精通的技术。我们可以定义一个技术列表，并在表单中显示为选择输入。
- en: 'In the `AddDeveloper` class, add the `technologies` property:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AddDeveloper`类中，添加`technologies`属性：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now in the template, just above the `submit` button, add the following markup:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模板中，在`submit`按钮的上方，添加以下标记：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just like for the input elements we declared earlier, Angular 2 will add the
    same classes depending on the state of the select input. In order to show red
    border around the select element when its value is invalid, we need to alter the
    `CSS` rules:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前声明的输入元素一样，Angular 2将根据选择输入的状态添加相同的类。为了在选择元素的值无效时显示红色边框，我们需要修改`CSS`规则：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that inlining all the styles in our components' declaration could be
    a bad practice, because this way, they won't be reusable. What we can do is extract
    all the common styles across our components into separate files. The `@Component`
    decorator has a property called `styleUrls` of type `array` where we can add a
    reference to the extracted styles used by the given component. This way, we can
    inline only the component-specific styles if required.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将所有样式内联到组件声明中可能是一种不好的做法，因为这样它们就无法重复使用。我们可以将所有组件中的通用样式提取到单独的文件中。`@Component`装饰器有一个名为`styleUrls`的属性，类型为`array`，我们可以在其中添加对给定组件使用的提取样式的引用。这样，如果需要，我们可以仅内联特定于组件的样式。
- en: Right after this, we will declare the name of the control to be equal to "technology"
    using `ngControl="technology"`. By using the `required` attribute, we will declare
    that the user of the application must specify the technology into which the current
    developer is proficient. Let's skip the `[(ngModel)]` attribute for the last time
    and see how we can define the select element's options.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将使用`ngControl="technology"`声明控件的名称等于"technology"。通过使用`required`属性，我们将声明应用程序的用户必须指定当前开发人员精通的技术。让我们最后一次跳过`[(ngModel)]`属性，看看如何定义选择元素的选项。
- en: 'Inside the `select` element, we will define the different options using:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select`元素内部，我们将使用以下方式定义不同的选项：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a syntax we're already familiar with. We will simply iterate over all
    the technologies defined within the `AddDeveloper` class, and for each technology,
    we will show an option element with a value of the technology name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经熟悉的语法。我们将简单地遍历`AddDeveloper`类中定义的所有技术，并对于每种技术，我们将显示一个值为技术名称的选项元素。
- en: Using the NgForm directive
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NgForm指令
- en: 'We already mentioned that the form directive enhances the HTML5 form''s behavior
    by adding some additional Angular 2-specific logic. Now, let''s take a step back
    and take a look at the form that surrounds the input elements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，表单指令通过添加一些额外的Angular 2特定逻辑来增强HTML5表单的行为。现在，让我们退一步，看看包围输入元素的表单：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding snippet, we defined a new identifier called `f`, which references
    to the form. We can think of the form as a composition of controls; we can access
    the individual controls through the form's controls property. On top of this,
    the form has the **touched**, **untouched**, **pristine**, **dirty**, **invalid**,
    and **valid** properties, which depend on the individual controls defined within
    the form. For example, if none of the controls within the form has been touched,
    then the form itself is going to be with the status untouched. However, if any
    of the controls in the form has been touched at least once, the form will be with
    the status touched as well. Similarly the form will be valid only if all its controls
    are valid.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们定义了一个名为`f`的新标识符，它引用了表单。我们可以将表单视为控件的组合；我们可以通过表单的controls属性访问各个控件。此外，表单还具有**touched**、**untouched**、**pristine**、**dirty**、**invalid**和**valid**属性，这些属性取决于表单中定义的各个控件。例如，如果表单中的控件都没有被触摸过，那么表单本身的状态就是untouched。然而，如果表单中的任何控件至少被触摸过一次，那么表单的状态也将是touched。同样，只有当表单中的所有控件都有效时，表单才会有效。
- en: 'In order to illustrate the usage of the `form` element, let''s define a component
    with the selector `control-errors`, which shows the current errors for a given
    control. We can use it in the following way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`form`元素的用法，让我们定义一个带有选择器`control-errors`的组件，该组件显示给定控件的当前错误。我们可以这样使用它：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we've also added the `maxlength` validator to the `realName` control.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还向`realName`控件添加了`maxlength`验证器。
- en: 'The `control-errors` element has the following properties:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`control-errors`元素具有以下属性：'
- en: '`control`: Declares the name of the control we want to show errors for.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`control`：声明我们想要显示错误的控件的名称。'
- en: '`errors`: Creates a mapping between control error and an error message.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errors`：创建控制错误和错误消息之间的映射。'
- en: 'Now add the following imports in `add_developer.ts`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`add_developer.ts`中添加以下导入：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In these imports, the `NgControl` class is the abstract class that represents
    the individual form components, `NgForm` represents the Angular forms, and `Host`
    is a parameter decorator related to the dependency injection mechanism, which
    we already covered in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些导入中，`NgControl`类是表示单个表单组件的抽象类，`NgForm`表示Angular表单，`Host`是与依赖注入机制相关的参数装饰器，我们已经在[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "第5章。Angular 2中的依赖注入")中介绍过，*Angular 2中的依赖注入*。
- en: 'Here is a part of the component''s definition:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是组件定义的一部分：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `ControlErrors` component defines two inputs: `control`—the name of the
    control declared with the `ngControl` directive (the value of the `ngControl`
    attribute)—and `errors`—the mapping between an error and an error message. They
    can be specified respectively by the `control` and the `errors` attributes of
    the `control-errors` element.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ControlErrors`组件定义了两个输入：`control`——使用`ngControl`指令声明的控件的名称（`ngControl`属性的值）——和`errors`——错误和错误消息之间的映射。它们可以分别由`control-errors`元素的`control`和`errors`属性指定。'
- en: 'For instance, if we have control:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有控件：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can declare its associated `control-errors` component by using the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式声明其关联的`control-errors`组件：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside of the `currentError` getter, in the preceding snippet, we need to do
    the following two things:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面片段中的`currentError` getter中，我们需要做以下两件事：
- en: Find a reference to the component declared with the `control` attribute.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到使用`control`属性声明的组件的引用。
- en: Return the error message associated with any of the errors that make the current
    control invalid.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回与使当前控件无效的任何错误相关联的错误消息。
- en: 'Here is a snippet that implements this behavior:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现此行为的代码片段：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the first line of the implementation of `currentError`, we get the target
    control by using the `controls` property of the injected form. It is of the type
    `{[key: string]: AbstractControl}`, where the key is the name of the control we''ve
    declared with the `ngControl` directive. Once we have a reference to the instance
    of the target control, we can check whether its status is touched (that is, whether
    it has been focused), and if it is, we can loop over all the errors within the
    `errors` property of the instance of `ControlError`. The `map` function will return
    an array with either an error message or a `null` value. The only thing left is
    to filter all the `null` values and get only the error messages. Once we get the
    error messages for each error, we will return the last one by popping it from
    the `errorMessages` array.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '在`currentError`的实现的第一行中，我们使用注入表单的`controls`属性获取目标控件。它的类型是`{[key: string]: AbstractControl}`，其中键是我们用`ngControl`指令声明的控件的名称。一旦我们获得了目标控件的实例引用，我们可以检查它的状态是否被触摸（即是否已聚焦），如果是，我们可以循环遍历`ControlError`实例的`errors`属性中的所有错误。`map`函数将返回一个包含错误消息或`null`值的数组。唯一剩下的事情就是过滤掉所有的`null`值，并且只获取错误消息。一旦我们获得了每个错误的错误消息，我们将通过从`errorMessages`数组中弹出它来返回最后一个。'
- en: 'The end result should look as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应如下所示：
- en: '![Using the NgForm directive](../images/00027.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用NgForm指令](../images/00027.jpeg)'
- en: Fig. 5
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图5
- en: If you experience any problems during the implementation of the `ControlErrors`
    component, you can take a look at its implementation at `ch6/ts/multi-page-template-driven/add_developer.ts`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实现`ControlErrors`组件的过程中遇到任何问题，您可以查看`ch6/ts/multi-page-template-driven/add_developer.ts`中的实现。
- en: 'The `hasError` method of every control accepts as an argument an error message
    identifier, which is defined by the validator. For instance, in the preceding
    example where we defined the custom e-mail validator, we will return the following
    object literal when the input control has an invalid value: `{ ''invalidEmail'':
    true }`. If we apply the `ControlErrors` component to the e-mail control, its
    declaration should look as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '每个控件的`hasError`方法接受一个错误消息标识符作为参数，该标识符由验证器定义。例如，在前面定义自定义电子邮件验证器的示例中，当输入控件具有无效值时，我们将返回以下对象字面量：`{
    ''invalidEmail'': true }`。如果我们将`ControlErrors`组件应用于电子邮件控件，则其声明应如下所示：'
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Two-way data-binding with Angular 2
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2的双向数据绑定
- en: One of the most famous rumors about Angular 2 was that the two-way data-binding
    functionality was removed because of the enforced unidirectional dataflow. This
    is not exactly true; the Angular 2's form module implements a directive with the
    selector `[(ngModel)]`, which allows us to easily achieve data-binding in two
    directions—from the view to the model and from the model to the view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Angular 2最著名的传言之一是，双向数据绑定功能被移除，因为强制的单向数据流。这并不完全正确；Angular 2的表单模块实现了一个带有选择器`[(ngModel)]`的指令，它允许我们轻松地实现双向数据绑定——从视图到模型，以及从模型到视图。
- en: 'Let''s take a look at the following simple component:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的组件：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we imported the directive `NgModel` from the `angular2/common`
    package. Later, in the template, we set the attribute `[(ngModel)]` to the value
    `name`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们从`angular2/common`包中导入了指令`NgModel`。稍后，在模板中，我们将属性`[(ngModel)]`设置为值`name`。
- en: At first, the syntax `[(ngModel)]` might seem a little bit unusual. From [Chapter
    4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582 "Chapter 4. Getting
    Started with Angular 2 Components and Directives"), *Getting Started with Angular
    2 Components and Directives*, we know that the syntax `(eventName)` is used for
    binding to events (or outputs) triggered by a given component. On the other hand,
    we use the syntax `[propertyName]="foobar"` to achieve one-way data-binding by
    setting the value of the property (or in the terminology of the Angular 2 components,
    the input) with the name `propertyName` to the result of the evaluation of the
    expression `foobar`. The syntax `NgModel` just combines both in order to achieve
    data-binding in two directions. That's why we can think of it more like a syntax
    sugar, rather than a new concept. One of the main advantages of this syntax compared
    to AngularJS 1.x is that we can tell which bindings are one-way and which are
    two-way only by looking at the template.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，语法`[(ngModel)]`可能看起来有点不寻常。从[第4章](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "第4章。使用Angular 2组件和指令入门")*使用Angular 2组件和指令入门*中，我们知道语法`(eventName)`用于绑定由给定组件触发的事件（或输出）。另一方面，我们使用语法`[propertyName]="foobar"`通过将属性（或在Angular
    2组件术语中的输入）的值设置为表达式`foobar`的评估结果来实现单向数据绑定。`NgModel`语法将两者结合起来，以实现双向数据绑定。这就是为什么我们可以将其视为一种语法糖，而不是一个新概念。与AngularJS
    1.x相比，这种语法的主要优势之一是我们可以通过查看模板来判断哪些绑定是单向的，哪些是双向的。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just like `(click)` has its canonical syntax `on-click` and `[propertyName]`
    has `bind-propertyName`, the alternative syntax of `[(ngModel)]` is `bindon-ngModel`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`(click)`有其规范语法`on-click`和`[propertyName]`有`bind-propertyName`一样，`[(ngModel)]`的替代语法是`bindon-ngModel`。
- en: 'If you open `http://localhost:5555/dist/dev/ch6/ts/simple-two-way-data-binding/`,
    you will see the following result:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`http://localhost:5555/dist/dev/ch6/ts/simple-two-way-data-binding/`，你会看到以下结果：
- en: '![Two-way data-binding with Angular 2](../images/00028.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用Angular 2进行双向数据绑定](../images/00028.jpeg)'
- en: Fig. 6
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图6
- en: Once you change the value of the input box, it will automatically update the
    following label.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你改变输入框的值，它将自动更新以下标签。
- en: 'We already used the `NgModel` directive in the preceding templates. For example,
    we bound to the developer''s e-mail using:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的模板中使用了`NgModel`指令。例如，我们绑定了开发人员的电子邮件：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This way, the value of the e-mail property of the developer object attached
    to the `AddDeveloper` component's instance is going to be updated once we change
    the value of the text input.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一旦我们改变文本输入的值，附加到`AddDeveloper`组件实例的开发人员对象的电子邮件属性的值就会被更新。
- en: Storing the form data
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储表单数据
- en: 'Let''s peek at the interface of the `AddDeveloper` component''s controller
    again:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看`AddDeveloper`组件控制器的接口：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It has a field of the type `Developer`, and we bind the form controls to its
    properties using the `NgModel` directive. The class also has a method called `addDeveloper`,
    which is being invoked on the submission of the form. We declare this by binding
    to the `submit` event using:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`Developer`类型的字段，我们使用`NgModel`指令将表单控件绑定到其属性。该类还有一个名为`addDeveloper`的方法，该方法在表单提交时被调用。我们通过绑定`submit`事件来声明这一点：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding snippet, we can notice two more things. We got a reference
    to the form using `#f="ngForm"` and we bound the disabled property of the button
    to the expression: `!f.form.valid`. We already described the `NgForm` control
    in the previous section; its valid property will have a value true once all the
    controls within the form have valid values.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们可以注意到两件事。我们使用`#f="ngForm"`引用了表单，并将按钮的disabled属性绑定到表达式`!f.form.valid`。我们已经在前一节中描述了`NgForm`控件；一旦表单中的所有控件都具有有效值，其valid属性将为true。
- en: 'Now, let''s suppose we''ve entered valid values for all the input controls
    in the form. This means that its **submit** button will be enabled. Once we press
    *Enter* or we click on the **Add** button, the `addDeveloper` method will be invoked.
    The following is a sample implementation of this method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们已经为表单中的所有输入控件输入了有效值。这意味着其**submit**按钮将被启用。一旦我们按下*Enter*或点击**Add**按钮，将调用`addDeveloper`方法。以下是此方法的示例实现：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Initially, we set the `id` property of the current developer to equal the total
    number of developers in `DeveloperCollection`, plus one. Later, we added the developer
    to the collection and set the value of the `successMessage` property. Right after
    this, we set the property submitted to equal to `true`, which will result in hiding
    the form.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将当前开发人员的“id”属性设置为“DeveloperCollection”中开发人员总数加一。稍后，我们将开发人员添加到集合中，并设置“successMessage”属性的值。就在这之后，我们将提交属性设置为“true”，这将导致隐藏表单。
- en: Listing all the stored developers
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有存储的开发人员
- en: Now that we can add a new entry to the developers' collection, let's show a
    list of all the developers on the front page of the "Coders repository".
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向开发人员集合添加新条目了，让我们在“Coders repository”的首页上显示所有开发人员的列表。
- en: 'Open the file `ch6/ts/step-1/home.ts` and enter the following content:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件“ch6/ts/step-1/home.ts”并输入以下内容：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is nothing new to us here. We extend the functionality of the `Home` component
    by providing an external template and implementing the `getDevelopers` method,
    which delegates its call to the instance of `DeveloperCollection` that is injected
    in the constructor.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说并不新鲜。我们通过提供外部模板并实现`getDevelopers`方法来扩展`Home`组件的功能，该方法将其调用委托给构造函数中注入的`DeveloperCollection`实例。
- en: 'The template itself is something that we''re already familiar with as well:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本身也是我们已经熟悉的东西：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We list all the developers as rows within an HTML table. For each developer,
    we check the status of its popular flag. If its value is `true`, then for the
    **Popular** column, we show a span with the text `Yes`, otherwise we set the text
    to `No`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有开发人员列为HTML表格中的行。对于每个开发人员，我们检查其popular标志的状态。如果其值为“true”，那么在**Popular**列中，我们显示一个带有文本“Yes”的span，否则我们将文本设置为“No”。
- en: 'When you enter a few developers in the **Add Developer** page and you navigate
    to the home page after that, you should see a result similar to the following
    screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在**添加开发人员**页面输入了一些开发人员，然后导航到主页时，您应该看到类似以下截图的结果：
- en: '![Listing all the stored developers](../images/00029.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![列出所有存储的开发人员](../images/00029.jpeg)'
- en: Fig. 7
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图7
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the complete functionality of the application at `ch6/ts/multi-page-template-driven`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch6/ts/multi-page-template-driven`找到应用程序的完整功能。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have explained the basics of routing in Angular 2\. We took a look
    at how we can define different routes and implement the components associated
    with them that are displayed on route change. In order to link to the different
    routes, we explained `routerLink`, and we also used the `router-outlet` directives
    for pointing out where the components associated with the individual routes should
    be rendered.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了Angular 2中路由的基础知识。我们看了一下如何定义不同的路由，并实现与它们相关的组件，这些组件在路由更改时显示出来。为了链接到不同的路由，我们解释了`routerLink`，并且我们还使用了`router-outlet`指令来指出与各个路由相关的组件应该被渲染的位置。
- en: Another thing we took a look at was the Angular 2 forms functionality with built-in
    and custom validation. After this, we explained the `NgModel` directive, which
    provides to us two-way data-binding.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了Angular 2表单功能，包括内置和自定义验证。之后，我们解释了`NgModel`指令，它为我们提供了双向数据绑定。
- en: In the next chapter, we will cover how we can develop model-driven forms and
    child and parametrized routes, use the `Http` module for making RESTful calls,
    and transform data with custom pipes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何开发基于模型的表单和子路由以及参数化路由，使用`Http`模块进行RESTful调用，并使用自定义管道转换数据。
