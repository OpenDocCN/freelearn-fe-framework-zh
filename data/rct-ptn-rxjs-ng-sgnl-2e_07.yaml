- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Sharing Data between Angular Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 组件之间的数据共享
- en: Sharing data between components is a very common use case in web applications.
    Angular provides many approaches for communicating between parent and child components,
    such as the popular `@Input()` and `@Output()` decorator patterns. The `@Input()`
    decorator allows parent components to provide data to their child components,
    while the `@Output()` decorator allows the child component to send data to a parent
    component. That’s great, but when data needs to be shared between components that
    are either deeply nested or not immediately connected, those kinds of techniques
    become less efficient and difficult to maintain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中，组件之间的数据共享是一个非常常见的用例。Angular 提供了许多在父组件和子组件之间进行通信的方法，例如流行的 `@Input()`
    和 `@Output()` 装饰器模式。`@Input()` 装饰器允许父组件向其子组件提供数据，而 `@Output()` 装饰器允许子组件向父组件发送数据。这很好，但当数据需要在深度嵌套或非直接连接的组件之间共享时，这些技术变得效率低下且难以维护。
- en: So, what’s the best way to share data between sibling components? This is the
    heart of this chapter. We will start by explaining the sharing data requirement,
    before walking through the different steps to implement the reactive pattern for
    sharing data between sibling components in our app. Finally, we will introduce
    Angular’s new Deferrable Views feature to maximize our app’s performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在兄弟组件之间共享数据最好的方法是什么？这正是本章的核心。我们将首先解释共享数据的需求，然后逐步介绍如何在我们的应用程序中实现兄弟组件之间共享数据的响应式模式。最后，我们将介绍
    Angular 的新特性可延迟视图，以最大化应用程序的性能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Defining the sharing data requirement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义共享数据需求
- en: Exploring the reactive pattern to share data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据共享的响应式模式
- en: Leveraging Deferrable Views in Angular 17
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Angular 17 中的可延迟视图
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of RxJS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节假设您已经对 RxJS 有基本的了解。
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的源代码可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap07)找到。
- en: Defining the sharing data requirement
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义共享数据需求
- en: 'Let’s assume that we have four components – **C1**, **C2**, **C3**, and **C4**
    – that do not have any relationship with each other, and there is information
    – **DATA** – shared between those components:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有四个组件 – **C1**、**C2**、**C3** 和 **C4** – 它们之间没有任何关系，并且这些组件之间共享信息 – **数据**：
- en: '![Figure 7.1 – Shared data between components](img/B21180_07_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 组件之间的共享数据](img/B21180_07_1.jpg)'
- en: Figure 7.1 – Shared data between components
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 组件之间的共享数据
- en: The components can update and consume **DATA** at the same time. But at any
    time during the process, the components should be able to access the last value
    of **DATA**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以同时更新和消费**数据**。但在任何过程中，组件都应该能够访问**数据**的最后一个值。
- en: Now, let’s make that explanation clearer with a more concrete example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个更具体的例子来使这个解释更加清晰。
- en: In our recipe application, when the user clicks on one recipe, it gets selected,
    but we want all components to have access to the last selected recipe by the user.
    In that case, the selected recipe represents our shared data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的食谱应用程序中，当用户点击一个食谱时，它会被选中，但我们希望所有组件都能访问用户最后选中的食谱。在这种情况下，选中的食谱代表我们的共享数据。
- en: One of the components that will need access to the selected recipe is the `RecipeDetailsComponent`
    component, as it will display the details of the selected recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要访问选中食谱的组件之一是 `RecipeDetailsComponent` 组件，因为它将显示选中食谱的详细信息。
- en: Without further ado, in the next section, let’s see how we can make this data
    available to everyone in a reactive way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，在下一节中，让我们看看如何以响应式的方式使这些数据对每个人可用。
- en: Exploring the reactive pattern to share data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据共享的响应式模式
- en: Angular services are powerful and efficient for creating common references to
    share both data and business logic between components. We will combine Angular
    services with Observables – more specifically, `BehaviorSubject` instances – to
    create stateful, reactive services that will allow us to synchronize the state
    efficiently across an entire application. So, in the following subsections, let’s
    explain the steps to implement a reactive pattern to share data between unrelated
    or sibling components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 服务在创建组件之间共享数据和业务逻辑的常见引用方面非常强大和高效。我们将结合 Angular 服务和 Observables – 更具体地说，`BehaviorSubject`
    实例 – 来创建具有状态的、反应式服务，这将使我们能够高效地在整个应用程序中同步状态。因此，在接下来的小节中，让我们解释实现反应式模式以在无关或兄弟组件之间共享数据的步骤。
- en: Step 1 – Creating a shared service
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 1 – 创建共享服务
- en: 'First, we will create an Angular service called `SharedDataService` using the
    Angular CLI, as usual under the `src/app/core/services` folder:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 Angular CLI 创建一个名为 `SharedDataService` 的 Angular 服务，就像通常在 `src/app/core/services`
    文件夹下做的那样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we named the service `SharedDataService` for demonstration purposes. While
    it’s true that we already have a service named `RecipesService` that could have
    accommodated the shared data, the purpose of this chapter is to underscore the
    broader concept of data sharing. Therefore, we chose a more generic term. However,
    in your own application, it’s recommended to use specific and descriptive names
    such as `RecipesService` or another name that accurately reflects the role and
    domain of the service. A name that accurately reflects the purpose of your service
    is crucial for clarity and maintainability, especially in a framework such as
    Angular where conventions can guide developers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为了演示目的将服务命名为 `SharedDataService`。虽然我们确实已经有一个名为 `RecipesService` 的服务可以容纳共享数据，但本章的目的是强调数据共享的更广泛概念。因此，我们选择了一个更通用的术语。然而，在你的应用程序中，建议使用特定且描述性的名称，如
    `RecipesService` 或其他准确反映服务角色和领域的名称。一个准确反映服务目的的名称对于清晰性和可维护性至关重要，尤其是在像 Angular 这样的框架中，其中约定可以指导开发者。
- en: 'Then, in the `SharedDataService` class, we need to create the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `SharedDataService` 类中，我们需要创建以下内容：
- en: 'A private `BehaviorSubject` instance called `selectedRecipeSubject` that emits
    the value of the currently selected recipe, which represents the data to be shared:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `selectedRecipeSubject` 的私有 `BehaviorSubject` 实例，它发出当前选定食谱的值，这代表要共享的数据：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `selectedRecipeSubject` has `Recipe` as the type and `undefined` as the
    initial value since initially, we don’t have any selected value.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`selectedRecipeSubject` 的类型是 `Recipe`，初始值是 `undefined`，因为最初我们没有选定任何值。
- en: Also, `selectedRecipeSubject` is declared as `private` to ensure that it’s only
    accessible within `SharedDataService`, where it’s defined, protecting it from
    external manipulation. Otherwise, any external process could have access to the
    property and consequently call the next method and change the emissions, which
    is dangerous. This encapsulation is important for maintaining control over the
    state and preventing unintended changes.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`selectedRecipeSubject` 被声明为 `private`，以确保它只能在定义它的 `SharedDataService` 内部访问，从而保护它免受外部操作。否则，任何外部进程都可以访问该属性，并随后调用下一个方法并更改发射，这是危险的。这种封装对于维护对状态的控制和防止意外更改非常重要。
- en: 'A public Observable, named `selectedRecipe$`, extracted from `selectedRecipeSubject`
    to handle data as an Observable:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `selectedRecipeSubject` 中提取的公共 Observable，命名为 `selectedRecipe$`，用于处理数据作为 Observable：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we used the `asObservable()` method available in the `Subject` type to
    derive a read-only Observable from `selectedRecipeSubject`. This ensures that
    the emissions of `selectedRecipeSubject` are only consumed in read-only mode,
    preventing external processes from altering the `selectedRecipeSubject` value.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `Subject` 类型中可用的 `asObservable()` 方法，从 `selectedRecipeSubject` 中派生出只读
    Observable。这确保了 `selectedRecipeSubject` 的发射仅在只读模式下被消费，防止外部进程更改 `selectedRecipeSubject`
    的值。
- en: 'A method called `updateSelectedRecipe` that will update the shared data, which
    is the selected recipe:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种名为 `updateSelectedRecipe` 的方法，用于更新共享数据，即选定的食谱：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method only calls `next` on `selectedRecipeSubject` to notify all subscribers
    of the last selected recipe passed as a parameter. The process that updates the
    selected recipe will call this method, which we will discuss in the next step.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法仅在 `selectedRecipeSubject` 上调用 `next`，以通知所有订阅者作为参数传递的最后一个选定的食谱。更新选定食谱的过程将调用此方法，我们将在下一步讨论。
- en: 'This is what the service looks like after putting all the pieces together:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将所有部件组合在一起后的服务外观：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have prepared the groundwork by creating our shared data service
    and defined the behavior subject that will hold the shared data, let’s see how
    we can update the shared data in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过创建我们的共享数据服务和定义将保存共享数据的行为主题来打下基础，让我们看看我们如何在下一节中更新共享数据。
- en: Step 2 – Updating the last selected recipe
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 - 更新最后选择的食谱
- en: 'We should update the shared `selectedRecipe` instance when the user clicks
    on one of the recipe cards in the `RecipesListComponent` component. As a reminder,
    here are the recipe cards in our `Recipe` app:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在`RecipesListComponent`组件中点击其中一个食谱卡片时，我们应该更新共享的`selectedRecipe`实例。作为提醒，以下是我们`Recipe`应用程序中的食谱卡片：
- en: '![Figure 7.2 – List of recipes](img/B21180_07_2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 食谱列表](img/B21180_07_2.jpg)'
- en: Figure 7.2 – List of recipes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 食谱列表
- en: 'In order to update the shared `selectedRecipe` instance when the user clicks
    on the card, we need to incorporate the `(click)` event output in the `RecipesListComponent`
    HTML template, which triggers the execution of the `editRecipe(recipe)` method.
    This is the HTML code required:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户点击卡片时更新共享的`selectedRecipe`实例，我们需要在`RecipesListComponent` HTML模板中结合`(click)`事件输出，这会触发`editRecipe(recipe)`方法的执行。这是所需的HTML代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `(click)` event binding is applied to each card, ensuring that when clicked,
    the `editRecipe(recipe)` method is invoked to update the `selectedRecipe` instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`(click)`事件绑定应用于每个卡片，确保点击时调用`editRecipe(recipe)`方法以更新`selectedRecipe`实例。
- en: 'In `RecipesListComponent`, we implement the `editRecipe` method as follows
    :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RecipesListComponent`中，我们按照以下方式实现`editRecipe`方法：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `editRecipe` method takes the selected recipe as the input and performs
    two actions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`editRecipe`方法接受所选食谱作为输入并执行两个操作：'
- en: 'It notifies `selectedRecipeSubject` that the value of `selectedRecipe` has
    changed by calling the `updateSelectedRecipe(recipe:Recipe)` method, available
    in `SharedDataService`. So, we should inject the `SharedDataService` service in
    `RecipesListComponent` as follows :'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过调用`SharedDataService`中可用的`updateSelectedRecipe(recipe:Recipe)`方法来通知`selectedRecipeSubject`，`selectedRecipe`的值已更改。因此，我们应该按照以下方式在`RecipesListComponent`中注入`SharedDataService`服务：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It displays the details of the recipe by routing to `RecipeDetailsComponent`,
    the standalone component responsible for rendering and displaying the details
    of a recipe. We’ve added a route configuration in the `app-routing-module.ts`
    file as follows :'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过路由到`RecipeDetailsComponent`来显示食谱的详细信息，这是负责渲染和显示食谱详细信息的独立组件。我们在`app-routing-module.ts`文件中添加了以下路由配置：
- en: '[PRE8]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, we have put in place the mechanism that updates the value of
    the shared data. Now, all that is left is to listen to the shared data and consume
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经建立了更新共享数据值的机制。现在，剩下的只是监听共享数据并消费它。
- en: Step 3 – Consuming the last selected recipe
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 - 消费最后选择的食谱
- en: 'In the `RecipeDetails` component, we need to consume the last selected recipe
    in order to display its details. So, again, we need to inject `SharedDataService`
    and define the `selectedRecipe$` Observable – which will emit the last selected
    recipe – as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RecipeDetails`组件中，我们需要消费最后选择的食谱以便显示其详细信息。因此，我们再次需要注入`SharedDataService`并定义`selectedRecipe$`
    Observable——它将发出最后选择的食谱——如下所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we will subscribe to the `selectedRecipe$` Observable using the `async`
    pipe in the `RecipeDetailsComponent` HTML template in order to display the selected
    recipe’s details, as follows :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`RecipeDetailsComponent` HTML模板中的`async` pipe订阅`selectedRecipe$` Observable，以便显示所选食谱的详细信息，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that’s it – this is how you can share data between unrelated components
    throughout the application!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——这就是你如何在应用程序中共享无关组件之间的数据的方法！
- en: 'Now, we can use the latest value of the recipe everywhere – we only have to
    inject `SharedDataService` into the component that needs the shared data and subscribe
    to the public Observable that emits the read-only value. For example, we can add
    this code in `HeaderComponent` to display the title of the last selected recipe
    in the application’s header:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何地方使用食谱的最新值——我们只需要将`SharedDataService`注入到需要共享数据的组件中，并订阅发出只读值的公共Observable。例如，我们可以在`HeaderComponent`中添加以下代码以在应用程序的标题中显示最后选择的食谱的标题：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we change the shared value in this component, all other components that listen
    to the shared data will get notified to update their processes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个组件中更改共享值，所有监听共享数据的其他组件都将收到通知以更新其过程。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We used this pattern in [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083), *Combining
    Streams*, to share the value of the filter in `RecipesFilterComponent` with `RecipesListComponent`
    instances, and then we combined the streams to display the filtered results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第五章*](B21180_05.xhtml#_idTextAnchor083) 中使用了这种模式，即 *结合流*，将 `RecipesFilterComponent`
    中的过滤器值与 `RecipesListComponent` 实例共享，然后我们将流合并以显示过滤后的结果。
- en: Wrapping up the data-sharing reactive pattern
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结数据共享的反应式模式
- en: 'To summarize everything, here’s a wrap-up of the steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是步骤的总结：
- en: Begin by creating an Angular service that will be shared across components.
    Within this service, define a private `BehaviorSubject` instance that will emit
    the shared value to its subscribers, remembering to specify the type of data emitted
    by `BehaviorSubject` and initialize it with the initial value of the shared data.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，创建一个将在组件间共享的 Angular 服务。在这个服务中，定义一个私有的 `BehaviorSubject` 实例，该实例将向其订阅者发出共享值，记得指定
    `BehaviorSubject` 发出的数据类型，并用共享数据的初始值初始化它。
- en: 'It’s important to note that we use `BehaviorSubject` for two primary reasons:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们使用 `BehaviorSubject` 有两个主要原因：
- en: It allows us to broadcast shared data to multiple observers.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们将共享数据广播到多个观察者。
- en: It stores the latest value emitted to its observers, and any new subscriber
    immediately receives the last emitted value upon subscription.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它存储发送给其观察者的最新值，并且任何新的订阅者一旦订阅，就会立即接收到最后发出的值。
- en: Next, define a public Observable within the shared service to hold the read-only
    shared value.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在共享服务中定义一个公共 Observable，以保存只读的共享值。
- en: Implement an `update` method within the shared service to update the shared
    value by calling the `next` method of the `Subject` type to emit the updated value
    to subscribers.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在共享服务中实现一个 `update` 方法，通过调用 `Subject` 类型的 `next` 方法来更新共享值，并将更新的值发出给订阅者。
- en: Inject the shared service in the component responsible for updating the value
    of the shared data and call the `update` method implemented in the service.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在负责更新共享数据值的组件中注入共享服务，并调用服务中实现的 `update` 方法。
- en: Inject the shared service in the component that consumes the value of the shared
    data and subscribe to the exposed Observable in the service.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消费共享数据值的组件中注入共享服务，并订阅服务中公开的 Observable。
- en: 'This reactive sharing data pattern has many benefits:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反应式共享数据模式有许多优点：
- en: It improves the sharing of data between unrelated components.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提高了无关组件之间数据共享的效率。
- en: It manages mutability risk. In fact, as we only expose the read-only extracted
    Observable to other consumers and keep `BehaviorSubject` private, we prevent shared
    data from being modified by subscribers, which can lead to data corruption and
    unexpected behavior.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它管理可变性风险。事实上，我们只向其他消费者公开只读的提取的 Observable，并保持 `BehaviorSubject` 为私有，从而防止共享数据被订阅者修改，这可能导致数据损坏和意外行为。
- en: It makes communication between components easier as you will only have to inject
    the shared service where you need it and just take care of updating the data.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得组件间的通信更加容易，因为你只需在需要的地方注入共享服务，并只关注数据的更新。
- en: As far as I’m concerned, this is the simplest way to share data between unrelated
    components in Angular and manage the application state. This works perfectly in
    many situations, but for big applications where there are a lot of user interactions
    and multiple data sources, managing states in services can become complicated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就我而言，这是在 Angular 中在无关组件之间共享数据并管理应用程序状态的最简单方法。这在许多情况下都工作得很好，但对于有大量用户交互和多个数据源的大型应用程序来说，在服务中管理状态可能会变得复杂。
- en: 'In those cases, we can use a state management library to manage the state of
    our application. There are many great state management libraries out there to
    manage states in Angular, all with one thing in common – they are built on top
    of RxJS Observables, and the state is stored in `BehaviorSubject`. The most popular
    state management library is NgRx, which you can find out more about here: [https://ngrx.io/guide/store](https://ngrx.io/guide/store).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以使用状态管理库来管理我们应用程序的状态。有许多优秀的状态管理库可以用于 Angular 的状态管理，它们都有一个共同点——它们都是建立在
    RxJS Observables 之上的，状态存储在 `BehaviorSubject` 中。最受欢迎的状态管理库是 NgRx，你可以在[https://ngrx.io/guide/store](https://ngrx.io/guide/store)了解更多信息。
- en: Data-sharing mechanisms facilitate communication between different components
    and improve the user experience, as well as the responsiveness of your application.
    Before ending this chapter, I want to shed light on a new feature introduced in
    Angular 17, Deferrable Views, which can complement data sharing and contribute
    to creating more responsive and efficient applications. Let’s see this in action
    in the next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据共享机制促进了不同组件之间的通信，并提高了用户体验以及应用的响应性。在结束这一章之前，我想介绍一下Angular 17中引入的新特性，可延迟视图，它可以补充数据共享，并有助于创建更响应和高效的程序。让我们在下一节中看看它是如何工作的。
- en: Leveraging Deferrable Views in Angular 17
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Angular 17中的可延迟视图
- en: '**Deferrable Views** allow you to declaratively mark parts of your templates
    as non-essential for immediate rendering. It is kind like delaying the rendering
    of certain parts of a page to improve the perceived performance of your application,
    as well as optimize the initial bundle size and loading times.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**可延迟视图**允许你声明性地标记模板的部分为非必需的立即渲染。这就像延迟页面某些部分的渲染，以提高应用的感知性能，以及优化初始包大小和加载时间。'
- en: There are a number of real-world scenarios where defer rendering can help to
    achieve faster load times such as e-commerce product pages – in this example,
    you can initially display the essential product details and then lazy load additional
    content such as reviews when the user clicks on a **Read more** button or scrolls
    down the page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际场景中，延迟渲染可以帮助实现更快的加载时间，例如电子商务产品页面 – 在这个例子中，你可以最初显示必要的产品细节，然后在用户点击**阅读更多**按钮或滚动页面时懒加载额外的内容，如评论。
- en: 'Let’s quickly see how this works. To lazy load a component, you need to use
    a Standalone component, otherwise deferring won’t work. Then you want to wrap
    up the Standalone component in a `@defer` block, like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看这是如何工作的。要懒加载一个组件，你需要使用独立组件，否则延迟将不起作用。然后你想要将独立组件包裹在`@defer`块中，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also define conditions for when exactly the deferred component should
    load. You can do this by using **triggers**, which specify events or situations
    that initiate loading:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以定义延迟组件何时应该加载的条件。你可以通过使用**触发器**来实现，这些触发器指定了启动加载的事件或情况：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `on viewport` trigger is used to display the `delayed-component` when
    it enters the viewport area of the user’s browser window.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`on viewport`触发器来显示当`delayed-component`进入用户浏览器窗口的视口区域时。
- en: 'Besides `on viewport`, there are other triggers that can be used such as `on
    hover`, which only initiates the content to load when the user’s mouse hovers
    over the delayed content. You can find a full list of available triggers here:
    [https://angular.dev/guide/defer#triggers](https://angular.dev/guide/defer#triggers).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`on viewport`，还有其他可以使用的触发器，例如`on hover`，它仅在用户的鼠标悬停在延迟内容上时启动内容加载。你可以在这里找到可用的完整触发器列表：[https://angular.dev/guide/defer#triggers](https://angular.dev/guide/defer#triggers)。
- en: 'Furthermore, the `@defer` block has some important sub-blocks. For example,
    you can display alternative content before the deferred content loads using the
    `@placeholder` sub-block, like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`@defer`块还有一些重要的子块。例如，你可以在延迟内容加载之前使用`@placeholder`子块显示替代内容，如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In addition to `@placeholder`, `@defer` also offers two other sub-blocks –
    `@loading` and `@``error` :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`@placeholder`，`@defer`还提供了两个其他子块 – `@loading`和`@error`：
- en: The `@loading` block is similar to the `@placeholder` block, but it specifically
    shows content like a loading message while the actual content is being prepared.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@loading`块类似于`@placeholder`块，但它专门显示在准备实际内容时的内容，如加载消息。'
- en: The `@error` block is displayed if there is an error while fetching or processing
    the deferred content. This allows you to provide a user-friendly error message,
    or alternative content, in case something goes wrong.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在获取或处理延迟内容时出现错误时，会显示`@error`块。这允许你在出现问题时提供友好的错误消息或替代内容。
- en: 'Now let’s look at how we can utilize defer rending in our Recipe app. Given
    that the images for each recipe have a high resolution, let’s delay the rendering
    of the images in `RecipesListComponent` HTML template so that they are only shown
    when the user hovers over the image:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在我们的食谱应用中利用延迟渲染。鉴于每个食谱的图片具有高分辨率，让我们在`RecipesListComponent` HTML模板中延迟图片的渲染，以便它们仅在用户悬停在图片上时显示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we surrounded the code block displaying the image with a `@defer`
    block, and used the `on hover` trigger. Then we used the `@placeholder` block
    to specify some text that should be displayed while the deferred content is not
    yet loaded. In this case, inside the <div> element, we added the text, **Hover
    to load** **the image**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在显示图像的代码块周围使用了`@defer`块，并使用了`on hover`触发器。然后我们使用`@placeholder`块指定一些在延迟内容尚未加载时应显示的文本。在这种情况下，我们在`<div>`元素中添加了文本，**悬停以加载**
    **图像**。
- en: For more details about the Deferrable Views feature, refer to [https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可延迟视图功能的更多详细信息，请参阅[https://angular.dev/guide/image-optimization](https://angular.dev/guide/image-optimization)。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained the motivation behind sharing data between components
    and learned how to implement it in a reactive way. First, we learned how we can
    use `BehaviorSubject` combined with Angular services to share data between unrelated
    components and manage our application state. Then, we highlighted the advantages
    of the sharing data reactive pattern. Finally, we explored Angular’s new Deferrable
    Views feature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了组件间共享数据的动机，并学习了如何以反应式的方式实现它。首先，我们学习了如何结合Angular服务使用`BehaviorSubject`在无关组件之间共享数据并管理我们的应用程序状态。然后，我们强调了共享数据反应模式的优点。最后，我们探讨了Angular的新可延迟视图功能。
- en: The features covered in this chapter will help you implement a good architecture
    for your web application, making it more reactive and performant, improving load
    times, and reducing the cost of maintainability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的特性将帮助您为您的Web应用程序实现一个良好的架构，使其更具反应性和性能，提高加载时间，并降低维护成本。
- en: Now, get ready for an exciting journey, because in the next chapter, we delve
    into a brand-new feature called Angular Signals! We’ll cover some reactive patterns
    using Signals and even integrate them into what we’ve learned so far.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好开始一段激动人心的旅程，因为在下一章中，我们将深入探讨一个全新的功能，称为Angular信号！我们将介绍一些使用信号的反应模式，并将它们整合到我们迄今为止所学的内容中。
- en: 'Part 3: The Power of Angular Signals'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：Angular信号的强大之处
- en: Dive into the exciting world of Angular Signals!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸在激动人心的Angular信号世界中！
- en: In this section, you will discover the core functionalities and advantages of
    Angular Signals, as well as unlock the potential of reactivity by leveraging Angular
    Signals and RxJS together. We will also go through the latest Angular Signals
    improvements.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将发现Angular信号的核心功能和优势，以及通过利用Angular信号和RxJS一起解锁反应性的潜力。我们还将介绍最新的Angular信号改进。
- en: 'This part includes the following chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 8*](B21180_08.xhtml#_idTextAnchor119), *Mastering Reactivity with
    Angular Signals*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21180_08.xhtml#_idTextAnchor119)，*使用Angular信号掌握反应性*'
