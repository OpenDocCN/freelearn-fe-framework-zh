- en: More Angular – SPA and Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 Angular – 单页应用和路由
- en: The previous chapter was about building our first useful app in Angular, then
    this chapter is about adding a whole lot of Angular goodness to it. Within the
    learning curve, we have made a start in exploring a technology platform and now
    we can build some rudimentary apps using Angular. But that's just the start! There
    is a lot more to learn before we can make effective use of Angular in a decent-sized
    application. This chapter takes us one step closer to realizing this goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章我们讲述了在 Angular 中构建我们的第一个有用应用，然后这一章将介绍如何为它添加大量的 Angular 优点。在学习曲线中，我们已经开始了探索一个技术平台，现在我们可以使用
    Angular 构建一些基本的应用。但这只是开始！在我们能够有效地在一个中等规模的应用中使用 Angular 之前，还有很多东西要学习。这一章让我们更接近实现这一目标。
- en: The *7-Minute Workout* app still has some rough edges that we can fix while making
    the overall app experience better. This chapter is all about adding those enhancements
    and features. And as always, this app-building process provides us with enough
    opportunities to enhance our understanding of the framework and learn new things
    about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*应用还有一些粗糙的边缘，我们可以在改进整体应用体验的同时修复它们。这一章完全是关于添加这些增强功能和特性。而且，像往常一样，这个应用构建过程为我们提供了足够的机会来增强我们对框架的理解，并学习关于它的新事物。'
- en: 'The topics we cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Exploring Angular''s Single Page Applications** (**SPAs**): We explore Angular''s
    SPA capabilities, which include route navigation, link generation, and routing
    events.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索 Angular 的单页应用**（**SPA**）：我们探索 Angular 的 SPA 功能，包括路由导航、链接生成和路由事件。'
- en: '**Understanding dependency injection**: One of the core platform features.
    In this chapter, we learn how Angular makes effective use of dependency injection to
    inject components and services across the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解依赖注入**：这是平台的核心功能之一。在这一章中，我们学习 Angular 如何有效地使用依赖注入来注入组件和服务到应用程序中。'
- en: '**Angular pure (stateless) and impure (stateful) pipes**: We explore the primary
    data transformation construct of Angular, pipes, in more detail as we build some
    new pipes.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 纯（无状态）和纯（有状态）管道**：当我们构建一些新的管道时，我们将更详细地探索 Angular 的主要数据转换结构——管道。'
- en: '**Cross-component communication**: Since Angular is all about components and
    their interactions, we look at how to do cross-component communication in a parent-child
    and sibling component setup. We learn how Angular''s *template variables* and *events* facilitate
    this communication.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨组件通信**：由于 Angular 的一切都是关于组件及其交互，我们来看看如何在父组件-子组件和兄弟组件设置中进行跨组件通信。我们学习 Angular
    的*模板变量*和*事件*如何促进这种通信。'
- en: '**Creating and consuming events**: We learn how a component can expose its
    own events and how to bind to these events from the HTML template and from other
    components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和消费事件**：我们学习一个组件如何公开其自己的事件，以及如何从 HTML 模板和其他组件中绑定到这些事件。'
- en: As a side note, I expect you are using the *7-Minute Workout* on a regular basis
    and working on your physical fitness. If not, take a seven-minute exercise break
    and exercise now. I insist!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我期望你正在定期使用*7分钟锻炼*来锻炼你的身体。如果不是，现在就进行七分钟的锻炼休息吧。我坚持这样做！
- en: Hope the workout was fun! Now let's get back to some serious business. Let's
    start with exploring Angular's **Single Page Application** (**SPA**) capabilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 希望锻炼很有趣！现在让我们回到一些严肃的业务。让我们从探索 Angular 的**单页应用**（**SPA**）功能开始。
- en: We are starting from where we left off in Chapter 2, *Building Our First App
    - 7-Minute Workout*. The `checkpoint2.4` Git branch can serve as the base for
    this chapter. The code is also available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub. If
    you are not using Git, download the snapshot of `checkpoint2.4` (a ZIP file) from
    the GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第二章*构建我们的第一个应用 - 7分钟锻炼*中继续进行。`checkpoint2.4` Git 分支可以作为本章的基础。代码也已在 GitHub
    ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    上提供，供大家下载。检查点作为 GitHub 中的分支实现。如果你不使用 Git，可以从 GitHub 位置下载`checkpoint2.4`的快照（ZIP
    文件）：[http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Exploring Single Page Application capabilities
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单页应用功能
- en: The *7-Minute Workout* starts when we load the app, but it ends with the last
    exercise sticking to the screen permanently. Not a very elegant solution. Why
    don't we add a start and finish page to the app? This makes the app look more
    professional and allows us to understand the single-page nomenclature of Angular.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟健身法*在加载应用时开始，但最后一个练习会永久地停留在屏幕上。这不是一个非常优雅的解决方案。我们为什么不给应用添加一个开始和结束页面呢？这会让应用看起来更专业，并允许我们理解Angular的单页命名空间。'
- en: The Angular SPA infrastructure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular SPA基础设施
- en: With modern web frameworks, such as Angular and Vue.js, we are now getting used
    to apps that do not perform full-page refreshes. But if you are new to this scene,
    it's worth mentioning what *SPAs* are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代Web框架，如Angular和Vue.js，我们现在已经习惯了不执行全页刷新的应用。但如果你是新手，那么提到*SPAs*是值得的。
- en: '**Single Page Applications** (**SPAs**) are browser-based apps devoid of any
    full-page refresh. In such apps, once the initial HTML is loaded, any future page
    navigations are retrieved using AJAX and HTML fragments and injected into the
    already loaded view. Google Mail is a great example of an SPA. SPAs make for a
    great user experience as the user gets a desktop app-like feel, with no constant
    post-backs and page refreshes, which are typically associated with traditional
    web apps.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**单页应用（SPAs**）是基于浏览器的应用，没有全页刷新。在这样的应用中，一旦初始HTML加载完毕，未来的页面导航将通过AJAX和HTML片段检索，并注入到已加载的视图中。Google
    Mail是SPA的一个很好的例子。SPAs提供了极佳的用户体验，因为用户会得到类似桌面应用的感觉，没有常规的回发和页面刷新，这些都是传统Web应用通常具有的。'
- en: Like any modern JavaScript framework, Angular also provides the necessary constructs
    for SPA implementation. Let's understand them and add our app pages too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何现代JavaScript框架一样，Angular也提供了SPA实现所需的必要结构。让我们了解它们，并添加我们的应用页面。
- en: Angular routing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由
- en: Angular supports SPA development using its **routing infrastructure**. This
    infrastructure tracks browser URLs, enables hyperlink generation, exposes routing
    events, and provides a set of directives/components for views that react to URL
    changes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持使用其**路由基础设施**进行SPA开发。这个基础设施跟踪浏览器URL，启用超链接生成，公开路由事件，并为响应URL变化的视图提供一组指令/组件。
- en: 'There are four major framework pieces that work together to support the Angular
    routing infrastructure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要的框架组件协同工作，以支持Angular的路由基础设施：
- en: '**The Router (Router)**: The primary infrastructure piece that actually provides
    component navigation'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器（Router）**：实际上是提供组件导航的主要基础设施组件。'
- en: '**The Routing configuration (Route)**: The component router is dependent upon
    the routing configuration for setting up routes'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由配置（Route）**：组件路由依赖于路由配置来设置路由。'
- en: '**The RouterOutlet component**: The `RouterOutlet` component is the placeholder container
    (*host*) where route-specific views are loaded'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器组件**：`RouterOutlet`组件是用于加载特定路由视图的占位符容器（*宿主*）。'
- en: '**The RouterLink directive**: This generates hyperlinks that can be embedded
    in the anchor tags for navigation'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器链接指令**：这个指令生成可以在锚标签中嵌入的超链接，用于导航。'
- en: 'The following diagram highlights the roles these components play within the
    routing setup:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示突出了这些组件在路由设置中的作用：
- en: '![](img/00021.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00021.jpeg)'
- en: I highly encourage everyone to keep revisiting this diagram as we set up routing
    for *7-Minute Workout*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议大家在设置*7分钟健身法*的路由时，不断回顾这张图。
- en: '*The router* is the central piece of this complete setup; therefore a quick
    overview of the router will be helpful.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由器*是这个完整设置中的核心组件；因此，快速了解路由器将很有帮助。'
- en: Angular router
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由
- en: If you have worked with any JavaScript framework with SPA support, this is how
    things work. The framework watches the browser URL and serves views based on the
    URL loaded. There are dedicated framework components for this job. In the Angular world,
    this tracking is done by a *framework service*, **the router**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过任何支持SPA的JavaScript框架，那么工作原理是这样的。框架会监视浏览器URL，并根据加载的URL提供视图。为此，有专门的框架组件。在Angular的世界里，这种跟踪是通过一个*框架服务*，**路由器**来完成的。
- en: In Angular, any class, object, or function that provides some generic functionality
    is termed a **service**. *Angular does not provide any special construct to declare
    a service as it does for components, directives, and pipes*. Anything that can
    be consumed by components/directives/pipes can be termed a service. The router
    is one such service. And there are many more services that are part of the framework. *If
    you are from the Angular 1 realm, this is a pleasant surprise-no service, factory,
    provider, value, or constant!*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，任何提供一些通用功能的类、对象或函数都被称为**服务**。*Angular没有为组件、指令和管道提供任何特殊的声明服务结构，就像它对它们所做的那样。任何可以被组件/指令/管道消费的东西都可以称为服务。路由器就是这样一种服务。框架中还有许多其他服务。*如果你来自Angular
    1领域，这会是一个令人愉快的惊喜——没有服务、工厂、提供者、值或常量！*
- en: 'The Angular router is there to:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器的作用是：
- en: Enable navigation between components on route change
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由更改时启用组件之间的导航
- en: Pass routing data between component views
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件视图之间传递路由数据
- en: Make the state of the current route available to active/loaded components
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使当前路由的状态对活动/加载的组件可用
- en: Provide APIs that allow navigation from component code
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供API，允许从组件代码中进行导航
- en: Track the navigation history, allowing us to move back and forward between component
    views using browser buttons
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪导航历史，使我们能够使用浏览器按钮在组件视图之间前后移动
- en: Provide life cycle events and guard conditions that allow us to affect navigation
    based on some external factors
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供生命周期事件和守卫条件，使我们能够根据某些外部因素影响导航
- en: The router also supports some advanced routing concepts, such as parent-child
    routes. This gives us the ability to define routes at multiple levels inside the
    component tree. The parent component can define routes and child components can
    further add more sub-routes to the parent route definition. This is something
    that we cover in detail in Chapter 4, *Building Personal Trainer*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器还支持一些高级路由概念，例如父子路由。这使我们能够在组件树内部定义多级路由。父组件可以定义路由，子组件可以进一步向父路由定义中添加更多子路由。这是我们在第4章“构建个人教练”中详细讨论的内容。
- en: The router does not work alone. As highlighted in the preceding diagram, it
    depends upon other framework pieces to achieve the desired results. Let's add
    some app pages and work with each piece of the puzzle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器不能单独工作。如前图所示，它依赖于其他框架组件以实现预期结果。让我们添加一些应用页面并处理每个拼图的一部分。
- en: Routing setup
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由设置
- en: 'The Angular router is not part of the core Angular framework. It has a separate
    Angular module and its own npm package. Angular CLI has already installed this
    package as part of the project setup. Look at `package.json` to confirm this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器不是Angular核心框架的一部分。它有一个独立的Angular模块和自己的npm包。Angular CLI已经作为项目设置的一部分安装了此包。查看`package.json`以确认这一点：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since the router is already installed, we just need to integrate it into *7-Minute
    Workout*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由器已经安装，我们只需将其集成到*7分钟锻炼*中。
- en: 'We can start by adding the  `base` reference (highlighted) to the `head` section
    of `index.html`, if not present:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先向`index.html`的`head`部分添加`base`引用（突出显示），如果尚未存在：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*The router requires `base href` to be set.* The `href` value specifies the
    base URL to use for all relative URLs within an HTML document, including links
    to CSS, scripts, images, and any other resource. This setting helps the router
    to create navigation URLs.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由器需要设置`base href`。`href`值指定了用于HTML文档中所有相对URL的基本URL，包括链接到CSS、脚本、图像以及其他资源。此设置有助于路由器创建导航URL*。'
- en: Adding start and finish pages
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加开始和结束页面
- en: 'The plan here is to have three pages for *7-Minute Workout*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的计划是为*7分钟锻炼*提供三个页面：
- en: '**Start page**: This becomes the landing page for the app'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始页面**：这成为应用的着陆页'
- en: '**Workout page**: What we have currently'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锻炼页面**：我们目前拥有的'
- en: '**Finish page**: We navigate to this once the workout is complete'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成页面**：当锻炼完成后，我们将导航到这个页面'
- en: The workout component and its view (`workout-runner.component.ts` and `workout-runner.component.html`)
    are already there. So let's create `StartComponent` and `FinishComponent`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼组件及其视图（`workout-runner.component.ts`和`workout-runner.component.html`）已经存在。因此，让我们创建`StartComponent`和`FinishComponent`。
- en: 'Again, using the Angular CLI generates the boilerplate for the start and finish
    components. Navigate to the `trainer/src/app` folder and execute the component-generation
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用Angular CLI生成开始和结束组件的样板代码。导航到`trainer/src/app`文件夹并执行组件生成命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, copy the views for the *start* and *finish* components from the `checkpoint3.1` Git
    branch (the GitHub location to download from is [http://bit.ly/ng6be-3-1-app](http://bit.ly/ng6be-3-1-app)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`checkpoint3.1` Git分支（下载位置为[http://bit.ly/ng6be-3-1-app](http://bit.ly/ng6be-3-1-app)）复制`start`和`finish`组件的视图。
- en: Both the *start* and *finish* components' implementations are empty. The interesting
    bits are in the view. The start component view has a link to navigate to the workout
    runner component (`<a routerLink="/workout" ...`) and so does finish. We have
    yet to define the routes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`finish`组件的实现都是空的。有趣的部分在视图中。开始组件视图有一个链接可以导航到锻炼运行者组件（`<a routerLink="/workout"
    ...`），结束组件也是如此。我们还没有定义路由。'
- en: The start and finish components have been added to *app module*, as they are
    rudimentary views, unlike workout runner, which has its own `WorkoutRunnerModule` module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`finish`组件已经被添加到`app module`中，因为它们是基本的视图，与拥有自己`WorkoutRunnerModule`模块的锻炼运行者不同。'
- en: All three components are ready. Time to define the route configurations!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个组件都已准备就绪。现在是定义路由配置的时候了！
- en: Route configuration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由配置
- en: 'To set up the routes for *7-Minute Workout*, we are going to create a *route
    definition module file*. Create a file called `app-routing.module.ts` in the `trainer/src/app` folder
    defining the top-level routes for the app. Add the following routing setup or
    copy it from the `checkpoint3.1` Git branch:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`7-Minute Workout`的路由，我们将创建一个`route definition module file`。在`trainer/src/app`文件夹中创建一个名为`app-routing.module.ts`的文件，定义应用的顶级路由。添加以下路由设置或从`checkpoint3.1`
    Git分支复制：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Angular CLI also supports boilerplate route-generation for modules. We have
    not used that feature. We can learn about it from the CLI documentation at [http://bit.ly/ng-cli-routing](http://bit.ly/ng-cli-routing).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI还支持为模块生成样板路由。我们没有使用该功能。我们可以从CLI文档中了解它，文档地址为[http://bit.ly/ng-cli-routing](http://bit.ly/ng-cli-routing)。
- en: 'The `routes` variable is an array of `Route` objects. Each `Route` defines
    the configuration of a single route, which contains:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`变量是一个`Route`对象的数组。每个`Route`定义了一个单独路由的配置，它包含：'
- en: '`path`: The target path to match'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：要匹配的目标路径'
- en: '`component`: The component to be loaded when the path is hit'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：当路径被访问时需要加载的组件'
- en: Such a route definition can be interpreted as, "when the user navigates to a
    URL (defined in `path`), load the corresponding component defined in the `component` property."
    Take the first route example; navigating to `http://localhost:9000/start` loads
    the component view for `StartComponent`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路由定义可以解释为：“当用户导航到URL（在`path`中定义）时，加载`component`属性中定义的相应组件。”以第一个路由示例为例；导航到`http://localhost:9000/start`将加载`StartComponent`的组件视图。
- en: You may have noticed that the last `Route` definition looks a bit different. `path` looks
    odd and it does not have a `component` property either. A path with `**` denotes
    a catch-all path or the **wildcard route** for our app. Any navigation that does
    not match one of the first three routes matches the catch-all route, causing the
    app to navigate to the start page (defined in the `redirectTo` property).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到最后一个`Route`定义看起来有点不同。`path`看起来很奇怪，它也没有`component`属性。带有`**`的路径表示一个通配符路径或应用的**通配符路由**。任何不匹配前三个路由的导航都将匹配通配符路由，导致应用导航到起始页面（在`redirectTo`属性中定义）。
- en: We can try this once the routing setup is complete. Type any random route, such
    as `http://localhost:9000/abcd`, and the app automatically redirects to `http://localhost:9000/start`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 路由设置完成后，我们可以尝试一下。输入任何随机的路由，例如`http://localhost:9000/abcd`，应用会自动重定向到`http://localhost:9000/start`。
- en: We finally create and import a new module into `AppRoutingModule` with the call
    to `RouterModule.forRoot`.  And by re-exporting Angular's `RouterModule`, we can
    import `AppRoutingModule` instead of `RouterModule` and have access to all of
    the routing constructs together with our app routes available in `AppModule`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终通过调用`RouterModule.forRoot`创建并导入一个新的模块到`AppRoutingModule`中。通过重新导出Angular的`RouterModule`，我们可以导入`AppRoutingModule`而不是`RouterModule`，并访问所有路由构造以及`AppModule`中可用的应用路由。
- en: 'The `enableTracing: true` property on the `forRoot` function parameter allows
    us to monitor the *router events* (such as `NavigationStart`, `NavigationEnd`,
    and `NavigationCancel`) that happen when navigation takes place and the correct
    route is resolved. The logs are visible in the browser''s debugger console. *Use
    it for debugging purposes only, remove it from production builds*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`forRoot` 函数参数上的 `enableTracing: true` 属性允许我们在导航发生并正确解析路由时监控 *路由事件*（例如 `NavigationStart`、`NavigationEnd`
    和 `NavigationCancel`）。日志在浏览器的调试控制台中可见。*仅用于调试目的，请从生产构建中移除*。'
- en: Could the preceding routing setup could have been done inside `AppModule`? Yes,
    it's definitely possible, but we would recommend against it. As the number of
    routes grow and the routing setup becomes more complex, having a separate routing
    module helps us organize the code better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路由设置是否可以在 `AppModule` 内完成？是的，这绝对可能，但我们建议不要这样做。随着路由数量的增加和路由设置的复杂性增加，有一个独立的路由模块有助于我们更好地组织代码。
- en: An important thing to highlight here:* route ordering is important in route
    definition*. Since route matching is done in a top-down fashion, it stops at the
    first match to define your specific routes before any generic catch-all route,
    such as the `**` *wildcard route *in our definition, which is declared at the
    last.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要强调的一个重要事项是：*路由定义中的路由顺序很重要*。由于路由匹配是自顶向下的，它会在定义你的特定路由之前停止，在任何一个通用的捕获所有路由之前，例如在我们的定义中声明的
    `**` 通配符路由，这是在最后声明的。
- en: 'The default router setup uses the **pushstate** mechanism for URL navigation.
    In such a setup, URLs look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的路由设置使用 **pushstate** 机制进行 URL 导航。在这种设置中，URL 看起来像：
- en: '`localhost:4200/start`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4200/start`'
- en: '`localhost:4200/workout`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4200/workout`'
- en: '`localhost:4200/finish`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:4200/finish`'
- en: 'This may not seem like a big deal, but remember that we are doing client-side
    navigation, not the full-page redirects that we are so used to. As the **developer
    guide** states:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不是什么大问题，但请记住，我们正在进行客户端导航，而不是我们如此习惯的全页重定向。正如 **开发者指南** 所述：
- en: Modern HTML 5 browsers support `history.pushState`, a technique that changes
    a browser's location and history without triggering a server page request. The
    router can compose a "natural" URL that is indistinguishable from one that would
    otherwise require a page load.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现代HTML 5浏览器支持 `history.pushState`，这是一种在不触发服务器页面请求的情况下改变浏览器位置和历史的技巧。路由器可以组合一个“自然”的URL，这个URL与需要页面加载的URL无法区分。
- en: Pushstate API and server-side url-rewrites
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pushstate API 和服务器端 URL 重写
- en: 'The router uses the  pushstate API in one of two cases:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器在两种情况下使用 pushstate API：
- en: When we click on links embedded in the view (`<a>` tag)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们点击视图中嵌入的链接（`<a>` 标签）
- en: When we use the router API
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用路由器 API
- en: In both cases, the router intercepts any navigation events, loads the appropriate
    component view, and finally updates the browser URL. The request never goes to
    the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，路由器拦截任何导航事件，加载适当的组件视图，并最终更新浏览器 URL。请求永远不会发送到服务器。
- en: But what if we refresh the browser window?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们刷新浏览器窗口会怎样呢？
- en: The Angular router cannot intercept the browser's refresh event, and hence a
    complete page refresh happens. In such a scenario, the server needs to respond
    to a resource request (URL) that only exists on the client side. A typical server
    response is to send the app entry file (such as `index.html`) for any arbitrary
    request that may result in a `404 (Not Found)` error. This is what we call the
    server **url-rewrite**. This implies requests to any non-existent URLs, such as `/start`, `/workout`,
    or `/finish` loads the index page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由无法拦截浏览器的刷新事件，因此会发生完整的页面刷新。在这种情况下，服务器需要响应仅存在于客户端的资源请求（URL）。典型的服务器响应是发送应用入口文件（例如
    `index.html`）以响应任何可能导致 `404 (Not Found)` 错误的任意请求。这就是我们所说的服务器 **URL 重写**。这意味着对任何不存在的
    URL 的请求，例如 `/start`、`/workout` 或 `/finish`，都会加载索引页面。
- en: Each server platform has a different mechanism to support url-rewrite. We suggest
    you look at the documentation for the server stack you use to enable url-rewrite
    for your Angular apps.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器平台都有不同的机制来支持 URL 重写。我们建议您查看您使用的服务器堆栈文档，以启用 Angular 应用的 URL 重写。
- en: We can see the server-side rewrites in action once the app routing is complete.
    Once completed, try to refresh the app and see the browser's network log; *the
    server sends the same  generated* `index.html` *content every time irrespective
    of the URL requested*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用路由完成后，我们可以看到服务器端重写的实际效果。完成后，尝试刷新应用并查看浏览器的网络日志；*服务器每次都会发送相同的* 生成的 *`index.html`
    内容，无论请求的URL是什么。
- en: 'The routing module definition is complete now. Before proceeding further, open `app.module.ts` and
    import `AppRoutingModule`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模块定义现在已完成。在继续之前，打开 `app.module.ts` 并导入 `AppRoutingModule`：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have all the required components and all the routes defined, where
    do we inject these components on route change? We just need to define a placeholder
    for that in the host view.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有必需的组件和所有已定义的路由，在路由更改时我们在哪里注入这些组件？我们只需要在宿主视图中定义一个占位符即可。
- en: Rendering component views with router-outlet
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 router-outlet 渲染组件视图
- en: 'Look at the current `AppComponent` template (`app.component.html`), it has an embedded `WorkoutRunnerComponent`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前的 `AppComponent` 模板（`app.component.html`），它包含一个内嵌的 `WorkoutRunnerComponent`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This needs to change as we need to render different components based on the
    URL (`/start`, `/workout`, or `/finish`). Remove the preceding declaration and
    replace it with a *router directive*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要改变，因为我们需要根据 URL（`/start`，`/workout`，或 `/finish`）渲染不同的组件。删除前面的声明，并用一个 *router
    指令* 替换它：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`RouterOutlet` is an Angular component directive that acts as a placeholder
    for loading route-specific components when the route changes. It integrates with
    the router service to load the appropriate component based on the current browser
    URL and the route definition.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet` 是 Angular 组件指令，它在路由更改时充当加载特定路由组件的占位符。它与路由服务集成，根据当前浏览器 URL 和路由定义加载适当的组件。'
- en: 'The following diagram helps us to easily visualize what is happening with the `router-outlet` setup:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表帮助我们轻松地可视化 `router-outlet` 设置中正在发生的事情：
- en: '![](img/00022.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: We are almost done; it's time to trigger navigation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；现在是时候触发导航。
- en: Route navigation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由导航
- en: 'Like standard browser navigation, Angular navigation happens:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准浏览器导航一样，Angular 导航发生：
- en: When a user enters a URL directly into the browser address bar
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户直接在浏览器地址栏中输入 URL
- en: On clicking on a link on the anchor tag
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在点击锚点标签上的链接
- en: On using a script/code to navigate
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用脚本/代码进行导航时
- en: If not started, start the app and load `http://localhost:4200` or `http://localhost:4200/start`.
    The start page should be loaded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未启动，请启动应用程序并加载 `http://localhost:4200` 或 `http://localhost:4200/start`。启动页面应该被加载。
- en: Click on the Start button and the workout should start under the `http://localhost:4200/workout` URL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Start 按钮，锻炼应该在 `http://localhost:4200/workout` URL 下开始。
- en: 'The Angular router also supports the old style of *hash (#)-based routing*.
    When hash-based routing is enabled, the routes appear as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由器还支持基于 *hash (#)-based routing* 的旧式路由。当启用基于 hash 的路由时，路由如下所示：
- en: '`localhost:9000/#/start`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/start`'
- en: '`localhost:9000/#/workout`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/workout`'
- en: '`localhost:9000/#/finish`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/finish`'
- en: To change it to hash-based routing, the route configuration for the top-level
    routes should be augmented with an extra `useHash:true` property in the `RouterModule.forRoot` function
    (second parameter).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其更改为基于 hash 的路由，顶级路由的路由配置应在 `RouterModule.forRoot` 函数（第二个参数）中增加一个额外的 `useHash:true` 属性。
- en: 'Interestingly, the anchor link in the `StartComponent` view definition does
    not have an `href` attribute. Instead, there is a `RouterLink` directive (the
    directive name is `RouterLink`, the selector is `routerLink`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在 `StartComponent` 视图定义中的锚点链接没有 `href` 属性。相反，有一个 `RouterLink` 指令（指令名称为 `RouterLink`，选择器为 `routerLink`）：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding case, since the route is fixed, the directive takes a constant
    expression (`"/workout"`). We are not using the standard square bracket notation
    (`[]`) here, instead are assigning the directive a fixed value. This is known
    as **one-time binding**. For dynamic routes, we can use template expressions and
    the link parameter array. We'll touch upon dynamic routes and the link parameter
    array shortly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，由于路由是固定的，指令采用了一个常量表达式（`"/workout"`）。我们在这里不使用标准的方括号表示法（`[]`），而是将指令分配一个固定值。这被称为 **一次性绑定**。对于动态路由，我们可以使用模板表达式和链接参数数组。我们很快就会涉及到动态路由和链接参数数组。
- en: Notice the **/** prefix in the preceding route path. `/` is used to specify
    an absolute path. The Angular router also supports relative paths, which are useful
    when working with child routes. We will explore the concept of child routes in
    the next few chapters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的路由路径中的 **/** 前缀。`/` 用于指定绝对路径。Angular 路由器也支持相对路径，这在处理子路由时非常有用。我们将在接下来的几章中探讨子路由的概念。
- en: 'Refresh the app and check the rendered HTML for `StartComponent`; the preceding
    anchor tag is rendered with the correct `href` value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用并检查渲染的HTML中的`StartComponent`；前面的锚标签被渲染为正确的`href`值：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Avoid hardcoding route links
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 避免硬编码路由链接
- en: While you could have directly used `<a href="/workout">`, prefer `routerLink` to
    avoid hardcoding routes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以直接使用`<a href="/workout">`，但为了避免硬编码路由，建议使用`routerLink`。
- en: The link parameter array
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接参数数组
- en: 'The route setup for the current *7-Minute Workout* is quite simple, and there
    isn''t a need to pass parameters as part of link generation. But the capability is
    there for non-trivial routes that require dynamic parameters. See this example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当前**7分钟锻炼**的路由设置相当简单，不需要在生成链接时传递参数。但非平凡路由需要动态参数时，这个功能是存在的。看看这个例子：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is how the first route can be generated:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何生成第一个路由的方法：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The array assigned to the `RouterLink` directive is what we called the **link
    parameter array**. The array follows a specific pattern:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给`RouterLink`指令的数组就是我们所说的**链接参数数组**。该数组遵循特定的模式：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first element is always the route path, and the next set of parameters is
    there to replace placeholder tokens defined in a route template.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素始终是路由路径，下一组参数用于替换在路由模板中定义的占位符标记。
- en: The Angular router is quite a beast and supports almost everything that we expect
    from a modern router library. It supports child routes, async routes, lifecycle
    hooks, secondary routes, and some other advanced scenarios. We'll delay discussion
    on these topics until later chapters. This chapter just gets us started with Angular
    routing, but there is more to come!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器非常强大，几乎支持我们从现代路由库中期望的所有功能。它支持子路由、异步路由、生命周期钩子、次要路由和一些其他高级场景。我们将推迟对这些主题的讨论，直到后面的章节。本章只是让我们开始使用Angular路由，但还有更多内容要介绍！
- en: 'The router link parameter can also be an object. Such objects are used to supply **optional
    parameters** to the route. See this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 路由链接参数也可以是一个对象。这样的对象用于向路由提供**可选参数**。看看这个例子：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the generated link contains a semicolon to separate optional parameters
    from the route and other parameters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生成的链接中包含分号，用于将可选参数与路由和其他参数分开。
- en: The last missing part of the implementation is routing to the finish page once
    the workout completes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的最后缺失部分是在锻炼完成后路由到完成页面。
- en: Using the router service for component navigation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由服务进行组件导航
- en: Navigation from the workout page to the finish page is not triggered manually
    but on completion of the workout. `WorkoutRunnerComponent` needs to trigger this
    transition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从锻炼页面到完成页面的导航不是手动触发的，而是在锻炼完成后触发的。`WorkoutRunnerComponent`需要触发这个转换。
- en: For this, `WorkoutRunnerComponent` needs to get hold of the router and invoke
    the `navigate` method on it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，`WorkoutRunnerComponent`需要获取路由并对其调用`navigate`方法。
- en: How does `WorkoutRunnerComponent` get the router instance? Using Angular's *dependency
    injection framework*. We have been shying away from this topic for some time now.
    We have achieved a lot without even knowing that there's a dependency injection
    framework in play all this time. Let's wait a tad longer and first concentrate
    on fixing the navigation issue.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`是如何获取路由实例的？使用Angular的**依赖注入框架**。我们至今一直对这个话题有所回避。我们取得了很多成就，甚至不知道一直都有依赖注入框架在发挥作用。让我们稍等片刻，首先集中精力解决导航问题。'
- en: 'For `WorkoutRunnerComponent` to get hold of the router service instance, it
    just needs to declare the service on the constructor. Update the `WorkoutRunnerComponent` constructor
    and add the imports:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`WorkoutRunnerComponent`获取路由服务实例，它只需要在构造函数中声明该服务。更新`WorkoutRunnerComponent`构造函数并添加导入：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Angular now magically injects the current router into the `router` private variable
    when `WorkoutRunnerComponent` is instantiated. The magic is done by *dependency
    injection framework*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WorkoutRunnerComponent`实例化时，Angular神奇地将当前路由注入到`router`私有变量中。这个魔法是通过**依赖注入框架**完成的。
- en: 'It''s now just a matter of replacing the `console.log("Workout complete!");` statement
    with the call to the `navigation` router:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要将`console.log("Workout complete!");`语句替换为对`navigation`路由的调用即可：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `navigate` method takes the same *link parameter array* as the `RouterLink` directive.
    We can verify the implementation by patiently waiting for the workout to complete!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigate`方法接受与`RouterLink`指令相同的**链接参数数组**。我们可以通过耐心等待锻炼完成来验证实现。'
- en: If you are having a problem running the code, look at the `checkpoint3.1` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.1` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-1](http://bit.ly/ng6be-checkpoint-3-1). Refer
    to the `README.md` file in the trainer folder when setting up the snapshot for
    the first time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看`checkpoint3.1`Git分支，以获取我们迄今为止所做工作的一个可工作版本。或者，如果您不使用Git，可以从[http://bit.ly/ng6be-checkpoint-3-1](http://bit.ly/ng6be-checkpoint-3-1)下载`checkpoint3.1`的快照（ZIP文件）。在首次设置快照时，请参考训练文件夹中的`README.md`文件。
- en: The routes we have defined in *7-Minute Workout* are standard simple routes.
    But if there are dynamic routes that take parameters, how do we make the parameters
    available in our components? Angular has a service for that, the `ActivatedRoute` service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义的*7分钟健身法*中的路线是标准的简单路线。但如果存在需要参数的动态路线，我们如何使这些参数在我们的组件中可用？Angular有一个服务可以做到这一点，那就是`ActivatedRoute`服务。
- en: Using the ActivatedRoute service to access route params
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ActivatedRoute服务访问路由参数
- en: There are times when the app requires access to the active route state. Information
    such as the current URL fragment, the current route parameters, and other route-related
    data may come in handy during a component's implementation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，应用程序需要访问活动路由状态。在组件实现过程中，有关当前URL片段、当前路由参数和其他与路由相关的数据等信息可能会派上用场。
- en: The `ActivatedRoute` service is a one-stop shop for all current route-related
    queries. It has a number of properties, including `url` and `paramMap`, that can
    be used to query the route's current state.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedRoute`服务是所有当前路由相关查询的一站式商店。它有几个属性，包括`url`和`paramMap`，可以用来查询路由的当前状态。'
- en: 'Let''s look at an example of a parameterized route and how to access a parameter
    passed from a component,  given this route:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个参数化路由的例子以及如何访问从组件传递过来的参数，给定这个路由：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the user navigates to `/user/5`, the underlying component  can access
    the `:id` parameter value by first injecting `ActivatedRoute` into its constructor:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到`/user/5`时，底层组件可以通过首先将其构造函数中的`ActivatedRoute`注入来访问`:id`参数值：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And then, anywhere in the code where the parameter is required, call `get` methods
    on the `ActivatedRoute.paramMap` property:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码中需要参数的任何地方，调用`ActivatedRoute.paramMap`属性的`get`方法：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `paramMap` property on `ActivatedObject` is actually an **observable.** We
    will learn more about observables later in the chapter, but for now, it is enough
    to understand that observables are objects that let the outside world know about
    their state changes by raising events that others can listen into.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivatedObject`上的`paramMap`属性实际上是一个**可观察对象**。我们将在本章后面部分了解更多关于可观察对象的内容，但就目前而言，理解可观察对象是对象，通过引发其他人可以监听的事件来让外界了解其状态变化就足够了。'
- en: We'll use this router capability in the later chapters where we build a new
    app that can create workouts and edit existing workouts. In the upcoming chapters,
    we also look at some advanced routing concepts, including *child routes*, *lazy
    loaded routes*, and *guard conditions*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中使用这个路由器功能，在那里我们将构建一个新的应用程序，可以创建健身计划并编辑现有的健身计划。在即将到来的章节中，我们还将探讨一些高级路由概念，包括*子路由*、*懒加载路由*和*守卫条件*。
- en: We have covered the basics of Angular routing, it's now time to concentrate
    on a much overdue topic: *Dependency Injection*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Angular路由的基础知识，现在是时候集中精力在一个久违的话题上了：*依赖注入*。
- en: Angular dependency Injection
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular依赖注入
- en: Angular makes heavy use of dependency injection to manage app and framework
    dependencies. The surprising part is that we could ignore this topic until we
    started our discussion on the router. All this time, the Angular dependency injection
    framework has been supporting our implementation. The hallmark of a good dependency
    injection framework is that the consumer can use it without bothering too much
    about the internals and with little ceremony.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Angular大量使用依赖注入来管理应用程序和框架的依赖。令人惊讶的是，我们可以在开始讨论路由器之前忽略这个话题。在这段时间里，Angular依赖注入框架一直在支持我们的实现。一个好的依赖注入框架的标志是，消费者可以在不太多关注内部结构和很少的仪式的情况下使用它。
- en: If you are not sure what dependency injection is or just have a vague idea about
    it, an introduction to DI surely does not hurt anyone.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定依赖注入是什么，或者只是对它有一个模糊的概念，那么DI的介绍肯定不会伤害任何人。
- en: Dependency injection 101
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入101
- en: For any application, its components (not to be confused with Angular components)
    do not work in isolation. There are dependencies between them. A component may
    use other components to achieve its desired functionalities. **Dependency injection** is
    a pattern for managing such dependencies.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何应用程序，其组件（不要与Angular组件混淆）并不是独立工作的。它们之间存在依赖关系。一个组件可能使用其他组件来实现其所需的功能。"**依赖注入**"是一种管理此类依赖的模式。
- en: The DI pattern is popular in many programming languages as it allows us to manage
    dependencies in a loosely coupled manner. With such a framework in place, dependent
    objects are managed by a DI container. This makes dependencies swappable and the
    overall code more decoupled and testable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入模式在许多编程语言中都很流行，因为它允许我们以松耦合的方式管理依赖。有了这样的框架，依赖对象由DI容器管理。这使得依赖可交换，整体代码更加解耦和可测试。
- en: The idea behind DI is that an object does not create/manage its own dependencies.
    Instead, the dependencies are provided from the outside. These dependencies are
    made available either through a constructor, which is called **constructor injection** (Angular
    also does this) or by directly setting the object properties, which is called **property
    injection**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入背后的理念是，一个对象不创建/管理自己的依赖。相反，依赖由外部提供。这些依赖可以通过构造函数提供，这被称为**构造函数注入**（Angular也这样做）或者通过直接设置对象属性，这被称为**属性注入**。
- en: 'Here is a rudimentary example of DI in action. Consider a class called `Tracker` that
    requires `Logger` for a logging operation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个依赖注入操作的初步示例。考虑一个名为`Tracker`的类，它需要一个`Logger`来进行日志操作：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The dependency of the `Logger` class is hardwired inside `Tracker` as `Tracker` itself
    instantiates the `Logger` instance. What if we externalize this dependency? So
    the class becomes:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`类的依赖在`Tracker`内部硬编码，因为`Tracker`本身实例化了`Logger`实例。如果我们外部化这个依赖呢？所以这个类变成了：'
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This innocuous-looking change has a major impact. By adding the ability to
    provide the dependency externally, we can now:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看似无害的更改产生了重大影响。通过添加提供依赖外部的能力，我们现在可以：
- en: '**Decouple these components and enable extensibility**. The DI pattern allows
    us to alter the logging behavior of the `Tracker` class without touching the class
    itself. Here is an example:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦这些组件并启用可扩展性**。依赖注入模式允许我们修改`Tracker`类的日志行为，而不需要触及该类本身。以下是一个示例：'
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two `Tracker` objects we just saw have different logging capabilities for
    the same `Tracker` class implementation. `trackerWithDBLog` logs to a DB and `trackerWithMemoryLog` to
    the memory (assuming both `DBLogger` and `MemoryLogger` are derived from the `Logger` class).
    Since `Tracker` is not dependent on a specific implementation on  `Logger` (`DBLogger` or `MemoryLogger`),
    this implies `Logger` and `Tracker` are loosely coupled. In the future, we can
    derive a new `Logger` class implementation and use that for logging without changing
    the `Tracker` implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的两个`Tracker`对象具有相同的`Tracker`类实现的不同日志功能。"trackerWithDBLog"将日志记录到数据库，而"trackerWithMemoryLog"则记录到内存中（假设`DBLogger`和`MemoryLogger`都派生自`Logger`类）。由于`Tracker`不依赖于`Logger`的具体实现（`DBLogger`或`MemoryLogger`），这表明`Logger`和`Tracker`是松耦合的。在未来，我们可以派生一个新的`Logger`类实现，并用于日志记录，而无需更改`Tracker`的实现。
- en: '**Mock dependencies**: The ability to mock dependencies makes our components
    more testable. The `Tracker` implementation can be tested in isolation (unit testing)
    by providing a mock implementation for `Logger`, such as `MockLogger`, or by using
    a mocking framework that can easily mock the `Logger` interface.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟依赖**：模拟依赖的能力使得我们的组件更容易测试。`Tracker`实现可以通过提供`Logger`的模拟实现（如`MockLogger`）或使用可以轻松模拟`Logger`接口的模拟框架来独立（单元测试）测试。'
- en: We can now understand how powerful DI is.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以理解DI有多强大。
- en: 'Think carefully: once DI is in place, the responsibility for resolving the
    dependencies now falls on the calling/consumer code. In the preceding example,
    a class that was earlier instantiating `Tracker` now needs to create a `Logger` derivation
    and inject it into `Tracker` before using it.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考：一旦DI就位，解决依赖的责任现在落在调用/消费代码上。在先前的示例中，之前实例化`Tracker`的类现在需要创建一个`Logger`派生类并将其注入到`Tracker`中，然后再使用它。
- en: Clearly, this flexibility in swapping internal dependencies of a component comes
    at a price. The calling code implementation can become overly complex as it now
    has to manage child dependencies too. This may seem simple at first, but given
    the fact that dependent components may themselves have dependencies, what we are
    dealing with is a complex dependency-tree structure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种在组件内部交换依赖项的灵活性是有代价的。调用代码的实现可能会变得过于复杂，因为它现在还必须管理子依赖项。这看起来可能很简单，但考虑到依赖组件本身可能也有依赖项，我们正在处理的是一个复杂的依赖树结构。
- en: This is where DI containers/frameworks add value. They make managing dependencies
    less cumbersome for the calling code. These containers then construct/manage dependencies
    and provide it to our client/consumer code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是DI容器/框架增加价值的地方。它们使调用代码管理依赖项变得更加简单。然后这些容器构建/管理依赖项，并将其提供给我们的客户端/消费者代码。
- en: The Angular DI framework manages dependencies for our Angular components, directives,
    pipes, and services.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Angular DI框架负责管理我们的Angular组件、指令、管道和服务的依赖项。
- en: Exploring dependency injection in Angular
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Angular中的依赖注入
- en: 'Angular employs its very own DI framework to manage dependencies across the
    application. The very first example of visible dependency injection was the injection
    of the component router into `WorkoutRunnerComponent`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用其自己的DI框架来管理应用程序中的依赖项。第一个可见的依赖注入示例是将组件路由注入到`WorkoutRunnerComponent`中：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the `WorkoutRunnerComponent` class gets instantiated, the DI framework
    internally locates/creates the correct router instance and injects it into the
    caller (in our case, `WorkoutRunnerComponent`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WorkoutRunnerComponent`类被实例化时，DI框架内部定位/创建正确的路由实例，并将其注入到调用者（在我们的例子中是`WorkoutRunnerComponent`）。
- en: While Angular does a good job of keeping the DI infrastructure hidden, it's
    imperative that we understand how Angular DI works. Otherwise, everything may
    seem rather magical.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular在隐藏DI基础设施方面做得很好，但了解Angular DI的工作方式至关重要。否则，一切可能看起来都很神奇。
- en: 'DI is about creating and managing dependencies, and the framework component
    that does this is dubbed the **the injector**. For the injector to manage dependencies,
    it needs to understand the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: DI是关于创建和管理依赖项的，执行此操作的是被称为**注入器**的框架组件。为了管理依赖项，注入器需要理解以下内容：
- en: '**The what:** What is the dependency? The dependency could be a class, an object,
    a factory function, or a value. Every dependency needs to be registered with the
    DI framework before it can be injected.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是什么**：依赖项是什么？依赖项可以是类、对象、工厂函数或值。每个依赖项在注入之前都需要在DI框架中注册。'
- en: '**The where/when:** The DI framework needs to know where to inject a dependency
    and when.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在哪里/何时**：DI框架需要知道在哪里注入依赖项以及何时注入。'
- en: '**The how**: The DI framework also needs to know the recipe for creating the
    dependency when requested.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何**：DI框架还需要知道在请求时创建依赖项的配方。'
- en: Any injected dependency needs to answer these questions, irrespective of whether
    it's a framework construct or an artifact created by us.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 任何注入的依赖项都需要回答这些问题，无论它是框架构造还是我们创建的工件。
- en: 'Take, for example, the `Router` instance injection done in `WorkoutRunnerComponent`.
    To answer the what and how parts, we register the `Router` service by importing
    the `RouterModule` into `AppRoutingModule`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以`WorkoutRunnerComponent`中完成的`Router`实例注入为例。为了回答“是什么”和“如何做”的问题，我们在`AppRoutingModule`中通过导入`RouterModule`来注册`Router`服务：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `AppRoutingModule` is a module that exports multiple routes together with
    all the Angular-router-related services (technically it re-exports `RouterModule`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppRoutingModule`是一个模块，它导出多个路由以及所有与Angular-router相关的服务（技术上它重新导出`RouterModule`）。'
- en: The where and when are decided based on the component that requires the dependencies.
    The constructor of `WorkoutRunnerComponent` takes a dependency of `Router`. This
    informs the injector to inject the current `Router` instance when `WorkoutRunnerComponent` is
    created as part of route navigation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “在哪里”和“何时”是由需要依赖项的组件决定的。`WorkoutRunnerComponent`的构造函数接受一个`Router`依赖项。这会通知注入器在创建`WorkoutRunnerComponent`作为路由导航的一部分时注入当前的`Router`实例。
- en: Internally, the injector determines the dependencies of a class based on the
    metadata reflected from it when converting TypeScript to ES5 code (done by the
    TypeScript compiler). The metadata is generated only if we add a decorator, such
    as `@Component` or `@Pipe`, on the class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，注入器根据从 TypeScript 转换为 ES5 代码（由 TypeScript 编译器完成）时反射的元数据来确定类的依赖关系。只有当我们向类添加装饰器，如
    `@Component` 或 `@Pipe` 时，才会生成元数据。
- en: What happens if we inject `Router` into another class? Is the same `Router` instance
    used? The short answer is yes. The Angular injector creates and caches dependencies
    for future reuse, and hence these services are singleton in nature.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `Router` 注入到另一个类中会发生什么？是否使用相同的 `Router` 实例？简短的答案是是的。Angular 注入器创建和缓存依赖关系以供将来重用，因此这些服务本质上是单例的。
- en: While dependencies in an injector are singleton, at any given time, there can
    be multiple injectors active throughout an Angular app. You'll learn about the
    injector hierarchy shortly. With the router, there is another layer of complexity.
    Since Angular supports the child route concept, each of these child routes has
    its own router instance. Wait until we cover child routers in the next chapter
    so that you can understand the intricacies!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然注入器中的依赖关系是单例的，但在任何给定时间，Angular 应用程序中可能有多个注入器处于活动状态。你很快就会了解注入器层次结构。与路由器一样，还有另一层复杂性。由于
    Angular 支持子路由概念，这些子路由中的每一个都有自己的路由实例。等到我们下一章介绍子路由时，你就可以理解其中的复杂性了！
- en: Let's create an Angular service to track workout history. This process will
    help you understand how dependencies are wired using Angular DI.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 Angular 服务来跟踪锻炼历史记录。这个过程将帮助你了解如何使用 Angular DI 连接依赖关系。
- en: Tracking workout history
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪锻炼历史记录
- en: It would be a great addition to our app if we could track our workout history.
    When did we last exercise? Did we complete it? How much time did we spend on it?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能跟踪我们的锻炼历史记录，那将是一个很好的补充。我们上次是什么时候锻炼的？我们完成了吗？我们花了多少时间？
- en: To answer these questions, we need to track when the workout starts and when
    it ends. This tracking data then needs to be persisted somewhere.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要跟踪锻炼开始和结束的时间。然后需要将这些跟踪数据持久化到某个地方。
- en: A possible solution could be to extend our `WorkoutRunnerComponent` with the
    desired functionality. But that adds unnecessary complexity to `WorkoutRunnerComponent` and
    that's not its primary job.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将所需的函数扩展到我们的 `WorkoutRunnerComponent` 中。但这会给 `WorkoutRunnerComponent`
    增加不必要的复杂性，这不是它的主要任务。
- en: We need a dedicated history-tracking service for this job, a service that tracks
    historical data and shares it throughout the app. Let's start building the workout-history-tracker
    service.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这项工作创建一个专门的历史跟踪服务，一个跟踪历史数据并在整个应用程序中共享的服务。让我们开始构建 workout-history-tracker
    服务。
- en: Building the workout-history-tracker service
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 workout-history-tracker 服务
- en: The workout-history-tracker service is going to track workout progress. The
    service will also expose an interface, allowing `WorkoutRunnerComponent` to start
    and stop workout tracking.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: workout-history-tracker 服务将跟踪锻炼进度。该服务还将公开一个接口，允许 `WorkoutRunnerComponent` 开始和停止锻炼跟踪。
- en: Inspired again by the *Angular style guide*, we are going to create a new module, **core
    module**, and add the service to this module. The role of the core module is to
    host services that are available across the application. It is also a good place
    to add single-use components that are required when the application starts. A
    nav bar and busy indicator are good examples of such components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 再次受到 *Angular 风格指南* 的启发，我们将创建一个新的模块，**核心模块**，并将服务添加到这个模块中。核心模块的作用是托管应用程序中可用的服务。这也是添加在应用程序启动时所需的单次使用组件的好地方。导航栏和忙碌指示器就是这样的组件示例。
- en: 'On the command line, navigate to the `trainer/src/app` folder and generate
    a new module:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，导航到 `trainer/src/app` 文件夹并生成一个新的模块：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This creates a new `CoreModule` module and imports it into `AppModule`. Next,
    create a new service inside the `trainer/src/app/core` folder, again using Angular
    CLI:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 `CoreModule` 模块并将其导入到 `AppModule` 中。接下来，在 `trainer/src/app/core` 文件夹中创建一个新的服务，再次使用
    Angular CLI：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The generated code is quite simple. The generator creates a new class `WorkoutHistoryTrackerService` (`workout-history-tracker.service.ts`)
    with a `@Injectable` decorator applied on the class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码相当简单。生成器创建了一个新的类 `WorkoutHistoryTrackerService` (`workout-history-tracker.service.ts`)，并在类上应用了
    `@Injectable` 装饰器：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `providedIn:'root'` property on `Injectable` instructs Angular to create **a
    provider** with the *root injector*. The sole job of this provider is to create
    the `WorkoutHistoryTrackerService` service and return it when Angular's DI injector
    desires. Any service that we create/use needs to be registered on an injector.
    As the Angular documentation on *providers* describes,
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Injectable` 上的 `providedIn:''root''` 属性指示 Angular 使用 *root injector* 创建 **一个提供者**。这个提供者的唯一任务是创建
    `WorkoutHistoryTrackerService` 服务并在 Angular 的 DI 注入器需要时返回它。我们创建/使用的任何服务都需要在注入器上注册。正如
    Angular 关于 *providers* 的文档所描述的，'
- en: '*Providers tell the injector how to create the service. Without a provider,
    the injector would not know that it is responsible for injecting the service nor
    be able to create the service*.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*提供者告诉注入器如何创建服务。没有提供者，注入器将不知道它负责注入服务，也无法创建服务*。'
- en: A service in Angular is just a class that has been registered with Angular's
    DI framework. Nothing special about them!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，服务只是一个已注册到 Angular DI 框架的类。它们没有什么特别之处！
- en: 'Sometimes it is desirable to include the service as part of a module instead
    of registering it with the root injector. In such a case, the service can be registered
    at the module level. There are two ways to achieve this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将服务作为模块的一部分而不是与根注入器注册可能是希望的。在这种情况下，服务可以在模块级别注册。有两种方法可以实现这一点：
- en: '**Option 1**: Reference the module with the `providedIn` property:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 1**：使用 `providedIn` 属性引用模块：'
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Option 2**: Register the service on the module, using the `providers` array:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项 2**：在模块上注册服务，使用 `providers` 数组：'
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Registering services at module level is advantageous in scenarios where a module
    is lazy loaded.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块级别注册服务在模块是懒加载的场景中具有优势。
- en: Registering the service using `Injectable` (*option 1*) has another advantage.
    It enables Angular CLI build to perform advanced optimization with code bundling,
    leaving out any service that is declared but never used (a process called **tree
    shaking**).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Injectable`（*选项 1*）注册服务还有另一个优点。它使 Angular CLI 构建能够执行代码捆绑的高级优化，省略任何已声明但从未使用的服务（这个过程称为
    **tree shaking**）。
- en: Irrespective of the two options we use, the service is still registered (via
    a provider) with the root injector.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们使用哪两种选项，服务仍然通过提供者（provider）与根注入器注册。
- en: 'We are going to use the `Injectable` approach to registering dependency throughout
    the book, unless stated otherwise. Open `workout-history-tracker.service.ts` and
    add the following implementation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Injectable` 方法在本书中注册依赖项，除非另有说明。打开 `workout-history-tracker.service.ts`
    并添加以下实现：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are two classes defined: `WorkoutHistoryTrackerService` and `WorkoutLogEntry`.
    As the name suggests, `WorkoutLogEntry` defines log data for one workout execution. `maxHistoryItems` allows
    us to configure the maximum number of items to store in the `workoutHistory` array,
    the array that contains the historical data. The `get tracking()` method defines
    a getter property for `workoutTracked` in TypeScript. `workoutTracked` is set
    to `true` during workout execution.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了两个类：`WorkoutHistoryTrackerService` 和 `WorkoutLogEntry`。正如其名称所暗示的，`WorkoutLogEntry`
    定义了单个锻炼执行的日志数据。`maxHistoryItems` 允许我们配置要存储在包含历史数据的 `workoutHistory` 数组中的最大项目数。`get
    tracking()` 方法在 TypeScript 中定义了 `workoutTracked` 的 getter 属性。在锻炼执行期间，`workoutTracked`
    被设置为 `true`。
- en: 'Let''s add the start tracking, stop tracking, and exercise complete functions
    to `WorkoutHistoryTrackerService`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 `WorkoutHistoryTrackerService` 添加开始跟踪、停止跟踪和完成锻炼的函数：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `startTracking` function creates a `WorkoutLogEntry` and adds it to the `workoutHistory` array.
    By setting the `currentWorkoutLog` to the newly created log entry, we can manipulate
    it later during workout execution. The `endTracking` function and the `exerciseComplete` function
    just alter `currentWorkoutLog`. The `exerciseComplete` function should be called
    on completion of each exercise that is part of the workout.  To save you some
    keystrokes, get the complete code for implementation done thus far from this gist: [http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts](http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTracking` 函数创建一个 `WorkoutLogEntry` 并将其添加到 `workoutHistory` 数组中。通过将 `currentWorkoutLog`
    设置为新创建的日志条目，我们可以在锻炼执行过程中稍后对其进行操作。`endTracking` 函数和 `exerciseComplete` 函数仅修改 `currentWorkoutLog`。`exerciseComplete`
    函数应在完成每个作为锻炼一部分的锻炼时调用。为了节省您的按键次数，您可以从此 gist 获取到目前为止的实现完整代码：[http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts](http://bit.ly/ng6be-gist-workout-history-tracker-v1-ts)。'
- en: 'The service implementation now also includes a function to get workout history
    data:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实现现在还包括一个获取锻炼历史数据的函数：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That completes the `WorkoutHistoryTrackerService` implementation; now it's time
    to integrate it into the workout execution.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`WorkoutHistoryTrackerService`的实现；现在，是时候将其集成到锻炼执行中了。
- en: Integrating with WorkoutRunnerComponent
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与`WorkoutRunnerComponent`集成
- en: '`WorkoutRunnerComponent` requires `WorkoutHistoryTrackerService` to track workout
    history; hence there is a dependency to be fulfilled. We already have registered `WorkoutHistoryTrackerService` with
    Angular''s DI framework using the `Injectable` decorator and now it''s time to
    consume the service.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`需要`WorkoutHistoryTrackerService`来跟踪锻炼历史；因此有一个依赖项需要满足。我们已经在Angular的DI框架中使用`Injectable`装饰器注册了`WorkoutHistoryTrackerService`，现在是时候使用构造函数注入来消费这个服务了。'
- en: Injecting dependencies with Constructor Injection
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造函数注入注入依赖项
- en: Consuming dependency is easy! *More often than not, we use constructor injection
    to consume a dependency*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 消费依赖项很容易！*通常情况下，我们使用构造函数注入来消费依赖项*。
- en: 'Add the `import` statement at the top and update the `WorkoutRunnerComponent` constructor,
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部添加`import`语句，并更新`WorkoutRunnerComponent`构造函数，如下所示：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As with `router,` Angular injects `WorkoutHistoryTrackerService` too when `WorkoutRunnerComponent` is
    created. Easy!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与`router`一样，当创建`WorkoutRunnerComponent`时，Angular也会注入`WorkoutHistoryTrackerService`。很简单！
- en: Once the service is injected and available to `WorkoutRunnerComponent`, the
    service instance (`tracker`) needs to be called when the workout starts, when
    an exercise is complete, and when the workout finishes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务被注入并可供`WorkoutRunnerComponent`使用，当锻炼开始、一项锻炼完成以及锻炼结束时，需要调用服务实例（`tracker`）。
- en: 'Add this as the first statement in the `start` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将此作为`start`函数中的第一个语句：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `startExerciseTimeTracking` function, add the highlighted code after
    the `clearInterval` call:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startExerciseTimeTracking`函数中，在`clearInterval`调用之后添加高亮代码：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the highlighted code inside the workout to complete the `else` condition
    in the same function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在锻炼中高亮显示的代码，以完成同一函数中的`else`条件：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: History tracking is almost complete except for one case. What if the user manually
    navigates away from the workout page? How do we stop tracking?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 历史跟踪几乎完成了，除了一个特殊情况。如果用户手动导航离开锻炼页面怎么办？我们如何停止跟踪？
- en: When that happens, we can always rely on the component's life cycle hooks/events
    to help us. Workout tracking can be stopped when the `NgOnDestroy` event is fired.
    An appropriate place to perform any cleanup work is before the component is removed
    from the component tree. Let's do it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们总能依赖组件的生命周期钩子/事件来帮助我们。当`NgOnDestroy`事件被触发时，可以停止锻炼跟踪。在组件从组件树中移除之前执行任何清理工作的合适位置。让我们这么做。
- en: 'Add this function and the corresponding life cycle event interface to `workout-runner.component.ts`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数和相应的生活周期事件接口添加到`workout-runner.component.ts`中：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The workout-history-tracking implementation is complete. We are eager to start
    the workout history page/component implementation, but not before completing our
    discussion on Angular's DI capabilities.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼历史跟踪实现已完成。我们渴望开始锻炼历史页面/组件的实现，但在完成我们对Angular DI能力的讨论之前，我们不会这么做。
- en: Feel free to skip the next section for now if you want to maintain the app-building
    velocity. Come back to this section with a fresh and relaxed mind. There are some
    very important core concepts we'll share in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保持应用构建速度，现在可以自由跳过下一节。用清新和放松的心态回到这一节。在下一节中，我们将分享一些非常重要的核心概念。
- en: Dependency injection in depth
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解依赖注入
- en: Let's first try to understand the different places we can register a dependency
    using `WorkoutHistoryTrackerService` as an example.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试理解我们可以使用`WorkoutHistoryTrackerService`作为示例来注册依赖项的不同位置。
- en: Registering dependencies
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册依赖项
- en: The standard way to register a dependency is to register it at the root/global
    level. This can be done either by passing the dependency type into the `provides` attribute
    (array) in the `NgModule` decorator, or by using the `providedIn` attribute on
    the `Injectable` service decorator.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注册依赖的标准方式是在根/全局级别注册。这可以通过在`NgModule`装饰器的`provides`属性（数组）中传递依赖类型，或者使用`Injectable`服务装饰器的`providedIn`属性来完成。
- en: 'Remember our `WorkoutHistoryTrackerService` registration? Check the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的`WorkoutHistoryTrackerService`注册吗？请检查以下内容：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The same thing can be done on the module declaration too, as shown here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的事情也可以在模块声明中完成，如下所示：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Technically speaking, when using any of the preceding mechanisms, the service
    gets registered with the **app's root injector**, irrespective of the Angular
    module it is declared in. Any Angular artifact across modules henceforth can use
    the service (`WorkoutHistoryTrackerService`). No module imports are required at
    all.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，当使用上述任何一种机制时，服务都会注册到应用的**根注入器**，而不管它在哪个 Angular 模块中声明。从今往后，任何跨模块的 Angular
    工件都可以使用该服务（`WorkoutHistoryTrackerService`）。根本不需要任何模块导入。
- en: This behavior is different from component/directive/pipe registration. Such
    artifacts have to be exported from a module for another module to use them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与组件/指令/管道注册不同。这样的工件必须从一个模块导出，以便另一个模块可以使用它们。
- en: '*Another place where dependencies can be registered is on the component*. The `@Component` decorator
    has a `providers` array parameter to register dependencies. With these two levels
    of dependency registration, the obvious question that we need to answer is, which
    one to use?'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*依赖项可以注册的另一个地方是在组件上*。`@Component` 装饰器有一个 `providers` 数组参数来注册依赖项。有了这两个依赖项注册级别，我们需要回答的明显问题是，哪一个该使用？'
- en: It seems obvious that if the dependency is exclusively used by a component and
    its children, it should be registered at the `@Component` decorator level. Not
    really! There is much more we need to understand before we can answer this question.
    There is a whole new world of hierarchical injectors that need to be introduced.
    Let's wait, and instead learn other ways of registering dependencies, by continuing
    our discussion on providers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果依赖项仅由组件及其子组件使用，它应该注册在 `@Component` 装饰器级别。但并非如此！在我们可以回答这个问题之前，我们还需要了解很多。需要介绍一个全新的分层注入器世界。让我们等待，并通过继续讨论提供者来学习注册依赖项的其他方法。
- en: '*Providers create dependencies when the Angular injector requests them*. *These
    providers have the recipe to create these dependencies*. While a class seems to
    be the obvious dependency that can be registered, we can also register:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*当 Angular 注入器请求时，提供者创建依赖项*。*这些提供者有创建这些依赖项的配方*。虽然类似乎是可以注册的明显依赖项，但我们也可以注册：'
- en: A specific object/value
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特定的对象/值
- en: A factory function
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂函数
- en: Registering `WorkoutHistoryTrackerService` using the `Injectable` decorator
    is the most common pattern of registration. But at times we need some flexibility
    with our dependency registrations. To register an object or a factory function,
    we need to use the expanded version of provider registrations available on `NgModule`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Injectable` 装饰器注册 `WorkoutHistoryTrackerService` 是最常见的注册模式。但有时我们需要在依赖项注册方面有一定的灵活性。要注册一个对象或工厂函数，我们需要使用在
    `NgModule` 上可用的提供者注册的扩展版本。
- en: To learn about these variations, we need to explore providers and dependency
    registration in a little more detail.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些变化，我们需要更详细地探索提供者和依赖项注册。
- en: Angular providers
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 提供者
- en: Providers create dependencies that are served by the DI framework.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者创建由 DI 框架提供的依赖项。
- en: 'Look at this `WorkoutHistoryTrackerService` dependency registration done on `NgModule`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在 `NgModule` 上完成的这个 `WorkoutHistoryTrackerService` 依赖项注册：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This syntax is a short-form notation for the following version:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法是以下版本的简写形式：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first property (`provide`) is a token that acts as a key for registering
    a dependency. This key also allows us to locate the dependency during dependency
    injection.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性（`provide`）是一个用作注册依赖项键的令牌。这个键也允许我们在依赖注入期间定位依赖项。
- en: The second property (`useClass`) is a *provider definition object* that defines
    the recipe for creating the dependency value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性（`useClass`）是一个**提供者定义对象**，它定义了创建依赖项值的配方。
- en: With `useClass`, we are registering a **class provider**.  *A class provider creates
    dependencies by instantiating the type of object requested for*. There are some
    other provider types.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useClass`，我们正在注册一个**类提供者**。**类提供者通过实例化请求的对象类型来创建依赖项**。还有一些其他的提供者类型。
- en: Value providers
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值提供者
- en: '*A class provider* creates class objects and fulfills the dependency, but at times we
    want to register a specific object/primitive with the DI provider instead. **Value
    providers** solve this use case.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*类提供者创建类对象并满足依赖项，但有时我们想在 DI 提供者中注册一个特定的对象/原始值*。**值提供者**解决了这个用例。'
- en: 'Had we registered `WorkoutHistoryTrackerService` using this technique, the
    registration would have looked like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这种技术注册 `WorkoutHistoryTrackerService`，注册将看起来像这样：
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*With the value provider, we have the responsibility to provide an instance
    of a service/object/primitive to Angular DI.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用值提供者，我们有责任为Angular DI提供一个服务/对象/原始实例。**'
- en: 'With the *value provider*, since we are creating the dependency manually, we
    are also responsible for constructing any child dependencies if there are dependencies
    further down the lineage. Take the example of `WorkoutHistoryTrackerService` again.
    If `WorkoutHistoryTrackerService` has some dependencies, those too need to be
    fulfilled by manual injection:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`value provider`，由于我们手动创建依赖项，因此我们也负责构建任何子依赖项（如果存在）。再次以`WorkoutHistoryTrackerService`为例。如果`WorkoutHistoryTrackerService`有一些依赖项，这些依赖项也需要通过手动注入来满足：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, we not only have to create an instance of `WorkoutHistoryTrackerService`,
    we also have to create an instance of the `LocalStorage` service. For a service
    with a complex dependency graph, setting up that service with a value provider
    becomes challenging.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们不仅要创建`WorkoutHistoryTrackerService`的实例，还要创建`LocalStorage`服务的实例。对于具有复杂依赖图的服务，使用值提供者设置该服务变得具有挑战性。
- en: Wherever possible, prefer *class provider* over *value provider*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，优先选择`class provider`而不是`value provider`。
- en: 'Value providers still come in handy in specific scenarios. For example, we
    can register a common app configuration using a value provider:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的场景中，值提供者仍然很有用。例如，我们可以使用值提供者注册一个通用的应用程序配置：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or register a mock dependency while unit testing:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在单元测试时注册一个模拟依赖项：
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Factory providers
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂提供者
- en: There are times when dependency construction is not a trivial affair. Construction
    depends upon external factors. These factors decide what objects or class instances
    are created and returned. **Factory providers** do this heavy lifting.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，依赖项构建并不是一件简单的事情。构建取决于外部因素。这些因素决定了创建和返回哪些对象或类实例。**工厂提供者**做这项繁重的工作。
- en: 'Take an example where we want to have different configurations for dev and
    production releases. We can very well use a factory implementation to select the
    right configuration:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子为例，我们想要为开发和生产发布提供不同的配置。我们可以很好地使用工厂实现来选择正确的配置：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A factory function can have its own dependencies too. In such a case, the syntax
    changes a bit:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数也可以有自己的依赖。在这种情况下，语法略有变化：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The dependencies are passed as a parameters to the factory function and registered
    on the provider definition object property, `deps` (`Environment` is the dependency
    injected in the preceding example).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖作为参数传递给工厂函数，并在提供者定义对象的属性`deps`上注册（在先前的例子中`Environment`是注入的依赖）。
- en: Use the `UseFactory` provide if the construction of the dependency is complex
    and not everything can be decided during dependency wire-up.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果依赖项的构建复杂，且在依赖项连接期间不能决定所有内容，请使用`UseFactory`提供。
- en: While we have a number of options to declare dependencies, consuming dependencies
    is far simpler. We saw one way of constructor injection in the *Injecting dependencies
    with Constructor Injection *section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有多种选项来声明依赖，但消费依赖要简单得多。我们在“使用构造函数注入注入依赖”这一节中看到了一种方法。
- en: Explicit injection using injector
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注入器进行显式注入
- en: 'We can even do explicit injections using Angular''s **Injector service**. This
    is the same injector Angular uses to support DI. Here is how to inject the `WorkoutHistoryTrackerService` service
    using `Injector`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用Angular的**Injector服务**进行显式注入。这是Angular用来支持DI的同一个注入器。以下是使用`Injector`注入`WorkoutHistoryTrackerService`服务的方法：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We inject the  `Injector` service and then ask for the `WorkoutHistoryTrackerService` instance
    explicitly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注入`Injector`服务，然后明确请求`WorkoutHistoryTrackerService`实例。
- en: When would someone want to do this? Well, almost never. Avoid this pattern as
    it exposes the DI container to your implementation and adds a bit of noise.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候有人会想这样做呢？嗯，几乎从不会。避免这种模式，因为它将DI容器暴露给实现，并增加了一些噪音。
- en: We now know how to register dependency and how to consume it, but how does the
    DI framework locate these dependencies?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何注册依赖和如何消费它，但DI框架是如何定位这些依赖的呢？
- en: Dependency tokens
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项令牌
- en: 'Remember this expanded version of dependency registration shown earlier:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 记住之前展示的依赖注册的扩展版本：
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `provide` property value is a **token**. This token is used to identify
    the dependency to inject. In the preceding example, we use class name or type
    to identify dependency and hence the token is called a **class token**.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`provide` 属性值是一个 **令牌**。此令牌用于标识要注入的依赖。在先前的示例中，我们使用类名或类型来标识依赖，因此该令牌被称为 **类令牌**。'
- en: 'Based on the preceding registration, whenever Angular sees a statement similar
    to the following, it injects the correct dependency based on the class type, here `WorkoutHistoryTrackerService`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 前面的注册，每当 Angular 看到类似以下语句时，它将根据类类型注入正确的依赖，这里 `WorkoutHistoryTrackerService`：
- en: '[PRE49]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Angular supports some other tokens too.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 还支持一些其他的令牌。
- en: Using InjectionToken
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 InjectionToken
- en: There are times when the dependency we define is either a primitive, object,
    or function. In such a scenario, the class token cannot be used as there is no
    class. Angular solves this problem using `InjectionToken` (or **string tokens** as
    we'll see later). The app configuration registration examples that we shared earlier
    can be rewritten using string tokens if there is no `AppConfig` class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们定义的依赖项要么是原始数据类型、对象或函数。在这种情况下，类令牌不能使用，因为没有类。Angular 通过使用 `InjectionToken` （或我们稍后将看到的**字符串令牌**）来解决这个问题。如果不存在 `AppConfig` 类，我们之前分享的应用配置注册示例可以使用字符串令牌重写。
- en: 'To register a dependency using `InjectionToken`, we first need to create the `InjectionToken` class
    instance:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `InjectionToken` 注册依赖，我们首先需要创建 `InjectionToken` 类实例：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, use the token to register the dependency:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用令牌来注册依赖：
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, inject the dependency anywhere using the `@Inject` decorator:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `@Inject` 装饰器在任何地方注入依赖：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Interestingly, when `@Inject()` is not present, the injector uses the type/class
    name of the parameter (*class token*) to locate the dependency.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当 `@Inject()` 不存在时，注入器使用参数的类型/类名（*类令牌*）来定位依赖。
- en: Using string tokens
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串令牌
- en: 'Angular also supports **string tokens**, allowing us to use string literals
    to identify and inject dependencies. The preceding example with a string token
    becomes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 也支持 **字符串令牌**，允许我们使用字符串字面量来标识和注入依赖。使用字符串令牌的前一个示例变为：
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A downside to string tokens is that you can misspell the token across the declaration
    and injection.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串令牌的一个缺点是，你可能会在声明和注入过程中拼写错误令牌。
- en: Phew! This was a really long section on Angular's Dependency Injection and there's
    still stuff left to cover. For now, let's get back on track and add the workout
    history page.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！这是关于 Angular 依赖注入的一个非常长的部分，还有很多内容要介绍。现在，让我们回到正轨，添加锻炼历史页面。
- en: Adding the workout history page
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加锻炼历史页面
- en: The workout history data that we are collecting during the execution of the
    workout can now be rendered in a view. Let's add a `History` component. The component
    will be available at the `/history` location and can be loaded by clicking on
    a link in the app header section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行锻炼过程中收集的锻炼历史数据现在可以在视图中呈现。让我们添加一个 `History` 组件。该组件将在 `/history` 位置可用，可以通过点击应用页眉部分中的链接来加载。
- en: 'Update the route definition in `app.routes.ts` to include a new route and the
    related import:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.routes.ts` 中更新路由定义以包含新的路由和相关导入：
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The History link needs to be added to the app header section. Let''s refactor
    the header section into its own component. Update the `app.component.html` template
    and replace the `nav` element with the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将 `History` 链接添加到应用页眉部分。让我们将页眉部分重构为其自己的组件。更新 `app.component.html` 模板，并用以下代码替换 `nav` 元素：
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `nav` element moves into a header component, which we still need to create.
    Use `ng generate` to generate a new `HeaderComponent` component by running the
    command inside the `trainer/src/app/core` folder:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `nav` 元素移动到页眉组件中，我们仍然需要创建它。在 `trainer/src/app/core` 文件夹内运行命令来使用 `ng generate` 生成一个新的 `HeaderComponent` 组件：
- en: '[PRE56]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This statement creates a new header component and declares it on the core module.
    Next, update the definition for the header component (`header.component.ts`) and
    its view (`header.component.html`) from the `checkpoint3.2` Git branch (GitHub
    location: [http://bit.ly/ng6be-3-2-header](http://bit.ly/ng6be-3-2-header)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句创建了一个新的页眉组件，并在核心模块中声明了它。接下来，从 `checkpoint3.2` Git 分支（GitHub 位置：[http://bit.ly/ng6be-3-2-header](http://bit.ly/ng6be-3-2-header)）更新页眉组件的定义（`header.component.ts`）及其视图（`header.component.html`）。
- en: 'While we have added the header element to `app.component.html`, the header
    component will not render unless we import the core module and export the component
    from the core module. Angular CLI did the first part for us, for the second part,
    update `core.module.ts` to:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经向`app.component.html`添加了标题元素，但除非我们导入核心模块并从核心模块导出组件，否则标题组件不会渲染。Angular
    CLI为我们完成了第一部分，对于第二部分，更新`core.module.ts`如下：
- en: '[PRE57]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you look at the `HeaderComponent` view, the history link is now there. We
    had to import `RouterModule` as the following link is generated using the `RouterLink` directive,
    which is part of `RouterModule`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`HeaderComponent`的视图，历史链接现在就在那里。我们必须导入`RouterModule`，因为以下链接是使用`RouterLink`指令生成的，而`RouterLink`是`RouterModule`的一部分：
- en: '[PRE58]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s add the workout history component by first generating the component''s
    boilerplate. From the command line, navigate to `trainer/src/app` and run:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过生成组件的模板来添加锻炼历史组件。从命令行导航到`trainer/src/app`并运行：
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `WorkoutHistoryComponent` implementation is available in the `checkpoint3.2` Git
    branch; the folder is `workout-history` (GitHub location: [http://bit.ly/ng6be-3-2-workout-history](http://bit.ly/ng6be-3-2-workout-history)).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryComponent`的实现可以在`checkpoint3.2`Git分支中找到；文件夹是`workout-history`（GitHub位置：[http://bit.ly/ng6be-3-2-workout-history](http://bit.ly/ng6be-3-2-workout-history))。'
- en: 'The `WorkoutHistoryComponent` view code is trivial, to say the least: a few
    Angular constructs, including `ngFor` and `ngIf`. The component implementation
    too is pretty straightforward. Inject the `WorkoutHistoryTrackerService` service
    dependency and load the history data when `WorkoutHistoryComponent` is initialized:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 至少可以说，`WorkoutHistoryComponent`的视图代码很简单：一些Angular构造，包括`ngFor`和`ngIf`。组件实现也很简单。注入`WorkoutHistoryTrackerService`服务依赖项，并在`WorkoutHistoryComponent`初始化时加载历史数据：
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And this time, we use the `Location` service instead of `Router` to navigate
    away from the `history` component:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`Location`服务而不是`Router`来从`history`组件导航离开：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Location service is used to interact with the browser URL. Depending upon
    the URL strategy, either URL paths (such as `/start` or `/workout`) or URL hash
    segments (such as `#/start` or `#/workout`) are used to track location changes.
    The router service internally uses the location service to trigger navigation.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 位置服务用于与浏览器URL交互。根据URL策略，要么使用URL路径（例如`/start`或`/workout`），要么使用URL哈希段（例如`#/start`或`#/workout`）来跟踪位置变化。路由器服务内部使用位置服务来触发导航。
- en: Router versus Location
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器与位置
- en: While the `Location` service allows us to perform navigation, using `Router` is
    a preferred way of performing route navigation. We used the location service here
    because the need was to navigate to the last route without bothering about how
    to construct the route.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Location`服务允许我们执行导航，但使用`Router`是执行路由导航的首选方式。我们在这里使用位置服务是因为需要导航到最后一个路由，而不必担心如何构建路由。
- en: 'We are ready to test our workout history implementation. Load the start page
    and click on the History link. The history page is loaded with an empty grid.
    Go back, start a workout, and let an exercise complete. Check the history page
    again; there should be a workout listed:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好测试我们的锻炼历史实现。加载起始页面并点击“历史”链接。历史页面加载了一个空网格。返回，开始锻炼，并完成一项练习。再次检查历史页面；应该有一个锻炼被列出：
- en: '![](img/00023.jpeg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.jpeg)'
- en: Looks good! If we run the workout multiple times and let the history list build,
    we realize there is one sore point in this listing. Historical data is not sorted
    in reverse-chronological order, with the newest at the top. Also, it would be
    great if we had some filtering capabilities.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！如果我们多次运行锻炼并让历史记录列表累积，我们会发现这个列表中有一个痛点。历史数据没有按倒序时间排序，最新数据在顶部。此外，如果我们有一些过滤功能那就太好了。
- en: Sorting and filtering history data using pipes
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道排序和过滤历史数据
- en: In Chapter 2, *Building Our First App – 7-Minute Workout*, we explored pipes.
    We even built our own pipe to format the seconds values as hh:mm:ss. The primary
    purpose of pipes is to transform data and, surprisingly, they work on arrays too!
    For arrays, pipes can sort and filter data. We create two pipes, one for each sorting
    and filtering.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章，“构建我们的第一个应用 - 7分钟锻炼”，我们探讨了管道。我们甚至构建了自己的管道来格式化秒数值为hh:mm:ss。管道的主要目的是转换数据，而且令人惊讶的是，它们也可以在数组上工作！对于数组，管道可以排序和过滤数据。我们创建了两个管道，一个用于排序，一个用于过滤。
- en: AngularJS has prebuilt filters (filters are pipes in Angular), `orderBy` and `filter`,
    for this very purpose. Angular does not come with these pipes and there is a good
    reason. These pipes are prone to poor performance. Learn the rationale behind
    this decision in the framework documentation on pipes at [http://bit.ly/ng-no-filter-orderby-pipe](http://bit.ly/ng-no-filter-orderby-pipe).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 预建了用于此目的的过滤器（在 Angular 中，过滤器是管道），`orderBy` 和 `filter`。Angular 并不自带这些管道，这有一个很好的原因。这些管道容易导致性能不佳。在框架文档中了解关于管道的决策背后的理由：[http://bit.ly/ng-no-filter-orderby-pipe](http://bit.ly/ng-no-filter-orderby-pipe)。
- en: Let's start with the `orderBy` pipe.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `orderBy` 管道开始。
- en: The orderBy pipe
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序管道
- en: 'The `orderBy` pipe we implement is going to order an array of objects based
    on any of the object''s properties. The usage pattern for sorting items in ascending
    order based on the `fieldName` property is going to be:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的 `orderBy` 管道将根据对象的任何属性对对象数组进行排序。根据 `fieldName` 属性按升序排序的项目使用模式如下：
- en: '[PRE62]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And for sorting items in descending order, the usage pattern is:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按降序排序项目，使用模式如下：
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Make note of the extra hyphen (`-`) before `fieldName`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `fieldName` 前面的额外连字符（`-`）。
- en: We plan to add `OrderByPipe` in a new shared module. Are you thinking, why not
    add it to core module? By convention, the core module contains global services
    and one-time-use components. This is exactly one core module per application.
    Shared modules, on the other hand, have components/directives/pipes that are shared across
    modules. Such shared modules can be also be defined at multiple levels, across
    the parent and child modules. In this case, we will define the shared module inside `AppModule`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在新的共享模块中添加 `OrderByPipe`。你在想，为什么不添加到核心模块中呢？按照惯例，核心模块包含全局服务和一次性使用的组件。每个应用程序只有一个核心模块。另一方面，共享模块包含跨模块共享的组件/指令/管道。这样的共享模块也可以在多个级别上定义，跨越父模块和子模块。在这种情况下，我们将在
    `AppModule` 内定义共享模块。
- en: 'Create a new `SharedModule` module by running this command in the `trainer/src/app` directory:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `trainer/src/app` 目录中运行此命令来创建新的 `SharedModule` 模块：
- en: '[PRE64]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'From the command line, navigate to the `trainer/src/app/shared` folder and
    generate the order by pipe boilerplate:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行导航到 `trainer/src/app/shared` 文件夹并生成排序管道模板：
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open `order-by.pipe.ts` and update the definition from the checkpoint3.2 code
    (GitHub location: [http://bit.ly/ng6be-3-2-order-by-pipe](http://bit.ly/ng6be-3-2-order-by-pipe)).
    While we are not going to delve into the pipe''s implementation details, some
    relevant parts need to be highlighted. Look at this pipe outline:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `order-by.pipe.ts` 并更新定义，从 checkpoint3.2 代码（GitHub 位置：[http://bit.ly/ng6be-3-2-order-by-pipe](http://bit.ly/ng6be-3-2-order-by-pipe)）中获取。虽然我们不会深入探讨管道的实现细节，但一些相关部分需要突出显示。看看这个管道概要：
- en: '[PRE66]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding `field` variable receives the field on which sorting is required. If
    the field has a `-` prefix, we truncate the prefix before sorting the array in
    descending order.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `field` 变量接收需要排序的字段。如果字段有 `-` 前缀，我们在按降序排序数组之前截断前缀。
- en: The pipe also uses the spread operator, `[...]`, which may be new to you. Learn
    more about the spread operator on MDN at [http://bit.ly/js-spread](http://bit.ly/js-spread).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道还使用了扩展运算符 `...`，这可能对你来说很新。在 MDN 上了解更多关于扩展运算符的信息：[http://bit.ly/js-spread](http://bit.ly/js-spread)。
- en: 'To use `OrderByPipe`, update the template view for workout history:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `OrderByPipe`，更新 `workout` 历史视图的模板：
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And again, we need to export the pipe from the shared module allowing `WorkoutHistoryComponent` to
    use it. Add an exports property on `SharedModule` and set it to `OrderByPipe`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要从共享模块导出管道，允许 `WorkoutHistoryComponent` 使用它。在 `SharedModule` 上添加一个 `exports`
    属性并将其设置为 `OrderByPipe`：
- en: '[PRE68]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The historical data will now be sorted in descending order on the `startedOn` field.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 历史数据现在将根据 `startedOn` 字段按降序排序。
- en: Make note of the single quotes around the pipe parameter (`'-startedOn'`). We
    are passing a literal string to the `orderBy` pipe. Pipe parameters support data
    binding and can be bound to component properties too.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意管道参数（`'-startedOn'`）周围的单引号。我们正在将一个字面字符串传递给 `orderBy` 管道。管道参数支持数据绑定，也可以绑定到组件属性。
- en: That's enough for the `orderBy` pipe. Let's implement filtering.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `orderBy` 管道来说，这就足够了。让我们来实现过滤功能。
- en: Pipe chaining with search pipe
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与搜索管道的管道链
- en: 'We start by creating the search pipe boilerplate by running the following command
    from the `trainer/src/app/shared` folder:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在 `trainer/src/app/shared` 文件夹中运行以下命令来创建搜索管道模板：
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The implementation can now be copied from checkpoint3.2 (GitHub location: [http://bit.ly/ng6be-3-2-search-pipe](http://bit.ly/ng6be-3-2-search-pipe)). `SearchPipe` does
    a basic equality-based filtering. Nothing special.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 实现现在可以从checkpoint3.2（GitHub位置：[http://bit.ly/ng6be-3-2-search-pipe](http://bit.ly/ng6be-3-2-search-pipe)）复制。`SearchPipe`执行基于基本相等性的过滤。没有什么特别的。
- en: Look at the pipe code; the pipe takes two arguments, the first being the field
    to search, and the second the value to search. We use the JavaScript array's `filter` function
    to filter the record, doing a strict equality check. Wondering about the `pure` attribute
    on the `Pipe` decorator? This is going to be the subject of discussion in the
    next section.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 看看管道代码；管道接受两个参数，第一个是要搜索的字段，第二个是要搜索的值。我们使用JavaScript数组的`filter`函数来过滤记录，进行严格的相等性检查。关于`Pipe`装饰器上的`pure`属性有什么疑问吗？这将是下一节讨论的主题。
- en: 'Let''s update the workout history view and incorporate the search pipe too.
    Open `workout-history.component.html` and uncomment the div with radio buttons.
    These radio buttons filter workouts based on whether they were completed or not.
    This is how the HTML filter selection looks:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新锻炼历史视图并包含搜索管道。打开`workout-history.component.html`并取消注释包含单选按钮的div。这些单选按钮根据是否完成来过滤锻炼。这是HTML过滤器选择看起来像这样：
- en: '[PRE70]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We define three filters: `all`, `completed`, and `incomplete` workouts. The
    radio selection sets the component's `completed` property using the `change` event
    expression. `$event.target` is the radio button that was clicked.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个过滤器：`all`、`completed`和`incomplete`工作集。通过使用`change`事件表达式，单选按钮选择设置组件的`completed`属性。`$event.target`是点击的单选按钮。
- en: 'The `search` pipe can now be added to the `ngFor` directive expression. We
    are going to chain the `search` and `orderBy` pipes. Update the `ngFor` expression
    to:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将`search`管道添加到`ngFor`指令表达式中。我们将链式连接`search`和`orderBy`管道。更新`ngFor`表达式为：
- en: '[PRE71]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A great example of Angular's pipe chaining capabilities!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Angular管道链式功能的一个很好的例子！
- en: As we did with `OrderByPipe`, `SearchPipe` too needs to be exported from the
    shared module before using it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`OrderByPipe`中所做的那样，`SearchPipe`也需要在使用之前从共享模块中导出。
- en: 'The `search` pipe first filters the historical data, followed by the `orderBy` pipe
    reordering it. Pay close attention to the `search` pipe parameters: the first
    parameter is a string literal denoting the field to search (`historyItem.completed`),
    whereas the second parameter is derived from the component''s `completed` property.
    Having the ability to bind pipe parameters to component properties allows us great
    flexibility.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`管道首先过滤历史数据，然后由`orderBy`管道重新排序。请特别注意`search`管道的参数：第一个参数是一个表示要搜索字段的字符串字面量（`historyItem.completed`），而第二个参数是从组件的`completed`属性派生出来的。能够将管道参数绑定到组件属性使我们具有很大的灵活性。'
- en: Go ahead and verify the search capabilities of the history page. Based on the
    radio selection, the history records are filtered, and of course, they are sorted
    in reverse-chronological order based on the workout start dates.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 继续验证历史页面的搜索功能。根据单选按钮的选择，历史记录被过滤，当然，它们根据锻炼开始日期按逆时间顺序排序。
- en: While pipe usage with arrays looks simple, it can throw up some surprises if
    we do not understand when pipes are evaluated.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用数组的管道看起来很简单，但如果我们不了解管道何时被评估，它可能会带来一些惊喜。
- en: Pipe gotcha with arrays
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组管道的注意事项
- en: To understand the issue with pipes applied to arrays, let's reproduce the problem.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解应用于数组的管道的问题，让我们重现这个问题。
- en: 'Open `search.pipe.ts` and remove the `@Pipe` decorator''s `pure` attribute.
    Also, take the following statement:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`search.pipe.ts`并移除`@Pipe`装饰器的`pure`属性。同时，取以下语句：
- en: '[PRE72]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And change it into this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其更改为这样：
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add a button at the end of the radio list (in `workout-history.component.html`)
    that adds a new log entry to the `history` array:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-history.component.html`的收尾处添加一个按钮，该按钮将新的日志条目添加到`history`数组中：
- en: '[PRE74]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add a function to `WorkoutHistoryComponent`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 向`WorkoutHistoryComponent`添加一个函数：
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding function duplicates the first history item and adds back to the `history` array.
    If we load the page and click on the button, a new log entry gets added to the
    history array, but it does not show up on the view unless we change the filter
    (by clicking on the other radios). Interesting!
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数复制了第一个历史条目并将其添加回`history`数组。如果我们加载页面并点击按钮，则会在历史数组中添加一个新的日志条目，但除非我们更改过滤器（通过点击其他单选按钮），否则它不会显示在视图中。有趣！
- en: Before calling `addLog` make sure at least one history log is already there;
    otherwise the `addLog` function will fail.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `addLog` 之前，确保至少已经存在一个历史日志；否则，`addLog` 函数将失败。
- en: The pipes that we have built thus far are **stateless** (also called **pure**)
    in nature. They simply transform input data into output. **Stateless** **pipes** are
    reevaluated only if the pipe input changes (the expression on the left side of
    pipe symbol) or any pipe argument is updated.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的管道在本质上是无状态的（也称为**纯**）。它们只是将输入数据转换为输出。**无状态****管道**仅在管道输入更改（管道符号左侧的表达式）或任何管道参数更新时重新评估。
- en: For arrays, this happens on an array assignment/reference change and not on
    the addition or deletion of elements. Switching the filter condition works, as
    it causes the search pipe to evaluate again as the search parameter (the `completed` status)
    changes. This behavior is something to be aware of.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，这发生在数组赋值/引用更改时，而不是在添加或删除元素时。切换过滤器条件有效，因为它会导致搜索管道再次评估，因为搜索参数（`completed`
    状态）已更改。这种行为是需要注意的。
- en: 'What''s the fix? For starters, we can make the history array immutable, which
    implies that it cannot be changed once created. To add a new element, we need
    to create a new array with the new value, something like:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是什么？首先，我们可以使历史数组不可变，这意味着一旦创建后就不能更改。要添加一个新元素，我们需要创建一个新的数组，并包含新的值，类似于：
- en: '[PRE76]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This works perfectly, but we are changing our implementation to make it work
    with pipes which is incorrect. Instead, we can change the pipe. The pipe should
    be marked stateful.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但我们正在更改我们的实现，使其与管道一起工作，这是不正确的。相反，我们可以更改管道。该管道应该被标记为有状态的。
- en: The difference between a stateless and stateful pipe is that stateful pipes
    are evaluated by Angular every time the framework does a change-detection run,
    which involves checking the complete application for changes. Therefore, with
    stateful pipes, the check is not limited to the pipe input/argument changes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态管道和有状态管道之间的区别在于，有状态管道在 Angular 每次进行变更检测运行时都会被评估，这涉及到检查整个应用程序的变化。因此，在有状态管道中，检查不仅限于管道输入/参数的变化。
- en: 'To make a `search` pipe stateless, just revert the first change we made and
    add back `pure: false` on the `Pipe` decorator:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '要使 `search` 管道无状态，只需撤销我们做的第一个更改，并在 `Pipe` 装饰器上添加 `pure: false`：'
- en: '[PRE77]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: It still does not work! The `search` pipe has one more quirk that needs a fix.
    The All radio selection does not work perfectly. Add a new workout log, and it
    still will not show up, unless we switch filters.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不起作用！`search` 管道还有一个需要修复的怪癖。全选单选按钮并不完美。添加一个新的锻炼日志，它仍然不会显示，除非我们切换过滤器。
- en: 'The fix here is to revert the second change. Isolate this line in the `search` pipe:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的修复是撤销第二个更改。在 `search` 管道中隔离这一行：
- en: '[PRE78]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And change it to the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其更改为以下内容：
- en: '[PRE79]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We changed the `if` condition to return a new array every time (using the spread
    operator), even when `searchTerm` is `null`. If we return the same array reference,
    Angular does not check for a size change in the array and hence does not update
    the UI.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `if` 条件更改为每次都返回一个新的数组（使用展开运算符），即使 `searchTerm` 是 `null`。如果我们返回相同的数组引用，Angular
    不会检查数组的大小变化，因此不会更新 UI。
- en: That completes our History page implementation. You may now be wondering what
    the last few fixes on pipes have to do with how change detection works. Or you
    may be wondering what change detection is. Let's put all of these doubts to rest
    and introduce everyone to *Angular's change-detection system*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的历史页面实现。你现在可能想知道管道的最后几个修复与变更检测的工作方式有什么关系。或者你可能想知道什么是变更检测。让我们消除所有这些疑虑，并向大家介绍
    *Angular 的变更检测系统*。
- en: Angular's change detection will be covered extensively in Chapter 8, *Some Practical
    Scenarios*. The aim of the next section is to introduce the concept of change
    detection and how Angular performs this process.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的变更检测将在第 8 章，*一些实际场景*中详细介绍。下一节的目标是介绍变更检测的概念以及 Angular 如何执行此过程。
- en: Angular change detection overview
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 变更检测概述
- en: To put it succinctly, change detection is all about tracking changes done to
    the component's model during app execution. This helps Angular's data-binding
    infrastructure to identify what parts of the view need to be updated. Every data
    binding framework needs to address this issue, and the approach these frameworks
    take for tracking changes differs. It even differs from AngularJS to Angular.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，变更检测就是跟踪应用执行期间对组件模型的更改。这有助于Angular的数据绑定基础设施确定哪些视图部分需要更新。每个数据绑定框架都需要解决这个问题，并且这些框架跟踪更改的方法各不相同。甚至从AngularJS到Angular也有所不同。
- en: To understand how change detection works in Angular, there are a few things
    that we need to keep in mind.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Angular中的变更检测是如何工作的，我们需要注意以下几点。
- en: An Angular app is nothing but a hierarchy of components, from the root to the
    leaf.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Angular应用不过是由组件组成的层次结构，从根到叶。
- en: There is nothing special about the component properties that we bind to view;
    therefore Angular needs an efficient mechanism to know when these properties change.
    It cannot keep polling for changes in these properties.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们绑定到视图的组件属性并没有什么特殊之处；因此，Angular需要一个高效的机制来知道这些属性何时发生变化。它不能持续轮询这些属性的变化。
- en: To detect changes in a property value, Angular does a *strict comparison* (`===`)
    between the previous and current value. For reference types, it means only the
    references are compared. No deep comparison is done.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测属性值的变化，Angular在先前值和当前值之间进行**严格比较**（`===`）。对于引用类型，这意味着只比较引用。不进行深度比较。
- en: For precisely this reason, we had to mark our search pipe as stateful. Adding
    elements to an existing array does not change the array reference and hence Angular
    fails to detect any change in the array. Once the pipe is marked as stateful,
    the pipe is evaluated, irrespective of whether the array has changed or not.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们不得不将我们的搜索管道标记为有状态的。向现有数组添加元素不会改变数组引用，因此Angular无法检测到数组中的任何变化。一旦管道被标记为有状态的，无论数组是否已更改，管道都会被评估。
- en: Since Angular cannot know when any bound property is updated automatically,
    it instead resorts to checking every bound property when a change detection run
    is triggered. Starting from the root of the component tree, Angular checks each
    bound property for changes as it goes down the component hierarchy. If a change
    is detected, that component is marked for refresh. It's worth reiterating that
    changes in a bound property do not immediately update the view. Instead, a change-detection
    run works in two phases.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular无法知道任何绑定属性何时自动更新，因此它会在触发变更检测运行时检查每个绑定属性。从组件树的根开始，Angular在遍历组件层次结构时检查每个绑定属性的变化。如果检测到变化，则标记该组件为刷新。值得重申的是，绑定属性的变化并不会立即更新视图。相反，变更检测运行分为两个阶段。
- en: In the *first phase*, it does the component tree walk and marks components that
    need to be refreshed due to model updates
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**第一阶段**，它遍历组件树，并标记因模型更新需要刷新的组件。
- en: In the *second phase*, the actual view is synchronized with the underlying model
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**第二阶段**，实际视图与底层模型同步。
- en: Model changes and view updates are never interleaved during a change-detection
    run.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在变更检测运行期间，模型更改和视图更新永远不会交织在一起。
- en: 'We now just need to answer two more questions:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要回答两个更多的问题：
- en: When is a change-detection run triggered?
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更检测运行何时被触发？
- en: How many times does it run?
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它运行了多少次？
- en: 'An Angular change-detection run is triggered when any of these events are triggered:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下任何事件被触发时，Angular的变更检测运行会被触发：
- en: '**User input/browser events**: We click on a button, enter some text, scroll
    the content. Each of these actions can update the view (and the underlying model).'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入/浏览器事件**：我们点击按钮、输入文本、滚动内容。这些操作中的每一个都可以更新视图（以及底层模型）。'
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程XHR请求**：这是视图更新的另一个常见原因。从远程服务器获取数据以显示在网格上，以及获取用户数据以渲染视图都是这种情况的例子。'
- en: '**setTimeout and setInterval**: As it turns out, we can use `setTimeout` and `setInterval` to
    execute some code asynchronously and at specific intervals. Such code can also
    update the model. For example, a `setInterval` timer may check for stock quotes
    at regular intervals and update the stock price on the UI.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setTimeout和setInterval**：实际上，我们可以使用`setTimeout`和`setInterval`来异步执行一些代码，并在特定的时间间隔内执行。这样的代码也可以更新模型。例如，一个`setInterval`计时器可能会定期检查股票报价，并在UI上更新股票价格。'
- en: To answer how many times, **it's one**. Each component model is checked only
    once, in a top-down fashion, starting from the root component to the tree leaves.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答“多少次”，**答案是1次**。每个组件模型只检查一次，以自顶向下的方式，从根组件到树叶子。
- en: The last statement is true when Angular is configured to run in production mode.
    In development mode, the component tree is traversed twice for changes. Angular
    expects the model to be stable after the first tree walk. If that is not the case,
    Angular throws an error in development mode, and ignores the changes in production
    mode. We can enable the production mode by invoking the `enableProdMode` function
    before the `bootstrap` function call.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular配置为生产模式运行时，上述说法是正确的。在开发模式下，组件树会被遍历两次以检测更改。Angular期望在第一次树遍历后模型是稳定的。如果情况不是这样，Angular会在开发模式下抛出错误，并在生产模式下忽略更改。我们可以在调用`bootstrap`函数之前通过调用`enableProdMode`函数来启用生产模式。
- en: It's time now to pick another topic linked to Angular's depedency injection.
    The concept of **hierarchical injectors** will be our next topic of discussion. 
    It is a very powerful feature that can come in handy as we build bigger and better
    apps using Angular.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候选择另一个与Angular的依赖注入相关的主题了。**分层注入器**的概念将成为我们接下来讨论的主题。这是一个非常强大的功能，在我们使用Angular构建更大更好的应用时非常有用。
- en: Hierarchical injectors
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层注入器
- en: An **injector** in Angular's dependency injection setup is a container that is responsible for
    storing dependencies and dispensing them when asked for. The provider registration
    examples shared earlier actually register the dependencies with a global injector.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的依赖注入设置中，**注入器**是一个容器，负责存储依赖项并在需要时提供它们。之前分享的提供者注册示例实际上是将依赖项注册到一个全局注入器中。
- en: Registering component-level dependencies
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册组件级别的依赖
- en: All of the dependency registrations that we have done thus far were done on
    a module. Angular goes one step further and allows registration of dependencies
    at the component level too. There is a similar `providers` attribute on the `@Component` decorator
    that allows us to register dependency at the component level.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所做的所有依赖项注册都是在模块上完成的。Angular更进一步，允许在组件级别注册依赖项。在`@Component`装饰器上也有类似的`providers`属性，允许我们在组件级别注册依赖项。
- en: 'We could''ve very well registered the `WorkoutHistoryTrackerService` dependency
    on `WorkoutRunnerComponent`. Something along these lines:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全可以在`WorkoutRunnerComponent`上注册`WorkoutHistoryTrackerService`依赖项。大致如下：
- en: '[PRE80]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: But whether we should do it or not is something that we discuss here.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们是否应该这样做是我们在这里讨论的问题。
- en: In the context of this discussion on hierarchical injectors, it's important
    to understand that Angular creates an injector per component (oversimplified).
    Dependency registration done at the component level is available on the component
    and its descendants.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于分层注入器的讨论背景下，重要的是要理解Angular为每个组件创建一个注入器（简化说明）。在组件级别完成的依赖注册在组件及其后代中都是可用的。
- en: We also learned that dependencies are singleton in nature. Once created, the
    injector will always return the same dependency every time. This feature is evident
    from the workout history implementation.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到依赖项本质上是单例的。一旦创建，注入器将始终在每次请求时返回相同的依赖项。这一特性在锻炼历史实现中很明显。
- en: '`WorkoutHistoryTrackerService` was registered with the `CoreModule` and then
    injected into two components: `WorkoutRunnerComponent` and `WorkoutHistoryComponent`.
    Both components get the same instance of `WorkoutHistoryTrackerService`. The next
    diagram highlights this registration and injection:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryTrackerService`与`CoreModule`注册，然后注入到两个组件中：`WorkoutRunnerComponent`和`WorkoutHistoryComponent`。这两个组件都获得`WorkoutHistoryTrackerService`的相同实例。下个图例突出了这个注册和注入：'
- en: '![](img/00024.jpeg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00024.jpeg)'
- en: 'To confirm, just add a `console.log` statement in the `WorkoutHistoryTrackerService` constructor:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认，只需在`WorkoutHistoryTrackerService`构造函数中添加一个`console.log`语句：
- en: '[PRE81]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Refresh the app and open the history page by clicking on the header link. The
    message log is generated once, irrespective of how many times we run the workout
    or open the history page.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击页眉链接刷新应用并打开历史页面。无论我们运行锻炼或打开历史页面多少次，消息日志只生成一次。
- en: That's also a new interaction/data flow pattern!
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种新的交互/数据流模式！
- en: Think carefully; a service is being used to share state between two components. `WorkoutRunnerComponent` is
    generating data and `WorkoutHistoryComponent` is consuming it. And without any
    interdependence. We are exploiting the fact that dependencies are singleton in
    nature. This data-sharing/interaction/data-flow pattern can be used to share state
    between any number of components. Indeed, this is a very powerful weapon in our
    arsenal. The next time there is a need to share state between unrelated components,
    think of services.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考；正在使用一个服务在两个组件之间共享状态。`WorkoutRunnerComponent`正在生成数据，而`WorkoutHistoryComponent`正在消费它。并且没有任何相互依赖。我们正在利用依赖本质上是单例的事实。这种数据共享/交互/数据流模式可以用来在任意数量的组件之间共享状态。实际上，这是我们武器库中非常强大的武器。下次需要在不相关的组件之间共享状态时，想想服务。
- en: But what does all this have to do with hierarchical injectors? OK, let's not
    beat around the bush; let's get straight to the point.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 但这一切与分层注入器有什么关系？好吧，我们不再绕弯子；让我们直接进入正题。
- en: While dependencies registered with the injector are singleton, `Injector` itself
    is not! At any given point in time, there are multiple injectors active in the
    application. In fact, injectors are created in the same hierarchy as the component
    tree. Angular creates an `Injector` instance for every component in the component
    tree (oversimplification; see the next information box).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与注入器注册的依赖项是单例的，但`Injector`本身不是！在任何给定的时间点，应用程序中都有多个活动注入器。实际上，注入器是在与组件树相同的层次结构中创建的。Angular为组件树中的每个组件创建一个`Injector`实例（这是一个简化的说法；请参见下一个信息框）。
- en: 'Angular does not literally create an injector for each component. As explained
    in the Angular developer guide: every component doesn''t need its own injector
    and it would be horribly inefficient to create masses of injectors for no good
    purpose. But it is true that every component has an injector (even if it shares
    that injector with another component) and there may be many different injector
    instances operating at different levels of the component tree. It is useful to
    pretend that every component has its own injector.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Angular并不是为每个组件都创建一个注入器。正如Angular开发者指南中解释的那样：每个组件不需要自己的注入器，为没有好处的目的创建大量的注入器将会非常低效。但确实，每个组件都有一个注入器（即使它与其他组件共享该注入器），并且可能存在许多不同的注入器实例在不同的组件树层级上运行。假装每个组件都有自己的注入器是有用的。
- en: 'The component and injector tree looks something like this when a workout is
    running:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个锻炼正在进行时，组件和注入器树看起来大致如下：
- en: '![](img/00025.jpeg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: The insert textbox denotes the component name. The **root injector** is the
    injector created as part of the application bootstrap process.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 插入文本框表示组件名称。**根注入器**是在应用程序引导过程中创建的注入器。
- en: What is the significance of this injector hierarchy? To understand the implications,
    we need to understand what happens when a component requests a dependency.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注入器层次结构的意义是什么？为了理解其影响，我们需要了解当组件请求依赖项时会发生什么。
- en: Angular DI dependency walk
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular DI依赖项遍历
- en: 'Whenever requested for a dependency, Angular first tries to satisfy the dependency
    from the component''s own injector. If it fails to find the requested dependency,
    it queries the parent component injector for the dependency, and its parent if
    the probing fails again, and so on and so forth till it finds the dependency or
    reaches the root injector. The takeaway: any dependency search is hierarchy-based.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求一个依赖项时，Angular首先尝试从组件自己的注入器中满足依赖项。如果它找不到请求的依赖项，它会查询父组件注入器以获取依赖项，如果探测失败，它会查询父组件的父组件，以此类推，直到找到依赖项或达到根注入器。要点：任何依赖项搜索都是基于层次的。
- en: Earlier when we registered `WorkoutHistoryTrackerService`, it was registered
    with the root injector. The `WorkoutHistoryTrackerService` dependency request
    from both `WorkoutRunnerComponent` and `WorkoutHistoryComponent` gets satisfied
    by the root injector, and not by their own component injectors.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前注册`WorkoutHistoryTrackerService`时，它是与根注入器一起注册的。来自`WorkoutRunnerComponent`和`WorkoutHistoryComponent`的`WorkoutHistoryTrackerService`依赖项请求由根注入器满足，而不是由它们自己的组件注入器满足。
- en: This hierarchical injector structure brings a lot of flexibility. We can configure
    different providers at different component levels and override the parent provider
    configuration in child components. This only applies to dependencies registered
    on components. If the dependency is added to a module, it gets registered on the
    root injector.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这种层次注入器结构带来了很多灵活性。我们可以在不同的组件级别配置不同的提供者，并在子组件中覆盖父提供者配置。这仅适用于在组件上注册的依赖项。如果依赖项被添加到模块中，它将在根注入器上注册。
- en: 'Also, if a dependency is registered at the component level, its life cycle
    is bound to the component''s life cycle. The dependency is created every time
    the component is loaded, and destroyed when the component is destroyed. Unlike
    module-level dependencies that are created only once: when requested for the first
    time.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果依赖项在组件级别注册，其生命周期将与组件的生命周期绑定。每次组件加载时都会创建依赖项，当组件被销毁时销毁。与仅在第一次请求时创建的模块级别依赖项不同。
- en: Let's try to override the global `WorkoutHistoryTrackerService` service in components
    that use it to learn what happens on such overrides. It's going to be fun and
    we will learn a lot!
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在使用它的组件中尝试覆盖全局的`WorkoutHistoryTrackerService`服务，以了解在这样覆盖时会发生什么。这将很有趣，我们将学到很多！
- en: 'Open `workout-runner.component.ts` and add a `providers` attribute to the `@Component` decorator:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-runner.component.ts`并为`@Component`装饰器添加一个`providers`属性：
- en: '[PRE82]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Do this in `workout-history.component.ts` too. Now if we refresh the app, start
    a workout, and then load the history page, the grid is empty. Irrespective of
    the times we try to run the workout, the history grid is always empty.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-history.component.ts`中也这样做。现在如果我们刷新应用，开始锻炼，然后加载历史页面，网格是空的。无论我们尝试运行锻炼多少次，历史网格总是空的。
- en: 'The reason is quite obvious. After setting the `WorkoutHistoryTrackerService` provider
    on each `WorkoutRunnerComponent` and `WorkoutHistoryComponent`, the dependency
    is being fulfilled by the respective component injectors themselves. Both component
    injectors create their own instance of `WorkoutHistoryTrackerService` when requested,
    and hence the history tracking is broken. Look at the following diagram to understand
    how the request is fulfilled in both scenarios:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很明显。在为每个`WorkoutRunnerComponent`和`WorkoutHistoryComponent`设置`WorkoutHistoryTrackerService`提供者之后，依赖项由各自的组件注入器本身来满足。当请求时，两个组件注入器都会创建自己的`WorkoutHistoryTrackerService`实例，因此历史跟踪被破坏。查看以下图表以了解在两种情况下请求是如何被满足的：
- en: '![](img/00026.jpeg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00026.jpeg)'
- en: 'A quick question: what happens if we register the dependency in the root component, `TrainerAppComponent`,
    instead of doing it on the module? Something like this:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速问题：如果我们不在模块上而是在根组件`TrainerAppComponent`中注册依赖项，会发生什么？类似于以下这样：
- en: '[PRE83]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Interestingly, with this setup too, things work perfectly. That's pretty evident; `TrainerAppComponent` is
    a parent component for `RouterOutlet` that internally loads `WorkoutRunnerComponent` and `WorkoutHistoryComponent`.
    Hence in such a setup, the dependency gets fulfilled by the `TrainerAppComponent` injector.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这种设置下，一切工作得都很完美。这一点很明显；`TrainerAppComponent`是`RouterOutlet`的父组件，它内部加载`WorkoutRunnerComponent`和`WorkoutHistoryComponent`。因此，在这种设置中，依赖项由`TrainerAppComponent`注入器来满足。
- en: Dependency lookup up on the component hierarchy can be manipulated if an intermediate
    component has declared itself as a host component. We will learn more about it
    in later chapters.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中间组件已声明自己为宿主组件，则可以在组件层次结构上操作依赖项查找。我们将在后面的章节中了解更多关于它的内容。
- en: Hierarchical injectors allow us to register dependencies at a component level,
    avoiding the need to register all dependencies globally.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 层次注入器允许我们在组件级别注册依赖项，避免需要全局注册所有依赖项。
- en: The predominant use case for this functionality is when building an Angular
    library component. Such components can register their own dependencies without
    requiring the consumer of the library to register library-specific dependencies.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的典型用例是在构建 Angular 库组件时。此类组件可以注册自己的依赖项，而无需要求库的消费者注册库特定的依赖项。
- en: 'Remember: if you are having trouble loading the right service/dependency, make
    sure you check the component hierarchy for overrides done at any level.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：如果你在加载正确的服务/依赖项时遇到麻烦，请确保检查任何级别的组件层次结构中是否进行了覆盖。
- en: We now understand how dependency resolution works in components. But what happens
    if a service has a dependency? Yet more uncharted territory to explore. Let's
    extend our app further.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了组件中依赖项解析的工作方式。但是，如果一个服务有依赖项会发生什么？还有更多未知的领域要探索。让我们进一步扩展我们的应用程序。
- en: Remove any `provider` registration done on components before continuing further.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进一步之前，移除在组件上完成的任何`provider`注册。
- en: Dependency injection with @Injectable
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@Injectable`进行依赖注入
- en: '`WorkoutHistoryTrackerService` has a fundamental flaw: the history is not persisted.
    Refresh the app and the history is lost. We need to add persistence logic to store
    historical data. To avoid any complex setup, we are going to use the browser local
    storage to store historical data.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutHistoryTrackerService`有一个基本缺陷：历史数据没有持久化。刷新应用程序，历史数据就会丢失。我们需要添加持久化逻辑来存储历史数据。为了避免任何复杂的设置，我们将使用浏览器本地存储来存储历史数据。'
- en: 'Add a new `LocalStorageService` service by invoking this CLI command from the `trainer/src/app/core` folder:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`trainer/src/app/core`文件夹调用此CLI命令添加一个新的`LocalStorageService`服务：
- en: '[PRE84]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Copy the following two functions to the generated class, or copy them from
    the `checkpoint3.2` GitHub branch:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两个函数复制到生成的类中，或者从`checkpoint3.2`GitHub分支复制它们：
- en: '[PRE85]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: A simple wrapper over the browser's `localStorage` object.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的浏览器`localStorage`对象的包装器。
- en: 'Like any other dependency, inject it into the `WorkoutHistoryTrackerService` constructor
    (the `workout-history-tracker.ts` file) with the necessary import:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他依赖项一样，将其注入到`WorkoutHistoryTrackerService`构造函数（`workout-history-tracker.ts`文件）中，并使用必要的导入：
- en: '[PRE86]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: It is advisable that the default `Injectable` decorator on the service is applied,
    even if we register the dependency on module (`NgModule` provider registrations
    syntax). Especially when the service itself has a dependency, as it does with
    the preceding example of `WorkoutHistoryTrackerService`. Do not use the `providedIn` decorator
    attribute of `Injectable`  when using the module-based service registration.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在服务上应用默认的`Injectable`装饰器，即使我们在模块上注册了依赖项（`NgModule`提供者注册语法）。特别是当服务本身有依赖项时，就像前面的`WorkoutHistoryTrackerService`示例一样。在使用基于模块的服务注册时，不要使用`Injectable`的`providedIn`装饰器属性。
- en: By putting in the `@Injectable` decorator, we are forcing the TypeScript transpiler
    to generate metadata for the `WorkoutHistoryTrackerService` class. This includes
    details about the constructor arguments. Angular DI consumes this generated metadata
    to determine the types of dependency the service has, and in future, it fulfills
    these dependencies when the service is created.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`@Injectable`装饰器，我们迫使TypeScript编译器为`WorkoutHistoryTrackerService`类生成元数据。这包括有关构造函数参数的详细信息。Angular
    DI（依赖注入）消耗这些生成的元数据以确定服务具有的依赖项类型，并在服务创建时满足这些依赖项。
- en: What about `WorkoutRunnerComponent`, which that uses `WorkoutHistoryTrackerService`?
    We have not used `@Injectable` there but still, the DI works. We don't need to.
    Any decorator works and there is already an `@Component` decorator applied to
    all components.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用`WorkoutHistoryTrackerService`的`WorkoutRunnerComponent`呢？我们没有在那里使用`@Injectable`，但仍然，DI（依赖注入）工作。我们不需要。任何装饰器都行，并且已经应用了`@Component`装饰器到所有组件上。
- en: The actual integration between the `LocalStorage` service and `WorkoutHistoryTrackerService` is
    a mundane process.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`LocalStorage`服务与`WorkoutHistoryTrackerService`之间的集成是一个平凡的过程。
- en: 'Update the constructor for `WorkoutHistoryTrackerService` as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`WorkoutHistoryTrackerService`的构造函数：
- en: '[PRE87]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And add a declaration for `storageKey`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加一个`storageKey`的声明：
- en: '[PRE88]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The constructor loads the workout logs from the local storage. The `map` function
    call is necessary as everything stored in `localStorage` is a string. Therefore,
    while de-serializing, we need to convert the string back to the date value.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数从本地存储中加载锻炼日志。调用`map`函数是必要的，因为存储在`localStorage`中的所有内容都是字符串。因此，在反序列化时，我们需要将字符串转换回日期值。
- en: 'Add this statement last in the `startTracking`, `exerciseComplete`, and `endTracking` functions:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startTracking`、`exerciseComplete`和`endTracking`函数中最后添加以下语句：
- en: '[PRE89]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We save the workout history to local storage every time the historical data
    changes.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 每当历史数据发生变化时，我们都会将锻炼历史保存到本地存储中。
- en: That's it! We have built workout history tracking over `localStorage`. Verify
    it!
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经通过`localStorage`构建了锻炼历史跟踪。验证一下！
- en: Before we move on to our big-ticket item, audio support, there are a few minor
    fixes that are needed for a better user experience. The first one is related to
    the History link.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到重要项目——音频支持之前，需要做一些小的修复以提供更好的用户体验。第一个修复与“历史”链接有关。
- en: Tracking route changes using the router service
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由服务跟踪路由更改
- en: The History link in the `Header` component is visible for all routes other that
    when a workout is in progress. We don't want to lose an in-progress workout by
    accidentally clicking on the History link. Moreover, no one is interested in knowing
    about the workout history while doing a workout.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header` 组件中，`History` 链接对所有路由都是可见的，除了当锻炼正在进行时。我们不希望用户不小心点击历史链接而丢失正在进行的锻炼。此外，在锻炼时，没有人对了解锻炼历史感兴趣。
- en: The fix is easy. We just need to determine whether the current route is the
    workout route and hide the link. The `Router` service is going to help us with
    this job.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 修复很简单。我们只需要确定当前路由是否是锻炼路由，并隐藏链接。`Router` 服务将帮助我们完成这项工作。
- en: 'Open `header.component.ts` and look at the highlighted implementation:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `header.component.ts` 并查看高亮显示的实现：
- en: '[PRE90]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `showHistoryLink` property binds to the view and decides whether the history
    link is shown to the user or not. In the constructor, we inject the `Router` service
    and subscribe to the observable `events` using the `subscribe` function.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`showHistoryLink` 属性绑定到视图，并决定是否向用户显示历史链接。在构造函数中，我们注入 `Router` 服务并使用 `subscribe`
    函数订阅 `events` 可观察对象。'
- en: We will learn more about observables later in the chapter, but for now, it is
    enough to understand that observables are objects that raise events and can be
    subscribed to. Since the router raises a number of events throughout the component's
    life cycle, the `filter` operator allows us to filter the event we are interested
    in and the `subscribe` function registers a callback function that is invoked
    every time the route changes.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面学习更多关于可观察对象的知识，但就目前而言，了解可观察对象是引发事件的对象，并且可以被订阅就足够了。由于路由器在整个组件生命周期中引发了许多事件，`filter`
    操作符允许我们过滤我们感兴趣的事件，而 `subscribe` 函数注册了一个回调函数，该函数在每次路由更改时被调用。
- en: To learn about the other router events, including `NavigationStart`, `NavigationEnd`, `NavigationCancel`,
    and `NavigationError`, look at the router documentation ([http://bit.ly/ng-router-events](http://bit.ly/ng-router-events))
    to understand when the events are raised.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其他路由器事件，包括 `NavigationStart`、`NavigationEnd`、`NavigationCancel` 和 `NavigationError`，请查看路由器文档
    ([http://bit.ly/ng-router-events](http://bit.ly/ng-router-events)) 以了解事件何时被引发。
- en: 'The callback implementation just toggles the `showHistoryLink` state based
    on the current route URL. To use `showHistoryLink` in the view, just update the
    header template line with the anchor tag to:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 回调实现只是根据当前路由 URL 切换 `showHistoryLink` 状态。要在视图中使用 `showHistoryLink`，只需更新标题模板行中的锚点标签为：
- en: '[PRE91]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: And that's it! The History link does not show up on the workout page.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！在锻炼页面上不会显示 `History` 链接。
- en: If you are having a problem with running the code, look at the `checkpoint3.2` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.2` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-2](http://bit.ly/ng6be-checkpoint-3-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看 `checkpoint3.2` Git 分支以获取我们迄今为止所做的工作的版本。或者如果你不使用 Git，请从 [http://bit.ly/ng6be-checkpoint-3-2](http://bit.ly/ng6be-checkpoint-3-2)
    下载 `checkpoint3.2` 的快照（ZIP 文件）。在首次设置快照时，请参考 `trainer` 文件夹中的 `README.md` 文件。
- en: Another fix/enhancement is related to the video panel on the workout page.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个修复/增强与锻炼页面上的视频面板有关。
- en: Fixing the video playback experience
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复视频播放体验
- en: The current video panel implementation can at best be termed amateurish. The
    size of the default player is small. When we play the video, the workout does
    not pause. The video playback is interrupted on exercise transitions. Also, the
    overall video-load experience adds a noticeable lag at the start of every exercise
    routine. This is a clear indication that this approach to video playback needs
    some fixing.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 当前视频面板的实现最多只能称为业余水平。默认播放器的尺寸很小。当我们播放视频时，锻炼不会暂停。在锻炼转换时，视频播放会被中断。此外，整体视频加载体验在每次锻炼程序开始时都会增加明显的延迟。这清楚地表明，这种视频播放方法需要一些修复。
- en: 'This is what we are going to do to fix the video panel:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要做的来修复视频面板：
- en: Show the image thumbnail for the exercise video instead of loading the video
    player itself
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示锻炼视频的缩略图而不是加载视频播放器本身
- en: When the user clicks on the thumbnail, load a popup/dialog with a bigger video
    player that can play the selected video
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击缩略图时，加载一个包含更大视频播放器的弹出/对话框，该播放器可以播放所选视频
- en: Pause the workout while the video playback is on
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在视频播放时暂停锻炼
- en: Let's get on with the job!
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作吧！
- en: Using thumbnails for video
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视频缩略图
- en: 'Replace the `ngFor` HTML template inside `video-player.component.html` with this snippet:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 将`video-player.component.html`中的`ngFor`HTML模板替换为以下片段：
- en: '[PRE92]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We have abandoned iframe, and instead loaded the thumbnail image of the video
    (check the `img` tag). All other content shown here is for styling the image.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经放弃了iframe，而是加载了视频的缩略图图像（检查`img`标签）。这里显示的所有其他内容都是为了样式化图像。
- en: We have referenced the Stack Overflow post ([http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)) to
    determine the thumbnail image URL for our videos.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们参考了Stack Overflow帖子（[http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)）来确定我们视频的缩略图图像URL。
- en: Start a new workout; the images should show up, but the playback functionality
    is broken. We need to add a video playback dialog.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的锻炼；图像应该会显示出来，但播放功能是损坏的。我们需要添加一个视频播放对话框。
- en: Using the ngx-modialog library
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngx-modialog库
- en: To show the video in a dialog, we are going to incorporate a third-party library, **ngx-modialog**,
    available on GitHub at [http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog).
    Let's install and configure the library.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 要在对话框中显示视频，我们将集成一个第三方库，**ngx-modialog**，可在GitHub上找到，[http://bit.ly/ngx-modialog](http://bit.ly/ngx-modialog)。让我们安装和配置这个库。
- en: 'From the command line (inside the `trainer` folder), run the following command
    to install the library:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行（在`trainer`文件夹内），运行以下命令来安装库：
- en: '[PRE93]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Work on an Angular v6-compatible `ngx-modialog` library is in progress ([https://github.com/shlomiassaf/ngx-modialog/issues/426](https://github.com/shlomiassaf/ngx-modialog/issues/426)).
    To use the version 5 library, which is dependent on older version of RxJS, install
    the `rxjs-compat` package from command line, `npm i rxjs-compat --save`, before
    proceeding.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行的Angular v6兼容的`ngx-modialog`库工作（[https://github.com/shlomiassaf/ngx-modialog/issues/426](https://github.com/shlomiassaf/ngx-modialog/issues/426)）。要使用依赖于较旧版本的RxJS的版本5库，在继续之前，从命令行安装`rxjs-compat`包，`npm
    i rxjs-compat --save`。
- en: 'Next import and configure the library in the core module. Open `core.module.ts` and
    add the highlighted configurations:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来在核心模块中导入和配置库。打开`core.module.ts`并添加以下高亮配置：
- en: '[PRE94]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The library is now ready for use.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库已经准备好使用。
- en: While *ngx-modialog* has a number of predefined templates for standard dialogs,
    such as alert, prompt, and confirm, these dialogs provide little customization
    in terms of look and feel. To have better control over the dialog UI, we need
    to create a custom dialog, which thankfully the library supports.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*ngx-modialog*提供了一些预定义的模板用于标准对话框，如警告、提示和确认，但这些对话框在外观和感觉方面提供的定制很少。为了更好地控制对话框UI，我们需要创建一个自定义对话框，幸运的是，这个库支持这样做。
- en: Creating custom dialogs
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义对话框
- en: Custom dialogs in `ngx-modialog` are nothing but Angular components with some
    special library construct incorporated.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngx-modialog`中的自定义对话框不过是包含了一些特殊库结构的Angular组件。'
- en: 'Let''s start with building a video dialog component that shows the YouTube
    video in a popup dialog. Generate the component''s boilerplate by navigating to `trainer/src/app/workout-runner/video-player` and
    running the following command:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个显示YouTube视频的弹出对话框的视频对话框组件开始。通过导航到`trainer/src/app/workout-runner/video-player`并运行以下命令来生成组件的模板：
- en: '[PRE95]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Copy the video dialog implementation from the `workout-runner/video-player/video-dialog` folder
    in the `checkpoint3.3` Git branch (GitHub location: [http://bit.ly/ng6be-3-3-video-dialog](http://bit.ly/ng6be-3-3-video-dialog))
    into your local setup. You need to update the component implementation and the
    view.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 从`checkpoint3.3`Git分支（GitHub位置：[http://bit.ly/ng6be-3-3-video-dialog](http://bit.ly/ng6be-3-3-video-dialog)）中的`workout-runner/video-player/video-dialog`文件夹复制视频对话框实现到您的本地设置中。您需要更新组件实现和视图。
- en: 'Next, update `workout-runner.module.ts` and add a new `entryComponents` attribute
    to the module decorator:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`workout-runner.module.ts`并在模块装饰器中添加一个新的`entryComponents`属性：
- en: '[PRE96]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The newly created `VideoDialogComponent` needs to be added to `entryComponents` as
    it is not explicitly used in the component tree.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的`VideoDialogComponent`需要添加到`entryComponents`中，因为它在组件树中没有被明确使用。
- en: '`VideoDialogComponent` is a standard Angular component, with some modal dialog
    and specific implementations that we describe later. The `VideoDialogContext` class
    declared inside `VideoDialogComponent` has been created to pass the `videoId` of
    the YouTube video clicked to the dialog instance. The library uses this context
    class to pass data between the calling code and the modal dialog. The `VideoDialogContext` class
    inherits a configuration class that the dialog library uses to alter the behavior
    and UI of the modal dialog from `BSModalContext`.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoDialogComponent` 是一个标准的 Angular 组件，包含一些模态对话框和特定的实现，我们将在后面进行描述。在 `VideoDialogComponent`
    内部声明的 `VideoDialogContext` 类是为了将点击的 YouTube 视频的 `videoId` 传递给对话框实例而创建的。库使用这个上下文类在调用代码和模态对话框之间传递数据。`VideoDialogContext`
    类继承了一个配置类，该配置类是对话框库用来改变模态对话框的行为和 UI 的 `BSModalContext`。'
- en: To get a better sense of how `VideoDialogContext` is utilized, let's invoke
    the preceding dialog from the workout runner when the video image is clicked.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解 `VideoDialogContext` 的使用方法，让我们在点击视频图片时从锻炼运行器调用前面的对话框。
- en: 'Update the `ngFor` div in `video-player.component.html` and add a `click` event
    handler:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `video-player.component.html` 中的 `ngFor` div 并添加一个 `click` 事件处理器：
- en: '[PRE97]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The preceding handler invokes the `playVideo` method, passing in the video
    clicked. The `playVideo` function, in turn, opens the corresponding video dialog.
    Add the `playVideo` implementation to `video-player.component.ts` as highlighted:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的处理器调用 `playVideo` 方法，传入点击的视频。`playVideo` 函数反过来打开相应的视频对话框。将 `playVideo` 实现添加到
    `video-player.component.ts` 中，如下所示：
- en: '[PRE98]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `playVideo` function calls the `Modal` class' `open` function, passing in
    the dialog component to open and a new instance of the `VideoDialogContext` class
    with the `videoId` of the YouTube video. Before proceeding, delete the `ngOnChange` function
    and the interface declaration too.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`playVideo` 函数调用 `Modal` 类的 `open` 方法，传入要打开的对话框组件和一个包含 YouTube 视频的 `videoId`
    的新实例的 `VideoDialogContext` 类。在继续之前，删除 `ngOnChange` 函数和接口声明。'
- en: Coming back to the `VideoDialogComponent` implementation, the component implements
    the `ModalComponent<VideoDialogContext>` interface required by the modal library.
    Look at how the context (`VideoDialogContext`) to the dialog is passed to the
    constructor and how we extract and assign the `videoId` property from the context.
    Then it's just a matter of binding the `videoId` property to the template view
    (see the HTML template) and rendering the YouTube player.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `VideoDialogComponent` 的实现，该组件实现了模态库所需的 `ModalComponent<VideoDialogContext>`
    接口。看看上下文（`VideoDialogContext`）是如何传递给构造函数的，以及我们是如何从上下文中提取并分配 `videoId` 属性的。然后只需将
    `videoId` 属性绑定到模板视图（见 HTML 模板）并渲染 YouTube 播放器即可。
- en: And we are good to go. Load the app and start the workout. Then click on any
    workout video images. The video dialog should load and now we can watch the video!
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就可以开始了。加载应用并开始锻炼。然后点击任何锻炼视频图片。视频对话框应该会加载，现在我们可以观看视频了！
- en: 'Before we call the dialog implementation complete, there is one small issue
    that needs to be fixed. When the dialog opens, the workout should pause: that''s
    not happening currently. We will help you fix it at the end of the next section
    using Angular''s eventing infrastructure.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用对话框实现完成之前，还有一个小问题需要修复。当对话框打开时，锻炼应该暂停：目前还没有这样做。我们将在下一节的末尾使用 Angular 的事件基础设施帮助你修复它。
- en: If you are having a problem with running the code, look at the `checkpoint3.3` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-3](http://bit.ly/ng6be-checkpoint-3-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看 `checkpoint3.3` Git 分支，那里有我们到目前为止所做的工作的可用版本。或者如果你不使用 Git，可以从
    [http://bit.ly/ng6be-checkpoint-3-3](http://bit.ly/ng6be-checkpoint-3-3) 下载 `checkpoint3.3`
    的快照（ZIP 文件）。在第一次设置快照时，请参考 `trainer` 文件夹中的 `README.md` 文件。
- en: 'There is one last feature that we plan to add to *7-Minute Workout* before
    wrapping up the application and building something new with Angular: audio support.
    It teaches us some new cross-component communication patterns too.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成应用并使用 Angular 构建新的东西之前，我们计划向 *7-Minute Workout* 添加最后一个功能：音频支持。这也教会了我们一些新的跨组件通信模式。
- en: Cross-component communication using Angular events
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular 事件进行跨组件通信
- en: We touched upon events in the last chapter when learning about Angular's binding infrastructure.
    It's time now to look at eventing in more depth. Let's add audio support to *7-Minute
    Workout*.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章学习Angular的绑定基础设施时，我们提到了事件。现在是时候更深入地研究事件了。让我们为*7分钟健身法*添加音频支持。
- en: Tracking exercise progress with audio
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频跟踪锻炼进度
- en: For the *7-Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues help the user perform the
    workout effectively as they can just follow the audio instructions.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟健身法*应用程序，添加声音支持至关重要。一个人不能在一直盯着屏幕的同时进行锻炼。音频线索帮助用户有效地完成锻炼，因为他们只需遵循音频指示。
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将如何使用音频线索支持练习跟踪的方法：
- en: A ticking clock soundtrack progress during the exercise
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个滴答作响的时钟音轨在锻炼期间显示进度
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中途指示器发出声音，表示锻炼已进行了一半
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当练习即将结束时，会播放一个完成练习的音频剪辑
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在休息阶段播放音频剪辑，并通知用户下一个练习
- en: There will be an audio clip for each of these scenarios.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都会有音频剪辑。
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into HTML content. We too will use the `<audio>` tag
    to play back our clips.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器对音频有很好的支持。HTML5 `<audio>` 标签提供了一个将音频剪辑嵌入HTML内容的方法。我们也将使用`<audio>`标签来播放我们的剪辑。
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计划使用HTML `<audio>` 元素，我们需要创建一个包装指令，以便我们从Angular控制音频元素。记住，指令是HTML扩展，但没有视图。
- en: The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the
    audio files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Download and unzip the contents and copy the audio files.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkpoint3.4` Git和`trainer/static/audio`文件夹包含所有用于播放的音频文件；首先复制它们。如果你不使用Git，本章代码的快照可在[http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4)找到。下载并解压缩内容，然后复制音频文件。'
- en: Building Angular directives to wrap HTML audio
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Angular指令以包装HTML音频
- en: If you have worked a lot with JavaScript and jQuery, you may have realized we have
    purposefully shied away from directly accessing the DOM for any of our component
    implementations. There has not been a need to do it. The Angular data-binding
    infrastructure, including property, attribute, and event binding, has helped us
    manipulate HTML without touching the DOM.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与JavaScript和jQuery有很多工作，你可能已经意识到我们故意避免直接访问DOM来进行任何组件实现。我们没有这个必要。Angular的数据绑定基础设施，包括属性、属性和事件绑定，帮助我们操作HTML而不接触DOM。
- en: For the audio element too, the access pattern should be Angularish. In Angular,
    the only place where direct DOM manipulation is acceptable and practiced is inside
    directives. Let's create a directive that wraps access to audio elements.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音频元素，访问模式也应该是Angular风格的。在Angular中，唯一可以接受并实践直接DOM操作的地方是在指令内部。让我们创建一个包装音频元素访问的指令。
- en: 'Navigate to `trainer/src/app/shared` and run this command to generate a template
    directive:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`trainer/src/app/shared`并运行此命令以生成模板指令：
- en: '[PRE100]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Since it is the first time we are creating a directive, we encourage you to
    look at the generated code.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次创建指令，我们鼓励您查看生成的代码。
- en: 'Since the directive is added to the shared module, it needs to be exported
    too. Add the `MyAudioDirective` reference in the `exports` array too (`shared.module.ts`).
    Then update the directive definition with the following code:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指令添加到共享模块中，因此也需要导出。在`exports`数组中添加`MyAudioDirective`引用（`shared.module.ts`）。然后使用以下代码更新指令定义：
- en: '[PRE101]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive` decorator
    is similar to the `@Component` decorator except we cannot have an attached view.
    Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective`类用`@Directive`装饰。`@Directive`装饰器与`@Component`装饰器类似，但我们不能有附加的视图。因此，不允许`template`或`templateUrl`！'
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. We have replaced the generated `[abeMyAudioDirective]` attribute
    selector with just `audio`. Using `audio` as the selector makes our directive
    load for every `<audio>` tag used in HTML. The new selector works as an element
    selector.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `selector` 属性允许框架识别应用指令的位置。我们将生成的 `[abeMyAudioDirective]` 属性选择器替换为 `audio`。使用
    `audio` 作为选择器使得我们的指令为 HTML 中使用的每个 `<audio>` 标签加载。新的选择器作为一个元素选择器工作。
- en: In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for
    the generated code), which helps us identify where the directive has been applied.
    We deviate from this norm and use an element selector for the `MyAudioDirective` directive.
    We want this directive to be loaded for every audio element, and it becomes cumbersome
    to go to each audio declaration and add a directive-specific attribute. Hence
    an element selector.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准场景中，指令选择器是基于属性的（例如，`[abeMyAudioDirective]` 用于生成的代码），这有助于我们识别指令被应用的位置。我们偏离了这个规范，并为
    `MyAudioDirective` 指令使用了一个元素选择器。我们希望这个指令为每个音频元素加载，因此逐个音频声明添加特定指令的属性变得繁琐。因此，我们使用了元素选择器。
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在视图模板中使用此指令时，`exportAs` 的使用变得清晰。
- en: The `ElementRef` object injected in the constructor is the Angular element (`audio` in
    this case) for which the directive is loaded. Angular creates the `ElementRef` instance
    for every component and directive when it compiles and executes the HTML template.
    When requested in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the underlying audio element in
    the code (the instance of `HTMLAudioElement`). The `audioPlayer` property holds
    this reference.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中注入的 `ElementRef` 对象是 Angular 元素（在这种情况下是 `audio`），该指令被加载。Angular 在编译和执行
    HTML 模板时为每个组件和指令创建 `ElementRef` 实例。当在构造函数中请求时，DI 框架定位相应的 `ElementRef` 并将其注入。我们使用
    `ElementRef` 在代码中获取底层音频元素（`HTMLAudioElement` 的实例）。`audioPlayer` 属性持有这个引用。
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在指令需要公开一个 API 来操作音频播放器。将这些函数添加到 `MyAudioDirective` 指令中：
- en: '[PRE102]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a Boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective` API 有两个函数（`start` 和 `stop`）和三个获取器（`currentTime`、`duration`
    和一个名为 `playbackComplete` 的布尔属性）。这些函数和属性的实现只是封装了音频元素函数。'
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处了解这些音频函数的 MDN 文档：[http://bit.ly/html-media-element](http://bit.ly/html-media-element)。
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们如何使用音频指令，让我们创建一个新的组件来管理音频播放。
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为音频支持创建 WorkoutAudioComponent
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>` tags
    (two audio tags work together for next-up audio).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下所需的音频提示，有四个不同的音频提示，因此我们将创建一个包含五个嵌入 `<audio>` 标签的组件（两个音频标签一起用于下一个音频）。
- en: From the command line go to the `trainer/src/app/workout-runner` folder and
    add a new `WorkoutAudioComponent` component using Angular CLI.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行进入 `trainer/src/app/workout-runner` 文件夹，并使用 Angular CLI 添加一个新的 `WorkoutAudioComponent`
    组件。
- en: 'Open `workout-audio.component.html` and replace the existing view template
    with this HTML snippet:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `workout-audio.component.html` 并将现有的视图模板替换为以下 HTML 片段：
- en: '[PRE103]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'There are five `<audio>` tags, one for each of the following:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个 `<audio>` 标签，每个标签对应以下内容：
- en: '**Ticking audio**: The first audio tag produces the ticking sound and is started as
    soon as the workout starts.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滴答音频**：第一个音频标签产生滴答声，一旦锻炼开始就立即启动。'
- en: '**Next up audio and exercise audio**: There next two audio tags work together.
    The first tag produces the "Next up" sound. And the actual exercise audio is handled
    by the third tag (in the preceding code snippet).'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一个音频和练习音频**：接下来的两个音频标签一起工作。第一个标签产生“下一个”声音。实际的练习音频由第三个标签（在之前的代码片段中）处理。'
- en: '**Halfway audio**: The fourth audio tag plays halfway through the exercise.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** halfway 音频**：第四个音频标签在练习进行到一半时播放。'
- en: '**About to complete audio**: The final audio tag plays a piece to denote the
    completion of an exercise.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即将完成音频**：最后的音频标签播放一段音乐以表示练习的完成。'
- en: Did you notice the usage of the `#` symbol in each of the `audio` tags? There
    are some variable assignments prefixed with `#`. In the Angular world, these variables are
    known as **template reference variables** or at times **template variables**.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到每个`audio`标签中使用的`#`符号了吗？有一些变量赋值以`#`开头。在Angular世界中，这些变量被称为**模板引用变量**或有时称为**模板变量**。
- en: 'As the platform guide defines:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台指南定义：
- en: A template reference variable is often a reference to a DOM element or directive
    within a template.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量通常是对模板中的DOM元素或指令的引用。
- en: Don't confuse them with the template input variables that we have used with
    the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template
    input variable's** (`video` in this case) scope is within the HTML fragment it
    is declared, whereas the template reference variable can be accessed across the
    entire template.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将它们与我们在之前的`ngFor`指令中使用的模板输入变量混淆，即`*ngFor="let video of videos"`。模板输入变量（在这种情况下为`video`）的作用域在其声明的HTML片段内，而模板引用变量可以在整个模板中访问。
- en: 'Look at the last section where `MyAudioDirective` was defined. The `exportAs` metadata
    is set to `MyAudio`. We repeat that same `MyAudio` string while assigning the `template
    reference variable` for each audio tag:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 看看定义`MyAudioDirective`的最后部分。`exportAs`元数据设置为`MyAudio`。我们在为每个音频标签分配`template
    reference variable`时重复相同的`MyAudio`字符串：
- en: '[PRE104]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template-reference variable based on what is on the right
    side of equals.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`exportAs`的作用是定义可以在视图中使用的名称，以便将此指令分配给变量。记住，单个元素/组件可以应用多个指令。`exportAs`允许我们根据等号右侧的内容选择将哪个指令分配给模板引用变量。'
- en: Typically, template variables, once declared, give access to the view element/component
    they are attached to, to other parts of the view, something we will discuss shortly.
    But in our case, we will use template variables to refer to the multiple `MyAudioDirective` from
    the parent component's code. Let's understand how to use them.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦声明，模板变量就可以访问它们附加到的视图元素/组件，以及其他视图部分，我们将在稍后讨论这一点。但在我们的情况下，我们将使用模板变量来引用父组件代码中的多个`MyAudioDirective`。让我们了解如何使用它们。
- en: 'Update the generated `workout-audio.compnent.ts` with the following outline:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下大纲更新生成的`workout-audio.compnent.ts`：
- en: '[PRE105]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The interesting bit in this outline is the `@ViewChild` decorator against the
    five properties. The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed to the decorator is the template
    variable name, which helps DI match the element/directive to inject. When Angular
    instantiates the main `WorkoutAudioComponent`, it injects the corresponding audio
    directives based on the `@ViewChild` decorator and the template reference variable
    name passed. Let's complete the basic class implementation before we look at `@ViewChild` in
    detail.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大纲中有趣的部分是对五个属性的反向`@ViewChild`装饰器。`@ViewChild`装饰器允许我们将子组件/指令/元素引用注入其父组件。传递给装饰器的参数是模板变量名称，这有助于DI匹配要注入的元素/指令。当Angular实例化主`WorkoutAudioComponent`时，它根据`@ViewChild`装饰器和传递的模板引用变量名称注入相应的音频指令。在我们详细查看`@ViewChild`之前，让我们完成基本类实现。
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection
    injects the related `ElementRef` instance instead of the `MyAudioDirective` instance.
    We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and
    then looking at the injected dependencies in `WorkoutAudioComponent`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyAudioDirective`指令上未设置`exportAs`的情况下，`@ViewChild`注入将相关`ElementRef`实例注入，而不是`MyAudioDirective`实例。我们可以通过从`myAudioDirective`中移除`exportAs`属性，然后在`WorkoutAudioComponent`中查看注入的依赖项来确认这一点。
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的任务只是正确地在正确的时间播放正确的音频组件。将这些函数添加到`WorkoutAudioComponent`：
- en: '[PRE106]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Having trouble writing these functions? They are available in the `checkpoint3.3` Git
    branch.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 写这些函数有困难吗？它们在 `checkpoint3.3` Git 分支中可用。
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts`, as follows (again available in `checkpoint3.3`):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用了两个新的模型类。将它们的声明添加到 `model.ts` 中，如下所示（同样在 `checkpoint3.3` 中可用）：
- en: '[PRE107]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent` implementation
    consumes this data. Remember to import the reference for `ExerciseProgressEvent` and `ExerciseProgressEvent` in `workout-audio.component.ts`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于跟踪进度事件的模型类。`WorkoutAudioComponent` 实现消费这些数据。请记住在 `workout-audio.component.ts`
    中导入 `ExerciseProgressEvent` 和 `ExerciseProgressEvent` 的引用。
- en: To reiterate, the audio component consumes the events by defining two event
    handlers: `onExerciseProgress` and `onExerciseChanged.` How the events are generated
    becomes clear as we move along.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，音频组件通过定义两个事件处理器来消费事件：`onExerciseProgress` 和 `onExerciseChanged`。随着我们的深入，事件是如何生成的将变得清晰。
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, about to complete, or
    half-way audio playback. We just want to continue from where we left off.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 和 `resume` 函数在锻炼开始、暂停或完成时停止和恢复音频。`resume` 函数的额外复杂性在于处理在下一个即将完成或音频播放中途暂停的锻炼情况。我们只想从我们离开的地方继续。'
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 应该调用 `onExerciseProgress` 函数来报告锻炼进度。它用于根据锻炼的状态播放中途音频和即将完成的音频。传递给它的参数是一个包含锻炼进度数据的对象。
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line and helps `WorkoutAudioComponent` to
    decide when to play the next up exercise audio.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼改变时，应该调用 `onExerciseChanged` 函数。输入参数包含当前和下一个即将进行的锻炼，并帮助 `WorkoutAudioComponent`
    决定何时播放下一个即将进行的锻炼音频。
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提到了两个新的概念：模板引用变量和将子元素/指令注入父元素。在我们继续实施之前，值得更详细地探索这两个概念。我们将从学习更多关于模板引用变量开始。
- en: Understanding template reference variables
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板引用变量
- en: '**Template reference variables** are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引用变量**是在视图模板上创建的，并且主要从视图中被消费。正如你已经学到的，这些变量可以通过用于声明它们的 `#` 前缀来识别。'
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量的最大好处之一是它们在视图模板级别促进了跨组件通信。一旦声明，这些变量就可以被兄弟元素/组件及其子元素引用。查看以下片段：
- en: '[PRE108]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 模板引擎将 `input` 的 DOM 对象（`HTMLInputElement` 的实例）分配给 `emailId` 变量。由于该变量在兄弟元素中可用，我们在按钮的
    `click` 表达式中使用它。
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量也可以与组件一起工作。我们可以轻松地做到这一点：
- en: '[PRE109]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this case, `runner` has a reference to the `WorkoutRunnerComponent` object,
    and the button is used to start the workout.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`runner` 有 `WorkoutRunnerComponent` 对象的引用，按钮用于启动锻炼。
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref-` 前缀是 `#` 的规范替代品。`#runner` 变量也可以声明为 `ref-runner`。'
- en: Template variable assignment
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板变量赋值
- en: 'You may not have noticed but there is something interesting about the template variable
    assignments described in the last few sections. To recap, the three examples that
    we have used are:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，但在最后几节中描述的模板变量赋值中有些有趣的事情。为了回顾，我们使用的三个示例是：
- en: '[PRE110]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'What got assigned to the variable depends on where the variable was declared.
    This is governed by rules in Angular:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给变量的内容取决于变量在哪里声明。这由 Angular 的规则控制：
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective` directive
    sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果元素上存在指令，例如在前面示例中显示的 `MyAudioDirective`，则指令设置值。`MyAudioDirective` 指令将 `ticks`
    变量设置为 `MyAudioDirective` 的一个实例。
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `input` and `workout-runner` examples).
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指令存在，则将分配底层的 HTML DOM 元素或组件对象（如 `input` 和 `workout-runner` 示例中所示）。
- en: We will be employing this technique to implement the workout audio component
    integration with the workout runner component. This introduction gives us the
    head start that we need.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这项技术来实现锻炼音频组件与锻炼运行组件的集成。这种介绍为我们提供了我们需要的先发优势。
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺要介绍的其他新概念是使用 `ViewChild` 和 `ViewChildren` 装饰器进行子元素/指令注入。
- en: Using the @ViewChild decorator
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 @ViewChild 装饰器
- en: The `@ViewChild` decorator instructs the Angular DI framework to search for
    some specific child component/directive/element in the component tree and inject
    it into the parent. This allows the parent component to interact with child components/element
    using the reference to the child, a new communication pattern!
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild` 装饰器指示 Angular DI 框架在组件树中搜索一些特定的子组件/指令/元素，并将其注入到父组件中。这允许父组件通过子组件的引用与子组件/元素进行交互，这是一种新的通信模式！'
- en: In the preceding code, the audio element directive (the `MyAudioDirective` class)
    is injected into the `WorkoutAudioComponent` code.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，音频元素指令（`MyAudioDirective` 类）被注入到 `WorkoutAudioComponent` 代码中。
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立上下文，让我们重新检查 `WorkoutAudioComponent` 的一个视图片段：
- en: '[PRE111]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent` property: `ticks`.
    The search is done based on the selector passed to the `@ViewChild` decorator.
    Let''s see the audio example again:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 将指令（`MyAudioDirective`）注入到 `WorkoutAudioComponent` 的属性 `ticks` 中。搜索是基于传递给
    `@ViewChild` 装饰器的选择器进行的。让我们再次看看音频示例：
- en: '[PRE112]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChild` 上的选择器参数可以是一个字符串值，在这种情况下，Angular 会搜索匹配的模板变量，就像之前一样。'
- en: 'Or it can be a *type.* This is valid and should inject an instance of `MyAudioDirective`:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可以是*类型*。这是有效的，应该注入 `MyAudioDirective` 的一个实例：
- en: '[PRE113]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: However, it does not work in our case. Why? Because there are multiple `MyAudioDirective` directives
    declared in the `WorkoutAudioComponent` view, one for each of the `<audio>` tags.
    In such a scenario, the first match is injected. Not very useful. Passing the
    type selector would have worked if there was only one `<audio>` tag in the view!
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下它不起作用。为什么？因为 `WorkoutAudioComponent` 视图中声明了多个 `MyAudioDirective` 指令，每个
    `<audio>` 标签一个。在这种情况下，第一个匹配项被注入。这并不很有用。如果视图中只有一个 `<audio>` 标签，传递类型选择器就会起作用！
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event
    hook on the component is called. This implies such properties are `null` if accessed
    inside the constructor.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 被 `@ViewChild` 装饰的属性在组件的 `ngAfterViewInit` 事件钩子被调用之前一定会被设置。这意味着如果在这个构造函数内部访问这些属性，它们将是
    `null`。
- en: Angular also has a decorator to locate and inject multiple child components/directives: `@ViewChildren`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 还有一个装饰器可以定位和注入多个子组件/指令：`@ViewChildren`。
- en: The @ViewChildren decorator
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ViewChildren 装饰器'
- en: '`@ViewChildren` works similarly to `@ViewChild`, except it can be used to inject
    multiple child types into the parent. Again taking the previous audio component
    above as an example, using `@ViewChildren`, we can get all the `MyAudioDirective` directive
    instances in `WorkoutAudioComponent`, as shown here:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChildren` 与 `@ViewChild` 的工作方式类似，但它可以用来将多个子类型注入父组件。再次以之前的音频组件为例，使用 `@ViewChildren`，我们可以获取
    `WorkoutAudioComponent` 中的所有 `MyAudioDirective` 指令实例，如下所示：'
- en: '[PRE114]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Look carefully; `allAudios` is not a standard JavaScript array, but a custom
    class, `QueryList<Type>`. The `QueryList` class is an immutable collection that
    contains the reference to the components/directives that Angular was able to locate
    based on the filter criteria passed to the `@ViewChildren` decorator. The best
    thing about this list is that Angular will keep this list in sync with the state
    of the view. When directives/components get added/removed from the view dynamically,
    this list is updated too. Components/directives generated using `ng-for` are a
    prime example of this dynamic behavior. Consider the preceding `@ViewChildren` usage
    and this view template:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察；`allAudios` 不是一个标准的 JavaScript 数组，而是一个自定义类，`QueryList<Type>`。`QueryList`
    类是一个不可变集合，包含 Angular 根据传递给 `@ViewChildren` 装饰器的筛选标准所能定位到的组件/指令的引用。这个列表最好的地方是 Angular
    将会保持这个列表与视图状态同步。当指令/组件在视图中动态添加/删除时，这个列表也会更新。使用 `ng-for` 生成的组件/指令是这种动态行为的典型例子。考虑之前的
    `@ViewChildren` 使用和这个视图模板：
- en: '[PRE115]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into the `allAudio` property and keeps
    it in sync when items are added or removed from the `clips` array.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 创建的 `MyAudioDirective` 指令的数量取决于 `clips` 的数量。当使用 `@ViewChildren` 时，Angular
    将正确的 `MyAudioDirective` 实例数量注入到 `allAudio` 属性中，并在向 `clips` 数组添加或删除项目时保持同步。
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective` directives,
    it cannot be used to control the playback. You see, we need to get hold of individual `MyAudioDirective` instances
    as the audio playback timing varies. Hence the distinct `@ViewChild` implementation.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `@ViewChildren` 的使用允许我们获取所有 `MyAudioDirective` 指令，但它不能用来控制播放。你看，我们需要获取单个
    `MyAudioDirective` 实例，因为音频播放的时间不同。因此，有独特的 `@ViewChild` 实现。
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们掌握了每个音频元素附加的 `MyAudioDirective` 指令，就只需在正确的时间播放音频轨道。
- en: Integrating WorkoutAudioComponent
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 WorkoutAudioComponent
- en: While we have componentized the audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to the `WorkoutRunnerComponent` implementation. `WorkoutAudioComponent` derives
    its operational intelligence from `WorkoutRunnerComponent`. Hence the two components
    need to interact. `WorkoutRunnerComponent` needs to provide the `WorkoutAudioComponent` state
    change data, including when the workout started, exercise progress, workout stopped,
    paused, and resumed.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经将音频播放功能组件化到 `WorkoutAudioComponent` 中，但它始终与 `WorkoutRunnerComponent` 的实现紧密耦合。`WorkoutAudioComponent`
    从 `WorkoutRunnerComponent` 中获取其操作智能。因此，这两个组件需要交互。`WorkoutRunnerComponent` 需要提供
    `WorkoutAudioComponent` 状态变化数据，包括锻炼开始、运动进度、锻炼停止、暂停和恢复。
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent` API
    (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种集成的一种方法是在 `WorkoutRunnerComponent` 中使用当前公开的 `WorkoutAudioComponent` API（停止、恢复和其他函数）。
- en: Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`,
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将 `WorkoutAudioComponent` 注入到 `WorkoutRunnerComponent` 中来完成某些操作，就像我们之前将
    `MyAudioDirective` 注入到 `WorkoutAudioComponent` 中一样。
- en: 'Declare the `WorkoutAudioComponent` in the `WorkoutRunnerComponent''s` view,
    such as:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WorkoutRunnerComponent's` 视图中声明 `WorkoutAudioComponent`，例如：
- en: '[PRE116]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Doing so gives us a reference to the `WorkoutAudioComponent` inside the `WorkoutRunnerComponent` implementation:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做给了我们 `WorkoutRunnerComponent` 实现内部的 `WorkoutAudioComponent` 引用：
- en: '[PRE117]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `WorkoutAudioComponent` functions can then be invoked from `WorkoutRunnerComponent` from
    different places in the code. For example, this is how `pause` would change:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以从代码的不同位置调用 `WorkoutAudioComponent` 的功能，从 `WorkoutRunnerComponent` 中调用。例如，这是
    `pause` 如何改变的方式：
- en: '[PRE118]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'And to play the next-up audio, we would need to change parts of the `startExerciseTimeTracking` function:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放下一个音频，我们需要更改`startExerciseTimeTracking`函数的部分：
- en: '[PRE119]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent` now
    needs to manage audio playback too.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全可行的选项，其中`WorkoutAudioComponent`成为由`WorkoutRunnerComponent`控制的哑组件。这个解决方案的唯一问题是它给`WorkoutRunnerComponent`的实现增加了一些噪音。`WorkoutRunnerComponent`现在还需要管理音频播放。
- en: There is an alternative, however.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个替代方案。
- en: '`WorkoutRunnerComponent` can expose events that are triggered during different
    times of workout execution, such as workout started, exercise started, and workout
    paused. The advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components/directives with `WorkoutRunnerComponent` using
    the same events. Be it the `WorkoutAudioComponent` or components we create in
    future.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`可以暴露在健身执行的不同时间触发的事件，例如健身开始、练习开始和健身暂停。拥有`WorkoutRunnerComponent`暴露事件的优点是，它允许我们使用相同的事件将其他组件/指令与`WorkoutRunnerComponent`集成。无论是`WorkoutAudioComponent`还是我们未来创建的组件。'
- en: Exposing WorkoutRunnerComponent events
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露`WorkoutRunnerComponent`事件
- en: Till now we have only explored how to consume events. Angular allows us to raise
    events too. Angular components and directives can expose custom events using the `EventEmitter` class
    and the `@Output` decorator.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只探讨了如何消费事件。Angular还允许我们触发事件。Angular组件和指令可以使用`EventEmitter`类和`@Output`装饰器来暴露自定义事件。
- en: 'Add these event declarations to `WorkoutRunnerComponent` at the end of the
    variable declaration section:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明部分的末尾添加这些事件声明：
- en: '[PRE120]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent` implementation,
    we need to raise them at the appropriate times.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称是自解释的，在我们的`WorkoutRunnerComponent`实现中，我们需要在适当的时候触发它们。
- en: Remember to add the `ExerciseProgressEvent` and `ExerciseChangeEvent` imports
    to the `model` already declared on top. And add the `Output` and `EventEmitter` imports
    to `@angular/core`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将`ExerciseProgressEvent`和`ExerciseChangeEvent`导入到已经声明的`model`中。并将`Output`和`EventEmitter`导入到`@angular/core`中。
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter` class.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解`@Output`装饰器和`EventEmitter`类的作用。
- en: The @Output decorator
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Output`装饰器'
- en: We covered a decent amount of Angular eventing capabilities in Chapter 2, *Building
    Our First App – 7-Minute Workout*. Specifically, we learned how we can consume
    any event on a component, directive, or DOM element using the `bracketed ()` syntax.
    How about raising our own events?
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章“构建我们的第一个应用 - 7分钟健身”中，我们介绍了相当多的Angular事件处理能力。具体来说，我们学习了如何使用`括号()`语法在组件、指令或DOM元素上消费任何事件。那么，我们自己触发事件呢？
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class, we can define and raise custom events.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们可以创建和触发我们自己的事件，这些事件表示在我们的组件/指令中发生了值得注意的事情。使用`@Output`装饰器和`EventEmitter`类，我们可以定义和触发自定义事件。
- en: It's also a good time to refresh what we learned about events, by revisiting
    the *Eventing subsection* in the *Angular event binding infrastructure* section
    from Chapter 2, *Building Our First App – 7-Minute Workout*.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是回顾我们在第二章“构建我们的第一个应用 - 7分钟健身”中学习的关于事件知识的好时机，重新查看“事件处理子节”和“Angular事件绑定基础设施”部分。
- en: 'Remember this: it is through events that components can communicate with the
    outside world. When we declare:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点：组件通过事件与外部世界进行通信。当我们声明：
- en: '[PRE121]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event, `exercisePaused` (raised
    when the workout is paused).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示`WorkoutRunnerComponent`暴露了一个事件`exercisePaused`（在健身暂停时触发）。
- en: 'To subscribe to this event, we can do the following:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅此事件，我们可以执行以下操作：
- en: '[PRE122]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This looks absolutely similar to how we did the DOM event subscription in the
    workout runner template. See this sample stipped from the workout-runner''s view:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在健身运行者模板中进行的DOM事件订阅非常相似。看看这个从健身运行者视图摘录的示例：
- en: '[PRE123]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. Events created without the `@Output` decorator cannot be referenced in
    HTML.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器指示 Angular 使此事件可用于模板绑定。没有 `@Output` 装饰器创建的事件不能在 HTML 中引用。'
- en: 'The `@Output` decorator can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event
    instead of `exercisePaused`.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Output` 装饰器还可以接受一个参数，表示事件的名称。如果没有提供，装饰器将使用属性名称：`@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`。这声明了一个 `workoutPaused` 事件而不是 `exercisePaused`。'
- en: Like any decorator, the `@Output` decorator is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the `EventEmitter` class.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何装饰器一样，`@Output` 装饰器只是为了向 Angular 框架提供元数据。真正的重活是由 `EventEmitter` 类完成的。
- en: Eventing with EventEmitter
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EventEmitter 的事件处理
- en: Angular embraces **reactive programming** (also dubbed **Rx**-style programming)
    to support asynchronous operations with events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 采用 **reactive programming**（也称为 **Rx**-style programming）来支持使用事件进行异步操作。如果你第一次听到这个术语或者对反应式编程不太了解，你并不孤单。
- en: Reactive programming is all about programming against **asynchronous data streams**.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程完全是关于针对 **异步数据流** 进行编程。这样的流不过是基于它们发生的时间顺序排列的一系列持续事件。我们可以想象一个流是一个生成数据（以某种方式）并将其推送到一个或多个订阅者的管道。由于这些事件是由订阅者异步捕获的，因此它们被称为异步数据流。
- en: The data can be anything, ranging from browser/DOM element events to user input
    to loading remote data using AJAX. With *Rx* style, we consume this data uniformly.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是任何东西，从浏览器/DOM 元素事件到用户输入，再到使用 AJAX 加载远程数据。使用 *Rx* 风格，我们统一消费这些数据。
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular **Observer design pattern**. **Observables** are streams that
    emit data. **Observers**, on the other hand, subscribe to these events.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rx 世界中，有观察者和可观察者，这是一个来自非常流行的 **观察者设计模式** 的概念。**可观察者**是发出数据的流。另一方面，**观察者**订阅这些事件。
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an *observer* and *observable*. We can fire events on
    it and it can also listen to events.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的 `EventEmitter` 类主要负责提供事件支持。它既充当 *观察者* 又充当 *可观察者*。我们可以在它上面触发事件，它也可以监听事件。
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 上有两个对我们有意义的函数：'
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` *is the observable side*.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emit`：正如其名所示，使用此函数来触发事件。它接受一个单一参数，即事件数据。"emit" 是 *可观察者端*。'
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`. `subscribe` is
    the observer side.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`：使用此函数来订阅由 `EventEmitter` 引发的事件。"subscribe" 是观察者端。'
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些事件发布和订阅，以了解前面函数的工作方式。
- en: Raising events from WorkoutRunnerComponent
  id: totrans-713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 WorkoutRunnerComponent 中引发事件
- en: Look at the `EventEmitter` declaration. These have been declared with the `type` parameter.
    The `type` parameter on `EventEmitter` signifies the type of data emitted.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `EventEmitter` 的声明。这些已经使用 `type` 参数声明。`EventEmitter` 上的 `type` 参数表示发出的数据类型。
- en: Let's add the event implementation to `workout-runner.component.ts`, starting
    from the top of the file and moving down.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `workout-runner.component.ts` 文件中添加事件实现，从文件顶部开始向下移动。
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `start` 函数的末尾添加此语句：
- en: '[PRE124]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We use the `emit` function of  `EventEmitter`  to raise a `workoutStarted` event
    with the current workout plan as an argument.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `EventEmitter` 的 `emit` 函数来使用当前锻炼计划作为参数触发 `workoutStarted` 事件。
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 要 `pause`，添加此行来引发 `exercisePaused` 事件：
- en: '[PRE125]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To `resume`, add the following line:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 要 `resume`，添加以下行：
- en: '[PRE126]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising the `exercisePaused` and `exerciseResumed` events.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在触发`exercisePaused`和`exerciseResumed`事件时，我们都会将当前练习索引作为参数传递给`emit`。
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startExerciseTimeTracking`函数中，在调用`startExercise`之后添加以下高亮代码：
- en: '[PRE127]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数包含即将开始的练习（`next`）和下一个练习（`this.getNextExercise()`）。
- en: 'To the same function, add the highlighted code:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 向相同的功能添加以下高亮代码：
- en: '[PRE128]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The event is raised when the workout is completed.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼完成时，会触发事件。
- en: 'In the same function, we raise an event that communicates the workout progress.
    Add this statement:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，我们触发一个事件来传达锻炼进度。添加以下语句：
- en: '[PRE129]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: That completes our eventing implementation.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的事件实现。
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，`WorkoutAudioComponent`现在需要消费这些事件。这里的挑战是如何组织这些组件，以便它们可以以最小的相互依赖进行通信。
- en: Component communication patterns
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件通信模式
- en: 'As the implementation stands now, we have:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 按照目前的实现，我们有：
- en: A basic `WorkoutAudioComponent` implementation
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的`WorkoutAudioComponent`实现
- en: Augmented `WorkoutRunnerComponent` by exposing workout life cycle events
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过暴露锻炼生命周期事件增强`WorkoutRunnerComponent`
- en: These two components just need to talk to each other now.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件现在只需要相互通信。
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件需要与其子组件通信，它可以这样做：
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example, this property
    binding can stop the audio player when the workout is paused:'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性绑定**：父组件可以设置子组件的属性绑定，以便将数据推送到子组件。例如，这种属性绑定可以在锻炼暂停时停止音频播放：'
- en: '[PRE130]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Property binding, in this case, works fine. When the workout is paused, the
    audio is stopped too. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，属性绑定工作得很好。当锻炼暂停时，音频也会停止。但并不是所有情况都可以使用属性绑定来处理。播放下一个练习音频或半程音频需要更多的控制。
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren` decorators
    in the `WorkoutAudioComponent` implementation. This approach and its shortcomings
    have also been discussed briefly in the *Integrating WorkoutAudioComponent* section.'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在子组件上调用函数**：如果父组件能够获取到子组件，它也可以在子组件上调用函数。我们已经在`WorkoutAudioComponent`实现中看到了如何使用`@ViewChild`和`@ViewChildren`装饰器来实现这一点。这种方法及其不足之处也在*集成WorkoutAudioComponent*部分中简要讨论过。'
- en: There is one more not-so-good option. Instead of the parent referencing the
    child component, the child references the parent component. This allows the child
    component to call the parent component's public functions or subscribe to parent
    component events.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不太好的选择。不是父组件引用子组件，而是子组件引用父组件。这允许子组件调用父组件的公共函数或订阅父组件的事件。
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试这种方法，然后废弃实现，寻找更好的方案！从我们计划实施的不是很理想的解决方案中可以学到很多。
- en: Injecting a parent component into a child component
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将父组件注入到子组件中
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before the
    last closing `div`:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerComponent`视图中的最后一个关闭`div`之前添加`WorkoutAudioComponent`：
- en: '[PRE131]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`. Open `workout-audio.component.ts` and
    add the following declaration and update the constructor:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中。打开`workout-audio.component.ts`并添加以下声明并更新构造函数：
- en: '[PRE132]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'And remember to add these imports:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 并且记得添加以下导入：
- en: '[PRE134]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Let's try to understand what we have done before running the app. There is some
    amount of trickery involved in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`, it fails with
    Angular complaining of not being able to find all the dependencies. Read the code
    and think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent` is
    already dependent on `WorkoutAudioComponent`, as we have referenced `WorkoutAudioComponent` in
    the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent` in `WorkoutAudioComponent`,
    we have created a dependency cycle.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，让我们尝试理解我们所做的一切。在构造注入中涉及一些技巧。如果我们直接尝试将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中，它将失败，Angular会抱怨无法找到所有依赖项。阅读代码并仔细思考；有一个微妙的依赖循环问题潜伏其中。`WorkoutRunnerComponent`已经依赖于`WorkoutAudioComponent`，因为我们已经在`WorkoutRunnerComponent`视图中引用了`WorkoutAudioComponent`。现在通过在`WorkoutAudioComponent`中注入`WorkoutRunnerComponent`，我们创建了一个依赖循环。
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject` decorator
    and passing in the token created using the `forwardRef()` global framework function.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖对于任何依赖注入框架来说都是一项挑战。当创建具有循环依赖的组件时，框架必须以某种方式解决这个循环。在先前的例子中，我们通过使用`@Inject`装饰器和传递使用`forwardRef()`全局框架函数创建的令牌来解决循环依赖问题。
- en: Once the injection is done correctly, inside the constructor, we attach a handler
    to the `WorkoutRunnerComponent` events, using the `subscribe` function of `EventEmitter`.
    The arrow function passed to `subscribe` is called whenever the event occurs with
    a specific event argument. We collect all the subscriptions into a `subscription` array.
    This array comes in handy when we unsubscribe, which we need to, to avoid memory
    leaks.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确完成注入，在构造函数中，我们使用`EventEmitter`的`subscribe`函数将处理程序附加到`WorkoutRunnerComponent`事件。传递给`subscribe`的箭头函数在事件发生时（带有特定的事件参数）被调用。我们将所有订阅收集到一个`subscription`数组中。当我们需要取消订阅以避免内存泄漏时，这个数组非常有用。
- en: 'A bit about `EventEmitter`: the `EventEmmiter` subscription (`subscribe` function)
    takes three arguments:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`EventEmitter`的一些信息：`EventEmitter`的订阅（`subscribe`函数）接受三个参数：
- en: '[PRE135]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个回调，它在事件发出时被调用
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个错误回调函数，当可观察者（生成事件的那个部分）出错时被调用
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数接受一个回调函数，当可观察者完成发布事件时会被调用
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all the `\` audio clips play at the right
    time. You may have to wait some time to hear the other audio clips. What is the
    problem?
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了足够的事情来使音频集成工作。运行应用程序并开始锻炼。除了滴答声之外，所有的`\`音频剪辑都在正确的时间播放。你可能需要等待一段时间才能听到其他音频剪辑。问题是什么？
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks` audio
    element or using the component life cycle events to trigger the ticking sound.
    Let's take the second approach.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们在锻炼开始时从未启动滴答声剪辑。我们可以通过在`ticks`音频元素上设置`autoplay`属性或使用组件生命周期事件来触发滴答声来修复它。让我们采取第二种方法。
- en: Using component life cycle events
  id: totrans-764
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件生命周期事件
- en: 'The injected `MyAudioDirective` in `WorkoutAudioComponent`, shown as follows,
    is not available till the view is initialized:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutAudioComponent`中注入的`MyAudioDirective`，如下所示，在视图初始化之前不可用：
- en: '[PRE136]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    children of `WorkoutAudioComponent` to be initialized.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在构造函数中访问`ticks`变量来验证它；它将是null。Angular还没有完成它的魔法，我们需要等待`WorkoutAudioComponent`的子组件初始化。
- en: The component's life cycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期钩子可以帮助我们在这里。当组件的视图初始化完成后，会调用`AfterViewInit`事件钩子，因此这是一个安全的地方，可以从中访问组件的子指令/元素。让我们快速完成它。
- en: 'Update `WorkoutAudioComponent` by adding the interface implementation, and
    the necessary imports, as highlighted:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加接口实现和必要的导入来更新`WorkoutAudioComponent`，如高亮所示：
- en: '[PRE137]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，去测试一下应用。应用现在有了完整的音频反馈，很棒！
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If, in the middle of the workout, we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上看起来一切都很正常，但现在应用程序中存在内存泄漏。如果在锻炼过程中我们离开锻炼页面（到开始或结束页面），然后再返回到锻炼页面，多个音频剪辑会在随机时间播放。
- en: It seems that `WorkoutRunnerComponent` is not getting destroyed on route navigation,
    and due to this, none of the child components are destroyed, including `WorkoutAudioComponent`.
    The net result? A new `WorkoutRunnerComponent` is being created every time we
    navigate to the workout page but is never removed from the memory on navigating
    away.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`WorkoutRunnerComponent`在路由导航时没有被销毁，因此，包括`WorkoutAudioComponent`在内的所有子组件都没有被销毁。最终结果是什么？每次我们导航到锻炼页面时都会创建一个新的`WorkoutRunnerComponent`，但在离开导航时却从未从内存中移除。
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will never
    be dereferenced.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内存泄漏的主要原因是我们添加到`WorkoutAudioComponent`中的事件处理器。当音频组件卸载时，我们需要从这些事件中取消订阅，否则`WorkoutRunnerComponent`引用将永远不会被解除引用。
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组件生命周期事件在这里发挥了救星的作用：`OnDestroy`。将以下实现添加到`WorkoutAudioComponent`类中：
- en: '[PRE138]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Also, remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得要添加对`OnDestroy`事件接口的引用，就像我们为`AfterViewInit`所做的那样。
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们在事件订阅期间创建的`subscription`数组现在看起来是有意义的。一次性取消订阅！
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 这种音频集成现在已完成。虽然这种方法不是整合两个组件的糟糕方式，但我们能做得更好。子组件引用父组件似乎是不受欢迎的。
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts` from
    the *Injecting a parent component into a child component* section onward.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请删除从`workout-audio.component.ts`的`*将父组件注入到子组件中*部分开始添加的代码。
- en: Sibling component interaction using events and template variables
  id: totrans-781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件和模板变量进行兄弟组件交互
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` were organized
    as sibling components?
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutRunnerComponent`和`WorkoutAudioComponent`被组织为兄弟组件会怎样？
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular''s *eventing* and *template reference variables*.
    Confused? Well, to start with, this is how the components should be laid out:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutAudioComponent`和`WorkoutRunnerComponent`成为兄弟组件，我们可以充分利用Angular的*事件*和*模板引用变量*。困惑吗？好吧，首先，组件应该这样布局：
- en: '[PRE139]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    HTML template would look? Think about it before you proceed further.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你想起什么吗？从这个模板开始，你能猜出最终的HTML模板会是什么样子吗？在你继续之前先想想。
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然感到困惑？一旦我们将它们作为兄弟组件，Angular模板引擎的力量就显现出来了。以下模板代码足以整合`WorkoutRunnerComponent`和`WorkoutAudioComponent`：
- en: '[PRE140]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `WorkoutAudioComponent` template variable, `wa`, is being manipulated by
    referencing the variable in the event handler expressions on `WorkoutRunnerComponent`.
    Quite elegant! We still need to solve the biggest puzzle in this approach: Where
    does the preceding code go? Remember, `WorkoutRunnerComponent` is loaded as part
    of route loading. Nowhere in the code have we had a statement like this:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutAudioComponent`模板变量`wa`通过在`WorkoutRunnerComponent`的事件处理器表达式中引用变量来被操作。相当优雅！我们仍然需要解决这个方法中最大的难题：前面的代码去哪里了？记住，`WorkoutRunnerComponent`是作为路由加载的一部分加载的。在代码的任何地方都没有这样的语句：'
- en: '[PRE141]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We need to reorganize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新组织组件树，引入一个可以托管`WorkoutRunnerComponent`和`WorkoutAudioComponent`的容器组件。然后路由器加载这个容器组件而不是`WorkoutRunnerComponent`。让我们开始吧。
- en: 'Generate a new component code from command line by navigating to `trainer/src/app/workout-runner` and
    executing:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到`trainer/src/app/workout-runner`并在命令行中执行来生成新的组件代码：
- en: '[PRE142]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Copy the HTML code with the events described to the template file. The workout
    container component is ready.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 将描述事件的HTML代码复制到模板文件中。锻炼容器组件就准备好了。
- en: 'We just need to rewire the routing setup. Open `app-routing.module.ts`. Change
    the route for the workout runner and add the necessary import:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要重新配置路由设置。打开`app-routing.module.ts`。更改锻炼运行者的路由并添加必要的导入：
- en: '[PRE143]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eye!
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个清晰、简洁且令人愉悦的音频集成工作！
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是结束本章的时候了，但在结束之前，我们需要解决在早期部分引入的视频播放器对话框故障。当视频播放器对话框打开时，锻炼不会停止/暂停。
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.4` code.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细说明修复方法，并敦促读者在没有查阅`checkpoint3.4`代码的情况下尝试修复。
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个明显的提示。使用事件基础设施！
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提示：从`VideoPlayerComponent`引发事件，每个播放开始和结束时引发一个。
- en: 'And one last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个提示：对话框服务（`Modal`）上的`open`函数返回一个承诺，当对话框关闭时该承诺被解决。
- en: If you are having a problem with running the code, look at the `checkpoint3.4` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看`checkpoint3.4`Git分支，以获取我们迄今为止所做工作的一个工作版本。或者如果你不使用Git，请从[http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4)下载`checkpoint3.4`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Summary
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Bit by bit, piece by piece, we have added a number of enhancements to the *7-Minute
    Workout* app that are imperative for any professional app. There is still scope
    for new features and improvements, but the core app works just fine.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步地，一点一滴地，我们已经为*7分钟锻炼*应用添加了许多对任何专业应用至关重要的增强功能。仍然有空间添加新功能和改进，但核心应用运行得很好。
- en: We started the chapter by exploring the Single Page Application (SPA) capabilities
    of Angular. Here we learned about basic Angular routing, setting up routes, using
    route configuration, generating links using the `RouterLink` directive, and using
    the Angular `Router` and `Location` services to perform navigation.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以探索Angular的单页应用程序（SPA）功能开始本章。在这里，我们了解了基本的Angular路由、设置路由、使用路由配置、使用`RouterLink`指令生成链接，以及使用Angular的`Router`和`Location`服务进行导航。
- en: From the app perspective, we added start, finish, and workout pages to *7-Minute
    Workout*.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用的角度来看，我们在*7分钟锻炼*中添加了开始、完成和工作页面。
- en: We then built a workout history tracker service that was used to track historical
    workout executions. During this process, we learned about Angular's **Dependency
    Injection (DI)** in depth. We covered how a dependency is registered, what a dependency
    token is, and how dependencies are singleton in nature. We also learned about
    injectors and how hierarchical injectors affect dependency probing.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后构建了一个锻炼历史追踪服务，用于追踪历史锻炼执行情况。在这个过程中，我们深入了解了Angular的**依赖注入（DI）**。我们涵盖了如何注册依赖项，依赖项令牌是什么，以及依赖项在本质上是如何单例的。我们还了解了注入器以及层次注入如何影响依赖项探测。
- en: 'Lastly, we touched upon an important topic: cross-component communication,
    primarily using Angular eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们触及了一个重要话题：跨组件通信，主要使用Angular事件。我们详细介绍了如何使用`@Output`装饰器和`EventEmitter`创建自定义事件。
- en: The `@ViewChild` and `@ViewChildren` decorators that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们提到的 `@ViewChild` 和 `@ViewChildren` 装饰器帮助我们理解父组件如何获取子组件以供使用。Angular DI 还允许将父组件注入到子组件中。
- en: We concluded this chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling-component communication can happen using Angular events and template
    variables.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个 `WorkoutAudioComponent` 来结束本章，并强调了如何使用 Angular 事件和模板变量实现兄弟组件之间的通信。
- en: What's next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7-Minute Workout* app into a generic *Workout Runner* app
    that can run workouts that we build using *Personal Trainer*.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？我们将构建一个新的应用程序，*个人教练*。这个应用程序将允许我们构建自己的自定义训练。一旦我们能够创建自己的训练，我们就将 *7 分钟训练*
    应用程序转变为一个通用的 *训练运行者* 应用程序，该应用程序可以运行我们使用 *个人教练* 构建的训练。
- en: For the next chapter, we'll showcase Angular's form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示 Angular 的表单功能，同时构建一个 UI，使我们能够创建、更新和查看我们自己的自定义训练/练习。
