- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Hooks: Bring State and Other Features into Function Components'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hooks：将状态和其他特性引入函数组件
- en: Hooks were introduced in function components to reap the benefits of React features
    without writing any classes and life cycle methods. Most developers use Redux,
    Recoil, Mobx, and other third-party libraries to manage the global state in large-scale
    applications. But when you use React Hooks such as `useContext` and `useReducer`
    together, it becomes a better alternative for external state management. Hooks
    are much easier to use than complex external libraries that involve excessive
    amounts of boilerplate code, repetitive files, and folders across the application.
    React also provides numerous other built-in Hooks that can be useful for various
    use cases in React applications. If there is no specific built-in Hook available
    to handle your use case, you can create your own Hook to fulfill your business
    needs. Some common use cases (or cross-cutting concerns) for Hooks are authentication,
    logging, caching, data fetching, and error handling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 是在函数组件中引入的，以利用 React 功能的好处，而无需编写任何类和生命周期方法。大多数开发者使用 Redux、Recoil、Mobx
    和其他第三方库来管理大型应用程序中的全局状态。但是，当您一起使用 React Hooks，如 `useContext` 和 `useReducer` 时，它成为外部状态管理的更好替代方案。Hooks
    比涉及大量样板代码、重复的文件和文件夹的复杂外部库更容易使用。React 还提供了许多其他内置 Hooks，这些 Hooks 可以用于 React 应用程序中的各种用例。如果没有特定的内置
    Hooks 可用于处理您的用例，您可以创建自己的 Hook 来满足您的业务需求。Hooks 的常见用例（或横切关注点）包括身份验证、日志记录、缓存、数据获取和错误处理。
- en: In this chapter, you will be introduced to React Hooks, their benefits, and
    various built-in Hooks that add React features to function components. The built-in
    Hooks will be explained in depth through examples to understand their usage in
    React applications. Additionally, you will gain the knowledge and confidence to
    answer questions related to third-party Hooks, create your own Hooks, and troubleshoot
    Hooks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解 React Hooks、它们的优点以及各种内置 Hooks，这些 Hooks 将 React 功能添加到函数组件中。将通过示例深入解释内置
    Hooks，以了解它们在 React 应用程序中的使用。此外，您将获得知识和信心，以回答与第三方 Hooks 相关的问题、创建自己的 Hooks 以及调试
    Hooks。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to Hooks and their purpose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hooks 及其目的简介
- en: Local state management using Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hooks 进行本地状态管理
- en: Global state management using Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Hooks 进行全局状态管理
- en: Performing side effects in React applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 应用程序中执行副作用
- en: Accessing DOM nodes using Ref Hooks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ref Hooks 访问 DOM 节点
- en: Optimizing the application performance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化应用程序性能
- en: Learning about popular third-party Hooks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解流行的第三方 Hooks
- en: Building your own Hooks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的 Hooks
- en: Troubleshooting and debugging Hooks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 Hooks
- en: Introduction to Hooks and their purpose
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hooks 及其目的简介
- en: Initially, React was mainly used with class components, but over the years the
    components became complex with the usage of various patterns to reuse the component
    logic. Subsequently, Hooks were introduced to simplify the code without writing
    any patterns, such as render props and **higher-order components** (**HOCs**).
    Since Hooks play an important role in building React applications nowadays, you
    can expect a couple of questions on Hooks in a React interview. This section will
    give you detailed answers about what Hooks are and what their purpose is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，React 主要与类组件一起使用，但随着时间的推移，组件变得复杂，因为使用了各种模式来重用组件逻辑。随后，Hooks 被引入以简化代码，无需编写任何模式，例如渲染属性和**高阶组件**（**HOCs**）。由于
    Hooks 在构建 React 应用程序中现在扮演着重要角色，你可以在 React 面试中期待到几个关于 Hooks 的问题。本节将为您提供关于 Hooks
    是什么以及它们的目的的详细答案。
- en: What are Hooks?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Hooks？
- en: Hooks are simple JavaScript functions that allow components to use the local
    state and execute side effects (or cross-cutting concerns) and other React features
    without writing classes. The Hooks API has been introduced in React 16.8 to isolate
    the stateful logic from the components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 是允许组件使用本地状态并执行副作用（或横切关注点）以及其他 React 功能的简单 JavaScript 函数，而无需编写类。Hooks API
    是在 React 16.8 中引入的，以将状态逻辑从组件中隔离出来。
- en: In a nutshell, the Hooks feature is a way for your function components to *Hook*
    into React’s life cycle and state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Hooks 功能是您的函数组件“挂钩”到 React 生命周期和状态的一种方式。
- en: What is the motivation behind Hooks?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hooks 背后的动机是什么？
- en: Hooks can solve a wide variety of problems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 可以解决各种各样的问题。
- en: 'Here are a few:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '*Difficulty in reusing stateful logic between components*: By default, React
    didn’t provide a way to reuse the component logic. Programming patterns such as
    **render props** and **HOCs** tried to solve this problem. But those patterns
    require modifying the structure of the component hierarchy, which makes the application
    cumbersome with the several layers of wrappers and makes it harder to follow the
    code.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在组件之间重用状态逻辑的困难*：默认情况下，React 没有提供重用组件逻辑的方法。例如，**渲染属性**和**高阶组件**（HOCs）等编程模式试图解决这个问题。但那些模式需要修改组件层次结构，这使得应用程序变得复杂，有多个包装层，并使代码更难跟踪。'
- en: As a result, Hooks were introduced to separate stateful logic from the components
    without modifying the component hierarchy.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，引入了 Hooks 来将状态逻辑从组件中分离出来，而不需要修改组件层次结构。
- en: '*Difficulty in understanding the complex components*: As an application grows,
    the components become much more complex with a full set of stateful logic and
    side effects. The life cycle methods become occupied with a mix of unrelated logic
    such as data fetching, adding event listeners, or removing event listeners in
    one place. For example, the `componentDidMount` life cycle method can perform
    data fetching for the component and add the event listeners too. At the same time,
    the related event listener logic, such as cleanup, needs to be added in the `componentWillUnmount`
    life cycle method. Ultimately, it becomes difficult to split the larger components
    into small components and, at the same time, difficult to test them.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解复杂组件的困难*：随着应用程序的增长，组件变得更加复杂，拥有完整的状态逻辑和副作用。生命周期方法被各种无关逻辑占据，例如数据获取、添加事件监听器或在一个地方移除事件监听器。例如，`componentDidMount`
    生命周期方法可以为组件执行数据获取并添加事件监听器。同时，相关的监听器逻辑，如清理，需要在 `componentWillUnmount` 生命周期方法中添加。最终，将大型组件拆分成小型组件变得困难，同时测试它们也变得困难。'
- en: Hooks can split the larger components into smaller functions with the related
    piece of code rather than splitting the code based on the life cycle methods.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Hooks 可以将大型组件拆分成带有相关代码的小函数，而不是根据生命周期方法来拆分代码。
- en: '*Confusion created by classes*: Classes are not specific to React, but they
    belong to JavaScript. If you would like to work on class components, first you
    should have a clear idea about **the** keyword behavior called **this**, which
    is different from that in other languages. Also, if you are not familiar with
    using ES2022 public class fields syntax, you need to remember about binding event
    listeners in the constructor. All these concepts created a lot of confusion among
    the developers about the proper usage.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由类引起的混淆*：类不是 React 特有的，但它们属于 JavaScript。如果你想要处理类组件，首先你应该清楚地了解称为 **this** 的关键字行为，它在其他语言中是不同的。此外，如果你不熟悉使用
    ES2022 公共类字段语法，你需要记住在构造函数中绑定事件监听器。所有这些概念在开发者中造成了大量关于正确使用的混淆。'
- en: Hooks are helpful for creating React features without writing the classes and
    to avoid confusion within the developer community.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 对于创建 React 功能非常有帮助，无需编写类，并且可以避免开发社区中的混淆。
- en: Can you describe the rules of Hook usage?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述 Hook 的使用规则吗？
- en: 'There are two main rules to be followed while using Hooks:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hooks 时需要遵循两个主要规则：
- en: '`useState` and `useEffect` Hooks.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useState` 和 `useEffect` Hooks。'
- en: '**Call Hooks from React functions only**: You shouldn’t call Hooks from regular
    JavaScript functions. Instead, you can call them from either React function components
    or custom Hooks.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅从 React 函数中调用 Hooks**：你不应该从常规 JavaScript 函数中调用 Hooks。相反，你可以从 React 函数组件或自定义
    Hooks 中调用它们。'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `eslint` plugin named `eslint-plugin-react-Hooks` ([https://www.npmjs.com/package/eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks))
    can be used to enforce the two rules described in the *Can you describe the rules
    of Hook* *usage?* section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用名为 `eslint-plugin-react-Hooks` 的 `eslint` 插件（[https://www.npmjs.com/package/eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks)）来强制执行在
    *你能描述 Hook 的使用规则吗* 部分中描述的两个规则。
- en: Can I use Hooks inside class components?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我能否在类组件中使用 Hooks？
- en: You cannot write Hooks inside class components. In other words, Hooks have been
    created for the function components only. However, you can mix class components,
    and function components with Hooks in a single component tree without causing
    any problems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在类组件中编写 Hooks。换句话说，Hooks 是为函数组件创建的。然而，你可以在单个组件树中混合类组件和函数组件，而不会引起任何问题。
- en: React components hold the data and keep track of data changes using an updatable
    structure called the **state**. In real-world applications, most components use
    the state to process and display the data in their UI. In the next section, we
    will be covering questions and their answers related to local state management
    using state Hooks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件通过一个可更新的结构称为 **状态** 来持有数据和跟踪数据变化。在实际应用中，大多数组件使用状态来处理和显示它们 UI 中的数据。在下一节中，我们将讨论与使用状态
    Hooks 进行本地状态管理相关的问题及其答案。
- en: Local state management using Hooks
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 进行本地状态管理
- en: There are two Hooks to achieve local state management inside React applications.
    The first Hook, named `useState`, can be used for simple state transformations,
    and the other Hook, `useReducer`, is used for complex state logic. Basically,
    `useState` uses `useReducer` internally. This means that the entire component
    state can be managed through the `useReducer` Hook itself. Since the state is
    a core building block of a React component, every developer should have a clear
    idea about managing the state using Hooks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用程序内部，有两种 Hooks 可以实现本地状态管理。第一个 Hook，名为 `useState`，可用于简单的状态转换，另一个 Hook，`useReducer`，用于复杂的状态逻辑。基本上，`useState`
    在内部使用 `useReducer`。这意味着整个组件状态可以通过 `useReducer` Hook 本身来管理。由于状态是 React 组件的核心构建块，每个开发者都应该清楚地了解如何使用
    Hooks 来管理状态。
- en: What is the useState Hook?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 `useState` Hook？
- en: 'The `useState` Hook is used to add the state to a function component. This
    is one of the most used built-in Hooks from React. This Hook takes the initial
    state as an argument and the same initial state can be either a value or a function
    type (i.e., initializer function). If the initial state is derived from an expensive
    computation, it is suggested to use the initializer function, which will be executed
    only on the initial render. The `useState` Hook returns an array that contains
    two values: the state variable and the setter function to update the state.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` Hook 用于向函数组件添加状态。这是 React 中最常用的内置 Hooks 之一。此 Hook 接收初始状态作为参数，相同的初始状态可以是值或函数类型（即初始化函数）。如果初始状态来自昂贵的计算，建议使用初始化函数，它只会在初始渲染时执行。`useState`
    Hook 返回一个包含两个值的数组：状态变量和用于更新状态的设置函数。'
- en: 'The syntactic representation of `useState` looks as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 的语法表示如下：'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s take an example of a counter component that preserves the state of a
    counter using the `useState` Hook. The setter function is used to update the `count`
    state variable and re-render the UI for any changes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个使用 `useState` Hook 保留计数器状态的计数器组件为例。设置函数用于更新 `count` 状态变量并重新渲染 UI 以反映任何更改：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Upon clicking the counter button each time, the `count` state variable will
    be incremented by one and the respective UI updated with the latest state variable's
    value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击计数器按钮时，`count` 状态变量将增加一，并且相应的 UI 将使用最新的状态变量值进行更新。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The state setter function doesn’t update the current state in the already executing
    code. It will be available only in the next render.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 状态设置函数不会更新正在执行的代码中的当前状态。它只会在下一次渲染中可用。
- en: Is it always recommended to use an updater function?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是否总是建议使用更新函数？
- en: You might hear about the recommendation from the developer community to always
    use an updater function to update the state if the new state is calculated from
    the previous state. This rule is helpful to avoid an unpredictable state after
    doing some state calculation logic. Even though there is no harm in following
    this rule, it is not always necessary. In most cases, React will update the state
    variable before the next event happens. That is, there is no risk of stale data
    for the state in the beginning of the event handler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会听到来自开发者社区的推荐，即始终使用更新函数来更新状态，如果新状态是从先前状态计算得出的。这个规则有助于避免在执行一些状态计算逻辑后出现不可预测的状态。尽管遵循这个规则没有坏处，但并不总是必要的。在大多数情况下，React
    会在下一个事件发生之前更新状态变量。也就是说，在事件处理程序开始时，状态不会有过时数据的风险。
- en: 'But if you are doing multiple state updates in the same event handler, then
    it is suggested to use an updater function to receive the expected data result.
    The usage of an updater function inside an event handler is coded as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你在同一个事件处理程序中执行多个状态更新，那么建议使用更新函数来接收预期的数据结果。在事件处理程序中使用更新函数的编码方式如下：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, `a => a + 1` is an updater function. React puts your updater functions
    in a queue and as a result, updates on same state variables are batched. During
    the next render, React will call them in the same order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`a => a + 1` 是一个更新函数。React 将您的更新函数放入队列中，因此对同一状态变量的更新被批处理。在下一个渲染过程中，React
    将按相同的顺序调用它们。
- en: What is a useReducer Hook? How do you use it?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 useReducer 钩子？如何使用它？
- en: The `useReducer` Hook is an alternative to the `useState` Hook. It is used to
    separate the custom state logic (e.g., add, update, and delete items of a state)
    from the rendering logic. In other words, it is helpful for extracting the state
    management out of the component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子是 `useState` 钩子的替代品。它用于将自定义状态逻辑（例如，添加、更新和删除状态项）与渲染逻辑分离。换句话说，它有助于将状态管理从组件中提取出来。'
- en: This Hook accepts three arguments. The first argument is a reducer function
    that specifies how to update the state, the second argument is for the initial
    state, and the third argument is an optional initializer function to determine
    the initial state. In contrast, `useState` just accepts the initial state.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子接受三个参数。第一个参数是一个 reducer 函数，指定如何更新状态，第二个参数用于初始状态，第三个参数是一个可选的初始化器函数，用于确定初始状态。相比之下，`useState`
    只接受初始状态。
- en: The `useReducer` Hook returns an array with two values, current state and dispatch
    function, which is used to modify the state and trigger re-renders.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子返回一个包含两个值的数组，当前状态和 dispatch 函数，用于修改状态并触发重新渲染。'
- en: 'Let’s understand the usage of this Hook with a counter example. Here, you can
    update the counter state value with increment, decrement, and reset actions using
    a reducer function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个计数器示例来了解此钩子的用法。在这里，您可以使用 reducer 函数通过增加、减少和重置操作来更新计数器状态值：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: React will save the initial state once and ignore it for the next renders. So,
    you need to avoid recreating the initial state for each render if you are deriving
    the state through a function call. Instead, you can use an initializer function
    as a third argument for the reducer function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: React 一次保存初始状态并忽略后续渲染。因此，如果您通过函数调用推导状态，则需要避免在每个渲染中重新创建初始状态。相反，您可以使用初始化器函数作为
    reducer 函数的第三个参数。
- en: In the third argument in the preceding code, the `init` function has been used
    to process the initial state based on a default value mentioned as the second
    argument within the Hook.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码的第三个参数中，`init` 函数已被用于根据 Hook 中提到的第二个参数的默认值处理初始状态。
- en: 'The important phases of the preceding code are described in the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的重要阶段在以下步骤中描述：
- en: When any of the button-click events are triggered, the respective event handler
    will be dispatched with an action to the reducer function.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当任何按钮点击事件被触发时，相应的事件处理程序将携带一个动作派发到 reducer 函数。
- en: Thereafter, the reducer function will update the state to a new state based
    on the requirement.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，reducer 函数将根据要求将状态更新为新状态。
- en: The state update will trigger the component to re-render to update the UI.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态更新将触发组件重新渲染以更新 UI。
- en: 'The flow diagram in *Figure 3**.1* depicts the `useReducer` Hook’s behavior
    in a step-by-step manner:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.1* 中的流程图以逐步方式描述了 `useReducer` 钩子的行为：'
- en: '![Figure 3.1: Behavior of the useReducer Hook](img/Figure_03.01_B18603.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：useReducer 钩子的行为](img/Figure_03.01_B18603.jpg)'
- en: 'Figure 3.1: Behavior of the useReducer Hook'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：useReducer 钩子的行为
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `useReducer` Hook won’t re-render the children if there is no change in
    state compared to the previous state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与上一个状态相比状态没有变化，`useReducer` 钩子不会重新渲染子组件。
- en: When should you use the useReducer Hook over the useState Hook?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该在什么情况下使用 useReducer 钩子而不是 useState 钩子？
- en: 'Both the `useReducer` and `useState` Hooks are helpful in managing the application
    state, but the `useReducer` Hook provides a well-controlled and powerful state
    management solution for the following reasons:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`useReducer` 和 `useState` 钩子都有助于管理应用程序状态，但 `useReducer` 钩子提供了以下原因的受控且强大的状态管理解决方案：'
- en: The `useReducer` Hook is preferred over `useState` when you need to manage complex
    state logic. For example, when the state contains multiple nested values or the
    next state depends on the previous one, the `useReducer` Hook is a better choice.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要管理复杂的状态逻辑时，首选 `useReducer` 钩子而不是 `useState`。例如，当状态包含多个嵌套值或下一个状态依赖于前一个状态时，`useReducer`
    钩子是一个更好的选择。
- en: The `useReducer` Hook can handle multiple actions in a single function rather
    than creating separate functions for each action using the `useState` Hook.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子可以在单个函数中处理多个动作，而不是使用 `useState` 钩子为每个动作创建单独的函数。'
- en: The `useReducer` Hook is also helpful in optimizing the performance of components
    that trigger deep or nested updates, because you can pass down a dispatch function
    of the `useReducer` Hook at any nested level via context instead of passing callbacks
    to every level of a component tree. In other words, it helps in avoiding the prop
    drilling issue mentioned in [*Chapter 2*](B18603_02.xhtml#_idTextAnchor055). Moreover,
    the dispatch function won’t change between re-renders.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer` 钩子对于优化触发深度或嵌套更新的组件的性能也非常有帮助，因为你可以通过上下文在任何嵌套级别传递 `useReducer` 钩子的
    dispatch 函数，而不是将回调函数传递到组件树的每一层。换句话说，它有助于避免在[*第二章*](B18603_02.xhtml#_idTextAnchor055)中提到的属性钻取问题。此外，dispatch
    函数在重新渲染之间不会改变。'
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since `useState` itself is derived from the `useReducer` Hook under the hood,
    you can cover all the state use cases with `useReducer`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `useState` 本身是在底层由 `useReducer` 钩子派生出来的，因此你可以使用 `useReducer` 覆盖所有状态用例。
- en: If you need to share the component state with multiple child components that
    exist in the deeper level of a component tree, it is preferred to use the in-built
    context Hook from React. This Hook is mainly used to maintain application-wide
    data, which is known as global state management.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将组件状态与存在于组件树更深层次的多个子组件共享，则建议使用 React 内置的 context 钩子。此钩子主要用于维护应用程序范围内的数据，这被称为全局状态管理。
- en: Global state management using Hooks
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Hooks 进行全局状态管理
- en: The `useContext` Hook is commonly used along with the `useState` Hook for global
    state management. The major advantage of the `useContext` Hook is that it solves
    the prop drilling issue.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext` 钩子通常与 `useState` 钩子一起用于全局状态管理。`useContext` 钩子的主要优势是它解决了属性钻取问题。'
- en: Detailed common use cases of the `useContext` Hook were already explained in
    [*Chapter 2*](B18603_02.xhtml#_idTextAnchor055). Hence, this section will mainly
    focus on specific use case questions related to global state management using
    the `useContext` Hook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext` 钩子的详细常见用法已在[*第二章*](B18603_02.xhtml#_idTextAnchor055)中解释。因此，本节将主要关注与使用
    `useContext` 钩子进行全局状态管理相关的特定用例问题。'
- en: How do you override context for a specific part of the component tree?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何覆盖组件树中特定部分的上下文？
- en: Sometimes, you may need to override the context with a different value for a
    certain part of the component tree. It is possible to override the context value
    by wrapping that part in a provider with a different value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要用不同的值覆盖组件树中某个部分的上下文。可以通过将这部分包裹在一个具有不同值的 provider 中来覆盖上下文值。
- en: 'As an example, the following code applies a blue background to all the pages
    except for the contact page, where a white background will be applied using a
    context provider:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将蓝色背景应用于除联系页面外的所有页面，而联系页面将使用上下文提供者应用白色背景：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is no restriction on the nesting level or number of times you override
    the context using a provider.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 provider 覆盖上下文时，没有对嵌套级别或覆盖次数的限制。
- en: What would the context value be for no matching provider?
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果没有匹配的 provider，上下文值会是什么？
- en: If there is no matching provider above the calling component of the `useContext`
    Hook, the default value mentioned in the context creation will be returned – that
    is, the default value used in `createContext(defaultValue)`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `useContext` 钩子的调用组件上方没有匹配的 provider，则将返回上下文创建中提到的默认值——即 `createContext(defaultValue)`
    中使用的默认值。
- en: If you specify a default value, you can avoid unexpected errors on the page
    for any missing providers in the component tree.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了一个默认值，你可以避免在页面中任何缺失的 provider 上出现意外的错误。
- en: In class components, the side effects are handled in different life cycle methods
    such as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
    based on the requirement. On the other hand, in function components, effect Hooks
    simplify the handling of side effects based on rendering in a single place. The
    next section will cover frequently asked questions about performing side effects
    in React applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在类组件中，根据需求，副作用是在不同的生命周期方法中处理的，例如 `componentDidMount`、`componentDidUpdate` 和
    `componentWillUnmount`。另一方面，在函数组件中，effect 钩子简化了基于渲染的单点副作用处理。下一节将涵盖关于在 React 应用程序中执行副作用时经常提出的问题。
- en: Performing side effects in React applications
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 应用程序中执行副作用
- en: 'Effects are an escape hatch in React programming. React provides a few effect
    Hooks that are used to implement side effects such as data fetching, subscriptions,
    timers, logging, DOM manipulations, and so on within function components. These
    Hooks should be used only when you are synchronizing with external systems. There
    are three types of Hooks available:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 效果是 React 编程中的一个逃生门。React 提供了一些效果钩子，用于在函数组件中实现副作用，如数据获取、订阅、计时器、日志记录、DOM 操作等。这些钩子仅应在您与外部系统同步时使用。有三种类型的钩子可用：
- en: '**useEffect**: This is a frequently used Hook to connect a component to an
    external system.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**useEffect**：这是一个常用的钩子，用于将组件连接到外部系统。'
- en: '`useEffect` Hook except that it fires before the browser repaints the screen
    to measure the layout.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子除了在浏览器重绘屏幕以测量布局之前触发之外，与 `useEffect` 钩子相同。'
- en: '**useInsertionEffect**: This Hook fires before React makes changes to the DOM,
    such as adding dynamic CSS.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**useInsertionEffect**：此钩子在 React 对 DOM 进行更改之前触发，例如添加动态 CSS。'
- en: Let’s thoroughly discuss the various effect Hooks and their features to answer
    the questions asked in the interview.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论各种效果钩子和它们的特性，以回答面试中提出的问题。
- en: How do reactive dependencies impact the logic inside the useEffect Hook?
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应依赖项如何影响 `useEffect` 钩子内部的逻辑？
- en: The `useEffect` Hook accepts an optional dependencies argument that accepts
    an array of reactive values. You cannot choose dependencies for your effect and
    every reactive value should be declared as a dependency to avoid any kinds of
    bugs. There are different scenarios for passing the reactive dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子接受一个可选的依赖项参数，该参数接受一个反应值的数组。您不能为您的效果选择依赖项，并且每个反应值都应该声明为依赖项，以避免任何类型的错误。存在不同的场景来传递反应依赖项。'
- en: Passing the dependency array
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递依赖项数组
- en: If you pass the reactive values in a dependency array, the effect should run
    the logic after the initial render and also after each re-render with the changed
    dependencies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在依赖项数组中传递反应值，则效果应在初始渲染之后以及每次具有更改依赖项的重新渲染后运行逻辑。
- en: 'The following is an example of passing name and status reactive dependencies
    to understand the syntax of `useEffect` with an array of dependencies:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，用于传递名称和状态反应依赖项，以了解使用依赖项数组时的 `useEffect` 语法：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Passing the empty dependency array
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递空依赖项数组
- en: 'If your effect doesn’t use any reactive values, it only runs after the initial
    render. In this case, the effect Hook looks as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的效果不使用任何反应值，它仅在初始渲染后运行。在这种情况下，效果钩子如下所示：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Not passing the dependency array
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未传递依赖项数组
- en: 'If you skip passing the dependency array, itself the effect runs after every
    re-render of your component, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跳过传递依赖项数组，则效果将在您的组件每次重新渲染后运行，如下所示：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: React will compare each reactive value from the dependency array with its previous
    value using `Object.is` comparison to verify the changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React 将使用 `Object.is` 比较比较依赖项数组中的每个反应值与其上一个值，以验证更改。
- en: How often are setup and cleanup functions invoked inside the useEffect Hook?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `useEffect` 钩子内部，设置和清理函数被调用的频率是多少？
- en: 'In most cases, effects should have a cleanup function to clear or undo the
    changes created by their respective setup code. React invokes setup and cleanup
    functions in the following different phases of the component life cycle:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，效果应该有一个清理函数来清除或撤销由其相应的设置代码创建的更改。React 在以下不同的组件生命周期阶段调用设置和清理函数：
- en: '**Mounting**: The logic inside the setup function runs whenever the component
    is added to the DOM or view.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：设置函数中的逻辑在组件被添加到 DOM 或视图中时运行。'
- en: '**Re-rendering**: After every re-rendering of a component along with its dependency
    change, the cleanup (if it is defined) and setup functions will be invoked in
    an order. Here, the cleanup function runs with the old props and state, and the
    setup code runs with the latest props and state thereafter.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新渲染**：在组件及其依赖项更改的每次重新渲染之后，清理（如果已定义）和设置函数将按顺序调用。在这里，清理函数使用旧属性和状态运行，然后设置代码使用最新的属性和状态运行。'
- en: '**Unmounting**: The cleanup code runs one final time after the component is
    removed from the DOM or view. This cleanup function helps to avoid unwanted behaviors
    such as memory leaks and to improve performance.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载**：在组件从 DOM 或视图中移除后，清理代码将最后一次运行。此清理函数有助于避免不希望的行为，如内存泄漏，并提高性能。'
- en: If strict mode is turned on in your React application, there will be an extra
    development-only **setup and cleanup cycle** before the first actual setup call.
    This is to ensure the cleanup logic mirrors the setup logic to avoid any discrepancies
    with the setup code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的React应用程序中启用了严格模式，则在第一次实际设置调用之前将有一个额外的仅开发使用的**设置和清理周期**。这是为了确保清理逻辑与设置逻辑相匹配，以避免与设置代码有任何差异。
- en: When should you remove an object or a function from dependencies?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该在什么时候从依赖中移除一个对象或一个函数？
- en: There might be a situation where your effect might re-run more frequently than
    necessary if that effect depends on an object or a function created during rendering.
    This is because the object or function created is different for every render.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果效果依赖于在渲染过程中创建的对象或函数，那么可能存在一种情况，即效果可能比必要的更频繁地重新运行。这是因为为每次渲染创建的对象或函数是不同的。
- en: 'Let’s understand this concept in a better way using an example. The following
    is an example of fetching a list of users inside the `useEffect` Hook based on
    the `Url` and `name` query parameter dependencies. Here, the query object has
    been created during rendering to build the absolute URL path:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子更好地理解这个概念。以下是一个根据`Url`和`name`查询参数依赖关系在`useEffect` Hook中获取用户列表的示例。在这里，查询对象是在渲染过程中创建的，用于构建绝对URL路径：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, the `userQueryOptions` object has been recreated for
    every re-rendering due to the `message` state changes. Also, this `message` data
    is not related to reactive elements inside the effect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由于`message`状态的变化，`userQueryOptions`对象在每次重新渲染时都被重新创建。此外，这个`message`数据与效果内部的反应性元素无关。
- en: 'This issue can be fixed by moving the object inside the effect and replacing
    the object dependency with a `name` string, because `name` is the only reactive
    value the effect depends on:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将对象移动到效果内部并使用`name`字符串替换对象依赖项，可以修复此问题，因为`name`是效果所依赖的唯一反应性值：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the same way, you can avoid creating the function during the rendering phase
    by moving it inside the effect Hook. After that, you can replace the function
    dependency with the direct reactive dependency value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以通过将函数移动到效果Hook内部来避免在渲染阶段创建函数。之后，您可以将函数依赖项替换为直接的反应性依赖值。
- en: What is the useLayoutEffect Hook? How does it work?
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useLayoutEffect` Hook有什么用？它是如何工作的？'
- en: The `useLayoutEffect` Hook is a special type of effect Hook that is invoked
    before the browser repaints the screen. This Hook is mainly used for scenarios
    where the component flickers when the state is updated. Imagine a pop-over component
    on the web page. The component first needs to determine the position of the element
    in the viewport before rendering it correctly on the screen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLayoutEffect` Hook是一种在浏览器重绘屏幕之前调用的特殊类型的effect Hook。此Hook主要用于在状态更新时组件闪烁的场景。想象一下网页上的弹出组件。组件首先需要确定元素在视口中的位置，然后才能正确地在屏幕上渲染。'
- en: 'The main purpose of the `useLayoutEffect` Hook is to provide the layout information
    to the component for rendering. It works in three simple steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`useLayoutEffect` Hook的主要目的是为组件提供布局信息以进行渲染。它通过三个简单的步骤工作：'
- en: Render the initial content without layout information.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有布局信息的情况下渲染初始内容。
- en: Calculate the layout size before the browser repaints the screen.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器重绘屏幕之前计算布局大小。
- en: Re-render the component using the correct layout information.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的布局信息重新渲染组件。
- en: Caution
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The component is going to be rendered twice and will block the browser before
    it repaints the screen. This impacts the application performance. Therefore, it
    is recommended to use the `useLayoutEffect` Hook only where it is required.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 组件将被渲染两次，并在屏幕重绘之前阻止浏览器。这会影响应用程序的性能。因此，建议仅在需要时使用`useLayoutEffect` Hook。
- en: Since effects will run after every render, one of the major ways to improve
    performance in React applications is to avoid unnecessary re-renders. There are
    a few in-built Hooks created in React to optimize the performance. Let’s dive
    deep into those details in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于效果将在每次渲染后运行，因此提高React应用程序性能的主要方法之一是避免不必要的重新渲染。React中创建了一些内置的Hooks来优化性能。让我们在下一节深入探讨这些细节。
- en: Optimizing the application performance
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化应用程序性能
- en: The performance optimizations have a massive impact on the customer experience.
    Even though React applications have a very fast UI by default, there might be
    performance issues when the size of the application increases. This section will
    focus on the questions related to performance optimization Hooks, which you could
    expect to be asked by interviewers to gauge your skill from a broader perspective.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化对客户体验有巨大影响。尽管 React 应用程序默认具有非常快的 UI，但当应用程序的大小增加时，可能会有性能问题。本节将重点介绍与性能优化钩子相关的问题，这些问题可能是面试官用来从更广泛的角度评估你的技能。
- en: What is memoization? How can it be implemented in React?
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是记忆化？如何在 React 中实现？
- en: '**Memoization** is an optimization technique for speeding up web applications
    by caching the results of expensive function calls. It returns the cached result
    when the same input arguments have been passed again.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**记忆化**是一种优化技术，通过缓存昂贵的函数调用结果来加速 Web 应用程序。当再次传递相同的输入参数时，它会返回缓存的結果。'
- en: 'In React, this optimization can be implemented through two Hooks: `useMemo`
    and `useCallback`. These Hooks improve the performance, skipping the unnecessary
    re-rendering by returning the cached result when the same input is given.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，这种优化可以通过两个钩子实现：`useMemo` 和 `useCallback`。这些钩子通过在相同输入给出时返回缓存的結果来提高性能，跳过不必要的重新渲染。
- en: Can you describe the useMemo() Hook?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能描述一下 useMemo() 钩子吗？
- en: 'The `useMemo()` Hook is used to cache the result of an expensive calculation
    between re-renders. The syntax of this Hook looks as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo()` 钩子用于在重新渲染之间缓存昂贵的计算结果。这个钩子的语法如下：'
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This Hook returns the value of the expensive calculation by accepting two arguments.
    The first argument is a function to do the expensive calculation, and the second
    is an array of dependencies that are reactive values used in the calculation.
    In other words, the cached result (or stored value from the last render) will
    be returned when there are no changes to the dependency values. Otherwise, the
    calculation will be performed again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子通过接受两个参数来返回昂贵的计算结果。第一个参数是执行昂贵计算的功能，第二个参数是用于计算的依赖项数组，这些依赖项是响应式值。换句话说，当依赖项值没有变化时，将返回缓存的結果（或上一次渲染存储的值）。否则，将再次执行计算。
- en: 'Let’s understand this concept with an example. Consider a factorial calculation
    function of a number and apply the `useMemo` Hook around it. The component also
    performs an increment action that is independent of the calculation function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念。考虑一个数字的阶乘计算函数，并在其周围应用 `useMemo` 钩子。该组件还执行一个与计算函数无关的增量操作：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, if you increment the counter value, there won’t be any
    re-rendering related to the factorial function because the respective reactive
    number was not updated. That is, the factorial function will only be called where
    there is a change in the input number, but not when the counter value is incremented.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果你增加计数器的值，由于相应的响应式数字没有被更新，因此与阶乘函数相关的任何重新渲染都不会发生。也就是说，阶乘函数只有在输入数字发生变化时才会被调用，而不会在计数器值增加时被调用。
- en: What are the possible use cases of the useMemo() Hook?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useMemo() 钩子的可能用例有哪些？
- en: Memoization is helpful in optimizing the application performance, and some of
    the developers even think that there is no harm in memoizing almost all the components
    as much as possible. However, this technique is unnecessary for simple calculations
    within the functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化有助于优化应用程序性能，一些开发者甚至认为尽可能多地记忆化几乎所有组件都没有害处。然而，这种技术在函数内的简单计算中是不必要的。
- en: 'There are a few common cases where memoization is useful:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见情况，记忆化非常有用：
- en: When there are expensive calculations, such as sorting, filtering, changing
    the format, and so on while rendering the content
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在渲染内容时进行昂贵的计算，例如排序、过滤、更改格式等
- en: When you are passing a prop to a component wrapped within the `useMemo` Hook
    and want to skip re-renderings when there is no change in the prop – that is,
    when pure components can be wrapped within `useMemo`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将属性传递给 `useMemo` 钩子包装的组件，并且希望在属性没有变化时跳过重新渲染——也就是说，当纯组件可以包装在 `useMemo` 中时
- en: When the value passing to the wrapped component has been used as a dependency
    of some other Hook
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递给包装组件的值被用作其他钩子的依赖项时
- en: The **profiler** section of **React DevTools** will be helpful in identifying
    the components that are laggy and require memoization to add.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**React DevTools**的**分析器**部分将有助于识别需要添加记忆化的卡顿组件。'
- en: What are common mistakes with the usage of useMemo? How do you rectify them?
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`useMemo`时常见的错误有哪些？你如何纠正它们？
- en: 'The usage of the `useMemo` Hook is quite straightforward, and this Hook might
    be used extensively to optimize the rendering performance. However, you need to
    be careful with some of the following common mistakes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMemo` Hook的使用相当简单，这个Hook可能会被广泛用于优化渲染性能。然而，你需要小心以下一些常见的错误：'
- en: If you try to return an object from the `useMemo` Hook, then either wrap it
    with parentheses or write an explicit return statement.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试从`useMemo` Hook返回一个对象，那么要么用括号将其包裹，要么写一个显式的返回语句。
- en: 'For example, the following `useMemo` Hook returns an undefined value because
    the opening brace ({) is part of an arrow function but not the object:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下`useMemo` Hook返回一个未定义的值，因为开括号({)是箭头函数的一部分，但不是对象的一部分：
- en: '[PRE12]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This can be fixed by an explicit return statement for the object, as follows:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过为对象添加显式的返回语句来修复，如下所示：
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you forget to specify the dependencies, then the calculation will re-render
    every time:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你忘记指定依赖项，那么计算将在每次渲染时重新执行：
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The reactive values used in the calculation are to be passed in the dependencies
    array to avoid unnecessary renders:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于计算的响应式值应传递到依赖项数组中，以避免不必要的渲染：
- en: '[PRE15]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You shouldn’t call `useMemo` inside loops. Instead, wrap it or extract it under
    a new component:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不应该在循环中调用`useMemo`。相反，将其包裹或提取到一个新组件下：
- en: '[PRE16]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can be solved by extracting the `useMemo` calculation inside a child component:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过在子组件内部提取`useMemo`计算来解决：
- en: '[PRE17]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The aforementioned points can be treated as best practices while working with
    the `useMemo` Hook.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`useMemo` Hook时，上述点可以作为最佳实践。
- en: When should you use the useCallback Hook instead of the useMemo Hook?
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该在什么情况下使用`useCallback` Hook而不是`useMemo` Hook？
- en: When a top-level component re-renders, by default, React re-renders all its
    children recursively. This situation will impact the performance of the application
    if the child component has heavy calculation. In this case, the child component
    needs to be optimized using the Memo API or the `useMemo` Hook.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶层组件重新渲染时，默认情况下，React会递归地重新渲染所有子组件。如果子组件有大量的计算，这种情况将影响应用程序的性能。在这种情况下，需要使用Memo
    API或`useMemo` Hook来优化子组件。
- en: However, if you pass the callback function as a prop to the child component,
    React will always re-render the children because either the function definition
    or arrow function is treated as a new function every time re-rendering occurs.
    This defeats the purpose of memoization. In this case, `useCallback` is helpful
    in optimizing the performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将回调函数作为prop传递给子组件，React将始终重新渲染子组件，因为函数定义或箭头函数在每次重新渲染时都被视为新函数。这违背了记忆化的目的。在这种情况下，`useCallback`有助于优化性能。
- en: The `useCallback` Hook is like the `useMemo` Hook, but it caches the callback
    function instead of a value. You can still use the `useMemo` Hook but the calculation
    function would have to return another function; that is, it requires an extra
    nested function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback` Hook类似于`useMemo` Hook，但它缓存的是回调函数而不是值。你仍然可以使用`useMemo` Hook，但计算函数必须返回另一个函数；也就是说，它需要一个额外的嵌套函数。'
- en: Let’s discuss this concept with an example that contains `TaxCalculation` as
    the parent component and `TaxPayer` as the child component. In the child component,
    you need to skip re-rendering considering when the same props are sent and re-rendering
    is slow.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个包含`TaxCalculation`作为父组件和`TaxPayer`作为子组件的例子来讨论这个概念。在子组件中，你需要考虑在相同的props发送和重新渲染缓慢的情况下跳过重新渲染。
- en: 'To skip re-rendering, first, you need to wrap the child component (`TaxPayer`)
    with the memo function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跳过重新渲染，首先需要使用记忆函数包裹子组件（`TaxPayer`）：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the parent component re-renders with a change in the `income` prop, then
    this change leads to the re-rendering of the child component as well. This won’t
    be a big problem when the child component doesn’t have any big calculations and
    changes from the `income` prop are minimal.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件在`income` prop发生变化时重新渲染，那么这种变化会导致子组件也重新渲染。当子组件没有进行大量计算且`income` prop的变化很小的时候，这不会是一个大问题。
- en: However, if you pass a callback function to a child component as a prop, it
    creates a new function every time. This specific case should be avoided all the
    time, irrespective of the performance impact.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将回调函数作为 prop 传递给子组件，它会在每次传递时创建一个新的函数。无论性能影响如何，都应该始终避免这种情况。
- en: 'To skip the re-render because of a new prop every time, let’s apply the `useCallback`
    Hook for the `handleSubmit` callback function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次新 prop 导致的重新渲染，让我们为 `handleSubmit` 回调函数应用 `useCallback` Hook：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, the callback function is going to be memoized until or
    unless there is a change in dependency reactive values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，回调函数将被缓存，直到或除非依赖的响应式值发生变化。
- en: Similar to the Ref API that exists in class components, some Hooks have been
    created in function components especially to interact with DOM nodes. The next
    section talks about important concepts related to accessing the DOM nodes using
    Hooks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件中存在的 Ref API 类似，一些 Hooks 在函数组件中也被创建，特别是为了与 DOM 节点交互。下一节将讨论使用 Hooks 访问 DOM
    节点的重要概念。
- en: Accessing DOM nodes using ref Hooks
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ref Hooks 访问 DOM 节点
- en: Refs are useful when you need to work with external systems (or non-React systems)
    such as built-in browser APIs. There are two built-in ref Hooks available in function
    components. The `useRef` Hook is used to declare a ref to hold any kind of value
    but is mainly used for DOM nodes. `useImperativeHandle` is used to expose the
    customized ref with only the required methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与外部系统（或非 React 系统）如内置浏览器 API 交互时，Refs 非常有用。函数组件中有两个内置的 ref Hooks。`useRef`
    Hook 用于声明一个可以持有任何类型的值的 ref，但主要用于 DOM 节点。`useImperativeHandle` 用于仅暴露所需方法的定制 ref。
- en: Please note that an introduction to refs has already been covered in [*Chapter
    2*](B18603_02.xhtml#_idTextAnchor055). In this section, we will go beyond what
    we have already discussed about refs in [*Chapter 2*](B18603_02.xhtml#_idTextAnchor055).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于 ref 的介绍已经在[*第二章*](B18603_02.xhtml#_idTextAnchor055)中进行了覆盖。在本节中，我们将超越在[*第二章*](B18603_02.xhtml#_idTextAnchor055)中已经讨论的关于
    ref 的内容。
- en: How do you avoid recreating the Ref contents?
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何避免重新创建 Ref 内容？
- en: The `useRef` Hook accepts the initial value (or default value) as an argument,
    like the `useState` Hook. The declaration of this Hook should be placed at the
    top of the enclosed component.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` Hook 接受初始值（或默认值）作为参数，就像 `useState` Hook 一样。此 Hook 的声明应放在封装组件的顶部。'
- en: React saves this initial value at the first render and ignores it for the next
    renders, but if you create an expensive object for the initial value of the ref,
    it might be called for every render unnecessarily. This will impact the performance
    of the application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: React 在第一次渲染时保存此初始值，并在后续渲染中忽略它，但如果你为 ref 的初始值创建了一个昂贵的对象，它可能会在每次渲染中不必要地被调用。这将影响应用程序的性能。
- en: 'The declaration of the initial ref value and how the ref content is recreated
    can be explained in a better way with the use of the following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下示例可以更好地解释初始 ref 值的声明以及 ref 内容是如何重新创建的：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, the `CreateBlogArticle()` function is always invoked
    to create the expensive object, even though React ignores this object from the
    second render onward.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`CreateBlogArticle()` 函数始终被调用以创建昂贵的对象，即使 React 从第二次渲染开始就忽略了此对象。
- en: 'This issue can be resolved by restricting the invocation of the `CreateBlogArticle()`
    function for the subsequent renders, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过限制 `CreateBlogArticle()` 函数在后续渲染中的调用来解决此问题，如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now the blog article object is calculated only once during the initial rendering.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在博客文章对象仅在初始渲染期间计算一次。
- en: Is it possible to access a ref in the render method?
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在渲染方法中能否访问 ref？
- en: Yes, you can access the current value of a ref inside the render method, but
    it is not recommended to read or write the `ref.current` value during the render
    process. This is because the ref value appearing on the screen may not be updated
    for any events by knowing the fact that changing a ref doesn’t trigger re-rendering,
    unlike the state variable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以在渲染方法中访问 ref 的当前值，但不建议在渲染过程中读取或写入 `ref.current` 值。这是因为屏幕上显示的 ref 值可能不会因为知道更改
    ref 不会触发重新渲染而更新，这与状态变量不同。
- en: How do you expose a subset of methods from a ref instance?
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何从 ref 实例中公开方法子集？
- en: The `useImperativeHandle` Hook is used to expose customized methods or only
    a subset of existing methods of a DOM node from a child component to a parent
    component. This is useful to restrict a parent ref to access only certain functions
    or properties without giving access to the entire ref. The common use case is
    creating a component to share it under a library and consumers can access only
    the exposed API.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`useImperativeHandle` 钩子用于从子组件向父组件暴露自定义方法或现有方法的一个子集。这有助于限制父级ref只能访问某些函数或属性，而不提供对整个ref的访问。常见的用例是创建一个组件，以便在库下共享，消费者只能访问暴露的API。'
- en: 'Let’s say you are planning to create a dialog component and want to share some
    basic features of the dialog in some top-level parent component. In this case,
    you can expose `open`, `close`, and `reset` methods inside child component instead
    of giving access to the entire dialog DOM node:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在计划创建一个对话框组件，并想在某个顶级父组件中共享对话框的一些基本功能。在这种情况下，你可以在子组件内部暴露 `open`、`close` 和
    `reset` 方法，而不是提供对整个对话框DOM节点的访问：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The component which uses the `useImperativeHandle` Hook needs to be wrapped
    with forwardRef and the ref received as a second argument from the `forwardRef`
    render function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useImperativeHandle` 钩子的组件需要用 `forwardRef` 包装，并且从 `forwardRef` 渲染函数的第二个参数接收ref。
- en: 'There are a few more built-in Hooks, such as `useId`, `useDeferred`, `useTransition`,
    and `useSyncExternalStore`, that are not covered because of their minimal usage.
    Let’s learn about them quickly:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个内置的钩子，如 `useId`、`useDeferred`、`useTransition` 和 `useSyncExternalStore`，由于它们的使用量很少，所以没有涵盖。让我们快速了解一下它们：
- en: '`useId`: This Hook is used to generate unique IDs for the HTML accessibility
    attributes'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useId`: 这个钩子用于为HTML可访问性属性生成唯一的ID'
- en: '`useDeferred`: This Hook is used to defer updating a part of the UI until the
    latest data is available'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDeferred`: 这个钩子用于将UI的一部分更新推迟到最新数据可用时进行'
- en: '`useTransition`: This Hook is helpful to improve user responsiveness by marking
    some of the state modifications as low-priority'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useTransition`: 这个钩子通过标记一些状态修改为低优先级来帮助提高用户响应性'
- en: '`useSyncExternalStore`: This Hook is used to subscribe to an external data
    store that exists outside the React system'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useSyncExternalStore`: 这个钩子用于订阅存在于React系统之外的外部数据存储'
- en: There are several built-in Hooks provided by React, but you can go beyond the
    usage of these Hooks and use third-party Hooks created by the React community
    to cover specific use cases based on your business needs. In the next section,
    we will cover questions related to third-party Hooks and their respective answers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了几个内置的钩子，但你可以在这些钩子的使用之外，使用React社区创建的第三方钩子来覆盖基于你业务需求的具体用例。在下一节中，我们将涵盖与第三方钩子及其相应答案相关的问题。
- en: Learning about popular third-party Hooks
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解流行的第三方钩子
- en: The Hooks API is quite popular among the developer community, and built-in Hooks
    have existed since 2019\. The developers tried to create many third-party Hooks,
    such as `useImmer`, `useFetch`, `useDebounce`, `useForm`, `useLocalStorage`, Redux
    Hooks, and so on, to solve common use cases observed in web development. If you
    would like to master the Hooks concepts then you should have a good understanding
    of third-party Hooks and how they are useful to solve some common problems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks API在开发者社区中非常受欢迎，内置的钩子自2019年以来一直存在。开发者尝试创建了许多第三方钩子，如 `useImmer`、`useFetch`、`useDebounce`、`useForm`、`useLocalStorage`、Redux
    Hooks等，以解决在Web开发中观察到的常见用例。如果你想要掌握Hooks概念，那么你应该对第三方钩子及其如何解决一些常见问题有一个很好的理解。
- en: What is the useImmer Hook? What is its purpose?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useImmer` 钩子是什么？它的用途是什么？'
- en: The `useImmer` Hook is just like the `useState` Hook but it provides advantages
    while managing the complex state with nested levels of data. It updates the state
    as if it were directly mutable, similar to regular JavaScript. This Hook is based
    on the Immer library by creating a new copy of the state that can be mutated.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`useImmer` 钩子就像 `useState` 钩子一样，但在管理具有嵌层数据的复杂状态时提供了优势。它更新状态的方式就像它是直接可变的，类似于常规JavaScript。这个钩子基于Immer库，通过创建一个新的状态副本来进行修改。'
- en: This Hook can be installed through the `use-immer` npm library. Like `useState`,
    it returns a tuple. The first value of the tuple is the current state, and the
    second is the updater function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子可以通过 `use-immer` npm库安装。像 `useState` 一样，它返回一个元组。元组的第一个值是当前状态，第二个是更新器函数。
- en: 'Let’s see an example of the `UserProfile` component and update the address
    details directly, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`UserProfile`组件的示例，并直接更新地址详情，如下所示：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Under the hood, `Immer` creates a temporary draft object and all the changes
    are applied to it. Once all the mutations are completed, `Immer` will produce
    the next state object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`Immer`创建了一个临时草稿对象，并将所有更改应用于它。一旦所有突变完成，`Immer`将生成下一个状态对象。
- en: If your use case is not fulfilled by built-in Hooks or by any third-party Hook,
    then you can build your own Hook to provide the solution for your needs. After
    the next section, you will be in a position to answer questions related to custom
    Hooks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用例无法由内置钩子或任何第三方钩子满足，那么你可以构建自己的钩子来提供满足你需求的解决方案。在下一节之后，你将能够回答与自定义钩子相关的问题。
- en: Building your own Hooks
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的钩子
- en: Even though React provides some built-in Hooks such as `useState`, `useEffect`,
    `useContext`, and so on for common use cases, you may sometimes need to use Hooks
    for specific requirements that cannot be solved by built-in Hooks or third-party
    libraries. By the end of this section, you will be able to answer questions related
    to custom Hooks and their purpose, and how to avoid traditional approaches to
    share the component logic.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管React为常见用例提供了某些内置钩子，如`useState`、`useEffect`、`useContext`等，但你有时可能需要使用钩子来满足无法由内置钩子或第三方库解决的问题。在本节结束时，你将能够回答与自定义钩子及其目的相关的问题，以及如何避免传统方法来共享组件逻辑。
- en: What are custom Hooks? How do you create them?
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是自定义钩子？你如何创建它们？
- en: React comes with several built-in Hooks, but it won’t restrict you from using
    Hooks for limited scenarios. It is also possible to create your own Hooks by extracting
    the component logic into separate reusable functions known as **custom Hooks**.
    These Hooks are helpful in hiding the complex logic from the components. They
    cover a wide range of use cases such as data fetching, form handling, online or
    offline status subscriptions, connecting to a chat room, animations, and so on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: React自带了几个内置钩子，但它不会限制你在有限场景中使用钩子。你也可以通过将组件逻辑提取到称为**自定义钩子**的单独可重用函数中来创建自己的钩子。这些钩子有助于隐藏组件中的复杂逻辑。它们涵盖了广泛的使用场景，如数据获取、表单处理、在线或离线状态订阅、连接到聊天室、动画等。
- en: The creation of custom Hooks and their usage can be explained in a better way
    with the demonstration of a real-time example. Let’s consider a blogging site
    application where you list all the posts of a particular user and at the same
    time display the comments on a particular post. Here, you need to create two components
    named **Posts** and **Comments**. Both of these components need to fetch the data
    from the server based on a given URL with an optional query parameter. Once the
    response is received, both the components display the data on the screen.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过演示实时示例，可以更好地解释自定义钩子的创建和使用。让我们考虑一个博客网站应用程序，其中你列出特定用户的全部帖子，并同时显示特定帖子的评论。在这里，你需要创建两个名为**Posts**和**Comments**的组件。这两个组件都需要根据给定的URL和可选查询参数从服务器获取数据。一旦收到响应，这两个组件都会在屏幕上显示数据。
- en: 'Instead of having duplicated logic related to data fetching, loading, error
    handling, and so on in both components, the code can be moved to a separate reusable
    custom Hook prefixed with the word `use`. The data fetching Hook can be created
    with the name `useFetchData` inside the `useFetchData.js` file, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在两个组件中都有与数据获取、加载、错误处理等相关逻辑的重复，可以将代码移动到一个以“use”为前缀的单独可重用自定义钩子中。可以在`useFetchData.js`文件中创建名为`useFetchData`的数据获取钩子，如下所示：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Thereafter, the above custom Hook can be used in consumer components created
    as a part of the `Posts.jsx` files and `Comments.jsx`. The usage in the **Posts**
    component would look as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，上述自定义钩子可以在作为`Posts.jsx`文件和`Comments.jsx`文件一部分创建的消费者组件中使用。在**Posts**组件中的使用方式如下：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the same way, you can reuse `useFetchData` in the **Comments** component
    as well. After these changes, the **Posts** and **Comments** components’ code
    became much simpler, more concise, and more readable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以在**Comments**组件中也重用`useFetchData`。在这些更改之后，**Posts**和**Comments**组件的代码变得更加简单、简洁和易于阅读。
- en: What are the benefits of custom Hooks?
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义钩子的好处是什么？
- en: 'The main advantage of using custom Hooks is code reusability without writing
    the duplicated logic in many components. There are a few other advantages as well
    to considering custom Hooks:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义钩子的主要优势是代码的可重用性，无需在许多组件中编写重复的逻辑。还有其他一些优势也值得考虑自定义钩子：
- en: '**Maintainability**: It is easier to maintain code with custom Hooks. In the
    future, if you need to change the logic of the Hook, you only need to change the
    code in one place without disturbing other parts of the code – that is, components
    or files.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：使用自定义钩子更容易维护代码。在未来，如果您需要更改钩子的逻辑，您只需更改一个地方，而不会干扰代码的其他部分——即组件或文件。'
- en: '**Readability**: The application code becomes cleaner and more readable using
    custom Hooks instead of wrapping layers of HOCs, providers and consumers, and
    render props around the actual presentation components shown in the UI. Moreover,
    the component code becomes much cleaner by moving out specific component logic
    into separate Hooks.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：使用自定义钩子而不是在UI中实际展示的组件周围包裹多层HOCs、提供者和消费者以及渲染属性，可以使应用程序的代码变得更加清晰和易于阅读。此外，通过将特定组件逻辑移动到单独的钩子中，组件代码也变得更加简洁。'
- en: '**Testability**: You need to write separate tests for test containers and presentation
    components in React applications. This is challenging especially for integration
    tests if your containers use many HOCs. The complexity increases because you need
    to test the containers and the components together to perform integration tests.
    This issue can be eliminated with custom Hooks as they allow you to combine containers
    and components into a single component.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：在React应用程序中，您需要为测试容器和展示组件编写单独的测试。如果您的容器使用了多个HOCs，那么集成测试尤其具有挑战性。复杂性增加，因为您需要测试容器和组件一起执行集成测试。使用自定义钩子可以消除这个问题，因为它们允许您将容器和组件组合成一个单独的组件。'
- en: Moreover, it is easier to write unit tests and mock Hooks compared to HOCs.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，与HOCs相比，编写单元测试和模拟钩子更容易。
- en: '**Community-driven Hooks**: The React community is already popular and has
    created many Hooks for their specific use cases. The recommended approach is first
    to check whether the Hook you are looking for has already been created by someone
    or not before going to create your own Hook. Some community-driven Hooks are available
    at [https://usehooks.com/](https://usehooks.com/) and [https://github.com/imbhargav5/rooks](https://github.com/imbhargav5/rooks).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区驱动的钩子**：React社区已经非常流行，并为他们的特定用例创建了多个钩子。建议的做法是在创建自己的钩子之前，首先检查您正在寻找的钩子是否已经被其他人创建。一些社区驱动的钩子可以在[https://usehooks.com/](https://usehooks.com/)和[https://github.com/imbhargav5/rooks](https://github.com/imbhargav5/rooks)找到。'
- en: The advantages listed inspire many React developers to create custom Hooks for
    unique features encountered in their React applications. If any third-party open
    source library has already provided the Hook to cover your specific scenario,
    it is suggested to reuse the same Hook instead of reinventing the wheel by building
    a custom Hook.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的优势激励了许多React开发者创建自定义钩子，以应对他们在React应用程序中遇到的独特功能。如果任何第三方开源库已经提供了覆盖您特定场景的钩子，建议重用相同的钩子，而不是通过构建自定义钩子来重新发明轮子。
- en: Should you still consider using render props and HOCs?
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你是否仍然应该考虑使用渲染属性和HOCs？
- en: Both render props and HOCs are traditional advanced patterns used in the React
    ecosystem to share the component state logic between components. However, Hooks
    are somewhat simpler and sufficient to cover use cases compared to these two traditional
    patterns. Moreover, using Hooks, you don’t need to change the existing component
    structure and add more components to end up with a nested tree.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染属性和HOCs都是React生态系统中用于在组件之间共享组件状态逻辑的传统高级模式。然而，与这两种传统模式相比，Hooks要简单得多，并且足以覆盖用例。此外，使用Hooks，您不需要更改现有的组件结构，也不需要添加更多组件，最终得到一个嵌套的树形结构。
- en: Do you recommend moving effects into custom Hooks?
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你推荐将效果移动到自定义钩子中吗？
- en: Effect Hooks are used to perform application side effects when you need to interact
    with the world outside of React’s scope. Some non-React systems can access web
    APIs, invoke external APIs, and so on. Over time, the number of effects in your
    code should be reduced by implementing specific solutions to your use cases. The
    standard guideline is to use effect Hooks when there are no built-in solutions
    available. This is because avoiding the effects makes your application simpler,
    faster to run, and less error-prone. By moving out your effects to custom Hooks,
    it becomes easier to upgrade the code related to effects when there are solutions
    available.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与 React 范围之外的世界交互时，使用 Effect Hooks 来执行应用程序的副作用。一些非 React 系统可以访问 Web API，调用外部
    API 等。随着时间的推移，你应该通过实现针对你用例的特定解决方案来减少代码中的副作用数量。标准指南是在没有内置解决方案可用时使用 effect Hooks。这是因为避免副作用可以使你的应用程序更简单、运行更快、更不容易出错。通过将你的副作用移动到自定义
    Hook 中，当有解决方案可用时，升级与副作用相关的代码变得更加容易。
- en: As your application grows with lots of custom Hooks to fulfill the business
    requirements, the application complexity increases and there is a high chance
    of encountering bugs in the application. The next section addresses how to debug
    React custom Hooks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用程序随着许多自定义 Hook 来满足业务需求而增长，应用程序的复杂性增加，并且有很大可能遇到应用程序中的错误。下一节将介绍如何调试 React
    自定义 Hook。
- en: Troubleshooting and debugging Hooks
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除和调试 Hooks
- en: Traditional debugging methods, such as debuggers with an IDE and browser DevTools,
    are not effective for debugging custom Hooks. React provides the `useDebugValue`
    Hook to allow developers to debug custom Hooks by assigning custom formatted labels
    to them. By the end of this section, you will have an idea about debugging custom
    Hooks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的调试方法，如 IDE 和浏览器 DevTools 中的调试器，对于调试自定义 Hook 并不有效。React 提供了 `useDebugValue`
    Hook，允许开发者通过为它们分配自定义格式化的标签来调试自定义 Hook。在本节结束时，你将了解如何调试自定义 Hook。
- en: How do you debug custom Hooks?
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何调试自定义 Hook？
- en: The `useDebugValue` Hook is used to extend the visualization of data related
    to the internal logic of custom Hooks within **React DevTools**. This information
    appears inside the **Component Inspector** tab of the **React** **DevTools** extension.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`useDebugValue` Hook 用于扩展与自定义 Hook 内部逻辑相关的数据在 **React DevTools** 中的可视化。这些信息出现在
    **React DevTools** 扩展的 **Component Inspector** 选项卡中。'
- en: The current debug information is limited to displaying the information about
    in-built Hooks used inside of our custom Hook. It is hard for developers to read
    the information by counting each line in the output and identifying which entry
    map corresponds to Hooks called inside the code. This difficulty can be rectified
    by adding additional entries to the **React DevTools** output for our custom Hook.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的调试信息仅限于显示我们自定义 Hook 内部使用的内置 Hooks 的信息。对于开发者来说，通过逐行计数输出并识别哪个条目映射对应于代码中调用的
    Hooks 来读取信息是很困难的。这种困难可以通过为我们的自定义 Hook 添加额外的条目到 **React DevTools** 输出中而得到纠正。
- en: 'Let’s understand this in a better way using an example. The required details
    can be logged in various places using the `useDebugValue` Hook inside the custom
    `useFetchData` Hook, as created in the *What are custom Hooks? How do you create*
    *them?* section:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来更好地理解这一点。所需的详细信息可以通过在自定义 `useFetchData` Hook 中的 `useDebugValue` Hook
    中记录，正如在 *什么是自定义 Hook？如何创建它们？* 部分所创建的那样：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, the second and third debug calls use an *optional second
    argument* to format the displayed value.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第二次和第三次调试调用使用了一个可选的第二个参数来格式化显示的值。
- en: '`FetchData` custom Hook. For example, if you hover over the **Posts** component,
    the **Hooks** section on the right side looks as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchData` 自定义 Hook。例如，如果你悬停在 **Posts** 组件上，右侧的 **Hooks** 部分看起来如下：'
- en: '![Figure 3.2: DebugValue label in DevTools](img/Figure_03.02_B18603.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：DevTools 中的 DebugValue 标签](img/Figure_03.02_B18603.jpg)'
- en: 'Figure 3.2: DebugValue label in DevTools'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：DevTools 中的 DebugValue 标签
- en: In the same way, when the API throws an error due to service unavailability,
    the respective root cause can be tracked through the **DebugValue** label.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当 API 由于服务不可用而抛出错误时，可以通过 **DebugValue** 标签追踪相应的根本原因。
- en: So far, we have discussed several questions related to built-in Hooks, followed
    by topics related to third-party Hooks and custom Hooks. All these topics have
    been covered in a specific order to understand the connection between various
    types of Hooks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了与内置 Hooks 相关的几个问题，然后是关于第三方 Hooks 和自定义 Hooks 的主题。所有这些主题都按照特定的顺序进行覆盖，以便理解各种类型
    Hooks 之间的联系。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter offered a thorough understanding of Hooks in React applications.
    We began by providing an introduction to Hooks, which included the motivation
    behind Hooks and rules to be followed when using Hooks. We next looked at state
    management within components using the `useState` and `useReducer` Hooks, and
    global state management to share data across components using the `useContext`
    Hook. Thereafter, we covered how to perform side effects in applications with
    the help of effect Hooks.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全面介绍了 React 应用程序中的 Hooks。我们首先提供了 Hooks 的介绍，包括 Hooks 的动机以及使用 Hooks 时需要遵循的规则。接下来，我们探讨了在组件中使用
    `useState` 和 `useReducer` Hooks 进行状态管理，以及使用 `useContext` Hook 在组件之间共享数据的全局状态管理。此后，我们介绍了如何借助
    effect Hooks 在应用程序中执行副作用。
- en: Apart from the frequently used built-in Hooks, we discussed accessing DOM nodes
    using ref Hooks, doing performance optimizations through Hooks, using third-party
    Hooks, and creating your own custom Hooks for your business needs.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常用的内置 Hooks 之外，我们还讨论了使用 ref Hooks 访问 DOM 节点、通过 Hooks 进行性能优化、使用第三方 Hooks，以及根据业务需求创建自定义
    Hooks。
- en: In the next chapter, we will cover an important navigation library known as
    React Router to navigate from one page to another, and learn about its rich features.
    Another important topic to be discussed in that chapter is supporting internationalization
    and creating dynamic localized messages by passing the arguments.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一个重要的导航库，称为 React Router，用于在页面之间导航，并了解其丰富的功能。那一章还将讨论支持国际化以及通过传递参数创建动态本地化消息的重要主题。
