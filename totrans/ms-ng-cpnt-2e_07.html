<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Components for User Experience</h1>
                </header>
            
            <article>
                
<p>User experience should be a core concern for developers building today's applications. We are no longer living in a world where users are content with an application that simply works. The expectations are now much higher. An application needs to be highly usable, and should provide an efficient workflow; users even expect it to bring them pleasure when performing tasks.</p>
<p>In this chapter, we're going to look at building some components that will increase the overall usability of our task management system. These features will enrich the current functionality and provide more efficient workflows.</p>
<p>We will develop the following two technical features and embed them into our current application, wherever applicable:</p>
<ul>
<li><strong>Tag management</strong>: We'll enable the use of tags within generated content, such as comments, activities, and other areas where they can be of use. Tags will help users build links between content and navigation shortcuts.</li>
<li><strong>Drag and drop</strong>: We'll build generic components that will make the using drag and drop features a breeze. By enabling drag and drop features, we'll allow users to fulfill certain tasks with much higher efficiency.</li>
</ul>
<p>We'll cover the following topics in this chapter:</p>
<ul>
<li>Creating a tag management system to enter and display tags</li>
<li>Creating a stateful pipe to render tags using a service</li>
<li>Creating a component to autocomplete tags during user input</li>
<li><span>Using the </span><kbd>read</kbd><span> property on a </span><kbd>ViewChild</kbd><span> decorator to query for directive instances</span></li>
<li>Going through the basics of the HTML5 drag and drop API</li>
<li>Creating directives for draggable elements and drop targets</li>
<li>Using <kbd>dataTransfer</kbd> objects and a custom attribute to enable selective drop targets</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tag management</h1>
                </header>
            
            <article>
                
<p>The classic form of tagging enables you to establish a taxonomy within a system. It helps you to organize your content. It allows you to have a many-to-many association that can be managed <span>quickly</span>, and you can use it later to filter relevant information.</p>
<p>In our task management system, we're going to use a slightly different version of tags. Our goal is to provide a way to allow semantic shortcuts within the application. With the help of tags, a user should be able to cross-reference information between different parts of the data, providing a summary of the referenced entity, as well as a navigation shortcut.</p>
<p>For example, we can include a project tag within a user comment. A user can enter the tag by simply typing in the project ID. When a comment is displayed, we will see the title of the project, and when we click on the tag, we can directly navigate to the project detail page where the task is located.</p>
<p>In this section, we'll develop the required system of components to provide a way to use project tags to cross-reference other projects within comments. We'll also use tag management in our activities, which we created in the previous chapter, <em>Keeping up with Activities</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A model for our tags</h1>
                </header>
            
            <article>
                
<p>Let's start with a tag model to represent tags within our system. Open up our model module file, located in <kbd>src/app/model.ts</kbd>, and add the following interface:</p>
<pre>export interface Tag {<br/>  type: string;<br/>  hashTag: string;<br/>  title: string;<br/>  link: string;<br/>}</pre>
<p>This interface represents tags; whenever we store tag information, we'll use this interface. Let's look at the individual fields and elaborate on their use:</p>
<ul>
<li><kbd>hashTag</kbd>: This is the text representation of a tag. All of our tags need to be identified uniquely, using this text representation. We can define the text representation of tags as follows:
<ul>
<li>Hashtags always start with a hash symbol (<kbd>#</kbd>).</li>
<li>Hashtags only contain word characters or the minus symbol (<kbd>-</kbd>).</li>
<li>All other details of a tag, defined by the properties <kbd>title</kbd>, <kbd>link</kbd>, and <kbd>type</kbd>, can be somehow derived from the <kbd>hashTag</kbd> property. The hashtag can, therefore, be considered a unique identifier.</li>
</ul>
</li>
<li><kbd>title</kbd>: This is a comparatively longer text representation of a tag. It should contain as much detail about the subject as possible. In the case of project tags, this could mean the project title, open tags count, assignee, and other important information. Since this is the field that will be rendered if a tag is presented to the user, it'll be beneficial if the content stays relatively condensed.</li>
<li><kbd>link</kbd>: A valid URL, which will be used when the tag is rendered. This URL will make links clickable and enable shortcut navigation. In the case of the project tags we're going to create, this will be a URL that will link to the given project view.</li>
<li><kbd>type</kbd>: This is used to distinguish between different tags and provide us with a way to organize tags at a higher granularity level.</li>
</ul>
<p>So far, so good. We now have a data model that we can use to transfer information about tags.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a tags service</h1>
                </header>
            
            <article>
                
<p>The next step for implementing our tagging system is to write a tags service. The service will be responsible for gathering all possible tags within our application. The list of available tags can then be shown to the user within our editor component. That way, the user can add tags to comments and other editable fields within our application. The tags service should also be used to convert text that contains simple hashtags into HTML. That way, tags can be rendered to links, which allow us to navigate to detail views within our application. The responsibilities of our tags service can be divided into two main areas. Let's look at these responsibilities in detail:</p>
<ul>
<li><strong>Providing a list of tags</strong>: For the moment, we only want to enable projects within our tagging system. Therefore, our tagging service needs to create one project tag for every project within our project service. This system will be extensible, and other sources for tags can easily be implemented.</li>
<li><strong>Parsing and rendering tags</strong><span>: The parsing functionality of the tags service is responsible for finding hashtags within an input string. While parsing the input string, the service will check for matching tags, and then</span> use the <kbd>title</kbd> and <kbd>link</kbd> fields of the tag objects to render their HTML representations.</li>
</ul>
<p>Let's use the Angular CLI tool to create the stubs of our new service:</p>
<pre><strong>ng generate service --spec false tags/tags</strong></pre>
<p>Now, let's add the following code as a starting point for our service:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {ProjectService} from '../project/project.service';<br/>import {Project, Tag} from '../model';<br/>import {Observable} from 'rxjs';<br/>import {map} from 'rxjs/operators';<br/>import {limitWithEllipsis} from '../utilities/string-utilities';<br/><br/>@Injectable()<br/>export class TagsService {<br/>  tags: Observable&lt;Tag[]&gt;;<br/><br/>  constructor(private projectService: ProjectService) {<br/>    this.tags = this.projectService.getProjects().pipe(<br/>      map((projects: Project[]) =&gt; projects.map(project =&gt; ({<br/>        type: 'project',<br/>        hashTag: `#project-${project.id}`,<br/>        title: limitWithEllipsis(project.title, 20),<br/>        link: `/projects/${project.id}/tasks`<br/>      })))<br/>    );<br/>  }<br/>}</pre>
<p>The <kbd>tags</kbd> member of our tags service class is an observable,with the generic type <kbd>Tag[]</kbd>. This observable will always emit the most recent list of available tags within our application. Within our constructor, we're using the project list observable from the project service as a base to convert all projects to project tags.</p>
<p>In the case of projects, we set the type of our tag object to<span> </span><kbd>'project'</kbd>. In a later stage of our project, we can also use sources other than projects to generate tags, but for the moment, we're only concerned about projects.</p>
<p><span>For the </span><kbd>hashTag</kbd> property, we're using the prefix <kbd>'#project-</kbd> and appending the ID of the project. That way, our hashtags can be identified as project tags, and by using the appended ID, we can also identify exactly which project is referenced. For the<span> </span><kbd>title</kbd><span> </span>field, we used a helper function,<span> </span><kbd>limitWithEllipsis</kbd>, which truncates project titles that are longer than 20 characters. For the<span> </span><kbd>link</kbd><span> </span>field of the<span> tag object</span>, we specify the URL that will navigate to the project details view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering tags</h1>
                </header>
            
            <article>
                
<p>We now have a service that uses a reactive approach to generate tags from the available projects. This already addresses the first concern of our service. Let's look at its other responsibility, which is parsing text content for tags and rendering HTML.</p>
<p>Before we start writing our parse method in the tags service, we need to create a small utility function for string replacement. Open the file <kbd>src/app/utilities/string-utilities.ts</kbd>, where we have already created our <kbd>limitWithEllipsis</kbd> function, and add the following code:</p>
<pre>export function replaceAll(<br/>  target: string,<br/>  search: string,<br/>  replacement: string): string {<br/>  return target.split(search).join(replacement);<br/>}</pre>
<p>The preceding method uses a small JavaScript trick to replace all occurrences of a string with another string. Unfortunately, that's not possible with the default <kbd>replace</kbd> function on strings.</p>
<p>Let's move on with our tags service. Rendering tags is not a big deal, since we have already abstracted the data model of tags in a clean way. Since tags have URLs that point to a location, we're going to use anchor HTML elements to represent our tags. These elements also have classes that will help us style tags differently than regular content. Let's create another method within the tags service that can be used to parse text, recognize tags within the text content, and render them into HTML. Open up the tags service file located in <kbd>src/app/tags/tags.service.ts</kbd>, and apply the following changes:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {ProjectService} from '../project/project.service';<br/>import {Project, Tag} from '../model';<br/>import {Observable<strong>, of</strong>} from 'rxjs';<br/>import {map} from 'rxjs/operators';<br/>import {limitWithEllipsis<strong>, replaceAll</strong>} from '../utilities/string-utilities';<br/><br/>@Injectable()<br/>export class TagsService {<br/>  tags: Observable&lt;Tag[]&gt;;<br/><br/>  constructor(private projectService: ProjectService) {<br/>    this.tags = this.projectService.getProjects().pipe(<br/>      map((projects: Project[]) =&gt; projects.map(project =&gt; ({<br/>        type: 'project',<br/>        hashTag: `#project-${project.id}`,<br/>        title: limitWithEllipsis(project.title, 20),<br/>        link: `/projects/${project.id}/tasks`<br/>      })))<br/>    );<br/>  }<br/><br/> <strong> parse(textContent: string): Observable&lt;string&gt; {</strong><br/><strong>    const hashTags: string[] = textContent.match(/#[\w\/-]+/g);</strong><br/><strong>    if (!hashTags) {</strong><br/><strong>      return of(textContent);</strong><br/><strong>    }</strong><br/><br/><strong>    return this.tags.pipe(</strong><br/><strong>      map((tags: Tag[]) =&gt; {</strong><br/><strong>        hashTags.forEach(hashTag =&gt; {</strong><br/><strong>          const tag = tags.find(t =&gt; t.hashTag === hashTag);</strong><br/><strong>          if (tag) {</strong><br/><strong>            textContent = replaceAll(</strong><br/><strong>              textContent,</strong><br/><strong>              hashTag,</strong><br/><strong>              `&lt;a class="tag tag-${tag.type}" <br/>              href="${tag.link}"&gt;${tag.title}&lt;/a&gt;`</strong><br/><strong>            );</strong><br/><strong>          }</strong><br/><strong>        });</strong><br/><strong>        return textContent;</strong><br/><strong>      })</strong><br/><strong>    );</strong><br/><strong>  }</strong><br/>}</pre>
<p>Let's quickly recap the preceding changes and look at the <kbd>parse</kbd> method step by step:</p>
<ol>
<li>First, we're searching the text content that was passed into the <kbd>parse</kbd> method for hashtags and storing the list of discovered hashtags into a variable called <kbd>hashTags</kbd>.</li>
<li>If no hashtags have been discovered, we immediately return a new observable stream with the original text content that was passed into the method. We're using the RxJS <kbd>of</kbd> helper to do so.</li>
<li>The next step is to render all discovered hashtags with the corresponding tag objects within our service. We don't store tags directly within our service, but rather, we use an observable stream to convert different sources into tags. We use a <kbd>map</kbd> operator to obtain the list of tags, and then render all discovered hashtags into HTML.</li>
<li>We are using <kbd>Array.prototype.forEach</kbd> to iterate through all discovered hashtags within the initial text content. We are then trying to find a matching tag object within the list of available project tags. We do that by simply comparing the hashtag found within the text to the <kbd>hashTag</kbd> property on our tag objects.</li>
<li>If a matching tag was found, we use our newly created <kbd>replaceAll</kbd> helper function to replace all occurrences of a given hashtag with a rendered HTML version of that tag. <span>We're using the tag object's <kbd>type</kbd>, <kbd>link</kbd>, and <kbd>title</kbd> fields to render an anchor HTML element.</span></li>
<li>After all hashtags have been replaced with the HTML versions of those tags, we're returning the rendered HTML content from the observable mapping function.</li>
</ol>
<p>That's it for our tags service. As a next step, we will create a pipe that will use our service to render tags directly within the view of components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating tags using a pipe</h1>
                </header>
            
            <article>
                
<p>All of the concerns of our task service have now been taken care of, and it is already storing tags for available projects. We can now go ahead and integrate our service into the application.</p>
<p>Since our tags service turns text with simple hashtags into HTML with links, a pipe would be a perfect helper to integrate the functionality within our components.</p>
<p>Let's create a new pipe by using the Angular CLI tool:</p>
<pre><strong>ng generate pipe --spec false pipes/tags</strong></pre>
<p>Open up the generated file, located in <kbd>src/app/pipes/tags.pipe.ts</kbd>, and add the following code:</p>
<pre>import {Pipe, PipeTransform} from '@angular/core';<br/>import {TagsService} from '../tags/tags.service';<br/>import {DomSanitizer} from '@angular/platform-browser';<br/>import {map} from 'rxjs/operators';<br/><br/>@Pipe({<br/>  name: 'tags',<br/>  pure: false<br/>})<br/>export class TagsPipe implements PipeTransform {<br/>  constructor(private tagsService: TagsService,<br/>              private sanitizer: DomSanitizer) {}<br/><br/>  transform(value) {<br/>    if (typeof value !== 'string') {<br/>      return value;<br/>    }<br/>    return this.tagsService.parse(value).pipe(<br/>      map(parsed =&gt; this.sanitizer.bypassSecurityTrustHtml(parsed))<br/>    );<br/>  }<br/>}</pre>
<p>We have already created a few pipes. However, this pipe is a bit different, in that it isn't a pure pipe. Pipes are considered pure if their <kbd>transform</kbd> function always returns the same output for a given input. This implies that the <kbd>transform</kbd> function should not be dependent on any other external source that can influence the outcome of the transform, and the only dependencies are the input values. This is not true for our tags pipe, though. It depends on the tags service to transform the input, and new tags can be stored in the tags service at any time. Successive transformations can successfully render tags that were non-existent just a moment ago.</p>
<p>By telling Angular that our pipe is not pure, we can disable the optimization it performs on pure pipes. This also means that Angular will need to re-validate the output of the pipe on every change detection. This can lead to performance issues; therefore, the pure flag should be used with caution.</p>
<p>Within our pipe, we're injecting the tags service, which helps us to convert simple text into rendered HTML. However, Angular has some security mechanisms preventing us from using this HTML string directly within our template. To ensure Angular that we know what we're doing here, we can use the DOM sanitizer instance to create trusted HTML, which we can then render within <kbd>innerHTML</kbd> bindings. By calling <kbd>bypassSecurityTrustHtml</kbd> on the sanitizer, passing our generated HTML string, we can tell Angular to put aside any security concerns for that instance, and we can go ahead and render the HTML within our view.</p>
<p>Alright; as far as rendering tags is concerned, we are all set. Let's integrate our tags functionality into our editor component so we can make use of them within the commenting system.</p>
<p>All that we really need to do is include the tags pipe within our editor component template. Let's open the editor template located in <kbd>src/app/ui/editor/editor.component.html</kbd>, and apply the following change:</p>
<pre>&lt;div #editableContentElement<br/>     class="editable-content"<br/>     contenteditable="true"&gt;&lt;/div&gt;<br/><strong>&lt;div class="output" [innerHTML]="content ? (content | tags | async) : '-'"&gt;&lt;/div&gt;</strong><br/>&lt;div *ngIf="showControls &amp;&amp; !editMode"<br/>     class="controls"&gt;<br/>  &lt;button (click)="beginEdit()" class="icon-edit"&gt;&lt;/button&gt;<br/>&lt;/div&gt;<br/>&lt;div *ngIf="showControls &amp;&amp; editMode"<br/>     class="controls"&gt;<br/>  &lt;button (click)="saveEdit()" class="icon-save"&gt;&lt;/button&gt;<br/>  &lt;button (click)="cancelEdit()" class="icon-cancel"&gt;&lt;/button&gt;<br/>&lt;/div&gt;<br/> </pre>
<p>The only change that we've made in the template is where we display the editor content. We are using a property binding to the <kbd>innerHTML</kbd> property of our editor's output HTML element. This allows us to render the HTML content generated by our tags service. Since the tags pipe is returning an observable, we need to chain in an async pipe, as well.</p>
<p>Congratulations! Your tagging system is already halfway done! We've created a tags service that collects available tags within the application, and, together with our newly created pipe, renders tags within our editor component. Preview your changes within the browser, and try to add hashtags to some comments on the comments tab of projects. Currently, we only have two projects within our application. Try to add the following hashtag to a comment—<kbd>#project-2</kbd>—and save the changes in the editor. You should now be able to see the rendered tag in the comment. If you're editing the comment again, you'll see the hashtag text representation.</p>
<p>Let's digress for a moment. We've already created a tagging system, and we just integrated it into our editor component by using the tags pipe. If a user writes project tags in any comment, they will now be rendered by the tags service. This is fantastic! Users can now establish cross-links to other projects within comments, which will be automatically rendered as links and show a truncated project title. All a user needs to do is add the text representation of a project tag to a comment.</p>
<p>The following two screenshots illustrate an example of the commenting system. The first screenshot is an example of an editor in edit mode, under the commenting system, where a text tag is entered:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0ec45e75-11b4-4519-b27e-391838c1857a.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An example of when a text tag is entered</div>
<p>The second screenshot is an example of a rendered tag enabled in the commenting system through our editor integration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/48ce0d4d-6eb6-4901-b11b-f3a9dc82813e.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">An example of a rendered tag through editor integration</div>
<p>In this section, we looked at the following<span> </span>concepts:</p>
<ul>
<li>We built a tags service that generates, caches, and renders tags</li>
<li>We built a stateful pipe using the<span> </span><kbd>pure</kbd><span> </span>flag</li>
<li>We used the<span> </span><kbd>[innerHTML]</kbd><span> </span>property binding to render HTML content into an element</li>
<li>We used the DOM sanitizer to bypass security checks when using<span> </span><kbd>innerHTML</kbd><span> </span>bindings</li>
</ul>
<p>We're not done yet, when it comes to entering tags. We cannot expect our users to know all of the available tags within the system and then enter them manually within comments. Let's look at how we can improve this in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supporting tag input</h1>
                </header>
            
            <article>
                
<p>Here, we're going to build a component (and its supporting structures) to make the process of entering tags a smooth experience for our users. So far, they can write project tags, but it requires them to know the project IDs, which makes our tag management quite useless. What we'd like to do is provide the user with some choices when they are about to write a tag. Ideally, we will show them the available tags as soon as they start writing a tag by typing the hash (<kbd><span class="KeyPACKT">#</span></kbd>) symbol.</p>
<p>What sounds simple at first is actually a quite tricky thing to implement. Our tag input needs to deal with the following challenges:</p>
<ul>
<li>Handling input events to monitor tag creation. Somehow, we need to know when a user starts writing a tag, and we need to know when the typed tag name is updated or cancelled by using an invalid tag character.</li>
<li>Calculating the position of the input caret of the user. Yeah, I know this sounds pretty simple, but it actually isn't. Calculating the viewport offset position of a user's input caret requires the use of the browser's Selection API, which is quite low-level and needs some abstraction.</li>
</ul>
<p>In order to tackle these challenges, we are going to introduce a utility directive that we can use to handle those rather complicated low-level user input events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a tag input directive</h1>
                </header>
            
            <article>
                
<p>Since recognizing hashtags within user input is not such a simple task, we're going to create a directive that helps us with that. This is actually our first directive that we're creating together! If you remember from <a href="72fc993e-43db-48eb-8797-c65ea9226b87.xhtml">Chapter 1</a>, <em>Component-Based User Interfaces</em>, directives are there to create custom behaviors without the need for an own view. Our tags input directive will collect and recognize hashtags from user input, but it does not actually render its own view.</p>
<p>Let's add two more interfaces to our model file in <kbd>src/app/model.ts</kbd>, to help us communicate hashtag user input:</p>
<pre>export interface InputPosition {<br/>  top: number;<br/>  left: number;<br/>  caretOffset: number;<br/>}<br/><br/>export interface HashTagInput {<br/>  hashTag: string;<br/>  position: InputPosition;<br/>}</pre>
<p>For every user input that is recognized as hashtag input by our directive, we will communicate using hashtag input objects. Besides the actual text content of the hashtag, we're also sending an input position that consists of the following properties:</p>
<ul>
<li><kbd>top</kbd> and <kbd>left</kbd>: Represent the top and left screen, offset in pixels of the caret position where the actual input happened.</li>
<li><kbd>caretOffset</kbd>: Describes the character offset of the hashtag within the text content of the editable element. This will be useful when we want to replace the hashtag within the editable element and achieve a feeling of autocomplete.</li>
</ul>
<p>From the <kbd>top</kbd> and <kbd>left</kbd> properties of the <kbd>InputPosition</kbd> interface, you can see that we want to compute the coordinates where the actual user input happened. This sounds very trivial, but it actually isn't. To help us with that computation, we're going to introduce a new helper function, which we're creating within a new file, on the path <kbd>src/app/utilities/dom-utilities.ts</kbd>. Create that new file and add the following content:</p>
<pre>import {InputPosition} from '../model';<br/><br/>export function getRangeBoundingClientRect(): InputPosition | null {<br/>  if (window.getSelection) {<br/>    const selection = window.getSelection();<br/>    if (!selection.rangeCount) {<br/>      return null;<br/>    }<br/><br/>    const range = selection.getRangeAt(0);<br/>    const rect = range.getBoundingClientRect();<br/><br/>    if (!range.collapsed) {<br/>      return {<br/>        top: rect.top,<br/>        left: rect.left,<br/>        caretOffset: range.startOffset<br/>      };<br/>    }<br/><br/>    const dummy = document.createElement('span');<br/>    range.insertNode(dummy);<br/>    const pos: InputPosition = {<br/>      top: rect.top,<br/>      left: rect.left,<br/>      caretOffset: range.startOffset<br/>    };<br/>    dummy.parentNode.removeChild(dummy);<br/>    return pos;<br/>  }<br/><br/>  if (document['selection']) {<br/>    return document['selection']<br/>      .createRange()<br/>      .getBoundingClientRect();<br/>  }<br/>}</pre>
<p>Let's not get into too much detail here. What this code basically does is try to find the bounding box <kbd>DOMRect</kbd> object, which describes the <kbd>top</kbd>, <kbd>right</kbd>, <kbd>bottom</kbd>, and <kbd>left</kbd> offsets of the caret position, relative to the viewport. The problem is that the Selection API does not allow us to get the position of the caret directly; it only allows us to get the position of the current selection. If the caret is not placed correctly, we will need to insert a dummy element at the location of the caret and return the bounding box <kbd>DOMRect</kbd> object of the dummy element. Of course, we'll need to remove the dummy element again, before we return the <kbd>DOMRect</kbd> object.</p>
<p>So, that's all that we need to write our tags input directive. Let's use the Angular CLI to create our first directive. The command to create directives is very similar to that to create components:</p>
<pre><strong>ng generate directive --spec false tags/tags-input</strong></pre>
<p>That generated the stub for our new directive. Let's open the file <kbd>src/app/tags/tags-input.directive.ts</kbd>, and add the following code:</p>
<pre>import {Directive, HostListener} from '@angular/core';<br/>import {getRangeBoundingClientRect} from '../utilities/dom-utilities';<br/>import {HashTagInput} from '../model';<br/>import {BehaviorSubject} from 'rxjs';<br/><br/>@Directive({<br/>  selector: '[macTagsInput]'<br/>})<br/>export class TagsInputDirective {<br/>  private hashTagInput: HashTagInput | null = null;<br/>  private hashTagSubject = new BehaviorSubject&lt;HashTagInput&gt;(this.hashTagInput);<br/>  hashTagChange = this.hashTagSubject.asObservable();<br/>}</pre>
<p>The private <kbd>hashTagInput</kbd> property is an internal state to store the current hashtag input information. The <kbd>hashTagSubject</kbd> member is a behavior subject, which we're using internally to publish hashtag input changes. We're using the <kbd>asObservable</kbd> method on the subject to expose an observable stream that emits hashtag input objects on every change. We're storing this derived observable stream in the member <kbd>hashTagChange</kbd>, which has public visibility. Other components can access this property and subscribe to get notified when there are hashtag input events.</p>
<p>Let's now add more parts to our directive, piece by piece. Let's first add a reset method, which we can call when the hashtag input should be reset. This method will be used internally, when an input is aborted, but can also be called from outside, from another component, to abort tag entry:</p>
<pre>reset() {<br/>  this.hashTagInput = null;<br/>  this.hashTagSubject.next(this.hashTagInput);<br/>}</pre>
<p>The next method is used to update the internal hashtag input object, based on user input:</p>
<pre>  private updateHashTag(hashTag, position = this.hashTagInput.position) {<br/>    this.hashTagInput = {hashTag, position};<br/>    this.hashTagSubject.next(this.hashTagInput);<br/>  }</pre>
<p>Now, let's add the two main methods to our tags input directive, to collect user input. We're using the <kbd>HostListener</kbd> decorator to create event bindings on the host element for <kbd>keydown</kbd> and <kbd>keypress</kbd> events:</p>
<pre>updateTextTag(textTag, position = this.position) { <br/>  this.textTag = textTag; <br/>  this.position = position; <br/>} </pre>
<p>The <kbd>keyDown</kbd> method will be called by the host event binding to <kbd>keydown</kbd> events. We are concerned about the backspace, which should also remove the last character of the tag that is currently entered. If we can detect a backspace (char code <kbd>8</kbd>), we're calling our <kbd>updateHashTag</kbd> method, and updating the current hashtag by removing the last character, using the <kbd>Array.prototype.slice</kbd> function:</p>
<pre>@HostListener('keydown', ['$event'])<br/>keyDown(event: KeyboardEvent) {<br/>  if (this.hashTagInput &amp;&amp; event.which === 8) {<br/>    this.updateHashTag(this.hashTagInput.hashTag.slice(0, -1));<br/>  }<br/>}</pre>
<p>The <kbd>keyPress</kbd> method is called from the host element event binding on <kbd>keypress</kbd> events. This is where the main logic of this supporting directive lies. Here, we handle two different cases:</p>
<ul>
<li>If the pressed key is a hash symbol, we will start over with a new tag</li>
<li>If the pressed key is not a valid word character or a hash symbol, we will reset it to its initial state, which will cancel the tag entry</li>
<li>Any other valid character, we'll add to the current text tag string</li>
</ul>
<p>Add the following code to the tags input directive:</p>
<pre>@HostListener('keypress', ['$event'])<br/>keyPress(event: KeyboardEvent) {<br/>  const char = String.fromCharCode(event.which);<br/>  if (char === '#') {<br/>    this.updateHashTag('#', getRangeBoundingClientRect());<br/>  } else if (!/[\w-]/i.test(char)) {<br/>    this.reset();<br/>  } else if (this.hashTagInput) {<br/>    this.updateHashTag(this.hashTagInput.hashTag + char);<br/>  }<br/>}</pre>
<p>When a new hashtag is entered (if a user inserts the hash symbol), we will update the internal hashtag input object and use our utility function, <kbd>getRangeBoundingClientRect</kbd>, to set the input object's position to the current caret position.</p>
<p>Okay; now we have all of the support we need to handle tag input. However, we still need a way to show the available tags in the tags service to the user. For this purpose, we'll create a new tags select component. It will show a list of available tags to the user, and will make use of the tag input changes emitted by our support directive in order to filter and position the list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a tags select component</h1>
                </header>
            
            <article>
                
<p>To support the user in finding the right tag, we'll provide them with a drop-down menu with the available tags. To do this, we need to use the hashtag input objects emitted by our tags input directive. Let's briefly look at the requirements of this component:</p>
<ul>
<li>It should display the available tags gathered from our tags service in a tooltip/callout box</li>
<li>It should support a limitation of displayed tags</li>
<li>It should receive a hashtag input object to filter the available tags and to position itself using the positional data on the hashtag input object</li>
<li>It should emit an event once the user clicks on a tag in the listed tags</li>
<li>The component should hide if the filter is invalid, or if there are no elements matching the filter:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/a8853fa4-31f0-4d42-a5a3-3a51108249f3.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Finished tags select component, filtered with user input</div>
<p>Let's start by updating our application model, located in <kbd>src/app/model.ts</kbd>, to include a new interface to be used to communicate tag selection. Add the following code to the file:</p>
<pre>export interface TagSelection {<br/>  tag: Tag;<br/>  hashTagInput: HashTagInput;<br/>}</pre>
<p>If a tag gets selected, we want to know which tag object was selected, but also, the corresponding hashtag input object should be passed along. This data is required so that we can properly react to the selected tag and correctly update the editable element.</p>
<p>Let's move on with our component, and create the component class. First, let's scaffold a new component using the Angular CLI:</p>
<pre><strong>ng generate component --spec false -cd onpush tags/tags-select</strong></pre>
<p>This will generate a new component, where we'll opening the component class file, located in <kbd>src/app/tags/tags-select/tags-select.component.ts</kbd>, and add the following code:</p>
<pre>import {ChangeDetectionStrategy, Component, EventEmitter, HostBinding, Input, OnChanges, Output} from '@angular/core';<br/>import {HashTagInput, Tag, TagSelection} from '../../model';<br/><br/>const tagListLimit = 4;<br/><br/>@Component({<br/>  selector: 'mac-tags-select',<br/>  templateUrl: './tags-select.component.html',<br/>  styleUrls: ['./tags-select.component.css'],<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TagsSelectComponent implements OnChanges {<br/>  @Input() tags: Tag[];<br/>  @Input() hashTagInput: HashTagInput | null;<br/>  @Output() outSelectTag = new EventEmitter&lt;TagSelection&gt;();<br/><br/>  filteredTags: Tag[];<br/><br/>  filterTags() {<br/>    const filter = this.hashTagInput.hashTag.slice(1).toLowerCase();<br/>    this.filteredTags = this.tags<br/>      .filter(tag =&gt;<br/>        tag.hashTag.toLowerCase().includes(filter) ||<br/>        tag.title.toLowerCase().includes(filter)<br/>      )<br/>      .slice(0, tagListLimit);<br/>  }<br/><br/>  selectTag(tag: Tag) {<br/>    this.outSelectTag.next({<br/>      tag,<br/>      hashTagInput: this.hashTagInput<br/>    });<br/>  }<br/><br/>  ngOnChanges(changes) {<br/>    if ((changes.hashTagInput || changes.tags) &amp;&amp; this.hashTagInput) {<br/>      this.filterTags();<br/>    }<br/>  }<br/>}</pre>
<p>Our component has two input elements. The <kbd>tags</kbd> input is used to pass all available tags into the tags select component. This is the list of tags that will be presented to the user when selecting available tags. The <kbd>hashTagInput</kbd> input is the hashtag input object that we obtain from the tags input directive we create previously. We will extract the current user input from that object in order to filter the displayed tags. We will also use the position data from that object to position the component onto the screen coordinates of the caret position where the user started to write the hashtag input.</p>
<p>The output <kbd>outSelectTag</kbd> is used to emit an event when a user selects a tag from the list of tags. The <kbd>filteredTags</kbd> property is used for the computed filtered list of tags. We're calling the <kbd>filterTags</kbd> method when there's a change in the <kbd>hashTagInput</kbd> or <kbd>tags</kbd> input objects. Here, we're filtering the list of all tags with the current hashtag input data that we have. Since this is only a computed state, our component is still a pure component, and we can still use the <kbd>OnPush</kbd> change detection strategy.</p>
<p>The <kbd>selectTag</kbd> method is called from the view when the user selects a tag from the list of filtered tags. There, we're emitting a new tag selection object that consists of the selected tag, as well as the hashtag input object. </p>
<p>Let's move on and add a few accessor properties to our component, which we're using to create host element style bindings. The following accessor property—<kbd>hasFilteredTags</kbd>—is bound to the host element's display style property. It will control whether the component is displayed or hidden. We will only display the component if the filter is valid and the filtered tags contain at least one tag:</p>
<pre>  @HostBinding('style.display')<br/>  get hasFilteredTags() {<br/>    return this.filteredTags &amp;&amp; this.filteredTags.length &gt; 0 ? 'block' : 'none';<br/>  }</pre>
<p>The following two accessor properties use host bindings to set the <kbd>top</kbd> and <kbd>left</kbd> styles of our host element, based on the <kbd>hashTagInput</kbd> input of the component:</p>
<pre>  @HostBinding('style.top')<br/>  get topPosition() {<br/>    return this.hashTagInput &amp;&amp; this.hashTagInput.position ?<br/>      `${this.hashTagInput.position.top}px` : 0;<br/>  }<br/><br/>  @HostBinding('style.left')<br/>  get leftPosition() {<br/>    return this.hashTagInput &amp;&amp; this.hashTagInput.position ?<br/>      `${this.hashTagInput.position.left}px` : 0;<br/>  }</pre>
<p>The template for our component is rather simple. Let's open the view template that is stored in <kbd>src/app/tags/tags-select/tags-select.component.html</kbd>, and apply the following changes:</p>
<pre>&lt;ul class="list"&gt;<br/>  &lt;li *ngFor="let tag of filteredTags"<br/>      (click)="selectTag(tag)"<br/>      class="item"&gt;{{tag.title}}&lt;/li&gt;<br/>&lt;/ul&gt;</pre>
<p>We used the <kbd>NgFor</kbd> directive to iterate over all of the tags within the <kbd>filteredTags</kbd> member. If a tag is clicked, we will need to execute the <kbd>selectTag</kbd> method and pass the tag of the current iteration. In the listing, we'll only display the tag title that should help the user identify the tag that they would like to use.</p>
<p>Now, we have built all of the pieces that we need to enable smooth tag entering for our users. However, we still need to wire everything together. The next step is to enable tag selection within our project comments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating tag selection within the editor component</h1>
                </header>
            
            <article>
                
<p>As the first step, we should amend our editor component to utilize the tags input directive in conjunction with the tags select component that we just created.</p>
<p>Before we start changing our editor, let's look at a new string helper function,<span> </span><kbd>splice</kbd>, which allows us to pass a specific location within the text, where we want to replace the partial hashtag entered by the user with the final hashtag from the selected tag object.</p>
<p>The<span> </span><kbd>splice</kbd><span> </span>method works similar to the<span> </span><kbd>Array.prototype.splice</kbd><span> </span>function, and allows us to remove a certain part within a string and add a new part to that string, at the same location. This allows us to replace certain areas in strings very specifically, which is exactly what we need in this situation. Let's implement this little helper function within our string utility module, located in <kbd>src/app/utilities/string-utilities.ts</kbd>:</p>
<pre style="font-size: 16px">…<br/>export function splice(<br/>  target: string,<br/>  index: number,<br/>  deleteCount: number,<br/>  content: string): string {<br/>  return target.slice(0, index) +<br/>    content +<br/>    target.slice(index + deleteCount);<br/>}</pre>
<p>Let's go back to our editor component and look at the changes to be made inside of the component template, located in <kbd>src/app/ui/editor/editor.component.html</kbd>. <span>Effective changes in the template are marked in bold:</span></p>
<pre>&lt;div #editableContentElement<br/>     class="editable-content"<br/>     contenteditable="true"<br/><strong>     macTagsInput</strong>&gt;&lt;/div&gt;<br/><strong>&lt;mac-tags-select</strong><br/><strong>  *ngIf="tags &amp;&amp; tagsInput.hashTagChange | async"</strong><br/><strong>  [hashTagInput]="tagsInput.hashTagChange | async"</strong><br/><strong>  [tags]="tags"</strong><br/><strong>  (outSelectTag)="selectTag($event)"&gt;</strong><br/><strong>&lt;/mac-tags-select&gt;</strong><br/>&lt;div class="output" [innerHTML]="content ? (content | tags | async) : '-'"&gt;&lt;/div&gt;<br/>&lt;div *ngIf="showControls &amp;&amp; !editMode"<br/>     class="controls"&gt;<br/>  &lt;button (click)="beginEdit()" class="icon-edit"&gt;&lt;/button&gt;<br/>&lt;/div&gt;<br/>&lt;div *ngIf="showControls &amp;&amp; editMode"<br/>     class="controls"&gt;<br/>  &lt;button (click)="saveEdit()" class="icon-save"&gt;&lt;/button&gt;<br/>  &lt;button (click)="cancelEdit()" class="icon-cancel"&gt;&lt;/button&gt;<br/>&lt;/div&gt;</pre>
<p>The first thing that we need to add is our tags input directive, which will help us to collect input data when a user enters a hashtag within our editable content field.</p>
<p>Just below the editable content element, we're adding our new tags select component. We're only rendering the tags select component if a list of tags was provided to the editor component as input. We're using the extracted hashtag input object from our tags input directive and passing it into the tags select <kbd>hashTagInput</kbd> input. If the tags select component emits a <kbd>outSelectTag</kbd> event, we're calling a new <kbd>selectTag</kbd> method, which we're going to implement on our editor component.</p>
<p>Now, let's apply the necessary changes to our component class, located in <kbd><span>src/app/ui/editor/editor.component.html</span></kbd>. <span>The ellipsis character (<kbd>…</kbd>) indicates code parts that have not changed. Effective changes are marked in bold:</span></p>
<pre>…<br/><strong>import {TagsInputDirective} from '../../tags/tags-input.directive';</strong><br/><strong>import {Tag, TagSelection} from '../../model';</strong><br/><strong>import {splice} from '../../utilities/string-utilities';</strong><br/><br/>@Component({<br/>  selector: 'mac-editor',<br/>  templateUrl: './editor.component.html',<br/>  styleUrls: ['./editor.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class EditorComponent implements OnChanges, AfterViewInit {<br/>  @ViewChild('editableContentElement') editableContentElement: ElementRef;<br/>  <strong>@ViewChild('editableContentElement', {</strong><br/><strong>    read: TagsInputDirective</strong><br/><strong>  }) tagsInput: TagsInputDirective;</strong><br/>  …<br/><br/>  saveEdit() {<br/>    this.editMode = false;<br/>    <strong>this.tagsInput.reset();</strong><br/>    this.outSaveEdit.emit(this.getEditableContent());<br/>  }<br/><br/>  cancelEdit() {<br/>    this.editMode = false;<br/><strong>    this.tagsInput.reset();</strong><br/>    this.setEditableContent(this.content);<br/>    this.outCancelEdit.emit();<br/>  }<br/>  …<br/><br/>  <strong>selectTag(tagSelection: TagSelection) {</strong><br/><strong>    this.setEditableContent(</strong><br/><strong>      splice(</strong><br/><strong>        this.getEditableContent(),</strong><br/><strong>        tagSelection.hashTagInput.position.caretOffset,</strong><br/><strong>        tagSelection.hashTagInput.hashTag.length,</strong><br/><strong>        tagSelection.tag.hashTag</strong><br/><strong>      ));</strong><br/><strong>    this.tagsInput.reset();</strong><br/><strong>  }</strong><br/>}</pre>
<p>First, we're adding another view query for our editable content element, using the view reference <kbd>editableContentElement</kbd>. However, this time, we're using an additional configuration object within the view query decorator. The <kbd>read</kbd> property in the view query option allows us to specify that we don't want to select the default <kbd>ElementRef</kbd> object, but a reference to a component instance or a directive instance that is present on the element. In our case, we want to get a handle on the tags input directive, which we've placed onto the editable content element.</p>
<p>Within the <kbd>saveEdit</kbd> and the <kbd>cancelEdit</kbd> methods of our editor, we can now additionally call the reset method on our tags input directive. This will ensure that we're not persisting any previous tag entry when a user saves or cancels an edit.</p>
<p>Finally, we're adding a new method: <kbd>selectTag</kbd>. This method is called from the editor view, as a reaction to the <kbd>outSelectTag</kbd> event from the tags select component. All we're doing here is replacing the part of the hashtag in our editable content element that was entered by the user with the hashtag that is emitted in the tag selection object. </p>
<p><span>Great stuff! We have completed our work on the tags select component and integrated it, with our tags input directive, into the editor component.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating tag selection in project comments</h1>
                </header>
            
            <article>
                
<p>Since the editor component now relies on a list of available tags to be passed as input, we need to apply some changes to our project comment components.</p>
<p>Let's start with the project comments container component, located in <kbd>src/app/container/project-comments-container/project-comments-container.component.ts</kbd>. The ellipsis character is hiding irrelevant code parts, while effective changes are in bold:</p>
<pre>…<br/>import {Comment, CommentUpdate, Project,<strong> Tag,</strong> User} from '../../model';<br/>…<br/><strong>import {TagsService} from '../../tags/tags.service';</strong><br/><br/>@Component({<br/>  …<br/>})<br/>export class ProjectCommentsContainerComponent {<br/>  …<br/>  <strong>tags: Observable&lt;Tag[]&gt;;</strong><br/><br/>  constructor(private projectService: ProjectService,<br/>              private userService: UserService,<br/>              private route: ActivatedRoute,<br/>              private activitiesService: ActivitiesService<strong>,</strong><br/><strong>              private tagsService: TagsService</strong>) {<br/>    …<br/>    <strong>this.tags = this.tagsService.tags;</strong><br/>  }<br/>  …<br/>}</pre>
<p style="font-size: 16px">Now, let's look at the view template changes within the container component located in <span><kbd>src/app/container/project-comments-container/project-comments-container.component.ts</kbd>:</span></p>
<pre>&lt;mac-comments [user]="user | async"<br/>              [comments]="projectComments | async"<br/>              <strong>[tags]="tags | async"</strong><br/>              (outCreateComment)="createComment($event)"<br/>              (outUpdateComment)="updateComment($event)"&gt;<br/>&lt;/mac-comments&gt;</pre>
<p style="font-size: 16px"><span>That was easy! All we did was get the tags observable from our tags service, subscribe in the view, and pass the resulting tags list down into our comments component.</span></p>
<p>Let's change our comments component to accept that list of tags as input. Open the file <kbd>src/app/comments/comments/comments.component.ts</kbd>, and add the following changes:</p>
<pre>…<br/>import {Comment, CommentUpdate, <strong>Tag, TagSelection,</strong> User} from '../../model';<br/><strong>import {TagsInputDirective} from '../../tags/tags-input.directive';</strong><br/><strong>import {splice} from '../../utilities/string-utilities';</strong><br/><br/>@Component({<br/>  …<br/>})<br/>export class CommentsComponent {<br/>  …<br/>  <strong>@Input() tags: Tag[];</strong><br/><strong>  @ViewChild('commentContentEditable', {</strong><br/><strong>    read: TagsInputDirective</strong><br/><strong>  }) tagsInput: TagsInputDirective;</strong><br/>  …<br/><br/> <strong> selectTag(tagSelection: TagSelection) {</strong><br/><strong>    this.commentContentEditable.nativeElement.textContent =</strong><br/><strong>      splice(</strong><br/><strong>        this.commentContentEditable.nativeElement.textContent,</strong><br/><strong>        tagSelection.hashTagInput.position.caretOffset,</strong><br/><strong>        tagSelection.hashTagInput.hashTag.length,</strong><br/><strong>        tagSelection.tag.hashTag</strong><br/><strong>      );</strong><br/><strong>    this.tagsInput.reset();</strong><br/><strong>  }</strong><br/>}</pre>
<p style="font-size: 16px">Using the same mechanism that we use within our editor, we're also enabling tag selection within the comment editable element. Let's look at the changes within the view template of our comments component, located in <kbd>src/app/comments/comments/comments.component.html</kbd>:</p>
<pre>&lt;div class="title"&gt;Add new comment&lt;/div&gt;<br/>&lt;div class="add-comment-section"&gt;<br/>  &lt;div #commentContentEditable<br/>       class="add-comment-box"<br/>       contenteditable="true"<br/>      <strong> macTagsInput</strong>&gt;<br/>  &lt;/div&gt;<br/><strong>  &lt;mac-tags-select</strong><br/><strong>    *ngIf="tags &amp;&amp; tagsInput.hashTagChange | async"</strong><br/><strong>    [hashTagInput]="tagsInput.hashTagChange | async"</strong><br/><strong>    [tags]="tags"</strong><br/><strong>    (outSelectTag)="selectTag($event)"&gt;</strong><br/><strong>  &lt;/mac-tags-select&gt;</strong><br/>  &lt;button (click)="createComment()"<br/>          class="button" &gt;Add comment&lt;/button&gt;<br/>&lt;/div&gt;<br/><br/>&lt;ng-container *ngIf="comments.length &gt; 0"&gt;<br/>  &lt;div class="title"&gt;All comments&lt;/div&gt;<br/>  &lt;mac-comment *ngFor="let comment of comments; let index = index"<br/>               [comment]="comment"<br/>               [user]="user"<br/>             <strong>  [tags]="tags"</strong><br/>               (outUpdateComment)="updateComment(index, $event)"&gt;<br/>  &lt;/mac-comment&gt;<br/>&lt;/ng-container&gt;</pre>
<p style="font-size: 16px">Besides implementing our own tag selection for the comments editable content element, we're also passing the tags, which we've received from our parent container component, down into each comment component as input.</p>
<p>Let's continue and complete the integration of our tagging system. Open up the comment component class, located in <kbd>src/app/comments/comment/comment.component.ts</kbd>, and apply the following changes:</p>
<pre>…<br/>import {Comment, <strong>Tag,</strong> User} from '../../model';<br/><br/>@Component({<br/>  …<br/>})<br/>export class CommentComponent {<br/>  …<br/>  <strong>@Input() tags: Tag[];</strong><br/>  …<br/>}</pre>
<p>All we needed to add was an additional input, to receive our tag list. Let's also reflect the necessary changes to our comment component view template, located in <kbd>src/app/comments/comment/comment.component.html</kbd>:</p>
<pre>…<br/>&lt;div class="main"&gt;<br/>  &lt;div class="content"&gt;<br/>    &lt;mac-editor [content]="comment.content"<br/>                [showControls]="comment.user.id === user.id"<br/>                <strong>[tags]="tags"</strong><br/>                (outSaveEdit)="updateComment($event)"&gt;<br/>    &lt;/mac-editor&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p style="font-size: 16px">Alright! There were quite a few changes for integration. However, they were pretty simple changes, and now we're ready to use our tagging system!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finishing up our tagging system</h1>
                </header>
            
            <article>
                
<p>Congratulations! You've now successfully implemented the first of the three usability components.</p>
<p>With the help of a tag input directive, we have hidden the low-level programming of user input and the processing of the user caret position. Then, we created a component to display the available tags to the user, and provided a way for them to select a tag by clicking on it. In our editor component, we used the tags input directive, together with the tags select component, to enable the smooth entering of tags when editing comments.</p>
<p>We've covered the following concepts in this section:</p>
<ul>
<li>We processed complex user input within a designated directive, to offload logic from our components</li>
<li>We used host bindings to set positional style attributes</li>
<li>We used the <kbd>read</kbd> property on a <kbd>ViewChild</kbd> decorator, to query for directive instances</li>
<li>We implemented fully reactive components that rely on observables and don't create side effects during change detection</li>
</ul>
<p>In the next section, we're going to look at how we can integrate drag and drop functionality within our application. We will build Angular directives, which will help us to easily integrate drag and drop capabilities into any area of our task management application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drag and drop</h1>
                </header>
            
            <article>
                
<p>We have learned to use our computer mouse and keyboard with great efficiency. Using keyboard shortcuts, different click actions, and contextual mouse menus, can provide us with support for performing tasks. However, there is one pattern that has gained more attention in applications lately, given the current mobile and touch device hype. Drag and drop actions are a very intuitive and logical way to express actions, such as moving or copying items. One particular task, performed on user interfaces, benefits from drag and drop: ordering items within a list. If we need to order items via action menus, it gets very confusing. Moving items step-by-step, using the up and down buttons, works great, but it takes a lot of time. If you can drag items around and drop them in a place where you'd like them to be reordered, you can sort a list of items extremely quickly.</p>
<p>In this topic, we will build the required elements to enable drag and drop within our application. We will use the drag and drop feature to enable users to reorder their task lists. By developing reusable directives to provide this functionality, we can later enable the feature at any spot within our application.</p>
<p>To implement our directives, we will make use of the HTML5 drag and drop API, which is supported in all of the major browsers at the time of writing this book.</p>
<p>Since we would like to reuse our drag and drop behavior on multiple components, we will use directives for the implementation. We are going to create two directives in this section:</p>
<ul>
<li><strong>Draggable directive</strong>: This directive should be attached to components, which should be enabled for dragging</li>
<li><strong>Draggable drop zone directive</strong>: This directive should be attached to components that will act as drop targets</li>
</ul>
<p>We'll also implement a feature wherein we can be selective about what can be dragged where. For this, we will use a type attribute on our draggable directives, as well as an accepted type attribute on our drop zones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating our model for ordering tasks</h1>
                </header>
            
            <article>
                
<p>As a first step, we should enable our task model for ordering. By introducing an <kbd>order</kbd> field on our task object, we can then use that field to sort tasks accordingly. Let's make the following changes to our model file, located in <kbd>src/app/model.ts</kbd>:</p>
<pre>export interface Task {<br/>  readonly id?: number;<br/>  readonly projectId?: number;<br/>  readonly title: string;<br/>  readonly done: boolean;<br/>  <strong>readonly order: number;</strong><br/>}<br/>…<br/><br/><strong>export type DraggableType = 'task';</strong></pre>
<p>We have also added a new type alias, <kbd>DraggableType</kbd>, which we're using to identify things that can be dragged within our application. We will use this type to make sure that we can only drag and drop to locations that support the given type.</p>
<p>Since we have changed the model for our tasks to include an <kbd>order</kbd> property, we will need to make some changes to our existing application state management, in order to work with the <kbd>order</kbd> property.</p>
<p>Let's first change our in-memory database, and open the file <kbd>src/app/database.ts</kbd> to apply the following changes:</p>
<pre>…<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    …<br/><br/>    const tasks: Task[] = [<br/>      {id: 1, projectId: 1, title: 'Task 1', done: false<strong>, order: 1</strong>},<br/>      {id: 2, projectId: 1, title: 'Task 2', done: false<strong>, order: 2</strong>},<br/>      {id: 3, projectId: 1, title: 'Task 3', done: true<strong>, order: 3</strong>},<br/>      {id: 4, projectId: 1, title: 'Task 4', done: false<strong>, order: 4</strong>}<br/>    ];<br/><br/>    …<br/>  }<br/>}</pre>
<p>Now, all of our initial tasks contain an <kbd>order</kbd> property. Now, we need to take care of two additional things:</p>
<ul>
<li>When new tasks get created, we need to compute the next available order value and use it to create a new task</li>
<li>We need to change our task list to use the <kbd>order</kbd> property for sorting</li>
</ul>
<p>We can implement both of these changes within our task list container component. Let's open the file <kbd>src/app/container/task-list-container/task-list-container.component.ts</kbd>, and apply some changes. Irrelevant code parts are hidden using the ellipsis character, while the effective changes are marked in bold:</p>
<pre>…<br/><br/>@Component({<br/>  selector: 'mac-task-list-container',<br/>  templateUrl: './task-list-container.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListContainerComponent {<br/>  …<br/><br/>  constructor(private taskService: TaskService,<br/>              private projectService: ProjectService,<br/>              private route: ActivatedRoute,<br/>              private activitiesService: ActivitiesService) {<br/>    …<br/><br/>    this.tasks = this.selectedProject.pipe(<br/>      switchMap((project) =&gt; this.taskService.getProjectTasks(project.id))<strong>,</strong><br/><strong>      map(tasks =&gt; tasks.sort((a: Task, b: Task) =&gt; b.order - a.order))</strong><br/>    );<br/><br/>    …<br/>  }<br/><br/>  …<br/><br/>  addTask(title: string) {<br/>    <strong>combineLatest(this.selectedProject, this.tasks)</strong><br/>      .pipe(<br/>        take(1)<br/>      )<br/>      .subscribe(<strong>([project, tasks])</strong> =&gt; {<br/>        <strong>const position = tasks.reduce(</strong><br/><strong>          (max, t: Task) =&gt; t.order &gt; max ? t.order : max, 0</strong><br/><strong>        ) + 1;</strong><br/>        const task: Task = {<br/>          projectId: project.id, title, done: false<strong>, order: position</strong><br/>        };<br/>        this.taskService.addTask(task);<br/>        this.activitiesService.logProjectActivity(<br/>          project.id,<br/>          'tasks',<br/>          'A task was added',<br/>          `A new task "${limitWithEllipsis(title, 30)}" was added to <br/>         #project-${project.id}.`<br/>        );<br/>      });<br/>  }<br/><br/>  …<br/>}</pre>
<p>Alright; that's it, for now. We've successfully introduced a new <kbd>order</kbd> property, which is now used to sort our task list. This order becomes very important when we want to use our drag and drop feature to sort the task list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the draggable directive</h1>
                </header>
            
            <article>
                
<p>The <kbd>draggable</kbd> directive will be attached to the elements that we want to enable for drag and drop. Let's get started by creating a new directive using the Angular CLI tool:</p>
<pre><strong>ng generate directive --spec false draggable/draggable</strong></pre>
<p>Let's open the directive class file, located in <kbd>src/app/draggable/draggable.directive.ts</kbd>, and add the following code:</p>
<pre>import {Directive, HostBinding, HostListener, Input} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggable]'<br/>})<br/>export class DraggableDirective {<br/>  @HostBinding('draggable') draggable = 'true';<br/>  @Input() draggableData: any;<br/>  @Input() draggableType: DraggableType;<br/>  @HostBinding('class.dragging') dragging = false;<br/>}</pre>
<p>By setting the HTML attribute <kbd>draggable</kbd> to <kbd>true</kbd>, using a host binding, we tell the browser that we're considering this element a draggable element. This HTML attribute is already part of the drag and drop API of the browser.</p>
<p>The <kbd>draggableData</kbd> input is used to specify the data that represents the element that can be dragged. This data will be serialized to JSON and transferred to our drop zones once a drag action is completed.</p>
<p>By specifying a draggable type using the <kbd>draggableType</kbd> input, which we have introduced to our model, we can be more selective when the element is dragged over a drop zone. Within the drop zone, we can include a counterpart that controls what types are acceptable to be dropped.</p>
<p><span>Additionally, we can use a host binding to set a class, called </span><kbd>dragging</kbd><span>, which will apply some special styles that will make it easy to recognize that an element is dragged.</span></p>
<p>Now, we need to handle two events within our directive, to implement the behavior of a draggable element. The following DOM events are triggered by the drag and drop DOM API:</p>
<ul>
<li><kbd>dragstart</kbd>: This event is emitted on elements that are grabbed and moved across the screen</li>
<li><kbd>dragend</kbd>: If the previously initiated dragging of the element is ended, because of a successful drop or a release outside of a valid drop target, this DOM event will be triggered</li>
</ul>
<p>Let's use the <kbd>HostListener</kbd> decorator to implement the logic for the <kbd>dragstart</kbd> event:</p>
<pre>import {Directive, HostBinding, HostListener, Input} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggable]'<br/>})<br/>export class DraggableDirective {<br/>  @HostBinding('draggable') draggable = 'true';<br/>  @Input() draggableData: any;<br/>  @Input() draggableType: DraggableType;<br/>  @HostBinding('class.dragging') dragging = false;<br/><br/><strong>  @HostListener('dragstart', ['$event'])</strong><br/><strong>  dragStart(event) {</strong><br/><strong>    event.dataTransfer.effectAllowed = 'move';</strong><br/><strong>    event.dataTransfer.setData('application/json', JSON.stringify(this.draggableData));</strong><br/><strong>    event.dataTransfer.setData(`draggable-type:${this.draggableType}`, '');</strong><br/><strong>    this.dragging = true;</strong><br/><strong>  }</strong><br/>}</pre>
<p>Now, let's discuss the different actions that we can perform in the implementation of our host listener.</p>
<p>We will need to access the DOM event object in our host listener. If we were to create this binding within the template, we would probably need to write something similar to this: <kbd>(dragstart)="dragStart($event)"</kbd>. Within event bindings, we can make use of the synthetic variable <kbd>$event</kbd>, which is a reference to the event that would have triggered the event binding. If we are creating an event binding on our host element using the <kbd>HostListener</kbd> decorator, we need to construct the parameter list for the binding by using the second argument of the decorator.</p>
<p>The first action in our event listener is to set the desired <kbd>effectAllowed</kbd> property on the data transfer object. Currently, we only support the <kbd>move</kbd> effect, as our main concern is to reorder tasks within the task list using drag and drop. The drag and drop API is very system-specific, but usually, there are different drag effects if a user holds a modifier key (such as <em><span class="KeyPACKT">Ctrl</span></em> or <em><span class="KeyPACKT">Shift</span></em>) while initiating the dragging. Within our <kbd>draggable</kbd> directive, we can force the <kbd>move</kbd> effect for all drag actions.</p>
<p>In the next code snippet, we set the data that should be transferred by dragging. It's important to understand the core purpose of the drag and drop API. It not only provides a way to implement drag and drop for elements in your DOM, but it also supports the dragging of files and other objects into your browser. Because of this, the API undergoes some constraints, one of which is making it impossible to transfer data, other than simple string values. In order for us to transfer complex objects, we will serialize the data from the <kbd>draggableData</kbd> input, using <kbd>JSON.stringify</kbd>.</p>
<p>Another limitation caused by some security constraints within the API is that data can only be read after a successful drop. This means that we cannot inspect the data if the user is just hovering over an element. However, we need to know some facts about the data when hovering over drop zones. We need to know the type of draggable element when entering a drop zone. This way we can control that certain draggable elements can only be dropped in specific drop zones. We're using a small workaround for this issue. The drag and drop API hides the data when we drag data over a drop target. However, it tells us what type of data it is. Knowing this fact, we can use the <kbd>setData</kbd> function to encode our draggable type. Accessing the data keys only is considered secure, and can therefore be done in all drop zone events.</p>
<p>Finally, we'll set the dragging flag to <kbd>true</kbd>, which will cause the class binding to re-validate and add the <kbd>dragging</kbd> class to the element.</p>
<p>After dealing with the <kbd>dragstart</kbd> event, we now need to handle the <kbd>dragend</kbd> event, to complete our draggable directive. The only thing we do within the <kbd>dragEnd</kbd> method that is bound to the <kbd>dragend</kbd> event is set the dragging member to false. This will cause the <kbd>dragging</kbd> class to be removed from the host element:</p>
<pre>import {Directive, HostBinding, HostListener, Input} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggable]'<br/>})<br/>export class DraggableDirective {<br/>  …<br/><br/><strong>  @HostListener('dragend')</strong><br/><strong>  onDragEnd() {</strong><br/><strong>    this.dragging = false;</strong><br/><strong>  }</strong><br/>}<br/> </pre>
<p>That's it for the behavior of our draggable directive. Now, we need to create its counterpart directive, to provide the behavior of a drop zone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing a drop target directive</h1>
                </header>
            
            <article>
                
<p>Drop zones will act as containers where draggable elements can be dropped. For this, we'll create a new draggable drop zone directive. Let's use the Angular CLI to create the directive:</p>
<pre><strong>ng generate directive --spec false draggable/draggable-drop-zone</strong></pre>
<p>Let's open the directive file, located in <kbd>src/app/draggable/draggable-drop-zone.directive.ts</kbd>, and add the following code:</p>
<pre>import {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggableDropZone]'<br/>})<br/>export class DraggableDropZoneDirective {<br/>  @Input() dropAcceptType: DraggableType;<br/>  @Output() outDropDraggable = new EventEmitter&lt;any&gt;();<br/>  @HostBinding('class.over') over = false;<br/><br/>  dragEnterCount = 0;<br/>}</pre>
<p>Using the <kbd>dropAcceptType</kbd> input, we can specify what types of draggable elements we accept in this drop zone. This will help the users identify whether they are able to drop off the draggable elements, when approaching the drop zone.</p>
<p>Upon successful drops into the drop zone, we will need to emit an event, so that the components using our drag and drop functionality can react accordingly. For that purpose, we will use the <kbd>dropDraggable</kbd> output property.</p>
<p>The <kbd>over</kbd> member field will store the state if an accepted element is in the process of being dragged over the drop zone. We are using a host binding to set the class <kbd>over</kbd> on our host element. That way, a drop zone element can be styled differently when we are about to drop an item onto it.</p>
<p>Now, let's add a method to check whether our drop zone should accept any given drag and drop event by checking against our <kbd>dropAcceptType</kbd> member. Remember the security problems that we needed to work around when creating the draggable directive? Now, we're implementing the counterpart, to extract the draggable type from the drag event and check whether the dragged item is supported by this drop zone:</p>
<pre>import {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggableDropZone]'<br/>})<br/>export class DraggableDropZoneDirective {<br/>  @Input() dropAcceptType: DraggableType;<br/>  @Output() outDropDraggable = new EventEmitter&lt;any&gt;();<br/>  @HostBinding('class.over') over = false;<br/><br/>  dragEnterCount = 0;<br/><br/><strong>  private typeIsAccepted(event: DragEvent) {</strong><br/><strong>    const draggableType = Array.from(event.dataTransfer.types).find((key) =&gt;</strong><br/><strong>      key.indexOf('draggable-type') === 0);</strong><br/><strong>    return draggableType &amp;&amp; draggableType.split(':')[1] === this.dropAcceptType;</strong><br/><strong>  }</strong><br/>}</pre>
<p>We can only read the keys of the data within data transfer objects for drag events, where the data itself is hidden until a successful <kbd>drop</kbd> event has occurred. To bypass this security limitation, we've encoded the draggable type information into a data key itself. Since we can list all of the data keys safely by using the <kbd>types</kbd> field on data transfer objects, it's not too hard to extract the encoded draggable type information. We search for a data type key that starts with <kbd>'draggable-type'</kbd>, and then split it by the column character. The value after the column character is our type information, which we can then compare against the <kbd>dropAcceptType</kbd> directive input property.</p>
<p>We will use two events to determine whether a draggable element is moved to our drop zone:</p>
<ul>
<li><kbd>dragenter</kbd>: This event is fired by an element if another element is dragged over it</li>
<li><kbd>dragleave</kbd>: This event is fired by an element if the previously entered element has left again</li>
</ul>
<p>There's one problem with the preceding events, which is that they actually bubble, and we will receive a <kbd>dragleave</kbd> event if the dragged element is moved to a child element within our drop zone. Because of the bubbling, we will then also receive <kbd>dragenter</kbd> and <kbd>dragleave</kbd> events from the child elements. This is not desired, in our case, and we need to build some functionality to improve this behavior. We make use of a counter member field, <kbd>dragEnterCount</kbd>, which counts up on all <kbd>dragenter</kbd> events and counts down on <kbd>dragleave</kbd> events. This way, we can now say that only on <kbd>dragleave</kbd> events, where the counter becomes zero, the users' mouse cursor will leave the drop zone. Let's look at the following diagram, which illustrates the problem:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f85d34b2-94fa-40ac-adc4-ad749352a14e.png" style=""/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Visualization of important variables and functions for our calculations</div>
<p>Let's implement this logic to build a proper behavior for <kbd>dragenter</kbd> and <kbd>dragleave</kbd> events within our drop zone:</p>
<pre>import {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggableDropZone]'<br/>})<br/>export class DraggableDropZoneDirective {<br/>  @Input() dropAcceptType: DraggableType;<br/>  @Output() outDropDraggable = new EventEmitter&lt;any&gt;();<br/>  @HostBinding('class.over') over = false;<br/><br/>  dragEnterCount = 0;<br/><br/>  private typeIsAccepted(event: DragEvent) {<br/>    const draggableType = Array.from(event.dataTransfer.types).find((key) =&gt;<br/>      key.indexOf('draggable-type') === 0);<br/>    return draggableType &amp;&amp; draggableType.split(':')[1] === this.dropAcceptType;<br/>  }<br/><br/> <strong> @HostListener('dragenter', ['$event'])</strong><br/><strong>  dragEnter(event: DragEvent) {</strong><br/><strong>    if (this.typeIsAccepted(event)) {</strong><br/><strong>      this.over = true;</strong><br/><strong>      this.dragEnterCount++;</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><br/><strong>  @HostListener('dragleave', ['$event'])</strong><br/><strong>  dragLeave(event: DragEvent) {</strong><br/><strong>    if (this.typeIsAccepted(event) &amp;&amp; --this.dragEnterCount === 0) {</strong><br/><strong>      this.over = false;</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/>}</pre>
<p>Within both of the events, we first check whether the event is carrying a data transfer object, of which we accept the type. After validating the type using our <kbd>typeIsAccepted</kbd> method, we deal with the counter, and set the <kbd>over</kbd> member field, if required.</p>
<p>We need to handle another event, which is important for drag and drop functionality. The <kbd>dragover</kbd> event helps us to set the accepted <kbd>dropEffect</kbd> of the current dragging action. This will tell our browser that the initiated dragging action from our draggable is suitable for this drop zone. It's also important that we prevent the default browser behavior, so that there's no default browser behavior in the way of our custom drag and drop implementation. Let's add another host listener to cover those concerns:</p>
<pre>import {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggableDropZone]'<br/>})<br/>export class DraggableDropZoneDirective {<br/>  …<br/><br/><strong>  @HostListener('dragover', ['$event'])</strong><br/><strong>  dragOver(event: DragEvent) {</strong><br/><strong>    if (this.typeIsAccepted(event)) {</strong><br/><strong>      event.preventDefault();</strong><br/><strong>      event.dataTransfer.dropEffect = 'move';</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/>}</pre>
<p>Finally, we need to handle the most important event in the drop zone, which is the <kbd>drop</kbd> event that is triggered if a user drops a draggable item into our drop zone:</p>
<pre>import {Directive, EventEmitter, HostBinding, HostListener, Input, Output} from '@angular/core';<br/>import {DraggableType} from '../model';<br/><br/>@Directive({<br/>  selector: '[macDraggableDropZone]'<br/>})<br/>export class DraggableDropZoneDirective {<br/>  …<br/><br/>  @HostListener('dragover', ['$event'])<br/>  dragOver(event: DragEvent) {<br/>    if (this.typeIsAccepted(event)) {<br/>      event.preventDefault();<br/>      event.dataTransfer.dropEffect = 'move';<br/>    }<br/>  }<strong><br/></strong><br/>  <strong>@HostListener('drop', ['$event'])</strong><br/><strong>  drop(event: DragEvent) {</strong><br/><strong>    if (this.typeIsAccepted(event)) {</strong><br/><strong>      const data = JSON.parse(event.dataTransfer.getData('application/json'));</strong><br/><strong>      this.over = false;</strong><br/><strong>      this.dragEnterCount = 0;</strong><br/><strong>      this.outDropDraggable.next(data);</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/>}</pre>
<p>After checking whether the dropped element is of an accepted type, we can go ahead and read the data transfer object data from the event. This data was previously set by the draggable directive, and needs to be deserialized, using <kbd>JSON.parse</kbd>.</p>
<p>Since the drop was successful, we can reset our <kbd>dragEnterCount</kbd> member and set the <kbd>over</kbd> flag to <kbd>false</kbd>.</p>
<p>Finally, we will emit the deserialized data from the draggable element using our <kbd>outDropDraggable</kbd> output property.</p>
<p>That's all we need to build a highly reusable drag and drop behavior. We can now attach the draggable and the draggable drop zone to any components within our application where we feel the need to enable drag and drop.</p>
<p>In the next section, we're going to integrate the drag and drop functionality within our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating drag and drop</h1>
                </header>
            
            <article>
                
<p>We can now use the draggable and draggable drop zone directives in our task list component, so that we can enable the reordering of tasks using drag and drop.</p>
<p>We can do this by attaching both of the directives to the task elements within the task list component template. Yeah, that's right! We want to make our task components draggable, but also a drop zone at the same time. That way, we can drop tasks onto other tasks, and that gives us the foundation for reordering. What we will do is reorder the list on a drop, so that the dropped task will be squeezed into the position right before the task where it was dropped.</p>
<p>First, let's apply the drag and drop directives to the task host elements in the task list component template. Open the file <kbd>src/app/tasks/task-list/task-list.component.html</kbd>, and apply the following changes:</p>
<pre>&lt;mac-toggle [buttonList]="taskFilterTypes"<br/>            [activeButton]="activeTaskFilterType"<br/>            (outActivate)="activateFilterType($event)"&gt;<br/>&lt;/mac-toggle&gt;<br/>&lt;mac-enter-task (outEnterTask)="addTask($event)"&gt;&lt;/mac-enter-task&gt;<br/>&lt;div class="tasks"&gt;<br/>  &lt;mac-task *ngFor="let task of tasks"<br/>            [task]="task"<br/>            (outUpdateTask)="updateTask($event)"<br/>            <strong>macDraggable</strong><br/><strong>            draggableType="task"</strong><br/><strong>            [draggableData]="task"</strong><br/><strong>            macDraggableDropZone</strong><br/><strong>            dropAcceptType="task"</strong><br/><strong>            (outDropDraggable)="dropTask(task, $event)"</strong>&gt;&lt;/mac-task&gt;<br/>&lt;/div&gt;</pre>
<p>Alright; using the preceding attributes, we made our tasks not only draggable, but also drop zones at the same time. By specifying both <kbd>draggableType</kbd> and <kbd>dropAcceptType</kbd> to the <kbd>'task'</kbd> string, we are telling our drag and drop behavior that these task elements can be dropped into other task elements. Our draggable drop zone directive is set to emit an <kbd>outDropDraggable</kbd> event whenever a valid draggable is dropped off. On a successful drop, we will call a new method within our task list component <kbd>dropTask</kbd>, to which we will pass the current task and the drop zone event object. The draggable drop zone directive will emit the data that was previously set using the <kbd>draggableData</kbd> input of the draggable directive. In other words, the <kbd>dropTask</kbd> method is called with the target task as the first parameter and the source task as the second parameter.</p>
<p>Let's implement the <kbd>dropTask</kbd> method within our component class, located in <kbd>src/app/tasks/task-list/task-list.component.ts</kbd>:</p>
<pre>…<br/><br/>@Component({<br/>  selector: 'mac-task-list',<br/>  templateUrl: './task-list.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListComponent {<br/>  …<br/><br/> <strong> dropTask(target: Task, source: Task) {</strong><br/><strong>    if (target.id === source.id) {</strong><br/><strong>      return;</strong><br/><strong>    }</strong><br/><br/><strong>    this.outUpdateTask.emit({</strong><br/><strong>      ...target,</strong><br/><strong>      order: source.order</strong><br/><strong>    });</strong><br/><strong>    this.outUpdateTask.emit({</strong><br/><strong>      ...source,</strong><br/><strong>      order: target.order</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}</pre>
<p>Let's elaborate on the implementation within our task list component:</p>
<ol>
<li>If you check the template again, you will see that we bound to the <kbd>dropTask</kbd> method with the following expression: <kbd>(outDropDraggable)="dropTask(task, $event)"</kbd>. Since the drop zone emitted an event with deserialized data that was bound using the draggable input property <kbd>draggableData</kbd>, we can safely assume that we will receive a copy of the task that was dropped into the drop zone. As the first parameter to our binding, we added the local view variable <kbd>task</kbd>, which is actually the task that acts as the drop zone. Therefore, we can say that the first parameter of our <kbd>dropTask</kbd> method represents the target, while the second represents the source task.</li>
<li>As a first check in our method, we compare the source ID with the target ID, and if they match, we can assume that the task was dropped to itself, and we don't need to perform any further actions.</li>
<li>Now, all we do is emit two update task events from our task list component, to reorder both the source and target task. We do that by switching the order property between the source and target. This is just one way to reorder, and we can also implement this differently.</li>
</ol>
<p>How great is that? We have successfully implemented drag and drop on our task list, to provide a very useful feature to reorder tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recapitulate on drag and drop</h1>
                </header>
            
            <article>
                
<p>With the use of the low-level drag and drop API, using events and data transfer objects, we have implemented two directives that can now be used to execute smooth drag and drop functionality within our application, wherever we desire.</p>
<p>With almost no effort, we have implemented our drag and drop behavior on the task list, to provide a nice feature to reorder the tasks within the list. The only thing that we needed to do, besides hooking up the directives, was implement a method where we could reorder the tasks based on the information from the draggable drop zone directive output.</p>
<p>We worked with the following concepts in this section:</p>
<ul>
<li>We learned the basics of the HTML5 drag and drop API</li>
<li>We used the data transfer object to securely transfer data within drag and drop events</li>
<li>We built reusable behavior patterns, using directives</li>
<li>We enriched the standard drag and drop API by providing our own custom selection mechanisms, using a custom data type that encodes draggable type information</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we built two features to enhance the usability of our application. Users can now make use of tags, to easily annotate comments with navigable items that provide summaries to the subject. They can also use drag and drop, to reorder tasks within the task list component.</p>
<p>Usability is a key asset in today's applications, and, by providing highly encapsulated and reusable components to address usability concerns, we can make our lives a lot easier when building those applications. When dealing with usability, t<span>hinking in terms of components</span> is a very good thing, not only for easing development, but for establishing consistency. Consistency itself plays a major role in making an application usable.</p>
<p>In the next chapter, we're going to create some nifty components to manage time within our task management system. This will also include some new user input components, to enable simple work time-entry fields.</p>


            </article>

            
        </section>
    </body></html>