- en: '*Chapter 3*: Testing Complex Components with React Testing Library'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用React Testing Library测试复杂组件'
- en: In [*Chapter 2*](B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029), *Working with
    React Testing Library*, we learned how to test presentational components. However,
    most features are designed to allow user actions that result in changes to the
    state and resulting output. Testing as many user action scenarios as possible
    is essential for reducing risk before sending code to production for end users.
    By the end of this chapter, you will learn how to simulate user actions with the
    `fireEvent` and `user-event` modules. You will learn how to test components that
    interact with web service APIs. Finally, you will learn how to use test-driven
    development as a workflow for building your features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16887_02_Final_PG_ePub.xhtml#_idTextAnchor029) *使用React Testing Library工作*中，我们学习了如何测试表现性组件。然而，大多数功能都是设计来允许用户操作，这些操作会导致状态和结果的改变。在将代码发送到生产环境供最终用户使用之前，测试尽可能多的用户操作场景对于降低风险至关重要。在本章结束时，你将学习如何使用`fireEvent`和`user-event`模块来模拟用户操作。你将学习如何测试与Web服务API交互的组件。最后，你将学习如何将测试驱动开发作为构建特性的工作流程。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Performing actions on components with the `fireEvent` module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fireEvent`模块在组件上执行操作
- en: Simulating `user-event` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟`user-event`模块
- en: Testing components that interact with APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与API交互的组件
- en: Implementing test-driven development with React Testing Library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Testing Library实现测试驱动开发
- en: The skills you gain in this chapter will provide you with a solid understanding
    of testing the outcomes of user behaviors. You will also gain a different approach
    to building components from start to finish.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你获得的技术将为你提供对测试用户行为结果的扎实理解。你还将获得一种从零开始构建组件的不同方法。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the examples in this chapter, you will need to have Node.js installed on
    your machine. We will be using the `create-react-app` CLI tool for all code examples.
    Please familiarize yourself with the tool before starting the chapter if needed.
    Although not a requirement, it may help if you review the material from the previous
    two chapters before beginning this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，你需要在你的机器上安装Node.js。我们将使用`create-react-app` CLI工具来展示所有代码示例。如果需要，请在开始本章之前熟悉这个工具。虽然这不是必需的，但在开始本章之前回顾前两章的内容可能会有所帮助。
- en: 'You can find code examples for this chapter here: [https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter03](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter03).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码示例：[https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter03](https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter03)。
- en: Testing user events
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试用户事件
- en: In this section, we will learn how to simulate user events and test the resulting
    output. To test component interactions, similar to the case with users, we need
    methods to simulate DOM events in our tests. Numerous events caused by users can
    occur on the DOM. For example, a user can perform a keypress event by entering
    text into an input box, a click event by clicking a button, or they can view drop-down
    menu items with a mouseover event. The DOM Testing Library provides two libraries
    to simulate user actions, `fireEvent` and `user-event`, which we are going to
    see in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何模拟用户事件并测试生成的输出。为了测试组件交互，类似于用户的情况，我们需要在我们的测试中模拟DOM事件的方法。用户在DOM上可以引发多种事件。例如，用户可以通过在输入框中输入文本来执行按键事件，通过点击按钮来执行点击事件，或者通过鼠标悬停事件来查看下拉菜单项。DOM
    Testing Library提供了两个库来模拟用户操作，即`fireEvent`和`user-event`，我们将在接下来的章节中看到。
- en: Simulating user actions with fireEvent
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`fireEvent`模块模拟用户操作
- en: 'We can use the `fireEvent` module to simulate user actions on the resulting
    DOM output of components. For example, we can build a reusable `Vote` component
    that renders the following DOM output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fireEvent`模块来模拟用户在组件生成的DOM输出上的操作。例如，我们可以构建一个可重用的`Vote`组件，渲染以下DOM输出：
- en: '![Figure 3.1 – Vote component'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – Vote组件'
- en: '](img/Figure_3.1_B16887.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16887.jpg)'
- en: Figure 3.1 – Vote component
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – Vote组件
- en: 'In the preceding screenshot, the number **10** represents the likes rating.
    We have two buttons that a user can click to place a vote and change the likes
    rating: a thumbs-up button and a thumbs-down button. There is also a disclaimer
    letting the user know that they are only allowed to vote once. When a user clicks
    the thumbs-up button, they will see the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，数字**10**代表点赞评分。我们有两个按钮，用户可以点击它们来投票并更改点赞评分：一个点赞按钮和一个踩按钮。还有一个免责声明告知用户他们只能投票一次。当用户点击点赞按钮时，他们将看到以下输出：
- en: '![Figure 3.2 – Thumbs-up vote'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 点赞按钮投票'
- en: '](img/Figure_3.2_B16887.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16887.jpg)'
- en: Figure 3.2 – Thumbs-up vote
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 点赞按钮投票
- en: 'In the previous screenshot, the likes rating increased from **10** to **11**.
    When a user clicks the thumbs-down button, they will see the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，点赞评分从**10**增加到**11**。当用户点击踩按钮时，他们将看到以下输出：
- en: '![Figure 3.3 – Thumbs-down vote](img/Figure_3.3_B16887.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 踩按钮投票](img/Figure_3.3_B16887.jpg)'
- en: Figure 3.3 – Thumbs-down vote
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 踩按钮投票
- en: 'In the previous screenshot, the likes rating has decreased from `fireEvent`.
    In the code implementation for the `Vote` component, an event handler is called
    inside the component with logic to update the likes we see on the screen:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图上，点赞评分已从`fireEvent`减少。在`Vote`组件的代码实现中，组件内部调用了一个事件处理器，其中包含更新屏幕上显示的点赞逻辑：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code block, the button has an `onClick` event handler attached.
    When the like button is clicked, the event handler calls the `handleLikeVote`
    method, which calls another method, `dispatch`, which updates the likes rating.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，按钮有一个`onClick`事件处理器附加。当点赞按钮被点击时，事件处理器调用`handleLikeVote`方法，该方法调用另一个方法`dispatch`来更新点赞评分。
- en: Important Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please refer to the [*Chapter 3*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046),
    *Testing Complex Components with React Testing Library*, code samples, found in
    the *Technical requirements* section, to see the component in its entirety.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*第3章*[*Testing Complex Components with React Testing Library*](B16887_03_Final_PG_ePub.xhtml#_idTextAnchor046)，在*技术要求*部分找到的代码示例，以查看组件的完整内容。
- en: 'We can write a test to assert the output of making a vote:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个测试来断言投票的输出：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code block, we import the `fireEvent`, `render`, and `screen`
    methods from React Testing Library. Next, we import the `Vote` component to test.
    Then, we arrange our test code in the `test` method and use the `render` method
    to render the `Vote` component with the value `10` for the `totalGlobalLikes`
    property passed in to the component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们从React Testing Library中导入`fireEvent`、`render`和`screen`方法。接下来，我们导入`Vote`组件以进行测试。然后，我们在`test`方法中安排我们的测试代码，并使用`render`方法渲染`Vote`组件，将`totalGlobalLikes`属性的值`10`传递给组件。
- en: 'The `totalGlobalLikes` property is the number we initially see on the screen
    when the component is rendered and represents the application-wide state for the
    likes. In a fully completed application, we would pass the `totalGlobalLikes`
    value down to the `Vote` component via a parent component. Next, we will interact
    with and assert the output of the rendered component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalGlobalLikes`属性是我们组件渲染时在屏幕上最初看到的数字，它代表了应用的点赞状态。在一个完全完成的程序中，我们会通过父组件将`totalGlobalLikes`的值传递给`Vote`组件。接下来，我们将与渲染组件的输出进行交互并断言：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code block, first, we assert that the `Vote` component's local
    version of `totalGlobalLikes` is in the document with a value equal to `10`. Next,
    we use the `click` method of `fireEvent` to click the button with the name `thumbs
    up`. Next, we assert that the value of `totalGlobalLikes` updates in the document
    to `11`. Finally, we assert that the `thumbs up` button's background color has
    changed to `green`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，首先，我们断言`Vote`组件的本地`totalGlobalLikes`版本在文档中的值等于`10`。接下来，我们使用`fireEvent`的`click`方法点击名为`thumbs
    up`的按钮。然后，我们断言文档中`totalGlobalLikes`的值更新为`11`。最后，我们断言点赞按钮的背景色已变为绿色。
- en: In many cases, using `fireEvent` is completely fine. However, it does have some
    limitations. For example, when a user performs an action such as entering text
    into an input box, many events occur, such as `keydown` and `keyup`. Now, `fireEvent`
    has methods to achieve these individual actions, but it doesn't have one way to
    handle them all together in sequence.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用 `fireEvent` 是完全可行的。然而，它确实有一些限制。例如，当用户执行诸如在输入框中输入文本等操作时，会发生许多事件，例如
    `keydown` 和 `keyup`。现在，`fireEvent` 有方法来实现这些单个动作，但它没有一种方法可以按顺序一起处理它们。
- en: Next, we will learn about using the `user-event` library to address the `fireEvent`
    module's limitations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用 `user-event` 库来解决 `fireEvent` 模块的局限性。
- en: Simulating user actions with user-event
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `user-event` 模拟用户操作
- en: The `user-event` library is an enhanced version of `fireEvent`. In the previous
    section, we learned that `fireEvent` has methods to simulate various events that
    occur when a user enters text into an input box. The `user-event` library has
    many methods, such as `click` or `type`, that automatically simulate all the events
    that occur when a user performs actions on the DOM. The advantage is that `user-event`
    methods provide more value compared to `fireEvent` methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`user-event` 库是 `fireEvent` 的增强版本。在上一节中，我们了解到 `fireEvent` 有方法来模拟用户在输入框中输入文本时发生的各种事件。`user-event`
    库有许多方法，例如 `click` 或 `type`，可以自动模拟用户在 DOM 上执行操作时发生的所有事件。其优势是 `user-event` 方法比 `fireEvent`
    方法提供了更多的价值。'
- en: '`create-react-app` comes with `user-event` already installed. For projects
    not using `create-react-app`, use the following command to install:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-react-app` 已经预装了 `user-event`。对于不使用 `create-react-app` 的项目，请使用以下命令进行安装：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can update the previous section''s `Vote` component test with `user-event`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `user-event` 更新上一节的 `Vote` 组件测试：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code, we imported the `user-event` library as `user`. Finally,
    we used the `click` method of `user-event` to click the `thumbs up` button. Our
    test provides more value because we are more closely simulating user DOM actions.
    The React Testing Library team recommends using `user-event` as much as possible,
    so we will not use `fireEvent` in any more examples throughout the remainder of
    this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `user-event` 库导入为 `user`。最后，我们使用 `user-event` 的 `click` 方法点击了 `点赞`
    按钮。我们的测试提供了更多的价值，因为我们更接近地模拟了用户的 DOM 操作。React 测试库团队建议尽可能多地使用 `user-event`，因此我们将在本书的其余部分不再使用
    `fireEvent`。
- en: 'When we introduced the `Vote` component in the previous section, we mentioned
    that a user could only vote once. We can write a test to handle that scenario:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中介绍 `Vote` 组件时，我们提到用户只能投票一次。我们可以编写一个测试来处理这种情况：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, first, we grab the `thumbs up` and `thumbs down` buttons.
    Then, we verify the current total likes is `10` and click the `thumbs up` button
    twice. Next, we verify the total likes is `11`. Finally, we click the `thumbs
    down` button and assert that the total likes count is still `11`. As another test
    case, we can also verify that the local version of `totalGlobalLikes` decreases
    by one when a user clicks the `thumbs down` button:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们获取了 `点赞` 和 `踩` 按钮。然后，我们验证当前的总点赞数是 `10`，并点击 `点赞` 按钮两次。接下来，我们验证总点赞数是
    `11`。最后，我们点击 `踩` 按钮，并断言总点赞数仍然是 `11`。作为另一个测试用例，我们还可以验证当用户点击 `踩` 按钮时，`totalGlobalLikes`
    的本地版本减少一个：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We click the `thumbs down` button and verify the total likes decreased from
    `10` to `9`, and the background color changed to `red` in the preceding code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们点击了 `踩` 按钮，并验证总点赞数从 `10` 减少到 `9`，背景颜色变为 `红色`。
- en: 'When we run all the tests for the `Vote` component, we get the following results
    indicating all tests passed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `Vote` 组件的所有测试时，我们得到以下结果，表明所有测试都通过了：
- en: '![Figure 3.4 – Vote component test results'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 投票组件测试结果'
- en: '](img/Figure_3.4_B16887.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – B16887.jpg](img/Figure_3.4_B16887.jpg)'
- en: Figure 3.4 – Vote component test results
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 投票组件测试结果
- en: The preceding screenshot shows that the `Vote.test.js` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了 `Vote.test.js` 文件。
- en: 'In another example, we might create an input component for employees that accepts
    their name:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，我们可能会为员工创建一个接受他们名字的输入组件：
- en: '![Figure 3.5 – Employee email input'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – 员工电子邮件输入'
- en: '](img/Figure_3.5_B16887.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – B16887.jpg](img/Figure_3.5_B16887.jpg)'
- en: Figure 3.5 – Employee email input
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 员工电子邮件输入
- en: 'When the employee enters their name, the component appends it to the company''s
    website name and displays the result to the screen:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当员工输入他们的名字时，组件将其追加到公司的网站名称，并将结果显示在屏幕上：
- en: '![Figure 3.6 – Completed employee email input'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 完成的员工电子邮件输入'
- en: '](img/Figure_3.6_B16887.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B16887.jpg)'
- en: Figure 3.6 – Completed employee email input
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 完成的员工电子邮件输入
- en: 'If the employee enters a first and last name separated by a space, the name
    is concatenated with a `.`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果员工输入由空格分隔的姓名和姓氏，则姓名会与一个 `.` 连接：
- en: '![Figure 3.7 – Concatenated employee email input'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 连接的员工电子邮件输入'
- en: '](img/Figure_3.7_B16887.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B16887.jpg)'
- en: Figure 3.7 – Concatenated employee email input
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 连接的员工电子邮件输入
- en: 'We can use the `type` method of `user-event` to simulate typing into the employee
    email component and make an assertion on the result as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `user-event` 的 `type` 方法模拟在员工电子邮件组件中输入，并对结果进行断言，如下所示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We import the `render`, `screen`, and `user-event` modules in the previous code.
    Then, we import the `EmployeeEmail` component. We render the component on the
    screen. Then, we grab the input element and store it in the variable input. Next,
    we use the `type` method from `user-event` to enter `jane doe` into the input.
    Finally, we assert that the text `jane.doe@software-plus.com` is in the DOM.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了 `render`、`screen` 和 `user-event` 模块。然后，我们导入了 `EmployeeEmail` 组件。我们在屏幕上渲染该组件。然后，我们获取输入元素并将其存储在变量
    input 中。接下来，我们使用 `user-event` 中的 `type` 方法将 `jane doe` 输入到输入框中。最后，我们断言文本 `jane.doe@software-plus.com`
    在 DOM 中。
- en: 'When we run our test, we get the following output indicating the scenario passes
    as expected:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们会得到以下输出，表明场景按预期通过：
- en: '![Figure 3.8 – Employee component test results'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 员工组件测试结果'
- en: '](img/Figure_3.8_B16887.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.8_B16887.jpg)'
- en: Figure 3.8 – Employee component test results
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 员工组件测试结果
- en: The previous screenshot shows that the `EmployeeEmail.test.js` file. Now you
    know how to simulate user actions using the `user-event` module. The skills learned
    in this section are essential because most of our tests typically will need to
    involve some type of user action.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的屏幕截图显示了 `EmployeeEmail.test.js` 文件。现在你知道如何使用 `user-event` 模块模拟用户操作。在本节中学到的技能是必不可少的，因为我们的大多数测试通常都需要涉及某种类型用户操作。
- en: Next, we will learn how to test components that call event handlers in isolation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何测试独立调用事件处理器的组件。
- en: Testing components that call event handlers in isolation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试独立调用事件处理器的组件
- en: 'It is very common to create child components that invoke methods passed down
    to them from parent components. In the previous section, we had a `Vote` component
    that included two buttons in the same component, which can be seen in the following
    code block:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建从父组件传递下来的方法调用的子组件是非常常见的。在前面的一节中，我们有一个 `Vote` 组件，它在一个组件中包含了两个按钮，这可以在以下代码块中看到：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We could decide to extract the button code into its own file to become a reusable
    component:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以决定将按钮代码提取到自己的文件中，成为一个可重用的组件：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code block, we have a `VoteBtn` component that accepts `handleVote`,
    `hasVoted`, `imgSrc`, and `altText` properties passed to the `props` object. The
    parent component would pass down the props. For this section''s purposes, our
    primary focus is the `handleVote` property. The `handleVote` method is called
    when a `click` event fires due to clicking the button. When this method runs inside
    the `Vote` component, the result is updating the local version of `totalGlobalLikes`.
    The resulting screen output of the button is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有一个 `VoteBtn` 组件，它接受 `handleVote`、`hasVoted`、`imgSrc` 和 `altText`
    属性，这些属性通过 `props` 对象传递。父组件会向下传递这些属性。对于本节的目的，我们的主要关注点是 `handleVote` 属性。当点击按钮时，由于点击事件触发，会调用
    `handleVote` 方法。当此方法在 `Vote` 组件内部运行时，结果是更新 `totalGlobalLikes` 的本地版本。按钮的最终屏幕输出如下：
- en: '![Figure 3.9 – Vote button'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 投票按钮'
- en: '](img/Figure_3.9_B16887.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B16887.jpg)'
- en: Figure 3.9 – Vote button
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 投票按钮
- en: In the preceding screenshot, we see a `Vote` component with a `thumbs up` image.
    To test the `VoteBtn` component in isolation, we need to provide properties to
    the component since it's no longer wrapped in a component that provides them automatically.
    Jest provides functions that serve as test doubles to replace the real versions
    of methods inside our tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们看到一个带有 `点赞` 图标的 `Vote` 组件。为了独立测试 `VoteBtn` 组件，我们需要向组件提供属性，因为它不再被一个自动提供这些属性的组件所包裹。Jest
    提供了作为测试替身的函数，用于替换我们测试中方法的真实版本。
- en: 'A test double is a generic term used to represent an object that replaces a
    real object for testing purposes. Test doubles used as placeholders for dependencies
    such as an API or database are known as `jest.fn` function to replace `handleVote`
    inside our test:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身是一个通用术语，用于表示在测试目的下替换真实对象的某个对象。用作API或数据库等依赖项占位符的测试替身被称为`jest.fn`函数，用于替换我们测试中的`handleVote`：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code block, first, we import the `render` and `screen` methods
    from React Testing Library. Next, we import the `user-event` module. Then, we
    import the `thumbsUp` image and the `VoteBtn` component we want to test. Then,
    inside the `test` method, we create a `jest` function to use as a mock and assign
    it to the `mockHandleVote` variable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，首先，我们从React Testing Library中导入`render`和`screen`方法。然后，我们导入`user-event`模块。接着，我们导入我们想要测试的`thumbsUp`图像和`VoteBtn`组件。然后，在`test`方法内部，我们创建一个`jest`函数作为模拟，并将其分配给`mockHandleVote`变量。
- en: 'Next, we render the `VoteBtn` component into the DOM and pass `mockHandleVote`
    and other properties to the component. Now that our test code is arranged, we
    can perform actions and make assertions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`VoteBtn`组件渲染到DOM中，并将`mockHandleVote`和其他属性传递给组件。现在我们的测试代码已经安排好了，我们可以执行操作并做出断言：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the previous code, we click the button with the name `mockHandleVote` method
    is called when a user clicked the button. The second assertion confirms the `mockHandleVote`
    method was called exactly one time. The `mockHandleVote` assertions can be important
    when you need to be sure the function is used correctly. When we run our test,
    we get the following output indicating the scenario passes as expected:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们点击了名为`mockHandleVote`的按钮，当用户点击按钮时，会调用该方法。第二个断言确认`mockHandleVote`方法被调用了一次。当需要确保函数被正确使用时，`mockHandleVote`断言可能很重要。当我们运行测试时，我们得到以下输出，表明场景按预期通过：
- en: '![Figure 3.10 – Vote button component test results'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 投票按钮组件测试结果'
- en: '](img/Figure_3.10_B16887.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.10_B16887.jpg)'
- en: Figure 3.10 – Vote button component test results
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 投票按钮组件测试结果
- en: The previous screenshot shows that the `VoteBtn.test.js` file. It should be
    noted that although we were able to verify that the event handler is called, we
    are not able to confirm whether the button state changes to disabled after being
    clicked. We would need to include the parent component and write an integration
    test to verify that behavior. We will learn how to approach these scenarios in
    [*Chapter 4*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062), *Integration Testing
    and Third-Party Libraries in Your Application*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了`VoteBtn.test.js`文件。需要注意的是，尽管我们能够验证事件处理器被调用，但我们无法确认按钮在被点击后状态是否变为禁用。我们需要包含父组件并编写集成测试来验证该行为。我们将在[*第4章*](B16887_04_Final_PG_ePub.xhtml#_idTextAnchor062)中学习如何处理这些场景，*应用程序中的集成测试和第三方库*。
- en: Now you know how to test event handlers in isolated components with test doubles.
    In this section, we learned how to simulate and test user interactions. We learned
    how to mimic actions with `fireEvent` and `user-event`. We also learned how to
    use test doubles to test event handlers. The skills learned in this section will
    help you in the next section when we learn how to test components that interact
    with APIs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用测试替身测试隔离组件中的事件处理器。在本节中，我们学习了如何模拟和测试用户交互。我们学习了如何使用`fireEvent`和`user-event`来模拟动作。我们还学习了如何使用测试替身来测试事件处理器。在本节中学到的技能将有助于你在下一节中学习如何测试与API交互的组件。
- en: Testing components that interact with APIs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试与API交互的组件
- en: This section will build on our knowledge of testing event handlers from the
    previous section by looking at how to test components that send and receive data
    from APIs. In our component unit tests, we can reduce application risk with our
    testing efforts by using tools that act as test doubles in place of real APIs.
    Using test doubles in place of the actual API, we can avoid slow internet connections
    or receive dynamic data resulting in unpredictable test results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将基于我们之前章节中学到的测试事件处理器的知识，通过查看如何测试发送和接收API数据的组件来构建。在我们的组件单元测试中，我们可以通过使用充当测试替身的工具来代替真实API，从而减少应用风险。使用测试替身代替实际API，我们可以避免缓慢的互联网连接或接收导致不可预测测试结果动态数据。
- en: We will learn how to install and use **Mock Service Worker** (**MSW**) as a
    test double in tests to capture API requests initiated by our components and return
    mock data. We will test a component designed for users to search for drinks data
    from an API. We will also learn how to use MSW as a development server. The concepts
    in this section will help us understand how to verify communication between the
    frontend and API servers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何安装和使用**模拟服务工作者**（**MSW**）作为测试替身，在测试中捕获组件发起的API请求并返回模拟数据。我们将测试一个用于用户从API搜索饮料数据的组件。我们还将学习如何将MSW用作开发服务器。本节中的概念将帮助我们了解如何验证前端和API服务器之间的通信。
- en: Requesting API data with fetch
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fetch请求API数据
- en: 'We can create a component that allows a user to search for drinks from TheCockTailDB
    ([https://www.thecocktaildb.com](https://www.thecocktaildb.com)), a free open
    source service that will play the backend API''s role. Our component will access
    the service and request data. When the component first renders, the user sees
    an input field and a **Search** button:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个组件，允许用户从TheCockTailDB ([https://www.thecocktaildb.com](https://www.thecocktaildb.com))搜索饮料，TheCockTailDB是一个免费的开源服务，将扮演后端API的角色。我们的组件将访问该服务并请求数据。当组件首次渲染时，用户会看到一个输入字段和一个**搜索**按钮：
- en: '![Figure 3.11 – Drink search component](img/Figure_3.11_B16887.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 饮料搜索组件](img/Figure_3.11_B16887.jpg)'
- en: Figure 3.11 – Drink search component
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 饮料搜索组件
- en: 'When a user searches for drinks, the API returns drink data similar to the
    following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户搜索饮料时，API返回类似以下的数据：
- en: '![Figure 3.12 – Drink search results'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – 饮料搜索结果'
- en: '](img/Figure_3.12_B16887.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.12_B16887.jpg)'
- en: Figure 3.12 – Drink search results
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 饮料搜索结果
- en: 'In the preceding screenshot, a user searched for `gin` and received an array
    of results from the API. If a user searches for drinks that don''t return results,
    a **No drinks found** message is displayed on the screen:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，用户搜索了`gin`并从API收到了一系列结果。如果用户搜索的饮料没有返回结果，屏幕上会显示**没有找到饮料**的消息：
- en: '![Figure 3.13 – No drink search results'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – 没有饮料搜索结果'
- en: '](img/Figure_3.13_B16887.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B16887.jpg)'
- en: Figure 3.13 – No drink search results
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 没有饮料搜索结果
- en: 'If a user attempts a search and the API server is inaccessible, a **Service
    unavailable** message is displayed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试搜索，但API服务器不可访问，则显示**服务不可用**的消息：
- en: '![Figure 3.14 – Drink search request error'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 饮料搜索请求错误'
- en: '](img/Figure_3.14_B16887.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B16887.jpg)'
- en: Figure 3.14 – Drink search request error
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 饮料搜索请求错误
- en: 'Our component will use an HTTP `request` module designed to request drink data
    from the API using the `fetch` method, a tool included in browsers to make HTTP
    requests:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件将使用一个HTTP `request`模块，该模块设计用于使用`fetch`方法从API请求饮料数据，`fetch`是浏览器中用于发送HTTP请求的工具：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code block, `fetchDrinks` accepts a `drinkQuery` parameter
    representing the search data and makes an API request to return drinks data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`fetchDrinks`接受一个`drinkQuery`参数，代表搜索数据，并通过API请求数据。
- en: 'The `Drink Search` component has a form that, when submitted, will call the
    `handleDrinkQuery` method, which ultimately invokes the `request` module with
    the drinks to search:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`饮料搜索`组件有一个表单，当提交时，将调用`handleDrinkQuery`方法，该方法最终调用`request`模块并带上要搜索的饮料：'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the `request` module sends a response that includes an array of drinks,
    the `Drink Search` component will call `drinkResults`, a method that renders `drinks`
    on the screen:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当`request`模块发送包含饮料数组的响应时，`饮料搜索`组件将调用`drinkResults`方法，该方法在屏幕上渲染`drinks`：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the response does not return any drinks, then the `No drinks found` code
    is rendered:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应没有返回任何饮料，则渲染`没有找到饮料`的代码：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If there is an error communicating with the server, then the `Service unavailable`
    code is rendered:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与服务器通信出现错误，则渲染`服务不可用`的代码：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we understand how the `Drink Search` component behaves based on user interactions.
    Next, we will learn how to create mock API data to test the component.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`饮料搜索`组件根据用户交互的行为。接下来，我们将学习如何创建模拟API数据来测试组件。
- en: Creating mock API data with MSW
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MSW创建模拟API数据
- en: '**MSW** is a tool we can use to capture API requests initiated by our components
    and return mocked responses. When our frontend React application makes an HTTP
    request to an API server, MSW will intercept the request before it reaches the
    network and respond with mock data. Use the following command to install MSW into
    your project:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**MSW** 是一个我们可以用来捕获由我们的组件发起的 API 请求并返回模拟响应的工具。当我们的前端 React 应用程序向 API 服务器发出
    HTTP 请求时，MSW 将在请求到达网络之前拦截该请求，并使用模拟数据做出响应。使用以下命令将 MSW 安装到您的项目中：'
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To get started using MSW, first, we will create a mock response route handler
    to override matching calls to specific URLs by our component:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 MSW，首先，我们将创建一个模拟响应路由处理程序来覆盖我们的组件对特定 URL 的匹配调用：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code block, we imported `rest` from `msw`. The `rest` object
    allows us to specify the `request` type to `mock`. Inside the `get` method, we
    specify the route we will override when a *GET* request is made. In the `callback`
    parameter of the `get` method, three parameters are accepted –the `req` parameter
    provides information about the request, such as the data sent in the request.
    The `res` parameter is a function used to make the mocked response. The `ctx`
    parameter provides a context for the response functions to send.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们导入了 `rest` 从 `msw`。`rest` 对象允许我们指定 `request` 类型为 `mock`。在 `get` 方法中，我们指定当发出
    *GET* 请求时要覆盖的路线。在 `get` 方法的 `callback` 参数中，接受三个参数 - `req` 参数提供了有关请求的信息，例如请求中发送的数据。`res`
    参数是一个函数，用于创建模拟响应。`ctx` 参数为响应函数提供了一个上下文。
- en: Inside `ctx`, we create a `200` response status code indicating a successful
    request, and lastly, we create JSON data to return, which will be an array of
    drinks. You may notice that the *GET* request route does not match the entire
    URL used in the HTTP request module from the previous section. MSW will pattern
    match URLs, making the need to use the exact URL string unnecessary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ctx` 中，我们创建一个表示成功请求的 `200` 响应状态码，最后，我们创建要返回的 JSON 数据，这将是一个饮料数组。您可能会注意到，*GET*
    请求路由并不匹配上一节中 HTTP 请求模块使用的整个 URL。MSW 将进行 URL 匹配，使得使用确切的 URL 字符串变得不必要。
- en: 'Next, we will create our mock server and pass in the mock response route handler:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的模拟服务器，并传入模拟响应路由处理程序：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous code, first, we import `setupServer` from `msw/node`, which
    will be used to intercept requests made to the route handler created in the previous
    code snippet. We use `msw/node` because our test code will run in a Node.js environment.
    Next, we import the route handlers. Finally, we pass the handlers to `setupServer`
    and export the code via the `mockServer` variable. Now that we have our server
    set up, we can write a test for the `DrinkSearch` component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们从 `msw/node` 导入 `setupServer`，它将用于拦截上一代码片段中创建的路由处理程序发出的请求。我们使用
    `msw/node` 因为我们的测试代码将在 Node.js 环境中运行。接下来，我们导入路由处理程序。最后，我们将处理程序传递给 `setupServer`，并通过
    `mockServer` 变量导出代码。现在我们已经设置了服务器，我们可以为 `DrinkSearch` 组件编写测试。
- en: Testing the DrinkSearch component
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 DrinkSearch 组件
- en: 'To get started testing the component, first, we will import the required code
    and start our mock server:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试组件，首先，我们将导入所需的代码并启动我们的模拟服务器：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code block, first, we import `render` and `screen` from React
    Testing Library. Next, we import the `user-event` module. Then we import the `DrinkSearch`
    component we want to test. Finally, we import `mockServer`, our mock server. Next,
    we need to start our mock server and set it up to perform specific actions at
    different points in the test life cycle:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，首先，我们从 React Testing Library 导入 `render` 和 `screen`。然后，我们导入 `user-event`
    模块。接着，我们导入我们想要测试的 `DrinkSearch` 组件。最后，我们导入 `mockServer`，我们的模拟服务器。接下来，我们需要启动我们的模拟服务器，并设置它在测试生命周期的不同点执行特定操作：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code block, first, we set up our mock server to listen to
    HTTP requests before running any of our tests. Next, we make our mock server reset
    after each test, so no tests are affected by previous tests. Finally, we shut
    down our mock server after all tests are finished running. Next, we will create
    the main test code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，首先，我们在运行任何测试之前设置我们的模拟服务器以监听 HTTP 请求。接下来，我们在每次测试后重置我们的模拟服务器，以确保测试之间不会相互影响。最后，在所有测试完成后关闭我们的模拟服务器。接下来，我们将创建主要的测试代码：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code block, we render the `DrinkSearch` component. Next, we
    grab the search input and enter `vodka` as the drink to search. That `{enter}`
    after `vodka` simulates pressing the *Enter* key on a keyboard. Next, we will
    make assertions on the outcomes of user actions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们渲染了`DrinkSearch`组件。接下来，我们获取搜索输入并输入`vodka`作为要搜索的饮料。在`vodka`后面的`{enter}`模拟了在键盘上按下*Enter*键。接下来，我们将对用户操作的结果进行断言：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we use the `findByRole` query method to grab the image
    element. In previous examples, we solely used `getBy*` queries. The `getBy*` queries
    can be used in most situations when you expect elements to be available in the
    current state of the DOM. However, in the previous code, we use a `findBy*` query
    because the process of communicating with the API is asynchronous, so we need
    to give our application time to receive a response and update the DOM before attempting
    to grab an element.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`findByRole`查询方法来获取图像元素。在先前的例子中，我们只使用了`getBy*`查询。`getBy*`查询可以在大多数情况下使用，当你期望元素在当前DOM状态中可用时。然而，在之前的代码中，我们使用了一个`findBy*`查询，因为与API通信的过程是异步的，所以我们需要给我们的应用程序一些时间来接收响应并更新DOM，然后再尝试获取元素。
- en: 'When a `getBy*` query is used to select elements, an error is thrown, and our
    test fails if the element is not found in the current DOM:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`getBy*`查询来选择元素时，会抛出一个错误，如果元素在当前DOM中找不到，我们的测试将失败：
- en: '![Figure 3.15 – No drink search failing test results'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – 无饮料搜索失败的测试结果'
- en: '](img/Figure_3.15_B16887.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B16887.jpg)'
- en: Figure 3.15 – No drink search failing test results
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 无饮料搜索失败的测试结果
- en: The preceding screenshot shows that the `DrinkSearch.test.js` file. The test
    result output also provides more context for the failure by letting us know it
    couldn't find an image element with the name `test drink`. The `findBy*` queries
    will also throw an error when elements are not found, but only after a few seconds,
    allowing time for the element to appear on the screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`DrinkSearch.test.js`文件。测试结果输出还提供了更多上下文，让我们知道它找不到名为`test drink`的图像元素。`findBy*`查询在元素找不到时也会抛出错误，但通常会在几秒钟后，这给了元素出现在屏幕上的时间。
- en: 'We can also write a test to verify the output when no results are returned
    from the API server for our drink search. We can modify the response of our MSW
    server to set up the scenario:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写一个测试来验证当API服务器没有返回我们的饮料搜索结果时的输出。我们可以修改我们的MSW服务器的响应来设置测试场景：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code block, we use the `use` method to override our default
    mock values to return `null`. As mentioned in the *Requesting API data with fetch*
    section, our component will return the `No drinks found` message when the server
    does not return an array of drinks. Now that we have our test set up to send the
    right data, we can write the main test code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用`use`方法来覆盖我们的默认模拟值，以返回`null`。正如在*使用fetch请求API数据*部分中提到的，当服务器没有返回饮料数组时，我们的组件将返回`No
    drinks found`消息。现在我们已经设置了测试来发送正确的数据，我们可以编写主要的测试代码：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We render the `DrinkSearch` component and search for `vodka` as in the last
    test in the preceding code. However, instead of expecting an array of drinks,
    we expect to see the `No drinks found` message.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像前面的测试中一样渲染了`DrinkSearch`组件并搜索了`vodka`。然而，这次我们期望看到`No drinks found`消息，而不是饮料数组。
- en: 'For our next test, we will verify the output when the API server is unavailable.
    Like we did in the previous test, we will modify the response of our MSW server
    to set up the test scenario:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个测试，我们将验证当API服务器不可用时输出。就像我们在上一个测试中所做的那样，我们将修改我们的MSW服务器的响应来设置测试场景：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We override our default mock values in the previous code to respond with a
    `503` status code indicating the API is not available. As mentioned in the *Requesting
    API data with fetch* section, our component will return the `Service unavailable`
    message when the server is offline. Now that we have our test set up to send the
    right response, we can write the main test code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的代码中覆盖了默认的模拟值，以响应`503`状态码，表示API不可用。正如在*使用fetch请求API数据*部分中提到的，当服务器离线时，我们的组件将返回`Service
    unavailable`消息。现在我们已经设置了测试来发送正确的响应，我们可以编写主要的测试代码：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Like code in the previous test, we render the `DrinkSearch` component and search
    for `vodka` as in the last test. However, now we expect `Service unavailable`
    to be in the document due to the server sending the `503` error code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个测试中的代码一样，我们渲染了`DrinkSearch`组件并搜索了`vodka`。然而，现在我们期望文档中包含`Service unavailable`，因为服务器发送了`503`错误代码。
- en: 'The last test we write will verify that no request is made when a user attempts
    to submit a blank search query:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要写的最后一个测试将验证当用户尝试提交空白搜索查询时不会发出任何请求：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous code, we press the *Enter* key without typing in a search string.
    When the application first loads, we only see the input field and the button used
    to search. The application is designed to display additional content that includes
    heading elements when a search query is submitted to the API. We expect no element
    with the role of `heading` on the screen using a `queryBy*` query. The `queryBy*`
    query is preferred when you want to verify that specific elements are not on the
    screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们按下 *Enter* 键而没有输入搜索字符串。当应用程序首次加载时，我们只能看到输入字段和用于搜索的按钮。应用程序设计为在向 API
    提交搜索查询时显示包括标题元素在内的附加内容。我们期望使用 `queryBy*` 查询时屏幕上没有具有 `heading` 角色的元素。当您想验证特定元素不在屏幕上时，`queryBy*`
    查询是首选的。
- en: 'Unlike the `getBy*` and `findBy*` queries, `queryBy*` queries do not throw
    an error and fail the test when an element is not found. `queryBy*` queries return
    `null` when an element is not found, allowing you to assert the expected absence
    of elements in the DOM without test failure. When we run our tests, we should
    receive the following output indicating our test suite passed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `getBy*` 和 `findBy*` 查询不同，`queryBy*` 查询在找不到元素时不会抛出错误并使测试失败。当找不到元素时，`queryBy*`
    查询返回 `null`，允许您在没有测试失败的情况下断言 DOM 中预期不存在元素。当我们运行测试时，我们应该收到以下输出，表明我们的测试套件已通过：
- en: '![Figure 3.16 – No drink search passing test results'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.16 – 无饮料搜索通过测试结果'
- en: '](img/Figure_3.16_B16887.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B16887.jpg)'
- en: Figure 3.16 – No drink search passing test results
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 无饮料搜索通过测试结果
- en: The preceding screenshot shows that the `DrinkSearch.test.js` file. Now you
    know how to create a mock server with MSW to test components that request API
    data.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了 `DrinkSearch.test.js` 文件。现在您知道了如何使用 MSW 创建模拟服务器来测试请求 API 数据的组件。
- en: Next, we will learn how to use MSW in development.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在使用 MSW 进行开发。
- en: Using MSW in development
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发中使用 MSW
- en: In addition to using MSW to mock HTTP responses in our tests, we can also create
    mock responses in development. The benefit of having a mock development server
    is building and testing the frontend even if the backend API is not complete.
    We need to know what the communication and data exchange will look like between
    the frontend and backend API to create the right mock responses.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在我们的测试中使用 MSW 模拟 HTTP 响应外，我们还可以在开发中创建模拟响应。拥有模拟开发服务器的优点是，即使后端 API 不完整，也可以构建和测试前端。我们需要了解前端和后端
    API 之间的通信和数据交换将是什么样子，以便创建正确的模拟响应。
- en: 'First, we need to add the service worker file to intercept HTTP requests made
    by our frontend and respond with mock data. The MSW documentation states we should
    install the file in the public directory of your project. Run the following command
    from the root of your project to install:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将服务工作者文件添加到拦截前端发出的 HTTP 请求并使用模拟数据响应。MSW 文档指出我们应该将文件安装到项目的公共目录中。从项目根目录运行以下命令以安装：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous command automatically downloads the service worker file to the
    public folder. If you are using `create-react-app` to build your project, the
    `public` directory is located at the project's root. We do not need to do anything
    extra in the file once it's downloaded. Next, we need to create a file in the
    `src/mocks/` directory to set up and start the service worker, similar to what
    we did in the *Creating mock API data with MSW* section in this chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令会自动将服务工作者文件下载到公共文件夹。如果您使用 `create-react-app` 构建项目，则 `public` 目录位于项目根目录。一旦下载，我们不需要在文件中做任何额外操作。接下来，我们需要在
    `src/mocks/` 目录中创建一个文件来设置和启动服务工作者，类似于我们在本章的 *使用 MSW 创建模拟 API 数据* 部分所做的那样。
- en: 'However, for the mock development server, we will make slight changes to how
    we set up the server:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于模拟开发服务器，我们将对设置服务器的方式做些轻微的调整：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, we import `rest` and `setupWorker` from `msw`. In the
    *Creating mock API data with MSW* section in this chapter, we imported modules
    from `msw/node` because our tests run in a Node.js environment. The mock development
    server will run in the browser, so we do not need to import the Node.js version.
    Next, we create a `drinks` array of drink data. Then, we set up the routes and
    responses for the server:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`msw`中导入了`rest`和`setupWorker`。在本章的“使用MSW创建模拟API数据”部分，我们由于测试在Node.js环境中运行，因此从`msw/node`中导入了模块。模拟开发服务器将在浏览器中运行，因此我们不需要导入Node.js版本。接下来，我们创建了一个包含饮料数据的`drinks`数组。然后，我们为服务器设置了路由和响应：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We create a route handler in the preceding code to handle *GET* requests made
    to the URL attempting to access the cocktail API. We pass in the array of drinks
    as the response data. In the *Creating mock API data with MSW* section in this
    chapter, we split the server setup code and route handlers into separate files.
    We will keep all the server setup code in the same file for the mock development
    server to achieve the same result. The last thing we need to do is set up our
    application to run the mock server in the development environment:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个路由处理程序来处理对尝试访问鸡尾酒API的URL发出的*GET*请求。我们将饮料数组作为响应数据传入。在本章的“使用MSW创建模拟API数据”部分，我们将服务器设置代码和路由处理程序拆分到单独的文件中。我们将保持所有服务器设置代码在同一个文件中，以实现模拟开发服务器相同的成果。最后，我们需要做的是设置我们的应用程序，以便在开发环境中运行模拟服务器：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we set up the server to start when the `NODE_ENV` environment
    variable is set to `development` before rendering the `App` component into the
    DOM. Applications built with `create-react-app` already set `NODE_ENV` to `development`,
    so all we need to do is start the application with the `npm` `start` script, typical
    when building `create-react-app` applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了服务器，在将`NODE_ENV`环境变量设置为`development`之前启动，然后将`App`组件渲染到DOM中。使用`create-react-app`构建的应用程序已经将`NODE_ENV`设置为`development`，所以我们只需要使用`npm`的`start`脚本来启动应用程序，这在构建`create-react-app`应用程序时很典型。
- en: Now you know how to create a mock server with MSW to test components that request
    API data. You also made an MSW server to respond with fake responses in development.
    Furthermore, you now know when to use the `findBy*` and `queryBy*` queries in
    addition to `getBy*` queries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用MSW创建模拟服务器来测试请求API数据的组件。你还创建了一个MSW服务器，在开发环境中以假响应进行响应。此外，你现在知道何时在`getBy*`查询之外使用`findBy*`和`queryBy*`查询。
- en: In this section, we learned how to install and use MSW. We tested a component
    used for searching drinks data from an API. Finally, we learned how to use MSW
    as a development server. Next, we will learn how to use the test-driven development
    approach to writing tests.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何安装和使用MSW。我们测试了一个用于从API搜索饮料数据的组件。最后，我们学习了如何将MSW用作开发服务器。接下来，我们将学习如何使用测试驱动开发方法编写测试。
- en: Implementing test-driven development
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施测试驱动开发
- en: '**Test-Driven Development** (**TDD**) entails writing unit tests first and
    then building the code to pass. The TDD approach allows you to think about whether
    the code is correct for the tests you want to write. The process provides a perspective
    that focuses on the least amount of code needed to make tests pass. TDD is also
    known as **Red, Green, Refactor**. *Red* represents failing tests, *Green* represents
    passing tests, and as the name says, *Refactor* means refactoring the code while
    maintaining passing tests. A typical TDD workflow would be the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）意味着先编写单元测试，然后构建代码以通过测试。TDD方法允许你思考代码是否适合你想要编写的测试。这个过程提供了一个关注最少代码以使测试通过的角度。TDD也被称为**红、绿、重构**。*红*代表失败的测试，*绿*代表通过的测试，正如其名，*重构*意味着在保持通过测试的同时重构代码。典型的TDD工作流程如下：'
- en: Write a test.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试。
- en: Run the test, expecting it to fail.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，预期它会失败。
- en: Write the minimum amount of code to make the test pass.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最少的代码以使测试通过。
- en: Rerun the test to verify it passes.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试以验证它是否通过。
- en: Refactor the code as needed.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重构代码。
- en: Repeat steps *2* through *5* as needed.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，重复步骤2到5。
- en: We can use React Testing Library to drive the development of React components
    using the TDD approach. First, we will use TDD to build the `Vote` component we
    introduced in a previous section in this chapter. Then, we will use TDD to create
    a `Registration` component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用React Testing Library通过TDD方法驱动React组件的开发。首先，我们将使用TDD来构建本章前一个部分中引入的`Vote`组件。然后，我们将使用TDD来创建一个`Registration`组件。
- en: Building the Vote component using TDD
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TDD构建投票组件
- en: In the *Testing components that call event handlers* *in isolation* section,
    we built a `Vote Button` component by first building the component and then writing
    tests. In this section, we will use TDD to build the component. First, we plan
    out how the component should look when rendered into the DOM and the actions a
    user should take. We decide the component will be an image button. The parent
    component should pass the image source and image alt text into the component as
    `props`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在*独立测试调用事件处理器的组件*部分，我们首先构建了`Vote Button`组件，然后编写了测试。在本节中，我们将使用TDD来构建组件。首先，我们规划出组件在渲染到DOM时应有的外观以及用户应采取的操作。我们决定组件将是一个图像按钮。父组件应将图像源和图像alt文本作为`props`传递给组件。
- en: 'The component will also accept a Boolean value passed for the `hasVoted` prop
    to set the button''s state to `enabled` or `disabled`. If `hasVoted` is set to
    `true`, a user can click the button to invoke a method that will handle updating
    the vote count. Next, we write tests based on our design. The first test will
    verify the component renders to the screen with the `props` passed in:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 组件还将接受一个用于`hasVoted`属性的布尔值，以设置按钮的状态为`enabled`或`disabled`。如果`hasVoted`设置为`true`，用户可以点击按钮以调用一个方法来处理更新投票计数。接下来，我们根据我们的设计编写测试。第一个测试将验证组件是否以传入的`props`渲染到屏幕上：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, first, we create `jest` functions and assign them to
    the `stubHandleVote` and `stubAltText` variables. We prepend the variable names
    with *stub* because we are only using them as dependency placeholders in the test.
    The variable names also provide more context for their purpose in the test.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建`jest`函数并将它们分配给`stubHandleVote`和`stubAltText`变量。我们在变量名前加上*stub*，因为我们只是在测试中将它们用作依赖占位符。变量名也提供了更多关于它们在测试中用途的上下文。
- en: 'Next, we render the component with `props` values passed in. Then, we grab
    the `image` and `button` elements and assign them to associated variables. Next,
    we will make assertions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用传入的`props`值渲染组件。然后，我们获取`image`和`button`元素并将它们分配给相关变量。接下来，我们将进行断言：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we assert that the `image` and `button` elements are
    on the DOM. We also assert that the button state is `enabled`, meaning a user
    can click it. We create a file for the `Vote Button` component like so:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们断言`image`和`button`元素在DOM中。我们还断言按钮状态为`enabled`，这意味着用户可以点击它。我们创建了一个`Vote
    Button`组件的文件，如下所示：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a `VoteBtn` component that doesn''t currently return any code to
    render in the DOM in the preceding code. We also export the component to be used
    in other files. When we run the test, we get the following output from the test
    results:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`VoteBtn`组件，该组件目前不返回任何代码以在DOM中渲染。我们还导出组件以在其他文件中使用。当我们运行测试时，我们从测试结果中得到了以下输出：
- en: '![Figure 3.17 – TDD Vote Button test step 1'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 – TDD投票按钮测试步骤1'
- en: '](img/Figure_3.17_B16887.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B16887.jpg)'
- en: Figure 3.17 – TDD Vote Button test step 1
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – TDD投票按钮测试步骤1
- en: 'In the preceding screenshot, the `image` element with the name `vote like`
    in the DOM. Since we know the image should be a child of a `button` element, next
    we will resolve the error by creating the `button` element with a child `image`
    element and pass in the required properties in the `VoteBtn` component file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，DOM中的`image`元素名为`vote like`。由于我们知道图像应该是`button`元素的子元素，因此接下来我们将通过在`VoteBtn`组件文件中创建带有子`image`元素的`button`元素并传递所需的属性来解决错误：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the previous code, we create a `button` element with the child `image` element
    and required `props` for the image source, alt text, and disabled attributes.
    Now when we run our test, we receive the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个带有子`image`元素和必需的图像源、alt文本和禁用属性的`button`元素。现在当我们运行测试时，我们得到了以下输出：
- en: '![Figure 3.18 – TDD Vote Button test step 2'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 – TDD投票按钮测试步骤2'
- en: '](img/Figure_3.18_B16887.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.18_B16887.jpg)'
- en: Figure 3.18 – TDD Vote Button test step 2
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – TDD投票按钮测试步骤2
- en: 'In the preceding screenshot, the `Vote Button`, we will write the code allowing
    a user to click the button to invoke a method that will handle updating the vote
    count when `hasVoted` is set to `true`. First, we will create another test to
    target the functionality:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们将编写允许用户点击按钮以调用一个方法来处理在`hasVoted`设置为`true`时更新投票计数的`Vote Button`代码。首先，我们将创建另一个测试来针对该功能：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, first, we create a `jest` function and assign it to
    the variable named `mockHandleVote`. We prepend the variable name with *mock*
    because we will assert against the variable later in the test. Next, we render
    the `VoteBtn` component into the DOM and pass in the required properties. Notice
    that we pass in `mockHandleVote` for the `handleVote` property. Next, we will
    click the button and make assertions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建一个`jest`函数并将其分配给名为`mockHandleVote`的变量。我们在变量名前加上`mock`是因为我们将在测试中对该变量进行断言。接下来，我们将`VoteBtn`组件渲染到DOM中并传入所需的属性。请注意，我们将`mockHandleVote`传递给`handleVote`属性。接下来，我们将点击按钮并进行断言：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, first, we click the button inside the component. Then,
    we assert that `mockHandleVote` was called and called precisely one time. Verifying
    if and how `mockHandleVote` was called is essential. If `mockHandleVote` is not
    called or is called more than once per click, we know the component will not correctly
    communicate when integrated with the parent component. We receive the following
    output when we run the test:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们在组件内部点击按钮。然后，我们断言`mockHandleVote`被调用且恰好调用了一次。验证`mockHandleVote`是否以及如何被调用是至关重要的。如果`mockHandleVote`没有被调用或者每次点击调用次数超过一次，我们知道组件在与父组件集成时将无法正确通信。当我们运行测试时，我们得到以下输出：
- en: '![Figure 3.19 – TDD Vote Button test step 3'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – TDD投票按钮测试步骤3'
- en: '](img/Figure_3.19_B16887.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – TDD投票按钮测试步骤3](img/Figure_3.19_B16887.jpg)'
- en: Figure 3.19 – TDD Vote Button test step 3
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – TDD投票按钮测试步骤3
- en: 'In the preceding code, the `jest` function passed in the component to be called
    at least once, but it was never called. Next, we will resolve the error by adding
    the implementation to the component:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，传入组件的`jest`函数被要求至少调用一次，但它从未被调用。接下来，我们将通过向组件添加实现来解决这个问题：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, we added an `onClick` event handler that will invoke
    the `handleVote` method passed into the component as a property when the button
    is clicked. Now when we run the test, we get the following output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个`onClick`事件处理器，当按钮被点击时，它将调用作为属性传递给组件的`handleVote`方法。现在当我们运行测试时，我们得到以下输出：
- en: '![Figure 3.20 – TDD Vote Button test step 4'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20 – TDD投票按钮测试步骤4'
- en: '](img/Figure_3.20_B16887.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20 – TDD投票按钮测试步骤4](img/Figure_3.20_B16887.jpg)'
- en: Figure 3.20 – TDD Vote Button test step 4
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – TDD投票按钮测试步骤4
- en: In the preceding screenshot, the `Vote Button` have been implemented and tested,
    we have finished building the feature using the TDD approach.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`投票按钮`已被实现并测试，我们已使用TDD方法完成该功能的构建。
- en: In the next section, we will use TDD to create a registration component.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用TDD创建一个注册组件。
- en: Building a registration form using TDD
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TDD构建注册表单
- en: 'In the previous section, we used TDD to build a `Vote` component. In this section,
    we will use TDD to build a component used to create user accounts for a website.
    Then, once we build the minimal functionality to make the test pass, we will also
    refactor the component''s implementation and verify the test continues to pass.
    The component will have a `heading` element, `email` and `password` fields, and
    a `handleSubmit` method should be invoked. The final version of the component
    should look like the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用TDD构建了一个`Vote`组件。在本节中，我们将使用TDD构建用于创建网站用户账户的组件。然后，一旦我们构建了使测试通过的最小功能，我们还将重构组件的实现并验证测试是否继续通过。该组件将包含一个`heading`元素、`email`和`password`字段，并且应该调用`handleSubmit`方法。组件的最终版本应该如下所示：
- en: '![Figure 3.21 – Registration form](img/Figure_3.21_B16887.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 注册表单](img/Figure_3.21_B16887.jpg)'
- en: Figure 3.21 – Registration form
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 注册表单
- en: 'In the preceding screenshot, we have a form allowing users to submit an email
    and password to register an account for a website. Now that we understand how
    the final version should look on the screen, we will write a test based on our
    design. For purposes of this section, we will verify that a `handleRegister` method
    is called when the form is submitted:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们有一个允许用户提交电子邮件和密码以注册网站账户的表单。现在我们了解了最终版本在屏幕上应该看起来是什么样子，我们将根据我们的设计编写一个测试。为了本节的目的，我们将验证当表单提交时是否调用`handleRegister`方法：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we create `mockHandleRegister` and `mockValues` variables.
    The variables will be asserted against later in the test. Then, we render the
    component under test into the DOM and pass in `mockHandleRegister`. Now, `mockHandleRegister`
    will allow us to test the `Register` component in isolation from the `handleRegister`
    dependency. Next, we will enter values in the form fields:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建 `mockHandleRegister` 和 `mockValues` 变量。这些变量将在测试的后续部分被断言。然后，我们将测试组件渲染到
    DOM 中，并传入 `mockHandleRegister`。现在，`mockHandleRegister` 将允许我们独立于 `handleRegister`
    依赖项测试 `Register` 组件。接下来，我们将输入表单字段中的值：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code, we enter values from the `mockValues` object into the
    `email` and `password` fields. Notice the use of string values passed into the
    `getByLabelText` queries. String values are another option for queries when you
    do not want to use a regular expression. Next, we will make assertions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将 `mockValues` 对象中的值输入到 `email` 和 `password` 字段中。注意 `getByLabelText`
    查询中使用的字符串值。当您不想使用正则表达式时，字符串值是查询的另一种选项。接下来，我们将进行断言：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we expect `mockHandleRegister` to be called once. Finally,
    we expect values from the `mockValues` object to have been included as arguments
    when `mockHandleRegister` was called. Verifying the arguments passed to `mockHandleRegister`
    is important because it helps reduce the risk that form values will not be passed
    to `handleRegister`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们期望 `mockHandleRegister` 被调用一次。最后，我们期望在调用 `mockHandleRegister` 时，`mockValues`
    对象的值被作为参数包含在内。验证传递给 `mockHandleRegister` 的参数很重要，因为它有助于降低表单值未传递给 `handleRegister`
    的风险。
- en: 'Next, we will create a file for the `Register` component like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `Register` 组件的文件，如下所示：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We create and export a `Register` component that doesn''t currently return
    any code to render in the DOM in the preceding code. When we run the test, we
    get the following output from the test results:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建并导出 `Register` 组件，该组件目前不返回任何要在 DOM 中渲染的代码。当我们运行测试时，我们从测试结果中得到以下输出：
- en: '![Figure 3.22 – TDD registration test step 1](img/Figure_3.22_B16887.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – TDD 注册测试步骤 1](img/Figure_3.22_B16887.jpg)'
- en: Figure 3.22 – TDD registration test step 1
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – TDD 注册测试步骤 1
- en: 'In the preceding screenshot, the `email` field element in the DOM. Next, we
    will resolve the error by creating the `email` field. We will also create the
    `password` field and the **Submit** button:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，DOM 中的 `email` 字段元素。接下来，我们将通过创建 `email` 字段来解决错误。我们还将创建 `password`
    字段和 **提交** 按钮：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code, first, we create a `state` object to store values entered
    for the `email` and `password` fields. Next, we create a `handleChange` method
    that will be called anytime a user enters a value into a form field. The `handleChange`
    method will update `state` values based on the `form` field that is changed. Next,
    we create the `heading` element and an `email` field:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建一个 `state` 对象来存储 `email` 和 `password` 字段输入的值。接下来，我们创建一个 `handleChange`
    方法，该方法将在用户在任何表单字段中输入值时被调用。`handleChange` 方法将根据更改的 `form` 字段更新 `state` 值。然后，我们创建
    `heading` 元素和一个 `email` 字段：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, first, we create a `main` element to wrap the `heading`
    and `form` elements. Inside `main`, we create the `form` element and add a field
    for users to enter an email address. When a user enters a value into the field,
    an `onChange` event handler is invoked to call `handleChange` to update the state
    object''s associated value. The field''s `value` attribute always displays the
    current value stored in the state object''s associated key. Next, we will create
    a field for users to enter a password and a `button` element to submit the form:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建一个 `main` 元素来包裹 `heading` 和 `form` 元素。在 `main` 内部，我们创建 `form`
    元素并为用户添加一个输入电子邮件地址的字段。当用户在字段中输入值时，将调用 `onChange` 事件处理器来调用 `handleChange` 以更新状态对象的相关值。字段的
    `value` 属性始终显示状态对象相关键中存储的当前值。接下来，我们将为用户创建一个输入密码的字段和一个用于提交表单的 `button` 元素：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding code, first, we create a `password` field. The field has the
    same event handler methods as the `email` field. Finally, we make a **Submit**
    button to allow a user to submit values entered in the form. Now when we run the
    test, we get the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建一个 `password` 字段。该字段具有与 `email` 字段相同的处理程序方法。最后，我们创建一个 **提交**
    按钮以允许用户提交表单中的输入值。现在当我们运行测试时，我们得到以下输出：
- en: '![Figure 3.23 – TDD registration test step 2](img/Figure_3.23_B16887.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.23 – TDD 注册测试步骤 2](img/Figure_3.23_B16887.jpg)'
- en: Figure 3.23 – TDD registration test step 2
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – TDD 注册测试步骤 2
- en: In the preceding code, our test is still failing, but for a different reason.
    Now the test can enter values and submit the form, but `mockHandleRegister` was
    not called with the submitted values. The failure happened because we have not
    yet implemented an `onSubmit` event handler to call our `mockHandleRegister` method
    and any other desired behavior when the form is submitted.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的测试仍然失败，但原因不同。现在测试可以输入值并提交表单，但 `mockHandleRegister` 没有被调用以提交的值。失败发生因为我们还没有实现一个
    `onSubmit` 事件处理器来调用我们的 `mockHandleRegister` 方法以及表单提交时任何其他期望的行为。
- en: 'Next, we will resolve the error by adding an `onSubmit` handler to the form
    and have it call a `handleSubmit` method that we will create:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过向表单添加 `onSubmit` 处理器并调用我们创建的 `handleSubmit` 方法来解决错误：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, we create the `handleSubmit` method. When `handleSubmit`
    is invoked, the browser `event` that triggered the method is passed into it. Next,
    we prevent the browser''s normal behavior of refreshing the page after submitting
    a form using the `preventDefault` method. Finally, we call `handleRegister`, provided
    to the component as `props`, and pass in the form values stored in the `state`
    object. Next, we will attach `handleSubmit` to the form:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了 `handleSubmit` 方法。当 `handleSubmit` 被调用时，触发该方法的浏览器 `event` 会被传递给它。接下来，我们使用
    `preventDefault` 方法防止浏览器在提交表单后刷新页面。最后，我们调用作为 `props` 提供给组件的 `handleRegister`，并传递存储在
    `state` 对象中的表单值。接下来，我们将 `handleSubmit` 附接到表单上：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code, we add an `onSubmit` event handler and pass in `handleSubmit`.
    When the form is submitted, `handleSubmit` will be called, resulting in `handleRegister`
    being called, with the form values as arguments. Now when we run the test, we
    get the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个 `onSubmit` 事件处理器，并传递了 `handleSubmit`。当表单提交时，`handleSubmit` 会被调用，导致
    `handleRegister` 被调用，表单值作为参数。现在当我们运行测试时，我们得到以下输出：
- en: '![Figure 3.24 – TDD registration test step 3](img/Figure_3.24_B16887.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – TDD 注册测试步骤 3](img/Figure_3.24_B16887.jpg)'
- en: Figure 3.24 – TDD registration test step 3
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – TDD 注册测试步骤 3
- en: 'The preceding screenshot shows that our test is finally passing. Technically,
    we could stop here since our code makes our test pass. However, we can make our
    component code cleaner by converting it from a class component into a function
    component. As long as the behavior remains the same, our test should continue
    to pass. We can refactor the component like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示，我们的测试最终通过了。技术上，我们可以在这里停止，因为我们的代码使测试通过。然而，我们可以通过将组件代码从类组件转换为函数组件来使代码更简洁。只要行为保持不变，我们的测试应该继续通过。我们可以像这样重构组件：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding code, first, we convert the class into a function. Then, we
    use the `useState` hook to manage the form value state. Next, we will refactor
    our `handleChange` and `handleSubmit` methods:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们将类转换为函数。然后，我们使用 `useState` 钩子来管理表单值状态。接下来，我们将重构我们的 `handleChange`
    和 `handleSubmit` 方法：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the previous code, the `handleChange` class and `handleSubmit` methods are
    converted to function expressions. The `handleChange` method calls `setValues`
    to update the state for each entered form value. The implementation of `handleSubmit`
    is virtually the same as the class version. Next, we will refactor the returned
    code that renders as HTML in the browser:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`handleChange` 类和 `handleSubmit` 方法被转换为函数表达式。`handleChange` 方法调用 `setValues`
    来更新每个输入表单值的州。`handleSubmit` 的实现几乎与类版本相同。接下来，我们将重构返回的代码，该代码在浏览器中以 HTML 的形式渲染：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, first, we remove the `render` method required in `class`
    components. The remainder of the code is very similar to the class version. However,
    the `value` attribute uses the `values` object, and the `handleChange` method
    passed in to the `onChange` event handler does not need to include the `this`
    keyword. When we rerun our test, we get the following result:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们移除了 `class` 组件中所需的 `render` 方法。其余的代码与类版本非常相似。然而，`value` 属性使用 `values`
    对象，并且传递给 `onChange` 事件处理器的 `handleChange` 方法不需要包含 `this` 关键字。当我们重新运行我们的测试时，我们得到以下结果：
- en: '![Figure 3.25 – TDD registration test step 4](img/Figure_3.25_B16887.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25 – TDD 注册测试步骤 4](img/Figure_3.25_B16887.jpg)'
- en: Figure 3.25 – TDD registration test step 4
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – TDD 注册测试步骤 4
- en: In the preceding screenshot, our test still passes after the refactor. The `refactor`
    component made our code a lot cleaner. Now you understand how to build a component
    using TDD with React Testing Library. In this section, we used TDD to drive the
    creation of vote and registration features. The test result feedback that React
    Testing Library provides makes for a pleasant experience to guide development.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，经过重构后我们的测试仍然通过。`refactor`组件使我们的代码变得更加整洁。现在你了解了如何使用 React Testing Library
    通过 TDD 来构建组件。在本节中，我们使用 TDD 来驱动投票和注册功能的创建。React Testing Library 提供的测试结果反馈使得开发过程更加愉快。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to install and use a module to simulate user
    actions on the resulting DOM output for components. You can now install and test
    features that interact with APIs with a user-friendly tool. You understand how
    to test components in isolation from event handler dependencies with mock functions.
    Finally, you learned how to implement the TDD approach to building features combined
    with React Testing Library.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何安装和使用模块来模拟组件在最终 DOM 输出上的用户操作。你现在可以使用一个用户友好的工具安装和测试与 API 交互的功能。你理解了如何使用模拟函数将组件与事件处理程序依赖项隔离来测试组件。最后，你学习了如何结合
    React Testing Library 实现构建功能的 TDD 方法。
- en: In the next chapter, we will dive deeper by learning the benefits of integration
    testing. We will also learn how to test React components that utilize popular
    third-party libraries.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习集成测试的好处来深入探讨。我们还将学习如何测试使用流行第三方库的 React 组件。
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why should you favor `user-event` over `fireEvent` to simulate user actions
    in your tests?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你应该在测试中优先选择`user-event`而不是`fireEvent`来模拟用户操作？
- en: Explain how MSW allows you to test components that make requests to APIs.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释 MSW 如何允许你测试向 API 发起请求的组件。
- en: What is a mock function?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟函数是什么？
- en: Explain the application risk associated with testing components in isolation
    with mock functions.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释使用模拟函数单独测试组件的应用风险。
- en: In your own words, describe the TDD workflow.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话描述 TDD 工作流程。
- en: Explain when to use a `getBy*`, `findBy*`, or `queryBy*` query to select an
    element.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释何时使用 `getBy*`、`findBy*` 或 `queryBy*` 查询来选择元素。
