- en: Implementing Flux Architecture with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Flux concepts clear in our minds, we will now explore the Vuex framework,
    understand how it works, and, with the help of some examples, see how you can
    use Vuex inside your Vue applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex at a glance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The boilerplate code that will be used to run the examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vue.js reactivity system explained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the core concepts of Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling strict mode while developing to prevent accidental direct state modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrictions in form handling when using Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple counter: all the Vuex concepts in a very simple example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first section introduces you to Vuex, focusing on the concepts behind the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the second section, you will be presented with a minimal HTML code to run
    the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the third section, the Vue reactivity system is examined in detail. This
    is useful because Vuex exploits this reactivity system to plug itself seemlessly
    into the Vue application's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth section, all Vuex core concepts are thoroughly examined, and,
    with the help of code snippets, you will see that Vuex is both powerful and simple
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth and sixth sections will explain some concepts to keep in mind when
    using Vuex inside your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last part of this chapter, a simple example will show you most
    of the Vuex concepts put together in a single HTML file, helping you to understand
    the whole picture.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have read this chapter, you will have a clear understanding of the
    Vuex framework, and you will be ready to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2](https://github.com/PacktPublishing/Vuex-Quick-Start-Guide/tree/master/chapter-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/2zXEav](https://goo.gl/2zXEav)'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex at a glance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml), *Rethinking User
    Interfaces with Flux, Vue and Vuex*, we defined Vuex as *a state management pattern
    + library for Vue.js applications. It serves as a centralized store for all the
    components in an application, with rules ensuring that the state can only be mutated
    in a predictable fashion*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although I think that, having read [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml),
    *Rethinking User Interfaces with Flux, Vue and* definition should sound clear
    enough to you, it is still a bit obscure. Let''s list down the three concepts
    contained in the preceding sentences:'
  prefs: []
  type: TYPE_NORMAL
- en: The centralized store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that the state can only be mutated in a predictable way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vue reactivity system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look back to *Figure 1.6* in *Flux architecture summarized* section in
    [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml), *Rethinking User Interfaces
    with Flux, Vue and Vuex*, you will see that the Flux architecture has one dispatcher
    that dispatches actions to every store. Having only one store means that the dispatcher
    can be inside the store and you can dispatch actions using the centralized store.
    In Vuex, we have a single store and its state is called **single state tree**.
  prefs: []
  type: TYPE_NORMAL
- en: One fundamental rule in Flux and Vuex is that the state can be mutated only
    because of an action. No component, class, or piece of code should modify the
    state. Only the code that is linked to an action can actually change the state
    values. this by using mutations that can only be executed by actions. In this,
    Vuex differs from Flux. In Flux, actions are just data objects containing the
    information about the action to be performed. In Vuex, actions can execute code
    that will eventually end by committing one or more mutations that will change
    the state. You will read about mutations and actions later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after an action has been dispatched and the state has been updated,
    it must notify the views of the application of the fact that has changed. This
    is done by taking advantage of the Vue reactivity system, which is the topic of
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Boilerplate code for the examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next few pages, you will be provided with some examples. In order to
    execute these examples, you need to create an HTML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By copying the example code inside the `<script>` tag, you can run it and see
    the results. Almost every example code can be found in the Git repository of this
    book, under the `/chapter-2/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js reactivity system explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the powerful features of Vue is its reactivity system. It is an unobtrusive
    way to detect changes to the components model. A component model is just a plain
    JavaScript object. When it changes, Vue detects the changes and updates the corresponding
    views. In Vuex, the single state tree is reactive, like the `data` part of a Vue
    component.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand how the reactivity system works to avoid some
    common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to detect whether a value inside a JavaScript object has
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `Proxy` feature, which is defined in ECMAScript 2015 (6th Edition,
    ECMA-262)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using `Object.defineProperty`, which is defined in ECMAScript 2011 (5.1 Edition,
    ECMA-262)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For compatibility reasons, Vue decided to use `Object.defineProperty`, which
    means that there are some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a component, Vue will walk through all the properties of the
    `data` part and use `Object.defineProperty` to convert them into `getter`/`setter`
    methods. For this reason, Vue can only detect changes to properties that have
    been defined in the `data` part of a component. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `counter` property is not declared in the `data` section
    of the component. This prevents Vue from detecting that `counter` has been changed,
    and so, when a user clicks on the button Begin!, they will not see the counter
    increasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be easily fixed by adding `counter` to the `data` section and removing
    it from the `created()` method. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can find the code for the preceding example in the Git repository of this
    book, inside the file `chapter-2/counterTo3/counter.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `Arrays`, Vue cannot detect the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a value directly using the index—for example, `this.items[indexOfItem]
    = newItem`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the array length—for example, `this.items.length = newLength`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid these problems, you could either create a new array and assign it
    to the corresponding data property, or use array methods, such as `push()` or
    `splice()`. The following are different ways to update an array observed by Vue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We now understood that every time we properly change something inside a component
    model or inside the single state tree, Vue detects it and updates the corresponding
    views accordingly. But what about performance? Isn''t it bad to update the views
    on each modification? In fact, Vue exploits how the JavaScript event loop works
    to queue all the updates to the views. To understand this concept, let''s focus
    on the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output (which may vary on different browsers) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, the JavaScript virtual machine executes the synchronous code that prints
    `start` and `end`, then it executes all the jobs queued during the execution,
    printing `promise` and `timeout`.
  prefs: []
  type: TYPE_NORMAL
- en: Vue uses `Promise` if it is available on the user browser; otherwise, it tries
    to find the best scheduling function, with a fallback to `setTimeout` in case
    no other supported scheduling function has been found. Today, `Promise` is supported
    in almost every browser, mobile, and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the core concepts of Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is now time to introduce the Vuex architecture, which consists of five core
    concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Single state tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each concept will be discussed in detail, with some pieces of code that will
    help to make it clear. Once you have read the following pages, you will have a
    clear understanding of Vuex architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Vuex store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex implements Flux stores using a single state tree. In this, it differs from
    Flux because in Flux there could be more than one store. You may think that a
    single store/state is not good for modularity. Later, we will see how to split
    the single state tree into modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having only one store has some benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It is available in every component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to debug since all the application state is there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can write unobstructive plugins that watch the state and perform an action,
    such as persisting the state for later retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single state tree contains all the application-level data—it represents
    the application domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the single state tree inside components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now see how to use this single state tree inside a `Vue` component using
    an example. Say that we want to show the number of unread messages in a chat session.
    Somewhere in the application, this number gets updated and the `NumUnreadMessages`
    component shows this number. The following is an example of how the component
    could be coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is straightforward—you just need to use `this.$store.state`
    to access the application state. In order to have `this.$store` available inside
    Vue `components`, you need to add the store to the `Vue` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can find the code for this example in the Git repository of this book, inside
    the file `chapter-2/unread-messages/unread.html`.
  prefs: []
  type: TYPE_NORMAL
- en: The mapState helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a computed property every time we want to access the state could be
    tedious and verbose, especially if a component needs more than one state property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Vuex provides a handy tool called `mapState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the computed property `unreadCounter` is mapped to `this.$store.state.unreadCounter`.
    Since `mapState` is not well documented, I am going to explain all the ways that
    you can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use functions, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`unreadCounter` is an arrow function, whereas `unreadCounterAlias` is a normal
    function. If you want to access the local state of the component, you must use
    a function and not an arrow function; otherwise, you cannot use the `this` keyword
    inside the arrow function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `strings`, as shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a much more concise way that can be used if the name of the
    `state` property and the name of the `computed` property are the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you just need to pass an array of strings to `mapState`, where
    each string is the name of the `state` property you want to map.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder how you can mix local computed properties with the ones coming
    from `mapState.` Here is an example using the ECMAScript 6 object spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the ES6 object spread operator `...` is not yet commonly known among
    programmers, especially when used with objects. See the following example if this
    operator sounds new to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Components' local state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if there is a global single state tree, it doesn't mean that components
    cannot have a local state. What is in the global state is application-wide and
    should not be polluted with the component's private state. For example, text parts
    of a component are likely to be used only inside the component, and for this reason,
    they should not be put into the application state.
  prefs: []
  type: TYPE_NORMAL
- en: Computing a derived state with getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes two or more components need a derived state based on the values inside
    the state. You could compute the derived state inside every component, but this
    means duplicating code, which is not acceptable. To avoid this, you could create
    an external function or utility class to compute the derived state, which is better
    than duplicating the code. However, Vuex provides getter functions so that we
    can write derived state code inside the application store, avoiding all these
    unnecessary steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that the app state contains a list of messages, and, when
    a new message is added to that list, it gets marked as `unread`. We could then
    write a `getter` function that returns all the unread messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A `getter` function also receives all the `getters` as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update the unread messages example using `getter` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will find the code for the following example in the Git repository of this
    book, inside the file named `chapter-2/unread-messages/unread-with-getters.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Getter` functions can also receive parameters, making them useful when executing
    queries regarding the state. To receive parameters, the `getter` functions must
    return a function that receives the parameters. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As for the state, there is a `mapState` helper. For getters, there is a `mapGetters`
    helper.
  prefs: []
  type: TYPE_NORMAL
- en: The mapGetters helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `mapGetters` helper simply maps store `getters` to local computed properties.
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As for `mapState`, we can use an array to list all the `getters` properties
    we want to map to a corresponding computed property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the name of the computed property is different from the `getter` name, you
    can use an object instead of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will find the code for this updated example of unread messages in the Git
    repository of this book, inside the file named `chapter-2/unread-messages/unread-with-getters-and-mapgetters.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the application state with mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have only seen how the app state can be retrieved. It is time
    to introduce mutations. Using mutations is the only way you can change the state.
    If you remember, Flux only allows actions to mutate the state. In Vuex, actions
    are split into actions and mutations. We will introduce actions later—here, we
    will focus on mutations and how we can change the state using Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to change the state, you need to commit a mutation. A mutation is
    similar to an event: you declare the mutation, which is a kind of event type,
    and link the mutation to a piece of code, which is like an event handler. From
    this point of view, Vuex can be seen as an evolution of the `EventBus` pattern,
    which was discussed in [Chapter 1](7f46d03c-2f58-4773-ad55-985fa1e74b56.xhtml),
    *Rethinking User Interfaces with Flux, Vue and Vuex*, as a possible solution to
    let MVC components communicate with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutations are declared in the `mutations` section of the `config` object provided
    to the `Vuex.Store(...)` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Commiting a mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You cannot call a mutation handler directly. Instead, you can commit the mutation
    using `store.commit(mutationName, payload)`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will add a message to the `messages` array of the application state.
  prefs: []
  type: TYPE_NORMAL
- en: The `payload` parameter can be a primitive type or an object with all the properties
    that the mutation needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use an object-style commit, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since with a mutation you change the state that is reactive, it is recommended
    that you follow some best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize all the properties of the state so that they represent the initial
    state of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that when you modify or add a new property to the state, `Vue` will detect
    the modification, as discussed in the reactivity section of this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a complete example where a user can add a message and see
    the message list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating mutation types using constant strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every time you want to commit a mutation, you need to write the type of mutation
    you want to perform. Scattering strings among the code is considered bad practice
    and has the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is error-prone: typos or wrong casing could occur when typing the mutation
    type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hard to rename a type, since you have to search for all the occurrences
    of that string in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not clear which module that mutation comes from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, it is better to use constant strings to define all the mutation
    types. Using uppercase will prevent wrong casing, and using constants variables
    will allow most editors to highlight occurrences. In addition, editors usually
    provide a way to rename variables, such as string constants, making it easy to
    rename a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation types should be defined inside a file with all the possible mutations
    of the application, or of the module if the application is split into modules.
    In this way, it is easier to understand all the changes the application state
    can be subjected to. In fact, if you remember, Vuex promises that the state will
    be changed in a predictable fashion. Say that a new programmer participates in
    your project. You could sit next to them and start explaining what the application
    does. You will soon find out that they can understand what happens when a user
    performs an action without your help. In fact, they just need to follow the flow
    from the action fired inside a `Vue` component to the corresponding state mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example illustrating how to use constant mutation types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Mutations must be synchronous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important rule when using Vuex is that *mutation handler functions must
    be synchronous*. Unfortunately, this cannot be enforced through JavaScript language,
    so Vuex cannot ensure that you follow this rule. This means that this rule is
    a best practice that must be followed when coding your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example that shows this rule being violated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, first `state.currentBook` is set with some partial data from
    the book, then, when the server provides the requested book details, the `state.currentBook`
    state gets updated with all the book details.
  prefs: []
  type: TYPE_NORMAL
- en: Showing book data as soon as possible is a good idea. We don't want the user
    to see a blank page until the server provides all the requested information. But
    asynchronicity must be dealt with somewhere else—more precisely, inside an `action`.
  prefs: []
  type: TYPE_NORMAL
- en: But what could happen in the preceding example? In the best case scenario, the
    book's partial data is displayed and a few moments later, all the book details
    are shown. But `api.getBookDetailsById(...)` could take longer than expected,
    or it can even fail. In these last cases, the result will be an incoherent application
    state. What if `state.currentBook` gets modified by the user before the server
    provides the book details?
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these problems, when a mutation is committed, the application state
    must move from a well-defined state to another well-defined state in a synchronous
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: The mapMutations helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As for the state and getters, there is a helper to save us some keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example, where a user can add a message, can be refactored using the `mapMutations`
    helper, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `mapMutations(...)` creates an `addNewMessage` method that calls
    `this.$store.commit(ADD_NEW_MESSAGE, payload)` when executed.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the code for the preceding example with and without `mapMutations`
    inside the `chapter-2/add-message` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Committing mutations within actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced earlier, Vuex splits Flux actions into mutations and actions.
    Mutations must be synchronous, so actions are where asynchronous code can be written.
    The idea is that mutations are well-defined state modifications and actions commit
    mutations to change the application state. For example, an action could request
    some data from the server, and when the server responds, commit a mutation using
    the data it just obtained.
  prefs: []
  type: TYPE_NORMAL
- en: In short, actions can change the state by committing mutations and can perform
    asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Action declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how actions are declared inside a `Vuex` store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In a similar way as that used for mutations, to declare an action, you write
    the action method inside the `actions` section of the `config` object provided
    to the `Vuex` store.
  prefs: []
  type: TYPE_NORMAL
- en: The action receives a `context` object and the action payload. The `context`
    object contains a `commit(...)` method and the `state` property, which is the
    application state.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `addMessage(...)` action sends the message text
    to a hypothetical server and, after the server response, it commits the corresponding
    mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatching an action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember, Flux has a single dispatcher that dispatches actions to every
    store. It is the same in Vuex, except that there is only a single store, which
    is also a dispatcher. This means that actions can be dispatched using the store,
    as shown in the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, I updated the `add message` example to use the `addMessage`
    action instead of directly using the `addNewMessage` mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You are probably now thinking that there must be some helper to dispatch actions...
    in fact, there is!
  prefs: []
  type: TYPE_NORMAL
- en: The mapActions helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the other helpers, the `mapActions` helper can be used inside the
    `methods` section of a `Vue` component. The syntax is the same as that of the
    other helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using modules for better scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex's single state tree can be divided into modules. This is useful when the
    application grows larger and you want to split the app into groups of features.
    Doing so also lets you only load core features when the page loads, and allows
    you to load the other functionalities later. This way, you can reduce loading
    times drastically, especially if the connection is slow or the application is
    run inside a low-end mobile phone. It takes time for the JavaScript virtual machine
    to parse all the JavaScript code, thus providing only a single huge file with
    all the application code will take seconds to be parsed, giving a mobile user
    the impression that the application is slow and heavy.
  prefs: []
  type: TYPE_NORMAL
- en: A good tool to use in combination with Vue/Vuex is webpack, which lets you split
    your application into bundles. A webpack bundle can contain one or more Vuex modules,
    and a module can be loaded after another module. You can find more information
    about webpack at [https://webpack.js.org/](https://webpack.js.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The application state tree can be split into modules, and each module into
    submodules. Let''s see how this can be coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the object passed to `new Vuex.store({})` is just the root module
    of your app, and inside the root module, or any other module, you can declare
    other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Module local state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state object passed to `mutations`, `actions`, and `getters` is the local
    module state. In this way, a submodule doesn't need to know it is inside another
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if a submodule wants to access a parent module? The `rootState` is
    provided inside `actions` and `getters` so that you can navigate down to the desired
    module from the `rootState`. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that inside an action, the `rootState` is a property
    of the parameter `context` that is passed to the action, whereas inside a `getter`,
    the `rootState` is passed as the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Module with namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be collisions between the names among different modules. To avoid
    this, and to create `reusable` modules, you can set the module''s `namespaced`
    property to `true`. The following is an example of a `namespaced` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The code inside a module doesn''t change when the `namespaced` property is
    set to `true`. What changes is the code that wants to use another `namespace`
    module. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To commit a mutation or dispatch an action of another module, you need to add
    `{ root: true }` as the third parameter. There is also a `rootGetters` parameter
    that is provided to the `actions` handlers or `getters` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when using Vuex helpers, you need to specify the namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can create namespaced helpers using the function `createNamespacedHelpers(nameSpace)`
    which returns all the helpers inside an object. These helpers are bound to the
    namespace you provided as the first argument. The following is an example of how
    to use `createNamespacedHelpers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At the end of this chapter, you will find an example of two modules with the
    `namespace` parameter set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic module registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to register a module after a Vuex store has been created using
    the `store.registerModule(...)` method. The following is an example of how a module
    can be registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is particularly useful when modules are loaded asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is `loaded-later-moudle.js` file code, which gets loaded inside `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the root module defines a `currentView` property that
    points to the `initial` component. With the dynamic import syntax, we import the
    `loaded-later-moudle.js` file, and after it has been loaded we execute the module
    code that replaces the `currentView` value, causing the `later` component to be
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example works inside a browser that supports dynamic import syntax,
    or you can use webpack to build it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also unregister a dynamic loaded module by using `store.unregisterModule(moduleName)`
    . Static loaded modules cannot be unregistered.
  prefs: []
  type: TYPE_NORMAL
- en: Module reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with Vue `components`, in order to reuse a module, the state declaration
    needs to be a function returning the state instead of a plain object. Otherwise,
    the state object is shared among all the module users. There are two cases where
    this may happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Where multiple stores are using the same module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the same module has been registered more than once in the same store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first case is unlikely to happen because Vuex uses a single store. Besides,
    you can always create more than one store, even though you can register only one
    store per Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: The second case is likely to happen if the module is general purpose and depends
    on some parameters. In the same way that classes can have constructor parameters,
    a module could be created using a factory method with parameters. For example,
    say that you have two similar RESTful APIs and you created a generic API module
    so that the module can be used for both the APIs. In this case, you will use two
    instances of the same module, one for each API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to create a `reusable` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Enabling strict mode while developing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `Vuex` is in strict mode, it will throw an error if the single state tree
    is mutated outside mutation handlers. This is useful when developing to prevent
    accidental modifications to the state. To enable strict mode, you just need to
    add `strict: true` to the store configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Strict mode should not be used in production*. Strict mode runs a synchronous
    deep watcher on the state tree for detecting inappropriate mutations, and this
    can slow down the application. To avoid changing strict to `false` each time you
    want to create a production bundle, you should use a build tool that makes the
    strict value `false` when creating the production bundle. For example, you could
    use the following snippet in conjunction with webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 3](bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml), *Implementing Notes
    App Using* *Vuex State Management,* you will be shown how to use webpack to enable/disable
    strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: Form handling restrictions when using Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Vue's `v-model` feature with the Vuex state results in a direct modification
    of the state, which is forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `$store.state` is mutated directly by `v-model`, and if strict
    mode is enabled, it will result in an error being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is more than one way to solve this problem, and I will show you the one
    that, in my opinion, is better: You can use a mutable computed property that accesses
    the `state` property when read and commits a mutation when set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using a mutable computed property also allows you to add some validation before
    committing the corresponding mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a possible code for the mutation that gets committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: A simple counter example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a very simple example of a counter that summarizes the core
    concepts of Vuex in a self-contained HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example shows two counters. The first one just increments or
    decrements the current value. The second one, FizzBuzz, shows *Fizz* if the counter
    is divisible by `3`, *Buzz* if it is divisible by `5`, and FizzBuzz when it is
    both divisible by `3` and `5`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/962ea5a9-c923-46f3-8733-630cb1944b91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: FizzBuzz counter'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I created two modules and two components that use these modules:
    one for the `sequential` counter and the other for the `fizzBuzz` counter.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, I created a new instance of `Vue` and added the two modules and
    components to it. The aim of this example is to show you how to use `namespaced`
    modules, as well as to serve as a full but simple example of Vue and Vuex combined
    together.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the example source code inside the GitHub repository of this book
    in the `chapter-2/fizzbuzz-counter` folder .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied the Vuex framework. We went through its core concepts
    and saw how Vuex can be integrated into a Vue application. At the end, a simple
    counter example helped us to get the whole picture.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to move from a simple example to real application development
    using Vuex. That is the topic of [Chapter 3](bf5c8728-bcfd-4db0-abe4-6ef1fe22185c.xhtml),
    *Implementing the Notes App Using Vuex State Management*, developing an application
    that takes notes in a similar way to Google Keep or Evernote.
  prefs: []
  type: TYPE_NORMAL
