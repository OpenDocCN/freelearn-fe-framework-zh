- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing States and Connecting Backends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理状态和连接后端
- en: In the previous chapter, you learned how to build an app that works fine and
    looks great. In this chapter, we will focus on data. First, you will learn how
    to handle more complex data in your app. Then, you’ll learn about different options
    regarding how to make your app communicate with the rest of the world by connecting
    it to remote backends.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何构建一个运行良好且外观出色的应用程序。在本章中，我们将关注数据。首先，你将学习如何在你的应用程序中处理更复杂的数据。然后，你将了解有关如何通过连接远程后端使你的应用程序与世界其他部分通信的不同选项。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Managing global application states
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理全局应用程序状态
- en: Working with global state management solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局状态管理解决方案
- en: Connecting to remote backends
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到远程后端
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you must set up the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，你必须设置以下内容：
- en: A working React Native environment ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的 React Native 环境 ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn) – React
    Native CLI 快速入门)。
- en: While most of this chapter should also work on Windows, I recommend working
    on a Mac.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然本章的大部分内容也应该在 Windows 上运行，但我建议你在 Mac 上工作。
- en: To check out the simple examples, you can use [https://codesandbox.io/](https://codesandbox.io/)
    and import `react-native-web` as a dependency. This provides all React Native
    components and transforms them into HTML tags.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看简单示例，你可以使用 [https://codesandbox.io/](https://codesandbox.io/) 并将 `react-native-web`
    作为依赖项导入。这提供了所有 React Native 组件并将它们转换为 HTML 标签。
- en: Managing global application states
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理全局应用程序状态
- en: Since React Native is based on React, managing the application state does not
    differ much from React applications. There are dozens of well-maintained and working
    state management libraries available, all of which you can use in React Native.
    However, having a good plan and knowing how to manage the application state is
    much more important in an app than in a web application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React Native 基于 React，管理应用程序状态与 React 应用程序没有太大区别。有数十个维护良好且可用的状态管理库，你都可以在
    React Native 中使用。然而，在应用程序中，有一个良好的计划和知道如何管理应用程序状态比在 Web 应用程序中更为重要。
- en: While it might be acceptable to wait a couple of seconds for data to appear
    or for a new page to load, this is not the case in a mobile app. Users are used
    to seeing information or changes immediately. So, you have to ensure that this
    also is the case in your app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然等待几秒钟数据出现或新页面加载可能是可以接受的，但在移动应用程序中并非如此。用户习惯于立即看到信息或变化。因此，你必须确保在你的应用程序中也是如此。
- en: In this section, we’ll have a look at the most popular state management solutions,
    but first, you’ll learn about the different state management patterns and which
    one you should use for your project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨最流行的状态管理解决方案，但首先，你将了解不同的状态管理模式以及你应该为你的项目使用哪一个。
- en: Passing properties
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递属性
- en: While it may work fine to only work with local component states in small applications
    and example projects, this approach is very limited. There are a lot of use cases
    where you have to share data between different components. The bigger your application
    grows, the more components you will have, and the more layers you will have to
    pass your data through.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在小应用程序和示例项目中仅使用本地组件状态可能运行良好，但这种方法非常有限。有许多用例需要在不同组件之间共享数据。你的应用程序越大，你将拥有的组件就越多，你需要传递数据的层级就越多。
- en: 'The following diagram shows the main problem:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了主要问题：
- en: '![Figure 5.1 – State management without a global state management solution'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 无全局状态管理解决方案的状态管理'
- en: '](img/B16694_05_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_05_01.jpg](img/B16694_05_01.jpg)'
- en: Figure 5.1 – State management without a global state management solution
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 无全局状态管理解决方案的状态管理
- en: 'The preceding diagram shows a very simple example that’s very close to our
    example app, but you can already see the main problem: the app contains two tabs,
    one to show content and one to provide an individual user area. This second tab
    contains a login functionality, which is extracted in a login component.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了一个非常简单的示例，与我们的示例应用程序非常接近，但你已经可以看到主要问题：应用程序包含两个标签页，一个用于显示内容，另一个提供个人用户区域。第二个标签页包含一个登录功能，该功能被提取到一个登录组件中。
- en: The **Content** tab contains a dashboard component, which is mainly for showing
    content. But we also want to be able to adapt this content to the user. So, we
    need the information about the user in the dashboard component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**标签页包含一个仪表板组件，主要用于显示内容。但我们也希望能够适应用户的内容。因此，我们需要在仪表板组件中获取有关用户的信息。'
- en: 'Without a global application state management library, we will have to do the
    following if a user logs in:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 没有全局应用程序状态管理库，如果用户登录，我们将不得不做以下操作：
- en: Pass the information from the **Login** component to the **User** tab.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**登录**组件传递信息到**用户**标签页。
- en: Pass the information from the `App.js`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`App.js`传递信息。
- en: Set the user information in the state of `App.js`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`的状态中设置用户信息。
- en: Pass the user information as a prop to the **Content** tab.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户信息作为属性传递给**内容**标签页。
- en: Pass the user information from the **Content** tab to the **Dashboard** component.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**内容**标签页将用户信息传递到**仪表板**组件。
- en: Even in this simple example, we had to include five components to provide the
    user information to the dashboard component. When we are talking about complex
    real-world applications, there could be 10 or more layers that you would have
    to pass your data through. This would be a nightmare to maintain and understand.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，我们也必须包含五个组件来向仪表板组件提供用户信息。当我们谈论复杂的现实世界应用时，可能会有10个或更多的层级，你需要通过这些层级传递你的数据。这将是一个难以维护和理解的噩梦。
- en: 'There is another problem with this approach: when we pass the user information
    as a prop to the `App.js` changes. This means that we re-render the **Content**
    tab and potentially a lot of child components that haven’t changed because of
    the changed prop.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还存在另一个问题：当我们把用户信息作为属性传递给`App.js`时，`App.js`会发生变化。这意味着我们会重新渲染**内容**标签页以及可能的大量未因属性更改而改变的子组件。
- en: This is especially important because the global state of large apps can become
    quite complex and huge. If you compare this to a backend application, you can
    think of the global application state as the database of the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其重要，因为大型应用程序的全局状态可能会变得相当复杂和庞大。如果你将其与后端应用程序进行比较，你可以将全局应用程序状态视为系统的数据库。
- en: So, global state management libraries should solve two problems. On the one
    hand, they should give us an option to share information between components and
    keep our application’s state management maintainable. On the other hand, they
    should also help reduce unnecessary re-renders and therefore optimize our app’s
    performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，全局状态管理库应该解决两个问题。一方面，它们应该给我们一个在组件之间共享信息并保持我们的应用程序状态管理可维护的选项。另一方面，它们还应该帮助减少不必要的重新渲染，从而优化我们的应用程序性能。
- en: Using global state providers/containers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用全局状态提供者/容器
- en: 'The following diagram shows how the data flow is expected to work with a global
    state management solution:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用全局状态管理解决方案的数据流预期工作方式：
- en: '![Figure 5.2 – State management with a global state management solution'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 使用全局状态管理解决方案的状态管理'
- en: '](img/B16694_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_05_02.jpg)'
- en: Figure 5.2 – State management with a global state management solution
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 使用全局状态管理解决方案的状态管理
- en: As you can see, the global app state management solution provides an option
    to set data to a global place and connect components to consume this data. While
    this ensures that the connected components get re-rendered automatically when
    this data changes, it also has to guarantee that only these components are re-rendered
    and not the whole component tree.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，全局应用程序状态管理解决方案提供了一个将数据设置到全局位置并连接组件以消费这些数据的选项。虽然这确保了当这些数据发生变化时，连接的组件会自动重新渲染，但它也必须保证只有这些组件会重新渲染，而不是整个组件树。
- en: While this is a good pattern, it also comes with some risks. When every component
    can connect to your global state, you have to be very careful in which ways this
    state can be edited.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个好的模式，但也伴随着一些风险。当每个组件都可以连接到你的全局状态时，你必须非常小心地编辑这种状态的方式。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Never allow any component to write directly to your state. No matter what library
    you use, your global state provider should always have control over how the state
    can be altered.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 绝不允许任何组件直接写入你的状态。无论你使用什么库，你的全局状态提供者都应该始终控制状态如何被更改。
- en: As mentioned in the preceding information box, your global state provider should
    always be in control of the state. This means that you should never allow any
    component to set the state directly. Instead, your app state provider should provide
    some functions that alter the state. This ensures that you always know in which
    ways your state can change. A state that can only be altered in these ways is
    also called a predictable state.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的信息框中提到，您的全局状态提供者应始终控制状态。这意味着您不应允许任何组件直接设置状态。相反，您的应用状态提供者应提供一些可以改变状态的函数。这确保您始终知道状态可以如何改变。只能以这些方式改变的状态也称为可预测状态。
- en: Using the predictable state pattern
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可预测状态模式
- en: Having a predictable state is especially important when working on large-scale
    projects with multiple developers. Imagine a project where anyone could simply
    set the state directly from any component. When you run into an error because
    your state contains an invalid value, which cannot be handled by your application,
    it is nearly impossible to find out where this value is coming from. Also, you
    cannot provide any central validation when you allow your state to be edited directly
    from outside the global state provider.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型项目时，特别是在有多个开发者参与的项目中，拥有可预测状态尤为重要。想象一下，在一个项目中，任何人都可以简单地从任何组件直接设置状态。当您遇到错误，因为您的状态包含一个无法由您的应用程序处理的无效值时，几乎不可能找出这个值是从哪里来的。此外，当您允许从全局状态提供者外部直接编辑状态时，您无法提供任何中央验证。
- en: When you use the predictable state pattern, you have three advantages. First,
    you can provide validation and prevent invalid values from getting written to
    your state. Second, if you run into an error because of invalid state values,
    you have a central point where you can start debugging. Third, it’s easier to
    write tests for it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用可预测状态模式时，您有三个优点。首先，您可以提供验证并防止无效值写入您的状态。其次，如果您遇到由于无效状态值而导致的错误，您有一个中心点可以开始调试。第三，它更容易为其编写测试。
- en: 'The pattern of creating a predictable state is shown in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可预测状态的模式如下图中所示：
- en: '![Figure 5.3 – Simple predictable state management'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 简单的可预测状态管理'
- en: '](img/B16694_05_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16694_05_03.jpg)'
- en: Figure 5.3 – Simple predictable state management
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 简单的可预测状态管理
- en: As you can see, a component triggers any event. In this example, a user clicks
    a button. This event triggers an action. This can be a custom Hook or a function
    that is provided by some state management library. This Hook or function can do
    multiple things, from validating the event to fetching data from a local storage
    solution or an external backend. In the end, the state will be set.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，组件触发任何事件。在这个例子中，用户点击了一个按钮。这个事件触发了一个动作。这可能是一个自定义钩子或由某些状态管理库提供的函数。这个钩子或函数可以执行多项操作，从验证事件到从本地存储解决方案或外部后端获取数据。最后，状态将被设置。
- en: To give you a better idea, let’s have a look at a concrete example. The component
    is a reload button. Upon clicking it, the action fetches the most recent data
    from the backend. It handles the request and if the request is successful and
    provides valid data, the action sets this data in the state. Otherwise, it sets
    an error message and provides code to the state.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您有一个更好的概念，让我们看看一个具体的例子。该组件是一个重新加载按钮。点击它后，动作从后端获取最新的数据。它处理请求，如果请求成功并提供有效数据，动作将此数据设置在状态中。否则，它设置错误消息并提供代码到状态。
- en: As you can see, this pattern can also provide a good layer of abstraction between
    business logic and UI. If you would like to have an even better abstraction, you
    could use the next pattern we’ll talk about.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种模式也可以在业务逻辑和UI之间提供一层良好的抽象。如果您想要一个更好的抽象，您可以使用我们接下来要讨论的下一个模式。
- en: Using the state/action/reducer pattern
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用状态/动作/还原模式
- en: 'This simple predictable state management pattern can be extended. The following
    diagram shows an extended version, which adds reducers and selectors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的可预测状态管理模式可以扩展。以下图显示了扩展版本，其中添加了还原器和选择器：
- en: '![Figure 5.4 – The state/action/reducer pattern'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 状态/动作/还原模式'
- en: '](img/B16694_05_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16694_05_04.jpg)'
- en: Figure 5.4 – The state/action/reducer pattern
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 状态/动作/还原模式
- en: The preceding diagram shows the so-called **state/action/reducer** pattern.
    In this pattern, the action is not a function or Hook but a JavaScript object
    that gets dispatched. In most cases, this action is handled by a reducer. The
    reducer takes the action, which can have some data as a payload, and processes
    it. It can validate data, merge the data with the current state, and set the state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了所谓的 **状态/动作/Reducer** 模式。在这个模式中，动作不是一个函数或Hook，而是一个被派发的JavaScript对象。在大多数情况下，这个动作由reducer处理。reducer接收动作，它可以携带一些数据作为有效负载，并对其进行处理。它可以验证数据，将数据与当前状态合并，并设置状态。
- en: Normally, in this pattern, the reducer does not reach out to any other data
    sources. It only knows the action and the state. If you want to fetch data in
    this pattern, you can use middleware. This middleware intercepts the dispatched
    actions, processes its tasks, and dispatches other actions, which are then handled
    by reducers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这个模式中，reducer不会访问任何其他数据源。它只知道动作和状态。如果你想要在这个模式中获取数据，你可以使用中间件。这个中间件拦截派发的动作，处理其任务，并派发其他动作，然后这些动作被reducers处理。
- en: Again, let’s have a look at a concrete example. A user clicks on the `FETCH_DATA`
    action. This `FETCH_DATA` action is handled by the middleware. The middleware
    fetches the data and validates the request. If everything worked fine, it dispatches
    a `SET_DATA` action with the new data as a payload.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们看看一个具体的例子。用户点击了 `FETCH_DATA` 动作。这个 `FETCH_DATA` 动作由中间件处理。中间件获取数据并验证请求。如果一切顺利，它将派发一个带有新数据作为有效负载的
    `SET_DATA` 动作。
- en: The reducer handles this `SET_DATA` action, maybe does some data validation,
    merges the data with the current state, and sets the new state. If the data fetching
    in the middleware fails, the middleware dispatches a `DATA_FETCH_ERROR` action
    with an error code and error message as a payload. This action is also handled
    by a reducer, which sets the error code and message for the state.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 处理这个 `SET_DATA` 动作，可能进行一些数据验证，将数据与当前状态合并，并设置新状态。如果中间件中的数据获取失败，中间件将派发一个带有错误代码和错误消息的有效负载的
    `DATA_FETCH_ERROR` 动作。这个动作也被一个reducer处理，它为状态设置错误代码和消息。
- en: Another difference between *Figure 5.3* and *Figure 5.4* is the existence of
    selectors. This is something that exists in different state management solutions
    because it makes it possible to subscribe to only a part of the state instead
    of the whole state. This is very useful because it makes it possible to create
    complex state objects while not always re-rendering your whole application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3* 和 *图5.4* 之间的另一个区别是选择器的存在。这是不同状态管理解决方案中存在的东西，因为它使得只订阅状态的一部分而不是整个状态成为可能。这非常有用，因为它使得在不需要总是重新渲染整个应用的情况下创建复杂的状态对象成为可能。'
- en: This is clearer when we look at an example. Let’s say that you have an application
    whose global state consists of a user, an array of articles, and an array of favorite
    article IDs. Your application shows the articles in one tab and every article
    has a button to add it to a favorite list. On a second tab, you show the user
    information.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看一个例子时，这会更清晰。假设你有一个应用程序，其全局状态由一个用户、一个文章数组和一个收藏文章ID数组组成。你的应用程序在一个标签页中显示文章，每个文章都有一个按钮可以将其添加到收藏列表中。在第二个标签页中，你显示用户信息。
- en: When you put all this in the same global state, without using selectors, the
    default behavior of your **User** tab would be to re-render if you favor an article,
    even if nothing on the user page has changed. This is because the **User** tab
    also consumes the whole state and this state changed. When using a selector on
    the user, it doesn’t re-render, because the user part of the state that the **User**
    tab is connected to didn’t change.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把所有这些都放在同一个全局状态中，而不使用选择器时，如果你的**用户**标签页偏好一篇文章，那么默认情况下，你的**用户**标签页会重新渲染，即使用户页面上没有任何变化。这是因为**用户**标签页也消耗了整个状态，并且这个状态发生了变化。当在用户上使用选择器时，它不会重新渲染，因为**用户**标签页连接到的状态的用户部分没有变化。
- en: If you were to use a complex state without selectors, you would have to create
    different state providers, which are completely independent of each other.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个没有选择器的复杂状态，你将不得不创建不同的状态提供者，它们之间完全独立。
- en: Now that you’ve learned about the different options, it’s time to have a look
    at when it is necessary to use a global state or when you can also use a local
    component state and simply pass the props.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了不同的选项，是时候看看何时需要使用全局状态，或者何时可以使用局部组件状态并简单地传递props了。
- en: Comparing local component state and global application state
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较局部组件状态和全局应用状态
- en: 'If you want to provide some data to be shown in your UI, you must store it
    in your state in most scenarios. But the interesting question is: In which state?
    Local component state or global application state?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在UI中显示一些数据，在大多数情况下你必须将其存储在你的状态中。但有趣的问题是：在哪个状态中？本地组件状态还是全局应用程序状态？
- en: 'This is a topic that has no simple answer or rules that fit every situation.
    However, I want to give you some guidelines so that you can make a good decision
    for all of your use cases:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有简单答案或适用于每种情况的规则的话题。然而，我想给你一些指导原则，以便你可以为所有用例做出良好的决策：
- en: '**Keep your global state as lean as possible**: Global variables are something
    that is very uncommon to use in most programming languages. And this is for a
    reason. If everything can be set anywhere in your application, it is hard to debug
    and maintain it. Also, the bigger the global application state grows, the more
    likely it is that you will run into performance problems.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量保持全局状态尽可能精简**：全局变量在大多数编程语言中是非常不常见的。这是有原因的。如果可以在应用程序的任何地方设置一切，那么调试和维护它将变得非常困难。此外，全局应用程序状态越大，遇到性能问题的可能性就越大。'
- en: '**Form data should not be part of the global state**: When you provide input
    fields such as text fields, toggles, date pickers, or anything else, the state
    of these components should not be part of the global application state. This information
    belongs to the view, which provides these fields and should therefore be part
    of the view’s component state.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单数据不应成为全局状态的一部分**：当你提供输入字段，如文本字段、开关、日期选择器或其他任何内容时，这些组件的状态不应成为全局应用程序状态的一部分。这些信息属于视图，它提供了这些字段，因此应成为视图组件状态的一部分。'
- en: '**Try not to pass data down more than three layers**: When passing props to
    a child component, you should try to avoid passing this data through multiple
    layers. The best practice would be to never pass the component props to a child
    component, but only the component’s state. However, this can be quite hard in
    practice, so I would recommend sticking to never passing data down more than three
    layers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量减少向下传递超过三层数据**：在向子组件传递props时，你应该尽量避免通过多层传递这些数据。最佳实践是永远不要将组件props传递给子组件，而只传递组件的状态。然而，在实践中这可能相当困难，所以我建议坚持不要向下传递超过三层数据。'
- en: '**Try not to pass data up multiple layers**: As you have already learned, it
    is possible to pass data from a child to a parent component by passing a function
    from the parent to the child, which sets the state of the parent and then calls
    this function from the child component. Since this can lead to very confusing
    component dependencies to each other, you should be even more careful with passing
    data up than passing it down. I would recommend passing data up only one layer.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽量减少向上传递多层数据**：正如你已经学到的，你可以通过从父组件传递一个函数给子组件，该函数设置父组件的状态，然后从子组件中调用这个函数，从而从子组件传递数据到父组件。由于这可能导致组件之间非常混乱的依赖关系，因此在向上传递数据时应比向下传递数据更加小心。我建议只向上传递一层数据。'
- en: '**Use the global application state for data, which is used in multiple areas
    of your app**: When data has to be available in multiple areas of your app, which
    are on completely different navigation stacks, you should always use the global
    app state.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于在应用程序多个区域使用的数据，使用全局应用程序状态**：当数据需要在应用程序的多个区域可用，而这些区域位于完全不同的导航堆栈中时，你应该始终使用全局应用程序状态。'
- en: Deciding which data belongs to which state can be challenging. It is always
    a case-by-case decision and sometimes, you will have to revert your decision because
    of changing requirements or because you realize that it wasn’t the right decision
    while working with it. That’s fine. However, you can reduce these efforts by thinking
    about the right state solution for your data at the beginning.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 决定哪些数据属于哪个状态可能具有挑战性。这始终是具体情况具体分析，有时，你可能因为需求变化或在使用过程中意识到这不是正确的决定而不得不撤销你的决定。这是可以的。然而，你可以在一开始就考虑为你的数据选择正确的状态解决方案来减少这些努力。
- en: Now that we’ve covered the theory, it’s time to look at the most popular solutions
    and how to maintain the global application state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了理论，是时候看看最流行的解决方案以及如何维护全局应用程序状态了。
- en: Working with global state management solutions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与全局状态管理解决方案一起工作
- en: Historically, we would have to start with Redux since it was the first global
    state management solution to be popular. Back in 2015, when it was introduced,
    it quickly became the de facto standard for global state management in React applications.
    It is still used very widely, but especially in the last 3 years, some other third-party
    solutions have emerged.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，我们可能需要从 Redux 开始，因为它是第一个流行的全局状态管理解决方案。在 2015 年推出时，它迅速成为 React 应用程序中全局状态管理的既定标准。它仍然被非常广泛地使用，但特别是在过去
    3 年中，一些其他第三方解决方案已经出现。
- en: React also introduced a built-in solution for global state management that can
    be used in class components, as well as function components. It’s called **React
    Context**, and since it ships with React, we’ll start by looking at it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React 还引入了一个内置的全局状态管理解决方案，它可以用于类组件，也可以用于函数组件。它被称为 **React Context**，由于它随 React
    一起提供，我们将首先看看它。
- en: Working with React Context
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Context
- en: 'The idea of React Context is very simple: it is like a tunnel into a component
    that any other component can connect to. A context always consists of a provider
    and a consumer. The provider can be added to any existing component and expects
    a value property to be passed. All components that are descendants of the provider
    component can then implement a consumer and consume this value.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: React Context 的概念非常简单：它就像是一个通向组件的隧道，任何其他组件都可以连接到它。一个上下文总是由一个提供者和一个消费者组成。提供者可以被添加到任何现有的组件中，并期望传递一个值属性。所有是提供者组件后代的组件都可以实现一个消费者并消费这个值。
- en: Working with plain React Context providers and consumers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用普通的 React Context 提供者和消费者
- en: 'The following code shows a plain React Context example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了普通的 React Context 示例：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In your `App.js` file, you add a `ColorsProvider`, which wraps a `ColoredButton`
    component. This means that in `ColoredButton`, we will be able to implement a
    consumer for the `ColorsProvider` value. But let’s have a look at the implementation
    of `ColorsProvider` first:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `App.js` 文件中，您添加了一个 `ColorsProvider`，它包裹了一个 `ColoredButton` 组件。这意味着在 `ColoredButton`
    中，我们将能够实现一个用于 `ColorsProvider` 值的消费者。但让我们先看看 `ColorsProvider` 的实现：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `ColorsProvider` is a function component that provides a state
    with the property colors. This is initialized with a default color scheme, which
    is imported from `defaultColors`. It also provides a `toggleColors` function,
    which changes the color schemes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ColorsProvider` 是一个函数组件，它提供了一个具有颜色属性的状态。这个状态使用从 `defaultColors` 导入的默认颜色方案初始化。它还提供了一个
    `toggleColors` 函数，该函数可以改变颜色方案。
- en: The colors state variable and the `toggleColors` function are then packed into
    a value object, which is passed to the value property of `ColorContext.Provider`.
    `ColorContext` is initialized in line 2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色状态变量和 `toggleColors` 函数随后被打包成一个值对象，并将其传递给 `ColorContext.Provider` 的值属性。`ColorContext`
    在第 2 行初始化。
- en: 'As you can see, the file has two exports: `ColorContext` itself and the `ColorsProvider`
    function component. You have already learned how to use the provider, so next,
    we’ll look at how to consume the context’s value.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该文件有两个导出：`ColorContext` 本身和 `ColorsProvider` 函数组件。您已经学习了如何使用提供者，所以接下来，我们将看看如何消费上下文的值。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ColorsProvider` function component isn’t necessary for React Context to
    work. We could have also added the React Context initialization, the colors state,
    and the `toggleColors` function, as well as `ColorContext.Provider` directly into
    the `App.js` file. But it is best practice, and I would recommend extracting your
    contexts into separate files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorsProvider` 函数组件对于 React Context 的工作并不是必需的。我们也可以将 React Context 的初始化、颜色状态、`toggleColors`
    函数以及 `ColorContext.Provider` 直接添加到 `App.js` 文件中。但这是一个最佳实践，我建议将您的上下文提取到单独的文件中。'
- en: 'The following code shows `ColoredButton`, which is wrapped by our `ColorsProvider`
    in our `App.js` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `ColoredButton`，它在我们的 `App.js` 文件中被 `ColorsProvider` 包裹：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we use a `ColorContext.Consumer` component, which provides the
    values of `ColorsProvider`. These values can then be used. In this case, we use
    the `colors` object to style the `Pressable` and `Text` components and we pass
    the `toggleColors` function to the `onPress` property of the `Pressable` component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了一个 `ColorContext.Consumer` 组件，它提供了 `ColorsProvider` 的值。这些值可以被使用。在这种情况下，我们使用
    `colors` 对象来样式化 `Pressable` 和 `Text` 组件，并将 `toggleColors` 函数传递给 `Pressable` 组件的
    `onPress` 属性。
- en: This method of implementing a consumer works in function components as well
    as in class components. When working with function components, there is a simpler
    syntax you can use to fetch the value of the context.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现消费者组件的方法在函数组件和类组件中都可以工作。当与函数组件一起工作时，你可以使用更简单的语法来获取上下文的值。
- en: Working with Context and React Hooks
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Context 和 React Hooks
- en: 'The following code example shows a small section of the code example we looked
    at previously:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了之前查看的代码示例的一个小部分：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, instead of having to implement the context consumer component,
    you can simply use the `useContext` Hook to fetch the values. This makes the code
    shorter and much more readable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你不需要实现上下文消费者组件，你可以简单地使用 `useContext` Hook 来获取值。这使得代码更短，可读性更强。
- en: While this example is very simple, it nevertheless follows best practices. As
    you can see, the `setColors` function, which is the setter for our state, isn’t
    publicly available. Instead, we provide a `toggleColors` function, which allows
    us to alter the state in a predefined way. Also, we have the state abstracted
    very well from the UI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子非常简单，但它仍然遵循了最佳实践。正如你所见，`setColors` 函数，即我们状态的设置器，不是公开可用的。相反，我们提供了一个 `toggleColors`
    函数，它允许我们以预定义的方式更改状态。此外，我们很好地将状态从 UI 中抽象出来。
- en: Hooks enable you to even go one step further. When the project grows and you
    want to have an additional layer of abstraction, such as for making external requests,
    you could create a custom Hook as your middleware.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 允许你更进一步。当项目增长并且你想要添加一个额外的抽象层，例如用于外部请求，你可以创建一个自定义 Hook 作为你的中间件。
- en: This is what we will add next to our example project. We’ll create some functionality
    so that the user can create a list of favorite movies, which then gets displayed
    in the **User** tab. While doing this, we’ll discuss the benefits and limitations
    of React Context for global state management.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在示例项目中添加的内容。我们将创建一些功能，使用户能够创建一个收藏电影列表，然后在该 **用户** 选项卡中显示。在这个过程中，我们将讨论 React
    Context 在全局状态管理中的优点和局限性。
- en: 'The following figure shows what we’ll create:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了我们将要创建的内容：
- en: '![Figure 5.5 – Example app – Favorite Movies'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 示例应用 – 收藏电影'
- en: '](img/B16694_05_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_05_05.jpg]'
- en: Figure 5.5 – Example app – Favorite Movies
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 示例应用 – 收藏电影
- en: This is what the app should be able to do. On each movie details page, we’ll
    add a button to add the movie to **Favorite Movies**. If a movie is already part
    of **Favorite Movies**, the button changes to a **Remove** button, which removes
    the movie from the list.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用应该能够做到的事情。在每部电影详情页，我们将添加一个按钮来将电影添加到 **收藏电影**。如果电影已经是 **收藏电影** 的一部分，按钮将变为
    **移除** 按钮，从列表中移除电影。
- en: In the **Movies** list, we want to add a thumbs-up icon to all movies that are
    part of the **Favorite Movies** list. Finally, we want to display all movies in
    the **User** tab.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **电影** 列表中，我们想在所有属于 **收藏电影** 列表的电影上添加点赞图标。最后，我们想在 **用户** 选项卡中显示所有电影。
- en: 'First, we have to create the context and the custom Hook to be able to store
    the data. The following code shows `UserProvider`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建上下文和自定义 Hook，以便能够存储数据。以下代码展示了 `UserProvider`：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we have two state variables: an object that stores the favorite
    movies in a map-like structure (`favs`) and the name of the user (`name`). You
    can ignore `name` for now; we’ll need this later.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们有两个状态变量：一个对象，以类似映射的结构存储收藏电影（`favs`）和用户的名字（`name`）。现在你可以忽略 `name`；我们稍后会用到它。
- en: The provider also contains `addFav` and `removeFav` functions, which are the
    only ways to edit the store from outside the provider. These two functions and
    the `name` and `favs` state variables are packed into the `value` variable, which
    then gets passed to the `value` property of the provider.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者还包含 `addFav` 和 `removeFav` 函数，这是从提供者外部编辑存储的唯一方式。这两个函数以及 `name` 和 `favs` 状态变量被打包到
    `value` 变量中，然后传递到提供者的 `value` 属性。
- en: 'Next, we’ll have a look at the custom Hook. This Hook serves as the middleware
    and the data selectors. It is used to fetch data before it’s stored and to transform
    data to provide it in the way it is needed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看自定义 Hook。这个 Hook 作为中间件和数据选择器，用于在存储之前获取数据，并将数据转换为所需的形式：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we did in our previous Hooks example, we’ll use the `useContext` Hook to
    make the provider’s data accessible in our custom Hook. The custom Hook contains
    three functions. The `addFavById` function takes a `movieId` and fetches the movie
    from our `movieService`. This is a typical middleware task.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的 Hooks 示例中所做的那样，我们将使用 `useContext` Hook 来使提供者的数据在我们的自定义 Hook 中可访问。自定义
    Hook 包含三个函数。`addFavById` 函数接受一个 `movieId` 并从我们的 `movieService` 中获取电影。这是一个典型的中间件任务。
- en: The `getFavsAsArray` function provides the favorite movies of a user as an array.
    The `isFav` function answers the question if a given ID belongs to a movie in
    the user’s favorite list. These two functions are typical selectors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFavsAsArray` 函数提供了一个用户喜欢的电影数组。`isFav` 函数回答了给定 ID 是否属于用户喜欢的电影列表中的问题。这两个函数是典型的选择器。'
- en: The Hook returns these three functions as well as `name`, `favs`, and `removeFav`
    from the provider. With these things, we have all we need to implement our requirements
    very easily.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Hook 返回这三个函数以及来自提供者的 `name`、`favs` 和 `removeFav`。有了这些，我们就可以非常容易地实现我们的需求。
- en: 'Let’s start with the movie details page. We’ll have a look at different parts
    of the added code; if you want to see the whole file, please visit this book’s
    GitHub repository:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从电影详情页面开始。我们将查看添加的代码的不同部分；如果您想查看整个文件，请访问这本书的 GitHub 仓库：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this component, we need the `isFav` function to check if a movie is already
    part of the user’s favorites. Depending on that, we want to be able to add or
    remove the movie to or from the user’s favorites. Therefore, we import our `useUser`
    Hook and then use object destructuring to make these functions available. We also
    store the `isFav` information in a variable for later use.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件中，我们需要 `isFav` 函数来检查电影是否已经是用户收藏的一部分。根据这一点，我们希望能够将电影添加到或从用户的收藏中。因此，我们导入
    `useUser` Hook，然后使用对象解构来使这些函数可用。我们还存储 `isFav` 信息以供以后使用。
- en: 'Now that we can work with these functions, we have to implement the button
    itself:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这些函数了，我们必须实现按钮本身：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the implementation part of the button is quite easy. We use
    our `_isFav` variable to check which text our button should display and to decide
    which function we should call. The `addFavById` and `removeFav` functions can
    be called like any other function provided by the component.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，按钮的实现部分相当简单。我们使用我们的 `_isFav` 变量来检查按钮应该显示哪种文本，并决定应该调用哪个函数。`addFavById` 和
    `removeFav` 函数可以像组件提供的任何其他函数一样调用。
- en: 'Now that we have built the functionality to edit the favorites, the next step
    is to display this information in the movies list. The import of the Hook works
    as follows in the movie details view:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了编辑收藏的功能，下一步是在电影列表中显示这些信息。在电影详情视图中，Hook 的导入工作如下：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since we don’t want to write anything to the state, we don’t need to make these
    functions available. And in contrast to the movie details page, we must check
    multiple movies for their favorite status, so it makes no sense to create a variable
    to cache the result of `isMovieFav` here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想向状态写入任何内容，因此我们不需要使这些函数可用。而且与电影详情页面相反，我们必须检查多部电影是否有收藏状态，因此在这里创建一个变量来缓存
    `isMovieFav` 的结果是没有意义的。
- en: 'Next, let’s look at the implementation of the movie list’s JSX:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看电影列表的 JSX 实现：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While iterating over the movies, we’ll check every movie with the `isMovieFav`
    function. If it returns `true`, we’ll add a thumbs-up icon. That’s the only change
    that is needed here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历电影时，我们将使用 `isMovieFav` 函数检查每部电影。如果它返回 `true`，我们将添加一个点赞图标。这里只需要进行这个更改。
- en: 'The last step is to show the list of **Favorite Movies** in the **User** tab.
    This is also just a few lines of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在 **用户** 选项卡中显示 **收藏电影** 的列表。这同样只需要几行代码：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code shows the whole component (except imports and styling). We
    fetch our favorite movies with the Hook’s `getMovieFavsAsArray` function and store
    them in a variable. Then, we iterate over the array and render the movies. That’s
    it! Our example is complete.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了整个组件（除了导入和样式）。我们使用 Hook 的 `getMovieFavsAsArray` 函数获取我们喜欢的电影，并将它们存储在一个变量中。然后，我们遍历数组并渲染电影。就这样！我们的示例就完成了。
- en: As you have seen in this example, the implementation part of the components
    is very easy and only needs a few lines of code in most cases. This will stay
    the same, even in bigger projects, when you have a good structure in your contexts.
    I like this approach very much because it doesn’t need any external libraries
    and has a clear separation between UI components, middleware, and state provider.
    It also comes with another benefit.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中看到的，组件的实现部分非常简单，在大多数情况下只需要几行代码。即使在大项目中，只要你的上下文结构良好，这一点也会保持不变。我非常喜欢这种方法，因为它不需要任何外部库，并且有清晰的
    UI 组件、中间件和状态提供者之间的分离。它还带来了另一个好处。
- en: It can be very useful to persist parts of the store and rehydrate (reload) them
    when the user reopens the app. This is also very easy when working with React
    Context. The following code snippet is part of `UserProvider` and shows how to
    store and reload the user’s favorite list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 React Context 时，持久化存储的部分并当用户重新打开应用时重新加载数据可以非常有用。这也非常简单。下面的代码片段是 `UserProvider`
    的一部分，展示了如何存储和重新加载用户的收藏列表。
- en: 'In this case, we are using `AsyncStorage` as a local storage solution:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `AsyncStorage` 作为本地存储解决方案：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the provider works like any other component, it can also use the `useEffect`
    Hook. In this example, we are using an effect to fetch `favs` from `AsyncStorage`
    when the provider gets mounted. We use another effect to store the favorites every
    time the `favs` variable changes. While there are a lot of benefits, unfortunately,
    this approach based on React Context comes with a big limitation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提供者就像任何其他组件一样工作，它也可以使用 `useEffect` Hook。在这个例子中，我们使用一个效果在提供者挂载时从 `AsyncStorage`
    获取 `favs`。我们使用另一个效果在 `favs` 变量每次变化时存储收藏。虽然有很多好处，但不幸的是，这种基于 React Context 的方法有一个很大的限制。
- en: Understanding the limitations of React Context
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 React Context 的限制
- en: At the beginning of this example, I told you to ignore the `name` variable in
    the state provider because we would need it later. This later is now. If you have
    already looked at this book’s GitHub repository, you may have realized that the
    code for the `Home` view has changed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的开始，我告诉你要忽略状态提供者中的 `name` 变量，因为我们需要它在以后使用。现在就是“以后”。如果你已经看过这本书的 GitHub 仓库，你可能已经意识到
    `Home` 视图的代码已经发生了变化。
- en: 'The following code snippet shows the changes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了变化：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This view now imports the `useUser` Hook and reads the user’s name to provide
    a warm welcome message to the user. It also contains a `console.log` that logs
    every re-render of the page. When you run the code example and add/remove movies
    to/from the user’s favorites, you’ll realize that the `Home` component re-renders
    on every change of `favs` in `UserProvider`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图现在导入了 `useUser` Hook，并读取用户的名字，为用户提供一个温馨的欢迎信息。它还包含一个 `console.log`，记录页面的每次重新渲染。当你运行代码示例并添加/删除电影到/从用户的收藏中时，你会意识到
    `Home` 组件在 `UserProvider` 中 `favs` 的每次变化时都会重新渲染。
- en: This happens even if we don’t use `favs` in this component. This is because
    a state change in `UserProvider` triggers a re-render in every descendant, which
    also contains every component that imports the custom Hook.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个组件中我们没有使用 `favs`，这种情况也会发生。这是因为 `UserProvider` 中的状态变化会触发每个子组件的重新渲染，这也包括所有导入自定义
    Hook 的组件。
- en: This limitation does not mean that you can’t use React Context. It is widely
    used, even in large projects. But you always have to keep this limitation in mind.
    My recommended solution for this problem is to split your global state into different
    contexts with different providers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制并不意味着你不能使用 React Context。它在大型项目中也很普遍。但你始终要记住这个限制。我推荐的解决方案是将你的全局状态分割成不同的上下文，每个上下文有不同的提供者。
- en: In this example, we could have created a `UserContext`, which only contains
    the name of the user, and a `FavContext`, which only contains the list of favorites.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以创建一个只包含用户名的 `UserContext`，以及一个只包含收藏列表的 `FavContext`。
- en: You could also use `useMemo`, `React.memo`, or `componentDidUpdate` to optimize
    the performance of this approach. But if you need to do this, I recommend using
    another solution that provides these optimizations out of the box. One of them
    is Zustand, which we’ll have a look at next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `useMemo`、`React.memo` 或 `componentDidUpdate` 来优化这种方法的表现。但如果你需要这样做，我建议使用另一个提供这些优化功能的解决方案。其中之一是
    Zustand，我们将在下一节中探讨。
- en: Working with Zustand
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Zustand
- en: '**Zustand.js** is a very lean approach to state management. It is based on
    Hooks and comes with performance-optimized selectors built in. It can also be
    extended in different ways so that you can use it to implement exactly the global
    state management pattern you like.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Zustand.js** 是一种非常简洁的状态管理方法。它基于 Hooks，并内置了性能优化的选择器。它还可以以不同的方式扩展，以便你可以用它来实现你喜欢的确切的全局状态管理模式。'
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to use Zustand in class components, you can’t do this directly because
    class components don’t support Hooks. However, you could use the **higher-order
    component** (**HOC**) pattern to wrap the class component in a function component.
    Then, you can use the Hook in the function component and pass the Zustand state
    to the class component as a prop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在类组件中使用 Zustand，你不能直接这样做，因为类组件不支持 Hooks。然而，你可以使用 **高阶组件**（**HOC**）模式将类组件包裹在一个函数组件中。然后，你可以在函数组件中使用
    Hook，并将 Zustand 状态作为 prop 传递给类组件。
- en: 'You can read more about HOC in the React documentation here: [https://bit.ly/prn-hoc](https://bit.ly/prn-hoc).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 React 文档中了解更多关于 HOC 的信息：[https://bit.ly/prn-hoc](https://bit.ly/prn-hoc)。
- en: To create a Zustand store, you must use the `create` Hook provided by Zustand.
    This creates a store, which holds the state and provides functions to access the
    state. To get a more concrete idea, let’s have a look at what our example project
    looks like with the global state handled by Zustand.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Zustand 存储，你必须使用 Zustand 提供的 `create` Hook。这创建了一个存储，它持有状态并提供访问状态的功能。为了获得更具体的概念，让我们看看我们的示例项目在由
    Zustand 处理全局状态时的样子。
- en: 'The code snippets shown here are just excerpts. If you want to check out the
    running example, please go to this book’s GitHub repository and choose the `chapter-5-zustand`
    tag:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的代码片段只是摘录。如果你想查看运行示例，请访问这本书的 GitHub 仓库，并选择 `chapter-5-zustand` 标签：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use the `create` function provided by Zustand to create the store. We pass
    a function to `create` that can access the `get` and `set` parameters and returns
    the store. This store itself is an object that can hold data objects (the state)
    and functions (setters or selectors) as properties. Inside these functions, we
    can use `get` to access state objects or `set` to write parts of the store.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Zustand 提供的 `create` 函数来创建存储。我们向 `create` 传递一个函数，该函数可以访问 `get` 和 `set`
    参数，并返回存储。这个存储本身是一个对象，可以持有数据对象（状态）和函数（设置器或选择器）作为属性。在这些函数内部，我们可以使用 `get` 来访问状态对象或
    `set` 来写入存储的部分。
- en: Again, when you work with objects as part of your state, you have to create
    a new object and write it to the store to trigger a re-render. If you just alter
    the existing state object and write it back, the state will not be recognized
    as changed because the object reference did not change.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当你将对象作为状态的一部分工作时，你必须创建一个新的对象并将其写入存储以触发重新渲染。如果你只是修改现有的状态对象并将其写回，状态将不会被识别为已更改，因为对象引用没有改变。
- en: Tip
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When working with objects in your state, it can be annoying to always have to
    create copies of these objects before setting them to the state. This problem
    is solved by an open source library called `produce` function, which takes the
    old state, lets you make changes, and automatically creates a new object out of
    it. It also integrates into Zustand as middleware.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在状态中使用对象时，总是需要在设置状态之前创建这些对象的副本可能会很烦人。这个问题通过一个名为 `produce` 函数的开源库得到解决，它接受旧状态，允许你进行更改，并自动从它创建一个新的对象。它还作为中间件集成到
    Zustand 中。
- en: 'You can find out more about immer.js here: [https://bit.ly/prn-immer](https://bit.ly/prn-immer).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 immer.js 的网站上了解更多信息：[https://bit.ly/prn-immer](https://bit.ly/prn-immer)。
- en: In our example, we still have `name` and `favs` as state properties. To modify
    this state, our Zustand store provides an `addFavById` function and a `removeFav`
    function. The `addFavById` function not only writes to the store but also fetches
    the movie for a given ID from our `movieService`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们仍然有 `name` 和 `favs` 作为状态属性。为了修改这个状态，我们的 Zustand 存储提供了 `addFavById`
    函数和 `removeFav` 函数。`addFavById` 函数不仅将数据写入存储，还会从我们的 `movieService` 中获取给定 ID 的电影。
- en: Next, we’ll look at how we connect to the store from within a component. We
    don’t even have to change much code to switch from React Context to Zustand in
    our components.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在组件内部连接到存储。我们甚至不需要更改太多代码，就可以在我们的组件中将 React Context 切换到 Zustand。
- en: 'Let’s have a look at the movie view:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看电影视图：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use the `useUserStore` Hook we just created with Zustand’s `create`
    function to connect to the Zustand state. We connect to multiple parts of the
    state using array destructuring. Since we have already implemented the usage of
    the functions in our JSX code in the React Context example, we don’t have to change
    anything there. It’s the same functions doing the same thing, but coming from
    another state management solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们刚刚使用 Zustand 的 `create` 函数创建的 `useUserStore` 钩子来连接到 Zustand 状态。我们通过数组解构连接到状态的多个部分。由于我们已经在
    React Context 示例中实现了函数在 JSX 代码中的使用，所以我们不需要在那里做任何改变。这些函数做的是同样的事情，但来自另一个状态管理解决方案。
- en: 'However, the most important thing occurs when looking at the `Home` view:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当查看 `Home` 视图时，最重要的事情发生了：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are doing the same as we did in the React Context example: we are
    connecting our home view to the global state and fetching the name. When you run
    this example, you will realize that `console.log` will no longer be triggered
    when you add or remove favorites.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在做与 React Context 示例中相同的事情：我们将我们的主页视图连接到全局状态并获取名称。当你运行这个示例时，你会意识到当你添加或删除收藏夹时，`console.log`
    将不再被触发。
- en: This is because Zustand only triggers re-renders if the part of the state the
    component is connected to changes, not if anything in the state changes. This
    is very useful because you don’t have to think about performance optimization
    that much. Zustand provides this out of the box.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Zustand 只在组件连接到的状态部分发生变化时触发重新渲染，而不是状态中的任何内容发生变化时。这非常有用，因为你不必过多地考虑性能优化。Zustand
    提供了这项功能作为默认设置。
- en: Zustand is becoming more and more popular because of its simplicity and flexibility.
    As mentioned previously, you don’t have to choose this simple approach with Zustand.
    You could even create a Redux-like workflow with it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Zustand 的简单性和灵活性，它变得越来越受欢迎。如前所述，你不必选择这种简单的 Zustand 方法。你甚至可以用它创建类似 Redux 的工作流程。
- en: Speaking of Redux, this is the next solution you’ll learn about.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 Redux，这是你接下来将要学习的下一个解决方案。
- en: Working with Redux
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Redux 一起工作
- en: 'Redux is by far the most used solution when it comes to global state management.
    The following diagram compares the usage of react-redux and Zustand:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到全局状态管理时，Redux 是迄今为止最常用的解决方案。以下图表比较了 react-redux 和 Zustand 的使用情况：
- en: '![Figure 5.6 – Daily npm downloads of react-redux and Zustand'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – react-redux 和 Zustand 的每日 npm 下载量'
- en: '](img/B16694_05_06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_05_06.jpg](img/B16694_05_06.jpg)'
- en: Figure 5.6 – Daily npm downloads of react-redux and Zustand
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – react-redux 和 Zustand 的每日 npm 下载量
- en: As you can see, the daily downloads of `react-redux` are quite stable at around
    5 million. Zustand’s popularity is rapidly growing. It changed from around 100,000
    daily downloads in Q3 2021 to around 500,000 daily downloads in Q2 2022\. This
    is a sign that a lot of new projects prefer Zustand over Redux.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`react-redux` 的每日下载量相当稳定，大约在 500 万左右。Zustand 的受欢迎程度正在迅速增长。它从 2021 年第三季度的每日约
    10 万次下载增长到 2022 年第二季度的每日约 50 万次下载。这是一个迹象，表明许多新项目更倾向于使用 Zustand 而不是 Redux。
- en: Nevertheless, Redux is a very good solution. It follows a very clear structure
    and has a huge ecosystem built around it. Redux uses the state/action/reducer
    pattern and forces the developer to stick to it. It can be enhanced with different
    middlewares such as `redux-thunk` or `redux-saga` to handle effects. It also provides
    great developer tools for debugging.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Redux 是一个非常好的解决方案。它遵循一个非常清晰的架构，并围绕它建立了一个庞大的生态系统。Redux 使用状态/动作/还原器模式，并强迫开发者坚持使用它。它可以通过不同的中间件如
    `redux-thunk` 或 `redux-saga` 来增强以处理效果。它还提供了出色的开发者工具用于调试。
- en: 'Since Redux is a very mature technology, there are a lot of great tutorials
    and books on the market that handle Redux. Therefore, the basic usage of Redux
    won’t be covered by this book. If you don’t already know the basics of Redux,
    I recommend starting with the official tutorial here: [https://bit.ly/prn-redux](https://bit.ly/prn-redux).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Redux 是一个非常成熟的技术，市场上有很多关于 Redux 的优秀教程和书籍。因此，本书不会涵盖 Redux 的基本用法。如果你还不了解 Redux
    的基础知识，我建议从这里开始学习官方教程：[https://bit.ly/prn-redux](https://bit.ly/prn-redux)。
- en: While Redux is a great state management solution, it comes with two huge downsides.
    First, it creates some overhead for creating and maintaining all the parts of
    the process. To provide a simple string value in your global state, you need at
    least the store, a reducer, and an action. Second, the code of applications with
    a deep Redux integration can become quite hard to read.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Redux是一个出色的状态管理解决方案，但它有两个巨大的缺点。首先，它为创建和维护流程的所有部分创建了一些额外开销。要在全局状态中提供一个简单的字符串值，你至少需要一个存储、一个reducer和一个action。其次，深度集成Redux的应用程序代码可能变得相当难以阅读。
- en: I would recommend Redux for huge applications that a lot of developers work
    on. In this case, the clear structure and the separation between the logical layers
    are worth the overhead. Middleware should be used to handle side effects and `redux-toolkit`
    can be used to simplify the code. This setup can work very well in this large-scale
    scenario.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我会推荐Redux用于由许多开发者共同工作的庞大应用。在这种情况下，清晰的结构和逻辑层之间的分离是值得额外开销的。应该使用中间件来处理副作用，而`redux-toolkit`可以用来简化代码。这种设置在大规模场景中可以非常有效地工作。
- en: Now that you’ve learned how to use Redux, Zustand, and React Context to handle
    the global application state, you have seen that there are multiple different
    ways to approach global state management. While these solutions are my favorites
    at the moment, there are a lot more options available. If you want to look for
    different options, I also recommend MobX, MobX-state-tree, Recoil, and Rematch.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用Redux、Zustand和React Context来处理全局应用程序状态，你已经看到有多个不同的方法可以处理全局状态管理。虽然这些解决方案目前是我的最爱，但还有更多选项可供选择。如果你想寻找不同的选项，我也推荐MobX、MobX-state-tree、Recoil和Rematch。
- en: Now that you’ve learned how to handle data inside a React Native app, we’ll
    check out how we can retrieve data from external APIs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何在React Native应用中处理数据，我们将探讨如何从外部API检索数据。
- en: Connecting to remote backends
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到远程后端
- en: React Native allows you to use different solutions to connect to online resources
    such as APIs. First, you’ll learn about plain HTTP API connections. Later in this
    section, we’ll also have a look at more high-level solutions such as GraphQL clients
    and SDKs such as Firebase or Amplify. But let’s start with some general things.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: React Native允许你使用不同的解决方案连接到在线资源，如API。首先，你将了解关于纯HTTP API连接的内容。在本节的后面部分，我们还将探讨更高级的解决方案，如GraphQL客户端和Firebase或Amplify等SDK。但让我们先从一些基本的事情开始。
- en: Understanding the general principles of connections in React Native
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解React Native中连接的一般原则
- en: No matter what connection solution you use in your React Native app, it is always
    a good idea to use **JavaScript Object Notation** (**JSON**) as the format for
    your data transfer. Since React Native apps are written in JavaScript and JavaScript
    plays very well with JSON, this is the only logical choice.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在你的React Native应用中使用什么连接解决方案，始终使用**JavaScript对象表示法**（**JSON**）作为数据传输的格式都是一个好主意。由于React
    Native应用是用JavaScript编写的，而JavaScript与JSON配合得非常好，这是唯一合理的选择。
- en: Next, regardless of which connection solution you use, always wrap your API
    calls in a service. Even if you are sure about the connection solution you chose,
    you may want or have to replace it in a few years.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，无论你使用哪种连接解决方案，都要始终将你的API调用封装在服务中。即使你确信你选择的连接解决方案，你可能在几年后想要或必须替换它。
- en: This is much simpler when you have all the code wrapped in a service than searching
    for it everywhere in your whole application. The last thing I want to mention
    here is that you have to think about how to secure your API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将所有代码封装在服务中时，这要简单得多，而不是在应用中的每个地方寻找它。我想在这里提到的最后一件事是，你必须考虑如何保护你的API。
- en: Understanding security risks
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解安全风险
- en: 'You always have to keep in mind that a React Native app runs completely client-side.
    This means that everything you ship in your app can be considered publicly available.
    This also includes API keys, credentials, or any other authentication information.
    While there can never be 100% impenetrable software, you should at least provide
    some level of security:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终要记住，React Native应用完全在客户端运行。这意味着你应用中发送的任何内容都可以被认为是公开可用的。这还包括API密钥、凭证或任何其他认证信息。虽然永远不可能有100%无法攻破的软件，但你至少应该提供一定级别的安全性：
- en: '![Figure 5.7 – Security efforts and likelihood of a breach (inspired by https://reactnative.dev/docs/security)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 安全努力和泄露的可能性（灵感来源于https://reactnative.dev/docs/security)'
- en: '](img/B16694_05_07.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B16694_05_07.jpg]'
- en: Figure 5.7 – Security efforts and likelihood of a breach (inspired by https://reactnative.dev/docs/security)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 安全努力和泄露的可能性（灵感来源于 https://reactnative.dev/docs/security）
- en: 'As you can see, even some efforts in securing your app reduce the likelihood
    of a breach significantly. The minimum you should do is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使是在保护你的应用程序方面的一些努力，也能显著降低泄露的可能性。你应该至少做到以下这些：
- en: Don’t store your private API keys or credentials in your code.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在你的代码中存储你的私有 API 密钥或凭证。
- en: Don’t use tools such as `react-native-dotenv` or `react-native-config` to store
    sensitive data. This data is also shipped to the client in plain text.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 `react-native-dotenv` 或 `react-native-config` 等工具来存储敏感数据。这些数据也会以纯文本形式发送到客户端。
- en: Use user-based keys or credentials wherever possible.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用基于用户的密钥或凭证。
- en: Remove all console output in production builds to not expose keys.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产构建中移除所有控制台输出，以防止暴露密钥。
- en: 'Store sensitive information in secure local storage solutions (see the *Storage*
    section of [*Chapter 4*](B16694_04.xhtml#_idTextAnchor079), *     Styling, Storage, and Navigation in React Native*).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全的本地存储解决方案中存储敏感信息（参见 [*第 4 章*](B16694_04.xhtml#_idTextAnchor079)，*React Native
    中的样式、存储和导航*）的 *存储* 部分）。
- en: When you need to work with third-party APIs, which only provide you with one
    key, you should create your own server layer that you can call from within your
    app. Then, you can store your API key on the server, add it to the request, call
    the third-party API from your server, and provide the response to your app.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要与只提供你一个密钥的第三方 API 一起工作时，你应该创建自己的服务器层，你可以在你的应用程序内部调用它。然后，你可以在服务器上存储你的 API
    密钥，将其添加到请求中，从你的服务器调用第三方 API，并将响应提供给你的应用程序。
- en: In that way, you don’t make your API key public. Again, always keep in mind
    that everything you ship with your app can be exposed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以防止你的 API 密钥公开。再次提醒，始终记住你与应用程序一起发布的所有内容都可能被暴露。
- en: With that warning given, let’s start with our first simple call, where we will
    use the JavaScript Fetch API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒到此，让我们开始我们的第一个简单调用，我们将使用 JavaScript Fetch API。
- en: Working with the built-in Fetch API
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置的 Fetch API
- en: React Native ships with a built-in Fetch API, which is sufficient for most use
    cases. It is easy to use, easy to read, and can be used in apps of all sizes.
    We’ll use our example app again to see how it works. We’ll replace the `genres.json`
    and `movies.json` static files with real API calls to The Movie DB ([https://www.themoviedb.org](https://www.themoviedb.org)).
    Please note that this API is free for non-commercial use only and you have to
    stick to the terms of use when using it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 内置了 Fetch API，这对于大多数用例来说已经足够了。它易于使用，易于阅读，并且可以用于所有大小的应用程序。我们将再次使用我们的示例应用程序来查看它是如何工作的。我们将用
    The Movie DB 的真实 API 调用替换 `genres.json` 和 `movies.json` 静态文件（[https://www.themoviedb.org](https://www.themoviedb.org)）。请注意，此
    API 仅适用于非商业用途且免费，并且在使用时必须遵守使用条款。
- en: 'You can find the full example code on GitHub (the `chapter-5-fetch` tag). To
    run it, you have to register at [https://www.themoviedb.org/](https://www.themoviedb.org/)
    and obtain an API key. You can read more about this here: [https://bit.ly/prn-tmd-api](https://bit.ly/prn-tmd-api).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完整的示例代码（`chapter-5-fetch` 标签）。要运行它，你必须注册 [https://www.themoviedb.org/](https://www.themoviedb.org/)
    并获取一个 API 密钥。你可以在这里了解更多信息：[https://bit.ly/prn-tmd-api](https://bit.ly/prn-tmd-api)。
- en: 'Now, let’s have a look at the code. First, we must create a constants file
    for all API information:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码。首先，我们必须为所有 API 信息创建一个常量文件：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our example, we put the base URL and the API key here. This is where you
    can paste the API key you retrieved from The Movie DB.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将基本 URL 和 API 密钥放在这里。这是你可以粘贴从 The Movie DB 获取的 API 密钥的地方。
- en: Security note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 安全提示
- en: Never put your API key in your app like this in production.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，永远不要像这样将你的 API 密钥放在你的应用程序中。
- en: 'Since we have already extracted our data connection in `movieService`, this
    is the file where we will make most of the changes. Instead of reading and filtering
    local files, we’ll connect to the real API. To make the connection easier, we’ll
    write two helper functions first:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 `movieService` 中提取了数据连接，因此这是我们将会进行大部分更改的文件。我们不会读取和过滤本地文件，而是连接到真实的 API。为了使连接更容易，我们首先编写两个辅助函数：
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `createFullAPIPath` function takes the path of the request and adds the
    base URL and the API key for authentication to the call. The `makeAPICall` function
    does the fetch action and returns typed data from the response JSON.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFullAPIPath` 函数接受请求的路径，并将基本 URL 和用于身份验证的 API 密钥添加到调用中。`makeAPICall`
    函数执行获取操作，并从响应 JSON 返回类型化数据。'
- en: 'These helper functions are used to create different functions that are exported
    so that they’re available in the application. Let’s look at one of them – the
    `getGenres` function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数用于创建不同的函数，这些函数被导出，以便在应用程序中使用。让我们看看其中之一——`getGenres` 函数：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we use the `makeAPICall` helper function to fetch the data.
    We add the data type we expect the data to be. As the path, we only have to pass
    the relative path of the API. Then, we process the response and return the data.
    In production, we wouldn’t log the error to the console but to an external error
    reporting system. You’ll learn more about this in [*Chapter 13*](B16694_13.xhtml#_idTextAnchor462)*,
    Tips and Outlook*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用 `makeAPICall` 辅助函数来获取数据。我们添加我们期望的数据类型。作为路径，我们只需要传递 API 的相对路径。然后，我们处理响应并返回数据。在生产中，我们不会将错误记录到控制台，而是记录到外部错误报告系统。你将在
    [*第 13 章*](B16694_13.xhtml#_idTextAnchor462)*，提示和展望* 中了解更多信息。
- en: There is one simple thing left that we have to change in our application to
    make it work again. You may have noticed that the functions in our service changed
    to `async` functions, which return promises instead of direct data. While we were
    able to process the local data synchronously, API calls are always executed asynchronously.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，还有一件简单的事情需要更改，以便使其再次工作。你可能已经注意到，我们的服务中的函数已更改为 `async` 函数，它们返回承诺而不是直接数据。虽然我们能够同步处理本地数据，但
    API 调用始终是异步执行的。
- en: And that’s a good thing. You don’t want your application to freeze until the
    response to your API request is there. But since the service function returns
    promises now, we have to modify the places where these functions are called.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事。你不想让你的应用程序在 API 请求的响应到来之前冻结。但是，由于服务函数现在返回承诺，我们必须修改这些函数被调用的地方。
- en: 'So, let’s have a look at the home view again – more precisely, the `useEffect`
    Hook part:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们再次看看主页视图——更确切地说，是 `useEffect` 钩子部分：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since we are not able to create async functions directly in the `useEffect`
    Hook, we create an async `fetchData` function that we then call in `useEffect`.
    In this function, we await the promise that is returned by `getGenres` and set
    the data in the state.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在 `useEffect` 钩子中直接创建异步函数，所以我们创建了一个异步的 `fetchData` 函数，然后在 `useEffect`
    中调用它。在这个函数中，我们等待由 `getGenres` 返回的承诺，并将数据设置在状态中。
- en: Similar changes have to be made in the `genre` view, the `movie` view, and the
    `addFavById` function of our Zustand store.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的变化必须在 `genre` 视图、`movie` 视图以及我们的 Zustand 存储的 `addFavById` 函数中进行。
- en: While Fetch is quite powerful and you can use it even in large-scale and enterprise
    projects, some other solutions can be useful too.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Fetch 非常强大，你甚至可以在大型和企业的项目中使用它，但其他一些解决方案也可能很有用。
- en: Working with other data fetching solutions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他数据获取解决方案一起工作
- en: 'In this subsection, you’ll learn about other popular solutions for data fetching.
    All of them have their benefits and tradeoffs and in the end, you have to decide
    what’s the best fit for your project. The following solutions work fine, are well
    maintained, and are widely used:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将了解其他流行的数据获取解决方案。它们都有各自的优点和缺点，最终你必须决定哪种最适合你的项目。以下解决方案运行良好，维护良好，并且被广泛使用：
- en: '**Axios**: Axios is a third-party HTTP client for fetching data. It works quite
    similarly to the Fetch API but brings a lot of additional features. Once created,
    you can configure your Axios instance with headers, interceptors, and more. It
    also provides excellent error handling and allows you to cancel requests.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Axios**：Axios 是一个用于获取数据的第三方 HTTP 客户端。它的工作方式与 Fetch API 非常相似，但带来了许多附加功能。一旦创建，你可以使用头信息、拦截器等配置你的
    Axios 实例。它还提供了出色的错误处理，并允许你取消请求。'
- en: '**Apollo/URQL GraphQL client**: GraphQL is a query language for APIs that has
    become very popular over the last few years. The advantage it has over REST APIs
    is that you can control what you want to fetch on the client. You can also fetch
    multiple resources in one call. This results in fetching exactly the data you
    need in the most efficient way possible. You can read more about GraphQL here:
    [https://bit.ly/prn-advantage-graph](https://bit.ly/prn-advantage-graph).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apollo/URQL GraphQL 客户端**：GraphQL 是一种 API 查询语言，在过去的几年中变得非常流行。它相对于 REST API
    的优势在于，你可以在客户端控制你想要获取的内容。你还可以在一次调用中获取多个资源。这以最有效的方式获取你所需的确切数据。你可以在[这里](https://bit.ly/prn-advantage-graph)了解更多关于
    GraphQL 的信息。'
- en: There are multiple client implementations for GraphQL. The most popular ones
    are Apollo and URQL. Both clients not only provide data fetching but also handle
    caching, refreshing, and data actualization in the UI. While this can be very
    useful, you always should ensure that you also provide a great user experience
    for users while they are offline.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL有多种客户端实现。最受欢迎的包括Apollo和URQL。这两个客户端不仅提供数据获取功能，还处理缓存、刷新和UI中的数据实际化。虽然这非常有用，但你始终应该确保在用户离线时也能提供出色的用户体验。
- en: '**React Native Firebase**: Firebase is a very popular app development backend
    platform. It provides different services with very well-maintained SDKs. React
    Native Firebase is a wrapper around the native Android and iOS SDK. It provides
    data fetching, but only for connections to the Firebase services. If you want
    to learn more about Firebase, you can visit the React Native Firebase documentation:
    [https://bit.ly/prn-firebase](https://bit.ly/prn-firebase).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React Native Firebase**：Firebase是一个非常流行的应用开发后端平台。它提供了一系列维护良好的SDK服务。React
    Native Firebase是针对原生Android和iOS SDK的包装器。它提供数据获取功能，但仅限于连接到Firebase服务的连接。如果你想了解更多关于Firebase的信息，可以访问React
    Native Firebase文档：[https://bit.ly/prn-firebase](https://bit.ly/prn-firebase)。'
- en: '**AWS Amplify**: Amplify is a collection of AWS services that can be accessed
    via the Amplify SDKs. Like Firebase, it provides data fetching capabilities, but
    only to the AWS services that have been configured in Amplify. If you want to
    learn more about Amplify, you can visit the Amplify JavaScript documentation:
    [https://bit.ly/prn-amplify](https://bit.ly/prn-amplify).'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Amplify**：Amplify是一组可以通过Amplify SDK访问的AWS服务。与Firebase类似，它提供了数据获取功能，但仅限于在Amplify中配置的AWS服务。如果你想了解更多关于Amplify的信息，可以访问Amplify
    JavaScript文档：[https://bit.ly/prn-amplify](https://bit.ly/prn-amplify)。'
- en: Besides these solutions, a lot of service providers provide their own SDKs that
    can be used to access their services. It is totally fine to use these SDKs. But
    again, always remember to not store any API keys or authentication information
    in your app.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些解决方案之外，许多服务提供商还提供了他们自己的SDK，可以用来访问他们的服务。使用这些SDK是完全可行的。但再次提醒，始终不要在应用中存储任何API密钥或认证信息。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To wrap this chapter up, let’s have a short recap. In this chapter, you learned
    how to handle local and global states. You learned about the most popular concepts
    of global state handling and how to decide which data should be stored in your
    global state or the local state of a component or view. You also understood how
    to use React Context, Zustand, and Redux for global state handling.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章内容，让我们简要回顾一下。在本章中，你学习了如何处理本地和全局状态。你了解了全局状态处理中最流行的概念以及如何决定哪些数据应该存储在你的全局状态或组件或视图的本地状态中。你还了解了如何使用React
    Context、Zustand和Redux进行全局状态处理。
- en: After mastering state management in React Native, you learned how to connect
    your app to a remote backend. You understood how to use the built-in Fetch API,
    how to extract API calls in a service, how to create and use helper functions,
    and how to work with async calls. Finally, you learned about the different solutions
    for data fetching, such as Axios, GraphQL clients, and other SDKs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握React Native中的状态管理后，你学习了如何将你的应用连接到远程后端。你了解了如何使用内置的Fetch API，如何在服务中提取API调用，如何创建和使用辅助函数，以及如何处理异步调用。最后，你学习了数据获取的不同解决方案，如Axios、GraphQL客户端和其他SDK。
- en: Now that you have completed the first five chapters of this book, you can create
    a working app with a strong technical foundation. In the next chapter, you will
    learn how to make your app look good with beautiful animations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了这本书的前五章，你可以创建一个具有强大技术基础的工作应用。在下一章中，你将学习如何通过美丽的动画让你的应用看起来更美观。
