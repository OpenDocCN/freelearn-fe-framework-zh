- en: '22'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '22'
- en: Collecting User Input
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集用户输入
- en: In web applications, you can collect user input from standard HTML form elements
    that look and behave similarly on all browsers. With native UI platforms, collecting
    user input is more nuanced.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用中，你可以从所有浏览器上看起来和表现相似的HTML表单元素中收集用户输入。在使用原生UI平台时，收集用户输入更为复杂。
- en: In this chapter, you’ll learn how to work with the various React Native components
    that are used to collect user input. These include text input, selecting from
    a list of options, checkboxes, and date/time selectors. All of these are used
    in every app in cases of register or login flow, as well as the purchase form.
    The experience of creating such forms is very valuable and this chapter will help
    you to know how to create any form in your future apps. You’ll learn the differences
    between iOS and Android and how to implement the appropriate abstractions for
    your app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用各种React Native组件来收集用户输入。这些包括文本输入、从选项列表中选择、复选框和日期/时间选择器。所有这些都在注册或登录流程以及购买表单的每个应用中使用。创建此类表单的经验非常有价值，本章将帮助你了解如何在未来的应用中创建任何表单。你将了解iOS和Android之间的差异以及如何为你的应用实现适当的抽象。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Collecting text input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集文本输入
- en: Selecting from a list of options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从选项列表中选择
- en: Toggling between on and off
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开和关之间切换
- en: Collecting date/time input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集日期/时间输入
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter23)2.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter23)2。
- en: Collecting text input
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集文本输入
- en: It turns out that there’s a lot to think about when it comes to implementing
    text inputs. For example, should it have placeholder text? Is this sensitive data
    that shouldn’t be displayed on the screen? Should you process text as it’s entered
    or when the user moves to another field?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文本输入时有很多需要考虑的因素。例如，是否应该有占位文本？这是否是敏感数据，不应该在屏幕上显示？是否应该在用户移动到另一个字段时处理文本？
- en: 'In web apps, there is a special `<input>` HTML element that allows you to collect
    user inputs. In React Native, for that purpose, we use the `TextInput` component.
    Let’s build an example that renders several instances of the `<TextInput>` component:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用中，有一个特殊的`<input>`HTML元素，允许你收集用户输入。在React Native中，我们使用`TextInput`组件来达到这个目的。让我们构建一个示例，渲染几个`<TextInput>`组件的实例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have implemented the `Input` component that we will reuse several times.
    Let’s take a look at a few use cases of text inputs:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`Input`组件，我们将多次重用它。让我们看看几个文本输入的使用案例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I won’t go into depth about what each of these `<TextInput>` components is
    doing; there are labels in the `Input` components that explain this. Let’s see
    what these components look like on the screen:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨每个`<TextInput>`组件的功能；`Input`组件中有标签解释了这一点。让我们看看这些组件在屏幕上的样子：
- en: '![Picture 1](img/B19636_22_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/B19636_22_01.png)'
- en: 'Figure 22.1: Text input variations'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.1：文本输入的变体
- en: The plain text input shows the text that’s been entered. The **Password Input**
    field doesn’t reveal any characters. **Placeholder Text** is displayed when the
    input is empty. The **Changed** text state is also displayed. You can’t see the
    **Submitted** text state because I didn’t press the **Submitted** button on the
    virtual keyboard before I took the screenshot.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本输入显示已输入的文本。**密码输入**字段不显示任何字符。**占位文本**在输入为空时显示。**已更改**的文本状态也显示出来。你无法看到**已提交**的文本状态，因为我没有在虚拟键盘上按下**已提交**按钮之前截图。
- en: 'Let’s take a look at the virtual keyboard for the input element where you changed
    the **Return Key** text via the `returnKeyType` prop:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过`returnKeyType`属性更改**返回键**文本的输入元素的虚拟键盘：
- en: '![Picture 2](img/B19636_22_02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/B19636_22_02.png)'
- en: 'Figure 22.2: Keyboard with changed Return key text'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.2：按键文本已更改的键盘
- en: When the keyboard **Return key** reflects what’s going to happen when the user
    presses it, the user feels more in tune with the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当键盘的**返回键**反映了用户按下它时将要发生的事情，用户会感到与应用程序更加协调。
- en: 'One more common use case is changing the keyboard type. By providing the `keyboardType`
    prop to the `TextInput` component, you will see different variations of keyboards.
    This is convenient when you need to enter a PIN code or email address. Here is
    an example of a `numeric` keyboard:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是更改键盘类型。通过将`keyboardType`属性提供给`TextInput`组件，你将看到不同类型的键盘。当你需要输入PIN码或电子邮件地址时，这很方便。以下是一个`numeric`键盘的示例：
- en: '![Picture 3](img/B19636_22_03.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_22_03.png)'
- en: 'Figure 22.3: Numeric keyboard type'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.3：数字键盘类型
- en: Now that you’re familiar with collecting text input, it’s time to learn how
    to select a value from a list of options.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了收集文本输入，是时候学习如何从选项列表中选择一个值了。
- en: Selecting from a list of options
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从选项列表中选择
- en: 'In web applications, you typically use the `<select>` element to let the user
    choose from a list of options. React Native comes with a `Picker` component, which
    works on both iOS and Android, but in terms of reducing the React Native app size,
    the Meta team decided to delete it in future releases and extract `Picker` to
    its own package. To use that package, firstly, we install it in a clean project
    by running this command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，你通常使用`<select>`元素让用户从选项列表中进行选择。React Native自带一个`Picker`组件，它在iOS和Android上都可用，但为了减少React
    Native应用程序的大小，Meta团队决定在未来版本中删除它，并将`Picker`提取到自己的包中。要使用该包，首先，在一个干净的项目中运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is some trickery involved with styling this component based on which
    platform the user is on, so let’s hide all of this inside a generic `Select` component.
    Here’s the `Select.ios.js` module:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户所在的平台，对这个组件进行样式设置涉及一些技巧，所以让我们将这些内容全部隐藏在一个通用的`Select`组件中。以下是`Select.ios.js`模块：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s a lot of overhead for a simple `Select` component. It turns out that
    it’s quite hard to style the React Native `Picker` component, because it looks
    completely different on iOS and Android. Despite that, we want to make it more
    cross-platform.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的`Select`组件来说，这确实是一个很大的开销。实际上，要样式化React Native的`Picker`组件相当困难，因为它在iOS和Android上的外观完全不同。尽管如此，我们仍然希望使其更加跨平台。
- en: 'Here’s the `Select.android.js` module:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Select.android.js`模块：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what the styles look like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是样式的样子：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As usual with the `container` and `pickersBlock` styles, we define the base
    layout of the screen. Next, let’s take a look at the styles of the `Select` component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如同通常的`container`和`pickersBlock`样式，我们定义了屏幕的基本布局。接下来，让我们看看`Select`组件的样式：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you can render your `Select` component. Here is what the `App.js` file
    looks like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以渲染你的`Select`组件。以下是`App.js`文件的样子：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we defined the default values for our `Select` component. Let’s take
    a look at the final `SelectingOptions` component:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的`Select`组件定义了默认值。让我们看看最终的`SelectingOptions`组件：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With these hooks, we’ve implemented states of selectors. Next, we will use
    and pass them into components:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些钩子，我们已经实现了选择器的状态。接下来，我们将使用并将它们传递到组件中：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The basic idea of this example is that the selected option in the first selector
    changes the available options in the second selector. When the second selector
    changes, the label shows `selectedSize` and `selectedGarment` as a string. Here’s
    how the screen looks:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的基本思想是第一个选择器中选中的选项会改变第二个选择器中可用的选项。当第二个选择器改变时，标签会显示`selectedSize`和`selectedGarment`作为字符串。以下是屏幕的显示方式：
- en: '![Picture 4](img/B19636_22_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/B19636_22_04.png)'
- en: 'Figure 22.4: Selecting from the list of options'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.4：从选项列表中选择
- en: The **Size** selector is shown on the left-hand side of the screen. When the
    **Size** value changes, the available values in the **Garment** selector on the
    right-hand side of the screen change to reflect size availability. The current
    selection is displayed as a string after the two selectors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Size**选择器显示在屏幕的左侧。当**Size**值改变时，屏幕右侧**Garment**选择器中可用的值会改变，以反映尺寸的可用性。两个选择器之后会以字符串的形式显示当前的选择。'
- en: 'This is how our `app` looks on an Android device:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`app`在Android设备上的样子：
- en: '![](img/B19636_22_05.PNG.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_22_05.PNG.png)'
- en: 'Figure 22.5: Selecting from the list of options on Android'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.5：在Android上从选项列表中选择
- en: When the iOS version of the `Picker` component renders a scrollable list of
    options, the Android one gives only buttons that open a dialog modal for selecting
    options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Picker`组件的iOS版本渲染一个可滚动的选项列表时，Android版本只提供打开对话框模态以选择选项的按钮。
- en: In the following section, you’ll learn about the buttons that toggle between
    on and off states.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将了解在开和关状态之间切换的按钮。
- en: Toggling between on and off
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开和关之间切换
- en: 'Another common element you’ll see in web forms is checkboxes. For example,
    think of toggling Wi-Fi or Bluetooth on your device. React Native has a `Switch`
    component that works on both iOS and Android. Thankfully, this component is a
    little easier to style than the `Picker` component. Let’s look at a simple abstraction
    you can implement to provide labels for your switches:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页表单中，您还会看到另一个常见元素，即复选框。例如，想想在您的设备上切换Wi-Fi或蓝牙。React Native有一个`Switch`组件，在iOS和Android上都能工作。幸运的是，这个组件比`Picker`组件更容易样式化。让我们看看您可以实现的简单抽象，为您的开关提供标签：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s learn how we can use a couple of switches to control application
    state:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用几个开关来控制应用程序状态：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These two switches toggle the `disabled` property of one another. When the first
    switch is toggled, the `setFirst()` function is called, which will update the
    value of the first state. Depending on the current value of `first`, it will either
    be set to `true` or `false`. The second switch works the same way, except it uses
    `setSecond()` and the second state value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个开关相互切换对方的`disabled`属性。当第一个开关被切换时，会调用`setFirst()`函数，这将更新第一个状态值。根据`first`的当前值，它将被设置为`true`或`false`。第二个开关的工作方式相同，但它使用`setSecond()`和第二个状态值。
- en: 'Turning on one switch will disable the other because we’ve set the `disabled`
    property value for each switch to the state of the other switch. For example,
    the second switch has `disabled={first}`, which means that it is disabled whenever
    the first switch is turned on. Here’s what the screen looks like on iOS:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个开关将禁用另一个开关，因为我们已经将每个开关的`disabled`属性值设置为另一个开关的状态。例如，第二个开关有`disabled={first}`，这意味着当第一个开关打开时，它将被禁用。以下是iOS上的屏幕截图：
- en: '![Picture 5](img/B19636_22_06.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/B19636_22_06.png)'
- en: 'Figure 22.6: Switch toggles on iOS'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.6：iOS上的开关切换
- en: 'Here’s what the same screen looks like on Android:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Android上的相同屏幕截图：
- en: '![Picture 6](img/B19636_22_07.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/B19636_22_07.png)'
- en: 'Figure 22.7: Switch toggles on Android'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.7：Android上的开关切换
- en: As you can see, our `CustomSwitch` component enables the same functionality
    on Android and iOS while using one component for both platforms. In the following
    section, you’ll learn how to collect date/time input.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的`CustomSwitch`组件在Android和iOS上实现了相同的功能，同时使用了一个组件来处理这两个平台。在下一节中，您将了解如何收集日期/时间输入。
- en: Collecting date/time input
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集日期/时间输入
- en: In this final section of this chapter, you’ll learn how to implement date/time
    pickers. React Native docs suggest using `@react-native-community/datetimepicker`
    independent date/time picker components for iOS and Android, which means that
    it is up to you to handle the cross-platform differences between the components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，您将学习如何实现日期/时间选择器。React Native文档建议使用`@react-native-community/datetimepicker`独立日期/时间选择器组件，这意味着处理组件之间的跨平台差异取决于您。
- en: 'To install `datetimepicker`, run the following command in the project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`datetimepicker`，请在项目中运行以下命令：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, let’s start with a `DatePicker` component for iOS:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从iOS的`DatePicker`组件开始：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There’s not a lot to this component; it simply adds a label to the `DateTimePicker`
    component. The Android version works a bit differently; the better approach would
    be to use an **imperative API**. Let’s take a look at the implementation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件没有太多内容；它只是给`DateTimePicker`组件添加了一个标签。Android版本的工作方式略有不同；更好的方法是使用**命令式API**。让我们看看实现方式：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The key difference between the two date pickers is that the Android version
    doesn’t use a React Native component like D`ateTimePicker` in iOS. Instead, we
    have to use the imperative `DateTimePickerAndroid.open()` API. This is triggered
    when the user presses the date text that our component renders and opens a date
    picker dialog. The good news is that this component of ours hides this API behind
    a declarative component.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 两个日期选择器的关键区别在于，Android版本不使用iOS中类似的React Native组件`DateTimePicker`。相反，我们必须使用命令式`DateTimePickerAndroid.open()`
    API。当用户点击我们组件渲染的日期文本并打开日期选择器对话框时，将触发此API。好消息是，我们组件的这个部分隐藏了这个API在声明式组件后面。
- en: I’ve also implemented a time picker component that follows this exact pattern.
    So, rather than listing that code here, I suggest that you download the code for
    this book from [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter22)2
    so that you can see the subtle differences and run the example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我还实现了一个遵循此精确模式的时间选择器组件。因此，而不是在这里列出代码，我建议您从 [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter22)
    下载本书的代码，这样您可以看到细微的差异并运行示例。
- en: 'Now, let’s learn how to use our date and time picker components:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用我们的日期和时间选择器组件：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Awesome! Now, we have `DatePicker` and `TimePicker` components that can help
    us select dates and times in our app. Also, they both work on iOS and Android.
    Let’s see how the pickers look on iOS:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们有了 `DatePicker` 和 `TimePicker` 组件，可以帮助我们在应用中选择日期和时间。此外，它们在 iOS 和 Android
    上都适用。让我们看看选择器在 iOS 上的样子：
- en: '![Picture 7](img/B19636_22_08.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7](img/B19636_22_08.png)'
- en: 'Figure 22.8: iOS date and time pickers'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.8：iOS 日期和时间选择器
- en: 'As you can see, the iOS date and time pickers use the `Picker` component that
    you learned about earlier in this chapter. The Android picker looks a lot different;
    let’s look at it now:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，iOS 日期和时间选择器使用了您在本章早期学习过的 `Picker` 组件。Android 的选择器看起来大不相同；现在让我们来看看：
- en: '![Picture 8](img/B19636_22_09.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片 8](img/B19636_22_09.png)'
- en: 'Figure 22.9: Android date picker'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.9：Android 日期选择器
- en: The Android version follows a completely different approach from the iOS date/time
    picker, yet we can use the same `DatePicker` component that we’ve created on both
    platforms. This brings us to the end of the chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Android 版本与 iOS 日期/时间选择器的做法完全不同，但我们可以在两个平台上使用相同的 `DatePicker` 组件。这就结束了本章的内容。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the various React Native components that resemble
    the form elements from the web that we’re used to. We started off by learning
    about text input and how each text input has its own virtual keyboard to take
    into consideration. Next, we learned about `Picker` components, which allow the
    user to select an item from a list of options. Then, we learned about the `Switch`
    component, which is kind of like a checkbox. With these components, you will be
    able to build a form of any complexity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了各种类似于我们习惯的网页表单元素的 React Native 组件。我们首先学习了文本输入以及每个文本输入都有自己的虚拟键盘需要考虑。接下来，我们学习了
    `Picker` 组件，它允许用户从选项列表中选择一个项目。然后，我们学习了 `Switch` 组件，它有点像复选框。有了这些组件，您将能够构建任何复杂性的表单。
- en: In the final section, we learned how to implement generic date/time pickers
    that work on both iOS and Android. In the next chapter, we’ll learn about modal
    dialogs in React Native.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们学习了如何实现适用于 iOS 和 Android 的通用日期/时间选择器。在下一章中，我们将学习 React Native 中的模态对话框。
