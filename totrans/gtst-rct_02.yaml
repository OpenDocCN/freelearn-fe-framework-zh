- en: Chapter 2. Exploring JSX and the ReactJS Anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you are going to explore the JSX syntax and learn what it
    is and why it makes it easier for us to understand UI components. You will learn
    about the ReactJS anatomy and code some common scenarios in order to demonstrate
    this efficient syntax so that we can step forward in next chapters and build a
    full application. This chapter will walk you through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ReactJS anatomy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX Gotchas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSX** is a JavaScript syntax extension that looks similar to XML. It is used
    to build UI components in ReactJS. It''s very similar to HTML with some subtle
    differences. JSX extends JavaScript in such a way that you can easily build ReactJS
    components with the same understanding as building HTML pages. It''s commonly
    mixed with your JavaScript code because ReactJS thinks about UI in a different
    way. This paradigm will be explained later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: It's wrong to say that you are mixing up your HTML with JavaScript. As already
    said, JSX extends JavaScript. Actually, you're not writing HTML tags, but you're
    writing JavaScript objects in the JSX syntax. Of course, it has to be transformed
    into plain JavaScript first.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s transformed into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This transformer script file detects JSX notations and transforms them into
    plain JavaScript notations. These scripts and tools should never be placed in
    a production environment because it would be painful for the server to transform
    the script on every request. For the production environment, we should provide
    the transformed file. We will be covering that process later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 1](part0015_split_000.html#page "Chapter 1. Getting
    Started with ReactJS"), *Getting Started with ReactJS*, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactElement` is the primary API of React. ReactElement has four properties:
    `type`, `props`, `key`, and `ref`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactElement has no methods of itself, and nothing has been defined on the prototype
    also.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactElement objects can be created by calling the `React.createElement` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the highlighted code mentioned earlier, we can see that the first argument
    for the `React.createElement` method is creating an `h1` element, with properties
    being passed as null and the actual content of the `h1` element being the string
    `Hello World from Learning ReactJS`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactElements are passed into DOM in order to create a new tree in DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactElements are named virtual DOM and are not the same as DOM elements. Details
    of virtual DOM will be discussed in later chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As per the official React documentation ([https://facebook.github.io/react/docs/glossary.html](https://facebook.github.io/react/docs/glossary.html)),
    "ReactElement is a light, stateless, immutable, virtual representation of a DOM
    Element".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check our previous example again when we didn''t use the JSX syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code is creating an `h1` element. Think about it being like creating an
    element through JavaScript with the `document.createElement()` function, which
    makes the code very readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSX is not mandatory, but it''s highly recommended. It is painful to create
    large and complex components using JavaScript. For example, if we want to create
    nested elements using JSX, we would need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using plain JavaScript ReactJS objects, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see a big scary component that might grow in case of more complex logic.
    Such complex components are difficult to maintain and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Why JSX?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, HTML and JavaScript are segregated in frameworks by defining UI
    or a view to represent their mutable data, which normally is a template language
    and/or a display logic interpreter. The following is some jQuery code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `script` element represents a template component that will be rendered
    in the `my-awesome-app div` element. The code here is a JavaScript file that pushes
    data to that template and asks jQuery to do the job and render the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you want to put some display logic on that code, you will need to rely
    on both JavaScript and HTML files. In other words, a single component is a mix
    of files—normally, a JavaScript file that controls the view, a template/markup
    file representing the view, and a model/service that fetches data from the server
    and sends it to the view. Typically in an MVC application, the logic of M(model),
    V(view), and C(controller) are separated in order to provide the separation of
    concern and better readability and maintenance of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we now have to change this view and need to hide the list when
    the user is not logged in. Considering that the model/service code is already
    bringing this information, we'll have to change both the code that controls the
    view and the markup one in order to apply those changes. Harder the change is,
    more painful it is to apply those changes. Our code ends up in big JavaScript
    and HTML files, mixed up with display logic, template expressions, and business
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you are an experienced frontend developer, apply some separation of
    concerns, and split your UI into smaller views, you end up with hundreds of files
    just to represent a single piece of UI: view controller, HTML template, style
    sheet, and your model. It makes a small application look complex with that amount
    of files, and you''ll certainly get messy wondering which file is part of a specific
    view or component.'
  prefs: []
  type: TYPE_NORMAL
- en: The thing we want to show here is that we've been mixing markup and logic code
    since the beginning, but other than that, we've also been splitting them into
    other files, making it more difficult to find and to modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'ReactJS with JSX drives you in the other way. There is a really interesting
    paragraph in the ReactJS official page that honestly reasons this powerful library
    and its paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"We strongly believe that components are the right way to separate concerns
    rather than "templates" and "display logic." We think that markup and the code
    that generates it are intimately tied together. Additionally, display logic is
    often very complex and using template languages to express it becomes cumbersome.
    ([http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax](http://facebook.github.io/react/docs/displaying-data.html#jsx-syntax))*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We like to think of ReactJS components as a single source of truth. All other
    locations that use your component will be just references. Every change you apply
    to the original one will be propagated to all other places referencing it. Customization
    is easily done through properties and child componentization. JSX is like a middleware
    that converts your markup code to objects where ReactJS can handle them.
  prefs: []
  type: TYPE_NORMAL
- en: JSX speeds up the frontend development in ReactJS. Instead of creating literal
    objects to represent your UI, you create XML-like elements very similar to HTML,
    and you can even reference other components that you've created. Also, it's very
    straightforward to reuse third-party components or even publish your own. In a
    corporate environment, you could have a commonly used components repository that
    other projects can import from.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for transforming JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JSX Transformer file and other tools, as already mentioned, are responsible
    for transforming your JSX syntax into plain JavaScript. The ReactJS team and the
    community provide some tools for that. Such tools can deal with any kind of file
    since they have JavaScript code and JSX syntax. In older versions of React, a
    comment was required on the first line of `.js` files such as `/** @jsx React.DOM
    */`. Thankfully, this was removed after version 0.12.
  prefs: []
  type: TYPE_NORMAL
- en: JSX Transformer has been deprecated now. Instead, we can use [https://babeljs.io/repl/](https://babeljs.io/repl/)
    to compile the JSX syntax into JavaScript. To include JSX in your script tag,
    either use `<script type="text/jsx">` or while transforming, use `babel`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Earlier there was an online tool at [http://facebook.github.io/react/jsx-compiler.html](http://facebook.github.io/react/jsx-compiler.html).
    However, the React developer team discontinued it, and JSX Transformer has been
    deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since such JSX transformation would take a substantial computation at the client
    side, we should *not* be doing these transformations in production environments.
    Instead, we should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Tools for transforming JSX](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the node `npm` package that the ReactJS team built to transform
    your JSX files. First, you need to install the `react-tools` NPM package with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install `react-tools` globally. All you need now is to run the following
    command from your project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command transforms every script in the `src` folder and puts it in the
    `build` folder. The `watch` parameter makes this tool run the same command every
    time a file changes in the `src` folder. This is a very useful tool because you're
    using node to bundle your frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re familiar with task runner tools such as Grunt or Gulp, they also
    have JSX transformer packages that can be installed with `npm` as well. In this
    case, they provide more options that can fit better in our deployment/building
    process, mainly if you already use one of them. It''s not the purpose of this
    book to dive into Grunt or Gulp. In order to configure and install them, you can
    follow their guidelines in the following links: Details of these are covered in
    [Chapter 9](part0053_split_000.html#page "Chapter 9. Preparing Your Code for Deployment"),
    *Preparing Your Code for Deployment*.'
  prefs: []
  type: TYPE_NORMAL
- en: Grunt – [https://www.gruntjs.com](https://www.gruntjs.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp – [https://www.gulpjs.com](https://www.gulpjs.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both sites have a [/plugins](http:///plugins) page where you can search for
    available plugins. The following are the links of these download tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Grunt React task—[https://www.npmjs.com/package/grunt-react](https://www.npmjs.com/package/grunt-react)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp React task—[https://www.npmjs.com/package/gulp-react/](https://www.npmjs.com/package/gulp-react/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They work much the same as do the React tools. We are going to use the `transformer`
    script file that is placed in `head` the element of our HTML page for the next
    examples, as this is easier to do. In [Chapter 9](part0053_split_000.html#page
    "Chapter 9. Preparing Your Code for Deployment"), *Preparing Your Code for Deployment*,
    we are going to use `webpack` and `gulp` as the `npm` packages to transform our
    JSX code and prepare it for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The ReactJS anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going any further into JSX, we need to understand some basic rules to
    build ReactJS components. First, we're going to detail the basic methods that
    you've already used to create and render components. Then, we'll move to some
    rules to create them, and finally, we'll talk about children components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a component, we need to use the `React.createClass` function.
    ReactJS components are basically classes. This method returns a ReactJS component
    definition that has a method named `render`, which is mandatory to implement.
    There are many other methods to configure your component and change its behavior
    that we are going to cover throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of how to use the `createClass` and `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a good practice to name all the classes and components in PascalCase. In
    addition to being a common pattern in JavaScript, it also helps to distinguish
    them from other variables.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have your component definition, as seen in our last example, the `HelloMessage`
    component, we can render it with the render method of `ReactJS`. It requires the
    component definition and the target location, where the component will be rendered.
    Let''s demonstrate this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the code mentioned earlier, you could change `document.body` with any other
    element in your page. For example, you could use the `document` object method
    `document.getElementById('id')` to find an element by its ID or any other helper
    that returns a DOM element. In the specific ID of the DOM (`id` in this case),
    the React component will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of roots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s not possible to return more than one element in the `render` method.
    Not for now, as they say in official ReactJS docs at [http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html](http://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The ReactJS library will throw a strange error that doesn't address clearly
    that you have more than one element being rendered. Therefore, take care to not
    do this; otherwise, you can get stuck trying to find the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have more than one element being represented by a ReactJS component,
    you must wrap them in a single parent element. The next example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can use whichever valid HTML element you want that supports children elements.
    It is also possible to render a custom ReactJS component that has children support
    (more about this in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the reasons to choose a good text editor and a good linter/lint
    package that can watch your code and warn you whenever you make a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Children components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is a really necessary thing when you talk about creating reusable user
    interfaces, it has to do with nesting components. This way you can better structure
    and separate concerns of your application. It's a pretty common thing to do on
    web world as well, as HTML has this feature built-in. As you could see in the
    last section and earlier examples of this book, ReactJS supports this feature
    as well and JSX syntax makes it very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you have a `Header` component and you want to place other components
    inside. ReactJS allows this and includes support for placing other ReactJS components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use either built-in components, such as `h2`, or custom components,
    such as the `Clock` component, described here. In this example, the expression
    `{this.props.children}` will be considered as a JavaScript array. If there was
    a single component like the one mentioned later, it will be addressed as a JavaScript
    object instead of an array. This saves array allocation, but we should be careful
    and not try to iterate it or check for its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Supported attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some HTML attributes conflict with JavaScript reserved words, and as ReactJS
    elements are basically JavaScript objects, such attributes have a different name
    in ReactJS to match the DOM API specification:'
  prefs: []
  type: TYPE_NORMAL
- en: The class is `className`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` is `htmlFor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Custom attributes, such as `data-*` and `aria-*`, are supported by ReactJS.
    There is an official list of HTML attributes supported, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `accept` `acceptCharset` `accessKey` `action` `allowFullScreen` `allowTransparency`
    `alt` `async` `autoComplete` `autoPlay` `cellPadding` `cellSpacing` `charSet`
    `checked` `classID` `className` `cols` `colSpan` `content` `contentEditable` `contextMenu`
    `controls` `coords` `crossOrigin` `data` `dateTime` `defer` `dir` `disabled` `download`
    `draggable` `encType` `form` `formAction` `formEncType` `formMethod` `formNoValidate`
    `formTarget` `frameBorder` `height` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `hidden` `href` `hrefLang` `htmlFor` `httpEquiv` `icon` `id` `label` `lang`
    `list` `loop` `manifest` `marginHeight` `marginWidth` `max` `maxLength` `media`
    `mediaGroup` `method` `min` `multiple` `muted` `name` `noValidate` `open` `pattern`
    `placeholder` `poster` `preload` `radioGroup` `readOnly` `rel` `required` `role`
    `rows` `rowSpan` `sandbox` `scope` `scrolling` `seamless` `selected` `shape` `size`
    `sizes` `span` `spellCheck` `src` `srcDoc` `srcSet` `start` `step` `style` `tabIndex`
    `target` `title` `type` `useMap` `value` `width` `wmode` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: At the time of writing this book, this is available at [http://facebook.github.io/react/docs/tags-and-attributes.html](http://facebook.github.io/react/docs/tags-and-attributes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Supported elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official ReactJS website also provides a list of supported elements. ReactJS
    supports mostly all HTML elements. A comprehensive list of all the supported elements
    are given on their website, [https://facebook.github.io/react/docs/tags-and-attributes.html](https://facebook.github.io/react/docs/tags-and-attributes.html).
  prefs: []
  type: TYPE_NORMAL
- en: HTML elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the elements that are supported. There are many more to the
    list as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `a` | `abbr` | `address` | `area` |'
  prefs: []
  type: TYPE_TB
- en: '| `article` | `aside` | `audio` | `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `base` | `bdi` | `bdo` | `big` |'
  prefs: []
  type: TYPE_TB
- en: '| `blockquote` | `body` | `br` | `button` |'
  prefs: []
  type: TYPE_TB
- en: '| `canvas` | `caption` | `cite` | `code` |'
  prefs: []
  type: TYPE_TB
- en: '| `col` | `colgroup` | `data` | `datalist` |'
  prefs: []
  type: TYPE_TB
- en: '| `dd` | `del` | `details` | `dfn` |'
  prefs: []
  type: TYPE_TB
- en: '| `dialog` | `div` | `dl` | `dt` |'
  prefs: []
  type: TYPE_TB
- en: '| `em` | `embed` | `footer` | `fieldset` |'
  prefs: []
  type: TYPE_TB
- en: '| `figcaption` | `figure` | `form` | `h4` |'
  prefs: []
  type: TYPE_TB
- en: '| `h1` | `h2` | `h3` | `h5` |'
  prefs: []
  type: TYPE_TB
- en: '| `h6` | `head` | `header` | `hr` |'
  prefs: []
  type: TYPE_TB
- en: '| `html` | `i` | `iframe` | `img` |'
  prefs: []
  type: TYPE_TB
- en: '| `input` | `ins` | `kbd` | `keygen` |'
  prefs: []
  type: TYPE_TB
- en: '| `label` | `legend` | `li` | `link` |'
  prefs: []
  type: TYPE_TB
- en: '| `main` | `map` | `mark` | `menu` |'
  prefs: []
  type: TYPE_TB
- en: '| `menuitem` | `meta` | `meter` | `nav` |'
  prefs: []
  type: TYPE_TB
- en: '| `noscript` | `object` | `ol` | `optgroup` |'
  prefs: []
  type: TYPE_TB
- en: '| `option` | `output` | `p` | `param` |'
  prefs: []
  type: TYPE_TB
- en: '| `picture` | `pre` | `progress` | `q` |'
  prefs: []
  type: TYPE_TB
- en: '| `rp` | `rt` | `ruby` | `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `samp` | `script` | `section` | `select` |'
  prefs: []
  type: TYPE_TB
- en: '| `small` | `source` | `span` | `strong` |'
  prefs: []
  type: TYPE_TB
- en: '| `style` | `sub` | `summary` | `sup` |'
  prefs: []
  type: TYPE_TB
- en: '| `table` | `tbody` | `td` | `textarea` |'
  prefs: []
  type: TYPE_TB
- en: '| `tfoot` | `thead` | `time` | `tr` |'
  prefs: []
  type: TYPE_TB
- en: '| `track` | `u` | `ul` | `video` |'
  prefs: []
  type: TYPE_TB
- en: '| `wbr` |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: SVG elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are some of the supported SVG elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `circle` `defs` `ellipse` `g` `line` `linearGradient` `mask` `path` `pattern`
    `polygon` `polyline` `radialGradient` `rect` `stop` `svg` `text` `tspan` |'
  prefs: []
  type: TYPE_TB
- en: Learning JSX and Gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to master JSX and learn some Gotchas. You're going to learn some
    basic concepts to build ReactJS UI components using JSX. It includes practices
    when writing expressions, conditions, and creating lists of components. It will
    also walk you through how JSX differs from HTML (because it's not HTML) in some
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: JSX understands the curly braces `{}` whenever you want to put JavaScript code
    within your presentation code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, let's improve our `Clock` component by supporting greetings
    depending on what the time is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the highlighted code mentioned later, if the current hour is lesser than
    `4`, it should return `day`, and if the hour is greater than `4` but less than
    `18`, it should return `night`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's possible to make a ternary within the curly braces. You
    can place any valid JavaScript code within them. It's more common to create a
    variable and address it to the result of this expression before rendering your
    component. This makes your code cleaner and more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will demonstrate how to render a component based on
    a condition. There are two components, one for login and the other for the user
    details. It depends on the fact that if the user is logged in, the user details
    component will be shown; otherwise, the login one will be rendered. The code to
    detect whether the user is logged in or not will be skipped, as this is just to
    demonstrate how to put rendering logic inside ReactJS components using JSX syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can put this code inside a component that contains all other components
    as children, as demonstrated in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Properties/attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properties allow you to customize your components, and JSX supports them in
    a very similar way to HTML elements. You can pass properties to ReactJS elements
    and get them before rendering the component. This is a very key fundamental of
    ReactJS, and you're going to learn how to work with them using JSX. In the next
    chapter, we'll dive into how properties work and discuss good practices on how
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to render this component, you have to pass properties to it, just
    like we do in HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use expressions inside properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we don't set the properties (name) required by a component, in our last example,
    it will be rendered as an empty string. Thus, if there are expressions trying
    to access that property, then it will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passing properties throughout your component hierarchy is a very common thing
    to do in ReactJS. You can think of properties as a way of making your component
    dynamic, and because you are splitting your components into smaller ones, you
    need an efficient way to pass incoming configuration and data to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following nested components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it's possible to pass properties to child components. If you
    have lots of properties to pass on, it becomes a tedious task to do and your code
    will get very messy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, you can transfer them in a fancy way that JSX provides us. All
    you''re going to do is to change your `App` component, so it can pass all its
    properties on that were received by the `React.render` function. This is done
    using the spread operator `{...this.props}` notation that JSX understands. The
    following is an example explaining this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Much clearer! However, there is still a problem with that solution. It can
    override properties on your subcomponents. Let''s take another example, imagine
    you have a property named `name`, and you want to pass it along. Some elements,
    basically HTML input elements, have this attribute to define their names inside
    forms. If you change it, it can result in unexpected consequences. Another example
    is the input checkbox or radio. Both have an attribute named `checked`, which
    defines whether the control will be visually checked. If you pass on a property
    named `checked,` it''d definitely result in a bad behavior. In order to avoid
    this, it''s possible to skip some properties using the same notation. You just
    need to specify them as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Everything that comes before the three dots, `...`, will be considered as separated
    variables, and the one that comes after the three dots, `...`, will be addressed
    to an array with all the remaining properties. This is an experimental ES6 (ECMA
    Script) syntax, and there are some ways you can transform that code into plain
    JavaScript. Details of ES6 are covered later in [Chapter 5](part0033_split_000.html#page
    "Chapter 5. Component Life cycle and Newer ECMAScript in React"), *Component Lifecycle
    and Newer ECMA Script in React*.
  prefs: []
  type: TYPE_NORMAL
- en: By looking through [https://www.npmjs.com/package/react-tools](https://www.npmjs.com/package/react-tools),
    you can find the details of the different options you can pass with the JSX Transformer.
  prefs: []
  type: TYPE_NORMAL
- en: '`--harmony`: turns on JS transformations such as ES6 classes and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the ES6 syntax will be transformed into ES5-compatible syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is to put an extra argument named `harmony` on your HTML `script`
    element so that the transformer will know that it''s going to need to understand
    the new version of ECMAScript in order to transform. This is how your script tag
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES6 (also known as Harmony) is a version (actual is ES5) of ECMAScript that
    is a standardized scripting language. The most known implementation of this standard
    is the JavaScript language, but there are many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `react-tools` node package. This exposes a command named
    `jsx` that can transform your files offline. In order to use it, you''re going
    to need to run this command from any console tool within your application''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `-x` option allows you to specify the syntax to search for. In our examples,
    we are creating the `.jsx` files, but you could also do that with the `.js` files
    that have the JSX code inside. The `--harmony` option is the same from the last
    example. It tells the transformer to understand ES6/ES7 features of the JavaScript
    language.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out how to install `react-tools` in the earlier section *Tools
    for transforming JSX*, as discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The reason to use the `.jsx` files is it facilitates text editors to match an
    installed syntax highlight without the need for configuring it.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once your React component is rendered, it''s not recommended to mutate its
    properties. This is considered an antipattern. Properties are immutable, and they
    roughly represent your presentation once it''s rendered. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although this work has a great chance to end up in unexpected results. The component's
    state is the only way to mutate data in a ReactJS component. The next two chapters
    cover details of props and states and when and where they should be used. States
    and properties are both keys in how ReactJS core works.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX allows you to place comments in your code; they differ in syntax depending
    on whether you''re placing them in a nested component or outside of it. Follow
    the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When within a nested component, you just need to wrap your comment with curly
    braces (like expressions).
  prefs: []
  type: TYPE_NORMAL
- en: Component style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can either style your component with the `className` or `style` properties.
    The `className` property works in the same way HTML class does and the `style`
    property applies inline style to your component, also similar to HTML. It's up
    to you to choose one that you prefer; both of them have an easy way to be handled
    in ReactJS, mainly when you need it to be dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever you want to apply style to your component, you can use a JavaScript
    object to do so. This object''s properties must match the DOM style specification,
    such as `height`, `width`, and so on. See the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to render a red small square `div` with text inside. You can
    move this style object to a variable and dynamically set that depending on your
    component properties or state. Properties and state will be discussed later in
    [Chapter 3](part0025_split_000.html#page "Chapter 3. Working with Properties"),
    *Breaking Your UI into Components* and [Chapter 4](part0029_split_000.html#page
    "Chapter 4. Stateful Components and Events"), *Stateful Components and Events*,
    respectively. For demonstration purposes, this is how you move this style object
    out of the component markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When you have styles where names are separated by dashes `-`, you need to write
    them in CamelCase, as you can see in our example for the `backgroundColor` style
    property earlier. Vendor prefixes other than `ms` should begin with a capital
    letter; for example, `WebkitTransition` will be transformed to `webkit-transition`
    and `msTransition` will be transformed to `ms-transition`. All other vendor names
    must begin with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: CSS classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to add CSS classes to your component, you need to specify the `className`
    property for them: `<component className="class1 class2" />`. Unfortunately, `className`
    doesn''t support an object literal like style does. If we want to change them
    dynamically, you need to concatenate strings or use classnames from [https://github.com/JedWatson/classnames](https://github.com/JedWatson/classnames).
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are concatenating strings, but this is a very tedious task
    to do, and it might lead to mistakes and errors. There is a class manipulation
    utility provided by ReactJS add-ons. If we are using ReactJS library script file,
    you should get the one that comes with add-ons embedded, as mentioned in downloading
    the ReactJS section on [Chapter 1](part0015_split_000.html#page "Chapter 1. Getting
    Started with ReactJS"), *Getting Started with ReactJS*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you are using node or other CommonJS/AMD package to require ReactJS dependency,
    you can reference add-ons through requiring `require('react/addons')` instead
    of just requiring React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check how our code functions using this utility code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Try changing the `isUrgent` property and see that the class property changes
    when you reload the page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned what JSX is, its syntax, and why it is necessary.
    We looked into some examples and how to build them using JSX. We covered very
    basic principles of ReactJS and how JSX helps you build components faster, easy
    to read, and reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to dive into ReactJS properties and how to
    break the UI into smaller components. You are going to learn it by creating a
    small application that will consume the Facebook Open Graph API and list your
    liked pages.
  prefs: []
  type: TYPE_NORMAL
