- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Building Custom React Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Custom React 钩子
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够做到以下几件事情：
- en: Build your own React Hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建您自己的 React 钩子
- en: Use custom and default React Hooks in your components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的组件中使用自定义和默认 React 钩子
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Throughout this book, one key React feature has been referenced repeatedly in
    many different variations. That feature is React Hooks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，一个关键的 React 功能被反复以许多不同的变体引用。这个功能就是 React 钩子。
- en: Hooks power almost all core functionalities and concepts offered by React—from
    state management in a single component to accessing cross-component state (context)
    in multiple components. They enable you to access JSX elements via refs and allow
    you to handle side effects inside of component functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子几乎提供了 React 所有的核心功能和概念——从单个组件中的状态管理到在多个组件中访问跨组件状态（上下文）。它们允许您通过 refs 访问 JSX
    元素，并允许您在组件函数内部处理副作用。
- en: Without Hooks, modern React would not work, and building feature-rich applications
    would be impossible.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 没有钩子，现代 React 就无法工作，构建功能丰富的应用程序将是不可能的。
- en: Thus far, only built-in Hooks have been introduced and used. However, you can
    build your own custom Hooks as well—or you can use custom Hooks built by other
    developers (e.g., by using third-party libraries). In this chapter, you will learn
    why you might want to do this and how it works.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，只介绍了内置钩子并使用了它们。然而，您也可以构建自己的自定义钩子——或者您可以使用其他开发者构建的自定义钩子（例如，通过使用第三方库）。在本章中，您将了解为什么您可能想要这样做以及它是如何工作的。
- en: Introducing Custom Hooks
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Custom 钩子
- en: Before starting to build custom Hooks, it’s very important to understand what
    exactly custom Hooks are.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建自定义钩子之前，了解自定义钩子究竟是什么非常重要。
- en: 'In React apps, custom Hooks are regular JavaScript functions that satisfy the
    following conditions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用中，自定义钩子是满足以下条件的常规 JavaScript 函数：
- en: 'The function name starts with `use` (just as all built-in Hooks start with
    `use` : `useState()` , `useReducer()` , etc.).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称以 `use` 开头（就像所有内置钩子一样以 `use` 开头：`useState()` 、`useReducer()` 等）。
- en: The function calls another React Hook (a built-in one or a custom one—doesn’t
    matter).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用另一个 React 钩子（一个内置的或自定义的——无关紧要）。
- en: The function does not just return JSX code (otherwise, it would essentially
    be a React component), though it could return some JSX code—as long as that’s
    not the only value returned.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数不仅返回 JSX 代码（否则，它本质上就是一个 React 组件），尽管它可以返回一些 JSX 代码——只要这不是返回的唯一值。
- en: If a function meets these three conditions, it can (and should) be called a
    custom (React) Hook. So, custom Hooks are really just normal functions with special
    names (starting with `use` ) that call other (custom or built-in) Hooks and that
    do not (just) return JSX code. If you try to call a (custom or built-in) Hook
    in some other place (e.g., outside of any function or in a regular, non-Hook function),
    you might get a warning (depending on your project setup; see below).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数满足以下三个条件，它可以（并且应该）被称为自定义（React）钩子。因此，自定义钩子实际上只是具有特殊名称（以 `use` 开头）的正常函数，这些函数调用其他（自定义或内置）钩子，并且不（仅）返回
    JSX 代码。如果您在其他地方（例如，在函数外部或在常规的非钩子函数中）尝试调用（自定义或内置）钩子，您可能会收到警告（取决于您的项目设置；见下文）。
- en: 'For example, the following function uses the `useEffect()` Hook but has a name
    that does not start with `use` . It is therefore not in line with the official
    naming recommendation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数使用了 `useEffect()` 钩子，但其名称不以 `use` 开头。因此，它不符合官方的命名建议：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In projects that perform code linting to check your code for rule violations,
    this code would produce a warning because this function doesn’t qualify as a custom
    Hook (due to its name).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码检查以查找规则违规的项目中，此代码将产生警告，因为此函数不符合自定义钩子的资格（由于其名称）。
- en: '![img](img/B31339_12_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_12_01.png)'
- en: 'Figure 12.1: React complains if you call a Hook function in the wrong place'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：React 会抱怨你在错误的位置调用钩子函数
- en: As the warning states, Hooks, whether custom or built-in, must only be called
    inside component functions. And, even though the warning message doesn’t explicitly
    mention it, they may also be called inside of custom Hooks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如警告所述，无论是自定义还是内置的钩子，都必须仅在组件函数内部调用。尽管警告消息没有明确提到，它们也可以在自定义钩子内部调用。
- en: So, if the `sendAnalyticsEvent()` function is renamed `useSendAnalyticsEvent()`
    , the warning disappears since the function now qualifies as a custom Hook.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将 `sendAnalyticsEvent()` 函数重命名为 `useSendAnalyticsEvent()` ，警告就会消失，因为现在该函数符合自定义钩子的资格。
- en: Even though it’s technically not a hard rule that’s enforced by React itself,
    it’s a strong recommendation to follow this naming convention.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从技术上讲，这不是React本身强制执行的规定规则，但强烈建议遵循此命名约定。
- en: Being able to build custom Hooks is an extremely important feature because it
    means that you can build reusable non-component functions that can contain state
    logic (via `useState()` or `useReducer()` ), handle side effects in your reusable
    custom Hook functions (via `useEffect()` ), or use any other React Hook. With
    normal, non-Hook functions, none of these would be possible, and you would therefore
    be unable to outsource any logic that involves a React Hook into such functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 能够构建自定义钩子是一个极其重要的功能，因为它意味着你可以构建包含状态逻辑的可重用非组件函数（通过`useState()`或`useReducer()`），在你的可重用自定义钩子函数中处理副作用（通过`useEffect()`），或使用任何其他React钩子。使用正常的非钩子函数，这些都不可能实现，因此你将无法将这些涉及React钩子的任何逻辑外包到这样的函数中。
- en: In this way, custom Hooks complement the concept of React components. While
    React components are reusable UI building blocks (which may contain stateful logic),
    custom Hooks are reusable logic snippets that can be used in your component functions.
    Thus, custom Hooks help you reuse shared logic across components. For example,
    custom Hooks enable you to outsource the logic for sending an HTTP request and
    handling the related states (loading, error, etc.).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，自定义钩子补充了React组件的概念。虽然React组件是可重用的UI构建块（可能包含状态逻辑），但自定义钩子是可重用的逻辑片段，可以在你的组件函数中使用。因此，自定义钩子帮助你跨组件重用共享逻辑。例如，自定义钩子使你能够将发送HTTP请求和处理相关状态（加载、错误等）的逻辑外包出去。
- en: Why Would You Build Custom Hooks?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你会构建自定义钩子？
- en: 'In the previous chapter ( *Chapter 11* , *Working with Complex State* ), when
    the `useReducer()` Hook was introduced, an example was provided in which the Hook
    was utilized in sending an HTTP request. Here’s the relevant, final code again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（*第11章*，*处理复杂状态*）中，当介绍了`useReducer()`钩子时，提供了一个示例，其中钩子被用于发送HTTP请求。这里再次提供相关的最终代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code example, an HTTP request is sent whenever the `App` component is
    rendered for the first time. The HTTP request fetches a list of (dummy) posts.
    Until the request finishes, a loading message ( `<p>Loading…</p>` ) is displayed
    to the user. If there’s an error, an error message is displayed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，每当`App`组件首次渲染时，就会发送一个HTTP请求。HTTP请求获取一个（虚拟的）帖子列表。在请求完成之前，向用户显示一个加载消息（`<p>Loading…</p>`）。如果有错误，则显示错误消息。
- en: As you can see, quite a lot of code must be written to handle this relatively
    basic use case. And, especially in bigger React apps, it is quite likely that
    multiple components will need to send HTTP requests. They probably won’t need
    to send the exact same request to the same URL ( `https://jsonplaceholder.typicode.com/posts`
    , in this example), but it’s definitely possible that different components will
    fetch different data from different URLs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，必须编写相当多的代码来处理这个相对基本的使用场景。特别是在更大的React应用程序中，很可能多个组件需要发送HTTP请求。它们可能不需要发送到相同URL（例如，`https://jsonplaceholder.typicode.com/posts`）的完全相同的请求，但肯定有可能不同的组件会从不同的URL获取不同的数据。
- en: Therefore, almost the exact same code must be written over and over again in
    multiple components. And it’s not just the code for sending the HTTP request (i.e.,
    the function wrapped by `useCallback()` ). Instead, the HTTP-related state management
    (done via `useReducer()` , in this example), as well as the request initialization
    via `useEffect()` , must be repeated in all those components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，几乎完全相同的代码必须在多个组件中反复编写。这不仅仅是发送HTTP请求的代码（即由`useCallback()`包装的函数）。相反，HTTP相关的状态管理（在本例中通过`useReducer()`完成），以及通过`useEffect()`进行的请求初始化，必须在所有这些组件中重复。
- en: And that is where custom Hooks come in to save the day. Custom Hooks help you
    avoid this repetition by allowing you to build reusable, potentially stateful
    “logic snippets” that can be shared across components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正是自定义钩子（Custom Hooks）在这里拯救了局面。自定义钩子通过允许你构建可重用、可能具有状态的“逻辑片段”，这些片段可以在组件之间共享，帮助你避免这种重复。
- en: A First Custom Hook
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个自定义钩子
- en: 'Before exploring advanced scenarios and solving the HTTP request problem mentioned
    previously, here’s a more basic example of a first, custom Hook:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索高级场景和解决之前提到的HTTP请求问题之前，这里有一个更基本的第一个自定义钩子的例子：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code can be stored in a file named `use-counter.js` inside a `hooks/` folder—though
    both names are totally up to you. There are no rules regarding the file or the
    folder name (or, in general, the place where you store this code). The file extension
    is `.js` instead of `.jsx` since this file contains no JSX code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以存储在 `hooks/` 文件夹内的一个名为 `use-counter.js` 的文件中——尽管这两个名称完全由您决定。关于文件名或文件夹名（或一般而言，存储此代码的位置）没有规则。由于此文件不包含
    JSX 代码，因此文件扩展名是 `.js` 而不是 `.jsx`。
- en: As you can see, `useCounter` is a regular JavaScript function. The name of the
    function starts with `use` , and therefore this function qualifies as a custom
    Hook (meaning you won’t get any warning messages when using other Hooks inside
    of it).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`useCounter` 是一个常规的 JavaScript 函数。函数名以 `use` 开头，因此这个函数符合自定义钩子的标准（这意味着在它内部使用其他钩子时，您不会收到任何警告信息）。
- en: Inside `useCounter()` , a `counter` state is managed via `useState()` . The
    state is changed via two nested functions ( `increment` and `decrement` ), and
    the state, as well as the functions, is returned by `useCounter` (grouped together
    in a JavaScript object).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `useCounter()` 内部，通过 `useState()` 管理一个 `counter` 状态。状态通过两个嵌套函数（`increment`
    和 `decrement`）进行更改，状态以及函数都由 `useCounter` 返回（在 JavaScript 对象中一起分组）。
- en: '**Note**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'The syntax used to group `counter` , `increment` , and `decrement` together
    uses a regular JavaScript feature: shorthand property names.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `counter`、`increment` 和 `decrement` 一起分组的语法使用了常规的 JavaScript 功能：简写属性名。
- en: If a property name in an object literally matches the name of the variable whose
    value is assigned to the property, you can use this shorter notation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象的属性名与分配给该属性的变量的名称完全匹配，您可以使用这种简短的表示法。
- en: 'Instead of writing `{ counter: counter, increment: increment, decrement: decrement
    }` , you can use the shorthand notation `{ counter, increment, decrement }` shown
    in the snippet above.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '而不是编写 `{ counter: counter, increment: increment, decrement: decrement }`，您可以使用上面片段中显示的简写表示法
    `{ counter, increment, decrement }`。'
- en: This custom Hook can be stored in a separate file (e.g., in a `hooks` folder
    inside the React project, such as `src/hooks/use-counter.js` ). Thereafter, it
    can be used in any React component, and you can use it in as many React components
    as needed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子可以存储在单独的文件中（例如，在 React 项目的 `hooks` 文件夹中，如 `src/hooks/use-counter.js`）。之后，它可以在任何
    React 组件中使用，并且您可以在所需的任何数量的 React 组件中使用它。
- en: 'For example, the following two components ( `Demo1` and `Demo2` ) could use
    this `useCounter` Hook as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下两个组件（`Demo1` 和 `Demo2`）可以这样使用这个 `useCounter` 钩子：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Note**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You will find the full example code at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/01-first-hook](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/01-first-hook)
    .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/01-first-hook](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/01-first-hook)
    找到完整的示例代码。
- en: The `Demo1` and `Demo2` components both execute `useCounter()` inside of their
    component functions. The `useCounter()` function is called a normal function because
    it is a regular JavaScript function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Demo1` 和 `Demo2` 组件都在它们的组件函数内部执行 `useCounter()`。`useCounter()` 函数被称为普通函数，因为它是一个常规的
    JavaScript 函数。'
- en: Since the `useCounter` Hook returns an object with three properties ( `counter`
    , `increment` , and `decrement` ), `Demo1` and `Demo2` use object destructuring
    to store the property values in local constants. These values are then used in
    the JSX code to output the `counter` value and connect the two `<button>` elements
    to the `increment` and `decrement` functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `useCounter` 钩子返回一个包含三个属性（`counter`、`increment` 和 `decrement`）的对象，`Demo1`
    和 `Demo2` 使用对象解构将属性值存储在局部常量中。然后，这些值在 JSX 代码中用于输出 `counter` 值，并将两个 `<button>` 元素连接到
    `increment` 和 `decrement` 函数。
- en: 'After pressing the buttons a couple of times each, the resulting user interface
    might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮按了几次之后，最终的用户界面可能看起来像这样：
- en: '![A screenshot of a calendar  Description automatically generated](img/B31339_12_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![日历的截图 自动生成描述](img/B31339_12_02.png)'
- en: 'Figure 12.2: Two independent counters'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：两个独立的计数器
- en: In this screenshot, you can also see a very interesting and important behavior
    of custom Hooks. That is, if the same stateful custom Hook is used in multiple
    components, every component gets its own state. The `counter` state is not shared.
    The `Demo1` component manages its own `counter` state (through the `useCounter()`
    custom Hook), and so does the `Demo2` component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图上，你还可以看到一个非常有趣且重要的自定义钩子行为。那就是，如果多个组件中使用了相同的具有状态的自定义钩子，每个组件都会得到自己的状态。`counter`状态是不共享的。`Demo1`组件通过`useCounter()`自定义钩子管理自己的`counter`状态，`Demo2`组件也是如此。
- en: 'Custom Hooks: A Flexible Feature'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义钩子：一个灵活的功能
- en: 'The two independent states of `Demo1` and `Demo2` show a very important feature
    of custom Hooks: you use them to share logic, not state. If you needed to share
    state across components, you would do so with React context (see the previous
    chapter).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Demo1`和`Demo2`的两个独立状态展示了自定义钩子的一个非常重要的特性：你使用它们来共享逻辑，而不是状态。如果你需要在组件之间共享状态，你将使用React上下文（参见上一章）。'
- en: When using Hooks, every component uses its own “instance” (or “version”) of
    that Hook. It’s always the same logic, but any state or side effects handled by
    a Hook are handled on a per-component basis.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用钩子时，每个组件都会使用该钩子的自己的“实例”（或“版本”）。逻辑始终相同，但钩子处理的任何状态或副作用都是基于每个组件的。
- en: It’s also worth noting that custom Hooks **can** be stateful but **don’t have
    to be** . They can manage state via `useState()` or `useReducer()` , but you could
    also build custom Hooks that only handle side effects (without any state management).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点也值得注意，自定义钩子**可以**有状态，但**不一定**必须有状态。它们可以通过`useState()`或`useReducer()`来管理状态，但你也可以构建只处理副作用（没有任何状态管理）的自定义钩子。
- en: 'There’s only one thing you implicitly have to do in custom Hooks: you must
    use some other React Hook (custom or built-in). This is because if you didn’t
    include any other Hook, there would be no need to build a custom Hook in the first
    place. A custom Hook is just a regular JavaScript function (with a name starting
    with `use` ) with which you are allowed to use other Hooks. If you don’t need
    to use any other Hooks, you can simply build a normal JavaScript function with
    a name that does not start with `use` .'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义钩子中，你隐式地必须做的一件事是：你必须使用其他React钩子（自定义或内置的）。这是因为如果你没有包含任何其他钩子，那么最初就没有必要构建自定义钩子。自定义钩子只是一个普通的JavaScript函数（以`use`开头命名），允许你使用其他钩子。如果你不需要使用任何其他钩子，你可以简单地构建一个不以`use`开头的普通JavaScript函数。
- en: You also have a lot of flexibility regarding the logic inside the Hook, its
    parameters, and the value it returns. Regarding the Hook logic, you can add as
    much logic as needed. You can manage no state or multiple state values. You can
    include other custom Hooks or only use built-in Hooks. You can manage multiple
    side effects, work with refs, or perform complex calculations. There are no restrictions
    regarding what can be done in a custom Hook.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你在钩子内部的逻辑、其参数以及它返回的值方面也有很多灵活性。关于钩子逻辑，你可以添加所需的任何逻辑。你可以管理没有状态或多个状态值。你可以包含其他自定义钩子或仅使用内置钩子。你可以管理多个副作用，与refs一起工作，或执行复杂的计算。在自定义钩子中可以做的事情没有限制。
- en: Custom Hooks and Parameters
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义钩子和参数
- en: 'You can also accept and use parameters in your custom Hook functions. For example,
    the `useCounter` Hook from the *A First Custom Hook* section can be adjusted to
    take an initial counter value and separate values by which the counter should
    be increased or decreased, as shown in the following snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在自定义钩子函数中接受和使用参数。例如，*第一个自定义钩子*部分的`useCounter`钩子可以被调整以接受一个初始计数器值和计数器应该增加或减少的单独值，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this adjusted example, the `initialValue` parameter is used to set the initial
    state via `useState(initialValue)` . The `incVal` and `decVal` parameters are
    used in the `increment` and `decrement` functions to change the `counter` state
    with different values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调整后的示例中，`initialValue`参数用于通过`useState(initialValue)`设置初始状态。`incVal`和`decVal`参数用于`increment`和`decrement`函数中，以不同的值改变`counter`状态。
- en: 'Of course, once parameters are used in a custom Hook, fitting parameter values
    must be provided when the custom Hook is called in a component function (or in
    another custom Hook). Therefore, the code for the `Demo1` and `Demo2` components
    must also be adjusted—for example, like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦在自定义钩子中使用了参数，在组件函数（或在另一个自定义钩子）中调用自定义钩子时，必须提供合适的参数值。因此，`Demo1`和`Demo2`组件的代码也必须进行调整——例如，如下所示：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Note**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can also find this code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/02-parameters](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/02-parameters)
    .
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在GitHub上找到此代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/02-parameters](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/02-parameters)。
- en: Now, both components pass different parameter values to the `useCounter` Hook
    function. Therefore, they can reuse the same Hook and its internal logic dynamically.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个组件将不同的参数值传递给`useCounter`钩子函数。因此，它们可以动态地重用相同的钩子和其内部逻辑。
- en: Custom Hooks and Return Values
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义钩子和返回值
- en: 'As shown with `useCounter` , custom Hooks may return values. And this is important:
    they **may** return values, but they don’t have to. If you build a custom Hook
    that only handles some side effects (via `useEffect()` ), you don’t have to return
    any value (because there probably isn’t any value that should be returned).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如`useCounter`所示，自定义钩子可以返回值。而且这是重要的：它们**可以**返回值，但不必这样做。如果您构建了一个仅处理一些副作用（通过`useEffect()`）的自定义钩子，您不必返回任何值（因为可能没有应该返回的值）。
- en: But if you do need to return a value, you decide which type of value you want
    to return. You could return a single number or string. If your Hook must return
    multiple values (like `useCounter` does), you can group these values into an array
    or object. You can also return arrays that contain objects or vice versa. In short,
    you can return anything. It is a normal JavaScript function, after all.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您确实需要返回一个值，您决定您想要返回哪种类型的值。您可以返回一个单独的数字或字符串。如果您的钩子必须返回多个值（如`useCounter`所做的那样），您可以将这些值组合成一个数组或对象。您还可以返回包含对象的数组或反之亦然。简而言之，您可以返回任何内容。毕竟，它是一个正常的JavaScript函数。
- en: Some built-in Hooks such as `useState()` and `useReducer()` return arrays (with
    a fixed number of elements). `useRef()` , on the other hand, returns an object
    (which always has a `current` property). `useEffect()` returns nothing. Your Hooks
    can therefore return whatever you want.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置钩子，如`useState()`和`useReducer()`，返回数组（具有固定数量的元素）。另一方面，`useRef()`返回一个对象（它始终具有一个`current`属性）。`useEffect()`不返回任何值。因此，您的钩子可以返回您想要的任何内容。
- en: 'For example, the `useCounter` Hook from previously could be rewritten to return
    an array instead:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，之前提到的`useCounter`钩子可以被重写为返回一个数组：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use the returned values, then, the `Demo1` and `Demo2` components need to
    switch from object destructuring to array destructuring, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用返回的值，`Demo1`和`Demo2`组件需要从对象解构切换到数组解构，如下所示：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two components behave like before, so you can decide which return value
    you prefer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个组件的行为与之前相同，因此您可以决定您更喜欢哪种返回值。
- en: '**Note**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This finished code can also be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/03-return-values](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/03-return-values)
    .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段完成后的代码也可以在GitHub上找到：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/03-return-values](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/examples/03-return-values)。
- en: A More Complex Example
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更复杂的例子
- en: The previous examples were deliberately rather simple. Now that the basics of
    custom Hooks are clear, it makes sense to dive into a slightly more advanced and
    realistic example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子故意比较简单。现在，自定义钩子的基础知识已经清楚，深入一个稍微复杂和现实的例子是有意义的。
- en: 'Consider the HTTP request example from the beginning of this chapter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑本章开头提到的HTTP请求示例：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In that example, the entire `useReducer()` logic (including the reducer function,
    `httpReducer` ) and the `useEffect()` call can be outsourced into a custom Hook.
    The result would be a very lean `App` component and a reusable Hook that could
    be used in other components as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个例子中，整个`useReducer()`逻辑（包括reducer函数`httpReducer`）和`useEffect()`调用都可以外包到一个自定义钩子中。结果将是一个非常精简的`App`组件和一个可重用的钩子，它也可以在其他组件中使用。
- en: Building a First Version of the Custom Hook
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义钩子的第一个版本
- en: 'This custom Hook could be named `useFetch` (since it fetches data), and it
    could be stored in `hooks/use-fetch.js` . Of course, both the Hook name as well
    as the file storage path are up to you. Here’s how the first version of `useFetch`
    might look:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子可以命名为`useFetch`（因为它用于获取数据），并且它可以存储在`hooks/use-fetch.js`中。当然，钩子名称以及文件存储路径由您决定。以下是`useFetch`的第一个版本可能看起来像这样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please note that this is not the final version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并非最终版本。
- en: In this first version, the `useFetch` Hook contains the `useReducer()` and `useEffect()`
    logic. It’s worth noting that the `httpReducer` function is created outside of
    `useFetch` . This ensures that the function is not recreated unnecessarily when
    `useFetch()` is re-executed (which will happen often as it is called every time
    the component that uses this Hook is re-evaluated). The `httpReducer` function
    will therefore only be created once (for the entire application lifetime), and
    that same function instance will be shared by all components that use `useFetch`
    .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个版本中，`useFetch` 钩子包含了 `useReducer()` 和 `useEffect()` 逻辑。值得注意的是，`httpReducer`
    函数是在 `useFetch` 外部创建的。这确保了当 `useFetch()` 重新执行时（这将在使用此钩子的组件重新评估时经常发生），函数不会被不必要地重新创建。因此，`httpReducer`
    函数将只创建一次（对于整个应用程序的生命周期），并且相同的函数实例将由所有使用 `useFetch` 的组件共享。
- en: Since `httpReducer` is a pure function (that is, it always produces new return
    values that are based purely on the parameter values), sharing this function instance
    is fine and won’t cause any unexpected bugs. If `httpReducer` were to store or
    manipulate any values that are not based on function inputs, it should be created
    inside of `useFetch` instead. This way, you avoid having multiple components accidentally
    manipulate and use shared values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `httpReducer` 是一个纯函数（即，它总是基于参数值产生新的返回值），共享这个函数实例是可以的，并且不会引起任何意外的错误。如果 `httpReducer`
    要存储或操作任何不是基于函数输入的值，它应该创建在 `useFetch` 内部。这样，你可以避免多个组件意外地操作和使用共享值。
- en: 'However, this version of the `useFetch` Hook has two big issues:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个版本的 `useFetch` 钩子有两个主要问题：
- en: Currently, no value is returned. Therefore, components that use this Hook won’t
    get access to the fetched data or the loading state.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前没有返回任何值。因此，使用这个钩子的组件将无法访问获取的数据或加载状态。
- en: The HTTP request URL is hardcoded into `useFetch` . As a result, all components
    that use this Hook will send the same kind of request to the same URL.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 请求 URL 被硬编码到 `useFetch` 中。因此，所有使用这个钩子的组件都会向相同的 URL 发送相同类型的请求。
- en: Therefore, to improve this Hook, these two issues must be tackled—starting with
    the first one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了改进这个钩子，必须解决这两个问题——从第一个问题开始。
- en: Making the Hook Useful by Returning Values
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过返回值使钩子变得有用
- en: 'The first issue can be solved by returning the fetched data (or `undefined`
    , if no data was fetched yet), the loading state value, and the error value. Since
    these values are exactly the values that make up the `httpState` object returned
    by `useReducer()` , `useFetch` can simply return that entire `httpState` object,
    as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题可以通过返回获取的数据（如果没有获取数据，则为 `undefined`）、加载状态值和错误值来解决。由于这些值正好是 `useReducer()`
    返回的 `httpState` 对象的组成部分，`useFetch` 可以简单地返回整个 `httpState` 对象，如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only thing that changed in this code snippet is the last line of the `useFetch`
    function. With `return httpState` , the state managed by `useReducer()` (and therefore
    by the `httpReducer` function) is returned by the custom Hook.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，唯一改变的是 `useFetch` 函数的最后一行。通过 `return httpState`，`useReducer()`（因此是
    `httpReducer` 函数）管理的状态由自定义钩子返回。
- en: With that first issue fixed, the next step is to also make the Hook more reusable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了第一个问题之后，下一步是也要使钩子更具可重用性。
- en: Improving Reusability by Accepting an Input Parameter
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过接受输入参数提高可重用性
- en: 'To fix the second problem (i.e., the hardcoded URL), a parameter should be
    added to `useFetch` :'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复第二个问题（即硬编码的 URL），应向 `useFetch` 添加一个参数：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this snippet, the `url` parameter was added to `useFetch` . This parameter
    value is then used inside the `try` block when calling `fetch(url)` . Please note
    that `url` was also added as a dependency to the `useCallback()` dependencies
    array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`url` 参数被添加到了 `useFetch` 中。这个参数值随后在调用 `fetch(url)` 时在 `try` 块内使用。请注意，`url`
    也被添加到了 `useCallback()` 依赖数组中。
- en: 'Since `useCallback()` is wrapped around the fetching function (to prevent infinite
    loops by `useEffect()` ), any external values used inside of `useCallback()` must
    be added to its dependencies array. Since `url` is an external value (meaning
    it’s not defined inside of the wrapped function), it must be added. This also
    makes sense logically: if the `url` parameter were to change (i.e., if the component
    that uses `useFetch` changes it), a new HTTP request should be sent.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`useCallback()`被包装在获取函数周围（以防止`useEffect()`造成的无限循环），`useCallback()`内部使用的任何外部值都必须添加到其依赖项数组中。由于`url`是外部值（意味着它不在包装函数内部定义），因此必须添加。这在逻辑上也是合理的：如果`url`参数发生变化（即，如果使用`useFetch`的组件更改它），则应发送新的HTTP请求。
- en: This final version of the `useFetch` Hook can now be used in all components
    to send HTTP requests to different URLs and use the HTTP state values as needed
    by the components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此`useFetch`钩子的最终版本现在可以在所有组件中使用，以向不同的URL发送HTTP请求，并按组件所需使用HTTP状态值。
- en: 'For example, the `App` component can use `useFetch` like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`App`组件可以这样使用`useFetch`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The component imports and calls `useFetch()` (with the appropriate URL as an
    argument) and uses object destructuring to get the `data` , `isLoading` , and
    `error` properties from the `httpState` object. These values are then used in
    the JSX code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 组件导入并调用`useFetch()`（以适当的URL作为参数），并使用对象解构从`httpState`对象中获取`data`、`isLoading`和`error`属性。然后，这些值在JSX代码中使用。
- en: 'Of course, the `useFetch` Hook could also return a pointer to the `fetchPosts`
    function (in addition to `httpState` ) to allow components such as the `App` component
    to manually trigger a new request, as shown here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`useFetch`钩子也可以返回指向`fetchPosts`函数的指针（除了`httpState`），以允许像`App`组件这样的组件手动触发新的请求，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the `return` statement was changed. Instead of returning just
    `httpState` , `useFetch` now returns an array that contains the `httpState` object
    and a pointer to the `fetchPosts` function. Alternatively, `httpState` and `fetchPosts`
    could have been merged into an object (instead of an array).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`return`语句已更改。现在`useFetch`返回一个包含`httpState`对象和指向`fetchPosts`函数的指针的数组。或者，`httpState`和`fetchPosts`可以合并到一个对象中（而不是数组）。
- en: 'In the `App` component, `useFetch` could now be used like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`组件中，现在可以这样使用`useFetch`：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `App` component uses array and object destructuring combined to extract
    the returned values (and the values nested in the `httpState` object). A newly
    added `<button>` element is then used to trigger the `fetchPosts` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件使用数组和对象解构结合提取返回的值（以及嵌套在`httpState`对象中的值）。然后，添加了一个新的`<button>`元素来触发`fetchPosts`函数。'
- en: This example effectively shows how custom Hooks can lead to much leaner component
    functions by allowing easy logic reuse, with or without state or side effects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有效地展示了自定义钩子如何通过允许轻松的逻辑重用，无论是否有状态或副作用，从而使得组件函数更加精简。
- en: In addition, Hooks can also enable some interesting patterns—for example, related
    to React’s Context API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，钩子还可以启用一些有趣的模式——例如，与React的Context API相关。
- en: Using Custom Hooks for Context Access
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义钩子进行上下文访问
- en: As hinted in the previous chapter, in the *Outsourcing Context Logic into Separate
    Components* section, you can use custom Hooks to improve the process of consuming
    context values in components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章中所述，在*将上下文逻辑外包到单独组件中*部分，你可以使用自定义钩子来改进在组件中消费上下文值的过程。
- en: 'For example, if you provide some context named `BookmarkContext` (e.g., via
    a `<BookmarkContextProvider>` component), you can access this context value inside
    components like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你提供一些名为`BookmarkContext`的上下文（例如，通过`<BookmarkContextProvider>`组件），你可以在组件内部这样访问此上下文值：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, instead of directly accessing the context value like this, you could
    also build the following custom Hook (e.g., stored in a `store/use-bookmark-context.js`
    file):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不必像这样直接访问上下文值，也可以构建以下自定义钩子（例如，存储在`store/use-bookmark-context.js`文件中）：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But, of course, this Hook doesn’t really provide any advantages compared to
    directly consuming the context value in a component via `use()` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但，当然，这个钩子与通过`use()`在组件中直接消费上下文值相比，并没有提供任何优势。
- en: 'That changes once you enrich this custom Hook with more useful logic—for example,
    with error handling if it’s used in a place where the context is not available:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用更多有用的逻辑丰富了此自定义钩子——例如，如果它在没有上下文可用的地方使用，则包含错误处理：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This Hook can then be used in your components to get hold of the context value
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子然后可以在你的组件中使用，以获取上下文值，如下所示：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This therefore is not just another example of a custom Hook, but also a common
    pattern you should know. It’s a pattern that’s used in many React projects since
    it ensures that you don’t accidentally try to use the context value in a place
    where it’s not accessible (i.e., in a component that’s not wrapped by `BookmarkContextProvider`
    ).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这不仅仅是一个自定义钩子的例子，而且是一个你应该了解的常见模式。这是一个在许多React项目中使用的模式，因为它确保你不会意外地在一个无法访问上下文值的地方尝试使用上下文值（即在未被`BookmarkContextProvider`包裹的组件中）。
- en: Of course, it’s not a pattern you must use, though. But it’s something you could
    consider using to get an early error if you’re trying to access your context in
    the wrong place. If you’re distributing a library that exposes some context, it’s
    an especially helpful pattern since it warns your library users in case they forget
    to provide the context.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是你必须使用的模式。但这是你可以考虑使用以在错误位置访问上下文时获得早期错误的一种方法。如果你正在分发暴露一些上下文的库，那么这是一个特别有用的模式，因为它会在你的库用户忘记提供上下文时发出警告。
- en: Summary and Key Takeaways
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: You can create custom Hooks to outsource and reuse logic that relies on other
    built-in or custom Hooks.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建自定义钩子来外包和重用依赖于其他内置或自定义钩子的逻辑。
- en: Custom Hooks are regular JavaScript functions with names that start with `use`
    .
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义钩子是名称以`use`开头的常规JavaScript函数。
- en: Custom Hooks can call any other Hooks.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义钩子可以调用任何其他钩子。
- en: Therefore, custom Hooks can, for example, manage state or perform side effects.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，自定义钩子可以管理状态或执行副作用。
- en: All components can use custom Hooks by simply calling them like any other (built-in)
    Hooks.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有组件都可以通过像调用任何其他（内置）钩子一样调用它们来使用自定义钩子。
- en: When multiple components use the same custom Hook, every component receives
    its own “instance” (i.e., its own state value, etc.).
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个组件使用相同的自定义钩子时，每个组件都会接收到自己的“实例”（即，自己的状态值等）。
- en: Inside custom Hooks, you can accept any parameter values and return any values
    of your choice.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义钩子内部，你可以接受任何参数值并返回你选择的任何值。
- en: What’s Next?
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Custom Hooks are a key React feature since they help you to write leaner components
    and reuse (stateful) logic across them. Especially when building more complex
    React apps (consisting of dozens or even hundreds of components), custom Hooks
    can lead to tremendously more manageable code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义钩子是React的一个关键特性，因为它们帮助你编写更精简的组件，并在它们之间重用（有状态的）逻辑。尤其是在构建更复杂的React应用（由数十个甚至数百个组件组成）时，自定义钩子可以使代码更加易于管理。
- en: Combined with components, props, state (via `useState()` or `useReducer()` ),
    side effects, and all the other concepts covered in this and previous chapters,
    you now have a very solid foundation that allows you to build production-ready
    React apps. Therefore, you’re now prepared to dive into more advanced React concepts
    as well as crucial third-party packages that you should know about.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结合组件、属性、状态（通过`useState()`或`useReducer()`）、副作用以及在本章和前几章中涵盖的所有其他概念，你现在拥有了一个非常坚实的基础，这使你能够构建生产就绪的React应用。因此，你现在准备深入更高级的React概念以及你应该了解的关键第三方包。
- en: For example, most React apps don’t just consist of one single page—instead,
    at least on most websites, users should be able to switch between multiple pages.
    For example, an online shop has a list of products, product detail pages, a shopping
    cart page, and many other pages.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数React应用不仅仅由一个单独的页面组成——相反，至少在大多数网站上，用户应该能够在多个页面之间切换。例如，在线商店有一个产品列表、产品详情页面、购物车页面以及许多其他页面。
- en: The next chapter will therefore explore how you can build such multipage apps
    with React and the popular React Router third-party package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一章将探讨如何使用React和流行的React Router第三方包构建这样的多页应用。
- en: Test Your Knowledge!
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/12-custom-hooks/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/12-custom-hooks/exercises/questions-answers.md)
    :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的理解。然后你可以将你的答案与可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/12-custom-hooks/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/12-custom-hooks/exercises/questions-answers.md)找到的示例进行比较。：
- en: What is the definition of a custom Hook?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义钩子的定义是什么？
- en: Which special feature can be used inside a custom Hook?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自定义钩子内部可以使用哪些特殊功能？
- en: What happens when multiple components use the same custom Hook?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当多个组件使用相同的自定义钩子时会发生什么？
- en: How can custom Hooks be made more reusable?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使自定义钩子更具可重用性？
- en: Apply What You Learned
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: Apply your knowledge about custom Hooks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 应用你对自定义钩子的知识。
- en: 'Activity 12.1: Build a Custom Keyboard Input Hook'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第12.1节：构建自定义键盘输入钩子
- en: In this activity, your task is to refactor a provided component such that it’s
    leaner and no longer contains any state or side-effect logic. Instead, you should
    create a custom Hook that contains that logic. This Hook could then potentially
    be used in other areas of the React application as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是重构一个提供的组件，使其更加精简，不再包含任何状态或副作用逻辑。相反，你应该创建一个包含该逻辑的自定义钩子。这个钩子随后可能也可以在React应用程序的其他区域使用。
- en: '**Note**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find the starting code for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1-start)找到这个活动的起始代码。在下载此代码时，你将始终下载整个仓库。请确保导航到包含起始代码的子文件夹（在这个例子中是`activities/practice-1-start`），以使用正确的代码快照。
- en: The provided project also uses many features covered in earlier chapters. Take
    your time to analyze it and understand the provided code. This is a great practice
    and allows you to see many key concepts in action.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目还使用了前面章节中介绍的一些许多功能。花时间分析它并理解提供的代码。这是一个很好的练习，让你看到许多关键概念的实际应用。
- en: 'Once you have downloaded the code and run `npm install` in the project folder
    to install all required dependencies, you can start the development server via
    `npm run dev` . As a result, upon visiting `localhost:5173` , you should see the
    following user interface:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码后，在项目文件夹中运行`npm install`以安装所有必需的依赖项，然后可以通过`npm run dev`启动开发服务器。结果，访问`localhost:5173`时，你应该看到以下用户界面：
- en: '![A close up of a sign  Description automatically generated](img/B31339_12_03.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![一个标志的特写  自动生成的描述](img/B31339_12_03.png)'
- en: 'Figure 12.3: The running starting project'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：正在运行的项目起始状态
- en: 'To complete the activity, the solution steps are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，解决方案步骤如下：
- en: Create a new custom Hook file (e.g., in the `src/hooks` folder) and create a
    Hook function in that file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/hooks`文件夹中创建一个新的自定义钩子文件，并在该文件中创建一个钩子函数。
- en: Move the side effect and state management logic into that new Hook function.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将副作用和状态管理逻辑移动到那个新的钩子函数中。
- en: Make the custom Hook more reusable by accepting and using a parameter that controls
    which keys are allowed.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过接受和使用一个控制允许哪些键的参数来使自定义钩子更具可重用性。
- en: Return the state managed by the custom Hook.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回自定义钩子管理的状态。
- en: Use the custom Hook and its returned value in the `App` component.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App`组件中使用自定义钩子和其返回的值。
- en: 'The user interface should be the same once you have completed the activity,
    but the code of the `App` component should change. After finishing the activity,
    `App` should contain only this code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完成活动后，用户界面应保持不变，但`App`组件的代码应发生变化。完成活动后，`App`应只包含以下代码：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Note**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: All code files used for this activity, and an example solution, can be found
    at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1)
    .
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于此活动的代码文件以及一个示例解决方案，可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/12-custom-hooks/activities/practice-1)找到。
