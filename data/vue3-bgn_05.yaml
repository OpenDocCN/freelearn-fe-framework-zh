- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Leveraging Computed Properties and Methods in Vue.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Vue.js中的计算属性和方法
- en: In the previous chapter, we learned about `<template>` section of our component.
    In this chapter, we are going to move our focus to the `<script>` tag and learn
    how to ensure that the logic of our component is abstracted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了组件的`<template>`部分。在本章中，我们将把重点转移到`<script>`标签上，并学习如何确保组件的逻辑被抽象化。
- en: 'This chapter aims to introduce you to two features: **methods** and **computed**.
    These Vue.js features are essential to ensuring that your component logic remains
    performant and readable. We will go over the components that we created in previous
    chapters and use the preceding techniques to make them easier to read. Throughout
    the chapter, we will also continue to add further details to features that we
    have learned about in previous chapters, such as Refs variables and directives.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在向您介绍两个功能：**方法**和**计算属性**。这些Vue.js功能对于确保组件逻辑保持高效和可读性至关重要。我们将回顾之前章节中创建的组件，并使用前面的技术使它们更容易阅读。在整个章节中，我们还将继续添加关于之前章节中学习到的功能的更多细节，例如Refs变量和指令。
- en: 'This chapter is going to be broken down into the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为以下几部分：
- en: Abstracting functionality using methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法抽象功能
- en: Creating dynamic data using computed properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性创建动态数据
- en: Learning the difference between methods and computed properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习方法和计算属性之间的区别
- en: By the end of this chapter, you will be able to abstract your logic within methods,
    create reactive variables using computed properties, and most importantly, understand
    the difference between them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将逻辑抽象到方法中，使用计算属性创建响应式变量，最重要的是，理解它们之间的区别。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to follow this chapter, you should use a branch called `CH05`. To
    pull this branch, run the following command or use your GUI software of choice
    to support you in this operation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟随本章内容，你应该使用名为`CH05`的分支。要拉取这个分支，请运行以下命令或使用您选择的GUI软件来支持此操作：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: Abstracting functionality using methods
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法抽象功能
- en: Most of the components shown within tutorials and training, such as the ones
    shared in this book so far, always appear to be easy to read and extremely small,
    but this is not always the case. Components written in real applications can easily
    get bloated with logic and become very hard to read. Most of the time, this complexity
    is the result of multiple iterations and feature changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在教程和培训中展示的大多数组件，例如本书中迄今为止分享的组件，看起来总是易于阅读且非常小巧，但这并不总是如此。在实际应用中编写的组件很容易因为逻辑而变得臃肿，难以阅读。大多数情况下，这种复杂性是多次迭代和功能变更的结果。
- en: It is very important to try and keep the components as clean as possible. The
    easiest way to achieve this is by abstracting the logic from the HTML and moving
    it within `<script>`, but what can we use to simplify our components?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量保持组件尽可能干净是非常重要的。实现这一点的最简单方法是将逻辑从HTML中抽象出来，并将其移动到`<script>`标签内，但我们可以使用什么来简化我们的组件呢？
- en: This is where methods come in handy. Methods are JavaScript functions that can
    be used within a Vue.js component instance. Methods can be described as helpers
    that allow you to perform an action within your component.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是方法发挥作用的地方。方法是可以用于Vue.js组件实例中的JavaScript函数。方法可以被描述为助手，允许你在组件内执行操作。
- en: Methods could be used in a wide variety of cases, from fetching data from an
    API to validating user input, and will be our go-to Vue.js feature to simplify
    our component’s logic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以在各种情况下使用，从从API获取数据到验证用户输入，并且将成为我们简化组件逻辑的Vue.js首选功能。
- en: Writing methods while using the Composition API syntax is extremely simple as
    methods are just simple JavaScript functions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Composition API语法编写方法时非常简单，因为方法只是简单的JavaScript函数。
- en: It is time to check out the correct branch from our repository as previously
    mentioned in the *Technical requirements* section and see methods in action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候检查我们在*技术要求*部分中提到的正确分支了，并看看方法在实际中的应用。
- en: 'We are going to look at the HTML of the `SocialPost.vue` component within the
    `components/molecules` folders and try to find some logic that can be extracted.
    What we are looking for is any JavaScript code that we have written within the
    HTML elements of our components that can be turned into a function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看`components/molecules`文件夹中的`SocialPost.vue`组件的HTML，并尝试找到一些可以提取的逻辑。我们要找的是任何我们可以将之转换为函数的、写在我们组件HTML元素中的JavaScript代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you analyze a component, the best candidates for refactoring into methods
    are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分析一个组件时，以下是最适合重构为方法的候选者：
- en: Logic associated with events (click, change)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与事件（点击、更改）相关的逻辑
- en: Logic that requires a parameter (loop index)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要参数（循环索引）的逻辑
- en: Logic that performs a side effect
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行副作用逻辑
- en: 'In our preceding code, we have two instances of click events that have some
    logic associated with them: `@click="selected = !selected"` within the first `<DIV>`
    and `@click="showComments = !showComments"` in the `Show` `Comments` button.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的代码中，有两个与某些逻辑相关联的点击事件实例：第一个`<DIV>`中的`@click="selected = !selected"`和`Show
    Comments`按钮中的`@click="showComments = !showComments"`。
- en: These are great candidates to be refactored as that logic should not live within
    the DOM (Document Object Model) but be moved out within the `<script>` tag of
    our component. Refactoring this code is done in two simple steps. First, we will
    create a method within our `<script>` and then we will replace the logic with
    our newly created method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是很好的重构候选者，因为这种逻辑不应该存在于DOM（文档对象模型）中，而应该移动到组件的`<script>`标签外部。重构此代码分为两个简单的步骤。首先，我们在`<script>`中创建一个方法，然后我们将逻辑替换为我们新创建的方法。
- en: Let’s create two functions within our component logic called `onSelectedClick`
    `and` `onShowCommentClick`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在组件逻辑中创建两个函数，分别命名为`onSelectedClick`和`onShowCommentClick`。
- en: 'Let’s update our code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Prefix your event handler with “on”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序前缀加上“on”
- en: You may have noticed that I have prefixed the event method name with the word
    “on” and suffixed it with the event name (click). This is good practice as it
    makes the code more readable and helps you identify methods that are associated
    with events.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我已将事件方法名称前缀为“on”，后缀为事件名称（click）。这是一个好的实践，因为它使代码更易于阅读，并帮助你识别与事件相关的方法。
- en: Thanks to the Composition API syntax, we can group our functionalities by adding
    the methods right below the Ref's initialization, making our code clean and easy
    to read.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Composition API语法，我们可以通过在Ref的初始化下方添加方法来按组组织我们的功能，使我们的代码更加整洁且易于阅读。
- en: Read and write Ref in the <script> tag
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`<script>`标签中读取和写入Ref
- en: You may have noticed that the code has something different from the logic that
    we used in the HTML. The `selected` and `showComments` Refs have a different syntax
    as they are followed by `.value`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，代码与我们在HTML中使用的逻辑有所不同。`selected`和`showComments`Ref的语法不同，因为它们后面跟着`.value`。
- en: Adding `.value` to a Ref is a requirement when reading and writing Ref within
    the `<script>` tag and does not apply to Reactive variables, which can be accessed
    with normal variables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取和写入`<script>`标签中的Ref时，向Ref添加`.value`是一个要求，这并不适用于可以通过普通变量访问的Reactive变量。
- en: 'Let’s see a visual to help clarify the difference between Ref and Reactive:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个视觉图来帮助阐明Ref和Reactive之间的差异：
- en: '![Figure 5.1: Table displaying the differences when reading and writing Ref
    and Reactive within the <script> and <template> tags](img/B21130_05_01_BW.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：显示在`<script>`和`<template>`标签中读取和写入Ref和Reactive时差异的表格](img/B21130_05_01_BW.jpg)'
- en: 'Figure 5.1: Table displaying the differences when reading and writing Ref and
    Reactive within the <script> and <template> tags'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：显示在`<script>`和`<template>`标签中读取和写入Ref和Reactive时差异的表格
- en: I know that this may be confusing at first, but by the end of the book, you
    will have mastered this difference as we will iterate and use this multiple times
    in the course of our development.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道一开始这可能会让人感到困惑，但到书的结尾，你将掌握这个差异，因为我们在开发过程中会多次迭代并使用这个差异。
- en: Why do Ref need .value
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Ref需要`.value`
- en: Vue reactivity is built on top of the proxy object that listens for “get” and
    “set” events of a variable. This proxy is not available in primitive values such
    as string, number, and Booleans (the type used with ref). To overcome this, these
    primitives are transformed into objects with a single property of `.value`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 的响应性是基于一个代理对象构建的，该对象监听变量的“get”和“set”事件。这个代理在原始值（如字符串、数字和布尔值，即 ref 使用的类型）中不可用。为了克服这一点，这些原始值被转换成具有单个属性
    `.value` 的对象。
- en: Now that our methods have been created, it is time to call them. We are going
    to call these methods from the HTML of our component. To do so, we are going to
    remove the previous logic that was assigned to the `@click` event and replace
    it with the methods that we just created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了方法，是时候调用它们了。我们将从组件的 HTML 中调用这些方法。为此，我们将移除之前分配给 `@click` 事件的逻辑，并用我们刚刚创建的方法替换它。
- en: 'Our main `<div>` will look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要 `<div>` 将看起来像这样：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `Show Comments` button will transform into this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“显示评论”按钮将变成这样：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown in the preceding code, the logic associated with our click events has
    been moved into the `<``script>` tag.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，与我们的点击事件相关的逻辑已经被移动到了 `<script>` 标签中。
- en: The change we made may seem very irrelevant and not worth it, but small readability
    improvements such as this one contribute to a code that is not only easy to read
    but also easy to change.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的改变可能看起来非常无关紧要，不值得这么做，但像这样的小可读性改进有助于使代码不仅易于阅读，而且易于更改。
- en: 'Let’s modify our component one more time and assume that we have been tasked
    to trigger a log using `console.log` every time the `<script>` tag of our component
    and they can easily be expanded:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次修改我们的组件，并假设我们被要求在组件的 `<script>` 标签每次触发时使用 `console.log`，它们可以很容易地扩展：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding `console.log` could not be easier. We We modified the methods methods
    using our existing JavaScript knowledge, as shown in the preceding code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `console.log` 简单得不能再简单了。我们使用现有的 JavaScript 知识修改了方法，如前述代码所示。
- en: Your turn
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 轮到你了
- en: Try to create your own methods. My suggestions would be to try and add `console.log`
    to a message when one of the components mounts (you can use `onMounted`) or continue
    to practice using Ref and Reactive by creating a method that logs how many posts
    and comments the application has.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建你自己的方法。我的建议是尝试在组件挂载时向消息中添加 `console.log`（你可以使用 `onMounted`）或者继续通过创建一个记录应用中帖子数和评论数的方法来练习使用
    Ref 和 Reactive。
- en: You should now be able to refactor your components by using methods and improve
    the readability of your code. Breaking down complex code into smaller functions
    will help us keep our components maintainable. In the next section, we are going
    to look at a similar feature offered by Vue.js called computed properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够通过使用方法来重构你的组件，并提高代码的可读性。将复杂代码分解成更小的函数将帮助我们保持组件的可维护性。在下一节中，我们将查看 Vue.js
    提供的类似功能，称为计算属性。
- en: Creating dynamic data using computed properties
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算属性创建动态数据
- en: In the previous section, we learned how to simplify our component by abstracting
    the logic of our click events. We are going to continue on the subject of “refactoring”
    and introduce a new feature called **computed properties**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何通过抽象点击事件的逻辑来简化我们的组件。我们将继续探讨“重构”的主题，并介绍一个名为**计算属性**的新特性。
- en: When people first learn about computed properties, they usually compare them
    to methods due to their similarities, but in reality, this feature is more closely
    related to props and Ref than methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们第一次了解计算属性时，他们通常会由于它们的相似性而将它们与方法进行比较，但事实上，这个特性与 props 和 Ref 的关系更密切。
- en: 'Computed properties can be described as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性可以这样描述：
- en: Computed properties enable you to create a dynamic property that can be used
    to modify, manipulate, and display your component data (refs, reactive, and properties).
    - [https://blog.logrocket.com/](https://blog.logrocket.com/)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性使你能够创建一个动态属性，可以用来修改、操作和显示你的组件数据（refs、reactive 和属性）。- [https://blog.logrocket.com/](https://blog.logrocket.com/)
- en: So far, we have used Ref, Reactive, and props to pass and display data within
    our application, but there are times when the data received may need to be formatted,
    or when we need to create new data altogether.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 Ref、Reactive 和 props 在我们的应用程序中传递和显示数据，但有时接收到的数据可能需要格式化，或者我们需要完全创建新的数据。
- en: When the need for dynamic properties arises, a computed property is the correct
    feature to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要动态属性时，计算属性是正确的特性来使用。
- en: Before we start to modify the Companion App, let’s introduce a couple of real-life
    examples to help better understand computed properties and their goal.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始修改配套应用程序之前，让我们介绍一些现实生活中的例子，以帮助更好地理解计算属性及其目标。
- en: '*Scenario 1 –* *student list*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*场景 1 –* *学生名单*'
- en: Let’s assume we receive data from an API that returns all students from a school,
    but we just want to filter out female students. We can use a computed property
    to create a filtered array.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们从 API 接收数据，该数据返回学校中的所有学生，但我们只想过滤出女学生。我们可以使用计算属性来创建一个过滤后的数组。
- en: '*Scenario 2 – toggle on* *array length*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*场景 2 –* *切换数组长度*'
- en: In this case, we have been asked to show a button only if five or more entries
    exist in our list. We can use computed properties to check the length of our entries
    and create a new property with a Boolean value.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们被要求只在我们列表中有五个或更多条目时显示按钮。我们可以使用计算属性来检查条目的长度，并创建一个具有布尔值的新的属性。
- en: '*Scenario 3 –* *concatenate values*'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*场景 3 –* *连接值*'
- en: Imagine an application that has a first name and last name as properties, and
    you wish to have access to a variable including the full name. Well, we can use
    a computed property to create this value, which will depend on the first and second
    names.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一个应用程序，它有名字和姓氏作为属性，而你希望访问一个包含全名的变量。嗯，我们可以使用计算属性来创建这个值，它将取决于名字和姓氏。
- en: '*Scenario 4 –* *snippets*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*场景 4 –* *片段*'
- en: Have you ever encountered a blog in which you see just a small part of the blog
    post and can click “show more” to show the full article? Well, to achieve this,
    we can create computer properties that take our blog post and just return a certain
    number of characters.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你是否遇到过这样的博客，你只能看到博客文章的一小部分，然后可以点击“显示更多”来显示完整文章？嗯，为了实现这一点，我们可以创建计算属性，它只返回一定数量的字符。
- en: 'If you re-read the preceding example, you may notice that they all have something
    in common. In fact, all the scenarios that we proposed have the following similarities:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新阅读前面的例子，你可能注意到它们都有共同之处。事实上，我们提出的所有场景都有以下相似之处：
- en: They all create a new piece of data / value that is required within the component
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都创建了一个在组件内部需要的新数据/值
- en: They do not produce any side effect
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会产生任何副作用
- en: They all depend on another piece of data (props, Refs, or Reactive)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都依赖于另一份数据（props、Refs 或 Reactive）
- en: The preceding bullets are present in all of the scenarios that I proposed, not
    because of my choice, but because they are the prerequisites of computed properties.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的要点出现在我提出的所有场景中，这不是因为我选择了它们，而是因为它们是计算属性的前提条件。
- en: A computed property is simply a feature that allows us to use one or more existing
    pieces of data (Refs, Reactive, and props) to create a new value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是一种特性，它允许我们使用一个或多个现有的数据片段（Refs、Reactive 和 props）来创建一个新的值。
- en: It is time to start and look at some examples to be able to learn how and when
    to use this feature.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始看看一些例子，以便了解如何以及何时使用这个特性了。
- en: 'The syntax of a computed property is the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性的语法如下：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When using a computed property, we need to first import it from Vue and then
    assign it to a new constant. The computed property accesses a callback that is
    going to include the logic required to create a new variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算属性时，我们首先需要从 Vue 中导入它，然后将其分配给一个新的常量。计算属性访问一个回调，该回调将包含创建新变量所需的逻辑。
- en: 'Let’s see a simple example and show how a computed property that creates a
    full name would look like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，并展示一个创建全名的计算属性将是什么样子：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have created a new dynamic property called `fullName`.
    This will act just like a normal property and can be used everywhere without our
    components.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `fullName` 的新动态属性。这将像普通属性一样工作，可以在组件的任何地方使用，而无需我们的组件。
- en: 'Just like we said before, the computed property fulfills our requirements,
    which are as follows: it creates new data (`fullName`), depends on another value
    (`name` and `surname`), and returns a value.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前说的那样，计算属性满足了我们的要求，具体如下：它创建新的数据（`fullName`），依赖于另一个值（`name` 和 `surname`），并返回一个值。
- en: Adding computed properties to the companion application
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将计算属性添加到配套应用程序中
- en: It is now time to update our component and see how we can leverage computed
    properties to simplify our code even further.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更新我们的组件，看看我们如何利用计算属性进一步简化我们的代码了。
- en: 'Just like in the previous section, we are going to continue to modify the `SocialPost.vue`
    file. Let’s review the file and try to see what a good candidate would be for
    a computed property:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前一个部分一样，我们将继续修改`SocialPost.vue`文件。让我们回顾一下这个文件，并尝试看看什么是一个好的计算属性候选者：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From the preceding code, we can see that the logic associated with the `v-show`
    directive has been highlighted. This is our best candidate to be turned into a
    computed property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到与`v-show`指令相关的逻辑已经被突出显示。这是我们最好的候选者，可以将其转换为计算属性。
- en: Computed properties need to return a value that depends on another value and
    has no side effect, and the preceding highlighted logic does just that. In fact,
    it returns a boolean of `true` or `false`, it depends on the value of `comments`,
    and it does nothing else that can be defined as a side effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性需要返回一个依赖于另一个值且没有副作用的值，前面突出显示的逻辑正是如此。实际上，它返回一个`true`或`false`的布尔值，这取决于`comments`的值，并且没有其他可以定义为副作用的操作。
- en: 'Just like methods, to be able to convert this logic into a computed property,
    we need to move its logic into the `<script>` tag of our component. Let’s see
    the steps required to achieve this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像方法一样，为了能够将这个逻辑转换为计算属性，我们需要将其逻辑移动到组件的`<script>`标签中。让我们看看实现这一目标所需的步骤：
- en: 'First, we need to import `computed` at the top of our `<``script>` tag:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`<script>`标签的顶部导入`computed`：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we create a function that uses a computed property:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个使用计算属性的函数：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we are going to add our logic as the first argument of the computed method
    as a callback:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的逻辑作为计算方法的第一个参数添加为一个回调：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Last, we replace the existing logic in the HTML with the new computed property:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将用新的计算属性替换HTML中现有的逻辑：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the preceding code, we have now created a new property within our component
    called `hasComments`. This property, just like every other Vue.js variable, is
    responsive and will change as soon as the `comments` array changes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们已经在我们的组件中创建了一个名为`hasComments`的新属性。这个属性，就像每个其他的Vue.js变量一样，是响应式的，并且会在`comments`数组变化时立即改变。
- en: Increasing performance with cached values
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用缓存值提高性能
- en: Creating computed properties not only improves the readability of our component
    but also improves the performance of our application by caching the value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建计算属性不仅提高了我们组件的可读性，还通过缓存值提高了我们应用程序的性能。
- en: What this means is that the actual function included within the computed property
    just gets run once, when the component mounts, but it does not run again when
    the component renders unless the dependent value changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着计算属性中包含的实际函数仅在组件挂载时运行一次，除非依赖的值发生变化，否则在组件渲染时不会再次运行。
- en: This may not bring a massive improvement to our simple example, but it does
    make a big difference in large applications where the computed property could
    actually be a large array with 100s of entries!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不会对我们的简单示例带来巨大的改进，但在大型应用程序中，计算属性实际上可能是一个包含100多个条目的大型数组，这确实会带来很大的差异！
- en: Formatting your data
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化你的数据
- en: Computed properties are not very common among other major frameworks and they
    are seen as a new technique/feature for most Vue.js developers. Due to their unique
    nature, it can be hard at times to grasp and use them in real life. To ensure
    that the topic has been fully understood, we are going to create a couple of extra
    examples that make use of computed properties.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性在其他的框架中并不常见，对于大多数Vue.js开发者来说，它们被视为一种新的技术/特性。由于它们的独特性质，有时在现实生活中掌握和使用它们可能会有点困难。为了确保这个主题被完全理解，我们将创建一些额外的示例，这些示例将使用计算属性。
- en: If you open the file called `TheWelcome.vue` and check the `posts` Reactive
    value, you will notice that there are extra parameters in the object. In fact,
    the value of `likes` and `retweets` has been added to our posts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开名为`TheWelcome.vue`的文件并检查`posts`响应式值，你会注意到对象中有额外的参数。实际上，`likes`和`retweets`的值已经添加到我们的帖子中。
- en: '![Figure 5.2: The posts Reactive property including extra likes and retweets
    entries](img/B21130_05_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：包含额外点赞和转发条目的响应式属性](img/B21130_05_02.jpg)'
- en: 'Figure 5.2: The posts Reactive property including extra likes and retweets
    entries'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：包含额外点赞和转发条目的响应式属性
- en: In this section, we are going to create a new dynamic property that will hold
    the total number of interactions. We are going to do so by adding all the different
    interactions, including comments, likes, and retweets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的动态属性，用于存储交互的总数。我们将通过添加所有不同的交互来实现这一点，包括评论、点赞和转发。
- en: This new computed property will be called `interactions`, and in the case in
    which our post has 2 comments, 2 likes, and 1 retweet, it will return a value
    of `5` (2 + 2 + 1).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的计算属性将被命名为 `interactions`，在我们的帖子有 2 个评论、2 个点赞和 1 个转发的情况下，它将返回一个值为 `5`（2 +
    2 + 1）。
- en: This example should help you understand that the computed property is not just
    a way to prettify your component, but is actually a powerful tool that helps you
    enhance the features of your application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子应该能帮助你理解计算属性不仅仅是一种美化组件的方式，实际上它是一个强大的工具，可以帮助你增强应用程序的功能。
- en: Give it a try
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看
- en: Why don’t you give it a try and attempt to create the computed property by yourself?
    Creating this computed property will require you to put into practice everything
    you learned until now, so why not take a little challenge?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么不试试看，尝试自己创建计算属性？创建这个计算属性需要你将到目前为止所学的一切付诸实践，所以为什么不接受一点挑战呢？
- en: Successfully creating a computed property to display our interaction requires
    a couple of steps. The following diagram shows how the data flows through the
    component, and it will help contextualize the steps we will have to take to fully
    define our computed property.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建一个用于显示我们交互的计算属性需要几个步骤。以下图表显示了数据如何通过组件流动，这将有助于我们理解定义计算属性所需采取的步骤。
- en: '![Figure 5.3: Data flow from the parent component to the computed property](img/B21130_05_03_BW.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：从父组件到计算属性的数据流](img/B21130_05_03_BW.jpg)'
- en: 'Figure 5.3: Data flow from the parent component to the computed property'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：从父组件到计算属性的数据流
- en: Throughout this book, we have already covered each of the preceding entries,
    but this will be the first time that we are using them all together in one single
    exercise. Generating a full data flow like this will be very common in your development
    life, so it is beneficial to get some early practice.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经涵盖了前面的每个条目，但这次将是第一次我们将它们全部在一个单独的练习中使用。在开发生活中生成这样的完整数据流将会非常常见，因此提前进行一些练习是有益的。
- en: 'Let’s go over the preceding data flow one step at a time:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地回顾前面的数据流：
- en: '**Set data in the** **parent component**'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在父组件中设置数据**：'
- en: 'Let’s open TheWelcome.vue and check the parameters available in the posts Reactive
    within the <script> tag:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们打开 TheWelcome.vue 并检查 <script> 标签内 posts Reactive 中可用的参数：
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As shown in the preceding code, the properties of likes and retweets are already
    set for us.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前述代码所示，点赞和转发属性已经为我们设置好了。
- en: '**The new properties are added to the instance of the** **child component**:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**新属性被添加到子组件的实例中**：'
- en: 'As explained in a previous chapter, a component requires properties to be passed
    to it, before it can use them. So, in our case, we need to add the new likes and
    retweets properties to the instances of <SocialPost>:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前一章所述，组件在使用属性之前需要传递属性给它。因此，在我们的情况下，我们需要将新的 likes 和 retweets 属性添加到 <SocialPost>
    的实例中：
- en: '[PRE34]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding example shows how you can add it to the first entry and how you
    can replicate the same for the second one.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的例子展示了如何将其添加到第一个条目，以及如何对第二个条目进行相同的复制。
- en: '**The new properties are read by the child component** **using definedProps:**'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**新属性通过 definedProps 被子组件读取**：'
- en: 'To achieve this step, we need to open the SocialPost.vue file and add the new
    properties of likes and retweets in the list of definedProps. These are both going
    to be Number types:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要实现这一步，我们需要打开 SocialPost.vue 文件，并将新属性 likes 和 retweets 添加到定义的 props 列表中。这两个都将属于
    Number 类型：
- en: '[PRE43]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Create a new computed property that uses the** **new properties**:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的计算属性，使用以下新属性**：'
- en: 'The computed function is going to use the newly created properties and create
    a new dynamic property called interactions:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算函数将使用新创建的属性并创建一个名为 interactions 的新动态属性：
- en: '[PRE52]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Just like every computed property, our preceding function creates a new `interactions`
    value using the `computed()` function and returns a value, which, in our case,
    is the sum of different properties.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像每个计算属性一样，我们前面的函数使用 `computed()` 函数创建一个新的 `interactions` 值，并返回一个值，在我们的例子中，这个值是不同属性的总和。
- en: 'The computed value is added to `<template>`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算值被添加到 `<template>`：
- en: '[PRE56]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we used our knowledge of string interpolation to print the value of interactions
    within the component.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了字符串插值的知识来在组件中打印交互的值。
- en: '**Style** **the HTML**:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样式** **HTML**：'
- en: 'The last step requires us to style the HTML. This can be done by using plain
    CSS within the <style> tag of our component:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步需要我们为 HTML 添加样式。这可以通过在组件的 <style> 标签中使用纯 CSS 来完成：
- en: '[PRE57]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After following the steps defined previously, our new property for `interactions`
    is fully set up and available within our companion application, as shown in the
    following screenshot.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循之前定义的步骤之后，我们的新 `interactions` 属性已经完全设置并可在配套应用程序中使用，如下面的截图所示。
- en: '![Figure 5.4: Companion application screenshot showing interactions](img/B21130_05_04.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：显示交互的配套应用程序截图](img/B21130_05_04.jpg)'
- en: 'Figure 5.4: Companion application screenshot showing interactions'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：显示交互的配套应用程序截图
- en: Computed properties will be a vital part of your Vue.js application and it is
    vital to understand when you should use them and how to use them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性将是您 Vue.js 应用程序的重要组成部分，了解何时以及如何使用它们至关重要。
- en: Your turn
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 轮到你了
- en: Try to create your own computed property. Open up the `TheHeader.vue` file and
    try to replace the current implementation of `Welcome {{ username }}` with a new
    computed property called `welcomeMessage`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建自己的计算属性。打开 `TheHeader.vue` 文件，并尝试用一个新的计算属性 `welcomeMessage` 替换当前 `Welcome
    {{ username }}` 的实现。
- en: 'In this section, we learned how to enhance our components by creating dynamic
    properties using computed properties. We have explained the three factors that
    make a computed property, which are as follows: it produces no side effect, creates
    a new variable, and depends on other component variables. Finally, we went over
    two different coding exercises to better understand the meaning and usage of computed
    properties.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何通过创建计算属性来增强我们的组件，从而创建动态属性。我们解释了使计算属性成为可能的三个因素，如下所述：它不会产生副作用，创建一个新变量，并依赖于其他组件变量。最后，我们回顾了两个不同的编码练习，以更好地理解计算属性的意义和用法。
- en: Learning the difference between methods and computed properties
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习方法和计算属性之间的区别
- en: During my career, I have seen many people misusing methods and computed properties.
    In this section, we are going to clarify the difference between the two features
    and provide you with a guide that you can revisit during the course of your early
    career.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我见过许多人误用方法和计算属性。在本节中，我们将阐明这两个功能之间的区别，并提供一个您可以在早期职业生涯中回顾的指南。
- en: Technical differences
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术差异
- en: 'It may be a good starting point to re-iterate what we discussed in the previous
    two sections and see side by side what the technical differences are between these
    two Vue.js features:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重新回顾前两节中讨论的内容，并对比这两个 Vue.js 功能之间的技术差异可能是一个好的起点：
- en: '![Figure 5.5: A table showing the technical differences between methods and
    computed properties](img/B21130_05_05_BW.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：展示方法和计算属性之间技术差异的表格](img/B21130_05_05_BW.jpg)'
- en: 'Figure 5.5: A table showing the technical differences between methods and computed
    properties'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：展示方法和技术差异以及计算属性的表格
- en: 'Let’s focus on some of the main differences displayed in *Figure 5**.5*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一下 *图 5.5* 中显示的一些主要差异：
- en: '**Time of initialization**: Methods can be initialized on demand by the user,
    while computed properties are triggered during the component creation life cycle.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化时间**：方法可以在用户需求时初始化，而计算属性则在组件创建生命周期中触发。'
- en: '**Parameters and dependencies**: While methods can accept parameters, computed
    properties can just use other component props and data that are called dependencies.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数和依赖关系**：虽然方法可以接受参数，但计算属性只能使用其他组件属性和数据，这些数据被称为依赖项。'
- en: '**Evaluation**: Methods are evaluated every time they are called, making them
    very expensive, while computed properties are cached and just re-evaluated if
    any of their dependencies are updated.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估**：每次调用方法时都会进行评估，这使得它们非常昂贵，而计算属性则被缓存，只有当其依赖项更新时才会重新评估。'
- en: '**Side effect**: Side effects occur when a method or a function modifies a
    value or triggers an action outside of its local scope. So, for example, triggering
    an API call is a side effect, or changing a variable that is not returned by the
    method is a side effect.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副作用**：当方法或函数在其局部作用域之外修改值或触发动作时，就会发生副作用。例如，触发 API 调用是一个副作用，或者改变方法未返回的变量也是一个副作用。'
- en: The goal of a computed property is to create a new variable and it should never
    include any side effect, while the main scope of methods is to produce side effects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性的目标是创建一个新的变量，它不应该包含任何副作用，而方法的主要作用域是产生副作用。
- en: 'If someone were asked to define the difference between computed properties
    and methods in a single sentence, I would say the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人被要求用一句话来定义计算属性和方法之间的区别，我会说以下内容：
- en: Methods are helper functions that allow you to complete an action, while computed
    properties allow you to create a new component property.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是辅助函数，允许你完成一个动作，而计算属性允许你创建一个新的组件属性。
- en: How to spot them in your component
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在组件中找到它们
- en: In the previous section, we spoke about the technical differences between methods
    and computed properties, while in this section we will see where we would find
    these helpers within a component.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了方法和计算属性之间的技术差异，而在本节中，我们将看到这些辅助函数在组件中的位置。
- en: Knowing where computed properties and methods are used within the component
    structure will help you make the correct choice. To better see whether we can
    make the correct choice, we are going to use a dummy component. This component
    has a few placeholders delimited by `???`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 了解计算属性和方法在组件结构中的使用位置将帮助你做出正确的选择。为了更好地看到我们是否可以做出正确的选择，我们将使用一个虚拟组件。这个组件有几个由`???`分隔的占位符。
- en: 'Spend a couple of minutes to try and understand whether this is going to be
    methods or computed properties and why you have made this choice. When you are
    ready, you can read my explanation and see whether it matches your choices:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间尝试理解这将是什么方法或计算属性，以及你为什么做出这个选择。当你准备好了，你可以阅读我的解释，看看它是否与你的选择相符：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first placeholder is `fetchBlog`. This is going to be a method. The decision
    is based on the fact that `fetchBlog` is not only going to trigger a side effect,
    contacting an external API, but it is also called in the `onMounted` life cycle.
    As we previously defined, only methods can be triggered on demand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个占位符是`fetchBlog`。这将是一个方法。这个决定基于`fetchBlog`不仅将触发副作用，联系外部API，而且它还在`onMounted`生命周期中被调用。正如我们之前定义的，只有方法可以被按需触发。
- en: The second one is `onShowAll`. This is going to run an action, something that
    will be triggered when the user clicks a button. Again, in this instance, we are
    going to define this as a method because it is triggered by an event, will include
    a side effect, and will accept parameters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`onShowAll`。这将执行一个动作，当用户点击按钮时将被触发。同样，在这个例子中，我们将将其定义为方法，因为它由事件触发，将包含副作用，并接受参数。
- en: Lastly, we have `snippets`. This variable is used in the template just like
    a variable. As we should know by now, creating dynamic variables is the perfect
    match for a computed property. In this instance, `snippets` is going to be a computed
    property that will depend on the blog content.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有“片段”。这个变量在模板中的使用就像一个变量一样。正如我们现在所知道的，创建动态变量是计算属性的完美匹配。在这个例子中，“片段”将是一个依赖于博客内容的计算属性。
- en: 'Let’s see what the `updates` script may look like:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`updates`脚本可能的样子：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With all the examples we have covered so far, you should have obtained a good
    understanding of these two different features.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了所有示例，你应该对这些两个不同的特性有了很好的理解。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced methods and used them to clean up the components
    of our Companion App. We learned the difference between Refs and Reactive and
    learned how to use them within the `<script>` section of components, and then
    we moved forward and learned how to create dynamic properties using computed properties.
    To complete the chapter, we fortified our knowledge of these two topics by going
    over a few more examples.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了方法，并使用它们来清理我们的伴侣应用组件。我们学习了Refs和Reactive之间的区别，并学习了如何在组件的`<script>`部分中使用它们，然后我们继续前进，学习了如何使用计算属性创建动态属性。为了完成这一章，我们通过一些更多示例来巩固这两个主题的知识。
- en: In the next chapter, we are going to learn how to create and manage events using
    Vue event handling. Up until now, we have focused on the individual components,
    but with the introduction of events and events handling, we will be able to define
    two-way communication between components. Event propagation is an essential skill
    to have to be able to develop scalable and clear component-based applications.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Vue 事件处理来创建和管理事件。到目前为止，我们一直专注于单个组件，但随着事件和事件处理的引入，我们将能够定义组件之间的双向通信。事件传播是开发可扩展且清晰的基于组件的应用程序所必需的一项基本技能。
