<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-97"><em class="italic"><a id="_idTextAnchor096"/>Chapter 9</em>: Testing Next.js</h1>
			<p>Testing is an essential part of the whole development workflow. It gives you more assurance that you're not introducing bugs into your code, as well as that you're not breaking any existing features.</p>
			<p>Testing Next.js specifically is not different from testing any other React app or Express.js, Fastify, or Koa application. In fact, we can divide the testing phases into three different stages:</p>
			<ul>
				<li>Unit testing</li>
				<li>End-to-end testing</li>
				<li>Integration testing</li>
			</ul>
			<p>We will look at those concepts in detail in this chapter's sections.</p>
			<p>If you already have previous experience in writing a React application, you're likely to re-utilize your knowledge for testing a Next.js-based website.</p>
			<p>In this chapter, we will look in detail at the following:</p>
			<ul>
				<li>An introduction to testing and testing frameworks</li>
				<li>Setting up a testing environment</li>
				<li>How to use some of the most popular test runners, frameworks, and utility libraries</li>
			</ul>
			<p>By the end of this chapter, you'll be able to set up a testing environment using a test runner and a testing library and run tests before sending the code to production.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine.</p>
			<p>If you prefer, you can use an online IDE such as https://repl.it or https://codesandbox.io; they both support Next.js, and you don't need to install any dependency on your computer. As with the other chapters, you can find the code base for this chapter on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Next.js">https://github.com/PacktPublishing/Real-World-Next.js</a>.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>An introduction to testing</h1>
			<p>As we've seen during <a id="_idIndexMarker490"/>this chapter's introduction, testing is an essential part of any development workflow and can be divided into three separate testing phases:</p>
			<ul>
				<li><em class="italic">Unit testing</em>: These <a id="_idIndexMarker491"/>tests aim to make sure that every single function in your code is working. They do that by testing the codebase's functions individually against correct and incorrect inputs, asserting their results and possible errors to ensure they're working expected.</li>
				<li><em class="italic">End-to-end testing</em>: This testing strategy reproduces a typical user interaction with your application, ensuring that the app responds with a specific output once a given action occurs, just like we would do by testing the website manually on a web browser. For instance, if we build a form, we want to automatically guarantee that it is working correctly, validating the input, and performing a specific action on the form's submission. Also, we want to test that the user interface is rendering as we intended by using particular CSS classes, mounting certain HTML elements, and so on.</li>
				<li><em class="italic">Integration testing</em>: In this case, we want to ensure that separate parts of our application, such as functions and modules, are cohesively working together. For instance, we want to assert that composing two functions results in a certain output, and so on. Unlike unit tests, where we test our functions individually, with integration tests, we ensure that a whole group of aggregated functions and modules are producing a correct output when given a different set of inputs.</li>
			</ul>
			<p>There might be other testing phases and philosophies, but in the following sections, we will be concentrating on the ones we've mentioned here, as they are the essential parts of the testing workflow, and I strongly encourage you to adopt all of those phases when shipping your code to production.</p>
			<p>As said in the introduction for this chapter, testing Next.js is not different than testing a React application or an <strong class="bold">Express.js/Fastify/Koa</strong> web server. We need to choose the proper test runner and libraries and ensure that our code is working as expected.</p>
			<p>When talking about test runners, we refer to tools responsible for executing every test found in the code base, collecting the coverage, and displaying the test results in the console. If the test runner process fails (and exits with a non-zero exit code), the tests are considered to have failed.</p>
			<p>The Node.js and JavaScript ecosystems offer a large set of choices for test runners, but starting from the next section, we will be concentrating on the two most popular alternatives out<a id="_idIndexMarker492"/> there: <strong class="bold">Jest</strong> (for unit and integration tests) and <strong class="bold">Cypress</strong> (for <strong class="bold">e2e</strong>, short for <strong class="bold">end-to-end</strong>, tests).</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Running unit and integration tests</h1>
			<p>In this section, we<a id="_idIndexMarker493"/> will write<a id="_idIndexMarker494"/> some integration and unit tests by using one of the most popular test runners in the JavaScript ecosystem: Jest.</p>
			<p>Before installing all the dependencies we need, clone the following repository, which already contains a small web application that we'll be using as an example for writing our te<a href="https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/boilerplate">sts: https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/boiler</a>plate.</p>
			<p>It's a simple website with the following features:</p>
			<ul>
				<li>Two pages: a home page containing all the articles in our blog and a single article page.</li>
				<li>The article page URL implements the following format: <strong class="source-inline">&lt;article_slug&gt;-&lt;article-id&gt;</strong>.</li>
				<li>There are some utility functions that create the page's URL, retrieve the article ID from the article URL, and so on.</li>
				<li>Two REST APIs: one for getting all the articles and one for getting a specific article given an ID.</li>
			</ul>
			<p>Now let's enter the project we've cloned and install the following dependency:</p>
			<p class="source-code">yarn add -D jest</p>
			<p>Jest is the only dependency that we'll need for our tests, as it acts both as a testing framework and as a test runner. It provides an extensive set of features that will make our development (and testing) experience pleasant.</p>
			<p>Given that we're writing our functions and components using ESNext" features, we want to tell Jest to use the default Next.js babel preset for transpiling those modules correctly. We can do that by creating a <strong class="source-inline">.babelrc</strong> file in our project's root and adding the following content:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "presets": ["next/babel"]</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">next/babel</strong> preset <a id="_idIndexMarker495"/>comes pre-installed with Next.js, so we don't need to install<a id="_idIndexMarker496"/> anything, and we're ready to go.</p>
			<p>We can start using it without any other configuration, as it comes pre-configured for running every file ending with <strong class="source-inline">.test.js</strong> or <strong class="source-inline">.spec.js</strong>.</p>
			<p>Still, there are different approaches for how to write and where to place those files. For example, some people prefer to have a test file close to the source file, and others prefer to have all the tests inside a <strong class="source-inline">tests/</strong> directory. Of course, neither of those approaches is wrong: it's up to your taste.</p>
			<p class="callout-heading">Pay Attention When Writing Next.js Pages' Tests</p>
			<p class="callout">Next.js serves every <strong class="source-inline">.js</strong>, <strong class="source-inline">.jsx</strong>, <strong class="source-inline">.ts</strong>, and <strong class="source-inline">.tsx</strong> file placed inside of the <strong class="source-inline">pages/</strong> directory as an application page. Therefore, <em class="italic">you should never place any test file inside that directory</em>, or Next.js will try to render it as an application page. We will see how to test Next.js pages in the next section while writing end-to-end tests.</p>
			<p>Let's write our first test, starting from the easiest part of our code base: the utility functions. We can create a new file, <strong class="source-inline">utils/tests/index.test.js</strong>, and start by importing all the functions that we can find in our <strong class="source-inline">utils/index.js</strong> file:</p>
			<p class="source-code">import { </p>
			<p class="source-code">  trimTextToLength, </p>
			<p class="source-code">  slugify, </p>
			<p class="source-code">  composeArticleSlug, </p>
			<p class="source-code">  extractArticleIdFromSlug</p>
			<p class="source-code">} from '../index';</p>
			<p>We can now write the first test for the <strong class="source-inline">trimTextToLength</strong> function. This function takes two arguments: a string and the length under which we will be cutting it, adding an ellipsis at its end. We<a id="_idIndexMarker497"/> use this function to show a sneak peek of the article<a id="_idIndexMarker498"/> body to tempt the reader to read the whole article.</p>
			<p>For instance, pretend we have the following string:</p>
			<p class="source-code">const str = "The quick brown fox jumps over the lazy dog";</p>
			<p>If we apply <strong class="source-inline">trimTextToLength</strong> to it, we should see the following output:</p>
			<p class="source-code">const str = "The quick brown fox jumps over the lazy dog";</p>
			<p class="source-code">const cut = <strong class="bold">trimTextToLength(str, 5);</strong></p>
			<p class="source-code">cut === "The q..." // true</p>
			<p>We can translate the preceding function description into code as follows:</p>
			<p class="source-code">describe("trimTextToLength", () =&gt; {</p>
			<p class="source-code">test('Should cut a string that exceeds 10 characters', () =&gt; {</p>
			<p class="source-code">    const initialString = 'This is a 34 character long </p>
			<p class="source-code">     string';</p>
			<p class="source-code">    const cutResult = trimTextToLength(initialString, 10);</p>
			<p class="source-code">    expect(cutResult).toEqual('This is a ...');</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>As you can see, we're using some of Jest's built-in functions, such as <strong class="source-inline">describe</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">expect</strong>. They all have their specific function, and we can summarize them as follows:</p>
			<ul>
				<li><strong class="source-inline">describe</strong>: Creates a group of related tests. For example, we should include tests regarding the same functions or modules inside of that function.</li>
				<li><strong class="source-inline">test</strong>: Declares a test and runs it.</li>
				<li><strong class="source-inline">expect</strong>: This is the function that we use to compare our function's outputs against a fixed number of results.</li>
			</ul>
			<p>As we've seen, we <a id="_idIndexMarker499"/>can <a id="_idIndexMarker500"/>add several tests into the <strong class="source-inline">describe</strong> group so that we can test our function against multiple values:</p>
			<p class="source-code">describe("trimTextToLength cuts a string when it's too long, () =&gt; {</p>
			<p class="source-code">  test('Should cut a string that exceeds 10 characters', () </p>
			<p class="source-code">    =&gt; {</p>
			<p class="source-code">    const initialString = 'This is a 35 characters long </p>
			<p class="source-code">     string';</p>
			<p class="source-code">    const cutResult = trimTextToLength(initialString, 10);</p>
			<p class="source-code">    expect(cutResult).toEqual('This is a ...');</p>
			<p class="source-code">  });</p>
			<p class="source-code"><strong class="bold">  test("Should not cut a string if it's shorter than 10 </strong></p>
			<p class="source-code"><strong class="bold">  characters",</strong></p>
			<p class="source-code"><strong class="bold">    () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">        const initialString = '7 chars';</strong></p>
			<p class="source-code"><strong class="bold">        const cutResult = trimTextToLength(initialString, </strong></p>
			<p class="source-code"><strong class="bold">         10);</strong></p>
			<p class="source-code"><strong class="bold">        expect(cutResult).toEqual('7 chars');</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">  );</strong></p>
			<p class="source-code">});</p>
			<p>Moving on <a id="_idIndexMarker501"/>to <a id="_idIndexMarker502"/>the <strong class="source-inline">slugify</strong> function, let's try to write its own tests:</p>
			<p class="source-code">describe('slugify makes a string URL-safe', () =&gt; {</p>
			<p class="source-code">  test('Should convert a string to URL-safe format', () =&gt; </p>
			<p class="source-code">   {</p>
			<p class="source-code">    const initialString = 'This is a string to slugify';</p>
			<p class="source-code">    const slugifiedString = slugify(initialString);</p>
			<p class="source-code">    expect(slugifiedString).</p>
			<p class="source-code">      toEqual('this-is-a-string-to-slugify');</p>
			<p class="source-code">   });</p>
			<p class="source-code">  test('Should slugify a string with special </p>
			<p class="source-code">    characters', () =&gt; {</p>
			<p class="source-code">    const initialString = 'This is a string to </p>
			<p class="source-code">    slugify!@#$%^&amp;*()+';</p>
			<p class="source-code">    const slugifiedString = slugify(initialString);</p>
			<p class="source-code">    expect(slugifiedString).</p>
			<p class="source-code">      toEqual('this-is-a-string-to-slugify');</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>Now, try to implement the tests for the remaining functions on your own. If you have any doubt, you can find the complete test implemen<a href="https://github.com/PacktPublishing/Real-World-Next.js/blob/main/09-testing-nextjs/unit-integration-tests/utils/tests/index.test.js">tation here: https://github.com/PacktPublishing/Real-World-Next.js/blob/main/09-testing-nextjs/unit-integration-tests/utils/tests/</a>index.test.js.</p>
			<p>Once we've written all the remaining tests, we're finally ready to run our test suite. To make it easier <a id="_idIndexMarker503"/>and <a id="_idIndexMarker504"/>standard, we can create a new script inside of our <strong class="source-inline">package.json</strong> file:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "dev": "next dev",</p>
			<p class="source-code">  "build": "next build",</p>
			<p class="source-code">  "start": "next start",</p>
			<p class="source-code"><strong class="bold">  "test": "jest"</strong></p>
			<p class="source-code">},</p>
			<p>And that's all we need! We can now type <strong class="source-inline">yarn test</strong> in the console and admire the following output:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_9.01_B16985.jpg" alt="Figure 9.1 – Unit test output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Unit test output</p>
			<p>We can now move on<a id="_idIndexMarker505"/> to<a id="_idIndexMarker506"/> writing a more complex test. If you open the <strong class="source-inline">components/ArticleCard/index.js</strong> file, you will see a simple React component that creates a link to a Next.js page.</p>
			<p>In that case, we want to test that our <strong class="source-inline">composeArticleSlug</strong> and <strong class="source-inline">trimTextToLength</strong> functions (used in that component) integrate correctly by producing the expected output. We also want to test that the displayed text will match a fixed result when given an article as input.</p>
			<p>Sadly, Jest alone is not enough for testing React components. We will need to mount and render them to test their output, and specific libraries do that incredibly well.</p>
			<p>The most popular options out there are <strong class="bold">react-testing-library</strong> and <strong class="bold">Enzyme</strong>. In this example, we will be using <strong class="source-inline">react-testing-library</strong>, but feel free to experiment with Enzyme and see which approach you prefer.</p>
			<p>Let's install the <strong class="source-inline">react-testing-library</strong> package by running this:</p>
			<p class="source-code">yarn add @testing-library/react</p>
			<p>Now let's move on to create a new file named <strong class="source-inline">components/ArticleCard/tests/index.test.js</strong>.</p>
			<p>Before moving on to the test implementation, let's consider something. We now need to test our <strong class="source-inline">ArticleCard</strong> component against a REST API, but we won't be running the server during the test's execution. Right now, we're not testing that our API is responding with the correct JSON containing the article, we're just testing that given an article as input, the component will produce a fixed output.</p>
			<p>That said, we can easily create a mock containing all the information we expect an article to contain, and give it as an input to our component.</p>
			<p>Let's create a new file, <strong class="source-inline">components/ArticleCard/tests/mock.js</strong>, with the following content (or <a id="_idIndexMarker507"/>just<a id="_idIndexMarker508"/> copy it from this book's GitHub repository under <strong class="source-inline">09-testing-nextjs/unit-integration-tests/components/ArticleCard/tests/mock.js</strong>):</p>
			<p class="source-code">export const article = {</p>
			<p class="source-code">  id: 'u12w3o0d',</p>
			<p class="source-code">  title: 'Healthy summer melon-carrot soup',</p>
			<p class="source-code">  body: 'Lorem ipsum dolor sit amet, consectetur adipiscing </p>
			<p class="source-code">   elit. Morbi iaculis, felis quis sagittis molestie, mi </p>
			<p class="source-code">   sem lobortis dui, a sollicitudin nibh erat id ex.',</p>
			<p class="source-code">  author: {</p>
			<p class="source-code">    id: '93ksj19s',</p>
			<p class="source-code">    name: 'John Doe',</p>
			<p class="source-code">  },</p>
			<p class="source-code">  image: {</p>
			<p class="source-code">    url: 'https://images.unsplash.com/photo-1629032355262-</p>
			<p class="source-code">     d751086c475d',</p>
			<p class="source-code">    author: 'Karolin Baitinger',</p>
			<p class="source-code">  },</p>
			<p class="source-code">};</p>
			<p>If you try to run the Next.js server, you will see that the APIs inside of <strong class="source-inline">pages/api/</strong> will return either an array of articles or a single article in the same format we used for the mock.</p>
			<p>We're finally ready to write our tests. Open the <strong class="source-inline">components/ArticleCard/tests/index.test.js</strong> file and start by importing the react-testing-library <a id="_idIndexMarker509"/>functions, the components, mocks, and utilities we want <a id="_idIndexMarker510"/>to test:</p>
			<p class="source-code">import { render, screen } from '@testing-library/react';</p>
			<p class="source-code">import ArticleCard from '../index';</p>
			<p class="source-code">import { trimTextToLength } from '../../../utils';</p>
			<p class="source-code">import { article } from '../tests/mock';</p>
			<p>Now let's write our first test case. If we open the <strong class="source-inline">ArticleCard</strong> component, we will see that there's a Next.js Link component wrapping the entire card. This link's <strong class="source-inline">href</strong> should be in the format <strong class="source-inline">/articles/&lt;article-title-slugified&gt;-id</strong>.</p>
			<p>As a first test case, we will test that there's one link, where the <strong class="source-inline">href</strong> attribute is equal to /<strong class="source-inline">articles/healthy-summer-meloncarrot-soup-u12w3o0d</strong> (which is the title we can see in our mock, plus the article ID):</p>
			<p class="source-code"> describe('ArticleCard', () =&gt; {</p>
			<p class="source-code">   test('Generated link should be in the correct format', () </p>
			<p class="source-code">     =&gt; {</p>
			<p class="source-code"><strong class="bold">        const component = render(&lt;ArticleCard {...article} /&gt;);</strong></p>
			<p class="source-code"><strong class="bold">        const link = component.getByRole('</strong></p>
			<p class="source-code"><strong class="bold">        link').getAttribute('href');</strong></p>
			<p class="source-code"><strong class="bold">        expect(link).toBe(</strong></p>
			<p class="source-code"><strong class="bold">        '/articles/healthy-summer-meloncarrot-soup-u12w3o0d'</strong></p>
			<p class="source-code"><strong class="bold">     );</strong></p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>We're using the react-testing-library <strong class="source-inline">render</strong> method to mount and render the component, then we get the link and extract its <strong class="source-inline">href</strong> attribute. We eventually test this attribute value against a fixed string, which is the expected value.</p>
			<p>Still, there is a problem with our test. If we try to run it, we will see the following error appearing in the console:</p>
			<p class="source-code">The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.</p>
			<p class="source-code">Consider using the "jsdom" test environment.</p>
			<p>That's because react-testing-library<a id="_idIndexMarker511"/> relies on the browser's document global<a id="_idIndexMarker512"/> variable, which is unavailable in Node.js.</p>
			<p>We can quickly solve this problem by changing the Jest environment for this test file to JSDOM, a library that emulates a large part of the browser's features for testing purposes. We don't need to install anything; we can just add the following comment at the top of our testing file, right before the <strong class="source-inline">import</strong> statements, and Jest will do the rest:</p>
			<p class="source-code">/**</p>
			<p class="source-code"> * @jest-environment jsdom</p>
			<p class="source-code"> */</p>
			<p>If we now run <strong class="source-inline">yarn test</strong> in the terminal, the tests will succeed as expected.</p>
			<p>Inside the <strong class="source-inline">ArticleCard</strong> component, we show a brief extract of the article body to tempt the reader to read the entire piece. It uses the <strong class="source-inline">trimTextToLength</strong> function to trim the article body to a maximum length of 100 characters, so we expect to see those first 100 chapters inside the rendered component.</p>
			<p>We can proceed with writing a test as follows:</p>
			<p class="source-code">describe('ArticleCard', () =&gt; {</p>
			<p class="source-code">  test('Generated link should be in the correct format', () </p>
			<p class="source-code">    =&gt; {</p>
			<p class="source-code">       const component = render(&lt;ArticleCard {...article} /&gt;);</p>
			<p class="source-code">       const link = component.getByRole('link')</p>
			<p class="source-code">         .getAttribute('href');</p>
			<p class="source-code">       expect(link).toBe(</p>
			<p class="source-code">       '/articles/healthy-summer-meloncarrot-soup-u12w3o0d'</p>
			<p class="source-code">    );</p>
			<p class="source-code">  });</p>
			<p class="source-code"><strong class="bold">  test('Generated summary should not exceed 100 </strong></p>
			<p class="source-code"><strong class="bold">   characters',</strong></p>
			<p class="source-code"><strong class="bold">    async () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">      render(&lt;ArticleCard {...article} /&gt;);</strong></p>
			<p class="source-code"><strong class="bold">      const summary = screen.getByText(</strong></p>
			<p class="source-code"><strong class="bold">        trimTextToLength(article.body, 100)</strong></p>
			<p class="source-code"><strong class="bold">      );</strong></p>
			<p class="source-code"><strong class="bold">    expect(summary).toBeDefined();</strong></p>
			<p class="source-code"><strong class="bold">  });</strong></p>
			<p class="source-code">});</p>
			<p>In this case, we render <a id="_idIndexMarker513"/>the <a id="_idIndexMarker514"/>whole component, then generate the article summary and expect it to exist inside our document.</p>
			<p>That was an elementary example of how we can test our code base by using Jest and react-testing-library. When writing a real-world application, we also want to test our components against incorrect data to see if they can handle any errors correctly, either by throwing an error, showing a message on the screen, and so on.</p>
			<p>Testing is not an easy topic, but it must be taken seriously as it can help us avoid shipping broken code or introducing regressions (for example, breaking a component that was previously working fine) into the existing code base. It is such a complex matter that there's also an entire book on how to test React components using react-testing-library: <em class="italic">Simplify Testing with React Testing Library </em>by Scottie Crump, published by Packt.</p>
			<p>If you're interested in learning more and digging deep into React testing, I strongly suggest reading this book.</p>
			<p>That said, there is still one piece missing in our tests. We're not testing the full-page renders, whether the APIs send back correct data, and whether we can navigate correctly <a id="_idIndexMarker515"/>between <a id="_idIndexMarker516"/>pages. But that's what end-to-end tests are all about, and we will discuss this in the next section.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>End-to-end testing with Cypress</h1>
			<p>Cypress is a <a id="_idIndexMarker517"/>powerful testing tool that can test anything that runs on<a id="_idIndexMarker518"/> a web browser.</p>
			<p>It enables you to write and run unit, integration, and end-to-end tests efficiently by running them on Firefox and Chromium-based browsers (for example, Google Chrome).</p>
			<p>So far, we have written tests for understanding whether our functions and components are working as expected. Now it's time to test whether the entire application is working correctly.</p>
			<p>To get started with Cypress, we just need to install it as a <strong class="source-inline">dev</strong> dependency in our project. We will be using the same project as the latest section, but if you want to get started from a clean project, you can clone the following repository<a href="https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-nextjs/unit-integration-tests"> and get started from there: https://github.com/PacktPublishing/Real-World-Next.js/tree/main/09-testing-</a>nextjs/unit-integration-tests.</p>
			<p>Let's install Cypress by typing the following command into the terminal:</p>
			<p class="source-code">yarn add -D cypress</p>
			<p>Once Cypress is installed, we can edit our main <strong class="source-inline">package.json</strong> file by adding the following script:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "dev": "next dev",</p>
			<p class="source-code">  "build": "next build",</p>
			<p class="source-code">  "start": "next start",</p>
			<p class="source-code">  "test": "jest",</p>
			<p class="source-code"><strong class="bold">  "cypress": "cypress run",</strong></p>
			<p class="source-code">},</p>
			<p>We now need to create a Cypress configuration file. Let's write a <strong class="source-inline">cypress.json</strong> file in the project root containing the follo<a href="http://localhost:3000">wing content:</a></p>
			<p class="source-code"><a href="http://localhost:3000">{</a></p>
			<p class="source-code"><a href="http://localhost:3000">  "ba</a>seUrl": http://localhost:3000</p>
			<p class="source-code">}</p>
			<p>Here, we're telling <a id="_idIndexMarker519"/>Cypress<a id="_idIndexMarker520"/> where to look when running tests; in our case, <strong class="source-inline">localhost:3000</strong>. Now that we're all set, let's move on to writing our first tests!</p>
			<p>By convention, we will be putting our end-to-end tests inside a folder called <strong class="source-inline">cypress/</strong>, placed at the root level of the repository.</p>
			<p>We will start with an easy test to verify that our REST APIs are working correctly.</p>
			<p>If you open the <strong class="source-inline">pages/api/</strong> folder, you will see two different APIs:</p>
			<ul>
				<li><strong class="source-inline">articles.js</strong>, which returns a list of articles:<p class="source-code">import data from '../../data/articles';</p><p class="source-code">export default (req, res) =&gt; {</p><p class="source-code">  res.status(200).json(data);</p><p class="source-code">};</p></li>
				<li><strong class="source-inline">article/index.js</strong>, which takes an article ID as a query string parameter and returns the single article with that ID:<p class="source-code">import data from '../../../data/articles';</p><p class="source-code">export default (req, res) =&gt; {</p><p class="source-code">  const id = req.query.id;</p><p class="source-code">  const requestedArticle = data.find(</p><p class="source-code">    (article) =&gt; article.id === id</p><p class="source-code">  );</p><p class="source-code">  requestedArticle</p><p class="source-code">    ? res.status(200).json(requestedArticle)</p><p class="source-code">    : res.status(404).json({ error: 'Not found' });</p><p class="source-code">};</p></li>
			</ul>
			<p>Let's create our<a id="_idIndexMarker521"/> first<a id="_idIndexMarker522"/> Cypress test file, named <strong class="source-inline">cypress/integration/api.spec.js</strong>, and add the following content:</p>
			<p class="source-code">describe('articles APIs', () =&gt; {</p>
			<p class="source-code">  test('should correctly set application/json header', () </p>
			<p class="source-code">   =&gt; {</p>
			<p class="source-code">    cy.request('http://localhost:3000/api/articles')</p>
			<p class="source-code">      .its('headers')</p>
			<p class="source-code">      .its('content-type')</p>
			<p class="source-code">      .should('include', 'application/json');</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>The APIs are slightly different from the Jest ones, but we can still see that they share the same philosophy. We use them to describe the response coming from the server, testing it against a fixed value.</p>
			<p>In the preceding example, we're just testing that the HTTP headers include the <strong class="source-inline">content-type=application/json header</strong>.</p>
			<p>We can proceed by testing the status code, which should be equal to <strong class="source-inline">200</strong>:</p>
			<p class="source-code">describe('articles APIs', () =&gt; {</p>
			<p class="source-code">  test('should correctly set application/json header', () </p>
			<p class="source-code">   =&gt; {</p>
			<p class="source-code">    cy.request('http://localhost:3000/api/articles')</p>
			<p class="source-code">      .its('headers')</p>
			<p class="source-code">      .its('content-type')</p>
			<p class="source-code">      .should('include', 'application/json');</p>
			<p class="source-code">  });</p>
			<p class="source-code"><strong class="bold">  test('should correctly return a 200 status code', () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    cy.request('http://localhost:3000/api/articles')</strong></p>
			<p class="source-code"><strong class="bold">      .its('status')</strong></p>
			<p class="source-code"><strong class="bold">      .should('be.equal', 200);</strong></p>
			<p class="source-code"><strong class="bold">  });</strong></p>
			<p class="source-code">});</p>
			<p>Moving on to a more <a id="_idIndexMarker523"/>complex<a id="_idIndexMarker524"/> test case, we can test the API output to be an array of objects, where each object must contain a minimum set of properties. The test implementation would look like this:</p>
			<p class="source-code">test('should correctly return a list of articles', (<strong class="bold">done</strong>) =&gt; {</p>
			<p class="source-code">  cy.request('http://localhost:3000/api/articles')</p>
			<p class="source-code">    .its('body')</p>
			<p class="source-code">    .each((article) =&gt; {</p>
			<p class="source-code">      expect(article)</p>
			<p class="source-code">        .to.have.keys('id', 'title', 'body', 'author', </p>
			<p class="source-code">          'image');</p>
			<p class="source-code">      expect(article.author).to.have.keys('id', 'name');</p>
			<p class="source-code">      expect(article.image).to.have.keys('url', 'author');</p>
			<p class="source-code"><strong class="bold">        done();</strong></p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p>As you can see, we're using the <strong class="source-inline">.to.have.keys</strong> method to test that returning object contains all the keys specified in the function argument.</p>
			<p>Another thing to notice is that we're doing that in an <strong class="source-inline">each</strong> loop. For that reason, we will need to call the <strong class="source-inline">done</strong> method (highlighted in the code snippet) once we've tested all the desired properties, as Cypress cannot control when the code inside of the <strong class="source-inline">each</strong> callback has returned.</p>
			<p>We can proceed by <a id="_idIndexMarker525"/>writing <a id="_idIndexMarker526"/>another couple of tests to see if we can get a single article given a fixed article ID:</p>
			<p class="source-code">test('should correctly return a an article given an ID', (done) =&gt; {</p>
			<p class="source-code">  cy.request('http://localhost:3000/api/article?id=u12w3o0d')</p>
			<p class="source-code">    .then(({ body }) =&gt; {</p>
			<p class="source-code">      expect(body)</p>
			<p class="source-code">        .to.have.keys('id', 'title', 'body', 'author', </p>
			<p class="source-code">         'image');</p>
			<p class="source-code">      expect(body.author).to.have.keys('id', 'name');</p>
			<p class="source-code">      expect(body.image).to.have.keys('url', 'author');</p>
			<p class="source-code">      done();</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>And we can also test that the server returns a <strong class="source-inline">404</strong> status code when the article is not found. To do that, we will need to change our request method a bit as Cypress, by default, throws an error when a status code greater than or equal to 400 is encountered:</p>
			<p class="source-code">test('should return 404 when an article is not found', () =&gt; {</p>
			<p class="source-code">  cy.request(<strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    url: 'http://localhost:3000/api/article?id=unexistingID',</strong></p>
			<p class="source-code"><strong class="bold">    failOnStatusCode: false,</strong></p>
			<p class="source-code"><strong class="bold">  })</strong></p>
			<p class="source-code">  .its('status')</p>
			<p class="source-code">  .should('be.equal', 404);</p>
			<p class="source-code">});</p>
			<p>Now that we have written<a id="_idIndexMarker527"/> the <a id="_idIndexMarker528"/>tests, we're ready to run them, but there's still a problem. If we try to run <strong class="source-inline">yarn cypress</strong>, we will see the following error on the console:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_9.02_B16985.jpg" alt="Figure 9.2 – Cypress cannot connect to the server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Cypress cannot connect to the server</p>
			<p>In fact, Cypress runs our tests against a real server, which is not reachable at the moment. We can quickly solve that by adding the following dependency:</p>
			<p class="source-code">yarn add -D start-server-and-test</p>
			<p>This will help us by building and starting the server, and once it's reachable, it will run Cypress. To do that, we will need to edit our <strong class="source-inline">package.json</strong> file too:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "dev": "next dev",</p>
			<p class="source-code">  "build": "next build",</p>
			<p class="source-code">  "start": "next start",</p>
			<p class="source-code">  "test": "jest",</p>
			<p class="source-code">  "cypress": "cypress run",</p>
			<p class="source-code">  <strong class="bold">"e2e": "start-server-and-test 'yarn build &amp;&amp; yarn start' </strong></p>
			<p class="source-code"><strong class="bold">   http://localhost:3000 cypress"</strong></p>
			<p class="source-code">},</p>
			<p>If we now try to run <strong class="source-inline">yarn e2e</strong>, we<a id="_idIndexMarker529"/> will <a id="_idIndexMarker530"/>see that the tests are passing correctly!</p>
			<p>Let's create one last test file where we'll be testing the navigation between pages. We can call it <strong class="source-inline">cypress/integration/navigation.spec.js</strong>, and we can add the following content:</p>
			<p class="source-code">describe('Navigation', () =&gt; {</p>
			<p class="source-code">  test('should correctly navigate to the article page', () </p>
			<p class="source-code">   =&gt; {</p>
			<p class="source-code">    cy.visit('http://localhost:3000/');</p>
			<p class="source-code">    cy.get('a[href*="/articles"]').first().click();</p>
			<p class="source-code">    cy.url().should('be.equal', </p>
			<p class="source-code">    'http://localhost:3000/articles/healthy-summer-meloncarrot-</p>
			<p class="source-code">     soup-u12w3o0d');</p>
			<p class="source-code">    cy.get('h1').contains('Healthy summer melon-carrot </p>
			<p class="source-code">     soup');</p>
			<p class="source-code">  });</p>
			<p class="source-code">  test('should correctly navigate back to the homepage', () </p>
			<p class="source-code">   =&gt; {</p>
			<p class="source-code">    cy.visit('http://localhost:3000/articles/</p>
			<p class="source-code">      healthy-summer-meloncarrot-soup-u12w3o0d');</p>
			<p class="source-code">    cy.get('a[href*="/"]').first().click();</p>
			<p class="source-code">    cy.url().should('be.equal', 'http://localhost:3000/');</p>
			<p class="source-code">    cy.get('h1').contains('My awesome blog');</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>In the first test case, we're <a id="_idIndexMarker531"/>asking Cypress to visit our website's home <a id="_idIndexMarker532"/>page. Then, we look for all the links where the <strong class="source-inline">href</strong> property contains <strong class="source-inline">/articles</strong>. We then click on the first occurrence and expect the new URL to be equal to a fixed value (<strong class="source-inline">http://localhost:3000/articles/healthy-summer-meloncarrot-soup-u12w3o0d</strong>).</p>
			<p>We also test that the <strong class="source-inline">&lt;h1&gt;</strong> HTML element contains the correct title. But what does this test tell us?</p>
			<ul>
				<li>We can navigate between pages; links aren't broken. Then, of course, we should add more and more tests for links, but we just want to look at the concept right now.</li>
				<li>The Next.js server correctly asks and serves the correct data, since we can spot the right title inside the rendered page.</li>
			</ul>
			<p>In the second test case, we ask Cypress to visit a single article page, then click on a link to go back to the home page. Again, we test the new URL is correct, and the <strong class="source-inline">&lt;h1&gt;</strong> HTML element contains the right title for the home page.</p>
			<p>Of course, these are not complete tests, as we might want to check whether the behavior of the website is consistent between browsers (especially if we do a lot of client-side rendering), that an existing form gets validated correctly, giving accurate feedback to the user, and so on.</p>
			<p>Like unit and integration testing, end-to-end testing is a vast and complex topic that we must deal with before shipping code to production, as it can ensure greater quality for our product, with fewer bugs and more control over regressions.</p>
			<p>If you're interested<a id="_idIndexMarker533"/> in<a id="_idIndexMarker534"/> learning more about Cypress, I suggest you read the book <em class="italic">End-to-End Web Testing with Cypress</em>, by Waweru Mwaura, published by Packt.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, we've seen how to write unit, integration, and end-to-end tests using some of the most popular libraries and test runners out there, such as Cypress, Jest, and react-testing-library.</p>
			<p>As mentioned multiple times during the chapter, testing is essential for any application development and release process. It should be taken seriously as it can be the difference between a successful and an unsuccessful product.</p>
			<p>In the next chapter, we will focus on a different yet crucial topic: SEO and performance. Even if our code base is 100% tested, well-designed, and working great, we need to consider its SEO score and performance. In many cases, we want as many people as possible to be browsing our applications, and we must take care of search engine optimization to reach a large audience to validate our product.</p>
		</div>
	</body></html>