- en: 12\. Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 单元测试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at approaches to unit testing Vue.js applications
    in order to improve our quality and speed of delivery. We will also look at using
    tests to drive development using T**est-Driven Development** (**TDD**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨对 Vue.js 应用程序进行单元测试的方法，以提高我们的质量和交付速度。我们还将探讨使用测试来驱动开发，即 T**est-Driven
    Development**（**TDD**）。
- en: As we proceed, you will gain an understanding of why code needs to be tested
    and what kinds of testing can be employed on different parts of a Vue.js application.
    You will see how to unit test isolated components and their methods using shallow
    rendering and `vue-test-utils`, and you will learn how to test asynchronous component
    code. Throughout the course of the chapter, you will gain familiarity with techniques
    to write efficient unit tests for **mixins** and **filters**. Toward the end of
    the chapter, you will become familiar with approaches to testing a Vue.js applications
    that includes routing and Vuex, and you will learn about using snapshot tests
    to validate your user interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，你将了解为什么代码需要被测试，以及可以在 Vue.js 应用的不同部分采用哪些类型的测试。你将看到如何使用浅渲染和 `vue-test-utils`
    对隔离组件及其方法进行单元测试，你还将学习如何测试异步组件代码。在整个章节的过程中，你将熟悉编写针对 **混入** 和 **过滤器** 的有效单元测试的技术。在章节的末尾，你将熟悉包括路由和
    Vuex 在内的 Vue.js 应用程序的测试方法，你还将了解如何使用快照测试来验证你的用户界面。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look at the purpose and approaches to testing Vue.js
    applications effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨有效测试 Vue.js 应用程序的目的和方法。
- en: In previous chapters, we saw how to build reasonably complex Vue.js applications.
    This chapter is about testing them to maintain code quality and prevent defects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何构建合理的复杂 Vue.js 应用程序。本章是关于测试它们以保持代码质量和防止缺陷。
- en: Unit testing will allow us to write fast and specific tests that we can develop
    against and ensure that features don't exhibit unwanted behavior. We'll see how
    to write unit tests for different parts of a Vue.js application, such as components,
    mixins, filters, and routing. We will use tools supported by the Vue.js core team,
    such as `vue-test-utils`, and tools supported by the rest of the open source community,
    such as the Vue Testing library and the **Jest testing framework**. These different
    tools will serve to illustrate different philosophies and approaches to unit testing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试将使我们能够编写快速且具体的测试，我们可以针对这些测试进行开发，并确保功能不会表现出不受欢迎的行为。我们将了解如何为 Vue.js 应用的不同部分编写单元测试，例如组件、混入、过滤器以及路由。我们将使用
    Vue.js 核心团队支持的工具，如 `vue-test-utils`，以及开源社区其他部分支持的工具，如 Vue 测试库和 **Jest 测试框架**。这些不同的工具将用于说明不同的单元测试哲学和方法。
- en: Why We Need to Test Code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要测试代码
- en: Testing is crucial for ensuring that the code does what it's meant to do.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于确保代码按预期执行至关重要。
- en: Quality production software is empirically correct. That means that for the
    enumerated cases that developers and testers have found, the application behaves
    as expected.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 质量生产软件是经验上正确的。这意味着对于开发人员和测试人员发现的列举案例，应用程序的行为符合预期。
- en: This lies in contrast with software that has *proven* to be correct, which is
    a very time-consuming endeavor and is usually part of academic research projects.
    We are still at the point where **correct software** (proven) is still being built
    to show what kinds of systems are possible to build with this constraint of correctness.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这与已被 *证明* 正确的软件形成对比，这是一个非常耗时的工作，通常是学术研究项目的一部分。我们仍然处于这样一个阶段，即 **正确的软件**（已证明）仍在构建，以展示在正确性的约束下可以构建哪些类型的系统。
- en: Testing prevents the introduction of defects such as bugs and regressions (that
    is, when a feature stops working as expected). In the next section, we will learn
    about the various types of testing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以防止引入缺陷，如错误和回归（即，当某个功能停止按预期工作时）。在下一节中，我们将了解各种测试类型。
- en: Understanding Different Types of Testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同类型的测试
- en: The testing spectrum spans from end-to-end testing (by manipulating the user
    interface) to integration tests, and finally to unit tests. End-to-end tests test
    everything, including the user interface, the underlying HTTP services, and even
    database interactions; nothing is mocked. For example, if you've got an e-commerce
    application, an end-to-end test might actually place a real order with a real
    credit card, or it might place a test order, with a test credit card.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 测试范围从端到端测试（通过操作用户界面）到集成测试，最后到单元测试。端到端测试测试一切，包括用户界面、底层HTTP服务，甚至数据库交互；没有任何内容被模拟。例如，如果你有一个电子商务应用程序，端到端测试可能会实际使用真实信用卡下订单，或者它可能会使用测试信用卡下测试订单。
- en: End-to-end tests are costly to run and maintain. They require the use of full-blown
    browsers controlled through programmatic drivers such as **Selenium**, **WebdriverIO**,
    or **Cypress**. This type of test platform is costly to run, and small changes
    in the application code can cause end-to-end tests to start failing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的运行和维护成本较高。它们需要使用通过程序性驱动程序（如**Selenium**、**WebdriverIO**或**Cypress**）控制的完整浏览器。这种测试平台运行成本较高，应用代码中的微小变化都可能导致端到端测试开始失败。
- en: Integration or system-level tests ensure that a set of systems is working as
    expected. This will usually involve deciding on a limit as to where the **system
    under test** lies and allowing it to run, usually against mocked or stubbed upstream
    services and systems (which are therefore not under test). Since external data
    access is stubbed, a whole host of issues, such as timeouts and flakes, can be
    reduced (when compared to end-to-end tests). Integration test suites are usually
    fast enough to run as a continuous integration step, but the full test suite tends
    not to be run locally by engineers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 集成或系统级测试确保一组系统按预期工作。这通常涉及确定**被测试系统**的界限，并允许它运行，通常是对模拟或存根的上游服务和系统进行测试（因此这些服务和系统不在测试范围内）。由于外部数据访问被存根，可以减少许多问题，如超时和故障（与端到端测试相比）。集成测试套件通常足够快，可以作为持续集成步骤运行，但完整的测试套件通常不会由工程师在本地运行。
- en: Unit tests are great at providing fast feedback during development. Unit testing
    paired with TDD is part of extreme programming practice. Unit tests are great
    at testing complicated logic or building a system from its expected output. Unit
    tests are usually fast enough to run that developers code against them before
    sending their code for review and continuous integration tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在开发过程中提供快速反馈方面非常出色。单元测试与TDD（测试驱动开发）相结合是极限编程实践的一部分。单元测试擅长测试复杂的逻辑或从预期的输出构建系统。单元测试通常足够快，以至于开发者在将代码提交审查和持续集成测试之前，会先针对它们编写代码。
- en: 'The following is an interpretation of the pyramid of testing. It can be interpreted
    as: you should have a high number of cheap and fast unit tests, a reasonable number
    of system tests, and a few end-to-end UI tests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对测试金字塔的解释。它可以理解为：你应该有大量便宜且快速的单元测试，合理数量的系统测试，以及少数端到端UI测试：
- en: '![Figure 12.1: Pyramid of testing diagram'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：测试金字塔图]'
- en: '](img/B15218_12_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B15218_12_01.jpg]'
- en: 'Figure 12.1: Pyramid of testing diagram'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：测试金字塔图
- en: Now that we've looked at why we should be testing applications, let's start
    writing some tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了为什么我们应该测试应用程序，让我们开始编写一些测试。
- en: Your First Test
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个测试
- en: 'To illustrate how quick and easy it is to get started with automated unit tests
    in a Vue CLI project, we will start by setting up and writing a unit test with
    Jest, `@vue-test-utils`. There is an official Vue CLI package that can be used
    to generate a setup that includes unit testing with Jest and `vue-test-utils`.
    The following command should be run in a project that has been set up with Vue
    CLI:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在Vue CLI项目中开始自动化单元测试有多快、有多简单，我们将首先设置并使用Jest和`@vue-test-utils`编写一个单元测试。有一个官方的Vue
    CLI包可以用来生成一个包含使用Jest和`vue-test-utils`进行单元测试的设置。以下命令应在已设置Vue CLI的项目中运行：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Vue CLI adds Jest as the test runner, `@vue/test-utils`, the official `Vue.js`
    testing utilities, and `vue-jest`, a processor for `.vue` single-file component
    files in Jest. It adds a `test:unit` script.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Vue CLI将Jest作为测试运行器，`@vue/test-utils`作为官方的`Vue.js`测试工具，以及`vue-jest`，它是Jest中用于处理`.vue`单文件组件文件的处理器。它添加了一个`test:unit`脚本。
- en: By default, it creates a `tests/unit` folder, which we'll remove. Instead, we
    can create a `__tests__` folder and create an `App.test.js` file as follows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它创建一个`tests/unit`文件夹，我们将删除它。相反，我们可以创建一个`__tests__`文件夹，并创建一个`App.test.js`文件，如下所示。
- en: 'We will use `shallowMount` to render the application and test that it displays
    the correct text. For the purposes of this example, we''ll use the text: "`The
    Vue.js Workshop Blog`".'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `shallowMount` 来渲染应用程序并测试它是否显示正确的文本。为了本例的目的，我们将使用文本："`The Vue.js Workshop
    Blog`"。
- en: '`shallowMount` does a **shallow render**, which means that only the top level
    of a component is rendered; all the child components are stubbed. This is useful
    for testing a component in isolation since the child components'' implementations
    are not run:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`shallowMount` 进行**浅渲染**，这意味着只渲染组件的最顶层；所有子组件都是占位符。这对于单独测试组件很有用，因为子组件的实现并未运行：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This test will fail when we run `npm run test:unit` because we do not have
    `The Vue.js Workshop Blog` in the `App` component:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `npm run test:unit` 时，这个测试将失败，因为我们没有在 `App` 组件中包含 `The Vue.js Workshop
    Blog`：
- en: '![Figure 12.2: Blog title heading failing the test at the command line'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：在命令行中测试失败的博客标题标题]'
- en: '](img/B15218_12_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_02.jpg]'
- en: 'Figure 12.2: Blog title heading failing the test at the command line'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：在命令行中测试失败的博客标题标题
- en: 'In order to get the test to pass, we can implement our blog title heading in
    the `App.vue` file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让测试通过，我们可以在 `App.vue` 文件中实现我们的博客标题标题：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have got the right heading, `npm run test:unit` will pass:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了正确的标题，`npm run test:unit` 将会通过：
- en: '![Figure 12.3: Blog heading test passing'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：博客标题测试通过]'
- en: '](img/B15218_12_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_03.jpg]'
- en: 'Figure 12.3: Blog heading test passing'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：博客标题测试通过
- en: 'We can also check that it renders as expected in the browser:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查它在浏览器中的渲染是否符合预期：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You have just completed your first piece of TDD. This process started by writing
    a test that failed. This failure was followed by an update to the code under test
    (in this case the `App.vue` component), which made the failing test pass. The
    TDD process gives us confidence that our features have been tested properly since
    we can see that tests fail before they pass when we update the code that drives
    our feature.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚完成了你的第一个TDD（测试驱动开发）。这个过程从编写一个失败的测试开始。随后是对测试代码（在本例中是 `App.vue` 组件）的更新，这使得失败的测试通过。TDD过程让我们有信心我们的功能已经得到了适当的测试，因为我们可以看到在更新驱动我们功能的代码之前，测试是失败的。
- en: Testing Components
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: Components are at the core of Vue.js applications. Writing unit tests for them
    is straightforward with `vue-test-utils` and Jest. Having tests that exercise
    the majority of your components gives you confidence that they behave as designed.
    Ideal unit tests for components run quickly and are simple.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是 Vue.js 应用程序的核心。使用 `vue-test-utils` 和 Jest 对它们进行单元测试非常简单。对大多数组件进行测试可以让你有信心它们按设计运行。理想的组件单元测试运行速度快且简单。
- en: We'll carry on building the blog application example. We have now built the
    heading, but a blog usually also needs a list of posts to display.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续构建博客应用程序示例。我们现在已经构建了标题，但一个博客通常还需要一个帖子列表来显示。
- en: 'We''ll create a `PostList` component. For now, it will just render a `div`
    wrapper and support a `posts` `Array` prop:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `PostList` 组件。目前，它将只渲染一个 `div` 包装器并支持 `posts` `Array` 属性：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can add some data in the `App` component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `App` 组件中添加一些数据：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have some posts, we can pass them as a bound prop to the `PostList`
    component from the `App` component:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些帖子，我们可以将它们作为绑定属性从 `App` 组件传递给 `PostList` 组件：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our `PostList` component will render out each post in a `PostListItem` component,
    which we'll create as follows.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PostList` 组件将在 `PostListItem` 组件中渲染每篇帖子，我们将按以下方式创建它。
- en: '`PostListItem` takes two props: `title` (which is a string) and `description`
    (also a string). It renders them in an `h3` tag and a `p` tag, respectively:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostListItem` 接受两个属性：`title`（一个字符串）和 `description`（也是一个字符串）。它分别用 `h3` 标签和
    `p` 标签渲染它们：'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now need to loop through the posts and render out a `PostListItem` component
    with relevant props bound in the `PostList.vue` component:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要遍历帖子并使用 `PostList.vue` 组件渲染带有相关属性的 `PostListItem` 组件：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now see the heading and the post list in the application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在应用程序中看到标题和帖子列表：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To test the `PostListItem` component, we can shallow render with some arbitrary
    `title` and `description` props set, and check that they get rendered:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `PostListItem` 组件，我们可以使用一些任意的 `title` 和 `description` 属性进行浅渲染，并检查它们是否被渲染：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The test output of `npm run test:unit __tests__/PostListItem.test.js` is as
    follows; the component passes the test:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm run test:unit __tests__/PostListItem.test.js` 的测试输出如下；组件通过了测试：
- en: '![Figure 12.4: PostListItem test output'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：PostListItem测试输出]'
- en: '](img/B15218_12_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_04.jpg)'
- en: 'Figure 12.4: PostListItem test output'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：PostListItem测试输出
- en: 'Next, we''ll see one of the pitfalls of shallow rendering. When testing the
    `PostList` component, all we can do is test the number of `PostListItem` components
    it''s rendering:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到浅渲染的一个陷阱。当测试`PostList`组件时，我们所能做的就是测试它渲染的`PostListItem`组件的数量：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This passes, but we are testing something that the user will not directly interact
    with, the number of `PostListItem` instances rendered in `PostList`, as shown
    in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了，但我们测试的是用户不会直接与之交互的东西，即`PostList`中渲染的`PostListItem`实例的数量，如下面的截图所示：
- en: '![Figure 12.5: PostList test output'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：PostList测试输出'
- en: '](img/B15218_12_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_05.jpg)'
- en: 'Figure 12.5: PostList test output'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：PostList测试输出
- en: A better solution is to use the `mount` function, which renders the full component
    tree, whereas the `shallow` function would only render out the children of the
    component being rendered. With `mount`, we can assert that the titles and descriptions
    are rendered to the page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用`mount`函数，它渲染完整的组件树，而`shallow`函数只会渲染正在渲染的组件的子组件。使用`mount`，我们可以断言标题和描述被渲染到页面上。
- en: The drawback of this approach is that we're testing both the `PostList` component
    and the `PostListItem` component since the `PostList` component doesn't render
    the title or description; it renders a set of `PostListItem` components that in
    turn render the relevant title and description.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是我们同时测试了`PostList`组件和`PostListItem`组件，因为`PostList`组件不渲染标题或描述；它渲染一组`PostListItem`组件，这些组件反过来渲染相关的标题和描述。
- en: 'The code will be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The new tests pass as per the following output of `npm run test:unit __tests__/PostList.vue`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的测试按照以下`npm run test:unit __tests__/PostList.vue`的输出通过：
- en: '![Figure 12.6: Test run for PostList with both shallow and mounted tests'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：PostList的浅渲染和挂载测试运行'
- en: '](img/B15218_12_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_06.jpg)'
- en: 'Figure 12.6: Test run for PostList with both shallow and mounted tests'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：PostList的浅渲染和挂载测试运行
- en: We have now seen how to write unit tests for Vue.js components using Jest and
    `vue-test-utils`. These tests can be run often, and test runs complete within
    seconds, which gives us near-immediate feedback while working on new or existing components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用Jest和`vue-test-utils`为Vue.js组件编写单元测试。这些测试可以经常运行，测试运行在几秒内完成，这在我们处理新组件或现有组件时提供了几乎即时的反馈。
- en: 'Exercise 12.01: Building and Unit Testing a Tag List Component'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：构建和单元测试标签列表组件
- en: When creating the fixture for `posts`, we populated a `tags` field with `vue`,
    `angularjs`, and `react` but did not display them. To make tags useful, we will
    display the tags in the post list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`posts`的测试用例时，我们用`vue`、`angularjs`和`react`填充了`tags`字段，但没有显示它们。为了使标签有用，我们将在帖子列表中显示标签。
- en: 'To access the code files for this exercise, refer to [https://packt.live/2HiTFQ1](https://packt.live/2HiTFQ1):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2HiTFQ1](https://packt.live/2HiTFQ1)：
- en: 'We can start by writing a unit test that will explain what we expect a `PostListItem`
    component to do when passed a set of tags as props. It expects that each tag will
    be rendered with a hashtag prepended to it; for example, the `react` tag will
    be shown as `#react`. In the `__tests__/PostListItem.test.js` file, we can add
    a new `test`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以首先编写一个单元测试，说明当传递一组标签作为props给`PostListItem`组件时，我们期望它做什么。它期望每个标签都会有一个前置的井号；例如，`react`标签将显示为`#react`。在`__tests__/PostListItem.test.js`文件中，我们可以添加一个新的`test`：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This test fails when run with `npm run test:unit __tests__/PostListItem.test.js`:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用`npm run test:unit __tests__/PostListItem.test.js`运行此测试时，测试失败：
- en: '![Figure 12.7: Tag test for PostListItem failing'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.7：PostListItem标签测试失败'
- en: '](img/B15218_12_07.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_12_07.jpg)'
- en: 'Figure 12.7: Tag test for PostListItem failing'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.7：PostListItem标签测试失败
- en: 'Next, we should implement the tag list rendering in `src/components/PostListItem.vue`.
    We''ll add tags as props of the `Array` type and use `v-for` to render out the
    tags:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该在`src/components/PostListItem.vue`中实现标签列表渲染。我们将添加标签作为`Array`类型的props，并使用`v-for`渲染标签：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the `PostListItem` component implemented, the unit test should now pass:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实现了`PostListItem`组件之后，单元测试现在应该通过：
- en: '![Figure 12.8: PostListItem unit test passing'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.8：PostListItem单元测试通过'
- en: '](img/B15218_12_08.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_12_08.jpg)'
- en: 'Figure 12.8: PostListItem unit test passing'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.8：PostListItem单元测试通过
- en: 'However, the tags are not displayed in the application:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，标签在应用程序中没有显示：
- en: '![Figure 12.9: PostList displaying without tags despite'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.9：显示没有标签的 PostList]'
- en: the correct PostListItem implementation
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确的 PostListItem 实现
- en: '](img/B15218_12_09.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_09.jpg](img/B15218_12_09.jpg)'
- en: 'Figure 12.9: PostList displaying without tags despite the correct PostListItem
    implementation'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.9：尽管 PostListItem 实现正确，但 PostList 显示没有标签
- en: 'We can write a unit test for `PostList` that would show this behavior. In essence,
    we''ll be passing some tags in our `posts` list and running the same assertions
    as are already present in the `PostListItem.test.js` file. We''ll do this in `__tests__/PostList.test.js`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为 `PostList` 编写一个单元测试，以展示这种行为。本质上，我们将向我们的 `posts` 列表中传递一些标签，并运行 `PostListItem.test.js`
    文件中已经存在的相同断言。我们将在 `__tests__/PostList.test.js` 中这样做：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As per our application output, the test is failing when run with `npm run test:unit
    __tests__/PostList.test.js`:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据我们的应用程序输出，当使用 `npm run test:unit __tests__/PostList.test.js` 运行时，测试失败：
- en: '![Figure 12.10: PostList tags test failing'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.10：PostList 标签测试失败]'
- en: '](img/B15218_12_10.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_10.jpg](img/B15218_12_10.jpg)'
- en: 'Figure 12.10: PostList tags test failing'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.10：PostList 标签测试失败
- en: 'In order to fix this test, we can find the issue in `src/components/PostList.vue`,
    where the `tags` prop for `PostListItem` is not bound. By updating `src/components/PostList.vue`
    to bind the `tags` prop, we can fix the unit test:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复这个测试，我们可以在 `src/components/PostList.vue` 中找到问题，这里的 `PostListItem` 的 `tags`
    属性没有被绑定。通过更新 `src/components/PostList.vue` 来绑定 `tags` 属性，我们可以修复单元测试：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The failing unit test now passes, as shown in the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 失败的单元测试现在通过了，如下面的截图所示：
- en: '![Figure 12.11: PostList tags test passing'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.11：PostList 标签测试通过]'
- en: '](img/B15218_12_11.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_11.jpg](img/B15218_12_11.jpg)'
- en: 'Figure 12.11: PostList tags test passing'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11：PostList 标签测试通过
- en: 'The tags also appear in the application, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 标签也出现在应用程序中，如下面的截图所示：
- en: '![Figure 12.12: Blog list rendering with tags'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.12：带有标签的博客列表渲染]'
- en: '](img/B15218_12_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_12.jpg](img/B15218_12_12.jpg)'
- en: 'Figure 12.12: Blog list rendering with tags'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12：带有标签的博客列表渲染
- en: 'We have now seen how we can test rendered component output with both the shallow
    rendering and mounting of components. Let''s briefly understand what each of these
    terms means:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用浅渲染和组件挂载来测试渲染的组件输出。让我们简要了解这些术语的含义：
- en: '**Shallow rendering**: This renders at a depth of 1, meaning that if children
    are components, they will just be rendered as the component tag; their template
    will not be run.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浅渲染**：这将在深度 1 处渲染，这意味着如果子元素是组件，它们将仅作为组件标签渲染；它们的模板将不会运行。'
- en: '**Mounting**: This renders the full component tree in a similar fashion as
    would be rendered in the browser.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：这将以与在浏览器中渲染相似的方式渲染整个组件树。'
- en: Next, we'll look at how to test component methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何测试组件方法。
- en: Testing Methods, Filters and Mixins
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试方法、过滤器和方法混合
- en: Since `click`, `input change`, `focus change`, and `scroll`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `click`、`input change`、`focus change` 和 `scroll`）。
- en: 'For example, a filter that truncates its input to eight characters would be
    implemented as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个将输入截断为八个字符的过滤器将实现如下：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are two options to test it. We could test it directly by importing the
    component and calling `truncate` on some input, as per the `truncate.test.js`
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种测试它的方法。我们可以直接通过导入组件并在某些输入上调用 `truncate` 来测试它，就像 `truncate.test.js` 文件中那样：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The alternative is to check where it''s being used in the `PostListItem` component:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是检查它在 `PostListItem` 组件中的使用情况：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can test `truncate` by checking what happens when we pass a long title
    into the `PostListItem` component in the `PostListItem.test.js` file, which we
    do in the following test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在 `PostListItem.test.js` 文件中将长标题传递给 `PostListItem` 组件来测试 `truncate`，我们在以下测试中这样做：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code will generate the output shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成以下截图所示的输出：
- en: '![Figure 12.13: PostListItem test for the title failing because'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13：PostListItem 测试失败，因为]'
- en: the content of the title is truncated
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标题的内容被截断
- en: '](img/B15218_12_13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_13.jpg](img/B15218_12_13.jpg)'
- en: 'Figure 12.13: PostListItem test for the title failing because the content of
    the title is truncated'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13：PostListItem 的标题测试失败，因为标题的内容被截断
- en: To fix this, we could update the failing test to expect `Blog pos` instead of
    `Blog post title`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们可以更新失败的测试，期望 `Blog pos` 而不是 `Blog post title`。
- en: These two approaches are great for testing filters. As we saw before with `filters.truncate()`
    test since it directly accesses the `truncate` filter. The looser unit test is
    the test using passed props and validating the component output. A tighter unit
    will usually mean tests are simpler, but it comes at the cost of sometimes testing
    functionality in a fashion that is very removed from how the end user perceives
    it. For example, the user would never call `filters.truncate()` directly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是测试过滤器的优秀方法。正如我们之前在`filters.truncate()`测试中看到的那样，它直接访问了`truncate`过滤器。较宽松的单元测试是使用传入的属性并验证组件输出的测试。更紧密的单元测试通常意味着测试更简单，但这也意味着有时以与最终用户感知非常不同的方式测试功能。例如，用户永远不会直接调用`filters.truncate()`。
- en: We have seen how to test an arbitrary `truncate` filter. We will now implement
    an `ellipsis` filter and test it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试一个任意的`truncate`过滤器。现在我们将实现一个`ellipsis`过滤器并对其进行测试。
- en: The `ellipsis` filter will be applied to the post description and will limit
    its length to `40` characters plus `…`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ellipsis`过滤器将应用于帖子描述，并将其长度限制为`40`个字符加上`…`。'
- en: 'Exercise 12.02: Building and Testing an ellipsis Filter'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：构建和测试省略号过滤器
- en: We have seen how to test an arbitrary `truncate` filter; we will now implement
    an `ellipsis` filter and test it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试一个任意的`truncate`过滤器；现在我们将实现一个`ellipsis`过滤器并对其进行测试。
- en: To access the code files for this exercise, refer to [https://packt.live/2UK9Mcs](https://packt.live/2UK9Mcs).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2UK9Mcs](https://packt.live/2UK9Mcs)。
- en: 'Now let''s look at the steps to build and test an `ellipsis` filter:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看构建和测试`ellipsis`过滤器的步骤：
- en: 'We can start by writing a set of tests for the `ellipsis` filter (which will
    live in `src/components/PostListItem.vue`). One test should check that the filter
    does nothing if the passed value is less than `50` characters; another should
    check that if the passed value is more than `50` characters, it truncates to `50`
    and appends `…`. We will do this in a `__tests__/ellipsis.test.js` file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以先为`ellipsis`过滤器编写一组测试（该过滤器将位于`src/components/PostListItem.vue`中）。一个测试应该检查如果传入的值少于`50`个字符，过滤器不做任何处理；另一个测试应该检查如果传入的值超过`50`个字符，它将截断到`50`个字符并附加`…`。我们将在`__tests__/ellipsis.test.js`文件中这样做：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now implement the logic for `ellipsis` in `src/components/PostListItem.vue`.
    We will add a `filters` object with `ellipsis`, which will use `String#slice`
    if the passed value is longer than `50` characters and do nothing otherwise:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在`src/components/PostListItem.vue`中实现`ellipsis`的逻辑。我们将添加一个带有`ellipsis`的`filters`对象，如果传入的值超过`50`个字符，它将使用`String#slice`，否则不做任何处理：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this case, the test now passes `npm run test:unit __tests__/ellipsis.test.js`,
    as shown in *Figure 12.14*:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，现在测试通过`npm run test:unit __tests__/ellipsis.test.js`，如图*图12.14*所示：
- en: '![Figure 12.14: The ellipsis filter unit test passing'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.14：省略号过滤器单元测试通过]'
- en: '](img/B15218_12_14.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_14.jpg]'
- en: 'Figure 12.14: The ellipsis filter unit test passing'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.14：省略号过滤器单元测试通过
- en: 'We now need to integrate our `ellipsis` filter into the component. To check
    whether this will work, we can first write the test in `__tests__/PostListItem.test.js`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的`ellipsis`过滤器集成到组件中。为了检查这能否工作，我们首先可以在`__tests__/PostListItem.test.js`中编写测试：
- en: '[PRE23]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This test fails since we don''t use the filter in the component template. The
    output will be as follows:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个测试失败了，因为我们没有在组件模板中使用过滤器。输出将如下所示：
- en: '![Figure 12.15: PostListItem ellipsis test failing'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.15：PostListItem省略号测试失败]'
- en: '](img/B15218_12_15.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_15.jpg]'
- en: 'Figure 12.15: PostListItem ellipsis test failing'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.15：PostListItem省略号测试失败]'
- en: 'To get the test to pass, we need to pipe the `description` property into the
    `ellipsis` filter in `src/components/PostListItem.vue`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要将`description`属性通过`src/components/PostListItem.vue`中的`ellipsis`过滤器：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, the test will pass, as displayed in the following screenshot:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，测试将通过，如下面的截图所示：
- en: '![Figure 12.16: PostListItem ellipsis test passing'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.16：PostListItem省略号测试通过]'
- en: '](img/B15218_12_16.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_16.jpg]'
- en: 'Figure 12.16: PostListItem ellipsis test passing'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16：PostListItem省略号测试通过]'
- en: 'We can see the descriptions being truncated in the application interface in
    the browser, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器中的应用程序界面中看到描述被截断，如下所示：
- en: '![Figure 12.17: Blog post item descriptions being truncated to 50 characters'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：博客帖子项描述被截断到50个字符]'
- en: '](img/B15218_12_17.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15218_12_17.jpg]'
- en: 'Figure 12.17: Blog post item descriptions being truncated to 50 characters'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：博客帖子项描述被截断到50个字符
- en: We have now seen how to test filters and other properties of a Vue.js component
    not only by testing directly against the object but also by testing the functionality
    where it is being used in component-level tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试Vue.js组件的过滤器和其他属性，不仅可以通过直接针对对象进行测试，还可以通过测试它在组件级测试中的功能来测试。
- en: Next, we will see how to deal with an application that uses Vue.js routing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何处理使用Vue.js路由的应用程序。
- en: Testing Vue Routing
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Vue路由
- en: We have currently got an application that renders what is our blog home page
    or **feed view**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有一个渲染我们博客主页或**feed视图**的应用程序。
- en: Next, we should have post pages. To do this, we will use Vue Router, as covered
    in previous chapters, and ensure that our routing works as designed with unit
    tests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该有帖子页面。为此，我们将使用Vue Router，如前几章所述，并确保我们的路由通过单元测试按设计工作。
- en: 'Vue Router is installed using `npm`, specifically, `npm install vue-router`,
    and wiring it up in the `main.js` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Vue Router使用`npm`安装，具体来说，`npm install vue-router`，并在`main.js`文件中进行配置：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `router.js` file registers `vue-router` with Vue using `Vue.use` and instantiates
    a `VueRouter` instance:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.js`文件使用`Vue.use`将`vue-router`注册到Vue中，并实例化一个`VueRouter`实例：'
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A router with no routes isn''t very useful. We''ll define the root path (`/`)
    to display the `PostList` component in the `router.js` file, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 没有路由的路由器并不很有用。我们将在`router.js`文件中定义根路径（`/`），以显示`PostList`组件，如下所示：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we''ve got our initial route, we should update the `App.vue` file
    to leverage the component being rendered by the router. We''ll render `render-view`
    instead of directly using `PostList`. The `posts` binding, however, stays the
    same:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了初始路由，我们应该更新`App.vue`文件以利用由路由器渲染的组件。我们将渲染`render-view`而不是直接使用`PostList`。然而，`posts`绑定保持不变：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, our posts in the `App.vue` file are missing a bit of core data to render
    a `SinglePost` component. We need to make sure to have the `slug` and `content`
    properties to render something useful on our `SinglePost` page:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`App.vue`文件中的帖子缺少一些核心数据来渲染`SinglePost`组件。我们需要确保有`slug`和`content`属性，以便在我们的`SinglePost`页面上渲染有用的内容：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now start working on a `SinglePost` component. For now, we''ll just
    have some placeholders in the template. Also, `SinglePost` will receive `posts`
    as a prop, so we can fill that in as well:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始工作在`SinglePost`组件上。目前，我们只是在模板中添加一些占位符。此外，`SinglePost`将接收`posts`作为属性，因此我们也可以填写这个属性：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we will register `SinglePost` in `router.js`, with the `/:postId` path
    (which will be available to the component under `this.$route.params.postId`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`router.js`中注册`SinglePost`，使用`/:postId`路径（这将通过`this.$route.params.postId`在组件中可用）：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we switch back to implementing the `SinglePost` component, we''ve got access
    to `postId`, which will map to the slug in the `posts` array, and we''ve also
    got access to `posts` since it''s being bound onto `render-view` by `App`. Now
    we can create a computed property, `post`, which finds posts based on `postId`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换回实现`SinglePost`组件，我们将能够访问`postId`，它将映射到`posts`数组中的slug，并且我们也有`posts`的访问权限，因为它被`App`绑定到`render-view`。现在我们可以创建一个计算属性`post`，它根据`postId`查找帖子：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From this computed `post` property, we can extract `title` and `content` if
    `post` exists (we have to watch out for posts that don''t exist). So, still in
    `SinglePost`, we can add the following computed properties:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个计算后的`post`属性中，我们可以提取`title`和`content`，如果`post`存在的话（我们必须注意那些不存在的帖子）。所以，在`SinglePost`中，我们可以添加以下计算属性：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then replace the placeholders in the template with the value of the
    computed properties. So, our template ends up as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用计算属性的值替换模板中的占位符。因此，我们的模板最终如下所示：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we should make the whole post item a `router-link` that points to
    the right slug in the `PostListItem.vue` file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该在`PostListItem.vue`文件中使整个帖子项成为一个指向正确slug的`router-link`：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`router-link` is a Vue Router-specific link, which means that on the `PostList`
    page, upon clicking on a post list item, we are taken to the correct post''s URL,
    as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`router-link`是Vue Router特定的链接，这意味着在`PostList`页面上，点击帖子列表项时，我们将被带到正确的帖子URL，如下面的截图所示：'
- en: '![Figure 12.18: Post list view displayed in the browser'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18：在浏览器中显示的帖子列表视图'
- en: '](img/B15218_12_18.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_18.jpg)'
- en: 'Figure 12.18: Post list view displayed in the browser'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：在浏览器中显示的帖子列表视图
- en: We'll be redirected to the correct URL, the post's slug, which will render the
    right post by `slug`, as shown in *Figure 12.19*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被重定向到正确的 URL，即文章的缩略语，这将通过 `slug` 渲染正确的文章，如图 *图 12.19* 所示。
- en: '![Figure 12.19: Single post view displaying in the browser'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.19：单篇文章视图在浏览器中显示'
- en: '](img/B15218_12_19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_19.jpg)'
- en: 'Figure 12.19: Single post view displaying in the browser'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19：单篇文章视图在浏览器中显示
- en: To test `vue-router`, we will explore a new library that's better suited to
    testing applications with routing and a Vuex store, the Vue Testing library, which
    is accessible on `npm` as `@testing-library/vue`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `vue-router`，我们将探索一个更适合测试具有路由和 Vuex 存储的应用程序的新库，即 Vue 测试库，该库可在 `npm` 上作为
    `@testing-library/vue` 访问。
- en: We can install it with `npm install --save-dev @testing-library/vue`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npm install --save-dev @testing-library/vue` 来安装它。
- en: 'To test `SinglePost` routing and rendering, we do the following. First of all,
    we should be able to access the `SinglePost` view by clicking on a post title
    in the `PostList` view. In order to do this, we check that we''re on the home
    page by examining the content (we''ll see two posts with the titles). Then we''ll
    click a post title and check that the content from the home page is gone and the
    post content is displayed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `SinglePost` 路由和渲染，我们执行以下操作。首先，我们应该能够通过点击 `PostList` 视图中的文章标题来访问 `SinglePost`
    视图。为了做到这一点，我们通过检查内容（我们将看到两个带有标题的文章）来确认我们处于主页。然后我们点击一个文章标题并检查主页的内容已消失，文章内容已显示：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We should check that navigating directly to a valid post URL will yield the
    correct result. In order to do this, we''ll use `router.replace(''/'')` to clear
    any state that''s set, and then use `router.push()` with a post slug. We will
    then use the assertions from the previous code snippet to validate that we are
    on the `SinglePost` page, not the home page:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该检查直接导航到有效的文章 URL 将产生正确的结果。为了做到这一点，我们将使用 `router.replace('/')` 来清除任何设置的状态，然后使用
    `router.push()` 并带有一个文章缩略语。然后我们将使用前一个代码片段中的断言来验证我们是否在 `SinglePost` 页面，而不是主页：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Those two tests work as expected when run with `npm run test:unit __tests__/SinglePost.test.js`.
    The following screenshot displays the desired output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `npm run test:unit __tests__/SinglePost.test.js` 运行这两个测试时，它们按预期工作。以下截图显示了所需的输出：
- en: '![Figure 12.20: Routing tests passing for SinglePost'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.20：SinglePost 的路由测试通过'
- en: '](img/B15218_12_20.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_20.jpg)'
- en: 'Figure 12.20: Routing tests passing for SinglePost'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.20：SinglePost 的路由测试通过
- en: We have now seen how to use the Vue.js Testing library to test an application
    that uses `vue-router`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Vue.js 测试库来测试一个使用 `vue-router` 的应用程序。
- en: 'Exercise 12.03: Building a Tag Page and Testing Its Routing'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03：构建标签页面并测试其路由
- en: Much like we have built a single-post page, we'll now build a tag page, which
    is similar to the `PostList` component except only posts with a certain tag are
    displayed and each post is a link to a relevant single-post view.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们构建的单篇文章页面类似，我们现在将构建一个标签页面，它与 `PostList` 组件类似，只是只显示具有特定标签的文章，并且每篇文章都是一个链接到相关单篇文章视图的链接。
- en: 'To access the code files for this exercise, refer to [https://packt.live/39cJqZd](https://packt.live/39cJqZd):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/39cJqZd](https://packt.live/39cJqZd)：
- en: 'We can start by creating a new `TagPage` component in `src/components/TagPage.vue`.
    We know it will receive `posts` as a prop and that we will want to render a `PostList`
    component:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从在 `src/components/TagPage.vue` 中创建一个新的 `TagPage` 组件开始。我们知道它将接收 `posts`
    作为属性，并且我们希望渲染一个 `PostList` 组件：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we want to wire the `TagPage` component into the router in `src/router.js`.
    We''ll import it and add it as part of `routes` with the `/tags/:tagName` path:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想在 `src/router.js` 中将 `TagPage` 组件连接到路由器。我们将导入它并将其添加到 `routes` 中，路径为 `/tags/:tagName`：
- en: '[PRE39]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now use `$route.params.tagName` in a computed property and create a
    `tagPosts` computed property that filters posts by tag:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在计算属性中使用 `$route.params.tagName` 并创建一个 `tagPosts` 计算属性，该属性通过标签过滤文章：
- en: '[PRE40]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have access to `tagPosts` and `tagName`, we can replace the placeholders
    in the template. We will render `#{{ tagName }}` and bind `tagPosts` to the `posts`
    prop of `PostList`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了对 `tagPosts` 和 `tagName` 的访问权限，我们可以替换模板中的占位符。我们将渲染 `#{{ tagName }}` 并将
    `tagPosts` 绑定到 `PostList` 的 `posts` 属性：
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, the page displays as follows if we navigate, for example, to `/tags/angularjs`:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们导航到例如 `/tags/angularjs`，页面将显示如下：
- en: '![Figure 12.21: Tag page for angularjs'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.21：angularjs 的标签页面'
- en: '](img/B15218_12_21.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_12_21.jpg)'
- en: 'Figure 12.21: Tag page for angularjs'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 12.21：angularjs 的标签页面
- en: 'The next step is to convert the tag anchors (`a`) in `PostListItem` to `router-link`
    that points to `/tags/${tagName}` (in `src/components/PostListItem.vue`):'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将`PostListItem`中的标签锚点（`a`）转换为指向`/tags/${tagName}`的`router-link`（在`src/components/PostListItem.vue`中）：
- en: '[PRE42]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now it is time to write some tests. We will first check that being on the home
    page and clicking on `#angularjs` puts us on the `angularjs` tag page. We''ll
    write it as follows in `__tests__/TagPage.test.js`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写一些测试了。我们首先检查在主页上点击`#angularjs`会将我们带到`angularjs`标签页。我们将在`__tests__/TagPage.test.js`中如下编写：
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We should also test that going directly to the tag URL works as expected; that
    is, we do not see irrelevant content:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该测试直接访问标签URL是否按预期工作；也就是说，我们看不到不相关的内容：
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The tests pass since the application is working as expected. Therefore, the
    output will be as follows:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试通过，因为应用程序按预期工作。因此，输出将如下所示：
- en: '![Figure 12.22: TagPage routing tests passing on the command line'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.22：TagPage路由测试通过命令行'
- en: '](img/B15218_12_22.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_12_22.jpg)'
- en: 'Figure 12.22: TagPage routing tests passing on the command line'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：TagPage路由测试通过命令行
- en: We've now seen how to implement and test an application that includes `vue-router`.
    In the next section, we will learn about testing Vuex in detail.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何实现和测试一个包含`vue-router`的应用程序。在下一节中，我们将详细了解Vuex的测试。
- en: Testing Vuex
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Vuex
- en: To show how to test a component that relies on Vuex (Vue.js's official global
    state management solution), we'll implement and test a newsletter subscription
    banner.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何测试依赖于Vuex（Vue.js的官方全局状态管理解决方案）的组件，我们将实现并测试新闻通讯订阅横幅。
- en: 'To start with, we should create the banner template. The banner will contain
    a `Subscribe to the newsletter` call to action and a close icon:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该创建横幅模板。横幅将包含一个“订阅新闻通讯”的行动呼吁和一个关闭图标：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can display the `NewsletterBanner` component in the `App.vue` file as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`App.vue`文件中如下显示`NewsletterBanner`组件：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll then install Vuex with the `npm install --save vuex` command. Once Vuex
    is installed, we can initialize our store in a `store.js` file as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`npm install --save vuex`命令安装Vuex。一旦安装了Vuex，我们就可以在`store.js`文件中初始化我们的存储，如下所示：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our Vuex store is also registered in the `main.js` file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Vuex存储也已在`main.js`文件中注册：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to decide whether the newsletter banner should be displayed or not,
    we need to add an initial state to our store:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定是否显示新闻通讯横幅，我们需要在我们的存储中添加一个初始状态：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To close the banner, we need a mutation that will set `dismissedSubscribeBanner`
    to `true`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭横幅，我们需要一个突变，该突变将`dismissedSubscribeBanner`设置为`true`：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can now use the store state and the `dismissSubscribeBanner` mutation to
    decide whether to show the banner (using `v-if`) and whether to close it (binding
    to a click on the `close` button):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用存储状态和`dismissSubscribeBanner`突变来决定是否显示横幅（使用`v-if`）以及是否关闭它（绑定到`close`按钮的点击）：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At this point, the banner looks like this in a browser:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，横幅在浏览器中的样子如下：
- en: '![Figure 12.23: Newsletter banner displayed in a browser'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.23：浏览器中显示的新闻通讯横幅'
- en: '](img/B15218_12_23.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_23.jpg)'
- en: 'Figure 12.23: Newsletter banner displayed in a browser'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：浏览器中显示的新闻通讯横幅
- en: To write unit tests, we will use the Vue Testing library, which provides a facility
    for injecting a Vuex store. We'll need to import the store and the `NewsletterBanner` component.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写单元测试，我们将使用Vue测试库，它提供了一个注入Vuex存储的功能。我们需要导入存储和`NewsletterBanner`组件。
- en: 'We can start with a sanity check that, by default, the newsletter banner is
    displayed:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先进行一个合理性检查，即默认情况下，新闻通讯横幅是显示的：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The next check should be that if the store has `dismissedSubscribeBanner: true`,
    the banner should not be displayed:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个检查应该是，如果存储有`dismissedSubscribeBanner: true`，则横幅不应显示：'
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The final test we''ll write is to make sure that clicking the banner''s close
    button commits a mutation to the store. We can do this by injecting a stub as
    the `dismissSubscribeBanner` mutation and checking that it is called when clicking
    the close button:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的最后一个测试是确保点击横幅的关闭按钮会将突变提交到存储中。我们可以通过将存根作为`dismissSubscribeBanner`突变注入，并检查在点击关闭按钮时是否被调用来实现这一点：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The tests will now pass when run with `npm run test:unit __tests__/NewsletterBanner.test.js`,
    as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`npm run test:unit __tests__/NewsletterBanner.test.js`运行时，测试将通过，如下所示：
- en: '![Figure 12.24: Unit tests for NewsletterBanner passing on the command line'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.24：新闻通讯横幅单元测试通过命令行'
- en: '](img/B15218_12_24.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_12_24.jpg)'
- en: 'Figure 12.24: Unit tests for NewsletterBanner passing on the command line'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：通过命令行执行的NewsletterBanner单元测试
- en: We've now seen how the Vue.js Testing library can be used to test application
    functionality driven by Vuex.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用Vue.js测试库来测试由Vuex驱动的应用程序功能。
- en: 'Exercise 12.04: Building and Testing a Cookie Disclaimer Banner (Vuex)'
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：构建和测试cookie免责声明横幅（Vuex）
- en: We'll now look at how to implement a cookie disclaimer banner using Vuex and
    how to test it with the Vue.js Testing library.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何使用Vuex实现cookie免责声明横幅，以及如何使用Vue.js测试库进行测试。
- en: We will store whether the cookie banner is showing in Vuex (the default is `true`);
    when the banner is closed, we will store it in Vuex.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Vuex中存储cookie横幅是否显示（默认为`true`）；当横幅关闭时，我们将将其存储在Vuex中。
- en: 'Test this opening/closing with a mock Vuex store. To access the code files
    for this exercise, refer to [https://packt.live/36UzksP](https://packt.live/36UzksP):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟Vuex存储来测试此打开/关闭操作。要访问此练习的代码文件，请参阅[https://packt.live/36UzksP](https://packt.live/36UzksP)：
- en: 'Create a green cookie banner with a `Cookies Disclaimer` title in bold, the
    disclaimer, and an `I agree` button. We will create this in `src/components/CookieBanner.vue`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有加粗标题`Cookies Disclaimer`、免责声明和`I agree`按钮的绿色cookie横幅。我们将在`src/components/CookieBanner.vue`中创建此组件：
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we will import, register, and render `CookieBanner` below `router-view`
    in `src/App.vue`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`src/App.vue`中导入、注册并渲染`CookieBanner`组件到`router-view`下方：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a `state` slice to control whether to display the cookie banner. In our
    Vuex store, we will initialize this `acceptedCookie` field as `false`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`state`切片来控制是否显示cookie横幅。在我们的Vuex存储中，我们将初始化此`acceptedCookie`字段为`false`：
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will also need an `acceptCookie` mutation to close the banner:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`acceptCookie`突变来关闭横幅：
- en: '[PRE58]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we will expose store state as an `acceptedCookie` computed property.
    We will create an `acceptCookie` function that triggers the `acceptCookie` mutation:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将暴露存储状态作为`acceptedCookie`计算属性。我们将创建一个`acceptCookie`函数，该函数触发`acceptCookie`突变：
- en: '[PRE59]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will use `v-if` to show the banner when cookies have not been accepted yet.
    The `I agree` button will close the banner when it''s clicked by toggling `acceptCookie`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`v-if`在尚未接受cookie时显示横幅。当点击`I agree`按钮时，通过切换`acceptCookie`来关闭横幅：
- en: '[PRE60]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have now got a cookie banner that shows until `I agree` is clicked, as shown
    in the following screenshot:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经得到了一个cookie横幅，直到点击`I agree`才会显示，如下面的截图所示：
- en: '![Figure 12.25: Cookie banner displayed in the browser'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.25：浏览器中显示的cookie横幅]'
- en: '](img/B15218_12_25.jpg)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_12_25.jpg]'
- en: 'Figure 12.25: Cookie banner displayed in the browser'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.25：浏览器中显示的cookie横幅
- en: 'We will now write a test that checks that the `CookieBanner` component is displayed
    by default:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个测试来检查`CookieBanner`组件是否默认显示：
- en: '[PRE61]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will also write a test to check that if `acceptedCookie` is true in the
    store, the cookie banner won''t be displayed:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将编写一个测试来检查如果存储中的`acceptedCookie`为`true`，则cookie横幅不会显示：
- en: '[PRE62]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we want to check that when the `I agree` button is clicked, the `acceptCookie`
    mutation is triggered:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望检查当点击`I agree`按钮时，会触发`acceptCookie`突变：
- en: '[PRE63]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The three tests we wrote pass when run with `npm run test:unit __tests__/CookieBanner.test.js`,
    as follows:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们使用`npm run test:unit __tests__/CookieBanner.test.js`运行我们编写的三个测试时，它们都会通过，如下所示：
- en: '![Figure 12.26: Tests for the cookie banner passing'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.26：cookie横幅测试通过]'
- en: '](img/B15218_12_26.jpg)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15218_12_26.jpg]'
- en: 'Figure 12.26: Tests for the cookie banner passing'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：cookie横幅测试通过
- en: We've now seen how to test components that rely on Vuex for state and updates.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试依赖于Vuex进行状态和更新的组件。
- en: Next, we'll look at snapshot testing and see how it simplifies the testing of
    render output.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨快照测试，看看它是如何简化渲染输出的测试的。
- en: Snapshot Testing
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照测试
- en: '**Snapshot tests** provide a way to write tests for fast-changing pieces of
    code without keeping the assertion data inline with the test. They store snapshots
    instead.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**快照测试**提供了一种为快速变化的代码片段编写测试的方法，而不需要将断言数据内联到测试中。它们存储快照。'
- en: Changes to a snapshot reflect changes to the output, which is quite useful for
    code reviews.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 快照的更改反映了输出的更改，这对于代码审查非常有用。
- en: 'For example, we can add a snapshot test to the `PostList.test.js` file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在`PostList.test.js`文件中添加一个快照测试：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When we next run this test file, with `npm run test:unit __tests__/PostList.test.js`,
    we will get the following output:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次运行此测试文件时，使用`npm run test:unit __tests__/PostList.test.js`，我们将得到以下输出：
- en: '![Figure 12.27: Snapshot test run for the first time'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.27：第一次运行快照测试]'
- en: '](img/B15218_12_27.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_12_27.jpg)'
- en: 'Figure 12.27: Snapshot test run for the first time'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27：第一次运行快照测试
- en: 'The snapshot was written to `__tests__/__snapshots__/PostList.test.js.snap`,
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 快照已写入`__tests__/__snapshots__/PostList.test.js.snap`，如下所示：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This makes it easy to quickly see what the changes mean in terms of concrete
    output.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们可以快速看到这些更改在具体输出方面的含义。
- en: We've now seen how to use snapshot tests. Next, we'll put all the tools we learned
    in the chapter together to add a new page.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用快照测试。接下来，我们将把本章学到的所有工具结合起来，添加一个新页面。
- en: 'Activity 12.01: Adding a Simple Search by Title Page with Tests'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十二.01：通过测试添加一个简单的按标题搜索页面
- en: We have already built a post list page, a single-post view page, and a posts-by-tag page.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个帖子列表页面、单个帖子视图页面和按标签分类的帖子页面。
- en: 'A great way to resurface old content on a blog is by implementing a good search
    functionality. We will add search to the `PostList` page:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在博客上重新展示旧内容的一个好方法是通过实现良好的搜索功能。我们将向`PostList`页面添加搜索功能：
- en: Create the search form with an input and a button in a new file at `src/components/SearchForm.vue`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件`src/components/SearchForm.vue`中创建一个带有输入和按钮的搜索表单。
- en: We'll now get the form to display by importing, registering, and rendering it
    in `src/App.vue`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过导入、注册并在`src/App.vue`中渲染来使表单显示。
- en: 'We are now able to see the search form in the application, as follows:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在应用程序中看到搜索表单，如下所示：
- en: '![Figure 12.28: The post list view with a search form'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.28：带有搜索表单的帖子列表视图]'
- en: '](img/B15218_12_28.jpg)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_12_28.jpg)'
- en: 'Figure 12.28: The post list view with a search form'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.28：带有搜索表单的帖子列表视图
- en: We're now ready to add a snapshot test for the search form. In `__tests__/SearchForm.test.js`,
    we should add `SearchForm should match expected HTML`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好为搜索表单添加一个快照测试。在`__tests__/SearchForm.test.js`中，我们应该添加`SearchForm should
    match expected HTML`。
- en: We want to track the contents of the search form input using `v-model` to two-way
    bind the `searchTerm` instance variable and the contents of the input.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望使用`v-model`跟踪搜索表单输入的内容，以双向绑定`searchTerm`实例变量和输入内容。
- en: When the search form is submitted, we'll need to update the URL with the right
    parameter. This can be done with `this.$router.push()`. We will store the search
    in a `q` query parameter.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提交搜索表单时，我们需要更新URL以包含正确的参数。这可以通过`this.$router.push()`来完成。我们将把搜索存储在`q`查询参数中。
- en: We will want to reflect the state of the `q` query parameter in the search form
    input. We can do this by reading `q` from `this.$route.query` and setting it as
    the initial value for the `searchTerm` data field in the `SearchForm` component state.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将`q`查询参数的状态反映在搜索表单输入中。我们可以通过从`this.$route.query`中读取`q`并将其设置为`SearchForm`组件状态中`searchTerm`数据字段的初始值来实现这一点。
- en: Next, we'll want to filter the posts passed to `PostList` on the home page.
    We'll use `this.$route.query.q` in a computed property that filters posts by their
    title. This new computed property will then be used instead of `posts` in `src/App.vue`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望过滤主页上传递给`PostList`的帖子。我们将使用`this.$route.query.q`在一个计算属性中过滤帖子标题。这个新的计算属性将替代`src/App.vue`中的`posts`。
- en: Next, we should add a test that changes the search query parameter and check
    that the app shows the right result. To do this, we can import `src/App.vue, src/store.js`
    and `src/router.js`, and render the app with the store and the router. We can
    then update the search field contents by using the fact that the placeholder for
    the field is `Search`. Finally, we can submit the form by clicking the element
    where `test id` is `Search` (which is the `search` button).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该添加一个测试，更改搜索查询参数，并检查应用程序是否显示正确的结果。为此，我们可以导入`src/App.vue`、`src/store.js`和`src/router.js`，并使用存储和路由渲染应用程序。然后，我们可以通过使用字段的占位符为`Search`来更新搜索字段的内容。最后，我们可以通过点击`test
    id`为`Search`（即搜索按钮）的元素来提交表单。
- en: Note
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor405).
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[这个链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor405)找到。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we've looked at different approaches to testing different
    types of Vue.js applications.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了测试不同类型Vue.js应用程序的不同方法。
- en: Testing in general is useful for empirically showing that the system is working.
    Unit tests are the cheapest to build and maintain and should be the base of testing
    functionality. System tests are the next level up in the testing pyramid and allow
    you to gain confidence that the majority of features are working as expected.
    End-to-end tests show that the main flows of the full system work.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，测试对于从经验上证明系统正在正常工作是有用的。单元测试是最容易构建和维护的，应该是测试功能的基础。系统测试是测试金字塔的下一层级，它使你能够对大多数功能按预期工作充满信心。端到端测试表明整个系统的主流程正在正常工作。
- en: We've seen how to unit test components, filters, component methods, and mixins,
    as well as testing through the layers, and testing component output in a black
    box fashion instead of inspecting component internals to test functionality. Using
    the Vue.js Testing library, we have tested advanced functionality, such as routing
    and applications, that leverage Vuex.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何对组件、过滤器、组件方法和混入进行单元测试，以及如何通过层进行测试，以及以黑盒方式测试组件输出而不是检查组件内部以测试功能。使用 Vue.js
    测试库，我们已经测试了利用 Vuex 的高级功能，如路由和应用程序。
- en: Finally, we looked at snapshot testing and saw how it can be an effective way
    to write tests for template-heavy chunks of code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了快照测试，并看到了它如何成为为模板密集型代码块编写测试的有效方式。
- en: In the next chapter, we will look at end-to-end testing techniques that can
    be applied to Vue.js applications.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可以应用于 Vue.js 应用的端到端测试技术。
