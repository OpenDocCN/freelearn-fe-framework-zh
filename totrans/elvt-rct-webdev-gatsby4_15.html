<html><head></head><body>
		<div id="_idContainer073">
			<h1 id="_idParaDest-157"><em class="italic"><a id="_idTextAnchor159"/>Chapter 12</em>: Using Real-Time Data</h1>
			<p>Have you ever ordered food and watched as it made its way closer to your destination without you having to refresh the page? You may have also seen this with package deliveries or ride-hailing apps. All of these make use of <strong class="bold">real-time data</strong>. This is a form of data that is presented as soon as it is acquired. So, in these examples, as soon as the service you are using has the food, package, or car's location, it will relay that information to you. The most common way that convenience sites and messaging applications enable real-time data is by using <strong class="bold">web sockets</strong>.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to web sockets</li>
				<li>Socket.io in action</li>
				<li>Live site visitor count</li>
				<li>Gaining further insights with rooms</li>
			</ul>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have completed <a href="B15983_11_ePub_RK.xhtml#_idTextAnchor152"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating Authenticated Experiences</em>.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor161"/>Introduction to web sockets</h1>
			<p>A web socket is a bi-directional communication channel between a client and a server. Unlike <strong class="bold">REST</strong> requests, the socket connection's channel remains open for the client and the server to push <a id="_idIndexMarker622"/>messages to and from each other whenever they need, instead of closing when a response is received. This kind of communication is commonly associated with low latency, which means it can handle high volumes of data with minimal delay.</p>
			<p>So, how does it work? To start, the client sends an HTTP request to a server, asking it to open a connection. If the server agrees, it will send back a response with a status of 101, indicating that it will be <a id="_idIndexMarker623"/>switching protocols. At this point, the handshake is complete and a <strong class="bold">TCP/IP</strong> connection is left open, allowing messages to pass back and forth between the two devices. This connection will remain open until one of the devices disconnects or loses its connection. </p>
			<p>One of the most popular socket implementations in the JavaScript world is <em class="italic">socket.io</em>, which consists of two parts – a Node.js server and a JavaScript client library. We'll look at socket.io in action by creating a minimal demo in the next section.</p>
			<p class="callout-heading">Quick Tip</p>
			<p class="callout">Note that there are also several other implementations of the <em class="italic">socket.io</em> server and client libraries available in languages other than JavaScript. This may be helpful if you want to combine a socket server (which we will create in this chapter) with more than just your Gatsby site.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>Socket.io in action</h1>
			<p>In this demo, we will make a server that accepts a socket connection. When it receives a message from the client, it will log <a id="_idIndexMarker624"/>it to the console. Let's start by creating the server and then move on to the client:</p>
			<ol>
				<li>Create a folder called <strong class="source-inline">server</strong> in your root directory. </li>
				<li>Open a terminal in the <strong class="source-inline">server</strong> folder and run the following command:<p class="source-code"><strong class="bold">npm init -y</strong></p><p>This will set up an empty npm package in the folder.</p></li>
				<li>In the same terminal, run the following command:<p class="source-code"><strong class="bold">npm i express socket.io</strong></p><p>Here, we are installing the <strong class="source-inline">express</strong> dependency for creating our server and the <strong class="source-inline">socket.io</strong> library.</p></li>
				<li>Create an <strong class="source-inline">app.js</strong> file in the <strong class="source-inline">server</strong> folder and add the following code:<p class="source-code">const PORT = 3000</p><p class="source-code">const express = require("express");</p><p class="source-code">const server = express()</p><p class="source-code">  .listen(PORT, () =&gt; console.log('Listening on</p><p class="source-code">    ${PORT}'));</p><p>This creates a minimal Express server that listens for requests on port <strong class="source-inline">3000</strong>. As we have already <a id="_idIndexMarker625"/>learned, this socket connection is established with an HTTP request, and it requires an HTTP server to do this.</p></li>
				<li>Verify that the server is working by opening a terminal within the <strong class="source-inline">server</strong> folder and running the following command:<p class="source-code"><strong class="bold">node app.js</strong></p><p>If the server starts, you will see <strong class="source-inline">Listening on 3000</strong> printed to the console.</p></li>
				<li>Update the <strong class="source-inline">app.js</strong> file with the following code:<p class="source-code">const PORT = 3000</p><p class="source-code">const express = require("express");</p><p class="source-code">const server = express()</p><p class="source-code">  .listen(PORT, () =&gt; console.log('Listening on</p><p class="source-code">    ${PORT}'));</p><p class="source-code"><strong class="bold">const io = require("socket.io")(server);</strong></p><p class="source-code"><strong class="bold">io.on("connection", (socket) =&gt; {</strong></p><p class="source-code"><strong class="bold">  socket.on("message", (msg) =&gt; {</strong></p><p class="source-code"><strong class="bold">    console.log("message: " + msg);</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code"><strong class="bold">});</strong></p><p>Here, we are passing the server instance into <strong class="source-inline">socket.io</strong> for the client-server handshake. We then <a id="_idIndexMarker626"/>tell our socket server how to handle events from clients. In this instance, if a client socket sends an event of the <strong class="source-inline">message</strong> type, we log it to the console.</p></li>
				<li>Before moving on, we must add a <strong class="bold">CORS</strong> policy for our HTTP and socket configuration. Without this, your <a id="_idIndexMarker627"/>browser will not be able to access the server as the cross-origin policy will be blocked. To do this, open a terminal within the <strong class="source-inline">server</strong> folder and run the following command:<p class="source-code"><strong class="bold">npm i cors</strong></p><p>This installs the <strong class="source-inline">cors</strong> library, which acts as middleware within our Express application to enable CORS.</p></li>
				<li>Now, update your <strong class="source-inline">app.js</strong> file with the following code:<p class="source-code">const PORT = 3000;</p><p class="source-code">const express = require("express");</p><p class="source-code"><strong class="bold">var cors = require("cors");</strong></p><p class="source-code"><strong class="bold">var allowlist = ["http://localhost:8000"];</strong></p><p class="source-code"><strong class="bold">var corsOptions = {</strong></p><p class="source-code"><strong class="bold">  origin: function (origin, callback) {</strong></p><p class="source-code"><strong class="bold">    var originIsAllowlisted =</strong></p><p class="source-code"><strong class="bold">      allowlist.indexOf(origin) !== -1;</strong></p><p class="source-code"><strong class="bold">    callback(null, originIsAllowlisted);</strong></p><p class="source-code"><strong class="bold">  },</strong></p><p class="source-code"><strong class="bold">};</strong></p><p class="source-code">const server = express()</p><p class="source-code">  <strong class="bold">.use(cors(corsOptions))</strong></p><p class="source-code">  .listen(PORT, () =&gt; console.log('Listening on</p><p class="source-code">    ${PORT}'));</p><p class="source-code"><strong class="bold">const io = require("socket.io")(server, {</strong></p><p class="source-code"><strong class="bold">  cors: {</strong></p><p class="source-code"><strong class="bold">    origin: corsOptions.origin,</strong></p><p class="source-code"><strong class="bold">  },</strong></p><p class="source-code"><strong class="bold">});</strong></p><p class="source-code">io.on("connection", (socket) =&gt; {</p><p class="source-code">  socket.on("message", (msg) =&gt; {</p><p class="source-code">    console.log("message: " + msg);</p><p class="source-code">  });</p><p class="source-code">});</p><p>This CORS setup uses an <strong class="source-inline">allowlist</strong> of origins that are allowed to access the server. The middleware checks the origin of any request to ensure that the origin is present in <a id="_idIndexMarker628"/>this list and is therefore allowed. If a request comes from an origin that is not on the list, the cross-origin request will be blocked. In this case, we have added <strong class="source-inline">localhost:8000</strong>, which is the default development port for Gatsby. If this changes or you are hosting the application, this list will need to be updated.</p></li>
				<li>Now that we have set up our socket server, let's interact with it from our Gatsby site by using Gatsby as the socket client. Navigate back to the root of your Gatsby site. Open a terminal here and run the following command:<p class="source-code"><strong class="bold">npm i socket.io-client</strong></p><p>As the name of the library might suggest, this installs the socket.io client library that we will be using to communicate with our web socket server.</p></li>
				<li>Create a new file within your <strong class="source-inline">pages</strong> folder called <strong class="source-inline">socket.js</strong> and add the following code to it:<p class="source-code">import React from "react";</p><p class="source-code"><strong class="bold">import openSocket from "socket.io-client";</strong></p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">export default function SocketDemo() {</p><p class="source-code">  const [socket, setSocket] = React.useState(null);</p><p class="source-code">  const [value, setValue] = React.useState("");</p><p class="source-code">  React.useEffect(() =&gt; {</p><p class="source-code">    const newSocket =</p><p class="source-code">     openSocket("http://localhost:3000");</p><p class="source-code">    setSocket(newSocket);</p><p class="source-code">    return () =&gt; newSocket.close();</p><p class="source-code">  }, [setSocket]);</p><p>The standard setup for this page is the same as any other Gatsby page. We have additionally imported our new <strong class="source-inline">socket.io-client</strong> package. Inside a <strong class="source-inline">useEffect</strong>, we create the <a id="_idIndexMarker629"/>socket connection by using the default export from <strong class="source-inline">socket.io-client</strong> with the server URL string as an argument. In our case, the server port was defined as <strong class="source-inline">3000</strong>, so we added <strong class="source-inline">http://localhost:3000</strong>. This one line of code abstracts all the logic around the client-server handshake, so all you need to focus on is firing the messages you want to send. We then set the socket in our <strong class="source-inline">useState</strong> so that we can use it within the page. It's best to create the socket connection in <strong class="source-inline">useEffect</strong> as we only want this connection to be established once. If the page re-renders, we do not want the socket to reconnect as this would be perceived as a new connection by the server. The <strong class="source-inline">return</strong> statement in our <strong class="source-inline">useEffect</strong> ensures that the socket connection is closed when the component dismounts.</p></li>
				<li>Continue editing <strong class="source-inline">socket.js</strong> and add the following code:<p class="source-code">  const sendMessage = () =&gt; {</p><p class="source-code">    socket &amp;&amp; socket.emit("message", value);</p><p class="source-code">  };  </p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-24</p><p class="source-code">        flex flex-col prose space-y-2 "&gt;</p><p class="source-code">        &lt;h1&gt;Message The Server&lt;/h1&gt;</p><p class="source-code">        &lt;label htmlFor="message"&gt;Your Message:&lt;/label&gt;</p><p class="source-code">        &lt;input</p><p class="source-code">          id="message"</p><p class="source-code">          className="border-blue-700 border-2"</p><p class="source-code">          onChange={(e) =&gt; setValue(e.target.value)}</p><p class="source-code">        /&gt;</p><p class="source-code">        &lt;button onClick={<strong class="bold">sendMessage</strong>} className="btn"&gt;</p><p class="source-code">          Send message</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p>We've set up a simple form here. The input updates the value of the state, which we can then <a id="_idIndexMarker630"/>send to the server by clicking the <strong class="bold">Send message</strong> button. Upon clicking this button, the <strong class="source-inline">sendMessage</strong> function is called, which uses <strong class="source-inline">socket.emit</strong> (if there is a socket available in the state), which emits a message from this client to the server. The first argument is the message type, while the second argument is the body of the message. In this case, we are just sending a string, but you could also send an object with multiple key-value pairs. If you were to send an object, there is no need to <strong class="source-inline">JSON.stringify</strong> it as the library handles all that for you.</p></li>
				<li>Start your Gatsby <a id="_idIndexMarker631"/>development server and ensure your socket server is also running. Navigate to <strong class="source-inline">localhost:8000/socket</strong>, type in a message, and click <strong class="bold">Send message</strong>. With any luck, the contents of your message should now be logged within your server's terminal. Congratulations – you've just sent your first message via sockets! </li>
			</ol>
			<p>Now, let's expand this demo so that the client can receive communication back from the server. As an example, let's make the server return one of three random greetings when it receives a message:</p>
			<ol>
				<li value="1">First, we need to modify how our server handles messages. Modify the socket server's connection configuration with the following code:<p class="source-code">io.on("connection", (socket) =&gt; {</p><p class="source-code">  socket.on("message", (msg) =&gt; {</p><p class="source-code">    console.log("message: " + msg);</p><p class="source-code"><strong class="bold">    socket.emit(</strong></p><p class="source-code"><strong class="bold">      "message",</strong></p><p class="source-code"><strong class="bold">      ["Hi there!", "Hello!",</strong></p><p class="source-code"><strong class="bold">       "Howdy"][Math.floor(Math.random() * 3)]</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code">  });</p><p class="source-code">});</p><p>Now, as well as logging the messages that are received from a client, we emit something back to that same client. In this case, we are choosing a random greeting to send back.</p></li>
				<li>With our Gatsby page, we <a id="_idIndexMarker632"/>need to tell it to expect and handle messages of a certain type. This works like event listeners, so this should feel familiar to you:<p class="source-code">export default function SocketDemo() {</p><p class="source-code">  const [socket, setSocket] = React.useState(null);</p><p class="source-code">  const [value, setValue] = React.useState("");</p><p class="source-code">  <strong class="bold">const [serverMessages, setServerMessages] =</strong></p><p class="source-code"><strong class="bold">  React.useState([]);</strong></p><p class="source-code">  React.useEffect(() =&gt; {</p><p class="source-code">    const newSocket =</p><p class="source-code">      openSocket("http://localhost:3000");</p><p class="source-code">    setSocket(newSocket);</p><p class="source-code">    return () =&gt; newSocket.close();</p><p class="source-code">  }, [setSocket]);</p><p class="source-code"><strong class="bold">  React.useEffect(() =&gt; {</strong></p><p class="source-code"><strong class="bold">    if (socket) {</strong></p><p class="source-code"><strong class="bold">      socket.on("message", (message) =&gt; {</strong></p><p class="source-code"><strong class="bold">        setServerMessages((currentMessages) =&gt;</strong></p><p class="source-code"><strong class="bold">        [...currentMessages, message]);</strong></p><p class="source-code"><strong class="bold">      });</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  }, [socket, setServerMessages]);</strong></p><p class="source-code">  const sendMessage = () =&gt; {</p><p class="source-code">    socket &amp;&amp; socket.emit("message", value);</p><p class="source-code">  };</p><p class="source-code">// render in next step</p><p>Here, we created a new <strong class="source-inline">useState</strong> hook to store the server messages. As we may receive more than one, we set this to an empty array that we can <strong class="source-inline">push</strong> elements to. Then, we <a id="_idIndexMarker633"/>defined a second <strong class="source-inline">useEffect</strong>. If the socket connection has been established, this function listens for messages from the server of the <strong class="source-inline">message</strong> type. If it receives one, it adds the body of the message to the server message list.</p></li>
				<li>Update the render of the <strong class="source-inline">page</strong> component:<p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 </p><p class="source-code">       lg:py-24 flex flex-col prose space-y-2 "&gt;</p><p class="source-code">        &lt;h1&gt;Message The Server&lt;/h1&gt;</p><p class="source-code">        &lt;label htmlFor="message"&gt;Your Message:&lt;/label&gt;</p><p class="source-code">        &lt;input</p><p class="source-code">          id="message"</p><p class="source-code">          className="border-blue-700 border-2"</p><p class="source-code">          onChange={(e) =&gt; setValue(e.target.value)}</p><p class="source-code">        /&gt;</p><p class="source-code">        &lt;button onClick={sendMessage} className="btn"&gt;</p><p class="source-code">          Send message</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code"><strong class="bold">        &lt;label&gt;Server Messages:&lt;/label&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;ul&gt;</strong></p><p class="source-code"><strong class="bold">          {serverMessages.map((message, index) =&gt; (</strong></p><p class="source-code"><strong class="bold">            &lt;li key={index}&gt;{message}&lt;/li&gt;</strong></p><p class="source-code"><strong class="bold">          ))}</strong></p><p class="source-code">        &lt;/ul&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p>Within the render, we can map through the server messages and render them to the screen in a bulleted list.</p></li>
				<li>Start your Gatsby <a id="_idIndexMarker634"/>development server and ensure your socket server is also running. Navigate to <strong class="source-inline">localhost:8000/socket</strong>, type in a message, and click <strong class="bold">Send message</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_12.1_B15983.jpg" alt="Figure 12.1 – Socket demonstration page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – Socket demonstration page</p>
			<p>Your message should be logged within the server's terminal, but additionally, the server should have also <a id="_idIndexMarker635"/>sent a message back. It should be visible underneath the <strong class="bold">Send Message</strong> button. The speed at which this happens can feel crazy. And when the connection is good, it can almost feel like the server message is being triggered by your button press.</p>
			<p>We now have a clear understanding of how socket connections work and we have managed to send messages between the client and the server. Now, let's apply what we have learned and build something useful for our Gatsby site with this technology – a live visitor count in our site footer.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor163"/>Live site visitor count</h1>
			<p>The setup for this will need to be a little different from the previous example since, in the <em class="italic">Socket.io in action</em> section, the socket connection was isolated to a single page. However, our site footer is <a id="_idIndexMarker636"/>not on a single page but every page! An implementation of this that would work well is wrapping the site in some context. By doing this, we would be able to access the count in other parts of the application if we needed to. Let's try this approach together:</p>
			<ol>
				<li value="1">Modify the socket server's connection configuration with the following code:<p class="source-code">io.on("connection", (socket) =&gt; {</p><p class="source-code">  io.emit("count", io.engine.clientsCount);</p><p class="source-code">  socket.on("disconnect", function () {</p><p class="source-code">    io.emit("count", io.engine.clientsCount);</p><p class="source-code">  });</p><p class="source-code">}); </p><p>We've changed this configuration quite a bit, so let's break it down. When a new socket connects to the server, we use <strong class="source-inline">io.emit</strong>. This function sends a message to all the connected clients instead of a single socket. The socket type is <strong class="source-inline">count</strong> and the body contains <strong class="source-inline">io.engine.clientsCount</strong>, which is a count of the number of connected clients. If you use this whenever a new client connects, everyone will know that the count has changed. Then, we have to make sure that the count for clients is updated on disconnect too. For that, we trigger the same <strong class="source-inline">io.emit</strong> when the server has seen a client drop off. </p></li>
				<li>Create a new folder inside <strong class="source-inline">src</strong> called <strong class="source-inline">context</strong> if you don't already have one.</li>
				<li>Create a new file called <strong class="source-inline">stats-context.js</strong> and add the following code:<p class="source-code">import React, { useState, useContext } from "react";</p><p class="source-code">import openSocket from "socket.io-client";</p><p class="source-code">const socket = openSocket("http://localhost:3000");</p><p class="source-code">const StatsContext = React.createContext();</p><p class="source-code">export const StatsProvider = ({ ...props }) =&gt; {</p><p class="source-code">  {/* Code continued in next step */}</p><p class="source-code">};</p><p class="source-code">export const useStats = () =&gt;</p><p class="source-code">  useContext(StatsContext);  </p><p class="source-code">export default StatsContext;</p><p>Here, we are setting up the boilerplate of our stat's context. We create a <strong class="source-inline">useStats</strong> hook to <a id="_idIndexMarker637"/>access the context values that we will be defining in the next step.</p></li>
				<li>Add the following code within <strong class="source-inline">StatsProvider</strong>:<p class="source-code">const [socket, setSocket] = React.useState(null);</p><p class="source-code">  const [liveVisitorCount, setLiveVisitorCount] =</p><p class="source-code">    useState(0);</p><p class="source-code">  React.useEffect(() =&gt; {</p><p class="source-code">    const newSocket =</p><p class="source-code">      openSocket("http://localhost:3000");</p><p class="source-code">    setSocket(newSocket);</p><p class="source-code">    return () =&gt; newSocket.close();</p><p class="source-code">  }, [setSocket]);</p><p class="source-code">  React.useEffect(() =&gt; {</p><p class="source-code">    if (socket) {</p><p class="source-code">      socket.on("count", (count) =&gt; {</p><p class="source-code">        setLiveVisitorCount(count);</p><p class="source-code">      });</p><p class="source-code">    }</p><p class="source-code">  }, [socket, setLiveVisitorCount]);</p><p class="source-code">  return (</p><p class="source-code">    &lt;StatsContext.Provider</p><p class="source-code">      value={{</p><p class="source-code">        liveVisitorCount,</p><p class="source-code">        connected: socket &amp;&amp; socket.connected,</p><p class="source-code">      }}</p><p class="source-code">      {...props}</p><p class="source-code">    /&gt;</p><p class="source-code">  ); </p><p>Within the page level demo, we set up the socket using a <strong class="source-inline">useEffect</strong>. We do the same thing here <a id="_idIndexMarker638"/>to ensure it only happens one time. Then, we create a second <strong class="source-inline">useEffect</strong> that, when connected to the server, will listen for messages of the <strong class="source-inline">count</strong> type. If one is received, it updates the count in state, which will then be available throughout the application via the <strong class="source-inline">useStats</strong> hook.</p></li>
				<li>Update your <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatbsy-ssr.js</strong> files with the following code:<p class="source-code">import React from "react";</p><p class="source-code">import { StatsProvider } from "./src/context/stats-</p><p class="source-code">  context";</p><p class="source-code">export const wrapPageElement = ({ element }) =&gt; {</p><p class="source-code">  return &lt;StatsProvider&gt;{element}&lt;/StatsProvider&gt;;</p><p class="source-code">};</p><p>We want to ensure that the count's context is available throughout the application. By adding <a id="_idIndexMarker639"/>this file to both the <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatsby-ssr.js</strong> files, we can be sure it is accessible everywhere. </p></li>
				<li>Create a <strong class="source-inline">VisitorCountBadge.js</strong> file in <strong class="source-inline">src/components/layout</strong> and add the following code to it:<p class="source-code">import React from "react";</p><p class="source-code">import { useStats } from "../../context/stats-</p><p class="source-code">  context";</p><p class="source-code">const VisitorCountBadge = () =&gt; {</p><p class="source-code">  const { liveVisitorCount, connected } = useStats();</p><p class="source-code">  return (</p><p class="source-code">    &lt;p className={'${connected? "bg-blue-200" :"bg-</p><p class="source-code">     red-200"} px-2 py-1 inline-block rounded'}&gt;</p><p class="source-code">     Visitors: {liveVisitorCount}</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default VisitorCountBadge;</p><p>Here, we are making use of the <strong class="source-inline">useStats</strong> hook to retrieve <strong class="source-inline">liveVistorCount</strong> and the connected status. The color of the badge is dependent on the connection's status – if it is blue, then we are connected to the server; if not, it will be red. Then, we render <strong class="source-inline">liveVistorCount</strong> within this badge so that it is visible to the user.</p><p class="callout-heading">Important Note</p><p class="callout">Here, we are using colors to signify the application state as an example only. Color alone should never be used to signify application state in production as it can leave your application inaccessible to colorblind users. It is better to combine color with another visual indicator, such as text, or at the very least an <strong class="source-inline">aria-label</strong>. </p></li>
				<li>Update your <strong class="source-inline">Footer</strong> component file with the following code:<p class="source-code">import React from "react";</p><p class="source-code"><strong class="bold">import VisitorCountBadge from "./VisitorCountBadge";</strong></p><p class="source-code">const Footer = () =&gt; (</p><p class="source-code">  &lt;footer className="px-2 border-t w-full max-w-5xl</p><p class="source-code">   mx-auto py-4"&gt;</p><p class="source-code">    &lt;div className="flex justify-between w-full"&gt;</p><p class="source-code">      <strong class="bold">&lt;VisitorCountBadge /&gt;</strong></p><p class="source-code">      &lt;div className="flex items-center"&gt;</p><p class="source-code">        &lt;p&gt;Your name here.&lt;/p&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/footer&gt;</p><p class="source-code">);</p><p class="source-code">export default Footer;</p><p>Where you want <a id="_idIndexMarker640"/>to use the badge and how you style it is entirely up to you. But by adding it to the <strong class="source-inline">Footer</strong> component, it will be visible on every page that utilizes our <strong class="source-inline">Layout</strong> component.</p></li>
				<li>Start your Gatsby development server and ensure your socket server is also running. Navigate to <strong class="source-inline">localhost:8000</strong> and you should see the visitor count. If you duplicate your browser tab, the visitor count will rise, while if you close a tab, the count will fall. Finally, if you close the terminal with the socket server running, you should <a id="_idIndexMarker641"/>see the badge change to red, indicating it has lost connection to the server.</li>
			</ol>
			<p>We have now implemented a working current visitor count. Let's build on this feature by using rooms.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor164"/>Gaining further insights with rooms</h1>
			<p>There is one element to socket.io events that we have not talked about yet but could be of great benefit in our application – <strong class="bold">rooms</strong>. Rooms are channels that a socket can <strong class="source-inline">join</strong> and <strong class="source-inline">leave</strong>. The server <a id="_idIndexMarker642"/>can emit messages to a room to broadcast an event to a subset of the clients connected to the server. </p>
			<p>To demonstrate the concept of rooms, we will be breaking down our visitor count into more granular stats. Not only will we display to the user the count of total users on the site, but we will also provide them with the details of how many people are on their current page of the site. Let's get started:</p>
			<ol>
				<li value="1">Update your <strong class="source-inline">server/app.js</strong> file's socket code so that it includes a new event:<p class="source-code">// defined at top of file</p><p class="source-code">const pathToRoom = (path) =&gt; 'Page-${path}';</p><p class="source-code">// defined in socket configuration</p><p class="source-code">socket.on("page-update", ({ currentPage, previousPage</p><p class="source-code">   }) =&gt; {</p><p class="source-code">    if (previousPage) {</p><p class="source-code">      const previousRoom = pathToRoom(previousPage);</p><p class="source-code">      socket.leave(previousRoom);</p><p class="source-code">      io.to(previousRoom).emit(</p><p class="source-code">        "page-count",</p><p class="source-code">        io.sockets.adapter.rooms.get(previousRoom)?.size</p><p class="source-code">      );</p><p class="source-code">    }</p><p class="source-code">    const roomToJoin = pathToRoom(currentPage);</p><p class="source-code">    socket.join(roomToJoin);</p><p class="source-code">    io.to(roomToJoin).emit(</p><p class="source-code">      "page-count",</p><p class="source-code">      io.sockets.adapter.rooms.get(roomToJoin).size</p><p class="source-code">    );</p><p class="source-code">  });</p><p>We now expect clients to send us a new event of the <strong class="source-inline">page-update</strong> type. The body contains a <strong class="source-inline">currentPage</strong> and an optional <strong class="source-inline">previousPage</strong> for the client. We will use <a id="_idIndexMarker643"/>these two pieces of information to make them join the room for their current page and remove them from the room for their previous page. </p><p>We have defined a function called <strong class="source-inline">pathToRoom</strong> that we use to take the path where the user is and turn it into a string that we can use as a room identifier. If the client has sent a previous page, we know that this is not the first page on the site they have visited, so they need to be removed from the <strong class="source-inline">previousPage</strong> room. To do this, we can call the <strong class="source-inline">socket.leave</strong> function with the room identifier as the argument. We can then use <strong class="source-inline">io.to(previousRoom).emit</strong> to emit the new reduced count to users still on that page. After that, we can use <strong class="source-inline">currentPage</strong> to determine the new room that the user should join and emit the new count to users in that room (including the new user). </p><p class="callout-heading">Quick Tip</p><p class="callout"><strong class="source-inline">socket.leave</strong> and <strong class="source-inline">socket.join</strong> are server-side only. Sockets cannot leave and join rooms on the client site.</p></li>
				<li>Update the <strong class="source-inline">disconnect</strong> event with the following code:<p class="source-code">socket.on("disconnect", function () {</p><p class="source-code">    io.emit("count", io.engine.clientsCount);</p><p class="source-code">    for(room of io.sockets.adapter.rooms){</p><p class="source-code">      io.to(room[0]).emit(</p><p class="source-code">        "page-count",</p><p class="source-code">        io.sockets.adapter.rooms.get(room[0])?.size</p><p class="source-code">      );</p><p class="source-code">    };</p><p class="source-code">  });</p><p>When a socket <a id="_idIndexMarker644"/>disconnects, we loop through all open rooms and emit the new number of clients to each of them. </p></li>
				<li>Update your <strong class="source-inline">gatsby-browser.js</strong> and <strong class="source-inline">gatbsy-ssr.js</strong> files with the following code:<p class="source-code">import React from "react";</p><p class="source-code">import { StatsProvider } from "./src/context/stats-</p><p class="source-code">  context";</p><p class="source-code">export const wrapPageElement = ({ element, props }) =&gt; {</p><p class="source-code">  return &lt;StatsProvider</p><p class="source-code">  <strong class="bold">location={props.location}</strong>&gt;{element}&lt;/StatsProvider&gt;;</p><p class="source-code">};</p><p>Here, we are passing in the <strong class="source-inline">location</strong> object that Gatsby provides via props to <strong class="source-inline">StatsProvider</strong>. The <strong class="source-inline">location</strong> object contains a <strong class="source-inline">pathname</strong> variable, which will tell us what path the user is currently at.</p></li>
				<li>Navigate to your <strong class="source-inline">stats-context.js</strong> file and update the <strong class="source-inline">StatsProvider</strong> arguments:<p class="source-code">export const StatsProvider = ({ location, ...props })</p><p class="source-code"> =&gt; {</p><p class="source-code">// Code continued in next step</p><p class="source-code">}</p><p>We will need to <a id="_idIndexMarker645"/>use the location that we are now passing in, so let's de-structure it with props. </p></li>
				<li>Add two new React hooks to the top of <strong class="source-inline">StatsProvider</strong>:<p class="source-code"><strong class="bold">  const [pageVisitorCount, setPageVisitorCount] =</strong></p><p class="source-code"><strong class="bold">    useState(0);</strong></p><p class="source-code"><strong class="bold">  const previousLocation = useRef(null);</strong></p><p>We will need to track the page visitor count in the state. We can do this by using a <strong class="source-inline">useState</strong> hook. We will also need to keep a record of the previous location, which we can do using a <strong class="source-inline">useRef</strong> React hook.</p></li>
				<li>Update <strong class="source-inline">useEffect</strong> that's related to incoming socket events within <strong class="source-inline">StatsProvider</strong>:<p class="source-code">  React.useEffect(() =&gt; {</p><p class="source-code">    if (socket) {</p><p class="source-code">      socket.on("count", (count) =&gt; {</p><p class="source-code">        setLiveVisitorCount(count);</p><p class="source-code">      });</p><p class="source-code">      <strong class="bold">socket.on("page-count", (count) =&gt; {</strong></p><p class="source-code"><strong class="bold">        setPageVisitorCount(count);</strong></p><p class="source-code"><strong class="bold">      });</strong></p><p class="source-code">    }</p><p class="source-code">  }, [socket, setLiveVisitorCount,</p><p class="source-code">   <strong class="bold">setPageVisitorCount</strong>]);</p><p>When the socket <a id="_idIndexMarker646"/>receives a <strong class="source-inline">page-count</strong> event, we update the <strong class="source-inline">pageVisitorCount</strong> value in the state using the <strong class="source-inline">setPageVisitorCount</strong> function.</p></li>
				<li>Create a new <strong class="source-inline">useEffect</strong> inside <strong class="source-inline">StatsProvider</strong>:<p class="source-code">React.useEffect(() =&gt; {</p><p class="source-code">    if (socket &amp;&amp; previousLocation.current !==</p><p class="source-code">      location.pathname) {</p><p class="source-code">      socket.emit("page-update", {</p><p class="source-code">        currentPage: location.pathname,</p><p class="source-code">        previousPage: previousLocation.current,</p><p class="source-code">      });</p><p class="source-code">      previousLocation.current = location.pathname;</p><p class="source-code">    }</p><p class="source-code">  }, [location, socket]);</p><p>Here is one of the most crucial parts of the code. We add the location to the <strong class="source-inline">useEffect</strong> dependency array so that this code runs whenever the user navigates between a page. Within <strong class="source-inline">useEffect</strong>, we check that the socket is available in the state and that the location update does not match the current location. If both conditions are met, we emit a <strong class="source-inline">page-update</strong> to the server, telling it where we have moved to so that it can keep track of the locations.</p></li>
				<li>Update the render of the <strong class="source-inline">StatsProvider.js</strong> file:<p class="source-code">  return (</p><p class="source-code">    &lt;StatsContext.Provider</p><p class="source-code">      value={{</p><p class="source-code">        liveVisitorCount,</p><p class="source-code">        <strong class="bold">pageVisitorCount</strong>,</p><p class="source-code">        connected: socket &amp;&amp; socket.connected,</p><p class="source-code">      }}</p><p class="source-code">      {...props}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p>By including <strong class="source-inline">pageVisitorCount</strong> in the provider's <strong class="source-inline">value</strong> prop, we can access it <a id="_idIndexMarker647"/>via the <strong class="source-inline">useStats</strong> hook in our components.</p></li>
				<li>Update <strong class="source-inline">components/VistorCountBadge.js</strong> with the following code:<p class="source-code">const VisitorCountBadge = () =&gt; {</p><p class="source-code">  const { liveVisitorCount, pageVisitorCount,</p><p class="source-code">   connected } = useStats();</p><p class="source-code">  return (</p><p class="source-code">    &lt;p className={'${connected? "bg-blue-200" :"bg-</p><p class="source-code">     red-200"} px-2 py-1 inline-block rounded'}&gt;</p><p class="source-code">     {pageVisitorCount} of {liveVisitorCount} visitors</p><p class="source-code">     on this page</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p>Here, we are retrieving <strong class="source-inline">pageVisitorCount</strong> from the <strong class="source-inline">useStats</strong> hook and rendering it to the screen so that the user can see the value within the badge.</p></li>
				<li>Start your Gatsby development server and ensure your socket server is also running. Navigate to <strong class="source-inline">localhost:8000</strong>; you should see the visitor and page count. If you duplicate <a id="_idIndexMarker648"/>your browser tab, both numbers should rise, and if you navigate one of these tabs to another page on the site, you should see both tabs' page visitor counts update. </li>
			</ol>
			<p>Now that we have implemented an entire feature using sockets, let's summarize what we have learned.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we learned all about web sockets and how we can use them to utilize real-time data within our Gatsby applications. Then, we implemented a working visitor count that shows the number of people on the current page, as well as the site as a whole. Visitor count statistics is one of a whole host of possible applications for web sockets within a personal site. Perhaps you could take what you have learned here and try and implement article reactions, polls, or even a chat application?</p>
			<p>In the next chapter, we will learn about our final advanced concept – localization. We will learn how we can make our Gatsby site support multiple languages for an international audience.</p>
		</div>
	</body></html>