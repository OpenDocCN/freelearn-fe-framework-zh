<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-34"><a id="_idTextAnchor033"/>2</h1>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Setup and Project Structure Overview</h1>
<p>In the previous chapter, we looked at all the challenges when building a React application and some great solutions that can help us handle them. We also planned out how our application should work and what tools we <span class="No-Break">should use.</span></p>
<p>In this chapter, we will look at the project structure and the setup tools that make a good baseline for <span class="No-Break">our project.</span></p>
<p>We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Next.js <span class="No-Break">application overview</span></li>
<li>TypeScript setup overview <span class="No-Break">and usage</span></li>
<li>ESLint <span class="No-Break">setup overview</span></li>
<li>Prettier <span class="No-Break">setup overview</span></li>
<li>Pre-committing checks <span class="No-Break">setup overview</span></li>
<li>Project <span class="No-Break">structure overview</span></li>
</ul>
<p>By the end of this chapter, we will have a good understanding of the tools we will be using for the project setup and the feature-based project structure to make organizing our code <span class="No-Break">more manageable.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Technical requirements</h1>
<p>Before we get started, we need to set up our project. To be able to develop our project, we will need the following things installed on <span class="No-Break">our computer:</span></p>
<ul>
<li><strong class="bold">Node.js</strong> version 16 or above and <strong class="bold">npm</strong> version 8 <span class="No-Break">or above.</span></li>
</ul>
<p>There are multiple ways to install Node.js and npm. Here is a great article that goes into more <span class="No-Break">detail: </span><a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js"><span class="No-Break">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</span></a><span class="No-Break">.</span></p>
<ul>
<li><strong class="bold">VSCode</strong> (optional) is currently the most popular editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source, has great integration with TypeScript, and we can extend its features via extensions. It can be downloaded <span class="No-Break">from </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
</ul>
<p>The code files for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/React-Application-Architecture-for-Production"><span class="No-Break">https://github.com/PacktPublishing/React-Application-Architecture-for-Production</span></a><span class="No-Break">.</span></p>
<p>The repository can be cloned locally with the <span class="No-Break">following command:</span></p>
<pre class="console">
git clone https://github.com/PacktPublishing/React-Application-Architecture-for-Production.git</pre>
<p>Once the repository has been cloned, we need to install the <span class="No-Break">application’s dependencies:</span></p>
<pre class="console">
npm install</pre>
<p>We also need to provide the <span class="No-Break">environment variables:</span></p>
<pre class="console">
cp .env.example .env</pre>
<p>Once the dependencies have been installed, we need to select the right stage of the code base that matches this chapter. We can do that by executing the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run stage:switch</pre>
<p>This command will prompt us with a list of stages for <span class="No-Break">each chapter:</span></p>
<pre class="console">
? What stage do you want to switch to? (Use arrow
 keys)
❯ chapter-02
  chapter-03
  chapter-03-start
  chapter-04
  chapter-04-start
  chapter-05
  chapter-05-start
(Move up and down to reveal more choices)</pre>
<p>This is the second chapter so we can select the <span class="No-Break"><strong class="source-inline">chapter-02</strong></span><span class="No-Break"> option.</span></p>
<p>Once the chapter has been selected, all files required to follow along with the chapter will appear. To follow along with this chapter, we don’t need to make any changes to the code. We can just use it as a reference to help get a better overview of the <span class="No-Break">code base.</span></p>
<p>For more information about the setup details, check out the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Next.js application overview</h1>
<p>Next.js is a <a id="_idIndexMarker082"/>web framework built on top of React and Node.js, allowing us to build web applications. Because it can run on the server, it can be used as a <span class="No-Break">full-stack framework.</span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Why Next.js?</h2>
<p>Using Next.js has <a id="_idIndexMarker083"/>multiple benefits. We want to use it because of <span class="No-Break">several reasons:</span></p>
<ul>
<li><strong class="bold">Very easy to get started with</strong>: In the early days of React, it was very challenging to start a project. To get a simple page on the screen, we had to deal with many tools such as Webpack, Babel, and others. We still use those tools today, but fortunately, most tooling configuration is hidden from us with an interface to extend the configuration <span class="No-Break">if required.</span></li>
</ul>
<p>Besides the challenges of setting up the project, it is very challenging to maintain all those dependencies over time. Next.js hides all those complexities away from developers and allows them to get started quickly with a <span class="No-Break">new project.</span></p>
<ul>
<li><strong class="bold">Allows multiple rendering strategies</strong>: Being able to use multiple rendering strategies<a id="_idIndexMarker084"/> is probably the main reason why we want to use Next.js, although it comes with other great benefits. First, it allows us to define the behavior of page rendering at the page level, meaning we can define how we want to render each page individually. It also supports multiple rendering strategies, such as <span class="No-Break">the following:</span><ul><li><span class="No-Break">Client-side rendering</span></li><li><span class="No-Break">Server-side rendering</span></li><li>Static <span class="No-Break">site generation</span></li><li>Incremental <span class="No-Break">static regeneration</span></li></ul></li>
</ul>
<p>We will be using different strategies based on the <span class="No-Break">application’s needs.</span></p>
<ul>
<li><strong class="bold">Performance optimizations</strong>: Next.js is built with web performance in mind. It implements performance optimization techniques such as <span class="No-Break">the following:</span><ul><li><span class="No-Break">Code splitting</span></li><li><span class="No-Break">Lazy loading</span></li><li><span class="No-Break">Prefetching</span></li><li><span class="No-Break">Image optimization</span></li></ul></li>
</ul>
<p>That sums up why we want to use Next.js for our application. Now, let’s see what the Next.js application structure <span class="No-Break">looks like.</span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Next.js application structure</h2>
<p>The <a id="_idIndexMarker085"/>easiest way to get started with Next.js is to use the <strong class="source-inline">create-next-app</strong> CLI to generate a <span class="No-Break">new application.</span></p>
<p>Since we have already generated the application as part of the code samples, we do not need to use the CLI, but if we were generating the application from scratch, we would execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npx create-next-app@latest jobs-app --typescript</pre>
<p>By<a id="_idIndexMarker086"/> executing this command, we would generate a new Next.js application with TypeScript configured out of <span class="No-Break">the box.</span></p>
<p>There are a couple of things that are specific to Next.js. Let’s look at the following file and folder structure of a simple <span class="No-Break">Next.js application:</span></p>
<pre class="source-code">
- .next
- public
- src
  - pages
    - _app.tsx
    - index.tsx
- next.config.js
- package.json</pre>
<p>Let’s analyze each file and folder one <span class="No-Break">by one:</span></p>
<ul>
<li><strong class="source-inline">.next</strong>: Contains production-ready files generated by running the <strong class="source-inline">build</strong> command <span class="No-Break">of Next.js.</span></li>
<li><strong class="source-inline">public</strong>: Contains all static assets of <span class="No-Break">the application.</span></li>
<li><strong class="source-inline">src/pages</strong>: This is a special folder in Next.js where all pages defined here become available at corresponding routes. This is possible thanks to the filesystem-based routing system. The <strong class="source-inline">pages</strong> folder can also live in the root of the project, but it is nice to keep everything in the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></li>
<li><strong class="source-inline">src/pages/_app.tsx</strong>: The <strong class="source-inline">_app.tsx</strong> file is a special file that exports a React component that wraps every page when rendered. By wrapping pages with this special component, we can add custom behavior for our application, such as adding any global configurations, providers, styles, layouts, and more to all <span class="No-Break">the pages.</span></li>
<li><strong class="source-inline">src/pages/index.tsx</strong>: This is how we declare pages of the application. This shows <a id="_idIndexMarker087"/>how the root page is defined. We will dive into Next.js-specific routing in the <span class="No-Break">upcoming chapters.</span></li>
<li><strong class="source-inline">next.config.js</strong>: This is where we can extend the default functionalities such as Webpack configuration and other things in a <span class="No-Break">simple way.</span></li>
<li><strong class="source-inline">package.json</strong>: Every Next.js application includes the following <span class="No-Break">npm scripts:</span><ul><li><strong class="source-inline">dev</strong>: Starts a development server <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">localhost:3000</strong></span></li><li><strong class="source-inline">build</strong>: Builds the application <span class="No-Break">for production</span></li><li><strong class="source-inline">start</strong>: Starts the production build <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">localhost:3000</strong></span></li></ul></li>
</ul>
<p>We will cover more on these topics in the following chapters, but for now, this should give us enough information to get started <span class="No-Break">with Next.js.</span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>TypeScript setup overview and usage</h1>
<p>JavaScript is a <a id="_idIndexMarker088"/>dynamically typed programming language, meaning it doesn’t catch any type errors during build time. That’s where TypeScript comes <span class="No-Break">into play.</span></p>
<p>TypeScript is a <a id="_idIndexMarker089"/>programming language that acts as a superset of JavaScript, which allows us to write JavaScript with some behaviors of a statically typed language. This comes in handy as we can catch many potential bugs before they get <span class="No-Break">into production.</span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Why TypeScript?</h2>
<p>TypeScript is especially useful for large applications built by large teams. Code written in TypeScript is much better documented than code written in vanilla JavaScript. By looking at the type definitions, we can figure out how a piece of code is supposed <span class="No-Break">to work.</span></p>
<p>Another reason is that TypeScript makes refactoring much easier because most of the issues can be caught before running <span class="No-Break">the application.</span></p>
<p>TypeScript also<a id="_idIndexMarker090"/> helps us utilize our editor’s IntelliSense, which shows us intelligent code completion, hover information, and signature information, which speeds up <span class="No-Break">our productivity.</span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>TypeScript setup</h2>
<p>Our project already has<a id="_idIndexMarker091"/> TypeScript configured. The TypeScript configuration is defined in the <strong class="source-inline">tsconfig.json</strong> file at the root of the project. It allows us to configure how strict we want it to be based on <span class="No-Break">our needs:</span></p>
<pre class="source-code">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "src"],
  "exclude": ["node_modules"]
}</pre>
<p>We will <a id="_idIndexMarker092"/>not dive too deeply into every configuration property since most of the properties have been auto-generated. However, there is one thing that was <span class="No-Break">also provided:</span></p>
<pre class="source-code">
   "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }</pre>
<p>This will tell the TypeScript compiler that anything imported via <strong class="source-inline">@/*</strong> will refer to the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></p>
<p>Previously, we had to perform messy imports, <span class="No-Break">like so:</span></p>
<pre class="source-code">
import { Component } from '../../../components/component'</pre>
<p>Now, we can import components <span class="No-Break">like so:</span></p>
<pre class="source-code">
import { Component } from '@/components/component'</pre>
<p>No matter how many nested levels we have, we can always import with absolute paths, and we will not be required to change our import statement should we decide to move the consumer file <span class="No-Break">somewhere else.</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Basic TypeScript usage</h2>
<p>Let’s cover some<a id="_idIndexMarker093"/> TypeScript basics so that we are comfortable using it throughout <span class="No-Break">this book.</span></p>
<h3>Primitive types</h3>
<pre class="source-code">
let numberVar: number;
numberVar = 1 // OK
numberVar = "1" // Error
let stringVar: string;
stringVar = "Hi"; // OK
stringVar = false; // Error
let stringVar: string;
stringVar = "Hi"; // OK
stringVar = false; // Error</pre>
<p>As we can<a id="_idIndexMarker094"/> see, we are only allowed to assign values with the <a id="_idIndexMarker095"/>corresponding type. Assigning to any other type except the <strong class="source-inline">any</strong> type, which we will cover in a moment, will cause a <span class="No-Break">TypeScript error.</span></p>
<h3>Any</h3>
<p>The <strong class="source-inline">any</strong> type is <a id="_idIndexMarker096"/>the loosest type in TypeScript and using it will disable<a id="_idIndexMarker097"/> any type checking. We can use it when we want to bypass errors that would usually occur. However, we should only use it as a last resort and try to use other <span class="No-Break">types first:</span></p>
<pre class="source-code">
let anyVar: any;
anyVar = 1; // OK
anyVar = "Hello" // OK
anyVar = true; // OK
numberVar = anyVar; // OK</pre>
<p>As we can see, variables with the <strong class="source-inline">any</strong> type can accept and be assigned to a value of any other type, which makes it <span class="No-Break">very flexible.</span></p>
<h3>Unknown</h3>
<p>Sometimes, we<a id="_idIndexMarker098"/> can’t know upfront which types we will have. This might happen with some dynamic data where we don’t know its type yet. Here, we can use<a id="_idIndexMarker099"/> the <span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break"> type:</span></p>
<pre class="source-code">
let unknownVar: unknown;
unknownVar = 1; // OK
unknownVar = "123" // OK
let unknownVar2: unknown;
unknownVar = unknownVar2; // OK
anyVar = unknownVar2; // OK
numberVar = unknownVar2; // Error
stringVar = unknownVar2; // Error
booleanVar = unknownVar2; // Error</pre>
<p>As we can see, we can assign values of any type to the variable with <strong class="source-inline">unknown</strong> <strong class="source-inline">type</strong>. However, we can only assign values with type <strong class="source-inline">unknown</strong> to the variables with <strong class="source-inline">any</strong> and <span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break"> types.</span></p>
<h3>Arrays</h3>
<p>There are two ways<a id="_idIndexMarker100"/> to define array types<a id="_idIndexMarker101"/> <span class="No-Break">with TypeScript:</span></p>
<pre class="source-code">
type numbers = number[]
type strings = Array&lt;string&gt;</pre>
<h3>Objects</h3>
<p>Object shapes <a id="_idIndexMarker102"/>can <a id="_idIndexMarker103"/>be defined in <span class="No-Break">two ways:</span></p>
<pre class="source-code">
type Person = {
  name: string;
  age: number;
}
interface Person {
  name: string;
  age: number;
}</pre>
<p>The first one is called type alias, while the second is <span class="No-Break">called interface.</span></p>
<p>There are a few differences between type aliases and interfaces, but we won't get into them right now. For any object shape type we define, we can use <span class="No-Break">type aliases.</span></p>
<h3>Unions</h3>
<p>The <a id="_idIndexMarker104"/>basic types <a id="_idIndexMarker105"/>we just mentioned are great, but sometimes, we want to allow a variable to be one of many types. Let’s look at the <span class="No-Break">following example:</span></p>
<pre class="source-code">
type Content = string | number;
let content: Content;
content = 1 // OK
content = "Hi"; // OK
content = false // Error</pre>
<p>As we can see, the <strong class="source-inline">content</strong> variable can now be either <strong class="source-inline">string</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break">.</span></p>
<p>We can also add literal types<a id="_idIndexMarker106"/> in the union, as shown in the <span class="No-Break">following example:</span></p>
<pre class="source-code">
type Color = "red" | "green" | "blue";
let color: Color;
color = "red" // OK
color = "yellow" // Error</pre>
<p>Here, we are <a id="_idIndexMarker107"/>defining colors as strings, but we want to add more constraints so that we can only take one of those three colors. If we try to add anything else, TypeScript will warn us with <span class="No-Break">an error.</span></p>
<h3>Intersections</h3>
<p>Intersection types<a id="_idIndexMarker108"/> allow us to combine the properties of two<a id="_idIndexMarker109"/> different objects into a single type. Consider <span class="No-Break">this example:</span></p>
<pre class="source-code">
type Foo = {
  x: string;
  y: number;
}
type Bar = {
  z: boolean;
}
type FooBar = Foo &amp; Bar;</pre>
<p>The <strong class="source-inline">FooBar</strong> type will now contain the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <span class="No-Break"><strong class="source-inline">z</strong></span><span class="No-Break"> properties.</span></p>
<h3>Generics</h3>
<p>Generics is<a id="_idIndexMarker110"/> a mechanism of creating reusable types by parameterizing <a id="_idIndexMarker111"/>them. They can help us reduce code repetition. Consider the <span class="No-Break">following type:</span></p>
<pre class="source-code">
type Foo = {
  x: number;
}</pre>
<p>Let’s see what happens if we need the same structure but with <strong class="source-inline">x</strong> as <span class="No-Break">a string:</span></p>
<pre class="source-code">
type Foo = {
  x: string;
}</pre>
<p>Here, we can see that there is some code duplication going on. We can simplify this by making it generic so that it accepts the type as <strong class="source-inline">T</strong>. This would be assigned as the type of the <span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
type Foo&lt;T&gt; = {
  x: T;
}
let x: Foo&lt;number&gt;;
let y: Foo&lt;string&gt;;</pre>
<p>Now, we have a nice way to reuse the structure by passing different types to <span class="No-Break">the generic.</span></p>
<p>We can also use generics <span class="No-Break">with functions:</span></p>
<pre class="source-code">
function logger&lt;T&gt;(value: T) {
  console.log(value)
}
logger&lt;number&gt;(1) // OK
logger&lt;string&gt;(1); // Error</pre>
<p>To try <a id="_idIndexMarker112"/>out these snippets and see how different types behave, go to <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a>, copy the snippets, and play around with the types to see how <span class="No-Break">they work.</span></p>
<h3>TypeScript and React</h3>
<p>Every<a id="_idIndexMarker113"/> TypeScript file that uses JSX must have the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">tsx</strong></span><span class="No-Break"> extension.</span></p>
<p>Typing React components is <span class="No-Break">very straightforward:</span></p>
<pre class="source-code">
type InfoProps = {
  name: string;
  age: number
};
const Info = (props: InfoProps) =&gt; {
  return &lt;div&gt;{props.name}-{props.age}&lt;/div&gt;;
};</pre>
<p>These examples are pretty trivial. We will see more practical examples in the upcoming chapters when we start building the application. To learn more about TypeScript, it is recommended to check the <a id="_idIndexMarker114"/>TypeScript handbook at <a href="https://www.typescriptlang.org/docs">https://www.typescriptlang.org/docs</a>, which covers all these topics in much <span class="No-Break">more detail.</span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>ESLint setup overview</h1>
<p><strong class="bold">Linting</strong> is a <a id="_idIndexMarker115"/>process where linters analyze source code and detect any potential issues in the <span class="No-Break">code base.</span></p>
<p>We will be using <strong class="bold">ESLint</strong>, which<a id="_idIndexMarker116"/> is the most popular linting tool for JavaScript. It can be configured with different plugins and rules to adapt the linter to our <span class="No-Break">application’s needs.</span></p>
<p>The ESLint configuration<a id="_idIndexMarker117"/> is defined in the <strong class="source-inline">.eslintrc.js</strong> file at the root of the project. We can add different rules, extend them with different plugins, and override which files to apply the rules to so that they suit our <span class="No-Break">application’s needs.</span></p>
<p>Sometimes, we don’t want to lint every folder and file, so we can tell ESLint to ignore folders and files by defining them in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">eslintignore</strong></span><span class="No-Break"> file.</span></p>
<p>ESLint has great integration with editors and IDEs so that we can see any potential issues in the file while we <span class="No-Break">are coding.</span></p>
<p>To run our linter, we have defined the linting script <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
"lint": "eslint --ext .ts,.tsx ./src",</pre>
<p>By running <strong class="source-inline">npm run lint</strong>, we will lint every <strong class="source-inline">.ts</strong> and <strong class="source-inline">.tsx</strong> file in the <strong class="source-inline">src</strong> directory, and the linter will notify us about any <span class="No-Break">potential issues.</span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Prettier setup overview</h1>
<p><strong class="bold">Prettier</strong> is a great<a id="_idIndexMarker118"/> tool for formatting code. It enforces a consistent coding style across the entire code base. By utilizing the “format on save” feature in our IDE, we can automatically format the code based on the configuration provided in the <strong class="source-inline">.prettierrc</strong> file. It will also give us good feedback when something is wrong with the code. If it doesn’t auto-format, something is wrong with the code and it needs to <span class="No-Break">be fixed.</span></p>
<p>Prettier comes with a<a id="_idIndexMarker119"/> default configuration out of the box. We can override this by creating the <strong class="source-inline">.prettierrc</strong> file and modifying <span class="No-Break">the configuration.</span></p>
<p>Just as with ESLint, sometimes, there are files we do not want to auto-format. We can tell Prettier to ignore files and folders by adding them to the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">prettierignore</strong></span><span class="No-Break"> file.</span></p>
<p>To run Prettier, we have defined a couple of scripts <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
"prettier": "prettier \"**/*.+(json|ts|tsx)\"",
"format:check": "npm run prettier -- --check",
"format:fix": "npm run prettier -- --write",</pre>
<p>As we can<a id="_idIndexMarker120"/> see, we can run <strong class="source-inline">npm run format:check</strong> to just check the formatting without trying to fix it. If we want to fix it, then we can run <strong class="source-inline">npm run format:fix</strong>, which will modify the files that need to <span class="No-Break">be fixed.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Pre-committing checks setup overview</h1>
<p>Having static <a id="_idIndexMarker121"/>code analysis tools such as TypeScript, ESLint, and Prettier is great; we have configured them and can run individual scripts whenever we make some changes to ensure everything is in the <span class="No-Break">best order.</span></p>
<p>However, there are some drawbacks. Developers can forget to run all checks before committing to the repo, which can still bring problematic and inconsistent code <span class="No-Break">to production.</span></p>
<p>Fortunately, there is a solution that can fix this problem: whenever we try to commit to the repository, we want to run all checks in an <span class="No-Break">automated way.</span></p>
<p>This is the flow we want <span class="No-Break">to have:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<img alt="Figure 2.1 – Pre-commit code checking diagram " height="406" src="image/B17297_02_01.jpg" width="968"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Pre-commit code checking diagram</p>
<p>As we can see, whenever we attempt to commit to the repository, the <strong class="source-inline">git pre-commit</strong> hook will run and execute the scripts that will do the checking. If all the checks pass, the changes will be <a id="_idIndexMarker122"/>committed to the repository; otherwise, we will have to fix the issues and <span class="No-Break">try again.</span></p>
<p>To enable this flow, we will use <strong class="source-inline">husky</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">lint-staged</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">husky</strong> is a <a id="_idIndexMarker123"/>tool that allows us to run git hooks. We want to run the pre-commit hook to run the checks before committing <span class="No-Break">our changes.</span></li>
<li><strong class="source-inline">lint-staged</strong> is a <a id="_idIndexMarker124"/>tool that allows us to run those checks only on files that are in the staging area of Git. This improves the speed of code checking since doing that on the entire code base might be <span class="No-Break">too slow.</span></li>
</ul>
<p>We already have these tools installed and configured, but if we didn’t, they could be installed using the <span class="No-Break">following command:</span></p>
<pre class="console">
npm install –-save-dev husky lint-staged</pre>
<p>Then, we would need to enable <span class="No-Break">Git hooks:</span></p>
<pre class="console">
npx husky install</pre>
<p>Then, we would need to create the <span class="No-Break">pre-commit hook:</span></p>
<pre class="console">
npx husky add .husky/pre-commit "npx lint-staged"</pre>
<p>The Husky pre-commit hook will run lint-staged. Then, we would need to define what commands lint-staged should run inside the <span class="No-Break"><strong class="source-inline">lint-staged.config.js</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
module.exports = {
  '*.{ts,tsx}': [
    'npm run lint',
    "bash -c 'npm run types:check'",
    'npm run format:check',
  ],
};</pre>
<p>If we try to commit code that contains any violations, it will fail and stop us from committing <span class="No-Break">the changes.</span></p>
<p>Now that we covered most of our setup, let’s look at the structure of <span class="No-Break">our project.</span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Project structure overview</h1>
<p>As we <a id="_idIndexMarker125"/>already mentioned, React is very flexible when it comes to <span class="No-Break">project structure.</span></p>
<p>Some of the benefits of having a good project structure are <span class="No-Break">as follows:</span></p>
<ul>
<li>Separation <span class="No-Break">of concerns</span></li>
<li><span class="No-Break">Easier refactors</span></li>
<li>Better reasoning about the <span class="No-Break">code base</span></li>
<li>Easier for larger teams to work on the code <span class="No-Break">base simultaneously</span></li>
</ul>
<p>Let’s see what the feature-based project structure <span class="No-Break">looks like.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">We will focus on the <strong class="source-inline">src</strong> folder only since, from now on, most of the code base <span class="No-Break">lives there.</span></p>
<p>Here is the structure of our <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder:</span></p>
<pre class="source-code">
- components // (1)
- config // (2)
- features // (3)
- layouts // (4)
- lib // (5)
- pages // (6)
- providers // (7)
- stores // (8)
- testing // (9)
- types // (10)
- utils // (11)</pre>
<p>Let’s<a id="_idIndexMarker126"/> analyze each of the folders, one <span class="No-Break">by one:</span></p>
<ol>
<li><strong class="source-inline">components</strong>: Contains all shared components that are used across the <span class="No-Break">entire application.</span></li>
<li><strong class="source-inline">config</strong>: Contains the application <span class="No-Break">configuration files.</span></li>
<li><strong class="source-inline">features</strong>: Contains all the feature-based modules. We will analyze this one in more detail in the <span class="No-Break">following section.</span></li>
<li><strong class="source-inline">layouts</strong>: Contains different layouts for <span class="No-Break">the pages.</span></li>
<li><strong class="source-inline">lib</strong>: Contains configurations for different libraries that are used in <span class="No-Break">our application.</span></li>
<li><strong class="source-inline">pages</strong>: Contains the pages of our application. This is where Next.js will look for pages in the <span class="No-Break">filesystem-based routing.</span></li>
<li><strong class="source-inline">providers</strong>: Contains all application providers. For example, if our application uses many different providers for styling, state, and so on, we can combine them here and export a single application provider with which we can wrap our <strong class="source-inline">_app.tsx</strong> to make all the providers available on all <span class="No-Break">the pages.</span></li>
<li><strong class="source-inline">stores</strong>: Contains all global state stores that are used in <span class="No-Break">the application.</span></li>
<li><strong class="source-inline">testing</strong>: Contains test-related mocks, helpers, utilities, <span class="No-Break">and configurations.</span></li>
<li><strong class="source-inline">types</strong>: Contains base TypeScript type definitions that are used across <span class="No-Break">the application.</span></li>
<li><strong class="source-inline">utils</strong>: Contains all shared <span class="No-Break">utility functions.</span></li>
</ol>
<p>There is nothing wrong with grouping files in folders based on their types. However, once the application <a id="_idIndexMarker127"/>starts to grow, it becomes more difficult to reason about and maintain the code base because there are too many files of a <span class="No-Break">single type.</span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Features</h2>
<p>To scale<a id="_idIndexMarker128"/> the application in the easiest and most maintainable way, we want to keep most of the application code inside the <strong class="source-inline">features</strong> folder, which should contain different feature-based things. Every <strong class="source-inline">feature</strong> folder should contain domain-specific code for a given feature. This will allow us to keep functionalities scoped to a feature and not mix its declarations with the shared things. This is much easier to maintain than a flat folder structure with <span class="No-Break">many files.</span></p>
<p>Let’s look at one of our feature folders, which has the <span class="No-Break">following structure:</span></p>
<pre class="source-code">
- api // (1)
- components // (2)
- types // (3)
- index.ts // (4)</pre>
<ol>
<li value="1"><strong class="source-inline">api</strong>: Contains the API request declarations and API hooks related to a specific feature. This makes our API layer and the UI layer separate <span class="No-Break">and reusable.</span></li>
<li><strong class="source-inline">components</strong>: Contains all components that are scoped to a <span class="No-Break">specific feature.</span></li>
<li><strong class="source-inline">types</strong>: This contains the TypeScript type definitions for a <span class="No-Break">specific feature.</span></li>
<li><strong class="source-inline">index.ts</strong>: This is the entry point of every feature. It behaves as the public API of the feature, and it should only export things that should be public for other parts of <span class="No-Break">the application.</span></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">A feature might have other folders, such as <strong class="source-inline">hooks</strong>, <strong class="source-inline">utils</strong>, and others, depending on the needs of the feature. The only required file is the <strong class="source-inline">index.ts</strong> file, which acts as the public API of <span class="No-Break">a feature.</span></p>
<p>Let’s try to visualize the project structure with the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 2.2 – Project structure " height="869" src="image/B17297_02_02.jpg" width="1020"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Project structure</p>
<p>As we can see, most <a id="_idIndexMarker129"/>of our application code will live <span class="No-Break">within features.</span></p>
<p>One more thing we can configure is enforcing developers to import features code via the <strong class="source-inline">index.ts</strong> file, <span class="No-Break">like so:</span></p>
<pre class="source-code">
import {JobsList} from '@/features/jobs'</pre>
<p>We shouldn’t <span class="No-Break">do this:</span></p>
<pre class="source-code">
import {JobsList} from '@/features/jobs/components/jobs-
  list'</pre>
<p>This will<a id="_idIndexMarker130"/> give us a better picture of which dependency is used where and where it comes from. Also, if the feature gets refactored, it doesn’t have to impact any external parts of the application where that component <span class="No-Break">is used.</span></p>
<p>We can constrain our code by having the following ESLint rule in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">eslintrc.js</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
rules: {
<strong class="bold">    'no-restricted-imports': [</strong>
<strong class="bold">      'error',</strong>
<strong class="bold">      {</strong>
<strong class="bold">        patterns: ['@/features/*/*'],</strong>
<strong class="bold">      },</strong>
<strong class="bold">    ],</strong>
<strong class="bold">    'import/no-cycle': 'error',</strong>
      … rest of the eslint rules
}</pre>
<p>The <strong class="source-inline">no-restricted-imports</strong> rule will add constraints to imports from other features by erroring if any violations in the preceding pattern <span class="No-Break">are detected.</span></p>
<p>Things from a feature can only be consumed if they’re exported from the <strong class="source-inline">index.ts</strong> file of that feature. This will force us to explicitly make something in a feature <span class="No-Break">publicly available.</span></p>
<p>If we decide to use features this way, we should also include the <strong class="source-inline">import/no-cycle</strong> rule to prevent cyclic dependencies where Feature A imports things from Feature B and vice versa. If this happens, that means something with the application design is wrong and it needs to <span class="No-Break">be restructured.</span></p>
<p>In this section, we learned what our application structure will look like. Then, we focused on splitting the application by feature, which will allow our code base to scale well if we decide to add <span class="No-Break">more features.</span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Summary</h1>
<p>In this chapter, we learned the basics of our Next.js application setup, which has been configured to work with TypeScript. Then, we learned about absolute imports, which will make it easier to move files around. We also overviewed ESLint and Prettier and made them static code analysis tools so that they can run checks before committing the changes to our repository by using lint-staged <span class="No-Break">and Husky.</span></p>
<p>Finally, we learned what our project structure will look like. We learned that the best way is to group code by features. We also defined an ESLint rule to enforce importing code from a feature in a specific way and prevent cyclic dependencies to make the code base clean and easy to <span class="No-Break">reason about.</span></p>
<p>In the next chapter, we will create the shared components that will act as the baseline for our application’s <span class="No-Break">user interface.</span></p>
</div>
</div></body></html>