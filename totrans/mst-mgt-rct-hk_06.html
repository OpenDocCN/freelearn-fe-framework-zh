<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.1.1">Chapter 4</span></em><span class="koboSpan" id="kobo.2.1">: Sharing Module State with Subscription</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we learned how to use Context for a global state. </span><span class="koboSpan" id="kobo.3.2">As discussed, Context is not designed for the singleton pattern; it's a mechanism for avoiding the singleton pattern and providing different values for different subtrees. </span><span class="koboSpan" id="kobo.3.3">For a singleton-like a global state, using a module state makes more sense because it's a singleton value in memory. </span><span class="koboSpan" id="kobo.3.4">The goal of this chapter is to learn to use a module state with React. </span><span class="koboSpan" id="kobo.3.5">It's a less well-known pattern than Context, but is often used to integrate the existing module state.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.4.1">What Is a Module State?</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.5.1">A strict definition of a module state would be some constants or variables defined in </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">ECMAScript</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">ES</span></strong><span class="koboSpan" id="kobo.9.1">) module scopes. </span><span class="koboSpan" id="kobo.9.2">In this book, we aren't following the strict definition. </span><span class="koboSpan" id="kobo.9.3">You can simply assume that a module state is a variable defined globally or within the scope of a file.</span></p>
			<p><span class="koboSpan" id="kobo.10.1">We'll explore how to use a module state as a global state in React. </span><span class="koboSpan" id="kobo.10.2">In order to use a module state in React components, we use a subscription mechanism.</span></p>
			<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.12.1">Exploring the module state</span></li>
				<li><span class="koboSpan" id="kobo.13.1">Using a module state as a global state in React</span></li>
				<li><span class="koboSpan" id="kobo.14.1">Adding a basic Subscription</span></li>
				<li><span class="koboSpan" id="kobo.15.1">Working with a selector and </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">useSubscription</span></strong></li>
			</ul>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.18.1">You are expected to have a moderate knowledge of React, including React Hooks. </span><span class="koboSpan" id="kobo.18.2">Refer to the official site at </span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.19.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.20.1"> to learn more.</span></p>
			<p><span class="koboSpan" id="kobo.21.1">In some code, we use TypeScript (</span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.22.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.23.1">) and you should have a basic knowledge of this.</span></p>
			<p><span class="koboSpan" id="kobo.24.1">The code in this chapter is available on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04"><span class="koboSpan" id="kobo.25.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_04</span></a></p>
			<p><span class="koboSpan" id="kobo.26.1">To run code snippets, you need a React environment, for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.27.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.28.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.29.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.30.1">).</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.31.1">Exploring the module state</span></h1>
			<p><span class="koboSpan" id="kobo.32.1">The module state is a variable defined at the module level. </span><em class="italic"><span class="koboSpan" id="kobo.33.1">Module</span></em><span class="koboSpan" id="kobo.34.1"> here means an ES module </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.35.1">or just a file. </span><span class="koboSpan" id="kobo.35.2">For simplicity, we assume that a variable defined outside a function is a module state.</span></p>
			<p><span class="koboSpan" id="kobo.36.1">For example, let's define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">count</span></strong><span class="koboSpan" id="kobo.38.1"> state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.39.1">let count = 0;</span></p>
			<p><span class="koboSpan" id="kobo.40.1">Assuming this is defined in a module, this is a module state.</span></p>
			<p><span class="koboSpan" id="kobo.41.1">Typically, with React, we want to have an object state. </span><span class="koboSpan" id="kobo.41.2">The following defines an object state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">count</span></strong><span class="koboSpan" id="kobo.43.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.44.1">let state = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.45.1">  count: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.46.1">};</span></p>
			<p><span class="koboSpan" id="kobo.47.1">More properties can be added to the object. </span><span class="koboSpan" id="kobo.47.2">Nesting objects are also possible.</span></p>
			<p><span class="koboSpan" id="kobo.48.1">Now, let's define functions to access this module state. </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">getState</span></strong><span class="koboSpan" id="kobo.50.1"> is a function to read </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">state</span></strong><span class="koboSpan" id="kobo.52.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">setState</span></strong><span class="koboSpan" id="kobo.54.1"> is a function to write </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">state</span></strong><span class="koboSpan" id="kobo.56.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.57.1">export const getState = () =&gt; state;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.58.1">export const setState = (nextState) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.59.1">  state = nextState;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.60.1">};</span></p>
			<p><span class="koboSpan" id="kobo.61.1">Notice that we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">export</span></strong><span class="koboSpan" id="kobo.63.1"> to these functions to express that they are expected to </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.64.1">be used outside the module.</span></p>
			<p><span class="koboSpan" id="kobo.65.1">In React, we often update a state with functions. </span><span class="koboSpan" id="kobo.65.2">Let's modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">setState</span></strong><span class="koboSpan" id="kobo.67.1"> to allow a </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">function</span></strong><span class="koboSpan" id="kobo.69.1"> update:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.70.1">export const setState = (nextState) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.71.1">  state = typeof nextState === 'function'</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.72.1">    ? </span><span class="koboSpan" id="kobo.72.2">nextState(state) : nextState;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.73.1">};</span></p>
			<p><span class="koboSpan" id="kobo.74.1">You can use a function update as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.75.1">setState((prevState) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.76.1">  ...prevState,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.77.1">  count: prevState.count + 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.78.1">}));</span></p>
			<p><span class="koboSpan" id="kobo.79.1">Instead of defining a module state directly, we can create a function for creating a container that includes </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">state</span></strong><span class="koboSpan" id="kobo.81.1"> and some access functions.</span></p>
			<p><span class="koboSpan" id="kobo.82.1">The following is the concrete implementation of such a function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.83.1">export const createContainer = (initialState) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.84.1">  let state = initialState;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.85.1">  const getState = () =&gt; state;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.86.1">  const setState = (nextState) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.87.1">    state = typeof nextState === 'function'</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.88.1">      ? </span><span class="koboSpan" id="kobo.88.2">nextState(state) : nextState;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.89.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.90.1">  return { getState, setState };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.91.1">};</span></p>
			<p><span class="koboSpan" id="kobo.92.1">You can </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.93.1">use this as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.94.1">import { createContainer } from '...';</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.95.1">const { getState, setState } = createContainer({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.96.1">  count: 0</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.97.1">});</span></p>
			<p><span class="koboSpan" id="kobo.98.1">So far, a module state has nothing to do with React. </span><span class="koboSpan" id="kobo.98.2">In the next section, we'll learn how to use a module state with React.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.99.1">Using a module state as a global state in React</span></h1>
			<p><span class="koboSpan" id="kobo.100.1">As we discussed in </span><a href="B17780_03_Final_VK_ePub.xhtml#_idTextAnchor049"><em class="italic"><span class="koboSpan" id="kobo.101.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.102.1">, </span><em class="italic"><span class="koboSpan" id="kobo.103.1">Sharing Component State with Context</span></em><span class="koboSpan" id="kobo.104.1">, React Context is </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.105.1">designed to provide </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.106.1">different values for different subtrees. </span><span class="koboSpan" id="kobo.106.2">Using React Context for a singleton global state is a valid operation, but it doesn't use the full capability of Context.</span></p>
			<p><span class="koboSpan" id="kobo.107.1">If what you need is a global state for an entire tree, a module state might fit better. </span><span class="koboSpan" id="kobo.107.2">However, to use a module state in a React component, we need to handle re-rendering ourselves.</span></p>
			<p><span class="koboSpan" id="kobo.108.1">Let's start with a simple example. </span><span class="koboSpan" id="kobo.108.2">Unfortunately, this is a non-working example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.109.1">let count = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.110.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.111.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.112.1">    count += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.113.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.114.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.115.1">    &lt;div&gt;{count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.116.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.117.1">};</span></p>
			<p><span class="koboSpan" id="kobo.118.1">You will see </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">count</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.120.1">0</span></strong><span class="koboSpan" id="kobo.121.1"> at the beginning. </span><span class="koboSpan" id="kobo.121.2">Clicking </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">button</span></strong><span class="koboSpan" id="kobo.123.1"> increases the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">count</span></strong><span class="koboSpan" id="kobo.125.1"> variable, but it doesn't trigger the component to re-render.</span></p>
			<p><span class="koboSpan" id="kobo.126.1">At the time </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.127.1">of writing this book, React has </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.128.1">only two hooks, </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">useState</span></strong><span class="koboSpan" id="kobo.130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">useReducer</span></strong><span class="koboSpan" id="kobo.132.1">, to trigger re-renders. </span><span class="koboSpan" id="kobo.132.2">We need to use either of those to make a component reactive with a module state.</span></p>
			<p><span class="koboSpan" id="kobo.133.1">The previous example can work with the following modification:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.134.1">let count = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.135.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.136.1">  const [state, setState] = useState(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.137.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.138.1">    count += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.139.1">    setState(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.140.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.141.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.142.1">    &lt;div&gt;{state} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.143.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.144.1">};</span></p>
			<p><span class="koboSpan" id="kobo.145.1">Now, if you click </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">button</span></strong><span class="koboSpan" id="kobo.147.1">, it will increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">count</span></strong><span class="koboSpan" id="kobo.149.1"> variable, as well as trigger the component.</span></p>
			<p><span class="koboSpan" id="kobo.150.1">Let's see what </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.151.1">happens if we have another </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.152.1">component like the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.153.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.154.1">  const [state, setState] = useState(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.155.1">  const inc2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.156.1">    count += 2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.157.1">    setState(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.158.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.159.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.160.1">    &lt;div&gt;{state} &lt;button onClick={inc2}&gt;+2&lt;/button&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.161.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.162.1">};</span></p>
			<p><span class="koboSpan" id="kobo.163.1">Even if you click </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">button</span></strong><span class="koboSpan" id="kobo.165.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Component1</span></strong><span class="koboSpan" id="kobo.167.1">, it won't trigger </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Component2</span></strong><span class="koboSpan" id="kobo.169.1"> to re-render. </span><span class="koboSpan" id="kobo.169.2">Only when you click </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">button</span></strong><span class="koboSpan" id="kobo.171.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Component2</span></strong><span class="koboSpan" id="kobo.173.1"> will it re-render and show the latest module state. </span><span class="koboSpan" id="kobo.173.2">This is the inconsistency between </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">Component1</span></strong><span class="koboSpan" id="kobo.175.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">Component2</span></strong><span class="koboSpan" id="kobo.177.1">, and our expectation is that both components should show the same value. </span><span class="koboSpan" id="kobo.177.2">The inconsistency also happens with two </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Component1</span></strong><span class="koboSpan" id="kobo.179.1"> components.</span></p>
			<p><span class="koboSpan" id="kobo.180.1">One naive approach to this problem is to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">setState</span></strong><span class="koboSpan" id="kobo.182.1"> functions in </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Component1 </span></strong><span class="koboSpan" id="kobo.184.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Component2</span></strong><span class="koboSpan" id="kobo.186.1"> at the same time. </span><span class="koboSpan" id="kobo.186.2">This requires having </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">setState</span></strong><span class="koboSpan" id="kobo.188.1"> functions at the module level. </span><span class="koboSpan" id="kobo.188.2">We should also consider the component life cycle and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">useEffect</span></strong><span class="koboSpan" id="kobo.190.1"> hook to modify a set that holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">setState</span></strong><span class="koboSpan" id="kobo.192.1"> functions outside React.</span></p>
			<p><span class="koboSpan" id="kobo.193.1">The following example is one possible solution. </span><span class="koboSpan" id="kobo.193.2">This is to illustrate the idea and is not very practical:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.194.1">let count = 0;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.195.1">const setStateFunctions =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.196.1">  new Set&lt;(count: number) =&gt; void&gt;();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.197.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.198.1">  const [state, setState] = useState(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.199.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.200.1">    setStateFunctions.add(setState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.201.1">    return () =&gt; { setStateFunctions.delete(setState); };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.202.1">  }, []);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.203.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.204.1">    count += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.205.1">    setStateFunctions.forEach((fn) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.206.1">      fn(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.207.1">    });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.208.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.209.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.210.1">    &lt;div&gt;{state} &lt;button onClick={inc}&gt;+1&lt;/button&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.211.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.212.1">};</span></p>
			<p><span class="koboSpan" id="kobo.213.1">Notice we return </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.214.1">a function in </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">useEffect</span></strong><span class="koboSpan" id="kobo.216.1"> to clean </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.217.1">up the effect. </span><span class="koboSpan" id="kobo.217.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">inc</span></strong><span class="koboSpan" id="kobo.219.1"> function, we invoke all </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">setState</span></strong><span class="koboSpan" id="kobo.221.1"> functions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">setStateFunctions</span></strong><span class="koboSpan" id="kobo.223.1"> set.</span></p>
			<p><span class="koboSpan" id="kobo.224.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Component2</span></strong><span class="koboSpan" id="kobo.226.1"> will also be modified like </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Component1</span></strong><span class="koboSpan" id="kobo.228.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.229.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.230.1">  const [state, setState] = useState(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.231.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.232.1">    setStateFunctions.add(setState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.233.1">    return () =&gt; { setStateFunctions.delete(setState); };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.234.1">  }, []);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.235.1">  const inc2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.236.1">    count += 2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.237.1">    setStateFunctions.forEach((fn) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.238.1">      fn(count);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.239.1">    });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.240.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.241.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.242.1">    &lt;div&gt;{state} &lt;button onClick={inc2}&gt;+2&lt;/button&gt;&lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.243.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.244.1">};</span></p>
			<p><span class="koboSpan" id="kobo.245.1">As noted, this is </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.246.1">not a very practical solution. </span><span class="koboSpan" id="kobo.246.2">We have </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.247.1">some repetitive code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Component1</span></strong><span class="koboSpan" id="kobo.249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Component2</span></strong><span class="koboSpan" id="kobo.251.1">.</span></p>
			<p><span class="koboSpan" id="kobo.252.1">In the next section, we will introduce a Subscription mechanism and reduce the repetitive code.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.253.1">Adding a basic Subscription</span></h1>
			<p><span class="koboSpan" id="kobo.254.1">Here, we'll learn about </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.255.1">the Subscription mechanism and how to connect a module state to the React state.</span></p>
			<p><span class="koboSpan" id="kobo.256.1">Subscription is a way to get notified of things such as updates. </span><span class="koboSpan" id="kobo.256.2">A typical use of a Subscription would look like the following: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.257.1">const unsubscribe = store.subscribe(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.258.1">  console.log('store is updated');</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.259.1">});</span></p>
			<p><span class="koboSpan" id="kobo.260.1">Here, we assume a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">store</span></strong><span class="koboSpan" id="kobo.262.1"> variable to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">subscribe</span></strong><span class="koboSpan" id="kobo.264.1"> method that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">callback</span></strong><span class="koboSpan" id="kobo.266.1"> function and returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">unsubscribe</span></strong><span class="koboSpan" id="kobo.268.1"> function.</span></p>
			<p><span class="koboSpan" id="kobo.269.1">In this case, the </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.270.1">expected behavior is that whenever </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">store</span></strong><span class="koboSpan" id="kobo.272.1"> is updated, the callback function is invoked and it shows the console log.</span></p>
			<p><span class="koboSpan" id="kobo.273.1">Now, let's implement a module state with a Subscription. </span><span class="koboSpan" id="kobo.273.2">We'll call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">store</span></strong><span class="koboSpan" id="kobo.275.1">, which holds the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">state</span></strong><span class="koboSpan" id="kobo.277.1"> value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">subscribe</span></strong><span class="koboSpan" id="kobo.279.1"> method, in addition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">getState</span></strong><span class="koboSpan" id="kobo.281.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">setState</span></strong><span class="koboSpan" id="kobo.283.1"> methods that we described in the </span><em class="italic"><span class="koboSpan" id="kobo.284.1">Exploring the module state</span></em><span class="koboSpan" id="kobo.285.1"> section. </span><span class="koboSpan" id="kobo.285.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">createStore</span></strong><span class="koboSpan" id="kobo.287.1"> is a function to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">store</span></strong><span class="koboSpan" id="kobo.289.1"> with an initial state value:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.290.1">type Store&lt;T&gt; = {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.291.1">  getState: () =&gt; T;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.292.1">  setState: (action: T | ((prev: T) =&gt; T)) =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.293.1">  subscribe: (callback: () =&gt; void) =&gt; () =&gt; void;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.294.1">};</span></p>
			<p class="source-code"> </p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">const createStore = &lt;T extends unknown&gt;(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.296.1">  initialState: T</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.297.1">): Store&lt;T&gt; =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.298.1">  let state = initialState;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.299.1">  const callbacks = new Set&lt;() =&gt; void&gt;();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.300.1">  const getState = () =&gt; state;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.301.1">  const setState = (nextState: T | ((prev: T) =&gt; T)) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.302.1">    state =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.303.1">      typeof nextState === "function"</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.304.1">        ? </span><span class="koboSpan" id="kobo.304.2">(nextState as (prev: T) =&gt; T)(state)</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.305.1">        : nextState;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.306.1">    callbacks.forEach((callback) =&gt; callback());</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.307.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.308.1">  const subscribe = (callback: () =&gt; void) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.309.1">    callbacks.add(callback);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.310.1">    return () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.311.1">      callbacks.delete(callback);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.312.1">    };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.313.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.314.1">  return { getState, setState, subscribe };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.315.1">}; </span></p>
			<p><span class="koboSpan" id="kobo.316.1">Compared </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.317.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">createContainer</span></strong><span class="koboSpan" id="kobo.319.1"> function that we implemented in the </span><em class="italic"><span class="koboSpan" id="kobo.320.1">Exploring the module state</span></em><span class="koboSpan" id="kobo.321.1"> section, </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">createStore</span></strong><span class="koboSpan" id="kobo.323.1"> has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">subscribe</span></strong><span class="koboSpan" id="kobo.325.1"> method and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">setState</span></strong><span class="koboSpan" id="kobo.327.1"> method, which invokes callbacks.</span></p>
			<p><span class="koboSpan" id="kobo.328.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">createStore</span></strong><span class="koboSpan" id="kobo.330.1"> as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.331.1">import { createStore } from '...';</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.332.1">const store = createStore({ count: 0 });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.333.1">console.log(store.getState());</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.334.1">store.setState({ count: 1 });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.335.1">store.subscribe(...);</span></p>
			<p><span class="koboSpan" id="kobo.336.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">store</span></strong><span class="koboSpan" id="kobo.338.1"> variable holds </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">state</span></strong><span class="koboSpan" id="kobo.340.1"> in it, and the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">store</span></strong><span class="koboSpan" id="kobo.342.1"> variable can be seen as a module state.</span></p>
			<p><span class="koboSpan" id="kobo.343.1">Next up is the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">store</span></strong><span class="koboSpan" id="kobo.345.1"> variable in React.</span></p>
			<p><span class="koboSpan" id="kobo.346.1">We define a new hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">useStore</span></strong><span class="koboSpan" id="kobo.348.1">, which will return a tuple of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">store</span></strong><span class="koboSpan" id="kobo.350.1"> state value and its update function:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.351.1">const useStore = (store) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.352.1">  const [state, setState] = useState(store.getState());</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.353.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">    const unsubscribe = store.subscribe(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">      setState(store.getState());</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.356.1">    });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.357.1">    setState(store.getState()); // [1]</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.358.1">    return unsubscribe;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.359.1">  }, [store]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.360.1">  return [state, store.setState];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.361.1">};</span></p>
			<p><span class="koboSpan" id="kobo.362.1">You may notice </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">[1]</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">This is to cover an edge case. </span><span class="koboSpan" id="kobo.364.3">It invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">setState()</span></strong><span class="koboSpan" id="kobo.366.1"> function </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.367.1">once in </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">useEffect</span></strong><span class="koboSpan" id="kobo.369.1">. </span><span class="koboSpan" id="kobo.369.2">This is due to the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">useEffect</span></strong><span class="koboSpan" id="kobo.371.1"> is delayed and there's a chance that </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">store</span></strong><span class="koboSpan" id="kobo.373.1"> already has a new state.</span></p>
			<p><span class="koboSpan" id="kobo.374.1">The following is a component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">useStore</span></strong><span class="koboSpan" id="kobo.376.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.377.1">const Component1 = () =&gt; {                            </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.378.1">  const [state, setState] = useStore(store);  </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.379.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.380.1">    setState((prev) =&gt; ({                       </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.381.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.382.1">      count: prev.count + 1,                   </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.383.1">    }));                    </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.384.1">  };              </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.385.1">  return (                       </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.386.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.387.1">      {state.count} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.388.1">    &lt;/div&gt;                                 </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.389.1">  );               </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.390.1">};</span></p>
			<p><span class="koboSpan" id="kobo.391.1">It's important to update a module state immutably, the same as the React state, because a </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.392.1">module state is eventually set in the React state:</span></p>
			<p><span class="koboSpan" id="kobo.393.1">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Component1</span></strong><span class="koboSpan" id="kobo.395.1">, we define another one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">Component2</span></strong><span class="koboSpan" id="kobo.397.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.398.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.399.1">  const [state, setState] = useStore(store);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.400.1">  const inc2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.401.1">    setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.402.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.403.1">      count: prev.count + 2,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.404.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.405.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.406.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.407.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.408.1">      {state.count} &lt;button onClick={inc2}&gt;+2&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.409.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.410.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.411.1">};</span></p>
			<p><span class="koboSpan" id="kobo.412.1">Both buttons in the two components will update the module state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">store</span></strong><span class="koboSpan" id="kobo.414.1"> and the states in both components are shared.</span></p>
			<p><span class="koboSpan" id="kobo.415.1">Finally, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">App</span></strong><span class="koboSpan" id="kobo.417.1"> component:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.418.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.419.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.420.1">    &lt;Component1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.421.1">    &lt;Component2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.422.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.423.1">);</span></p>
			<p><span class="koboSpan" id="kobo.424.1">When you run </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.425.1">this app, you will see something like </span><em class="italic"><span class="koboSpan" id="kobo.426.1">Figure 4.1</span></em><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">If you click either the </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">+1</span></strong><span class="koboSpan" id="kobo.429.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">+2</span></strong><span class="koboSpan" id="kobo.431.1"> buttons, you will see that both counts (shown as </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">3</span></strong><span class="koboSpan" id="kobo.433.1">) are updated together:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<span class="koboSpan" id="kobo.434.1"><img src="image/Figure_4.1_B17780.jpg" alt="Figure 4.1 – Screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.435.1">Figure 4.1 – Screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.436.1">In this section, we used a Subscription to connect the module state to a React component.</span></p>
			<p><span class="koboSpan" id="kobo.437.1">In the next section, we will use </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.438.1">a selector function to use only part of the state, as well as learn how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">useSubscription</span></strong><span class="koboSpan" id="kobo.440.1">.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.441.1">Working with a selector and useSubscription </span></h1>
			<p><span class="koboSpan" id="kobo.442.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">useStore</span></strong><span class="koboSpan" id="kobo.444.1"> hook we created in the previous section returns a whole state object. </span><span class="koboSpan" id="kobo.444.2">This means </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.445.1">that any small part of the state object change </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.446.1">will notify all </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">useStore</span></strong><span class="koboSpan" id="kobo.448.1"> hooks and it can cause extra re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.449.1">To avoid extra re-renders, we can introduce a selector to return the only part of the state that a component is interested in.</span></p>
			<p><span class="koboSpan" id="kobo.450.1">Let's first develop </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.452.1">.</span></p>
			<p><span class="koboSpan" id="kobo.453.1">We use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">createStore</span></strong><span class="koboSpan" id="kobo.455.1"> function defined in the previous section and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">store</span></strong><span class="koboSpan" id="kobo.457.1"> variable as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">const store = createStore({ count1: 0, count2: 0 });</span></p>
			<p><span class="koboSpan" id="kobo.459.1">The state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">store</span></strong><span class="koboSpan" id="kobo.461.1"> has two counts – </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">count1</span></strong><span class="koboSpan" id="kobo.463.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">count2</span></strong><span class="koboSpan" id="kobo.465.1">.</span></p>
			<p><span class="koboSpan" id="kobo.466.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.468.1"> hook is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">useStore</span></strong><span class="koboSpan" id="kobo.470.1">, but it receives an additional selector function. </span><span class="koboSpan" id="kobo.470.2">It uses the selector function to scope the state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.471.1">const useStoreSelector = &lt;T, S&gt;(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.472.1">  store: Store&lt;T&gt;,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.473.1">  selector: (state: T) =&gt; S</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.474.1">) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.475.1">  const [state, setState] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.476.1">    useState(() =&gt; selector(store.getState()));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.477.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.478.1">    const unsubscribe = store.subscribe(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.479.1">      setState(selector(store.getState()));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.480.1">    });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.481.1">    setState(selector(store.getState()));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.482.1">    return unsubscribe;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.483.1">  }, [store, selector]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.484.1">  return state;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.485.1">};</span></p>
			<p><span class="koboSpan" id="kobo.486.1">Compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">useStore</span></strong><span class="koboSpan" id="kobo.488.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">useState</span></strong><span class="koboSpan" id="kobo.490.1"> hook in </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.492.1"> holds the return value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">selector</span></strong><span class="koboSpan" id="kobo.494.1"> instead of the entire state.</span></p>
			<p><span class="koboSpan" id="kobo.495.1">Now we define </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.496.1">a component to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.498.1">. </span><span class="koboSpan" id="kobo.498.2">The return </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.499.1">value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.501.1"> is a count number. </span><span class="koboSpan" id="kobo.501.2">To update the state, we invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">store.setState()</span></strong><span class="koboSpan" id="kobo.503.1"> directly in this case. </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Component1</span></strong><span class="koboSpan" id="kobo.505.1"> is a component for displaying </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">count1</span></strong><span class="koboSpan" id="kobo.507.1"> in the state:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.508.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.509.1">  const state = useStoreSelector(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.510.1">    store,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.511.1">    useCallback((state) =&gt; state.count1, []),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.512.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.513.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.514.1">    store.setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.515.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.516.1">      count1: prev.count1 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.517.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.519.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.520.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.521.1">      count1: {state} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.522.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.523.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.524.1">};</span></p>
			<p><span class="koboSpan" id="kobo.525.1">Notice we need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">useCallback</span></strong><span class="koboSpan" id="kobo.527.1"> to get a stable selector function. </span><span class="koboSpan" id="kobo.527.2">Otherwise, as the </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.528.1">selector is specified in the second argument </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.529.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">useEffect</span></strong><span class="koboSpan" id="kobo.531.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Component1</span></strong><span class="koboSpan" id="kobo.533.1"> will subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">store</span></strong><span class="koboSpan" id="kobo.535.1"> variable every time </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">Component1</span></strong><span class="koboSpan" id="kobo.537.1"> renders.</span></p>
			<p><span class="koboSpan" id="kobo.538.1">We define </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Component2</span></strong><span class="koboSpan" id="kobo.540.1">, which is to display </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">count2</span></strong><span class="koboSpan" id="kobo.542.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">count1</span></strong><span class="koboSpan" id="kobo.544.1">. </span><span class="koboSpan" id="kobo.544.2">We define a selector function outside the component to avoid </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">useCallback</span></strong><span class="koboSpan" id="kobo.546.1"> this time:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.547.1">const selectCount2 = (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.548.1">  state: ReturnType&lt;typeof store.getState&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.549.1">) =&gt; state.count2;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.550.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.551.1">  const state = useStoreSelector(store, selectCount2);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.552.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.553.1">    store.setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.554.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.555.1">      count2: prev.count2 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.556.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.557.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.558.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.559.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.560.1">      count2: {state} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.561.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.562.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.563.1">};</span></p>
			<p><span class="koboSpan" id="kobo.564.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">App</span></strong><span class="koboSpan" id="kobo.566.1"> component </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.567.1">renders two components for </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.568.1">each </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Component1</span></strong><span class="koboSpan" id="kobo.570.1"> component and </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Component2</span></strong><span class="koboSpan" id="kobo.572.1"> component for demonstration:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.573.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.574.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.575.1">    &lt;Component1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.576.1">    &lt;Component1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.577.1">    &lt;Component2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.578.1">    &lt;Component2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.579.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.580.1">);</span></p>
			<p><em class="italic"><span class="koboSpan" id="kobo.581.1">Figure 4.2</span></em><span class="koboSpan" id="kobo.582.1"> is a screenshot of the running app:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<span class="koboSpan" id="kobo.583.1"><img src="image/Figure_4.2_B17780.jpg" alt="Figure 4.2 – Screenshot of the running app "/></span>
				</div>
			</div>
			<p class="figure-caption"><span class="koboSpan" id="kobo.584.1">Figure 4.2 – Screenshot of the running app</span></p>
			<p><span class="koboSpan" id="kobo.585.1">The first two lines </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.586.1">in the preceding figure are rendered by </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">Component1</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">If you </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.589.1">click either of the first two </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">+1</span></strong><span class="koboSpan" id="kobo.591.1"> buttons, it will increment </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">count1</span></strong><span class="koboSpan" id="kobo.593.1">, which will trigger </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Component1</span></strong><span class="koboSpan" id="kobo.595.1"> to re-render. </span><span class="koboSpan" id="kobo.595.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Component2</span></strong><span class="koboSpan" id="kobo.597.1"> (the last two lines in </span><em class="italic"><span class="koboSpan" id="kobo.598.1">Figure 4.2</span></em><span class="koboSpan" id="kobo.599.1">) won't re-render because </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">count2</span></strong><span class="koboSpan" id="kobo.601.1"> isn't changed.</span></p>
			<p><span class="koboSpan" id="kobo.602.1">While the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.604.1"> hook works well and is usable in production, there's a caveat when </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">store</span></strong><span class="koboSpan" id="kobo.606.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">selector</span></strong><span class="koboSpan" id="kobo.608.1"> is changed. </span><span class="koboSpan" id="kobo.608.2">Because </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">useEffect</span></strong><span class="koboSpan" id="kobo.610.1"> fires a little later, it will return a stale state value until re-subscribing is done. </span><span class="koboSpan" id="kobo.610.2">We could fix it by ourselves, but it's a little technical.</span></p>
			<p><span class="koboSpan" id="kobo.611.1">Fortunately, the React team provides an official hook for this use case. </span><span class="koboSpan" id="kobo.611.2">It's called </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">use-subscription</span></strong><span class="koboSpan" id="kobo.613.1"> (</span><a href="https://www.npmjs.com/package/use-subscription"><span class="koboSpan" id="kobo.614.1">https://www.npmjs.com/package/use-subscription</span></a><span class="koboSpan" id="kobo.615.1">).</span></p>
			<p><span class="koboSpan" id="kobo.616.1">Let's re-define </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.618.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">useSubscription</span></strong><span class="koboSpan" id="kobo.620.1">. </span><span class="koboSpan" id="kobo.620.2">The code is as simple as the following:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.621.1">const useStoreSelector = (store, selector) =&gt; useSubscription(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.622.1">  useMemo(() =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.623.1">    getCurrentValue: () =&gt; selector(store.getState()),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.624.1">    subscribe: store.subscribe,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.625.1">  }), [store, selector])</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.626.1">);</span></p>
			<p><span class="koboSpan" id="kobo.627.1">The app still works with this change.</span></p>
			<p><span class="koboSpan" id="kobo.628.1">We could avoid </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.629.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">useStoreSelector</span></strong><span class="koboSpan" id="kobo.631.1"> hook and </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.632.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">useSubscription</span></strong><span class="koboSpan" id="kobo.634.1"> directly in </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">Component1</span></strong><span class="koboSpan" id="kobo.636.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.637.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.638.1">  const state = useSubscription(useMemo(() =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.639.1">    getCurrentValue: () =&gt; store.getState().count1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.640.1">    subscribe: store.subscribe,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.641.1">  }), []));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.642.1">  const inc = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.643.1">    store.setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.644.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.645.1">      count1: prev.count1 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.646.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.647.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.648.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.649.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.650.1">      count1: {state} &lt;button onClick={inc}&gt;+1&lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.651.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.652.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.653.1">};</span></p>
			<p><span class="koboSpan" id="kobo.654.1">In this case, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">useMemo</span></strong><span class="koboSpan" id="kobo.656.1"> is </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.657.1">already used, </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">useCallback</span></strong><span class="koboSpan" id="kobo.659.1"> is </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.660.1">not necessary.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.661.1">useSubscription and useSyncExternalStore</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.662.1">In future versions of React, a hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">useSyncExternalStore</span></strong><span class="koboSpan" id="kobo.664.1"> will be included. </span><span class="koboSpan" id="kobo.664.2">This is a successor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">useSubscription</span></strong><span class="koboSpan" id="kobo.666.1">. </span><span class="koboSpan" id="kobo.666.2">Hence, using the module state will become more accessible (</span><a href="https://github.com/reactwg/react-18/discussions/86 "><span class="koboSpan" id="kobo.667.1">https://github.com/reactwg/react-18/discussions/86 </span></a><span class="koboSpan" id="kobo.668.1">).</span></p>
			<p><span class="koboSpan" id="kobo.669.1">In this section, we learned about using selectors to scope state and also the official </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">useSubscription</span></strong><span class="koboSpan" id="kobo.671.1"> hook to have a more concrete solution.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.672.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.673.1">In this chapter, we learned how to create a module state and integrate it in React. </span><span class="koboSpan" id="kobo.673.2">Using what we learned, you can use the module state as a global state in React. </span><span class="koboSpan" id="kobo.673.3">Subscription plays an important role in integration because it allows the re-rendering of components to be triggered when the module state is changed. </span><span class="koboSpan" id="kobo.673.4">In addition to the basic Subscription implementation to use the module state in React, there is an official package. </span><span class="koboSpan" id="kobo.673.5">Both the basic Subscription and the official package work for the production use case.</span></p>
			<p><span class="koboSpan" id="kobo.674.1">In the next chapter, we will learn about the third pattern of implementing a global state, which is a combination of the first pattern and the second pattern.</span></p>
		</div>
	</body></html>