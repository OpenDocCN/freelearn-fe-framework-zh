<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer056">
<h1 class="chapter-number" id="_idParaDest-283"><a id="_idTextAnchor355"/>18</h1>
<h1 id="_idParaDest-284"><a id="_idTextAnchor356"/>Adding Features Guided by Cucumber Tests</h1>
<p>In the last chapter, we studied the basic elements of writing Cucumber tests and how to use Puppeteer to manipulate our UI. But we haven’t yet explored how these techniques fit into the wider development process. In this chapter, we’ll implement a new application feature, but starting the process with Cucumber tests. These will act as acceptance tests that our (imaginary) product owner can use to determine whether the software works as required.</p>
<p class="callout-heading">Acceptance testing</p>
<p class="callout">An <strong class="bold">acceptance test</strong> is a test that a product owner or customer can use to decide whether they accept the delivered software. If it passes, they accept the software. If it fails, the developers must go back and adjust their work.</p>
<p class="callout">We can use the term <strong class="bold">Acceptance-Test-Driven Development (ATDD)</strong> to refer to a testing workflow that the whole team can participate in. Think of it as like TDD but it is done at the wider team level, with the product owner and customer involved in the cycle. Writing BDD tests using Cucumber is one way—but not the only way—that you can bring ATDD to your team.</p>
<p>In this chapter, we’ll use our BDD-style Cucumber tests to act as our acceptance tests.</p>
<p>Imagine that our product owner has seen the great work that we’ve done building <strong class="bold">Spec Logo</strong>. They have noted that the share screen functionality is good, but it could do with an addition: it should give the presenter the option of resetting their state before sharing begins, as shown:</p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 18.1 – The new sharing dialog " height="1241" src="image/Figure_18.01_B18423.jpg" width="1367"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.1 – The new sharing dialog</p>
<p>The product owner has provided us with some Cucumber tests that are currently red for implementation—both the step definitions and the production code.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Adding Cucumber tests for a dialog box</li>
<li>Fixing Cucumber tests by test-driving production code</li>
<li>Avoiding timeouts in test code</li>
</ul>
<p>By the end of the chapter, you’ll have seen more examples of Cucumber tests and how they can be used as part of your team’s workflow. You’ll also have seen how to avoid using specific timeouts within your code.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor357"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter18">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter18</a></p>
<h1 id="_idParaDest-286">A<a id="_idTextAnchor358"/>dding Cucumber tests for a dialog box</h1>
<p>In this<a id="_idIndexMarker1532"/> section, we’ll <a id="_idIndexMarker1533"/>add a new Cucumber test that won’t yet pass.</p>
<p>Let’s start by taking a look at the new feature:</p>
<ol>
<li>Open the <strong class="source-inline">features/sharing.feature</strong> file and take a look at the first feature that you’ve been given. Read through the steps and try to understand what our product owner is describing. The test covers quite a lot of behavior—unlike our unit tests. It tells a complete story:<p class="source-code">Scenario: Presenter chooses to reset current state when sharing</p><p class="source-code">  Given the presenter navigated to the application page</p><p class="source-code">  And the presenter entered the following instructions at the prompt:</p><p class="source-code">    | forward 10 |</p><p class="source-code">    | right 90 |</p><p class="source-code">  And the presenter clicked the button 'startSharing'</p><p class="source-code">  When the presenter clicks the button 'reset'</p><p class="source-code">  And the observer navigates to the presenter's sharing link</p><p class="source-code">  Then the observer should see no lines</p><p class="source-code">  And the presenter should see no lines</p><p class="source-code">  And the observer should see the turtle at x = 0, y = 0, angle = 0</p><p class="source-code">  And the presenter should see the turtle at x = 0, y = 0, angle = 0</p></li>
<li>The<a id="_idIndexMarker1534"/> first <strong class="bold">Given</strong> phrase, <strong class="source-inline">the presenter navigated to the application page</strong>, already works, and you can verify this if you run <strong class="source-inline">npx cucumber-js</strong>.</li>
<li>The next step, <strong class="source-inline">the presenter entered the following instructions at the prompt</strong>, is very similar to a step from the last chapter. We could choose to extract the commonality here, just as we did with the <strong class="source-inline">browseToPageFor</strong> function; however, we’ll wait until our test and implementation <a id="_idIndexMarker1535"/>are complete before <a id="_idIndexMarker1536"/>refactoring. For now, we’ll just duplicate the code. Open <strong class="source-inline">features/support/sharing.steps.js</strong> and add the following step definition at the bottom of the code:<p class="source-code">When(</p><p class="source-code">  "the presenter entered the following instructions at the prompt:",</p><p class="source-code">  async function(dataTable) {</p><p class="source-code">    for (let instruction of dataTable.raw()) {</p><p class="source-code">      await this.getPage("presenter").type(</p><p class="source-code">       "textarea",</p><p class="source-code">       `${instruction}\n`</p><p class="source-code">      );</p><p class="source-code">      await this.getPage(</p><p class="source-code">        "presenter"</p><p class="source-code">      ).waitForTimeout(3500);</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Next up is a <strong class="bold">Given</strong> clause that we have already: <strong class="source-inline">the presenter clicked the button 'startSharing'</strong>. The line that appears after this is the first <strong class="bold">When</strong> clause, which will need to be implemented. Run <strong class="source-inline">npx cucumber-js</strong> and you’ll be given template code for this function. Copy and paste the template code into your<a id="_idIndexMarker1537"/> step <a id="_idIndexMarker1538"/>definition file, as shown in the following code block:<p class="source-code">When(</p><p class="source-code">  "the presenter clicks the button {string}",</p><p class="source-code">  function (string) {</p><p class="source-code">    // Write code here that turns the phrase above</p><p class="source-code">    // into concrete actions</p><p class="source-code">    return "pending";</p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Two When phrases</p>
<p class="callout">This scenario <a id="_idIndexMarker1539"/>has <em class="italic">two</em> <strong class="source-inline">When</strong> phrases, which is unusual. Just as with your unit tests in the <strong class="bold">Act</strong> phase, you generally want just one <strong class="bold">When</strong> phrase. However, since there are two users working together at this point, it makes sense to have a single action for both of them, so we’ll let our product owner off the hook on this occasion.</p>
<ol>
<li value="5">This step definition is very similar to the ones we’ve written before. Fill out the function as shown in the<a id="_idIndexMarker1540"/> following code block. There is a new call to <strong class="source-inline">waitForSelector</strong>. This waits for the button to appear on the page before we continue, which gives the dialog time to render:<p class="source-code">When(</p><p class="source-code">  "the presenter clicks the button {string}",</p><p class="source-code">  <strong class="bold">async </strong>function (</p><p class="source-code">  <strong class="bold">  buttonId</strong></p><p class="source-code">  ) {</p><p class="source-code"><strong class="bold">    await this.getPage(</strong></p><p class="source-code"><strong class="bold">      "presenter"</strong></p><p class="source-code"><strong class="bold">    ).waitForSelector(`button#${buttonId}`);</strong></p><p class="source-code"><strong class="bold">    await this.getPage(</strong></p><p class="source-code"><strong class="bold">      "presenter"</strong></p><p class="source-code"><strong class="bold">    ).click(`button#${buttonId}`);</strong></p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>The second <strong class="bold">When</strong> clause <a id="_idIndexMarker1541"/>already has a definition<a id="_idIndexMarker1542"/> from our previous test, so we move on to the <strong class="source-inline">Then</strong> clauses. The first is <strong class="source-inline">the observer should see no lines</strong>; run <strong class="source-inline">npx cucumber-js</strong> and copy and paste the template function that Cucumber provides, as shown in the following code block:<p class="source-code">Then("the observer should see no lines", function () {</p><p class="source-code">  // Write code here that turns the phrase above</p><p class="source-code">  // into concrete actions</p><p class="source-code">  return "pending";</p><p class="source-code">});</p></li>
<li>For this step, we want to assert that there are no line elements on the page:<p class="source-code">Then(</p><p class="source-code">  "the observer should see no lines",</p><p class="source-code">  <strong class="bold">async</strong> function () {</p><p class="source-code"><strong class="bold">    const numLines = await this.getPage(</strong></p><p class="source-code"><strong class="bold">      "observer"</strong></p><p class="source-code"><strong class="bold">    ).$$eval("line", lines =&gt; lines.length);</strong></p><p class="source-code"><strong class="bold">    expect(numLines).toEqual(0);</strong></p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Running <strong class="source-inline">npx cucumber-js</strong>, you should see that this step passes, and the next one is<a id="_idIndexMarker1543"/> very<a id="_idIndexMarker1544"/> similar. Copy the step definition you just wrote and modify it to work for the presenter, as shown in the following code block. Again, we can clean up the duplication later:<p class="source-code">Then(</p><p class="source-code">  "the presenter should see no lines",</p><p class="source-code">  async function () {</p><p class="source-code">    const numLines = await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).$$eval("line", lines =&gt; lines.length);</p><p class="source-code">    expect(numLines).toEqual(0);</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Run Cucumber now, and you’ll see that this step fails; this is the first failure that we’ve got. It points to the specific change that we’ll need to make in the code base:<p class="source-code">✖ And the presenter should see no lines</p><p class="source-code">   Error: expect(received).toEqual(expected)</p><p class="source-code">   Expected value to equal:</p><p class="source-code">   0</p><p class="source-code">   Received:</p><p class="source-code">   1</p></li>
<li>Since we have hit a red step, we could now go back and start working on our code to make this green. However, because we just have two almost identical clauses to complete, I’m going to choose to complete these definitions before continuing. Cucumber tells <a id="_idIndexMarker1545"/>us the template function <a id="_idIndexMarker1546"/>that we should use, so add that now, as follows:<p class="source-code">Then(</p><p class="source-code">  "the observer should see the turtle at x = {int}, y = {int}, angle = {int}",</p><p class="source-code">  function (int, int2, int3) {</p><p class="source-code">    // Write code here that turns the phrase above</p><p class="source-code">    // into concrete actions</p><p class="source-code">    return "pending";</p><p class="source-code">});</p></li>
<li>We need to define a couple of helpers that can tell us the current <em class="italic">x</em>, <em class="italic">y</em>, and angle values of the turtle. We need this because all we have<a id="_idIndexMarker1547"/> is the SVG <strong class="source-inline">polygon</strong> element, which uses a <strong class="source-inline">points</strong> string and a <strong class="source-inline">transform</strong> string to position the turtle. Our helpers will take these strings and convert them back to numbers for us. As a reminder, here’s how the turtle is initially positioned:<p class="source-code">&lt;polygon</p><p class="source-code">  points="-5,5, 0,-7, 5,5"</p><p class="source-code">  fill="green"</p><p class="source-code">  stroke-width="2"</p><p class="source-code">  stroke="black"</p><p class="source-code">  transform="rotate(90, 0, 0)" /&gt;</p></li>
</ol>
<p>We can use the first <strong class="source-inline">points</strong> coordinate to calculate <em class="italic">x</em> and <em class="italic">y</em>, by adding <strong class="source-inline">5</strong> to the first number and subtracting <strong class="source-inline">5</strong> from the second. The angle can be calculated by taking the <a id="_idIndexMarker1548"/>first<a id="_idIndexMarker1549"/> parameter to rotate and subtracting <strong class="source-inline">90</strong>. Create a new file named <strong class="source-inline">features/support/turtle.js</strong>, and then add the following two definitions:</p>
<p class="source-code">export const calculateTurtleXYFromPoints = points =&gt; {</p>
<p class="source-code">  const firstComma = points.indexOf(",");</p>
<p class="source-code">  const secondComma = points.indexOf(</p>
<p class="source-code">    ",",</p>
<p class="source-code">    firstComma + 1</p>
<p class="source-code">  );</p>
<p class="source-code">  return {</p>
<p class="source-code">    x:</p>
<p class="source-code">      parseFloat(</p>
<p class="source-code">        points.substring(0, firstComma)</p>
<p class="source-code">      ) + 5,</p>
<p class="source-code">    y:</p>
<p class="source-code">      parseFloat(</p>
<p class="source-code">        points.substring(firstComma + 1, secondComma)</p>
<p class="source-code">      ) - 5</p>
<p class="source-code">  };</p>
<p class="source-code">};</p>
<p class="source-code">export const calculateTurtleAngleFromTransform = (</p>
<p class="source-code">  transform </p>
<p class="source-code">) =&gt; {</p>
<p class="source-code">  const firstParen = transform.indexOf("(");</p>
<p class="source-code">  const firstComma = transform.indexOf(",");</p>
<p class="source-code">  return (</p>
<p class="source-code">    parseFloat(</p>
<p class="source-code">      transform.substring(</p>
<p class="source-code">        firstParen + 1, </p>
<p class="source-code">        firstComma</p>
<p class="source-code">      )</p>
<p class="source-code">    ) - 90</p>
<p class="source-code">  );</p>
<p class="source-code">}</p>
<ol>
<li value="12">In <strong class="source-inline">feature/sharing.steps.js</strong>, update<a id="_idIndexMarker1550"/> the step<a id="_idIndexMarker1551"/> definition, as shown in the following code block:<p class="source-code">Then(</p><p class="source-code">  "the observer should see the turtle at x = {int}, y = {int}, angle = {int}",</p><p class="source-code">  <strong class="bold">async</strong> function (</p><p class="source-code"><strong class="bold">    expectedX, expectedY, expectedAngle</strong></p><p class="source-code">  ) {</p><p class="source-code"><strong class="bold">    await this.getPage(</strong></p><p class="source-code"><strong class="bold">      "observer"</strong></p><p class="source-code"><strong class="bold">    ).waitForTimeout(4000);</strong></p><p class="source-code"><strong class="bold">    const turtle = await this.getPage(</strong></p><p class="source-code"><strong class="bold">      "observer"</strong></p><p class="source-code"><strong class="bold">    ).$eval(</strong></p><p class="source-code"><strong class="bold">      "polygon",</strong></p><p class="source-code"><strong class="bold">      polygon =&gt; ({</strong></p><p class="source-code"><strong class="bold">        points: polygon.getAttribute("points"),</strong></p><p class="source-code"><strong class="bold">        transform: polygon.getAttribute("transform")</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code"><strong class="bold">    const position = calculateTurtleXYFromPoints(</strong></p><p class="source-code"><strong class="bold">      turtle.points</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code"><strong class="bold">    const angle = calculateTurtleAngleFromTransform(</strong></p><p class="source-code"><strong class="bold">      turtle.transform</strong></p><p class="source-code"><strong class="bold">    );</strong></p><p class="source-code"><strong class="bold">    expect(position.x).toBeCloseTo(expectedX);</strong></p><p class="source-code"><strong class="bold">    expect(position.y).toBeCloseTo(expectedY);</strong></p><p class="source-code"><strong class="bold">    expect(angle).toBeCloseTo(expectedAngle);</strong></p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Finally, repeat <a id="_idIndexMarker1552"/>this step definition for the<a id="_idIndexMarker1553"/> presenter, as follows:<p class="source-code">Then(</p><p class="source-code">  "the presenter should see the turtle at x = {int}, y = {int}, angle = {int}",</p><p class="source-code">  async function (</p><p class="source-code">    expectedX, expectedY, expectedAngle</p><p class="source-code">  ) {</p><p class="source-code">    await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).waitForTimeout(4000);</p><p class="source-code">    const turtle = await this.getPage(</p><p class="source-code">      "presenter"</p><p class="source-code">    ).$eval(</p><p class="source-code">      "polygon",</p><p class="source-code">      polygon =&gt; ({</p><p class="source-code">        points: polygon.getAttribute("points"),</p><p class="source-code">        transform: polygon.getAttribute("transform")</p><p class="source-code">      })</p><p class="source-code">    );</p><p class="source-code">    const position = calculateTurtleXYFromPoints(   </p><p class="source-code">      turtle.points</p><p class="source-code">    );</p><p class="source-code">    const angle = calculateTurtleAngleFromTransform(</p><p class="source-code">      turtle.transform</p><p class="source-code">    );</p><p class="source-code">    expect(position.x).toBeCloseTo(expectedX);</p><p class="source-code">    expect(position.y).toBeCloseTo(expectedY);</p><p class="source-code">    expect(angle).toBeCloseTo(expectedAngle);</p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p>That’s the first test; now, let’s move on to the second scenario:</p>
<ol>
<li value="1">Nearly all of the step definitions for our second scenario are already implemented; there <a id="_idIndexMarker1554"/>are only two that <a id="_idIndexMarker1555"/>aren’t:<p class="source-code">  Then these lines should have been drawn for the observer:</p><p class="source-code">    | x1 | y1 | x2 | y2 |</p><p class="source-code">    | 0 | 0 | 10 | 0 |</p><p class="source-code">  And these lines should have been drawn for the presenter:</p><p class="source-code">    | x1 | y1 | x2 | y2 |</p><p class="source-code">    | 0 | 0 | 10 | 0 |</p></li>
</ol>
<p>We already have a step definition that is very similar to these two in <strong class="source-inline">features/support/drawing.steps.js</strong>. Let’s extract that logic into its own module so that we can reuse it. Create a new file named <strong class="source-inline">features/support/svg.js</strong> and then duplicate the following code from the drawing step definitions:</p>
<p class="source-code">import expect from "expect";</p>
<p class="source-code">export const checkLinesFromDataTable = page =&gt;</p>
<p class="source-code">  return async function (dataTable) {</p>
<p class="source-code">    await this.getPage(page).waitForTimeout(2000);</p>
<p class="source-code">    const lines = await this.getPage(page).$$eval(</p>
<p class="source-code">      "line",</p>
<p class="source-code">      lines =&gt;</p>
<p class="source-code">        lines.map(line =&gt; ({</p>
<p class="source-code">          x1: parseFloat(line.getAttribute("x1")),</p>
<p class="source-code">          y1: parseFloat(line.getAttribute("y1")),</p>
<p class="source-code">          x2: parseFloat(line.getAttribute("x2")),</p>
<p class="source-code">          y2: parseFloat(line.getAttribute("y2"))</p>
<p class="source-code">        }))</p>
<p class="source-code">    );</p>
<p class="source-code">    for (let i = 0; i &lt; lines.length; ++i) {</p>
<p class="source-code">      expect(lines[i].x1).toBeCloseTo(</p>
<p class="source-code">        parseInt(dataTable.hashes()[i].x1)</p>
<p class="source-code">      );</p>
<p class="source-code">      expect(lines[i].y1).toBeCloseTo(</p>
<p class="source-code">        parseInt(dataTable.hashes()[i].y1)</p>
<p class="source-code">      );</p>
<p class="source-code">      expect(lines[i].x2).toBeCloseTo(</p>
<p class="source-code">        parseInt(dataTable.hashes()[i].x2)</p>
<p class="source-code">      );</p>
<p class="source-code">      expect(lines[i].y2).toBeCloseTo(</p>
<p class="source-code">        parseInt(dataTable.hashes()[i].y2)</p>
<p class="source-code">      );</p>
<p class="source-code">    }</p>
<p class="source-code">  };</p>
<ol>
<li value="2">In <strong class="source-inline">features/support/drawing.steps.js</strong>, modify the <strong class="source-inline">these lines should have been drawn</strong> step definition so that it now uses this function:<p class="source-code">import { checkLinesFromDataTable } from "./svg";</p><p class="source-code">Then(</p><p class="source-code">  "these lines should have been drawn:",</p><p class="source-code">  checkLinesFromDataTable("user")</p><p class="source-code">);</p></li>
<li>The two new step definitions for our latest sharing scenario are now straightforward. In <strong class="source-inline">features/support/sharing.steps.js</strong>, add the following <strong class="source-inline">import</strong> statement<a id="_idIndexMarker1556"/> and step <a id="_idIndexMarker1557"/>definitions:<p class="source-code">import { checkLinesFromDataTable } from "./svg";</p><p class="source-code">Then(</p><p class="source-code">  "these lines should have been drawn for the presenter:",</p><p class="source-code">  checkLinesFromDataTable("presenter")</p><p class="source-code">);</p><p class="source-code">Then(</p><p class="source-code">  "these lines should have been drawn for the observer:",</p><p class="source-code">  checkLinesFromDataTable("observer")</p><p class="source-code">);</p></li>
</ol>
<p>You’ve now seen how to write longer step definitions and how to extract common functionality into support functions.</p>
<p>With the step definitions complete, it’s time to make bo<a id="_idTextAnchor359"/>th these scenarios pass.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor360"/>Fixing Cucumber tests by test-driving production code</h1>
<p>In this<a id="_idIndexMarker1558"/> section, we’ll start by doing a little up-front design, then we’ll write unit tests that cover the same functionality as the Cucumber tests, and then use those to build out the new implementation.</p>
<p>Let’s do a little up-front design:</p>
<ul>
<li>When the user clicks on <strong class="bold">Start sharing</strong>, a dialog should appear with a <strong class="bold">Reset</strong> button.</li>
<li>If the user chooses to reset, the Redux store is sent a <strong class="source-inline">START_SHARING</strong> action with a new <strong class="source-inline">reset</strong> property that is set to <strong class="source-inline">true</strong>:<p class="source-code">{ type: "START_SHARING", reset: true }</p></li>
<li>If the user chooses to share their existing commands, then the <strong class="source-inline">START_SHARING</strong> action is sent with <strong class="source-inline">reset</strong> set to <strong class="source-inline">false</strong>:<p class="source-code">{ type: "START_SHARING", reset: false }</p></li>
<li>When the user clicks on <strong class="bold">Reset</strong>, a <strong class="source-inline">RESET</strong> action should be sent to the Redux store.</li>
<li>Sharing should not be initiated until <em class="italic">after</em> the <strong class="source-inline">RESET</strong> action has occurred.</li>
</ul>
<p>That’s all the up-front design we need. Let’s move on to integrat<a id="_idTextAnchor361"/>ing the <strong class="source-inline">Dialog</strong> component.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor362"/>Adding a dialog box</h2>
<p>Now that <a id="_idIndexMarker1559"/>we know<a id="_idIndexMarker1560"/> what we’re building, let’s go for it! To do so, perform these steps:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/MenuButtons.test.js</strong> and skip the test that is titled <strong class="source-inline">dispatches an action of START_SHARING when start sharing is clicked</strong>. We’re going to sever this connection for the moment. But we’ll come back to fix this later:<p class="source-code">it<strong class="bold">.skip</strong>("dispatches an action of START_SHARING when start sharing is clicked", () =&gt; {</p><p class="source-code">  ...</p><p class="source-code">});</p></li>
<li>In the same file, add a new <strong class="source-inline">import</strong> statement for the <strong class="source-inline">Dialog</strong> component, and mock it out using <strong class="source-inline">jest.mock</strong>. The <strong class="source-inline">Dialog</strong> component already exists in the code base but has remained unused until now:<p class="source-code"><strong class="bold">import { Dialog } from "../src/Dialog";</strong></p><p class="source-code"><strong class="bold">jest.mock("../src/Dialog", () =&gt; ({</strong></p><p class="source-code"><strong class="bold">  Dialog: jest.fn(() =&gt; &lt;div id="Dialog" /&gt;),</strong></p><p class="source-code"><strong class="bold">});</strong></p></li>
<li>Add this <a id="_idIndexMarker1561"/>new <a id="_idIndexMarker1562"/>test just below the one you’ve skipped. Very simply, it checks that we display the dialog when the appropriate button is clicked:<p class="source-code">it("opens a dialog when start sharing is clicked", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  click(buttonWithLabel("Start sharing"));</p><p class="source-code">  expect(Dialog).toBeCalled();</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/MenuButtons.js</strong>, add a new <strong class="source-inline">Dialog</strong> element to the JSX, including the <strong class="source-inline">import</strong> statement at the top of the file. The new component should be placed at the very bottom of the returned JSX. The test should then pass:<p class="source-code"><strong class="bold">import { Dialog } from "./Dialog";</strong></p><p class="source-code">export const MenuButtons = () =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;&gt;</p><p class="source-code">      ...</p><p class="source-code"><strong class="bold">     &lt;Dialog /&gt;</strong></p><p class="source-code">    &lt;/&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Next, let’s<a id="_idIndexMarker1563"/> set the <strong class="source-inline">message</strong> prop to something<a id="_idIndexMarker1564"/> useful for the user. Add this to your test suite:<p class="source-code">it("prints a useful message in the sharing dialog", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  click(buttonWithLabel("Start sharing"));</p><p class="source-code">  expect(propsOf(Dialog).message).toEqual(</p><p class="source-code">    "Do you want to share your previous commands, or would you like to reset to a blank script?"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, add the <strong class="source-inline">message</strong> prop to your implementation:<p class="source-code">&lt;Dialog</p><p class="source-code"><strong class="bold">  message="Do you want to share your previous commands, or would you like to reset to a blank script?"</strong></p><p class="source-code">/&gt;</p></li>
<li>Now, we need to make sure the dialog isn’t shown until the sharing button is clicked; add the following test:<p class="source-code">it("does not initially show the dialog", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  expect(Dialog).not.toBeCalled();</p><p class="source-code">});</p></li>
<li>Make this pass by adding a new state variable, <strong class="source-inline">isSharingDialogOpen</strong>. The sharing<a id="_idIndexMarker1565"/> button will set this to <strong class="source-inline">true</strong> when it’s <a id="_idIndexMarker1566"/>clicked. You’ll need to add the <strong class="source-inline">import</strong> statement for <strong class="source-inline">useState</strong> at the top of the file:<p class="source-code">import React<strong class="bold">, { useState }</strong> from "react";</p><p class="source-code">export const MenuButtons = () =&gt; {</p><p class="source-code"><strong class="bold">  const [</strong></p><p class="source-code"><strong class="bold">    isSharingDialogOpen, setIsSharingDialogOpen</strong></p><p class="source-code"><strong class="bold">  ] = useState(false);</strong></p><p class="source-code"><strong class="bold">  const openSharingDialog = () =&gt;</strong></p><p class="source-code"><strong class="bold">   setIsSharingDialogOpen(true);</strong></p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;&gt;</p><p class="source-code">      ...</p><p class="source-code">      {environment.isSharing ? (</p><p class="source-code">        &lt;button</p><p class="source-code">          id="stopSharing"</p><p class="source-code">          onClick={() =&gt; dispatch(stopSharing())}</p><p class="source-code">        &gt;</p><p class="source-code">          Stop sharing</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">      ) : (</p><p class="source-code">        &lt;button</p><p class="source-code">          id="startSharing"</p><p class="source-code">          onClick={<strong class="bold">openSharingDialog</strong>}</p><p class="source-code">        &gt;</p><p class="source-code">          Start sharing</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">      )}</p><p class="source-code"><strong class="bold">      {isSharingDialogOpen ? (</strong></p><p class="source-code">        &lt;Dialog</p><p class="source-code">          message="..."</p><p class="source-code">        /&gt;</p><p class="source-code"><strong class="bold">      ) : null}</strong></p><p class="source-code">    &lt;/&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Now, let’s add a test for adding buttons to the dialog. This is done by specifying the <strong class="source-inline">buttons</strong> prop on the <strong class="source-inline">Dialog</strong> component:<p class="source-code">it("passes Share and Reset buttons to the dialog", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  click(buttonWithLabel("Start sharing"));</p><p class="source-code">  expect(propsOf(Dialog).buttons).toEqual([</p><p class="source-code">    { id: "keep", text: "Share previous" },</p><p class="source-code">    { id: "reset", text: "Reset" }</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>Make<a id="_idIndexMarker1567"/> this<a id="_idIndexMarker1568"/> pass by adding a <strong class="source-inline">buttons</strong> prop to the <strong class="source-inline">Dialog</strong> component, as follows:<p class="source-code">{isSharingDialogOpen ? (</p><p class="source-code">  &lt;Dialog</p><p class="source-code">    message="..."</p><p class="source-code"><strong class="bold">    buttons={[</strong></p><p class="source-code"><strong class="bold">     { id: "keep", text: "Share previous" },</strong></p><p class="source-code"><strong class="bold">     { id: "reset", text: "Reset" }</strong></p><p class="source-code"><strong class="bold">    ]}</strong></p><p class="source-code">  /&gt;</p><p class="source-code">) : null}</p></li>
<li>For the next test, we’ll test that the dialog closes. Start by defining a new <strong class="source-inline">closeDialog</strong> helper in your test suite:<p class="source-code">const closeDialog = () =&gt;</p><p class="source-code">  act(() =&gt; propsOf(Dialog).onClose());</p></li>
<li>Add the next test, which checks that the <strong class="source-inline">Dialog</strong> component disappears once the dialog has had its <strong class="source-inline">onClose</strong> prop invoked:<p class="source-code">it("closes the dialog when the onClose prop is called", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  click(buttonWithLabel("Start sharing"));</p><p class="source-code">  closeDialog();</p><p class="source-code">  expect(element("#dialog")).toBeNull();</p><p class="source-code">});</p></li>
<li>Make that pass by adding the following line to the <strong class="source-inline">Dialog</strong> JSX:<p class="source-code">&lt;Dialog</p><p class="source-code">  <strong class="bold">onClose={() =&gt; setIsSharingDialogOpen(false)}</strong></p><p class="source-code">  ...</p><p class="source-code">/&gt;</p></li>
<li>Now<a id="_idIndexMarker1569"/> go <a id="_idIndexMarker1570"/>back to the test that you skipped and modify it so that it reads the same as the following code block. We’re going to modify the <strong class="source-inline">START_SHARING</strong> Redux action to take a new <strong class="source-inline">reset</strong> Boolean variable:<p class="source-code"><strong class="bold">const makeDialogChoice = button =&gt;</strong></p><p class="source-code"><strong class="bold">  act(() =&gt; propsOf(Dialog).onChoose(button));</strong></p><p class="source-code">it("dispatches an action of START_SHARING <strong class="bold">when dialog onChoose prop is invoked with reset</strong>", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  click(buttonWithLabel("Start sharing"));</p><p class="source-code"><strong class="bold">  makeDialogChoice("reset");</strong></p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "START_SHARING"<strong class="bold">, reset: true</strong> });</p><p class="source-code">});</p></li>
<li>To make this pass, move to <strong class="source-inline">src/MenuButtons.js</strong> and modify the <strong class="source-inline">startSharing</strong> function to add a <strong class="source-inline">reset</strong> property to the created Redux action. Notice<a id="_idIndexMarker1571"/> how we hardcode the value to <strong class="source-inline">true</strong> for now—we’ll need to <strong class="bold">triangulate</strong> in<a id="_idIndexMarker1572"/> the<a id="_idIndexMarker1573"/> upcoming test:<p class="source-code">const startSharing = () =&gt; ({</p><p class="source-code">  type: "START_SHARING",</p><p class="source-code"><strong class="bold">  reset: true,</strong></p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Triangulation within tests</p>
<p class="callout">See <a href="B18423_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a><em class="italic">, First Steps with Test-Driven Development</em>, for a reminder on triangulation and why we do it.</p>
<ol>
<li value="16">In the <strong class="source-inline">MenuButtons</strong> component, set the <strong class="source-inline">onChoose</strong> prop on the <strong class="source-inline">Dialog</strong> component:<p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code">    ...</p><p class="source-code">    {isSharingDialogOpen ? (</p><p class="source-code">      &lt;Dialog</p><p class="source-code">        onClose={() =&gt; setIsSharingDialogOpen(false)}</p><p class="source-code">        <strong class="bold">onChoose={() =&gt; dispatch(startSharing())}</strong></p><p class="source-code">        ...</p><p class="source-code">      /&gt;</p><p class="source-code">    ) : null}</p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
<li>Finally, we need to add a <a id="_idIndexMarker1574"/>new test for sending a value of <strong class="source-inline">false</strong> through for the <strong class="source-inline">reset</strong> action<a id="_idIndexMarker1575"/> property:<p class="source-code">it("dispatches an action of START_SHARING when dialog onChoose prop is invoked with share", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;MenuButtons /&gt;);</p><p class="source-code">  click(buttonWithLabel("Start sharing"));</p><p class="source-code">  makeDialogChoice("share");</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({</p><p class="source-code">      type: "START_SHARING",</p><p class="source-code">      reset: false</p><p class="source-code">    });</p><p class="source-code">});</p></li>
<li>To make that pass, modify <strong class="source-inline">startSharing</strong> to take a <strong class="source-inline">button</strong> parameter and then use that to set the <strong class="source-inline">reset</strong> property:<p class="source-code">const startSharing = (<strong class="bold">button</strong>) =&gt; ({</p><p class="source-code">  type: "START_SHARING",</p><p class="source-code"><strong class="bold">  reset: button === "reset",</strong></p><p class="source-code">});</p></li>
<li>Then, finally, in the <strong class="source-inline">MenuButtons</strong> component JSX, set the <strong class="source-inline">onChoose</strong> prop on the <strong class="source-inline">Dialog</strong> element:<p class="source-code"><strong class="bold">onChoose={(<a id="_idTextAnchor363"/>button) =&gt; dispatch(startSharing(button))}</strong></p></li>
</ol>
<p>You’ve now completed the first new piece of functionality specified in the Cucumber test. There’s a<a id="_idIndexMarker1576"/> dialog box being displayed and a <strong class="source-inline">reset</strong> Boolean flag<a id="_idIndexMarker1577"/> being sent through to the Redux store. We are inching toward a working solution.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor364"/>Updating sagas to a reset or replay state</h2>
<p>Now, we need to<a id="_idIndexMarker1578"/> update the <a id="_idIndexMarker1579"/>sharing saga to handle the new reset flag:</p>
<ol>
<li value="1">Open <strong class="source-inline">test/middleware/sharingSagas.test.js</strong> and add the following test to the end of the <strong class="source-inline">START_SHARING</strong> nested <strong class="source-inline">describe</strong> block:<p class="source-code">it("puts an action of RESET if reset is true", async () =&gt; {</p><p class="source-code">  store.dispatch({</p><p class="source-code">    type: "START_SHARING",</p><p class="source-code">    reset: true,</p><p class="source-code">  });</p><p class="source-code">  await notifySocketOpened();</p><p class="source-code">  await sendSocketMessage({</p><p class="source-code">    type: "UNKNOWN",</p><p class="source-code">    id: 123,</p><p class="source-code">  });</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "RESET" });</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/middleware/sharingSagas.js</strong>, modify <strong class="source-inline">startSharing</strong> so that it reads the same as the following code block. Don’t forget to add the new <strong class="source-inline">action</strong> parameter to the top line:<p class="source-code">function* startSharing(<strong class="bold">action</strong>) {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  if (action.reset) {</strong></p><p class="source-code"><strong class="bold">    yield put({ type: "RESET" });</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}</p></li>
<li>Now for<a id="_idIndexMarker1580"/> the<a id="_idIndexMarker1581"/> tricky second test. If <strong class="source-inline">reset</strong> is <strong class="source-inline">false</strong>, we want to replay all the current actions:<p class="source-code">it("shares all existing actions if reset is false", async () =&gt; {</p><p class="source-code">  const forward10 = {</p><p class="source-code">    type: "SUBMIT_EDIT_LINE",</p><p class="source-code">    text: "forward 10",</p><p class="source-code">  };</p><p class="source-code">  const right90 = {</p><p class="source-code">    type: "SUBMIT_EDIT_LINE",</p><p class="source-code">    text: "right 90"</p><p class="source-code">  };</p><p class="source-code">  store.dispatch(forward10);</p><p class="source-code">  store.dispatch(right90);</p><p class="source-code">  store.dispatch({</p><p class="source-code">    type: "START_SHARING",</p><p class="source-code">    reset: false,</p><p class="source-code">  });</p><p class="source-code">  await notifySocketOpened();</p><p class="source-code">  await sendSocketMessage({</p><p class="source-code">    type: "UNKNOWN",</p><p class="source-code">    id: 123,</p><p class="source-code">  });</p><p class="source-code">  expect(sendSpy).toBeCalledWith(</p><p class="source-code">    JSON.stringify({</p><p class="source-code">      type: "NEW_ACTION",</p><p class="source-code">      innerAction: forward10,</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">  expect(sendSpy).toBeCalledWith(</p><p class="source-code">    JSON.stringify({</p><p class="source-code">      type: "NEW_ACTION",</p><p class="source-code">      innerAction: right90</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make this pass, we can use the <strong class="source-inline">toInstructions</strong> function from the <strong class="source-inline">export</strong> namespace. We also need to make use of two new <strong class="source-inline">redux-saga</strong> functions: <strong class="source-inline">select</strong> and <strong class="source-inline">all</strong>. The <strong class="source-inline">select</strong> function is used to retrieve the state and the <strong class="source-inline">all</strong> function is used with <strong class="source-inline">yield</strong> to ensure that we wait for all the passed calls to<a id="_idIndexMarker1582"/> complete before continuing. Add those <strong class="source-inline">import</strong> statements now<a id="_idIndexMarker1583"/> to <strong class="source-inline">src/middleware/sharingSagas.js</strong>:<p class="source-code">import {</p><p class="source-code">  call,</p><p class="source-code">  put,</p><p class="source-code">  takeLatest,</p><p class="source-code">  take,</p><p class="source-code"><strong class="bold">  all,</strong></p><p class="source-code"><strong class="bold">  select</strong></p><p class="source-code">} from "redux-saga/effects";</p><p class="source-code">import { eventChannel, END } from "redux-saga";</p><p class="source-code"><strong class="bold">import { toInstructions } from "../language/export";</strong></p></li>
<li>Now, modify the <strong class="source-inline">startSharing</strong> function by tacking on an <strong class="source-inline">else</strong> block to the conditional:<p class="source-code">if (action.reset) {</p><p class="source-code">  yield put({ type: "RESET" });</p><p class="source-code"><strong class="bold">} else {</strong></p><p class="source-code"><strong class="bold">  const state = yield select(state =&gt; state.script);</strong></p><p class="source-code"><strong class="bold">  const instructions = toInstructions(state);</strong></p><p class="source-code"><strong class="bold">  yield all(</strong></p><p class="source-code"><strong class="bold">    instructions.map(instruction =&gt;</strong></p><p class="source-code"><strong class="bold">      call(shareNewAction, {</strong></p><p class="source-code"><strong class="bold">        innerAction: {</strong></p><p class="source-code"><strong class="bold">          type: "SUBMIT_EDIT_LINE",</strong></p><p class="source-code"><strong class="bold">          text: instruction</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">      })</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
<li>If you run the tests now, you’ll notice that there are a couple of unrelated failures. We can fix these by adding a default value for the <strong class="source-inline">reset</strong> property to the <strong class="source-inline">startSharing</strong> helper <a id="_idIndexMarker1584"/>method <a id="_idIndexMarker1585"/>in our tests:<p class="source-code">const startSharing = async () =&gt; {</p><p class="source-code">  store.dispatch({</p><p class="source-code">    type: "START_SHARING",</p><p class="source-code"><strong class="bold">    reset: true</strong></p><p class="source-code">  });</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
</ol>
<p>That completes the feature; both the unit tests and the Cucumber tests should be passing. Now would be<a id="_idIndexMarker1586"/> a great time to try things out <a id="_idIndexMarker1587"/>manually, too.</p>
<p>In the next section, we’ll focus on rewo<a id="_idTextAnchor365"/>rking our Cucumber tests to make them run much faster.</p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor366"/>Avoiding timeouts in test code</h1>
<p>In this <a id="_idIndexMarker1588"/>section, we’ll <a id="_idIndexMarker1589"/>improve the <a id="_idIndexMarker1590"/>speed at which our Cucumber tests run by replacing <strong class="source-inline">waitForTimeout</strong> calls <a id="_idIndexMarker1591"/>with <strong class="source-inline">waitForSelector</strong> calls.</p>
<p>Many of our step definitions contain waits that pause our test script interaction with the browser while we wait for the animations to finish. Here’s an example from our tests, which waits for a period of 3 seconds:</p>
<pre class="source-code">
await this.getPage("user").waitForTimeout(3000);</pre>
<p>Not only will this timeout slow down the test suite, but this kind of wait is also brittle as there are likely to be occasions when the timeout is slightly too short and the animation hasn’t finished. In this case, the test will intermittently fail. Conversely, the wait period is actually quite long. As more tests are added, the timeouts add up and the test runs suddenly take forever to run.</p>
<p class="callout-heading">Avoiding timeouts</p>
<p class="callout">Regardless <a id="_idIndexMarker1592"/>of the type of automated test, it is a good idea to avoid timeouts in your test code. Timeouts will substantially increase the time it takes to run your test suite. There are almost always methods you can use to avoid using them, such as the one highlighted in this section.</p>
<p>What we can do instead is modify our production code to notify us when it is animating, by setting an <strong class="source-inline">isAnimating</strong> class when the element is animating. We then use the Puppeteer <strong class="source-inline">waitForSelector</strong> function to<a id="_idIndexMarker1593"/> check for<a id="_idIndexMarker1594"/> a <a id="_idIndexMarker1595"/>change <a id="_idTextAnchor367"/>in the value of this class, replacing <strong class="source-inline">waitForTimeout</strong> entirely.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor368"/>Adding HTML classes to mark animation status</h2>
<p>We do this<a id="_idIndexMarker1596"/> by <a id="_idIndexMarker1597"/>adding an <strong class="source-inline">isAnimating</strong> class to the viewport <strong class="source-inline">div</strong> element when an animation is running.</p>
<p>Let’s start by adding the <strong class="source-inline">isAnimating</strong> class when the <strong class="source-inline">Drawing</strong> element is ready to animate a new Logo command:</p>
<ol>
<li value="1">In <strong class="source-inline">test/Drawing.test.js</strong>, add a new nested <strong class="source-inline">describe</strong> block within the main <strong class="source-inline">Display</strong> context, just below the context for resetting. Then, add the following test:<p class="source-code">describe("isAnimating", () =&gt; {</p><p class="source-code">  it("adds isAnimating class to viewport when animation begins", () =&gt; {</p><p class="source-code">    renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">      script: { drawCommands: [horizontalLine] }</p><p class="source-code">    });</p><p class="source-code">    triggerRequestAnimationFrame(0);</p><p class="source-code">    expect(</p><p class="source-code">      element("#viewport")</p><p class="source-code">    ).toHaveClass("isAnimating");</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/Drawing.js</strong>, update the JSX to include this class name on the <strong class="source-inline">viewport</strong> element:<p class="source-code">return (</p><p class="source-code">  &lt;div</p><p class="source-code">    id="viewport"</p><p class="source-code"><strong class="bold">    className="isAnimating"</strong></p><p class="source-code">  &gt;</p><p class="source-code">    ...</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p></li>
<li>Let’s triangulate <a id="_idIndexMarker1598"/>in order to get this <a id="_idIndexMarker1599"/>state variable in place. To do this, add the following test:<p class="source-code">it("initially does not have the isAnimating class set", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: { drawCommands: [] }</p><p class="source-code">  });</p><p class="source-code">  expect(</p><p class="source-code">    element("#viewport")</p><p class="source-code">  ).not.toHaveClass("isAnimating");</p><p class="source-code">});</p></li>
<li>To make this pass, update <strong class="source-inline">className</strong> to only set <strong class="source-inline">isAnimating</strong> if <strong class="source-inline">commandToAnimate</strong> is not null:<p class="source-code">className=<strong class="bold">{commandToAnimate ? "isAnimating" : ""}</strong>&gt;</p></li>
<li>As a final flourish, we’ll add an arguably unnecessary test. We want to be careful about removing the <strong class="source-inline">isAnimating</strong> class once the animation is finished. However, our implementation already takes care of this as <strong class="source-inline">commandToAnimate</strong> will be set to <strong class="source-inline">undefined</strong> when that happens. In other words, we don’t need an explicit test for this, and we’re done with this addition. However, for completeness’ sake, you can add the test:<p class="source-code">it("removes isAnimating class when animation is finished", () =&gt; {</p><p class="source-code">  renderWithStore(&lt;Drawing /&gt;, {</p><p class="source-code">    script: { drawCommands: [horizontalLine] },</p><p class="source-code">  });</p><p class="source-code">  triggerAnimationSequence([0, 500]);</p><p class="source-code">  expect<a id="_idTextAnchor369"/>(element("#viewport")).not.toHaveClass(</p><p class="source-code">    "isAnimating"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p>That <a id="_idIndexMarker1600"/>completes <a id="_idIndexMarker1601"/>adding the <strong class="source-inline">isAnimating</strong> class functionality. Now we can use this class as a means of replacing the <strong class="source-inline">waitForTimeout</strong> calls.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor370"/>Updating step definitions to use waitForSelector</h2>
<p>We’re ready to<a id="_idIndexMarker1602"/> use this <a id="_idIndexMarker1603"/>new behavior in our step definitions, bringing in a new call to <strong class="source-inline">waitForSelector</strong> that waits until the <strong class="source-inline">isAnimating</strong> class appears (or disappears) on an element:</p>
<ol>
<li value="1">In <strong class="source-inline">features/support/world.js</strong>, add the following two methods to the <strong class="source-inline">World</strong> class. The first waits for the <strong class="source-inline">isAnimating</strong> selector to appear within the DOM and the second waits for it to disappear:<p class="source-code">waitForAnimationToBegin(page) {</p><p class="source-code">  return this.getPage(page).waitForSelector(</p><p class="source-code">    ".isAnimating"</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">waitForAnimationToEnd(page) {</p><p class="source-code">  return this.getPage(page).waitForSelector(</p><p class="source-code">    ".isAnimating",</p><p class="source-code">   { hidden: true }</p><p class="source-code">  );</p><p class="source-code">}</p></li>
<li>In <strong class="source-inline">features/support/drawing.steps.js</strong>, search for the single <strong class="source-inline">waitForTimeout</strong> invocation<a id="_idIndexMarker1604"/> in this file and replace it with the code in the following block:<p class="source-code">When(</p><p class="source-code">  "the user enters the following instructions at the prompt:",</p><p class="source-code">  async function (dataTable) {</p><p class="source-code">    for (let instruction of dataTable.raw()) {</p><p class="source-code">      await this.getPage("user").type(</p><p class="source-code">        "textarea",</p><p class="source-code">        `${instruction}\n`</p><p class="source-code">      );</p><p class="source-code">      <strong class="bold">await this.waitForAnimationToEnd("user");</strong></p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Being careful about class transitions</p>
<p class="callout">We’re waiting for animation after <em class="italic">each</em> instruction is entered. This is important as it mirrors how the <strong class="source-inline">isAnimating</strong> class will be added and removed from the application. If we only had one <strong class="source-inline">waitForAnimationToEnd</strong> function as the last instruction on the page, we may end up exiting the step definition early if the wait catches the removal of an <strong class="source-inline">isAnimating</strong> class in the <em class="italic">middle</em> of a sequence of instructions, rather than catching the <em class="italic">last</em> one.</p>
<ol>
<li value="3">Now, open <strong class="source-inline">features/support/sharing.steps.js</strong>; this file has a similar step in it<a id="_idIndexMarker1605"/> as the previous one, so update that one now, in the same way:<p class="source-code">When(</p><p class="source-code">  "the presenter entered the following instructions at the prompt:",</p><p class="source-code">  async function(dataTable) {</p><p class="source-code">    for (let instruction of dataTable.raw()) {</p><p class="source-code">      await this.getPage("presenter").type(</p><p class="source-code">        "textarea",</p><p class="source-code">        `${instruction}\n`</p><p class="source-code">      );</p><p class="source-code"><strong class="bold">      await this.waitForAnimationToEnd("presenter");</strong></p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Toward the bottom of the file, update the two step definitions that check the turtle position:<p class="source-code">Then(</p><p class="source-code">  "the observer should see the turtle at x = {int}, y = {int}, angle = {int}",</p><p class="source-code">  async function (</p><p class="source-code">    expectedX, expectedY, expectedAngle</p><p class="source-code">  ) {</p><p class="source-code"><strong class="bold">    await this.waitForAnimationToEnd("observer");</strong></p><p class="source-code">    ...</p><p class="source-code">  }</p><p class="source-code">);</p><p class="source-code">Then(</p><p class="source-code">  "the presenter should see the turtle at x = {int}, y = {int}, angle = {int}",</p><p class="source-code">  async function (</p><p class="source-code">    expectedX, expectedY, expectedAngle</p><p class="source-code">  ) {</p><p class="source-code">    <strong class="bold">await this.waitForAnimationToEnd("presenter");</strong></p><p class="source-code">    ...</p><p class="source-code">  }</p><p class="source-code">);</p></li>
<li>Open <strong class="source-inline">features/support/svg.js</strong> and <a id="_idIndexMarker1606"/>update the function within it, as follows:<p class="source-code">export const checkLinesFromDataTable = page =&gt; {</p><p class="source-code">  return async function (dataTable) {</p><p class="source-code">    <strong class="bold">await this.waitForAnimationToEnd(page);</strong></p><p class="source-code">    ...</p><p class="source-code">  }</p><p class="source-code">};</p></li>
<li>If you run <strong class="source-inline">npx cucumber-js</strong> now, you’ll see that we have one test failure, which is related to the output on the observer’s screen. It indicates that we need to wait for the animations when we load the observer’s page. In this case, we need to wait for the animation to start before we can wait for it to finish. We can fix this by adding a new step to the feature. Open <strong class="source-inline">features/sharing.feature</strong> and modify the last test to include a <em class="italic">third</em> entry in<a id="_idIndexMarker1607"/> the <strong class="bold">When</strong> section:<p class="source-code">When the presenter clicks the button 'keep'</p><p class="source-code">And the observer navigates to the presenter's sharing link</p><p class="source-code"><strong class="bold">And the observer waits for animations to finish</strong></p></li>
</ol>
<p class="callout-heading">Encapsulating multiple When clauses</p>
<p class="callout">If you aren’t happy <a id="_idIndexMarker1608"/>with having three <strong class="bold">When</strong> clauses, then you can always combine them into a single step.</p>
<ol>
<li value="7">Back in <strong class="source-inline">features/support/sharing.steps.js</strong>, add this new step definition just underneath the other <strong class="bold">When</strong> step definitions:<p class="source-code">When(</p><p class="source-code">  "the observer waits for animations to finish",</p><p class="source-code">  async function () {</p><p class="source-code">    await this.waitForAnimationToBegin("observer");</p><p class="source-code">    await this.waitForAnimationToEnd("observer");</p><p class="source-code">  }</p><p class="source-code">);</p></li>
</ol>
<p>Your tests should now be passing, and they should be much faster. On<a id="_idTextAnchor371"/> my machine, they now only take <a id="_idIndexMarker1609"/>a quarter of the time than they did before.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor372"/>Summary</h1>
<p>In this chapter, we looked at how you can integrate Cucumber into your team’s workflow.</p>
<p>You saw some more ways that Cucumber tests differ from unit tests. You also learned how to avoid using timeouts to keep your test suites speedy.</p>
<p>We’re now finished with our exploration of the <strong class="bold">Spec Logo</strong> world.</p>
<p>In the final chapt<a id="_idTextAnchor373"/>er of the book, we’ll look at how TDD compares to other developer processes.</p>
<h1 id="_idParaDest-294"><a id="_idTextAnchor374"/>Exercise</h1>
<p>Remove as much duplication as possible from your step definitions.</p>
</div>
<div>
<div id="_idContainer057">
</div>
</div>
</div></body></html>