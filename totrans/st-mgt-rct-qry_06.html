<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer029">
<h1 class="ch pter-number" id="_idParaDest-88"><a id="_idTextAnchor159"/>6</h1>
<h1 id="_idParaDest-89"><a id="_idTextAnchor160"/>Performing Data Mutations with React Query</h1>
<p>When building applications, you won’t always need to fetch data. Sometimes, you will want to create, update, or delete it. When doing these actions, your server state will have <span class="No-Break">to change.</span></p>
<p>React Query allows you to change your server state by using mutations. To perform mutations, you can leverage another of React Query’s custom hooks, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break">.</span></p>
<p>In this chapter, you will be introduced to the <strong class="source-inline">useMutation</strong> hook and understand how React Query allows you to create, update, and delete your server state. Similar to <a href="B18501_04.xhtml#_idTextAnchor091"><span class="No-Break"><em class="it lic">Chapter 4</em></span></a>, during this process, you will learn about all the defaults used in your mutations. You will also be introduced to some options you can use to improve your <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> experience.</span></p>
<p>Once you are familiar with <strong class="source-inline">useMutation</strong>, you will get to know how you can leverage some of its options to perform some side-effect patterns, such as manually updating your data or forcing a query to update after performing <span class="No-Break">a mutation.</span></p>
<p>At the end of this chapter, we will put together all we have learned so far and apply it to do something that might improve your user experience considerably: <span class="No-Break">optimistic updates.</span></p>
<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
<ul>
<li>What is <strong class="source-inline">useMutation</strong> and how does <span class="No-Break">it work?</span></li>
<li>Performing side-effect patterns <span class="No-Break">after mutations</span></li>
<li>Performing <span class="No-Break">optimistic updates</span></li>
</ul>
<h1 id="_idParaDest-90"><a id="_idTextAnchor161"/>Technical requirements</h1>
<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6"><span class="No-Break">https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor162"/>What is useMutation and how does it work?</h1>
<p>You must be<a id="_idIndexMarker293"/> aware by now that mutations allow you to perform updates to your server state. These updates can be things such as creating data, removing data, or editing <span class="No-Break">your data.</span></p>
<p>To allow <a id="_idIndexMarker294"/>you to perform mutations on your server data, React Query created a hook <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break">.</span></p>
<p>Now, unlike <strong class="source-inline">useQuery</strong>, which under the default circumstances runs your query automatically as soon as the component using it renders or some dependencies of it change, <strong class="source-inline">useMutation</strong> will only run your mutation when you call one of the functions it returns from the hook instantiation <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">mutate</strong></span><span class="No-Break">.</span></p>
<p>To use the <strong class="source-inline">useMutation</strong> hook, you have to import it <span class="No-Break">like this:</span></p>
<pre class="source-code">
import { useMutation } from '@tanstack/react-query';</pre>
<p>Once it is imported, you can use it to define your mutation. Here is the <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> syntax:</span></p>
<pre class="source-code">
const mutation = useMutation({
    mutationFn: &lt;InsertMutationFunction&gt;
})</pre>
<p>As you can see from the preceding snippet, the <strong class="source-inline">useMutation</strong> hook only needs one required parameter for it to work, the <span class="No-Break">mutation function.</span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor163"/>What is the mutation function?</h2>
<p>The mutation function <a id="_idIndexMarker295"/>is a function that returns a promise responsible for performing an asynchronous task. In this scenario, this asynchronous task will be <span class="No-Break">our mutation.</span></p>
<p>The same principle we previously saw with the query function also applies to the mutation function. This means that, as we saw with query functions, since this function only needs to<a id="_idIndexMarker296"/> return a promise, it allows us again to use any asynchronous client of our choice. This means that REST and GraphQL are still supported, so you can use both options simultaneously if <span class="No-Break">you desire.</span></p>
<p>Let us now look at an example of a mutation function using GraphQL and another using REST. These mutation functions will be leveraged to create a new user on our <span class="No-Break">server state:</span></p>
<p class="Paragraph-Style-1" lang="en-US" xml:lang="en-US">Mutation with GraphQL</p>
<pre class="source-code">
import { useMutation } from "@tanstack/react-query";
import { gql, GraphQLClient } from "graphql-request";
const customMutation = gql`
mutation AddUser($user: String!, $age: Int!) {
  insert_user(object: { user: $user, age: $age }) {
    user
    age
  }
}
`
const createUserGQL = async (user) =&gt; {
  const endpoint = &lt;add_endpoint_here&gt;;
  const client = new GraphQLClient(endpoint)
  return client.request(customMutation, user);
  return data;
};
 ...
const mutation = useMutation({
    mutationFn: createUserGQL
  });</pre>
<p>The <a id="_idIndexMarker297"/>preceding snippet shows an example of using React Query to create a mutation with GraphQL. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We start by creating our GraphQL mutation and assigning it to our <span class="No-Break"><strong class="source-inline">customQuery</strong></span><span class="No-Break"> variable.</span></li>
<li>We then create the <strong class="source-inline">createUserGQL</strong> function, which will be our mutation function. This function will also receive as a parameter the <strong class="source-inline">user</strong> data to be used by our mutation to create the data on <span class="No-Break">the server.</span></li>
<li>In our <strong class="source-inline">useMutation</strong> hook, we pass our <strong class="source-inline">createUserGQL</strong> function as the mutation function to <span class="No-Break">the hook.</span></li>
</ol>
<p>Let us now see how to do this <span class="No-Break">using REST:</span></p>
<p class="Paragraph-Style-1" lang="en-US" xml:lang="en-US">Mutation with REST</p>
<pre class="source-code">
import axios from "axios";
import {useMutation} from "@tanstack/react-query";
const createUser = async (user) =&gt; {
  return axios.post
    (`https://danieljcafonso.builtwithdark.com/name-api`,
      user);
};
 …
const mutation = useMutation({
    mutationFn: createUser
  });</pre>
<p>In the preceding snippet, we can see an example of using React Query to create a mutation with REST. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We start by creating the <strong class="source-inline">createUser</strong> function, which will be our mutation function. This function will receive as a parameter the <strong class="source-inline">user</strong> data used by our mutation to create the data on the server. Here, we know we are going to be creating data on the server due to the use of the <span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break"> method.</span></li>
<li>In our <strong class="source-inline">useMutation</strong> hook, we pass to the hook our <strong class="source-inline">createUser</strong> function as the <span class="No-Break">mutation function.</span></li>
</ol>
<p>In the <a id="_idIndexMarker298"/>preceding example, we used <strong class="source-inline">axios</strong>, but if you prefer using <strong class="source-inline">fetch</strong> over <strong class="source-inline">axios</strong>, all you have to do is inside the <strong class="source-inline">createUser</strong> function, replace <strong class="source-inline">axios</strong> with <strong class="source-inline">fetch</strong> and apply the required changes for <strong class="source-inline">fetch</strong> to work. Here is an example of what you would need to do to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">fetch</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const createUserFetch = async (user) =&gt; {
  return fetch
    (`https://danieljcafonso.builtwithdark.com/name-api`, {
    method: "POST",
    body: JSON.stringify(user),
    headers: {
      "Content-type": "application/json; charset=UTF-8",
    },
  });
};
const mutation = useMutation({
    mutationFn: createUserFetch
});</pre>
<p>In the preceding snippet, we can see an example of our <strong class="source-inline">createUser</strong> function shown previously, but this time, we used <strong class="source-inline">fetch</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">axios</strong></span><span class="No-Break">.</span></p>
<p>Now that we<a id="_idIndexMarker299"/> are familiar with the mutation function, we need to understand how the <strong class="source-inline">useMutation</strong> hook leverages this function to allow us to perform our mutations. In the next section, we will learn about how the <strong class="source-inline">mutate</strong> function enables us to do this, as well as other things <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> returns.</span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor164"/>What does useMutation return?</h2>
<p>Like <strong class="source-inline">useQuery</strong>, when using the <strong class="source-inline">useMutation</strong> hook, it returns a couple <span class="No-Break">of values.</span></p>
<p>As mentioned throughout this chapter so far, to perform mutations, we need to leverage <strong class="source-inline">mutate</strong>. Now, <strong class="source-inline">mutate</strong> is not the only way to perform mutations and is also not the only thing <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> returns.</span></p>
<p>In this section, we’ll review the<a id="_idIndexMarker300"/> following returns of the <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">mutate</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">mutateAsync</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">data</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">error</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">reset</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">status</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">isPaused</strong></span></li>
</ul>
<h3>mutate</h3>
<p>After creating <a id="_idIndexMarker301"/>your mutation with your <strong class="source-inline">useMutation</strong> hook, you need a way to trigger it. <strong class="source-inline">mutate</strong> is the function you will need almost every time to <span class="No-Break">do so.</span></p>
<p>Here is how you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">mutate</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const { mutate } = useMutation({
    mutationFn: createUser
  });
mutate({ name: "username", age: 25 })</pre>
<p>In this snippet, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">mutate</strong> function from our <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook.</span></li>
<li>We call the <strong class="source-inline">mutate</strong> function with the variables our mutation function is expecting to receive to perform <span class="No-Break">our mutation.</span></li>
</ol>
<p>That’s it; that <a id="_idIndexMarker302"/>is how you can perform mutations with React Query. You create your mutation function, pass it to your <strong class="source-inline">useMutation</strong> hook, destructure <strong class="source-inline">mutate</strong> from it, and call it with the required parameters to perform your mutation whenever <span class="No-Break">you want.</span></p>
<p>Now, the preceding snippet serves to show how you can trigger mutations by using <strong class="source-inline">mutate</strong> but isn’t a very practical example. To help you create a mental model of how you can use <strong class="source-inline">mutate</strong> to perform mutations, you can refer to the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
import axios from "axios";
import { useMutation } from "@tanstack/react-query";
import { useState } from "react";
const createUser = async (user) =&gt; {
  return axios.post
    (`https://danieljcafonso.builtwithdark.com/name-api`,
      user);
};
const SimpleMutation = () =&gt; {
  const [name, setName] = useState("");
  const { mutate } = useMutation({
    mutationFn: createUser,
  });
  const submitForm = (e) =&gt; {
    e.preventDefault()
    mutate({ name })
  }
  return (
    &lt;div&gt;
      &lt;form&gt;
        &lt;input
          name="name"
          type={"text"}
          onChange={(e) =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;button onClick={submitForm}&gt;Add&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding<a id="_idIndexMarker303"/> snippet, we can see an example of a simple form using a controlled component. This is what is happening in the <span class="No-Break">preceding snippet:</span></p>
<ol>
<li>We create the <strong class="source-inline">createUser</strong> mutation function, which will receive a <strong class="source-inline">user</strong> object with <span class="No-Break">some data.</span></li>
</ol>
<p>Inside this function, we return the invocation of the <strong class="source-inline">axios</strong> client’s <strong class="source-inline">post</strong> method, which will return the promise that <strong class="source-inline">useMutation</strong> expects to receive for its <span class="No-Break">mutation function.</span></p>
<ol>
<li value="2">Inside<a id="_idIndexMarker304"/> our <strong class="source-inline">SimpleMutation</strong> component, we do <span class="No-Break">the following:</span><ol><li>We create a state variable to control the state of <span class="No-Break">our input.</span></li><li>We create our mutation using the <strong class="source-inline">createUser</strong> function as the mutation function and destructure <strong class="source-inline">mutate</strong> <span class="No-Break">from it.</span></li><li>We create a <strong class="source-inline">submitForm</strong> function. This function will receive the event from the form and prevent it from propagating so your page is not refreshed. After handling the event, it triggers the mutation and passes it the <strong class="source-inline">name</strong> state variable as part of the <strong class="source-inline">user</strong> object by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">mutate</strong></span><span class="No-Break">.</span></li></ol></li>
<li>Inside our form, we create our input to handle our <strong class="source-inline">name</strong> and have React control <span class="No-Break">its state.</span></li>
<li>We create a button with an <strong class="source-inline">onClick</strong> event to fire our <span class="No-Break"><strong class="source-inline">submitForm</strong></span><span class="No-Break"> function.</span></li>
</ol>
<p>As you should understand from the preceding explanation and code, whenever we click on the <strong class="bold">Add</strong> button, we will trigger a <strong class="source-inline">POST</strong> request to our URL with the current value of <span class="No-Break">our input.</span></p>
<p>One thing you’ll also see while proceeding with this chapter is that <strong class="source-inline">mutate</strong> can also receive some options to perform side effects if you desire to. But let’s leave these details <span class="No-Break">for later.</span></p>
<p>While <strong class="source-inline">mutate</strong> is the staple for performing mutations in React Query, there is also another function you can use if you so <span class="No-Break">desire: </span><span class="No-Break"><strong class="source-inline">mutateAsync</strong></span><span class="No-Break">.</span></p>
<h3>mutateAsync</h3>
<p>While in most scenarios you will use <strong class="source-inline">mutate</strong>, sometimes you might want to access the promise that <a id="_idIndexMarker305"/>contains the result of your mutation. In these scenarios, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">mutateAsync</strong></span><span class="No-Break">.</span></p>
<p>One thing to keep in mind while using <strong class="source-inline">mutateAsync</strong> is that you need to handle the promise yourself. This means that in an error scenario, you need to catch <span class="No-Break">the error.</span></p>
<p>Here is how you can use the <span class="No-Break"><strong class="source-inline">mutateAsync</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
const { mutateAsync } = useMutation({
  mutationFn: createUser,
});
try {
  const user = await mutateAsync({ name: "username", age:
    25 });
} catch (error) {
  console.error(error);
}</pre>
<p>In the preceding snippet, we destructure the <strong class="source-inline">mutateAsync</strong> function from the <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook:</span></p>
<ul>
<li>We need to handle potential error scenarios, so we wrap our <strong class="source-inline">mutateAsync</strong> call with a <strong class="source-inline">try-catch</strong> statement. Since this is an asynchronous function, we must wait for the data to <span class="No-Break">be returned.</span></li>
<li>If there is an error, we catch it and show an error in <span class="No-Break">our console.</span></li>
</ul>
<p>The preceding snippet shows how you can trigger mutations by using <strong class="source-inline">mutateAsync</strong>; as we showed in <strong class="source-inline">mutate</strong>, it doesn’t seem to be a very practical example. To help you create a mental model of how you can use <strong class="source-inline">mutateAsync</strong> to perform mutations, you can see the <span class="No-Break">following snippet:</span></p>
<pre class="source-code">
const ConcurrentMutations = () =&gt; {
  const [name, setName] = useState("");
  const { mutateAsync: mutateAsyncOne } = useMutation({
    mutationFn: createUser,
  });
  const { mutateAsync: mutateAsyncTwo } = useMutation({
    mutationFn: registerUser,
  });
  const submitForm = async (e) =&gt; {
    e.preventDefault()
    const mutationOne = mutateAsyncOne({ name })
    const mutationTwo = mutateAsyncTwo({ name })
     try {
      const data = await Promise.all([mutationOne,
        mutationTwo]);
      // do something with data
    } catch (error) {
      console.error(error);
    }
  }
  return (
    &lt;div&gt;
      &lt;form&gt;
        &lt;input
          name="name"
          type={"text"}
          onChange={(e) =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;button onClick={submitForm}&gt;Add&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the <a id="_idIndexMarker306"/>preceding snippet, we can see an example of a simple form using a controlled component where we leverage <strong class="source-inline">mutateAsync</strong> to perform concurrent mutations. This is what is happening in <span class="No-Break">the code:</span></p>
<ol>
<li>We create a state variable to control the state of <span class="No-Break">our input.</span></li>
<li>We create our first mutation using the <strong class="source-inline">createUser</strong> function as the mutation function and destructure <strong class="source-inline">mutateAsync</strong> as <strong class="source-inline">mutateAsyncOne</strong> <span class="No-Break">from it.</span></li>
<li>We create our second mutation using the <strong class="source-inline">registerUser</strong> function as the mutation function and destructure <strong class="source-inline">mutateAsync</strong> as <strong class="source-inline">mutateAsyncTwo</strong> <span class="No-Break">from it.</span></li>
<li>We create a <span class="No-Break"><strong class="source-inline">submitForm</strong></span><span class="No-Break"> function:</span><ol><li>This function will receive the event from the form and prevent it from propagating so your page is <span class="No-Break">not refreshed.</span></li><li>We assign the promise returned from the call of <strong class="source-inline">mutationAsyncOne</strong> with <strong class="source-inline">name</strong> as a parameter to our <span class="No-Break"><strong class="source-inline">mutationOne</strong></span><span class="No-Break"> variable.</span></li><li>We assign the promise returned from the call of <strong class="source-inline">mutationAsyncTwo</strong> with <strong class="source-inline">name</strong> as a parameter to our <span class="No-Break"><strong class="source-inline">mutationTwo</strong></span><span class="No-Break"> variable.</span></li><li>We leverage the <strong class="source-inline">Promise.all</strong> method and pass it to our <strong class="source-inline">mutationOne</strong> and <strong class="source-inline">mutationTwo</strong> promises so they can be <span class="No-Break">performed concurrently.</span></li></ol></li>
<li>Inside<a id="_idIndexMarker307"/> our form, we create our input to handle our name and have React control <span class="No-Break">its state.</span></li>
<li>We create a button with an <strong class="source-inline">onClick</strong> event to fire our <span class="No-Break"><strong class="source-inline">submitForm</strong></span><span class="No-Break"> function.</span></li>
</ol>
<p>Now that you are familiar with how you can perform mutations, let’s review a variable that is impacted by the success of a <span class="No-Break">mutation, </span><span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break">.</span></p>
<h3>data</h3>
<p>This variable<a id="_idIndexMarker308"/> is the last successfully resolved <strong class="source-inline">data</strong> of the mutation returned from your <span class="No-Break">mutation function.</span></p>
<p>Here is how you can use the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const SimpleMutation = () =&gt; {
  const { mutate, data } = useMutation({
    mutationFn: createUser,
  });
  return (
    &lt;div&gt;
        {data &amp;&amp; &lt;p&gt;{data.data.user}&lt;/p&gt;}
      ...
    &lt;/div&gt;
  );
}</pre>
<p>In this snippet, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">data</strong> variable from our <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook.</span></li>
<li>On our component return, we check whether we already have <strong class="source-inline">data</strong> from our mutation. If we do, we <span class="No-Break">render it.</span></li>
</ol>
<p>When the<a id="_idIndexMarker309"/> hook renders initially, this <strong class="source-inline">data</strong> will be undefined. Once the mutation triggers and finishes executing, and the promise returned from the mutation function successfully resolves our data, we will have access to the <strong class="source-inline">data</strong>. If for some reason our mutation function promise rejects, we can use the next variable, the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> one.</span></p>
<h3>error</h3>
<p>The <strong class="source-inline">error</strong> variable<a id="_idIndexMarker310"/> lets you access the <strong class="source-inline">error</strong> object returned from your mutation function <span class="No-Break">after failing.</span></p>
<p>Here is how you can use the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const SimpleMutation = () =&gt; {
  const { mutate, error } = useMutation({
    mutationFn: createUser,
  });
  return (
    &lt;div&gt;
        {error &amp;&amp; &lt;p&gt;{error.message}&lt;/p&gt;}
  ...
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding snippet, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">error</strong> variable from our <span class="No-Break"><strong class="source-inline">useQuery</strong></span><span class="No-Break"> hook.</span></li>
<li>On our component return, we check whether we have any errors. If we do, we render the <span class="No-Break">error message.</span></li>
</ol>
<p>When<a id="_idIndexMarker311"/> the hook renders initially, the <strong class="source-inline">error</strong> value will be null. If, after a mutation, for some reason the mutation function rejects and throws an error, then this error will be assigned to our <strong class="source-inline">error</strong> variable. It is important to mention here that this only applies if you are using <strong class="source-inline">mutate</strong>. If you use <strong class="source-inline">mutateAsync</strong>, you must catch the error and handle <span class="No-Break">it yourself.</span></p>
<p>When using the <strong class="source-inline">error</strong> variable, there will be times for the sake of user experience when you want to clear your errors. In those scenarios, the <strong class="source-inline">reset</strong> function will be your <span class="No-Break">best friend.</span></p>
<h3>reset</h3>
<p>The <strong class="source-inline">reset</strong> function <a id="_idIndexMarker312"/>allows you to reset <strong class="source-inline">error</strong> and <strong class="source-inline">data</strong> to their <span class="No-Break">initial state.</span></p>
<p>This function is useful if you need to clear the current value of data or errors after running <span class="No-Break">a mutation.</span></p>
<p>Here is how you can use the <span class="No-Break"><strong class="source-inline">reset</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
const SimpleMutation = () =&gt; {
  const { mutate, data, error, reset } = useMutation({
    mutationFn: createUser,
  });
  return (
    &lt;div&gt;
        {error &amp;&amp; &lt;p&gt;{error.message}&lt;/p&gt;}
        {data &amp;&amp; &lt;p&gt;{data.data.user}&lt;/p&gt;}
        &lt;button onClick={() =&gt; reset()}&gt;Clear errors and
          data&lt;/button&gt;
        ...
   &lt;/div&gt;
  );
};</pre>
<p>In this snippet, we <a id="_idIndexMarker313"/>do <span class="No-Break">the following:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">data</strong> and <strong class="source-inline">error</strong> variables and the <strong class="source-inline">reset</strong> function from our <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook.</span></li>
<li>On our component return, we check whether we already have data or errors from our mutation. When and if we do, we <span class="No-Break">render them.</span></li>
<li>We also render a button with an <strong class="source-inline">onClick</strong> event. When clicked, this button will trigger our <strong class="source-inline">reset</strong> function to clear our <strong class="source-inline">data</strong> and <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> values.</span></li>
</ol>
<p>Now, to use the <strong class="source-inline">error</strong> and <strong class="source-inline">data</strong> variables, we just check in the code whether they are defined to allow us to render them. To make this easier and once again help you craft a better user experience in your application, you can resort to using the <span class="No-Break"><strong class="source-inline">status</strong></span><span class="No-Break"> variable.</span></p>
<h3>status</h3>
<p>Like queries, when<a id="_idIndexMarker314"/> performing a mutation, the mutation can go through several states. These states help you to give more feedback to your users. For you to know what the current state of your mutation is, the <strong class="source-inline">status</strong> variable <span class="No-Break">was created.</span></p>
<p>Here are the states that the <strong class="source-inline">status</strong> variable <span class="No-Break">can have:</span></p>
<ul>
<li><strong class="source-inline">idle</strong>: This is the initial status of your mutation before <span class="No-Break">bein<a id="_idTextAnchor165"/>g executed.</span></li>
<li><strong class="source-inline">loading</strong>: This indicates if your mutation is <span class="No-Break">currently executing.</span></li>
<li><strong class="source-inline">error</strong>: This indicates that there was an error while performing the last mutation. Whenever this is the status, the <strong class="source-inline">error</strong> property will receive the error returned from the <span class="No-Break">mutation function.</span></li>
<li><strong class="source-inline">success</strong>: Your last mutation was successful, and it has returned data. Whenever this is the status, the <strong class="source-inline">data</strong> property will receive the successful data from the <span class="No-Break">mutation function.</span></li>
</ul>
<p>Here is how you <a id="_idIndexMarker315"/>can use the <span class="No-Break"><strong class="source-inline">status</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
 const SimpleMutation = () =&gt; {
  const [name, setName] = useState("");
  const { mutate, status, error, data } = useMutation({
    mutationFn: createUser,
  });
  const submitForm = (e) =&gt; {
    e.preventDefault()
    mutate({ name })
  }
  return (
    &lt;div&gt;
      {status === "idle" &amp;&amp; &lt;p&gt; Mutation hasn't run &lt;/p&gt;}
      {status === "error" &amp;&amp; &lt;p&gt; There was an error:
        {error.message} &lt;/p&gt;}
      {status === "success" &amp;&amp; &lt;p&gt; Mutation was successful:
        {data.name} &lt;/p&gt;}
      &lt;form&gt;
        &lt;input
          name="name"
          type={"text"}
          onChange={(e) =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;button disabled={status === "loading"}
          onClick={submitForm}&gt;Add&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding<a id="_idIndexMarker316"/> snippet, we are leveraging the <strong class="source-inline">status</strong> variable to create a better user experience for our users. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We create a state variable to handle our <span class="No-Break">controlled form.</span></li>
<li>We create our mutation and destructure <strong class="source-inline">status</strong> from the <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook.</span></li>
<li>We create a <strong class="source-inline">submitForm</strong> function to handle our <span class="No-Break">mutation submission.</span></li>
<li>We leverage our <strong class="source-inline">status</strong> variables to do the following in our <span class="No-Break">component return:</span><ol><li>If <strong class="source-inline">status</strong> is <strong class="source-inline">idle</strong>, we render a message letting the user know our mutation <span class="No-Break">hasn’t run.</span></li><li>If <strong class="source-inline">status</strong> equals <strong class="source-inline">error</strong>, we must destructure our <strong class="source-inline">error</strong> variable and display the <span class="No-Break">error message.</span></li><li>If <strong class="source-inline">status</strong> equals <strong class="source-inline">success</strong>, we must destructure our <strong class="source-inline">data</strong> variable and display it to <span class="No-Break">our user.</span></li><li>If <strong class="source-inline">status</strong> equals <strong class="source-inline">loading</strong>, it means we are executing a mutation, so we use this to make sure we disable our <strong class="bold">Add</strong> button and avoid the user clicking it again while the <span class="No-Break">mutation runs.</span></li></ol></li>
</ol>
<p>Now, you know how <a id="_idIndexMarker317"/>to use the <strong class="source-inline">status</strong> variable. For convenience, React Query also introduced some Boolean variants to help identify each state. They are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">isIdle</strong>: Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">idle state</span></li>
<li><strong class="source-inline">isLoading</strong>: Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">loading state</span></li>
<li><strong class="source-inline">isError</strong>: Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">error state</span></li>
<li><strong class="source-inline">isSuccess</strong>: Your <strong class="source-inline">status</strong> variable is in the <span class="No-Break">success state</span></li>
</ul>
<p>Let’s now rewrite our previous snippet leveraging our <strong class="source-inline">status</strong> <span class="No-Break">Boolean variants:</span></p>
<pre class="source-code">
 const SimpleMutation = () =&gt; {
  const [name, setName] = useState("");
  const { mutate, isIdle, isError, isSuccess, isLoading,
    error, data } = useMutation({
    mutationFn: createUser,
  });
  const submitForm = (e) =&gt; {
    e.preventDefault()
    mutate({ name })
  }
  return (
    &lt;div&gt;
      {isIdle &amp;&amp; &lt;p&gt; Mutation hasn't run &lt;/p&gt;}
      {isError &amp;&amp; &lt;p&gt; There was an error: {error.message}
        &lt;/p&gt;}
      {isSuccess &amp;&amp; &lt;p&gt; Mutation was successful:
        {data.name} &lt;/p&gt;}
      &lt;form&gt;
        &lt;input
          name="name"
          type={"text"}
          onChange={€ =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;button disabled={isLoading} onClick={submitForm}&gt;
          Add&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>As you can see, the<a id="_idIndexMarker318"/> code is similar. All we had to do was replace our <strong class="source-inline">status</strong> variable with <strong class="source-inline">isLoading</strong>, <strong class="source-inline">isError</strong>, <strong class="source-inline">isSuccess</strong>, and <strong class="source-inline">isIdle</strong> in the destructuring part and then use these variables in the respective <span class="No-Break">status check.</span></p>
<p>Unlike queries, mutations don’t have a <strong class="source-inline">fetchStatus</strong> variable. Now, this doesn’t mean that your mutation cannot suffer from a sudden loss of internet connection. To give more feedback to your users, the <strong class="source-inline">isPaused</strong> variable <span class="No-Break">was created.</span></p>
<h3>isPaused</h3>
<p>As you should remember from <a href="B18501_04.xhtml#_idTextAnchor091"><span class="No-Break"><em class="it lic">Chapter 4</em></span></a>, React Query introduced a new property called <strong class="source-inline">networkMode</strong>. When <a id="_idIndexMarker319"/>used in online mode, you can access a new variable in your <strong class="source-inline">useMutation</strong> hook <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">isPaused</strong></span><span class="No-Break">.</span></p>
<p>This Boolean variable identifies whether your mutation is currently paused due to a <span class="No-Break">lost connection.</span></p>
<p>Let us see how to use the <span class="No-Break"><strong class="source-inline">isPaused</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
const SimpleMutation = () =&gt; {
  const [name, setName] = useState("");
  const { mutate, isPaused } = useMutation({
    mutationFn: createUser,
  });
  const submitForm = € =&gt; {
    e.preventDefault()
    mutate({ name })
  }
  return (
    &lt;div&gt;
      {isPaused &amp;&amp; &lt;p&gt; Waiting for network to come back &lt;/p&gt;}
      &lt;form&gt;
        &lt;input
          na"e="n"me"
          typ"={"t"xt"}
          onChang€(e) =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;button disabled={isPaused} onClick={submitForm}&gt;
          Add&lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the preceding <a id="_idIndexMarker320"/>snippet, we leverage the <strong class="source-inline">isPaused</strong> variable to craft a better user experience in <span class="No-Break">our application:</span></p>
<ol>
<li>We destructure our <strong class="source-inline">isPaused</strong> variable from our <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook.</span></li>
<li>In our component return, we check whether <strong class="source-inline">isPaused</strong> is <strong class="source-inline">true</strong>. If so, we render a message to let our users know. We also assign it to disable our <strong class="bold">Add</strong> button to avoid the user accidentally triggering <span class="No-Break">another mutation.</span></li>
</ol>
<p>Now that we know some of the values our <strong class="source-inline">useMutation</strong> hook returns, let’s see how we can customize this hook with <span class="No-Break">some options.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor166"/>Commonly used mutation options explained</h2>
<p>Like the <strong class="source-inline">useQuery</strong> hook, more <a id="_idIndexMarker321"/>options can be passed into our <strong class="source-inline">useMutation</strong> hook than just its mutation function. These options will also help us craft a better developer and <span class="No-Break">user experience.</span></p>
<p>In this section, we’ll see some options that are more common and very important for you to be <span class="No-Break">aware of.</span></p>
<p>Here are the options we’ll <span class="No-Break">look at:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">cacheTime</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">mutationKey</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">retry</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">retryDelay</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onMutate</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onSuccess</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onError</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onSettled</strong></span></li>
</ul>
<h3>cacheTime</h3>
<p>The <strong class="source-inline">cacheTime</strong> option <a id="_idIndexMarker322"/>is the duration in milliseconds<a id="_idIndexMarker323"/> that the data in your cache that is inactive remains in memory. Once this time passes, the data will be garbage collected. Note that this does not work the same way as it does with queries. If you perform a mutation, the returned data is cached, but if you perform the same mutation again while this mutation is pending, <strong class="source-inline">useMutation</strong> won’t return the previous mutation data. In mutations, this option is mostly useful for preventing previous mutation data from being held in <span class="No-Break"><strong class="source-inline">MutationCache</strong></span><span class="No-Break"> indefinitely.</span></p>
<p>Here is how to use the <span class="No-Break"><strong class="source-inline">cacheTime</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  cacheTime: 60000,
});</pre>
<p>In this snippet, we define that after our mutation is inactive for one minute, the data will be <span class="No-Break">garbage collected.</span></p>
<h3>mutationKey</h3>
<p>Sometimes you will want to set some defaults for all your mutations by leveraging your <span class="No-Break"><strong class="source-inline">queryClient</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">setMutationDefaults</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">mutationKey</strong> option <a id="_idIndexMarker324"/>allows React Query to know whether it needs to apply previously configured defaults to <span class="No-Break">this mutation.</span></p>
<p>Here is how to use <a id="_idIndexMarker325"/>the <span class="No-Break"><strong class="source-inline">mutationKey</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  mutationKey: ["myUserMutation"],
});</pre>
<p>In the preceding<a id="_idIndexMarker326"/> snippet, we create a mutation with <strong class="source-inline">["myUserMutation"]</strong> as the mutation key. If any defaults were configured to be applied to any<a id="_idIndexMarker327"/> mutation with <strong class="source-inline">["myUserMutation"]</strong> as the mutation key, they would now <span class="No-Break">be applied.</span></p>
<h3>retry</h3>
<p>The <strong class="source-inline">retry</strong> option<a id="_idIndexMarker328"/> is a value that indicates whether your mutation will <a id="_idIndexMarker329"/>retry or not when it fails. When <strong class="source-inline">true</strong>, it will retry until it succeeds. When <strong class="source-inline">false</strong>, it <span class="No-Break">won’t retry.</span></p>
<p>This property can also be a number. When it is a number, the mutation will retry that specified number <span class="No-Break">of times.</span></p>
<p><em class="it lic">By default, React Query will not retry a mutation </em><span class="No-Break"><em class="it lic">on error.</em></span></p>
<p>Here is how to use the <span class="No-Break"><strong class="source-inline">retry</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  retry: 2,
});</pre>
<p>In the snippet, we set the <strong class="source-inline">retry</strong> option to <strong class="source-inline">2</strong>. This means that when failing to perform a mutation, this hook will retry performing the mutation <span class="No-Break">two times.</span></p>
<h3>retryDelay</h3>
<p>The <strong class="source-inline">retryDelay</strong> option<a id="_idIndexMarker330"/> is the delay to apply before the next <a id="_idIndexMarker331"/>retry attempt <span class="No-Break">in milliseconds.</span></p>
<p>By default, React Query uses an exponential backoff delay algorithm to define the retry timing <span class="No-Break">between retries.</span></p>
<p>Here is how to use the <span class="No-Break"><strong class="source-inline">retryDelay</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  retryDelay: (attempt) =&gt; attempt * 2000,
});</pre>
<p>In the<a id="_idIndexMarker332"/> snippet, we define a linear backoff function as our <strong class="source-inline">retryDelay</strong> option. Every time there is a<a id="_idIndexMarker333"/> retry, this function receives the attempt number and multiplies it by 2,000. This means that the time between every retry will be two <span class="No-Break">seconds longer.</span></p>
<h3>onMutate</h3>
<p>The <strong class="source-inline">onMutate</strong> option<a id="_idIndexMarker334"/> is a function that will be triggered <a id="_idIndexMarker335"/>before your mutation function is fired. This function also receives the variables your mutation function <span class="No-Break">will receive.</span></p>
<p>You can return values from this function that will be passed to your <strong class="source-inline">onError</strong> and <strong class="source-inline">onSettled</strong> <span class="No-Break">callback functions:</span></p>
<pre class="source-code">
useMutation({
  onMutate: (variables) =&gt; showNotification("Updating the
    following data:", variables),
});</pre>
<p>In this snippet, we pass an arrow function to our <strong class="source-inline">onMutate</strong> option. When our mutation is triggered, this function assigned to the <strong class="source-inline">onMutate</strong> option will be called with the variables your mutation function will receive. We then use these variables to show a notification to the user about the <span class="No-Break">pending mutation.</span></p>
<h3>onSuccess</h3>
<p>The <strong class="source-inline">onSuccess</strong> option <a id="_idIndexMarker336"/>is a function that will be triggered when your <a id="_idIndexMarker337"/>mutation <span class="No-Break">is successful.</span></p>
<p>If a promise is returned from this function, it will be awaited and resolved. This means your mutation status will be in a loading state until the <span class="No-Break">promise resolves.</span></p>
<p>This is how to use the <span class="No-Break"><strong class="source-inline">onSuccess</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  onSuccess: (data) =&gt; console.log("mutation was
    successful", data),
});</pre>
<p>In the snippet, we <a id="_idIndexMarker338"/>pass an arrow function to our <strong class="source-inline">onSuccess</strong> option. When our mutation performs<a id="_idIndexMarker339"/> successfully, this function assigned to the <strong class="source-inline">onSuccess</strong> option will be called with our data. We then use this data to log a message to <span class="No-Break">our console.</span></p>
<h3>onError</h3>
<p>The <strong class="source-inline">onError</strong> option<a id="_idIndexMarker340"/> is a function that will be triggered <a id="_idIndexMarker341"/>when your <span class="No-Break">mutation fails.</span></p>
<p>If a promise is returned from this function, it will be awaited and resolved. This means your mutation status will be in a loading state until the <span class="No-Break">promise resolves.</span></p>
<p>This is how to use the <span class="No-Break"><strong class="source-inline">onError</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  onError: (error) =&gt; console.log("mutation was
    unsuccessful", error.message),
});</pre>
<p>In the snippet, we pass an arrow function to our <strong class="source-inline">onError</strong> option. When the mutation fails, this function assigned to the <strong class="source-inline">onError</strong> option will be called with the thrown error. We then log the error in <span class="No-Break">our console.</span></p>
<h3>onSettled</h3>
<p>The <strong class="source-inline">onSettled</strong> option<a id="_idIndexMarker342"/> is a function that will be triggered when <a id="_idIndexMarker343"/>your mutation is either successful <span class="No-Break">or fails.</span></p>
<p>If a promise is returned from this function, it will be awaited and resolved. This means your mutation status will be in a loading state until the <span class="No-Break">promise resolves.</span></p>
<p>This is how to use the <span class="No-Break"><strong class="source-inline">onSettled</strong></span><span class="No-Break"> option:</span></p>
<pre class="source-code">
useMutation({
  onSettled : (data, error) =&gt; console.log("mutation has
    settled"),
});</pre>
<p>In the snippet, we<a id="_idIndexMarker344"/> pass an arrow function to our <strong class="source-inline">onSettled</strong> option. When the mutation fails or succeeds, this function assigned to the <strong class="source-inline">onSettled</strong> option will be called with the thrown error or the resolved data. We then log a message in <span class="No-Break">our console.</span></p>
<p>By now, you<a id="_idIndexMarker345"/> should be familiar with how the <strong class="source-inline">useMutation</strong> hook works and should be able to start using it to create, update, or delete your server state data. Now, let us see how we can leverage this hook and some of its options to perform some common <span class="No-Break">side-effect patterns.</span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor167"/>Performing side-effect patterns after mutations</h1>
<p>As you<a id="_idIndexMarker346"/> read this section title, you might have been wondering whether you’ve seen how to perform side effects after your mutations previously. The answer is yes, you already did. To perform side effects after a mutation, you can leverage any of <span class="No-Break">these options:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">onMutate</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onSuccess</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onError</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">onSettled</strong></span></li>
</ul>
<p>Now, what you haven’t seen is how you can leverage these side effects to do some amazing things that might improve your user experience, such as performing multiple side effects, refetching a query, or even updating your query data after <span class="No-Break">a mutation.</span></p>
<p>In this section, we will review some ways we leverage the callback functions of our <strong class="source-inline">useMutation</strong> hook and more to perform the previously mentioned <span class="No-Break">side effects.</span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor168"/>How to perform an additional side effect</h2>
<p>During <a id="_idIndexMarker347"/>development, a scenario may come up where it would be useful if you could perform two <strong class="source-inline">onSuccess</strong> callbacks. Now, you can definitely add as much logic as you want to your <strong class="source-inline">useMutation</strong> hook callback, but what if you wanted to split the logic or only execute this specific logic on one single mutation? This would indeed be useful because you could separate the concerns and logic. Well, you can definitely <span class="No-Break">do it!</span></p>
<p>The <strong class="source-inline">mutate</strong> function allows you to create your own callback functions that will execute after your <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> callbacks.</span></p>
<p>You just need<a id="_idIndexMarker348"/> to be aware that your <strong class="source-inline">useMutation</strong> callbacks run first, and then your <strong class="source-inline">mutate</strong> function callbacks. This is important to know because sometimes if you do something that causes your hook to unmount on your <strong class="source-inline">useMutation</strong> callback, your <strong class="source-inline">mutate</strong> function callbacks might not be <span class="No-Break">called after.</span></p>
<p>Here is an example of how to use the <strong class="source-inline">mutate</strong> <span class="No-Break">callback functions:</span></p>
<pre class="source-code">
 const { mutate } = useMutation({
    mutationFn: createUser,
    onSuccess: (data) =&gt; {
      showToast(`${data.data.name} was created
        successfuly`)
    }
  });
  const submitForm = (e) =&gt; {
    e.preventDefault()
    mutate({ name }, {
      onSuccess: (data) =&gt; {
        const userId = data.data.userID
        goToRoute(`/user/${userId}`)
      }
    })
  }
  ...</pre>
<p>In the preceding snippet, we leverage the <strong class="source-inline">mutate</strong> callback functions to perform some extra side effects. Here <a id="_idIndexMarker349"/>is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We create our mutation <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break">.</span></li>
<li>Inside this mutation, we leverage the <strong class="source-inline">onSuccess</strong> callback, which will receive the resolved data and display a toast to the user to let them know that data <span class="No-Break">was created.</span></li>
<li>We then create a <strong class="source-inline">submitForm</strong> function that will be given to an <strong class="source-inline">onSubmit</strong> event later on in <span class="No-Break">our code.</span></li>
<li>When triggered, this function will prevent the received event <span class="No-Break">from propagating.</span></li>
<li>This function will also trigger our mutation by calling <strong class="source-inline">mutate</strong>. In this <strong class="source-inline">mutate</strong>, we leverage its <strong class="source-inline">onSuccess</strong> callback to trigger a <span class="No-Break">route change.</span></li>
</ol>
<p>Now that we know how to use the <strong class="source-inline">mutate</strong> callback functions to perform some extra side effects, let’s see how we can retrigger a query after performing <span class="No-Break">a mutation.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor169"/>How to retrigger a query refetch after mutation</h2>
<p>When <a id="_idIndexMarker350"/>performing mutations that will change the data of a query you are currently displaying to your users, it is recommended that you refetch that query. This is because, at this time, you know that this data has changed, but if your query is still marked as fresh internally, React Query won’t refetch it; therefore, you must do <span class="No-Break">it yourself.</span></p>
<p>Having read the previous two chapters, when you read this section title, something must have come to your mind, and that is <span class="No-Break">query invalidation!</span></p>
<p>Here is how you can leverage the <strong class="source-inline">onSuccess</strong> callback to retrigger a <span class="No-Break">query refetch:</span></p>
<pre class="source-code">
  const queryClient = useQueryClient()
  const { data } = useQuery({
    queryKey: ["allUsers"],
    queryFn: fetchAllData,
  });
  const { mutate } = useMutation({
    mutationFn: createUser,
    onSuccess: () =&gt; {
      queryClient.invalidateQueries({
        queryKey: ["allUsers"],
      })
    }
  });</pre>
<p>In the <a id="_idIndexMarker351"/>preceding snippet, we leverage our <strong class="source-inline">onSuccess</strong> callback to retrigger a query after a successful mutation. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We get access <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">queryClient</strong></span><span class="No-Break">.</span></li>
<li>We create our query with <strong class="source-inline">["allUsers"]</strong> as a <span class="No-Break">query key.</span></li>
<li>We create our mutation. In this mutation <strong class="source-inline">onSuccess</strong> callback, we leverage our <strong class="source-inline">queryClient</strong> <strong class="source-inline">invalidateQueries</strong> method to trigger a refetch of our query with <strong class="source-inline">["allUsers"]</strong> as the <span class="No-Break">query key.</span></li>
</ol>
<p>As mentioned at the beginning of this section, this is a recommended practice, and you should do it every time you are mutating data your user sees on the page. Now, you might be thinking: if our mutation was successful, it might have returned the new data, so can’t we just manually update our query data and avoid an <span class="No-Break">extra request?</span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor170"/>How to perform an update to our query data after a mutation</h2>
<p>You can definitely <a id="_idIndexMarker352"/>manually update your query data. All you need is access to <strong class="source-inline">queryClient</strong> and the query key of the query you want <span class="No-Break">to update.</span></p>
<p>While this might be a practice that might save some bandwidth on the user side, it doesn’t guarantee that the data you end up displaying to your user is accurate. What if someone else using the same application changes <span class="No-Break">your data?</span></p>
<p>Now, if there are guarantees that there is no one else able to update this server state, then feel free to try. Just be sure that your query refetches somewhere in between to guarantee that all the data is up <span class="No-Break">to date.</span></p>
<p>Here is how you can perform an update to your query data after a <span class="No-Break">successful mutation:</span></p>
<pre class="source-code">
 const queryClient = useQueryClient()
  const { data } = useQuery({
    queryKey: ["allUsers"],
    queryFn: fetchAllData,
  });
  const { mutate } = useMutation({
    mutationFn: createUser,
    onSuccess: (data) =&gt; {
      const user = data.data
      queryClient.setQueryData(["allUsers"], (prevData) =&gt;
        [user, ...prevData]);
    }
  });</pre>
<p>In the previous snippet, we leverage our <strong class="source-inline">onSuccess</strong> callback to update our query data and avoid<a id="_idIndexMarker353"/> refetching it. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We get access <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">queryClient</strong></span><span class="No-Break">.</span></li>
<li>We create our query with <strong class="source-inline">["allUsers"]</strong> as a <span class="No-Break">query key.</span></li>
<li>We create our mutation. In this mutation <strong class="source-inline">onSuccess</strong> callback, we leverage our <strong class="source-inline">queryClient</strong> <strong class="source-inline">setQueryData</strong> function to manually update the data of the query with <strong class="source-inline">["allUsers"]</strong> as the <span class="No-Break">query key.</span></li>
<li>In this update, we create a new array that combines our created data and our previous data to create the new <span class="No-Break">query data.</span></li>
</ol>
<p>As you can see, there are a couple of patterns you can apply to improve your user experience after performing mutations. Now, when speaking about mutations often, one topic shows up every time, which is the topic that will close this chapter: <span class="No-Break">optimistic updates!</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor171"/>Performing optimistic updates</h1>
<p>As we <a id="_idIndexMarker354"/>saw in <a href="B18501_02.xhtml#_idTextAnchor049"><span class="No-Break"><em class="it lic">Chapter 2</em></span></a>, an optimistic update is a pattern used during an ongoing mutation where we update our UI to show how it will look after our mutation is finished, although our mutation is still not confirmed <span class="No-Break">as complete.</span></p>
<p>Well, React Query allows you to perform optimistic updates, and it makes it extremely simple. All you need is to use the callback functions we saw in the <span class="No-Break">previous sections.</span></p>
<p>Here is how to perform an optimist update using the <span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break"> hook:</span></p>
<pre class="source-code">
import axios from "axios";
import { useQuery, useMutation, useQueryClient } from
  "@tanstack/react-query";
import { useState } from "react";
const fetchAllData = async () =&gt; {
  const { data } = await axios.get(
    `https://danieljcafonso.builtwithdark.com/name-api`
  );
  return data;
};
const createUser = async (user) =&gt; {
  return axios.post
    (`https://danieljcafonso.builtwithdark.com/name-api`,
      user);
};
const Mutation = () =&gt; {
  const queryClient = useQueryClient();
  const [name, setName] = useState("");
  const [age, setAge] = useState(0);
  const { data } = useQuery({
    queryKey: ["allUsers"],
    queryFn: fetchAllData,
  });
  const mutation = useMutation({
    mutationFn: createUser,
    onMutate: async (user) =&gt; {
      await queryClient.cancelQueries({
        queryKey: ["allUsers"],
      });
      const previousUsers = queryClient.getQueryData({
        queryKey: ["allUsers"],
      });
      queryClient.setQueryData(["allUsers"], (prevData) =&gt;
        [user, ...prevData]);
      return { previousUsers };
    },
    onError: (error, user, context) =&gt; {
      showToast("Something went wrong...")
      queryClient.setQueryData(["allUsers"], context.
        previousUsers);
    },
    onSettled: () =&gt;
      queryClient.invalidateQueries({
        queryKey: ["allUsers"],
      }),
  });
  return (
    &lt;div&gt;
     {data?.map((user) =&gt; (
        &lt;div key={user.userID}&gt;
          Name: {user.name} Age: {user.age}
        &lt;/div&gt;
      ))}
      &lt;form&gt;
        &lt;input
          name="name"
          type={"text"}
          onChange={(e) =&gt; setName(e.target.value)}
          value={name}
        /&gt;
        &lt;input
          name="number"
          type={"number"}
          onChange={(e) =&gt; setAge(Number(e.target.value))}
          value={age}
        /&gt;
        &lt;button
          type="button"
          onClick={(e) =&gt; {
            e.preventDefault()
            mutation.mutate({ name, age })
          }}
        &gt;
          Add
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</pre>
<p>In the <a id="_idIndexMarker355"/>preceding snippet, we put our gained knowledge about mutations into practice to create a better user experience for our users using optimistic updates. Here is what we <span class="No-Break">are doing:</span></p>
<ol>
<li>We define the needed imports for <span class="No-Break">our code.</span></li>
<li>Create the <strong class="source-inline">fetchAllData</strong> query function. This function will trigger a <strong class="source-inline">GET</strong> request to our endpoint to fetch the <span class="No-Break">user data.</span></li>
<li>Create the <strong class="source-inline">createUser</strong> mutation function. This function will receive the user and perform a <strong class="source-inline">POST</strong> request to our endpoint to <span class="No-Break">create it.</span></li>
<li>Inside our <strong class="source-inline">Mutation</strong> component, we do <span class="No-Break">the following:</span><ol><li>We get access <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">queryClient</strong></span><span class="No-Break">.</span></li><li>Create state variables and respective setters for the name and <span class="No-Break">age inputs.</span></li><li>Create our query using <strong class="source-inline">["allUsers"]</strong> as the query key and <strong class="source-inline">fetchAllData</strong> as the <span class="No-Break">query function.</span></li><li>Create our mutation using <strong class="source-inline">createUser</strong> as the mutation function. Inside this mutation, we define <span class="No-Break">some callbacks:</span><ol><li>On the <strong class="source-inline">onMutate</strong> callback, we do our <span class="No-Break">optimistic update:</span><ul><li>We make sure we cancel any ongoing queries for our query with <strong class="source-inline">["allUsers"]</strong> as the query key. To do this, we use our <strong class="source-inline">queryClient</strong> <span class="No-Break"><strong class="source-inline">cancelQueries</strong></span><span class="No-Break"> method.</span></li><li>We save our previous data cached under the <strong class="source-inline">["allUsers"]</strong> query key just in case we need to roll back. To do this, we leverage our <strong class="source-inline">queryClient</strong> <span class="No-Break"><strong class="source-inline">getQueryData</strong></span><span class="No-Break"> function.</span></li><li>We perform our optimistic update by merging our new data with our previous data and updating the data cached under the <strong class="source-inline">["allUsers"]</strong> query key. To do this, we leverage our <strong class="source-inline">queryClient</strong> <span class="No-Break"><strong class="source-inline">setQueryData</strong></span><span class="No-Break"> function.</span></li><li>We<a id="_idIndexMarker356"/> return our <strong class="source-inline">previousUsers</strong> data in case we need to <span class="No-Break">roll back.</span></li></ul></li><li>On the <strong class="source-inline">onError</strong> callback, in case of an error, we need to roll back <span class="No-Break">our data:</span><ul><li>As a good practice, we let our users know something went wrong with our mutation. In this scenario, we are displaying a <span class="No-Break">toast notification.</span></li><li>To do the rollback, we access our context parameter and leverage the <strong class="source-inline">previousUsers</strong> data returned from the <strong class="source-inline">onMutate</strong> callback. We then use this variable to override the cached data under the <strong class="source-inline">["allUsers"]</strong> query key. To do this, we use our <strong class="source-inline">queryClient</strong> <span class="No-Break"><strong class="source-inline">setQueryData</strong></span><span class="No-Break"> function.</span></li></ul></li><li>On the <strong class="source-inline">onSettled</strong> callback, when our mutation settles, we need to refetch <span class="No-Break">our data:</span><ul><li>To refetch our data, we leverage our <strong class="source-inline">queryClient</strong> <strong class="source-inline">invalidateQueries</strong> and invalidate the query with <strong class="source-inline">["allUsers"]</strong> as the <span class="No-Break">query key.</span></li></ul></li><li>In our component return, we create a <strong class="source-inline">div</strong> element with <span class="No-Break">the following:</span></li></ol></li></ol><ul><li>We use the <strong class="source-inline">data</strong> variable from our query to display our <span class="No-Break">users’ data.</span></li><li>We create our controlled form with our name and <span class="No-Break">age inputs.</span></li><li>We also create a button that, when pressed, fires its <strong class="source-inline">onClick</strong> event and consequentially triggers our mutation with our name and <span class="No-Break">age values.</span></li></ul></li>
</ol>
<p>Having seen<a id="_idIndexMarker357"/> how you build an optimistic update, here is the flow of our created <span class="No-Break">optimistic update:</span></p>
<ol>
<li>Our component renders, and our query fetches our data and <span class="No-Break">caches it.</span></li>
<li>When we click on the <strong class="bold">Add</strong> button, the data returned from the query is automatically updated to include the new user and reflects this change on the <span class="No-Break">UI immediately.</span></li>
<li>If there is an error, we roll back to our <span class="No-Break">previous data.</span></li>
<li>When our mutation settles, we refetch the data for the query we just performed the optimistic update on to ensure our query <span class="No-Break">is updated.</span></li>
</ol>
<p>With this knowledge under your belt, you now have all the knowledge you need to take your mutation game to the next level with the help of your new <span class="No-Break">ally: </span><span class="No-Break"><strong class="source-inline">useMutation</strong></span><span class="No-Break">!</span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor172"/>Summary</h1>
<p>In this chapter, we learned how React Query allows us to perform mutations by using the <strong class="source-inline">useMutation</strong> hook. By now, you should be able to create, delete, or update your server state. To make these changes, you resort to the mutation function, which, like your query function, supports any client and allows you to use GraphQL or REST as long it returns <span class="No-Break">a promise.</span></p>
<p>You learned about some things the <strong class="source-inline">useMutation</strong> hook returns, such as the <strong class="source-inline">mutate</strong> and <strong class="source-inline">mutateAsync</strong> functions.  Similar to <strong class="source-inline">useQuery</strong>, <strong class="source-inline">useMutation</strong> also returns the mutation <strong class="source-inline">data</strong> and <strong class="source-inline">error</strong> variables and gives you access to some statuses you can use to craft a better user experience. For your convenience, <strong class="source-inline">useMutation</strong> also returns a <strong class="source-inline">reset</strong> function to clear your state and an <strong class="source-inline">isPaused</strong> variable in case your mutation enters a <span class="No-Break">paused state.</span></p>
<p>For you to customize your developer experience, you learned about some commonly used options that allow you to customize your <strong class="source-inline">useMutation</strong> hook experience. We then leveraged four of these options to teach you how to perform some side effects after your <span class="No-Break">mutation runs.</span></p>
<p>Finally, you used some of the knowledge you learned to perform optimistic updates and craft a better experience for your <span class="No-Break">application users.</span></p>
<p>In <a href="B18501_07.xhtml#_idTextAnchor173"><span class="No-Break"><em class="it lic">Chapter 7</em></span></a>, <em class="it lic">Server-Side Rendering with Next.js or Remix</em>, we’ll understand how we can leverage React Query even in a scenario where we are using a server-side framework. You will learn how you can fetch your data in the server and provision React Query on your client side to make it work and craft a <span class="No-Break">better experience.</span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer030">
</div>
</div>
</div></body></html>