<html><head></head><body>
  <div id="_idContainer105" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-43" class="chapterTitle">Forms, Observables, Signals, and Subjects</h1>
    <p class="normal">In this <a id="_idIndexMarker098"/>chapter, we’ll work on a simple weather app, <strong class="keyWord">LocalCast Weather</strong>, using Angular and a third-party web API from <a href="https://www.geonames.org/postal-codes"><span class="url">OpenWeatherMap.org</span></a>. The source code for this project is provided on GitHub at <a href="https://github.com/duluca/local-weather-app"><span class="url">https://github.com/duluca/local-weather-app</span></a>, including various stages of development in the <code class="inlineCode">projects</code> folder.</p>
    <div class="note">
      <p class="normal">If you’ve never used<a id="_idIndexMarker099"/> Angular before and need an introduction to Angular essentials, I recommend checking out <em class="italic">What is Angular?</em> on Angular.dev at <a href="https://angular.dev/overview"><span class="url">https://angular.dev/overview</span></a> and going through the <em class="italic">Learn Angular Tutorial</em> at <a href="https://angular.dev/tutorials/learn-angular"><span class="url">https://angular.dev/tutorials/learn-angular</span></a>.</p>
      <p class="normal">Feeling brave? Just type the following into your terminal:</p>
      <pre class="programlisting con"><code class="hljs-con">$ npm create @angular
</code></pre>
    </div>
    <p class="normal">LocalCast Weather <a id="_idIndexMarker100"/>is a simple app that demonstrates the essential elements that make up an Angular application, such as components, standalone components, modules, providers, pipes, services, RxJS, unit testing, e2e using Cypress, environment variables, Angular Material, and <strong class="keyWord">Continuous Integration</strong> and <strong class="keyWord">Continuous Delivery</strong> (<strong class="keyWord">CI/CD</strong>) pipelines<a id="_idIndexMarker101"/> leveraging CircleCI.</p>
    <p class="normal">I’ve created a Kanban board for this project on GitHub. You can access it at the following link to get more context about the project: </p>
    <p class="normal"><a href="https://github.com/duluca/local-weather-app"><span class="url">https://github.com/users/duluca/projects/1</span></a>.</p>
    <p class="normal">A Kanban board<a id="_idIndexMarker102"/> is a great way to document your plans for building an app. I touch on the importance of building a roadmap and creating information radiators for the status of your project in <em class="chapterRef">Chapter 3</em>, <em class="italic">Architecting an Enterprise App</em>.</p>
    <div class="note">
      <p class="normal">An information radiator<a id="_idIndexMarker103"/> is a physical or virtual display that is easily visible or accessible, conveying key information about a project or process. It typically includes metrics, progress charts, or status indicators and is designed to provide at-a-glance awareness without requiring the viewer to seek out information. The goal of an information radiator is to promote transparency, facilitate communication among team members, and enable stakeholders to get updates without interrupting the team’s workflow.</p>
    </div>
    <div class="packt_tip">
      <p class="normal">As a bonus, I created a rudimentary wiki page on my repository at <a href="https://github.com/duluca/local-weather-app/wiki"><span class="url">https://github.com/duluca/local-weather-app/wiki</span></a>. Note that you can’t upload images to <code class="inlineCode">README.md</code> or wiki pages. To get around this limitation, you can create a new issue, upload an image in a comment, and copy and paste the URL for it to embed images in <code class="inlineCode">README.md</code> or wiki pages. In the sample wiki, I followed this technique to embed the wireframe design into the page.</p>
    </div>
    <p class="normal">The source<a id="_idIndexMarker104"/> code for the sample projects in the book is divided into <strong class="keyWord">stages</strong> to capture snapshots of various states of development. In this chapter, we pick up the app development from <code class="inlineCode">stage5</code> and evolve it into <code class="inlineCode">stage6</code>. In <code class="inlineCode">stage5</code>, the app is polished, but it can only pull weather information for one city, which is hardcoded into the app. As a result, it is not a very useful app.</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_01.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.1: The LocalCast Weather app as in projects/stage5</p>
    <p class="normal">You will <a id="_idIndexMarker105"/>inherit an existing project that is not interactive yet. To build an interactive app, we need to be able to handle user input. Enabling user input in your application opens possibilities for creating great user experiences.</p>
    <p class="normal">We will cover the following main topics in this chapter:</p>
    <ul>
      <li class="bulletList">Great UX should drive implementation</li>
      <li class="bulletList">Reactive forms versus template-driven forms</li>
      <li class="bulletList">Component interaction with observables and RxJS/BehaviorSubject</li>
      <li class="bulletList">Managing subscriptions and memory leaks</li>
      <li class="bulletList">Coding in the reactive paradigm</li>
      <li class="bulletList">Chaining API calls</li>
      <li class="bulletList">Using Angular Signals</li>
      <li class="bulletList">Generating apps with ChatGPT</li>
    </ul>
    <h1 id="_idParaDest-44" class="heading-1">Technical requirements </h1>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the repository linked shortly. The repository contains the final and completed state of the code. You can verify your progress at the end of this chapter by looking for the end-of-chapter snapshot of code under the <code class="inlineCode">projects</code> folder.</p>
    <p class="normal">For <em class="italic">Chapter 2</em>:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Clone the <a href="https://github.com/duluca/local-weather-app"><span class="url">https://github.com/duluca/local-weather-app</span></a> repo.</li>
      <li class="numberedList">Execute <code class="inlineCode">npm install</code> on the root folder to install dependencies.</li>
      <li class="numberedList">The beginning state of the project is reflected at:
        <pre class="programlisting con"><code class="hljs-con">projects/stage5
</code></pre>
      </li>
      <li class="numberedList">The end state of the project is reflected at:
        <pre class="programlisting con"><code class="hljs-con">projects/stage6
</code></pre>
      </li>
      <li class="numberedList">Add the stage name to any <code class="inlineCode">ng</code> command to act only on that stage:
        <pre class="programlisting con"><code class="hljs-con">npx ng build stage6
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Note that the <code class="inlineCode">dist/stage6</code> folder at the root of the repository will contain the compiled result.</p>
    </div>
    <div class="note">
      <p class="normal">Beware that the source code provided in the book and the version on GitHub are likely to be different. The ecosystem around these projects is ever evolving. Between changes to how the Angular CLI generates new code, bug fixes, new versions of libraries, and side-by-side implementations of multiple techniques, there’s a lot of variation impossible to account for. If you find errors or have questions, please create an issue or submit a pull request on GitHub.</p>
    </div>
    <p class="normal">By the end of the chapter, you should be comfortable leveraging observables and signals to build apps that provide a great UX. As a<a id="_idIndexMarker106"/> bonus, I’ll touch on how you can <a id="_idIndexMarker107"/>leverage <strong class="keyWord">Generative AI</strong> (<strong class="keyWord">GenAI</strong>) tools like ChatGPT (<a href="https://chat.openai.com/"><span class="url">https://chat.openai.com/</span></a>) to build quick prototypes. But first, let’s get back to UX because no matter how much you run, crawl, or scale the city walls, if you nail the UX, your app will be loved; but if you miss the mark, your app will be a dime a dozen.</p>
    <h1 id="_idParaDest-45" class="heading-1">Great UX should drive implementation</h1>
    <p class="normal">Creating an easy-to-use and rich<strong class="keyWord"> User Experience </strong>(<strong class="keyWord">UX</strong>)<strong class="keyWord"> </strong>should be<a id="_idIndexMarker108"/> your main goal. You shouldn’t pick a design just because it’s easiest to implement. However, often, you’ll <a id="_idIndexMarker109"/>find a great UX that is simple to implement in the front end of your app but a lot more difficult on the back end. Consider google.com’s landing page:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_02.png" alt="A screenshot of a google search  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.2: Google’s landing page</p>
    <p class="normal">In this context, Google Search is just a simple input field with two buttons. Easy to build, <em class="italic">right?</em> That simple input field unlocks some of the world’s most sophisticated and advanced software technologies <a id="_idIndexMarker110"/>backed by a global infrastructure of custom-built data centers and <strong class="keyWord">Artificial Intelligence</strong> (<strong class="keyWord">AI</strong>). It is a deceptively simple and insanely powerful way to interact with users. You can augment user input by leveraging modern web APIs like <code class="inlineCode">GeoLocation</code> and add critical context to derive new meaning from user input. So, when the user types in <code class="inlineCode">Paris</code>, you don’t have to guess whether they mean Paris, France, or Paris, Texas, or whether you should show the current temperature in Celsius or Fahrenheit. With <code class="inlineCode">LocalStorage</code>, you can cache user credentials and remember user preferences to enable dark mode in your app.</p>
    <p class="normal">In this book, we won’t be implementing an AI-driven super app, but we will enable users to search for their cities using a city name or postal code (often called <em class="italic">zip codes</em> in the US). Once you realize how complicated it can get to implement something as seemingly simple as a search by postal code, you may gain a new appreciation for well-designed web apps.</p>
    <p class="normal">To accomplish the UX goal, we need to build a UI centered around an input field. To do this, we need to leverage Angular forms with validation messages to create engaging search experiences with <em class="italic">search-as-you-type</em> functionality. </p>
    <p class="normal">Behind the scenes, <code class="inlineCode">RxJS</code>/<code class="inlineCode">BehaviorSubject</code> or <code class="inlineCode">signals</code> enables us to build decoupled components that can communicate with one another, and a reactive data stream allows us to merge data from multiple web APIs without increasing the complexity of our app. In addition, you will be introduced to<a id="_idIndexMarker111"/> Angular Signals and see how it differs from RxJS.</p>
    <p class="normal">Next, let’s see how to implement an input field using forms. Forms are the primary mechanism that <a id="_idIndexMarker112"/>we need to<a id="_idIndexMarker113"/> capture user input. In Angular, there are two kinds of forms: <strong class="keyWord">reactive</strong> and <strong class="keyWord">template-driven</strong>. We need to cover both techniques so that you’re familiar with how forms work in Angular.</p>
    <h1 id="_idParaDest-46" class="heading-1">Reactive versus template-driven forms</h1>
    <p class="normal">Now, we’ll <a id="_idIndexMarker114"/>implement the search bar on the home<a id="_idIndexMarker115"/> screen of the application. The next user story states <strong class="screenText">Display forecast information for current location</strong>, which may be taken to imply an inherent GeoLocation functionality. However, as you may note, GeoLocation is a separate task. The challenge is that with native platform features such as GeoLocation, you are never guaranteed to receive the actual location information. This may be due to signal loss issues on mobile devices, or the user may simply refuse to give permission to share their location information.</p>
    <p class="normal">First and foremost, we must deliver a good baseline UX and implement value-added functionality such as GeoLocation only afterward. In <code class="inlineCode">stage5</code>, the status of the project is represented on the Kanban board, as captured in the following snapshot:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_03.png" alt="A screenshot of a chat  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.3: GitHub project Kanban board</p>
    <p class="normal">We’ll <a id="_idIndexMarker116"/>implement the <strong class="screenText">Add city search capability</strong> card (which captures a user story), as shown in the <strong class="screenText">In progress</strong> column. As<a id="_idIndexMarker117"/> part of this story, we are going to implement a search-as-you-type functionality while providing feedback to the user if the service is unable to retrieve the expected data.</p>
    <p class="normal">Initially, it may be intuitive to implement a type-search mechanism; however, <code class="inlineCode">OpenWeatherMap</code> APIs don’t provide such an endpoint. Instead, they provide bulk data downloads, which are costly and are in the multiples-of-megabytes range.</p>
    <p class="normal">We will need to implement our application server to expose such an endpoint so that our app can effectively query while using minimal data.</p>
    <p class="normal">The free endpoints for <code class="inlineCode">OpenWeatherMap</code> do pose an interesting challenge, where a two-digit country code may accompany either a city name or zip code for the most accurate results. This is an excellent opportunity to implement a feedback mechanism for the user if more than one result is returned for a given query.</p>
    <p class="normal">We want every iteration of the app to be a potentially releasable increment and avoid doing too much at any given time.</p>
    <p class="normal">Before you begin working on a story, it is a good idea to break it into technical tasks. The following is the task breakdown for this story:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add an Angular form control so that we can capture user input events.</li>
      <li class="numberedList">Use an Angular Material input as documented at <a href="https://material.angular.io/components/input"><span class="url">https://material.angular.io/components/input</span></a> to improve the UX of the input field.</li>
      <li class="numberedList">Create the search bar as a separate component to enforce the separation of concerns and a decoupled component architecture.</li>
      <li class="numberedList">Extend the existing endpoint to accept a zip code and make the country code optional in <code class="inlineCode">weather.service.ts</code> to make it more intuitive for end users to interact with our app.</li>
      <li class="numberedList">Throttle requests so that we don’t query the API with every keystroke but at an interval where users still get immediate feedback without clicking a separate button.</li>
    </ol>
    <p class="normal">Let’s tackle these tasks over the following few sections.</p>
    <h2 id="_idParaDest-47" class="heading-2">Adding Angular reactive forms</h2>
    <p class="normal">You may wonder why we’re adding Angular forms since we’ve got just a single input field, not a form with multiple inputs. As a general rule of thumb, any time you add an input field, it should be wrapped in a <code class="inlineCode">&lt;form&gt;</code> tag. The <code class="inlineCode">Forms</code> module contains <code class="inlineCode">FormControl</code> that enables you to write the backing code behind the input field to respond to user inputs and provide the appropriate data or the validation or message in response.</p>
    <p class="normal">There are two types of forms in Angular:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Template-driven forms</strong>: These <a id="_idIndexMarker118"/>forms are like what you may be familiar with in the case of AngularJS, where the form logic is mainly inside the HTML template. I’m not a fan of this approach because it is harder to test these behaviors, and fat HTML templates become challenging to maintain quickly.</li>
      <li class="bulletList"><strong class="keyWord">Reactive forms</strong>: The behavior of reactive forms<a id="_idIndexMarker119"/> is driven by TypeScript code in the controller. This means that your validation logic can be unit tested and, better yet, reused across your application. Reactive forms are the core technology that, in the future, will enable the Angular Material team to write automated tools that can autogenerate an input form based on a TypeScript interface.</li>
    </ul>
    <div class="packt_tip">
      <p class="normal">Read more about <a id="_idIndexMarker120"/>reactive forms at <a href="https://angular.dev/guide/forms/reactive-forms"><span class="url">https://angular.dev/guide/forms/reactive-forms</span></a>.</p>
    </div>
    <p class="normal">In Angular, dependencies are encapsulated in modules provided by the framework. User-created modules are no longer mandatory, and our code sample is configured as a standalone app. For the component we define in the next section, you must import <code class="inlineCode">FormsModule</code> and <code class="inlineCode">ReactiveFormsModule</code> to be able to use these features in your template.</p>
    <p class="normal">In a pure reactive form implementation, you only need <code class="inlineCode">ReactiveFormsModule</code>. Note that <code class="inlineCode">FormsModule</code> supports template-driven forms and other scenarios where you may only want to declare <code class="inlineCode">FormControl</code> without <code class="inlineCode">FormGroup</code>. This is how we implement the input field for this app. <code class="inlineCode">FormGroup</code> is defined in the next section.</p>
    <p class="normal">Note that reactive forms allow you to code in the reactive paradigm, which is a net positive when using observables. Next, let’s add a city search component to our app.</p>
    <h2 id="_idParaDest-48" class="heading-2">Adding and verifying components</h2>
    <p class="normal">We will be <a id="_idIndexMarker121"/>creating a <code class="inlineCode">citySearch</code> component using Angular Material form and input modules:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create the new <code class="inlineCode">citySearch</code> component:
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npx ng g c citySearch
</code></pre>
      </li>
      <li class="numberedList">Import the form dependencies from the previous section and Material dependencies, <code class="inlineCode">MatFormFieldModule</code> and <code class="inlineCode">MatInputModule</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">FormsModule</span>, <span class="hljs-title">ReactiveFormsModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">MatButtonModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/button'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">MatFormFieldModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/form-field'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">MatIconModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/icon'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">MatInputModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/input'</span>
...
<span class="hljs-meta">@Component</span>({
  ...
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">imports</span>: [
    <span class="hljs-title">FormsModule</span>,
    <span class="hljs-title">ReactiveFormsModule</span>,
    <span class="hljs-title">MatFormFieldModule</span>,
    <span class="hljs-title">MatInputModule</span>,
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchComponent</span>
...
</code></pre>
      
    <p class="normal">We’re adding <code class="inlineCode">MatFormFieldModule</code> because each input field should be wrapped in a <code class="inlineCode">&lt;mat-form-field&gt;</code> tag to get the most out of the Angular Material functionality.</p>
    <div class="note">
      <p class="normal">At a high level, <code class="inlineCode">&lt;form&gt;</code> encapsulates numerous default behaviors for keyboard, screen-reader, and browser extension users; <code class="inlineCode">&lt;mat-form-field&gt;</code> enables easy two-way data binding, a technique that should be used in moderation, and also allows graceful label, validation, and error message displays.</p>
    </div></li>
    </ol>


    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Create a basic template, replacing the existing content:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.component.html</strong></span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-form-field</span><span class="hljs-tag"> </span><span class="hljs-attr">appearance</span><span class="hljs-tag">=</span><span class="hljs-string">"outline"</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-label</span><span class="hljs-tag">&gt;</span>City Name or Postal Code<span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-label</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-icon</span><span class="hljs-tag"> </span><span class="hljs-attr">matPrefix</span><span class="hljs-tag">&gt;</span>search<span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-icon</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">matInput</span><span class="hljs-tag"> </span><span class="hljs-attr">aria-label</span><span class="hljs-tag">=</span><span class="hljs-string">"City or Zip" </span><span class="hljs-tag">[</span><span class="hljs-attr">formControl</span><span class="hljs-tag">]=</span><span class="hljs-string">"search"</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-form-field</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
</code></pre>
      </li>
      <li class="numberedList">Declare <a id="_idIndexMarker122"/>a property named <code class="inlineCode">search</code> and instantiate it as an instance of <code class="inlineCode">FormControl</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">FormControl</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchComponent</span> <span class="hljs-keyword">implements</span> 
  <span class="hljs-title">OnInit</span> { 
  
  search = <span class="hljs-keyword">new</span> <span class="hljs-title">FormControl</span>()
  ...
</code></pre>
      
    <p class="normal">Reactive forms have three levels of control:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">FormControl</code> is the most basic element with a one-to-one relationship with an input field.</li>
      <li class="bulletList"><code class="inlineCode">FormArray</code> represents repetitive input fields that represent a collection of objects.</li>
      <li class="bulletList"><code class="inlineCode">FormGroup</code> registers individual <code class="inlineCode">FormControl</code> or <code class="inlineCode">FormArray</code> objects as you add more input fields to a form.</li>
    </ul>
    <p class="normal">Finally, the <code class="inlineCode">FormBuilder</code> object is used to orchestrate and maintain the actions of a <code class="inlineCode">FormGroup</code> object more easily. <code class="inlineCode">FormBuilder</code> and <code class="inlineCode">FormGroup</code> are first used in <em class="chapterRef">Chapter 6</em>, <em class="italic">Implementing Role-Based Navigation</em>, and all controls, including <code class="inlineCode">FormArray</code>, are covered in depth in <em class="chapterRef">Chapter 8</em>, <em class="italic">Recipes – Reusability, Forms, and Caching</em>.</p></li>
    </ol>



    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">In <code class="inlineCode">app.component.ts</code>, import <code class="inlineCode">CitySearchComponent</code>, then add <code class="inlineCode">&lt;app-city-search&gt;</code> as a new <code class="inlineCode">div</code> in between the row that contains the tagline of the app and the row that contains <code class="inlineCode">mat-card</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-attr">template</span>: <span class="hljs-string">`</span>
<span class="hljs-string">  ...</span>
<span class="hljs-string">    &lt;/div&gt;</span>
    <span class="code-highlight"><strong class="hljs-string-slc">&lt;div fxLayoutAlign="center"&gt;</strong></span>
      <span class="code-highlight"><strong class="hljs-string-slc">&lt;app-city-search&gt;&lt;/app-city-search&gt;</strong></span>
    <span class="code-highlight"><strong class="hljs-string-slc">&lt;/div&gt;</strong></span>
<span class="hljs-string">    &lt;div fxLayout="row"&gt;</span>
<span class="hljs-string">  ...</span>
<span class="hljs-string">`</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">imports</span>: [
    <span class="hljs-title">FlexModule</span>,
    <span class="hljs-title">CitySearchComponent</span>,
    ...
  ],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> {
</code></pre>
      </li>
      <li class="numberedList">Launch your app from your terminal:
        <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> npm start
</code></pre>
      </li>
      <li class="numberedList">Test the<a id="_idIndexMarker123"/> integration of components by checking out the app in the browser, as shown:
    <figure class="mediaobject"><img src="../Images/B20960_02_04.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.4: The LocalCast Weather app with a search field</p></li>
    </ol>
    <p class="normal">If no <a id="_idIndexMarker124"/>errors occur, we can start adding the <code class="inlineCode">FormControl</code> elements and wire them up to a search endpoint.</p>
    <h2 id="_idParaDest-49" class="heading-2">Adding a search option to the weather service</h2>
    <p class="normal">So far, we<a id="_idIndexMarker125"/> have been passing parameters to get the weather for a city using its name and country code. By allowing users to enter zip codes, we must make our service more flexible in accepting both types of inputs.</p>
    <p class="normal">OpenWeatherMap’s API accepts URI parameters, so we can refactor the existing <code class="inlineCode">getCurrentWeather</code> function using a TypeScript <strong class="keyWord">union type</strong> and a <strong class="keyWord">type guard</strong>. </p>
    <p class="normal">That means we can supply different parameters <a id="_idIndexMarker126"/>while<a id="_idIndexMarker127"/> preserving type checking:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Refactor the <code class="inlineCode">getCurrentWeather</code> function in <code class="inlineCode">weather.service.ts</code> to handle both <code class="inlineCode">zip</code> and <code class="inlineCode">city</code> inputs:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
  <span class="hljs-title">getCurrentWeather</span>(
    <span class="hljs-attr">search</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, 
    country?: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; { 
    <span class="hljs-keyword">let</span> uriParams = <span class="hljs-keyword">new</span> <span class="hljs-title">HttpParams</span>()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> search === <span class="hljs-string">'string'</span>) { 
      uriParams = uriParams.<span class="hljs-title">set</span>(<span class="hljs-string">'q'</span>,
        country ? <span class="hljs-string">`</span><span class="hljs-subst">${search}</span><span class="hljs-string">,</span><span class="hljs-subst">${country}</span><span class="hljs-string">`</span> : search
      )
    } <span class="hljs-keyword">else</span> {
      uriParams = uriParams.<span class="hljs-title">set</span>(<span class="hljs-string">'zip'</span>, <span class="hljs-string">'search'</span>)
    }
    
    uriParams = uriParams.<span class="hljs-title">set</span>(<span class="hljs-string">'appid'</span>, environment.<span class="hljs-property">appId</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">httpClient</span>
      .<span class="hljs-property">get</span>&lt;<span class="hljs-title">ICurrentWeatherData</span>&gt;(
        <span class="hljs-string">`</span><span class="hljs-subst">${environment.baseUrl}</span><span class="hljs-string">api.openweathermap.org/data/2.5/</span>
          <span class="hljs-string">weather`</span>,
        { <span class="hljs-attr">params</span>: uriParams } 
    )
    .<span class="hljs-title">pipe</span>(<span class="hljs-title">map</span>(
      <span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-title">transformToICurrentWeather</span>(data)))
  }
</code></pre>
      
    <p class="normal">We <a id="_idIndexMarker128"/>renamed the <code class="inlineCode">city</code> parameter to <code class="inlineCode">search</code> since it can be a city name or a zip code. We then allowed its type to be either a <code class="inlineCode">string</code> or a <code class="inlineCode">number</code>, and depending on what the type is at runtime, we will either use <code class="inlineCode">q</code> or <code class="inlineCode">zip</code>. We also made <code class="inlineCode">country</code> optional and only append it to the query if it exists.</p>
    <p class="normal"><code class="inlineCode">getCurrentWeather</code> now has business logic embedded into it and is thus a good target for unit testing. Following the single responsibility principle from the SOLID principles, we will refactor the HTTP call to its own function, <code class="inlineCode">getCurrentWeatherHelper</code>.</p>
    <div class="note">
      <p class="normal">If you’re unfamiliar with <a id="_idIndexMarker129"/>SOLID principles, I cover them in the Agile engineering best practices section of <em class="italic">Chapter 3, Architecting an Enterprise App</em>. If you want to read more about it now, see the Wikipedia entry here: <a href="https://en.wikipedia.org/wiki/SOLID"><span class="url">https://en.wikipedia.org/wiki/SOLID</span></a>.</p>
    </div></li>
    </ol>



    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Refactor the HTTP<a id="_idIndexMarker130"/> call into <code class="inlineCode">getCurrentWeatherHelper</code>.
    <p class="normal">In the next sample, note the use of a backtick character, <code class="inlineCode">`</code>, instead of a single-quote character, <code class="inlineCode">'</code>, which leverages the template literals’ functionality that allows embedded expressions in JavaScript:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
  <span class="hljs-title">getCurrentWeather</span>(
    <span class="hljs-attr">search</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, 
    country?: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; { 
    <span class="hljs-keyword">let</span> uriParams = <span class="hljs-keyword">new</span> <span class="hljs-title">HttpParams</span>()
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> search === <span class="hljs-string">'string'</span>) { 
      uriParams = uriParams.<span class="hljs-title">set</span>(<span class="hljs-string">'q'</span>,
        country ? <span class="hljs-string">`</span><span class="hljs-subst">${search}</span><span class="hljs-string">,</span><span class="hljs-subst">${country}</span><span class="hljs-string">`</span> : search
      )
    } <span class="hljs-keyword">else</span> {
      uriParams = uriParams.<span class="hljs-title">set</span>(<span class="hljs-string">'zip'</span>, <span class="hljs-string">'search'</span>)
    }
    
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">getCurrentWeatherHelper</strong><strong class="hljs-slc">(uriParams)</strong></span>
  }
  <span class="hljs-keyword">private</span> <span class="hljs-title">getCurrentWeatherHelper</span>(<span class="hljs-attr">uriParams</span>: <span class="hljs-title">HttpParams</span>):
    <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; { 
    uriParams = uriParams.<span class="hljs-title">set</span>(<span class="hljs-string">'appid'</span>, environment.<span class="hljs-property">appId</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">httpClient</span>
      .<span class="hljs-property">get</span>&lt;<span class="hljs-title">ICurrentWeatherData</span>&gt;(
        <span class="hljs-string">`</span><span class="hljs-subst">${environment.baseUrl}</span><span class="hljs-string">api.openweathermap.org/data/2.5/</span>
          <span class="hljs-string">weather`</span>,
        { <span class="hljs-attr">params</span>: uriParams } 
      )
      .<span class="hljs-title">pipe</span>(<span class="hljs-title">map</span>(
        <span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-title">transformToICurrentWeather</span>(data)))
    }
</code></pre>
    <p class="normal">As a <a id="_idIndexMarker131"/>positive side effect, <code class="inlineCode">getCurrentWeatherHelper</code> adheres to the open/closed principle from SOLID. After all, it is open to extension by our ability to change the function’s behavior by supplying different <code class="inlineCode">uriParams</code> and is closed to modification because it won’t have to be changed frequently.</p>
    <p class="normal">To demonstrate the latter point, let’s implement a new function to get the current weather by latitude and longitude.</p></li>
    </ol>




    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Implement <code class="inlineCode">getCurrentWeatherByCoords</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-title">getCurrentWeatherByCoords</span>(<span class="hljs-attr">coords</span>: <span class="hljs-title">Coordinates</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; {
  <span class="hljs-keyword">const</span> uriParams = <span class="hljs-keyword">new</span> <span class="hljs-title">HttpParams</span>()
      .<span class="hljs-title">set</span>(<span class="hljs-string">'lat'</span>, coords.<span class="hljs-property">latitude</span>.<span class="hljs-title">toString</span>())
      .<span class="hljs-title">set</span>(<span class="hljs-string">'lon'</span>, coords.<span class="hljs-property">longitude</span>.<span class="hljs-title">toString</span>())
  <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeatherHelper</span>(uriParams)
}
</code></pre>
      
    <p class="normal">As you can see, the functionality of <code class="inlineCode">getCurrentWeatherHelper</code> is extensible without modifying its code.</p></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Ensure that you update <code class="inlineCode">IWeatherService</code> with the changes made earlier:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IWeatherService</span> {
  <span class="hljs-title">getCurrentWeather</span>(
    <span class="hljs-attr">search</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, country?: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
  <span class="hljs-title">getCurrentWeatherByCoords</span>(<span class="hljs-attr">coords</span>: <span class="hljs-title">Coordinates</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
}
</code></pre>
      </li>
    </ol>
    <p class="normal">As a result of<a id="_idIndexMarker132"/> adhering to the SOLID design principles, we make it easier to robustly unit test flow-control logic and ultimately write code that is more resilient to bugs and cheaper to maintain.</p>
    <h2 id="_idParaDest-50" class="heading-2">Implementing a search</h2>
    <p class="normal">Now, let’s connect the<a id="_idIndexMarker133"/> new service method to the input field:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Update <code class="inlineCode">citySearch</code> to inject <code class="inlineCode">weatherService</code> and subscribe to input changes:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">WeatherService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../weather/weather.service'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span> { 
  search = <span class="hljs-keyword">new</span> <span class="hljs-title">FormControl</span>()
  
  <span class="hljs-title">constructor</span>(<span class="code-highlight"><strong class="hljs-keyword-slc">private</strong><strong class="hljs-params-slc"> </strong><strong class="hljs-attr-slc">weatherService</strong><strong class="hljs-params-slc">: </strong><strong class="hljs-title-slc">WeatherService</strong></span>) {}
  ...
  <span class="hljs-title">ngOnInit</span>(): <span class="hljs-built_in">void</span> { 
    <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">search</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">valueChanges</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">subscribe</strong><strong class="hljs-slc">()</strong></span>
  }
</code></pre>
     
    <p class="normal">We are treating all input as <code class="inlineCode">string</code> at this point. The user input can be a city and zip code, city and country code, or a zip code and country code, separated by a comma. While a city or zip code is required, a country code is optional. We can use the <code class="inlineCode">String.split</code> function to parse any potential comma-separated input and then trim any whitespace out from the beginning and the end of the string with <code class="inlineCode">String.trim</code>. We then ensure that we trim all parts of the string by iterating over them with <code class="inlineCode">Array.map</code>.</p>
    <p class="normal">We then deal with the optional parameter with the ternary operator <code class="inlineCode">?:</code>, only passing in a value if it exists, otherwise leaving it undefined.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Implement the search handler:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-variable">this</span>.<span class="hljs-property">search</span>.<span class="hljs-property">valueChanges</span>
  .<span class="hljs-title">subscribe</span>(
    <span class="hljs-function">(</span><span class="hljs-attr">searchValue</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span><span class="hljs-function">) =&gt;</span> { 
    <span class="hljs-keyword">if</span> (searchValue) {
      <span class="hljs-keyword">const</span> userInput = searchValue.<span class="hljs-title">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title">map</span>(<span class="hljs-params">s</span><span class="hljs-function"> =&gt;</span> s.<span class="hljs-title">trim</span>())
      <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-title">getCurrentWeather</span>(
        userInput[<span class="hljs-number">0</span>],
        userInput.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? userInput[<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>
      ).<span class="hljs-title">subscribe</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> (<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(data)))
  }
})
</code></pre>
      </li>
      <li class="numberedList">Add a hint for the user under the input field, informing them about the optional country functionality:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.component.html</strong></span>
...
  <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-form-field</span><span class="hljs-tag"> </span><span class="hljs-attr">appearance</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">outline"</span><span class="hljs-tag">&gt;</span>
    ...
    <span class="code-highlight"><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">mat-hint</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc">Specify country code like 'Paris, US'</strong><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">mat-hint</strong><strong class="hljs-tag-slc">&gt;</strong></span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-form-field</span><span class="hljs-tag">&gt;</span>
...
</code></pre>
      </li>
    </ol>
    <p class="normal">At this point, the<a id="_idIndexMarker134"/> subscribe handler will call the server and log its output to the console.</p>
    <div class="note">
      <p class="normal">Observe how this works using Chrome DevTools. Note how often the <code class="inlineCode">search</code> function is run and that we are not handling service errors.</p>
    </div>
    <h2 id="_idParaDest-51" class="heading-2">Limiting user inputs with throttle/debounce</h2>
    <p class="normal">We currently submit a <a id="_idIndexMarker135"/>request to the server with every keystroke. This is not desirable behavior because it can lead to a bad user experience and drain battery life, resulting in wasted network requests and performance issues both on the client and server side. Users make typos; they can change their minds about what they are inputting, and rarely do the first few characters of information input result in useful results.</p>
    <p class="normal">We can still listen to every keystroke, but we don’t have to react to every stroke. By leveraging <code class="inlineCode">throttle</code>/<code class="inlineCode">debounce</code>, we can limit the number of events generated to a predetermined interval and maintain the type-as-you-search functionality.</p>
    <div class="packt_tip">
      <p class="normal">Note that <code class="inlineCode">throttle</code> and <code class="inlineCode">debounce</code> are not functional equivalents, and their behavior will differ from framework to framework. In addition to throttling, we expect to capture the last input that the user has typed. In the <code class="inlineCode">lodash</code> framework, the <code class="inlineCode">throttle</code> function fulfills this requirement, whereas, in <code class="inlineCode">RxJS</code>, <code class="inlineCode">debounce</code> fulfills it.</p>
    </div>
    <p class="normal">It is easy to inject <a id="_idIndexMarker136"/>throttling into the observable stream using <code class="inlineCode">RxJS/debounceTime</code>. Implement <code class="inlineCode">debounceTime</code> with <code class="inlineCode">pipe</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { debounceTime } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>
  <span class="hljs-variable">this</span>.<span class="hljs-property">search</span>.<span class="hljs-property">valueChanges</span>
    .<span class="hljs-title">pipe</span>(<span class="hljs-title">debounceTime</span>(<span class="hljs-number">1000</span>))
    .<span class="hljs-title">subscribe</span>(...)
</code></pre>
    <p class="normal"><code class="inlineCode">debounceTime</code> will, at a maximum, run a search every second, but also run another search after the user has stopped typing. In comparison, <code class="inlineCode">RxJS/throttleTime</code> will only run a search every second, on the second, and will not necessarily capture the last few characters the user may have input.</p>
    <p class="normal">RxJS also has the <code class="inlineCode">throttle</code> and <code class="inlineCode">debounce</code> functions, which you can use to implement custom logic to limit input that is not necessarily time-based.</p>
    <p class="normal">Since this is a time- and event-driven functionality, breakpoint debugging is not feasible. You may monitor the network calls within the <strong class="screenText">Chrome Dev Tools | Network</strong> tab, but to get a more real-time<a id="_idIndexMarker137"/> feel for how often your search handler is being invoked, add a <code class="inlineCode">console.log</code> statement.</p>
    <div class="packt_tip">
      <p class="normal">It is not a good practice to check in code with active <code class="inlineCode">console.log</code> statements. These debug statements make it difficult to read the actual code, which creates a high cost of maintainability. Even if debug statements are commented out, do not check them.</p>
    </div>
    <h2 id="_idParaDest-52" class="heading-2">Input validation and error messages</h2>
    <p class="normal"><code class="inlineCode">FormControl</code> is highly <a id="_idIndexMarker138"/>customizable. It allows you to set a<a id="_idIndexMarker139"/> default initial value, add validators, or listen to changes on <code class="inlineCode">blur</code>, <code class="inlineCode">change</code>, and <code class="inlineCode">submit</code> events, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">new</span> <span class="hljs-title">FormControl</span>(<span class="hljs-string">'Bethesda'</span>, { <span class="hljs-attr">updateOn</span>: <span class="hljs-string">'submit'</span> })
</code></pre>
    <p class="normal">We won’t be initializing <code class="inlineCode">FormControl</code> with a value, but we need to implement a validator to disallow single-character inputs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Import <code class="inlineCode">Validators</code> from <code class="inlineCode">@angular/forms</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">FormControl</span>, <span class="hljs-title">Validators</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>
</code></pre>
      </li>
      <li class="numberedList">Modify <code class="inlineCode">FormControl</code> to add a minimum length validator:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
search = <span class="hljs-keyword">new</span> <span class="hljs-title">FormControl</span>(<span class="hljs-string">''</span>, [<span class="hljs-title">Validators</span>.<span class="hljs-title">minLength</span>(<span class="hljs-number">2</span>)])
</code></pre>
      </li>
      <li class="numberedList">Modify the template to show a validation error message below the hint text:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.component.html</strong></span>
...
<span class="hljs-tag">&lt;</span><span class="hljs-name">form</span><span class="hljs-tag"> </span><span class="code-highlight"><strong class="hljs-attr-slc">style</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"margin-bottom: 32px"</strong></span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-form-field</span><span class="hljs-tag"> </span><span class="hljs-attr">appearance</span><span class="hljs-tag">=</span><span class="hljs-string">"outline"</span><span class="hljs-tag">&gt;</span>
    ...
    @if (search.invalid) {
      <span class="code-highlight"><strong class="hljs-tag-slc">&lt;</strong><strong class="hljs-name-slc">mat-error</strong><strong class="hljs-tag-slc">&gt;</strong></span>
        <span class="code-highlight"><strong class="hljs-slc">Type more than one character to search</strong></span>
      <span class="code-highlight"><strong class="hljs-tag-slc">&lt;/</strong><strong class="hljs-name-slc">mat-error</strong><strong class="hljs-tag-slc">&gt;</strong><strong class="hljs-slc"> </strong></span>
    }
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-form-field</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">form</span><span class="hljs-tag">&gt;</span>
...
</code></pre>
      
    <div class="note">
      <p class="normal">Note the addition of some extra margin to make room for lengthy error messages.</p>
    </div>
    <p class="normal">If you are <a id="_idIndexMarker140"/>handling different kinds of errors, the <code class="inlineCode">hasError</code> syntax in the template can get repetitive. You may want to implement a more scalable solution that can be customized through code, as<a id="_idIndexMarker141"/> shown:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-meta">@if</span> (search.<span class="hljs-property">invalid</span>) {
  <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-error</span><span class="hljs-tag">&gt;</span>
    {{getErrorMessage()}}
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-error</span><span class="hljs-tag">&gt;</span>
}
<span class="hljs-title">getErrorMessage</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">search</span>.<span class="hljs-title">hasError</span>(<span class="hljs-string">'minLength'</span>) ?
    <span class="hljs-string">'Type more than one character to search'</span> : <span class="hljs-string">''</span>;
}
</code></pre></li>
    </ol>




    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Modify the <code class="inlineCode">search</code> function to not execute a search with invalid input, replacing the condition in the existing <code class="inlineCode">if</code> statement:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong><strong class="hljs-slc"> </strong></span>
<span class="hljs-variable">this</span>.<span class="hljs-property">search</span>.<span class="hljs-property">valueChanges</span>
  .<span class="hljs-title">pipe</span>(<span class="hljs-title">debounceTime</span>(<span class="hljs-number">1000</span>))
  .<span class="hljs-title">subscribe</span>(<span class="hljs-function">(</span><span class="hljs-params">search </span><span class="hljs-title">Value</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="code-highlight"><strong class="hljs-slc">!</strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">search</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">invalid</strong></span>) {
      ...
</code></pre>
      </li>
    </ol>
    <p class="normal">Instead of doing a simple check to see whether <code class="inlineCode">searchValue</code> is defined and not an empty string, we can tap into the validation engine for a more robust check by calling <code class="inlineCode">this.search.invalid</code>.</p>
    <p class="normal">For now, we’re done with implementing <code class="inlineCode">search</code> functionality. Next, let’s go over a what-if scenario to see how a template-driven form implementation would appear.</p>
    <h3 id="_idParaDest-53" class="heading-3">Template-driven forms with two-way binding</h3>
    <p class="normal">The alternative to<a id="_idIndexMarker142"/> reactive forms is template-driven forms. If <a id="_idIndexMarker143"/>you’re familiar with <code class="inlineCode">ng-model</code> from AngularJS, you’ll find that the new <code class="inlineCode">ngModel</code> directive is an API-compatible replacement for it.</p>
    <div class="note">
      <p class="normal">Behind the scenes, <code class="inlineCode">ngModel</code> implements <code class="inlineCode">FormControl</code> that automatically attaches itself to <code class="inlineCode">FormGroup</code>. <code class="inlineCode">ngModel</code> can be used at the <code class="inlineCode">&lt;form&gt;</code> level or the individual <code class="inlineCode">&lt;input&gt;</code> level. You can read more about <code class="inlineCode">ngModel</code> at <a href="https://angular.dev/api/forms/NgModel"><span class="url">https://angular.dev/api/forms/NgModel</span></a>.</p>
    </div>
    <p class="normal">In the <code class="inlineCode">stage6</code> example <a id="_idIndexMarker144"/>code of the LocalCast Weather app<a id="_idIndexMarker145"/> repository on GitHub, I have included a template-driven component in <code class="inlineCode">app.component.ts</code> named <code class="inlineCode">&lt;app-city-search-tpldriven&gt;</code> rendered under <code class="inlineCode">&lt;div class="example"&gt;</code>. You can experiment with this component to see what the alternate template implementation looks like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">projects/stage6/src/app/city-search-tpldriven/city-search-tpldriven.component.html</strong></span>
  ...
    <span class="hljs-tag">&lt;</span><span class="hljs-name">input</span><span class="hljs-tag"> </span><span class="hljs-attr">matInput</span><span class="hljs-tag"> </span><span class="hljs-attr">aria-label</span><span class="hljs-tag">=</span><span class="hljs-string">"City or Zip"</span>
<span class="hljs-tag">      [(</span><span class="hljs-attr">ngModel</span><span class="hljs-tag">)]=</span><span class="hljs-string">"model.search"</span>
<span class="hljs-tag">      (</span><span class="hljs-attr">ngModelChange</span><span class="hljs-tag">)=</span><span class="hljs-string">"doSearch($event)"</span><span class="hljs-tag"> </span><span class="hljs-attr">minlength</span><span class="hljs-tag">=</span><span class="hljs-string">"2"</span><span class="hljs-tag"> </span>
<span class="hljs-tag">      </span><span class="hljs-attr">name</span><span class="hljs-tag">=</span><span class="hljs-string">"search"</span><span class="hljs-tag"> #</span><span class="hljs-attr">search</span><span class="hljs-tag">=</span><span class="hljs-string">"ngModel"</span><span class="hljs-tag">&gt;</span>
  ...
    @if(search.invalid) {
      <span class="hljs-tag">&lt;</span><span class="hljs-name">mat-error</span><span class="hljs-tag">&gt;</span>
        Type more than one character to search
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">mat-error</span><span class="hljs-tag">&gt;</span>
    }
  ...
</code></pre>
    <div class="note">
      <p class="normal">Note the <code class="inlineCode">[()]</code> “box of bananas” two-way binding syntax in use with <code class="inlineCode">ngModel</code>.</p>
    </div>
    <p class="normal">The differences in the components are implemented as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">projects/stage6/src/app/city-search-tpldriven/city-search-tpldriven.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">WeatherService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../weather/weather.service'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchTpldrivenComponent</span> { 
  model = {
    <span class="hljs-attr">search</span>: <span class="hljs-string">''</span>,
  }
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">weatherService</span><span class="hljs-params">: </span><span class="hljs-title">WeatherService</span>) {}
    
  <span class="hljs-title">doSearch</span>(<span class="hljs-params">searchValue</span>) {
    <span class="hljs-keyword">const</span> userInput = searchValue.<span class="hljs-title">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title">map</span>(<span class="hljs-params">s</span><span class="hljs-function"> =&gt;</span> s.<span class="hljs-title">trim</span>())
    <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>
      .<span class="hljs-title">getCurrentWeather</span>(userInput[<span class="hljs-number">0</span>], userInput.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ?
        userInput[<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>
      )
      .<span class="hljs-title">subscribe</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(data))
  }
}
</code></pre>
    <p class="normal">As you can see, most of the logic is implemented in the template; as such, you are required to maintain an active mental model of the template and the controller. Any changes to event handlers and validation logic require you to switch back and forth between the two files.</p>
    <p class="normal">Furthermore, we <a id="_idIndexMarker146"/>have lost input limiting and the ability<a id="_idIndexMarker147"/> to prevent service calls when the input is invalid. It is still possible to implement these features, but they require convoluted solutions and do not neatly fit into the new Angular syntax and concepts.</p>
    <p class="normal">Overall, I do not recommend the use of template-driven forms. There may be a few instances where it may be very convenient to use the box-of-bananas syntax. However, this sets a bad precedent for other team members to replicate the same pattern around the application.</p>
    <h1 id="_idParaDest-54" class="heading-1">Component interaction with BehaviorSubject</h1>
    <p class="normal">To <a id="_idIndexMarker148"/>update the current weather information, we need the <code class="inlineCode">citySearch</code> component to interact with the <code class="inlineCode">currentWeather</code> component. There<a id="_idIndexMarker149"/> are four main techniques to enable component interaction in Angular:</p>
    <ul>
      <li class="bulletList">Global events</li>
      <li class="bulletList">Parent components listening for information bubbling up from children components</li>
      <li class="bulletList">Sibling, parent, or children components within a module that works off of similar data streams</li>
      <li class="bulletList">Parent components passing information to children components</li>
    </ul>
    <p class="normal">Let’s explore them in detail in the following sections.</p>
    <h2 id="_idParaDest-55" class="heading-2">Global events</h2>
    <p class="normal">This technique has been <a id="_idIndexMarker150"/>leveraged since the early days of programming in general. In JavaScript, you may have achieved this with global function delegates or jQuery’s event system. In AngularJS, you may have created a service and stored variables within it.</p>
    <p class="normal">In Angular, you can still create a root-level service, store values in it, use Angular’s <code class="inlineCode">EventEmitter</code> class, which is meant for directives, or use <code class="inlineCode">RxJS/Subscription</code> to create a fancy messaging bus for yourself.</p>
    <p class="normal">As a pattern, global events are open to rampant abuse, and rather than helping to maintain a decoupled application architecture, they lead to a global state over time. A global state or a localized state at the controller level, where functions read and write to variables in any given class, is enemy number one of writing maintainable and unit-testable software.</p>
    <p class="normal">Ultimately, if you’re storing all your application data or routing all events in one service to enable component interaction, you’re merely inventing a better mousetrap. A single service will grow large and complex over time. This leads to unforeseen bugs, side effects from unintentional mutations of unrelated data, continuously increasing memory usage because data from previous views can’t be discarded, and low cohesion due to data stored from unrelated components of the application. Overusing a service is an anti-pattern that should be avoided at all costs. In a later section, you will find that, essentially, we will still be using services to enable component interaction; however, I want to point out that there’s a fine line that exists between a flexible architecture that enables decoupling and the global or centralized decoupling approach that does not scale well.</p>
    <h2 id="_idParaDest-56" class="heading-2">Child-parent relationships with event emitters</h2>
    <p class="normal">Your child component<a id="_idIndexMarker151"/> should be completely unaware of its parent. This is key to creating reusable components.</p>
    <p class="normal">We can implement the communication between <code class="inlineCode">CitySearchComponent</code> and the <code class="inlineCode">CurrentWeatherComponent</code>, leveraging <code class="inlineCode">AppComponent</code> as a parent element and letting the <code class="inlineCode">AppComponent</code> controller orchestrate the data.</p>
    <div class="note">
      <p class="normal"><em class="italic">Commit your code now!</em> In the next two sections, you will be making code changes that you will need to discard.</p>
    </div>
    <p class="normal">Let’s see how this<a id="_idIndexMarker152"/> implementation will look:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1"><code class="inlineCode">CitySearchComponent</code> exposes <code class="inlineCode">EventEmitter</code> through an <code class="inlineCode">@Output</code> property:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Component</span>, <span class="hljs-title">OnInit</span>, <span class="hljs-title">Output</span>, <span class="hljs-title">EventEmitter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span> {
  <span class="hljs-meta">@Output</span>() searchEvent = <span class="hljs-keyword">new</span> <span class="hljs-title">EventEmitter</span>&lt;<span class="hljs-built_in">string</span>&gt;()
  ...
  <span class="hljs-variable">this</span>.<span class="hljs-property">search</span>.<span class="hljs-property">valueChanges</span>
    .<span class="hljs-title">pipe</span>(<span class="hljs-title">debounceTime</span>(<span class="hljs-number">1000</span>))
    .<span class="hljs-title">subscribe</span>(<span class="hljs-function">(</span><span class="hljs-params">search </span><span class="hljs-title">Value</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span><span class="hljs-function">) =&gt;</span> {
      <span class="hljs-keyword">if</span> (!<span class="hljs-variable">this</span>.<span class="hljs-property">search</span>.<span class="hljs-property">invalid</span>) {
        <span class="hljs-variable">this</span>.<span class="hljs-property">searchEvent</span>.<span class="hljs-title">emit</span>(searchValue)
      }
    })
  ...
}
</code></pre>
      </li>
      <li class="numberedList"><code class="inlineCode">AppComponent</code> consumes that and calls <code class="inlineCode">weatherService</code>, setting the <code class="inlineCode">currentWeather</code> variable:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">WeatherService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./weather/weather.service'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">ICurrentWeather</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interfaces'</span>
...
<span class="hljs-attr">template</span>: <span class="hljs-string">`</span>
<span class="hljs-string">  ...</span>
<span class="hljs-string">    &lt;app-city-search (searchEvent)="doSearch($event)"&gt;</span>
<span class="hljs-string">    &lt;/app-city-search&gt;</span>
<span class="hljs-string">  ...</span>
<span class="hljs-string">`</span>,
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> { 
  <span class="hljs-attr">currentWeather</span>: <span class="hljs-title">ICurrentWeather</span> 
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">weatherService</span><span class="hljs-params">: </span><span class="hljs-title">WeatherService</span>) { }
  <span class="hljs-title">doSearch</span>(<span class="hljs-params">searchValue</span>) {
    <span class="hljs-keyword">const</span> userInput = searchValue.<span class="hljs-title">split</span>(<span class="hljs-string">','</span>).<span class="hljs-title">map</span>(
      <span class="hljs-params">s</span><span class="hljs-function"> =&gt;</span> s.<span class="hljs-title">trim</span>()) 
    <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>
      .<span class="hljs-title">getCurrentWeather</span>(
        userInput[<span class="hljs-number">0</span>], userInput.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ?
        userInput[<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>
    )
    .<span class="hljs-title">subscribe</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">currentWeather</span> = data)
  }
}
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">Note that we are binding to <code class="inlineCode">searchEvent</code> with the parenthesis syntax. The <code class="inlineCode">$event</code> variable automatically captures the output from the event and passes it into the <code class="inlineCode">doSearch</code> method.</p>
    </div>
    <p class="normal">We successfully <a id="_idIndexMarker153"/>bubbled the information up to the parent component, but we must also be able to pass it down to <code class="inlineCode">CurrentWeatherComponent</code>.</p>
    <h2 id="_idParaDest-57" class="heading-2">Parent-child relationships with input binding</h2>
    <p class="normal">By definition, the <a id="_idIndexMarker154"/>parent component will know what child components it is working with. Since the <code class="inlineCode">currentWeather</code> property is bound to the <code class="inlineCode">current</code> property on <code class="inlineCode">CurrentWeatherComponent</code>, the results are passed down for display. This is achieved by creating an <code class="inlineCode">@Input</code> property:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Component</span>, <span class="code-highlight"><strong class="hljs-title-slc">Input</strong></span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentWeatherComponent</span> { 
  <span class="code-highlight"><strong class="hljs-meta-slc">@Input</strong><strong class="hljs-slc">()</strong></span> <span class="hljs-attr">current</span>: <span class="hljs-title">ICurrentWeather</span>
  ...
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">Note that the <code class="inlineCode">ngOnInit</code> function of <code class="inlineCode">CurrentWeatherComponent</code> is now superfluous and can be removed.</p>
    </div>
    <p class="normal">You can then update <code class="inlineCode">AppComponent</code> to bind the data to the current weather:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-attr">template</span>: <span class="hljs-string">`</span>
<span class="hljs-string">  ...</span>
<span class="hljs-string">  &lt;app-current-weather </span><span class="code-highlight"><strong class="hljs-string-slc">[current]="currentWeather"</strong></span><span class="hljs-string">&gt;</span>
<span class="hljs-string">  &lt;/app-current-weather&gt;</span>
<span class="hljs-string">  ...</span>
<span class="hljs-string">`</span>
</code></pre>
    <p class="normal">At this point, your code should work! Try searching for a city. If <code class="inlineCode">CurrentWeatherComponent</code> updates, then success!</p>
    <p class="normal">The event<a id="_idIndexMarker155"/> emitter to input binding approach is appropriate in cases where you are creating well-coupled components or user controls, and the child is not consuming any external data. A good demonstrator for this might be by adding forecast information to <code class="inlineCode">CurrentWeatherComponent</code> as shown:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_05.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.5: Weather forecast wireframe</p>
    <p class="normal">Each day of the week can be implemented as a component that is repeated using <code class="inlineCode">@for</code>, and it will be perfectly reasonable for <code class="inlineCode">CurrentWeatherComponent</code> to retrieve and bind this information to its child component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-meta">@for</span> (dailyForecast <span class="hljs-keyword">of</span> forecastArray; track dailyForecast) {
  <span class="hljs-tag">&lt;</span><span class="hljs-name">app-mini-forecast</span><span class="hljs-tag"> [</span><span class="hljs-attr">forecast</span><span class="hljs-tag">]=</span><span class="hljs-string">"dailyForecast"</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">app-mini-forecast</span><span class="hljs-tag">&gt;</span>
}
</code></pre>
    <p class="normal">In general, if you’re working with data-driven components, the parent-child or child-parent communication pattern results in an inflexible architecture, making it difficult to reuse or rearrange your components. A good example of tight coupling is when we imported <code class="inlineCode">WeatherService</code> in <code class="inlineCode">app.component.ts</code>. Note that <code class="inlineCode">AppComponent</code> should have no idea about <code class="inlineCode">WeatherService</code>; its only job is to lay out several components. Given ever-changing business <a id="_idIndexMarker156"/>requirements and design, this is an important lesson to remember.</p>
    <div class="note">
      <p class="normal"><em class="italic">Discard changes from the two sections</em> before moving on. We will instead be implementing an alternate solution.</p>
    </div>
    <p class="normal">Next, we cover a better way for two components to interact with each other without introducing additional coupling with subjects.</p>
    <h2 id="_idParaDest-58" class="heading-2">Sibling interactions with subjects</h2>
    <p class="normal">The main<a id="_idIndexMarker157"/> reason for components to interact is to send or receive updates to data either provided by the user or received from the server. In Angular, your services expose <code class="inlineCode">RxJS/Observable</code> endpoints, which are data streams that your components can subscribe to. <code class="inlineCode">RxJS/Observer</code> complements <code class="inlineCode">RxJS/Observable</code> as a consumer of events emitted by <code class="inlineCode">Observable</code>. <code class="inlineCode">RxJS/Subject</code> brings the two functionalities together in an easy-to-work-with package.</p>
    <p class="normal">You can essentially describe a stream that belongs to a particular set of data, such as the current weather data that is being displayed, with subjects:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Subject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWeatherService</span> { 
  <span class="hljs-attr">currentWeather$</span>: <span class="hljs-title">Subject</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
  ...
}
</code></pre>
    <p class="normal"><code class="inlineCode">currentWeather$</code> is still a data stream and does not simply represent one data point. You can subscribe to changes to <code class="inlineCode">currentWeather$</code> data using <code class="inlineCode">subscribe</code>, or you can publish changes to it using <code class="inlineCode">next</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
currentWeather$.<span class="hljs-title">subscribe</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> (<span class="hljs-variable">this</span>.<span class="hljs-property">current</span> = data))
  currentWeather$.<span class="hljs-title">next</span>(newData)
</code></pre>
    <div class="packt_tip">
      <p class="normal">Note the naming convention for the <code class="inlineCode">currentWeather$</code> property, which is postfixed with <code class="inlineCode">$</code>. This is the naming convention for observable properties.</p>
    </div>
    <p class="normal">The default<a id="_idIndexMarker158"/> behavior of <code class="inlineCode">Subject</code> is very much like generic pub/sub mechanisms, such as jQuery events. However, in an asynchronous world where components are loaded or unloaded in unpredictable ways, using the default <code class="inlineCode">Subject</code> is not very useful.</p>
    <p class="normal">There are three advanced variants of subjects:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">ReplaySubject</code> remembers and caches data points that occurred within the data stream so that a subscriber can replay old events at any given time.</li>
      <li class="bulletList"><code class="inlineCode">BehaviorSubject</code> remembers only the last data point while listening for new data points.</li>
      <li class="bulletList"><code class="inlineCode">AsyncSubject</code> is for one-time-only events that are not expected to reoccur.</li>
    </ul>
    <p class="normal"><code class="inlineCode">ReplaySubject</code> can have severe memory and performance implications on your application, so it should be used carefully. In the case of <code class="inlineCode">CurrentWeatherComponent</code>, we are only interested in displaying the latest weather data received, but through user input or other events, we are open to receiving new data to keep <code class="inlineCode">CurrentWeatherComponent</code> up to date. <code class="inlineCode">BehaviorSubject</code> would be the appropriate mechanism to meet these needs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add <code class="inlineCode">currentWeather$</code> as a read-only property to <code class="inlineCode">IWeatherService</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">BehaviorSubject</span>, <span class="hljs-title">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IWeatherService</span> {
  <span class="code-highlight"><strong class="hljs-keyword-slc">readonly</strong><strong class="hljs-slc"> </strong><strong class="hljs-attr-slc">currentWeather$</strong><strong class="hljs-slc">: </strong><strong class="hljs-title-slc">BehaviorSubject</strong><strong class="hljs-slc">&lt;</strong><strong class="hljs-title-slc">ICurrentWeather</strong><strong class="hljs-slc">&gt;</strong></span>
  ...
}
</code></pre>
     
    <p class="normal"><code class="inlineCode">currentWeather$</code> is declared as read-only because its <code class="inlineCode">BehaviorSubject</code> should not be reassigned. It’s our data anchor or a reference, not a copy of the data itself. Any updates to the value should be sent by calling the <code class="inlineCode">next</code> function on the property.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Define <code class="inlineCode">BehaviorSubject</code> in <code class="inlineCode">WeatherService</code> and set a default value:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWeatherService</span> {
  <span class="hljs-keyword">readonly</span> currentWeather$ =
    <span class="hljs-keyword">new</span> <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;({ 
    <span class="hljs-attr">city</span>: <span class="hljs-string">'--'</span>,
    <span class="hljs-attr">country</span>: <span class="hljs-string">'--'</span>,
    <span class="hljs-attr">date</span>: <span class="hljs-title">Date</span>.<span class="hljs-title">now</span>(),
    <span class="hljs-attr">image</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">temperature</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">''</span>,
  })
...
}
</code></pre>
      </li>
      <li class="numberedList">Add a <a id="_idIndexMarker159"/>new function named <code class="inlineCode">updateCurrentWeather</code>, which will trigger <code class="inlineCode">getCurrentWeather</code> and update the value of <code class="inlineCode">currentWeather$</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-title">updateCurrentWeather</span>(<span class="hljs-attr">search</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, 
  country?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> { 
  <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeather</span>(search, country)
    .<span class="hljs-title">subscribe</span>(<span class="hljs-params">weather</span><span class="hljs-function"> =&gt;</span> 
      <span class="hljs-variable">this</span>.<span class="hljs-property">currentWeather$</span>.<span class="hljs-title">next</span>(weather)
    )
}
...
</code></pre>
      </li>
      <li class="numberedList">Update <code class="inlineCode">IWeatherService</code> with the new function so that it appears as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IWeatherService</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">currentWeather$</span>: <span class="hljs-title">BehaviorSubject</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; 
  <span class="hljs-title">getCurrentWeather</span>(<span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, country?: <span class="hljs-built_in">string</span>):
    <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
  <span class="hljs-title">getCurrentWeatherByCoords</span>(<span class="hljs-attr">coords</span>: <span class="hljs-title">Coordinates</span>):
    <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
    <span class="code-highlight"><strong class="hljs-title-slc">updateCurrentWeather</strong><strong class="hljs-slc">(</strong></span>
      <span class="code-highlight"><strong class="hljs-attr-slc">search</strong><strong class="hljs-slc">: </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc"> | </strong><strong class="hljs-built_in-slc">number</strong><strong class="hljs-slc">, country?: </strong><strong class="hljs-built_in-slc">string </strong></span>    <span class="code-highlight"><strong class="hljs-slc">): </strong><strong class="hljs-built_in-slc">void</strong></span>
}
</code></pre>
      </li>
      <li class="numberedList">Update <code class="inlineCode">CurrentWeatherComponent</code> to subscribe to the new <code class="inlineCode">BehaviorSubject</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
  <span class="hljs-title">ngOnInit</span>() { 
    <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-property">currentWeather$</span>
      .<span class="hljs-title">subscribe</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> (<span class="hljs-variable">this</span>.<span class="hljs-property">current</span> = data))
  }
...
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">CitySearchComponent</code>, update the <code class="inlineCode">getCurrentWeather</code> function call to utilize the<a id="_idIndexMarker160"/> new <code class="inlineCode">updateCurrentWeather</code> function:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
...
  <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="code-highlight"><strong class="hljs-title-slc">updateCurrentWeather</strong></span>( 
    userInput[<span class="hljs-number">0</span>],
    userInput.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? userInput[<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>
  )
...
</code></pre>
      </li>
      <li class="numberedList">Test your app in the browser; it should appear as follows:
    <figure class="mediaobject"><img src="../Images/B20960_02_06.png" alt="A screenshot of a weather forecast  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.6: Weather information for Bursa, Turkey</p></li>
    </ol>
    <p class="normal">When you <a id="_idIndexMarker161"/>type in a new city, the component should update to include the current weather information for that city. We can move the <strong class="screenText">Add city search capability...</strong> task to the <strong class="screenText">Done</strong> column, as shown on our Kanban board:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_07.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.7: GitHub project Kanban board status</p>
    <p class="normal">We have a functional app. However, we have introduced a memory leak in the way we handled the subscription to <code class="inlineCode">currentWeather$</code>. In the next section, we’ll review how memory leaks can happen and avoid them altogether by using <code class="inlineCode">first</code> and <code class="inlineCode">takeUntilDestroyed</code> operations.</p>
    <h1 id="_idParaDest-59" class="heading-1">Managing subscriptions</h1>
    <p class="normal">Subscriptions<a id="_idIndexMarker162"/> are a convenient way to read a value from a data stream for your application logic. If unmanaged, they can create memory leaks in your application. A leaky application will consume ever-increasing amounts of RAM, eventually leading the browser tab to become unresponsive, leading to a negative perception of your app and, even worse, potential data loss, which can frustrate end users.</p>
    <p class="normal">The source of <a id="_idIndexMarker163"/>a memory leak may not be obvious. In <code class="inlineCode">CurrentWeatherComponent</code>, we inject <code class="inlineCode">WeatherSevice</code> to access the value of <code class="inlineCode">BehaviorSubject</code>,<code class="inlineCode"> currentWeather$</code>. If we mismanage subscriptions,<code class="inlineCode">currentWeather$</code>, we can end up with leaks in the component or the service.</p>
    <h2 id="_idParaDest-60" class="heading-2">Lifecycle of services</h2>
    <p class="normal">By default, Angular <a id="_idIndexMarker164"/>services are <strong class="keyWord">shared instance services</strong> or <a id="_idIndexMarker165"/>singletons automatically registered to <a id="_idIndexMarker166"/>a <strong class="keyWord">root provider</strong>. This means that, once created in memory, they’re kept alive as long as the app or feature module they’re a part of remains in memory. See the following example of a shared instance service:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Injectable</span>({
  <span class="code-highlight"><strong class="hljs-attr-slc">providedIn</strong><strong class="hljs-slc">: 'root'</strong></span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWeatherService</span>
...
</code></pre>
    <p class="normal">From a practical perspective, this will mean that most services in your application will live in the memory for the application’s lifetime. However, the lifetime of a component may be much shorter, or there could be multiple instances of the same component created repeatedly.</p>
    <p class="normal">Additionally, there are use cases where a component needs its own instance or a copy of the service (e.g., caching values input into a form or displaying weather for different cities simultaneously). To create <strong class="keyWord">multiple instance services,</strong> see the example below:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWeatherService</span>
...
</code></pre>
    <p class="normal">You would then provide the service with a <strong class="keyWord">component provider</strong>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-current-weather'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="code-highlight"><strong class="hljs-attr-slc">providers</strong><strong class="hljs-slc">: [</strong><strong class="hljs-title-slc">WeatherService</strong><strong class="hljs-slc">]</strong></span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentWeatherComponent</span> {
...
</code></pre>
    <p class="normal">In this case, the service would be destroyed when the component is destroyed. But this is not protection against memory leaks. If we don’t manage the interactions between long-lived and short-lived objects carefully, we can end up with dangling references between objects, leading to memory leaks.</p>
    <h2 id="_idParaDest-61" class="heading-2">Exposé of a memory leak</h2>
    <p class="normal">When we subscribe<a id="_idIndexMarker167"/> to <code class="inlineCode">currentWeather$</code>, we attach an event handler to it so that <code class="inlineCode">CurrentWeatherComponent</code> can react to value changes pushed to <code class="inlineCode">BehaviorSubject</code>. This presents a problem when the component needs to be destroyed.</p>
    <p class="normal">In managed languages such as JavaScript, memory is managed by the garbage collector, or GC for short, as opposed to having to allocate and deallocate memory by hand in unmanaged languages such as C or C++. At a very high level, the GC periodically scans the stack for objects not referenced by other objects.</p>
    <p class="normal">If an object is found to be dereferenced, then the space it takes up in the stack can be freed up. However, if an unused object still has a reference to another object that is still in use, it can’t be garbage collected. The GC is not magical and can’t read our minds. When an object is unused and can’t be deallocated, the memory taken up by the object can never be used for another purpose so long as your application is running. This is considered a memory leak.</p>
    <p class="normal">My colleague, Brendon Caulkins, provides a helpful analogy:</p>
    <blockquote class="packt_quote">
      <p class="quote">Imagine the memory space of the browser as a parking lot; every time we assign a value or create a subscription, we park a car in that lot. If we happen to abandon a car, we still leave the parking spot occupied; no one else can use it. If all the applications in the browser do this, or we do it repeatedly, you can imagine how quickly the parking lot gets full, and we never get to run our application.</p>
    </blockquote>
    <p class="normal">Next, let’s see how we can ensure we don’t abandon our car in the parking lot.</p>
    <h2 id="_idParaDest-62" class="heading-2">Unsubscribing from a subscription</h2>
    <p class="normal">Subscriptions<a id="_idIndexMarker168"/> or event handlers create references to other objects, such as from a short-lived component to a long-lived service. Granted, in our case, <code class="inlineCode">CurrentWeatherComponent</code> is also a singleton, but that could change if we added more features to the app, navigating from page to page or displaying weather from multiple cities at once. If we don’t unsubscribe from <code class="inlineCode">currentWeather$</code>, then any instance of <code class="inlineCode">CurrentWeatherComponent</code> would be stuck in memory. We subscribe in <code class="inlineCode">ngOnInit</code>, so we must unsubscribe in <code class="inlineCode">ngOnDestroy</code>. <code class="inlineCode">ngOnDestroy</code> is called when Angular determines that the framework no longer uses the component.</p>
    <p class="normal">Let’s see an<a id="_idIndexMarker169"/> example of how you can unsubscribe from a subscription in the sample code in the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">example</strong></span>
<span class="hljs-keyword">import</span> { ..., <span class="hljs-title">OnDestroy</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { ..., <span class="hljs-title">Subscription</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentWeatherComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span>, <span class="hljs-title">OnDestroy</span> { 
  <span class="hljs-attr">currentWeatherSubscription</span>: <span class="hljs-title">Subscription</span>
  ...
  <span class="hljs-title">ngOnInit</span>() { 
    <span class="hljs-variable">this</span>.<span class="hljs-property">currentWeatherSubscription</span> =
      <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-property">currentWeather$</span>
        .<span class="hljs-title">subscribe</span>(<span class="hljs-function">(</span><span class="hljs-params">data</span><span class="hljs-function">) =&gt;</span> (<span class="hljs-variable">this</span>.<span class="hljs-property">current</span> = data))
  }
  <span class="hljs-title">ngOnDestroy</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable">this</span>.<span class="hljs-property">currentWeatherSubscription</span>.<span class="hljs-title">unsubscribe</span>()
  }
...
</code></pre>
    <p class="normal">First, we need to implement the <code class="inlineCode">OnDestroy</code> interface for the component. Then, we update <code class="inlineCode">ngOnInit</code> to store a reference to the subscription in a property named <code class="inlineCode">currentWeatherSubscription</code>. Finally, in <code class="inlineCode">ngOnDestroy</code>, we can call the <code class="inlineCode">unsubscribe</code> method.</p>
    <p class="normal">Should our component get destroyed, it will no longer result in a memory leak. However, if we have multiple subscriptions in a component, this leads to tedious amounts of coding.</p>
    <div class="packt_tip">
      <p class="normal">Note that in <code class="inlineCode">CitySearchComponent</code>, we subscribe to the <code class="inlineCode">valueChanges</code> event of a <code class="inlineCode">FormControl</code> object. We don’t need to manage the subscription to this event because <code class="inlineCode">FormControl</code> is a child object of our component. When the parent component is dereferenced from all objects, all its children can be safely collected by the GC.</p>
    </div>
    <p class="normal">Subscribing to<a id="_idIndexMarker170"/> values in data streams itself can be considered an anti-pattern because you switch your programming model from reactive to imperative. But of course, we must subscribe at least once to activate the data stream. In the next section, we will cover how you ensure you don’t leak memory when subscribing.</p>
    <h2 id="_idParaDest-63" class="heading-2">Subscribe with first or takeUntilDestroyed</h2>
    <p class="normal">By default, an observable stream doesn’t end. Given how engrained RxJS is within every Angular operation, this is rarely the desired outcome. There are two common strategies that we can apply at the time of subscribing to a resource so we can ensure that streams will complete predictably and won’t lead to memory leaks.</p>
    <p class="normal">The first strategy is, well, the first <a id="_idIndexMarker171"/>method. Observe the <code class="inlineCode">updateCurrentWeather</code> method in <code class="inlineCode">WeatherService</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { map, switchMap, first } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span> 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWeatherService</span>{
  ...
    <span class="hljs-title">updateCurrentWeather</span>(<span class="hljs-attr">searchText</span>: <span class="hljs-built_in">string</span>, country?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
      <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeather</span>(searchText, country)
        .<span class="hljs-title">pipe</span>(<span class="hljs-title">first</span>())
        .<span class="hljs-title">subscribe</span>(<span class="hljs-function">(</span><span class="hljs-params">weather</span><span class="hljs-function">) =&gt;</span> <span class="hljs-variable">this</span>.<span class="hljs-property">currentWeather$</span>.<span class="hljs-title">next</span>(weather))
    }  
  ...
</code></pre>
    <p class="normal">In the example above, we intend to get the current weather and display it – and do this only once per request. By piping in a <code class="inlineCode">first()</code> call into the observable stream, we instruct RxJS to complete the stream after it receives one result. This way, when a resource that utilizes this stream is being GC’d, the relevant RxJS objects will not cause a leak.</p>
    <p class="normal">The second strategy is <code class="inlineCode">takeUntilDestroyed</code>. The <code class="inlineCode">first()</code> strategy doesn’t make sense with components that will update multiple times, that will update multiple times. For example <code class="inlineCode">CurrentWeatherComponent</code> can update after the user enters new search text, so we want to receive updates as long as the component exists. See the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { takeUntilDestroyed } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/rxjs-interop'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentWeatherComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OnInit</span> {
  <span class="hljs-keyword">private</span> destroyRef = <span class="hljs-title">inject</span>(<span class="hljs-title">DestroyRef</span>);
  ...
  <span class="hljs-title">ngOnInit</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>
      .<span class="hljs-title">getCurrentWeather</span>(<span class="hljs-string">'Bethesda'</span>, <span class="hljs-string">'US'</span>)
      .<span class="hljs-title">pipe</span>(<span class="hljs-title">takeUntilDestroyed</span>(<span class="hljs-variable">this</span>.<span class="hljs-property">destroyRef</span>))
      .<span class="hljs-title">subscribe</span>(<span class="hljs-function">(</span><span class="hljs-params">data</span><span class="hljs-function">) =&gt;</span> (<span class="hljs-variable">this</span>.<span class="hljs-property">current</span> = data))
  }
  ...
</code></pre>
    <p class="normal"><code class="inlineCode">takeUntilDestroyed</code> can only be used within an injector context, i.e., a constructor. When using it in lifecycle hook calls, like <code class="inlineCode">ngOnInit</code>, we must inject <code class="inlineCode">DestroyRef</code> and pass it into the function. It automatically registers itself, so when the component is destroyed, it completes the stream. This way, the component can receive messages while it’s needed, but with no risk of leaking memory.</p>
    <p class="normal">By applying<a id="_idIndexMarker172"/> these alongside the <code class="inlineCode">subscribe</code> method, we don’t have to rely on difficult-to-trace unsubscribe methods, and we can easily verify their implementation with a quick search of the word subscribe.</p>
    <p class="normal">The best part is no part at all. Next, let’s see how we can consume an observable component without subscribing to it all.</p>
    <h1 id="_idParaDest-64" class="heading-1">Coding in the reactive paradigm</h1>
    <p class="normal">As covered in <em class="chapterRef">Chapter 1</em>, <em class="italic">Angular’s Architecture and Concepts</em>, we should only subscribe to an observable stream to activate it. If we treat a <code class="inlineCode">subscribe</code> function as an event handler, we implement our code<a id="_idIndexMarker173"/> imperatively.</p>
    <div class="packt_tip">
      <p class="normal">Seeing anything other than an empty <code class="inlineCode">subscribe()</code> call in your code base should be considered a red flag because it deviates from the reactive paradigm.</p>
    </div>
    <p class="normal">In reactive programming, when you subscribe to an event in a reactive stream, you shift your coding paradigm from reactive programming to imperative programming. There are two places in our application where we subscribe, one in <code class="inlineCode">CurrentWeatherComponent</code>, and the other in <code class="inlineCode">CitySearchComponent</code>.</p>
    <p class="normal">Let’s start by fixing <code class="inlineCode">CurrentWeatherComponent</code> so we don’t mix paradigms.</p>
    <h2 id="_idParaDest-65" class="heading-2">Binding to an observable with an async pipe</h2>
    <p class="normal">Angular has been designed <a id="_idIndexMarker174"/>to be an asynchronous framework from the ground up. You can get the most out of Angular by staying in the reactive paradigm. It can feel unnatural to do so at first, but Angular provides all the tools you need to reflect the current state of your application to the user without having to shift to imperative programming.</p>
    <p class="normal">You may leverage the <code class="inlineCode">async</code> pipe in your templates to reflect the current value of an observable. Let’s update <code class="inlineCode">CurrentWeatherComponent</code> to use the <code class="inlineCode">async</code> pipe:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start by replacing <code class="inlineCode">current: ICurrentWeather</code> with an observable property:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">current$</span>: <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
</code></pre>
      </li>
      <li class="numberedList">In the constructor, assign <code class="inlineCode">weatherService.currentWeather$</code> to <code class="inlineCode">current$:</code>
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentWeatherComponent</span> {
  <span class="hljs-attr">current$</span>: <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">weatherService</span><span class="hljs-params">: </span><span class="hljs-title">WeatherService</span>) {
    <span class="hljs-variable">this</span>.<span class="hljs-property">current$</span> = <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-property">currentWeather$</span>
  }
  ...
</code></pre>
      </li>
      <li class="numberedList">Remove all code related to <code class="inlineCode">SubSink</code>, <code class="inlineCode">ngOnInit</code>, and <code class="inlineCode">ngOnDestroy</code>.</li>
      <li class="numberedList">Update the template to so you can bind to <code class="inlineCode">current$</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">html</strong></span>
<span class="hljs-meta">@if</span> (current$ | <span class="hljs-keyword">async</span>; <span class="hljs-keyword">as</span> current) {
  <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span> ... <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
}
</code></pre>
     
    <p class="normal">The <code class="inlineCode">async</code> pipe automatically subscribes to the current value of <code class="inlineCode">current$</code> and makes it available to the template to be used imperatively as the <code class="inlineCode">current</code> variable. The beauty of this approach is that the <code class="inlineCode">async</code> pipe implicitly manages the subscription, so you don’t have to worry about unsubscribing.</p> </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Remove the <code class="inlineCode">@else { &lt;div&gt;no data&lt;/div&gt; }</code> block, which is no longer needed because <code class="inlineCode">BehaviorSubject</code> is always initialized.</li>
    </ol>
    <p class="normal">So far, the <a id="_idIndexMarker175"/>reactive paradigm has allowed us to streamline and clean up our code.</p>
    <div class="note">
      <p class="normal">The async pipe allows you to display a loading message with simple <code class="inlineCode">if-else</code> logic. To display a message while your observable is resolved, see the following technique:</p>
      <pre class="programlisting code"><code class="hljs-code"><code style="font-weight: bold;" class="codeHighlighted">example</code>
@if (current$ | async; as current) {
  &lt;div&gt;{{current}}&lt;/div&gt;
} @else {
  &lt;div&gt;Loading…&lt;/div&gt;
}
</code></pre>
    </div>
    <p class="normal">Next, let’s further improve our code.</p>
    <h2 id="_idParaDest-66" class="heading-2">Tapping into an observable stream</h2>
    <p class="normal">The <code class="inlineCode">CitySearchComponent</code> implements a<a id="_idIndexMarker176"/> callback within a <code class="inlineCode">subscribe</code> statement when firing the <code class="inlineCode">search</code> function. This leads to an imperative style of coding and mindset. The danger with switching programming paradigms is that you can introduce unintentional side effects to your code base by making it easier to store state or create bugs.</p>
    <p class="normal">Let’s refactor <code class="inlineCode">CitySearchComponent</code> to be in the reactive functional programming style, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { debounceTime, <span class="code-highlight"><strong class="hljs-slc">filter, tap</strong></span> } <span class="hljs-keyword">from</span> 'rxjs/operators'
<span class="hljs-keyword">import</span> { <span class="code-highlight"><strong class="hljs-slc">takeUntilDestroyed</strong></span> } <span class="hljs-keyword">from</span> '<span class="hljs-meta">@angular</span>/core/rxjs-interop'
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchComponent</span> {
  search = <span class="hljs-keyword">new</span> <span class="hljs-title">FormControl</span>('', 
    [<span class="code-highlight"><strong class="hljs-title-slc">Validators</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">required</strong></span>, <span class="hljs-title">Validators</span>.<span class="hljs-title">minLength</span>(<span class="hljs-number">2</span>)])
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">weatherService</span><span class="hljs-params">: </span><span class="hljs-title">WeatherService</span>) { 
    <span class="code-highlight"><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">search</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">valueChanges</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">pipe</strong><strong class="hljs-slc">(</strong></span>
        <span class="code-highlight"><strong class="hljs-title-slc">takeUntilDestroyed</strong><strong class="hljs-slc">(),</strong></span>
        <span class="code-highlight"><strong class="hljs-title-slc">filter</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">() =&gt;</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">search</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">valid</strong><strong class="hljs-slc">),</strong></span>
        <span class="code-highlight"><strong class="hljs-title-slc">debounceTime</strong><strong class="hljs-slc">(</strong><strong class="hljs-number-slc">1000</strong><strong class="hljs-slc">),</strong></span>
        <span class="code-highlight"><strong class="hljs-title-slc">tap</strong><strong class="hljs-slc">(</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-attr-slc">searchValue</strong><strong class="hljs-params-slc">: </strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-function-slc">) =&gt;</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">this</strong><strong class="hljs-slc">.</strong><strong class="hljs-title-slc">doSearch</strong><strong class="hljs-slc">(searchValue))</strong></span>
        <span class="code-highlight"><strong class="hljs-title-slc">takeUntilDestroyed()</strong></span>
      <span class="code-highlight"><strong class="hljs-slc">).</strong><strong class="hljs-title-slc">subscribe</strong><strong class="hljs-slc">()</strong></span>
}
<span class="hljs-title">doSearch</span>(<span class="hljs-attr">searchValue</span><span class="hljs-params">: </span><span class="hljs-built_in">string</span>) {
  <span class="hljs-keyword">const</span> userInput = searchValue.<span class="hljs-title">split</span>(',').<span class="hljs-title">map</span>(<span class="hljs-params">s</span><span class="hljs-function"> =&gt;</span> s.<span class="hljs-title">trim</span>())
  <span class="hljs-keyword">const</span> searchText = userInput[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> country = userInput.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? userInput[<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>
  <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-title">updateCurrentWeather</span>(searchText, country)
}
}
</code></pre>
    <p class="normal">In the preceding code, we removed the <code class="inlineCode">OnInit</code> implementation and implemented our filtering logic reactively. The <code class="inlineCode">tap</code> operator will only get triggered if <code class="inlineCode">this.search</code> is valid.</p>
    <div class="note">
      <p class="normal"><code class="inlineCode">constructor</code> should only be used when working with properties and events local to the class context. In this case, search is initialized when defined, and <code class="inlineCode">valueChanges</code> can only be triggered by a user interacting with the component. So, it’s okay to set up the subscribe logic in it.</p>
      <p class="normal">However, if you’re referencing any properties within the template, <code class="inlineCode">@Input</code> variables, or registering an external service call, you must use <code class="inlineCode">ngOnInit</code>. Otherwise, you will run into render errors or unpredictable behavior. This is because template properties, including <code class="inlineCode">@Input</code> variables, won’t be accessible until <code class="inlineCode">ngOnInit</code> is called. Further, external service calls may return a response before the component is initialized, leading to change detection errors.</p>
      <p class="normal">Simply put, 99% of the time you should use <code class="inlineCode">ngOnInit</code>.</p>
    </div>
    <p class="normal">In addition, <code class="inlineCode">doSearch</code> is called in a functional context, making it very difficult to reference any <a id="_idIndexMarker177"/>other class property within the function. This reduces the chances of the state of the class impacting the outcome of our function. As a result, <code class="inlineCode">doSearch</code> is a composable and unit-testable function, whereas in the previous implementation, it would have been very challenging to unit test <code class="inlineCode">ngOnInit</code> in a straightforward manner.</p>
    <div class="packt_tip">
      <p class="normal">Note that <code class="inlineCode">subscribe()</code> must be called on <code class="inlineCode">valueChanges</code> to activate the observable data stream. Otherwise, no event will fire.</p>
    </div>
    <p class="normal">The fact that we didn’t need to implement <code class="inlineCode">ngOnInit</code> reflects the truly asynchronous nature of our code, which is independent of the lifecycle or state of the application. However, you should stick with <code class="inlineCode">ngOnInit</code> as a general best practice.</p>
    <p class="normal">With our refactoring complete, the app should function the same as before but with less boilerplate code. Now, let’s look into enhancing our app to handle postal codes from any country.</p>
    <h1 id="_idParaDest-67" class="heading-1">Chaining API calls</h1>
    <p class="normal">Currently, our app can only <a id="_idIndexMarker178"/>handle 5-digit numerical postal or zip codes from the US. A <a id="_idIndexMarker179"/>postal code such as <code class="inlineCode">22201</code> is easy to differentiate from a city name with a simplistic conditional such as <code class="inlineCode">typeof search === 'string'</code>. However, postal codes can vary widely from country to country, the UK being a great example, with postal codes such as <code class="inlineCode">EC2R 6AB</code>. Even if we had a perfect understanding of how postal codes are formatted for every country, we still couldn’t ensure that the user didn’t fat-finger a slightly incorrect postal code. Today’s sophisticated users expect web applications to be resilient toward such mistakes. However, as web developers, we can’t be expected to code up a universal postal code validation service by hand. Instead, we need to leverage an external service before we send our request to OpenWeatherMap APIs. Let’s explore how we can chain back-to-back API calls that rely on each other.</p>
    <div class="note">
      <p class="normal">After the first edition of this book was published, I received some passionate reader feedback on their disappointment that the sample app could only support US zip codes. I’ve implemented this feature because it demonstrates how simple requests can introduce unplanned complexity to your apps. As a bonus, the app now works worldwide.</p>
    </div>
    <p class="normal">Let’s add a new item, <strong class="screenText">Support international zip codes</strong>, to the backlog and move it to <strong class="screenText">In progress</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_08.png" alt="A screenshot of a chat  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.8: Adding an international zip codes story</p>
    <h2 id="_idParaDest-68" class="heading-2">Implementing a postal code service</h2>
    <p class="normal">To properly understand<a id="_idIndexMarker180"/> whether the user inputs a valid postal code versus the name of a city, we must rely on a third-party API call provided by <a href="http://geonames.org"><span class="url">geonames.org</span></a>. Let’s see how we can inject a secondary API call into the search logic of our app.</p>
    <div class="note">
      <p class="normal">You need to sign up for a free account on <a href="http://geonames.org"><span class="url">geonames.org</span></a>. Afterward, store username as a new parameter in <code class="inlineCode">environment.ts</code> and <code class="inlineCode">environment.prod.ts</code>.</p>
    </div>
    <p class="normal">You may experiment with the postal code API interactively at <a href="https://www.geonames.org/postal-codes"><span class="url">https://www.geonames.org/postal-codes</span></a>.</p>
    <p class="normal">We need to implement a service that adheres to the following interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPostalCodeService</span> {
  <span class="hljs-title">resolvePostalCode</span>(<span class="hljs-attr">postalCode</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">IPostalCode</span>&gt;
}
</code></pre>
    <div class="note">
      <p class="normal">Declaring an interface for your service is a useful practice when you’re initially designing your app. You and your team members can focus on providing the right interaction model without being bogged down by implementation details. Once your interface is defined, you can quickly stub out functionality and have a walking skeleton version of your app in place. Stubbed-out functions help validate design choices and encourage early integration between components. Once in place, team members will no longer need to guess whether they are coding in the right spot. You should always export your interface, so you can use the type information for writing unit tests, creating test doubles or fakes.</p>
      <p class="normal">Interfaces are key to<a id="_idIndexMarker181"/> practicing <strong class="keyWord">Test-Driven Development</strong> (<strong class="keyWord">TDD</strong>).</p>
    </div>
    <p class="normal">Now implement <code class="inlineCode">PostalCodeService</code> as shown below:</p>
    <div class="note">
      <p class="normal">You may generate the service by executing <code class="inlineCode">npx ng generate service postalCode --project=local-weather-app --no-flat</code>.</p>
    </div>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/postal-code/postal-code.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">HttpClient</span>, <span class="hljs-title">HttpParams</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>
<span class="hljs-keyword">import</span> { defaultIfEmpty, flatMap } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>
<span class="hljs-keyword">import</span> { environment } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../environments/environment'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPostalCode</span> {
  <span class="hljs-attr">countryCode</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">postalCode</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">placeName</span>: <span class="hljs-built_in">string</span>
  <span class="hljs-attr">lng</span>: <span class="hljs-built_in">number</span>
  <span class="hljs-attr">lat</span>: <span class="hljs-built_in">number</span>
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPostalCodeData</span> { 
  <span class="hljs-attr">postalCodes</span>: [<span class="hljs-title">IPostalCode</span>]
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPostalCodeService</span> {
  <span class="hljs-title">resolvePostalCode</span>(<span class="hljs-attr">postalCode</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">IPostalCode</span>&gt;
}
<span class="hljs-meta">@Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>,
}) 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PostalCodeService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPostalCodeService</span> {
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">httpClient</span><span class="hljs-params">: </span><span class="hljs-title">HttpClient</span>) {}
  <span class="hljs-title">resolvePostalCode</span>(<span class="hljs-attr">postalCode</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">IPostalCode</span>&gt; {
    <span class="hljs-keyword">const</span> uriParams = <span class="hljs-keyword">new</span> <span class="hljs-title">HttpParams</span>()
      .<span class="hljs-title">set</span>(<span class="hljs-string">'maxRows'</span>, <span class="hljs-string">'1'</span>)
      .<span class="hljs-title">set</span>(<span class="hljs-string">'username'</span>, environment.<span class="hljs-property">username</span>)
      .<span class="hljs-title">set</span>(<span class="hljs-string">'postalcode'</span>, postalCode)
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">httpClient</span>
      .<span class="hljs-property">get</span>&lt;<span class="hljs-title">IPostalCodeData</span>&gt;(
        <span class="hljs-string">`</span><span class="hljs-subst">${environment.baseUrl}${environment.geonamesApi}</span><span class="hljs-string">.geonames.org/</span>
          <span class="hljs-string">postalCodeSearchJSON`</span>,
      { <span class="hljs-attr">params</span>: uriParams }
    )
    .<span class="hljs-title">pipe</span>(
      <span class="hljs-title">flatMap</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> data.<span class="hljs-property">postalCodes</span>), 
      <span class="hljs-title">defaultIfEmpty</span>(<span class="hljs-literal">null</span>)
    )
  }
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">Note the new environment variable, <code class="inlineCode">environment.geonamesApi</code>. In <code class="inlineCode">environment.ts</code>, set this value to <code class="inlineCode">api</code> and, in <code class="inlineCode">environment.prod.ts</code>, to <code class="inlineCode">secure</code>, so calls over HTTPS work correctly to avoid the mixed-content error, as covered in <em class="chapterRef">Chapter 10</em>, <em class="italic">Releasing to Production Using CI/CD</em>.</p>
    </div>
    <p class="normal">In the<a id="_idIndexMarker182"/> preceding code segment, we implement a <code class="inlineCode">resolvePostalCode</code> function that calls an API, which is configured to receive the first viable result the API returns. The results are then flattened and piped out to the subscriber. With <code class="inlineCode">defaultIfEmpty</code>, we ensure that a null value will be provided if we don’t receive a result from the API. If the call is successful, we will get back all the information defined in <code class="inlineCode">IpostalCode</code>, making it possible to leverage <code class="inlineCode">getCurrentWeatherByCoords</code> using coordinates.</p>
    <h2 id="_idParaDest-69" class="heading-2">Observable sequencing with switchMap</h2>
    <p class="normal">Let’s update the weather service<a id="_idIndexMarker183"/> so that it can call the <code class="inlineCode">postalCode</code> service to determine whether the user input was a valid postal code:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Start by updating the interface so we only deal with a string:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
…
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IWeatherService</span> {
...
  <span class="hljs-title">getCurrentWeather</span>(<span class="hljs-attr">search</span>: <span class="code-highlight"><strong class="hljs-built_in-slc">string</strong></span>, country?: <span class="hljs-built_in">string</span>): 
    <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
  <span class="hljs-title">updateCurrentWeather</span>(<span class="hljs-attr">search</span>: <span class="code-highlight"><strong class="hljs-built_in-slc">string</strong></span>, country?: <span class="hljs-built_in">string</span>)
}
</code></pre>
      </li>
      <li class="numberedList">Inject <code class="inlineCode">PostalCodeService</code> to the weather service as a private property:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> {
  <span class="hljs-title">PostalCodeService</span>
} <span class="hljs-keyword">from</span><span class="hljs-string"> '../postal-code/postal-code.service'</span>
...
<span class="hljs-title">constructor</span>(
<span class="hljs-params">  </span><span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">httpClient</span><span class="hljs-params">: </span><span class="hljs-title">HttpClient</span><span class="hljs-params">,</span>
<span class="hljs-params">  </span><span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">postalCodeService</span><span class="hljs-params">: </span><span class="hljs-title">PostalCodeService</span>
) {}
</code></pre>
      </li>
      <li class="numberedList">Update <a id="_idIndexMarker184"/>the method signature for <code class="inlineCode">updateCurrentWeather</code>.</li>
      <li class="numberedList">Update <code class="inlineCode">getCurrentWeather</code> to try and resolve <code class="inlineCode">searchText</code> as a postal code:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { map, <span class="code-highlight"><strong class="hljs-slc">switchMap</strong></span> } <span class="hljs-keyword">from</span><span class="hljs-string"> 'rxjs/operators'</span>
... 
<span class="hljs-title">getCurrentWeather</span>(
  <span class="hljs-attr">searchText</span>: <span class="hljs-built_in">string</span>,
  country?: <span class="hljs-built_in">string</span>
): <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">postalCodeService</span>.
    <span class="hljs-title">resolvePostalCode</span>(searchText)
    .<span class="hljs-title">pipe</span>(
      <span class="hljs-title">switchMap</span>(<span class="hljs-function">(</span><span class="hljs-params">postalCode</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-keyword">if</span> (postalCode) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeatherByCoords</span>({
            <span class="hljs-attr">latitude</span>: postalCode.<span class="hljs-property">lat</span>,
            <span class="hljs-attr">longitude</span>: postalCode.<span class="hljs-property">lng</span>,
          } <span class="hljs-keyword">as</span> <span class="hljs-title">Coordinates</span>)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">const</span> uriParams = <span class="hljs-keyword">new</span> <span class="hljs-title">HttpParams</span>().<span class="hljs-title">set</span>(
         <span class="hljs-string">   'q'</span>,
            country ? <span class="hljs-string">`</span><span class="hljs-subst">${searchText}</span><span class="hljs-string">,</span><span class="hljs-subst">${country}</span><span class="hljs-string">`</span> : searchText
          )
          <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeatherHelper</span>(uriParams)
        }
     })
   )
}
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p class="normal">If you run into TypeScript issues when passing the latitude and longitude into <code class="inlineCode">getCurrentWeatherByCoords</code>, you may have to cast the object using the <code class="inlineCode">as</code> operator. So, your code would look like this:</p>
      <pre class="programlisting code"><code class="hljs-code"> return this.getCurrentWeatherByCoords({
   latitude: postalCode.lat,
   longitude: postalCode.lng,
 } as Coordinates)
</code></pre>
    </div>
    <p class="normal">In the preceding code segment, our first call is to the <code class="inlineCode">postalCode</code> service. We then react to postal codes posted on the data stream using <code class="inlineCode">switchMap</code>. Inside <code class="inlineCode">switchMap</code>, we can observe whether <code class="inlineCode">postalCode</code> is null and make the appropriate follow-up call to either get the current weather by coordinates or by city name.</p>
    <p class="normal">Now, LocalCast Weather<a id="_idIndexMarker185"/> should work with global postal codes, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_09.png" alt="A screenshot of a weather forecast  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.9: LocalCast Weather with global postal codes</p>
    <p class="normal">We are done with implementing international zip code support. Move it to the <strong class="screenText">Done</strong> column on your Kanban board:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_10.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 2.10: International zip code support done</p>
    <p class="normal">As we <a id="_idIndexMarker186"/>complete our implementation of LocalCast Weather, there’s still room for improvement. Initially, the app looks broken when it first loads because of the dashes and empty fields shown. There are at least two different ways to handle this. The first is to hide the entire component at the <code class="inlineCode">AppComponent</code> level if there’s no data to display. For this to work, we must inject <code class="inlineCode">WeatherService</code> into <code class="inlineCode">AppComponent</code>, ultimately leading to a less flexible solution. Another way is to enhance <code class="inlineCode">CurrentWeatherComponent</code> so that it is better able to handle missing data.</p>
    <p class="normal">You improve the app further by implementing geolocation to get the weather for the user’s current location upon launching the app. You can also leverage <code class="inlineCode">window.localStorage</code> to store the city that was last displayed or the last location retrieved from <code class="inlineCode">window.geolocation</code> upon initial launch.</p>
    <p class="normal">We are done with the LocalCast Weather app until <em class="chapterRef">Chapter 9</em>, <em class="italic">Recipes – Master/Detail, Data Tables, and NgRx</em>, where I demonstrate how a state store like NgRx compares to using <code class="inlineCode">RxJS/BehaviorSubject</code>.</p>
    <h1 id="_idParaDest-70" class="heading-1">Using Angular Signals</h1>
    <p class="normal">A signal<a id="_idIndexMarker187"/> is a reactivity primitive that keeps track of its value changing over time. Angular Signals<a id="_idIndexMarker188"/> implements this primitive to granularly sync the application state with the DOM. By focusing on granular changes in state and only the relevant DOM nodes, the number and severity of change detection operations are significantly reduced. As covered in <em class="chapterRef">Chapter 1</em>, <em class="italic">Angular’s Architecture and Concepts</em>, change detection is one of the most expensive operations that the Angular framework performs. As an app grows in complexity, change detection operations may be forced to traverse or update larger parts of the DOM tree. As the number of interactive elements increases in your app, change detection events occur more frequently. App complexity combined with the frequency of events can introduce significant performance issues, resulting in slow or choppy rendering of the app. Usually, there’s no quick fix for a problem like this. So, it is critical to understand how signals work and implement them in your app to avoid costly performance issues.</p>
    <div class="note">
      <p class="normal">As of this publication, Angular Signals is in preview. This means that the functionality and performance characteristics of the feature set can and likely will change. Refer to the following guide for the latest information: <a href="https://angular.dev/guide/signals"><span class="url">https://angular.dev/guide/signals</span></a>.</p>
    </div>
    <p class="normal">Angular Signals <a id="_idIndexMarker189"/>provides a few simple functions to interact with it:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">signal</code>: A wrapper around a value. It works like a value getter or setter in a class and is conceptually similar to how <code class="inlineCode">BehaviorSubject</code> works:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> mySignal = <span class="hljs-title">signal</span>(<span class="hljs-string">'</span><span class="hljs-string">Hello'</span>)
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">mySignal</span>()) <span class="hljs-comment">// outputs: Hello (only once)</span>
mySignal.<span class="hljs-title">set</span>(<span class="hljs-string">'Goodbye'</span>) <span class="hljs-comment">// updates the value. Update and mutate methods have subtle differences in setting a new value.</span>
<span class="hljs-comment">// To display the new value, you must call console.log again.</span>
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">computed</code>: A computed signal. It utilizes one or more signals to modify the outcome:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> someSignal = <span class="hljs-title">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`</span><span class="hljs-subst">${mySignal()}</span><span class="hljs-string">, World`</span>)
<span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-title">someSignal</span>()) <span class="hljs-comment">// outputs: Hello, World. If needed, it lazily updates when mySignal is set to a new value.</span>
</code></pre>
      </li>
      <li class="bulletList"><code class="inlineCode">effect</code>: An event that triggers when a signal changes:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">effect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">`A robot says: </span><span class="hljs-subst">${someSignal}</span><span class="hljs-string">`</span>) 
})  
<span class="hljs-comment">// console.log will be called any time mySignal changes.</span>
</code></pre>
      </li>
    </ul>
    <p class="normal">Signals are a new foundational concept, and they change how we think about observables, binding data, and syncing state between components. They are performant, surgical in their nature, and best of all, they’re memory safe. No subscriptions to worry about here.</p>
    <p class="normal">Let’s start by covering a simple example of using signals.</p>
    <h2 id="_idParaDest-71" class="heading-2">Implementing dark mode</h2>
    <p class="normal">For our app to be considered <a id="_idIndexMarker190"/>cool by techies, we must implement a dark mode for it. Let’s use signals to implement this feature and go a step further by remembering the user’s selection in <code class="inlineCode">localStorage</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/app.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">const</span> darkClassName = <span class="hljs-string">'dark-theme'</span>
<span class="hljs-meta">@Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">imports</span>: [...],
  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span>
<span class="hljs-string">    &lt;mat-toolbar color="primary"&gt;</span>
<span class="hljs-string">      &lt;span data-testid="title"&gt;LocalCast Weather&lt;/span&gt;</span>
<span class="hljs-string">      &lt;div fxFlex&gt;&lt;/div&gt;</span>
<span class="hljs-string">      &lt;mat-icon&gt;brightness_5&lt;/mat-icon&gt;</span>
<span class="hljs-string">      &lt;mat-slide-toggle</span>
<span class="hljs-string">        color="warn"</span>
<span class="hljs-string">        data-testid="darkmode-toggle"</span>
<span class="hljs-string">        [checked]="toggleState()"</span>
<span class="hljs-string">        (change)="toggleState.set($event.checked)"&gt;&lt;/mat-slide-toggle&gt;</span>
<span class="hljs-string">      &lt;mat-icon&gt;bedtime&lt;/mat-icon&gt;</span>
<span class="hljs-string">    &lt;/mat-toolbar&gt;</span>
<span class="hljs-string">    &lt;div fxLayoutAlign="center"&gt;</span>
<span class="hljs-string">      &lt;div class="mat-caption vertical-margin"&gt;</span>
<span class="hljs-string">        Your city, your forecast, right now!</span>
<span class="hljs-string">      &lt;/div&gt;</span>
<span class="hljs-string">    &lt;/div&gt;</span>
<span class="hljs-string">    &lt;div fxLayoutAlign="center"&gt;</span>
<span class="hljs-string">      &lt;app-city-search&gt;&lt;/app-city-search&gt;</span>
<span class="hljs-string">    &lt;/div&gt;</span>
<span class="hljs-string">    &lt;div fxLayout="row"&gt;</span>
<span class="hljs-string">      &lt;div fxFlex&gt;&lt;/div&gt;</span>
<span class="hljs-string">      &lt;mat-card appearance="outlined" fxFlex="300px"&gt;</span>
<span class="hljs-string">        &lt;mat-card-header&gt;</span>
<span class="hljs-string">          &lt;mat-card-title&gt;</span>
<span class="hljs-string">            &lt;div class="mat-headline-5"&gt;Current Weather&lt;/div&gt;</span>
<span class="hljs-string">          &lt;/mat-card-title&gt;</span>
<span class="hljs-string">        &lt;/mat-card-header&gt;</span>
<span class="hljs-string">        &lt;mat-card-content&gt;</span>
<span class="hljs-string">          &lt;app-current-weather&gt;&lt;/app-current-weather&gt;</span>
<span class="hljs-string">        &lt;/mat-card-content&gt;</span>
<span class="hljs-string">      &lt;/mat-card&gt;</span>
<span class="hljs-string">      &lt;div fxFlex&gt;&lt;/div&gt;</span>
<span class="hljs-string">    &lt;/div&gt;</span>
<span class="hljs-string">  `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> {
  <span class="hljs-keyword">readonly</span> toggleState = <span class="hljs-title">signal</span>(<span class="hljs-variable">localStorage</span>.<span class="hljs-title">getItem</span>(darkClassName) === <span class="hljs-string">'true'</span>)
  <span class="hljs-title">constructor</span>() {
    <span class="hljs-title">effect</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable">localStorage</span>.<span class="hljs-title">setItem</span>(darkClassName, <span class="hljs-variable">this</span>.<span class="hljs-title">toggleState</span>().<span class="hljs-title">toString</span>())
      <span class="hljs-variable">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">classList</span>.<span class="hljs-title">toggle</span>(
        darkClassName, <span class="hljs-variable">this</span>.<span class="hljs-title">toggleState</span>()
      )
    })
  }
}
</code></pre>
    <div class="packt_tip">
      <p class="normal">If this were production code, I would not use this terse line of code: </p>
      <pre class="programlisting code"><code class="hljs-code">document.documentElement.classList.toggle(darkClassName, this. toggleState())
</code></pre>
      <p class="normal">Here, I wanted to keep the lines of code to a minimum, and the toggle function provided by the DOM API contains the logic needed to make this work correctly. The line should be refactored to adhere to the single responsibility principle.</p>
    </div>
    <p class="normal">Observe the <code class="inlineCode">readonly</code> property named <code class="inlineCode">toggleState</code>. This is our signal. It holds a Boolean value. We <a id="_idIndexMarker191"/>can initialize it by reading a value from <code class="inlineCode">localStorage</code>; if it doesn’t exist, it will default to <code class="inlineCode">false</code>.</p>
    <p class="normal">In the toolbar, we define mat-slide-toggle and assign its [<code class="inlineCode">checked</code>] state to <code class="inlineCode">toggleState()</code>. This binds the value of the signal to the component. By assigning <code class="inlineCode">(change)="toggleState.set($event.checked)"</code>, we ensure that when the user flips the toggle, its value will be written back to the signal.</p>
    <p class="normal">Finally, we implement the <code class="inlineCode">effect</code> method to react to the changes in the value of the signal. In the constructor, we can define the behavior we want within the <code class="inlineCode">effect</code> function. First, we update <code class="inlineCode">localStorage</code> with the current value of <code class="inlineCode">toggleState</code>, and second, we set the <code class="inlineCode">dark-theme</code> class on the DOM to toggle the dark mode state.</p>
    <div class="note">
      <p class="normal">We leverage Angular Material’s built-in dark theme functionality to define a dark theme and attach it to a CSS class named <code class="inlineCode">dark-theme</code>. Refer to <code class="inlineCode">styles.scss</code> to see how this is configured.</p>
    </div>
    <p class="normal">We could’ve<a id="_idIndexMarker192"/> implemented this functionality at least a half-dozen different ways, but signals do offer a very economical way of doing it.</p>
    <p class="normal">We can build on these concepts and replace the uses of <code class="inlineCode">BehaviorSubject</code> and <code class="inlineCode">[(ngModel)]</code> throughout our application. Doing so greatly simplifies how our Angular app works, while also reducing package size and complexity.</p>
    <h2 id="_idParaDest-72" class="heading-2">Replacing BehaviorSubject with signals</h2>
    <p class="normal">Now, let’s see <a id="_idIndexMarker193"/>what it looks like to use signals instead of <code class="inlineCode">BehaviorSubject</code>. Implementing a signal means we must change the end-to-end pipeline of how a value is retrieved and displayed. A signal is a synchronous pipeline, whereas RxJS is asynchronous.</p>
    <div class="packt_tip">
      <p class="normal">You may wonder, isn’t asynchronous better than synchronous? Yes, but not when the synchronous code can run in a non-blocking manner. Asynchronous is expensive, and due to the fundamental technologies that are being leveraged under the hood, signals are way cheaper and faster. This is due to great features that are now built into JavaScript. See <a href="https://www.arrow-js.com"><span class="url">https://www.arrow-js.com</span></a> by Justin Schroeder as an example of this. Certain kinds and sizes of projects no longer need full-fat frameworks like Angular, React, or Vue.</p>
    </div>
    <p class="normal">We will need to update <code class="inlineCode">WeatherService</code>, <code class="inlineCode">CitySearchComponent</code>, and <code class="inlineCode">CurrentWeatherComponent</code>:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First replace <code class="inlineCode">currentWeather$</code> with <code class="inlineCode">currentWeatherSignal</code> in <code class="inlineCode">WeatherService</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">import</span> { signal } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IWeatherService</span>{
  ...
  <span class="hljs-keyword">readonly</span> currentWeatherSignal = <span class="hljs-title">signal</span>(defaultWeather)  
  ...
</code></pre>
      </li>
      <li class="numberedList">Implement a new <code class="inlineCode">getCurrentWeatherAsPromise</code> function to convert the observable to a <code class="inlineCode">Promise</code> and a new <code class="inlineCode">updateCurrentWeatherSignal</code> function to await <a id="_idIndexMarker194"/>the result of the call and assign the result to the signal:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/weather/weather.</strong><strong class="hljs-property-slc">service</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="code-highlight"><strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc"> { ..., firstValueFrom } </strong><strong class="hljs-keyword-slc">from</strong><strong class="hljs-slc"> </strong><strong class="hljs-string-slc">'</strong><strong class="hljs-string-slc">rxjs'</strong></span>
  <span class="hljs-title">getCurrentWeatherAsPromise</span>(
    <span class="hljs-attr">searchText</span>: <span class="hljs-built_in">string</span>,
    country?: <span class="hljs-built_in">string</span>
  ): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-title">firstValueFrom</span>(
      <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeather</span>(searchText, country)
    )
  }
  <span class="hljs-keyword">async</span> <span class="hljs-title">updateCurrentWeatherSignal</span>(<span class="hljs-attr">searchText</span>: <span class="hljs-built_in">string</span>,
    country?: <span class="hljs-built_in">string</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-variable">this</span>.<span class="hljs-property">currentWeatherSignal</span>.<span class="hljs-title">set</span>(
      <span class="hljs-keyword">await</span> <span class="hljs-variable">this</span>.<span class="hljs-title">getCurrentWeatherAsPromise</span>(
        searchText, country
      )
    )
  }
</code></pre>
     
    <div class="note">
      <p class="normal">Note that we use <code class="inlineCode">firstValueFrom</code> to make sure the stream completes as intended.</p>
    </div> </li>
    </ol>


    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Next, replace the <code class="inlineCode">current$</code> property with <code class="inlineCode">currentSignal</code> in <code class="inlineCode">CurrentWeatherComponent</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentWeatherComponent</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">currentSignal</span>: <span class="hljs-title">WritableSignal</span>&lt;<span class="hljs-title">ICurrentWeather</span>&gt;
  <span class="hljs-title">constructor</span>(<span class="hljs-keyword">private</span><span class="hljs-params"> </span><span class="hljs-attr">weatherService</span><span class="hljs-params">: </span><span class="hljs-title">WeatherService</span>) {
    <span class="hljs-variable">this</span>.<span class="hljs-property">currentSignal</span> = <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-property">currentWeatherSignal</span>
...
</code></pre>
      </li>
      <li class="numberedList">Update the template to use the signal:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/current-weather/current-weather.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">html</strong></span>
<span class="hljs-meta">@if</span> (<span class="hljs-title">currentSignal</span>(); <span class="hljs-keyword">as</span> current) {
  ...
}
</code></pre>
      </li>
      <li class="numberedList">Finally, update <code class="inlineCode">CitySearchComponent</code> to trigger the new service call:
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">src/app/city-search/city-search.</strong><strong class="hljs-property-slc">component</strong><strong class="hljs-slc">.</strong><strong class="hljs-property-slc">ts</strong></span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CitySearchComponent</span> {
  ...
  <span class="hljs-variable">this</span>.<span class="hljs-property">weatherService</span>.<span class="hljs-title">updateCurrentWeatherSignal</span>(
    searchText, country
  )
  ...
</code></pre>
      </li>
    </ol>
    <p class="normal">We have transformed our app to use a signal to communicate between components. A signal is less sophisticated than <code class="inlineCode">BehaviorSubject</code>, but most of the time, the extra capabilities aren’t used. Signals are memory safe, lightweight, and allow novel applications by leveraging computed signals, like the RxJS merge technique discussed earlier in this chapter.</p>
    <p class="normal">Ultimately, RxJS and <a id="_idIndexMarker195"/>signals are complementary technologies. For example, we wouldn’t consider replacing the debounce logic in the search input away from RxJS. Angular also ships with <code class="inlineCode">toSignal</code> and <code class="inlineCode">fromSignal</code> interoperability functions; however, I would caution against mixing paradigms. To get the full benefit of signals, always prefer an end-to-end refactor, as this section covers.</p>
    <p class="normal">With so many options, paradigms, techniques, and gotchas, you may be wondering if you can just generate this code using AI. I did just that for you. Read on.</p>
    <h1 id="_idParaDest-73" class="heading-1">Generating apps with ChatGPT</h1>
    <p class="normal">Let’s <a id="_idIndexMarker196"/>see what result we get if we ask ChatGPT to generate a <a id="_idIndexMarker197"/>weather app. In August 2023, I asked ChatGPT to generate a weather app using GPT-4 with the <code class="inlineCode">CodeInterpreter</code> plugin. I gave it the following prompt:</p>
    <blockquote class="packt_quote">
      <p class="quote">Write an Angular app that displays real-time weather data from openweathermap.org APIs, using Angular Material, with a user input that accepts city name, country, or postal code as input.</p>
    </blockquote>
    <p class="normal">After <a id="_idIndexMarker198"/>making a few<a id="_idIndexMarker199"/> minor corrections, this is the result I got:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_11.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.11: ChatGPT weather app – August 2023</p>
    <p class="normal">ChatGPT created a very simple and straightforward app for me, with a weather-display component using two-way binding for the input field. The service call was correctly implemented in a dedicated weather service triggered by the <strong class="screenText">Fetch Weather</strong> button. To achieve similar results to the <code class="inlineCode">LocalCast</code> app we built, we would have to provide a prompt with far more technical details. Non-technical people won’t know to ask for specific implementation details, and developers may simply find it easier to iteratively develop their solution. Nevertheless, the results are impressive.</p>
    <p class="normal">Four months later, I questioned my premise from the paragraph above.</p>
    <p class="normal"><em class="italic">What if developers were okay with providing one or two more prompts?</em></p>
    <p class="normal">In December 2023, I provided the same prompt from above to ChatGPT using GPT-4 without using any plugins, and after it generated the code, I provided an additional prompt:</p>
    <blockquote class="packt_quote">
      <p class="quote">Can you rewrite weather.component.html and style it in a way that looks like a professional design on desktop and mobile devices alike?</p>
    </blockquote>
    <p class="normal">And <a id="_idIndexMarker200"/>boom, I got<a id="_idIndexMarker201"/> a result that looked a lot better!</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_12.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.12: ChatGPT Weather app initial version – December 2023</p>
    <p class="normal">Still, this output doesn’t look like my design. Of course, ChatGPT has no idea what my design is, and it’s too cumbersome to meticulously describe it in writing. Then I remembered I had a hand-drawn mockup of the weather app I created for the 1<sup class="superscript">st</sup> edition in 2018.</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_13.png" alt="A picture containing text, handwriting, drawing, diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 2.13: Hand-drawn wireframe for LocalCast</p>
    <div class="packt_tip">
      <p class="normal">Yes, I did use a ruler!</p>
    </div>
    <p class="normal">In<a id="_idIndexMarker202"/> August 2023, ChatGPT couldn’t see, but since then, it has gained computer <a id="_idIndexMarker203"/>vision. I uploaded the mockup as is and said, “Redesign the UI to follow this mockup.” Remember that my mockup has three screens and difficult-to-read handwriting in it.</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_14.png" alt="Initial result with Sidenav"/></figure>
    <p class="packt_figref">Figure 2.14: ChatGPT weather app second version – December 2023</p>
    <p class="normal">I’m <a id="_idIndexMarker204"/>shocked that it picked up on <code class="inlineCode">SideNav</code> and incorporated <a id="_idIndexMarker205"/>it using proper Material components and <code class="inlineCode">FlexLayout</code> media queries to make it responsive – never mind the misinterpretation of my handwriting.</p>
    <p class="normal">I updated the generated UI code to make it interactive and included it as a project named <code class="inlineCode">chat-get-dec23</code> in the repo. Here’s the result:</p>
    <figure class="mediaobject"><img src="../Images/B20960_02_15.png" alt="Initial result with Sidenav"/></figure>
    <p class="packt_figref">Figure 2.15: ChatGPT weather app final version – December 2023</p>
    <p class="normal">This is <a id="_idIndexMarker206"/>beyond impressive. By the time the next edition of this <a id="_idIndexMarker207"/>book is published, this chapter may be only a few pages long and filled with tips, highlighting the crucial need to use a ruler when drawing your mockups.</p>
    <h1 id="_idParaDest-74" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned how to create search-as-you-type functionality using <code class="inlineCode">MatInput</code>, validators, reactive forms, and data-stream-driven handlers. You became aware of two-way binding and template-driven forms. You also learned about different strategies to enable inter-component interactions and data sharing. You dove into understanding how memory leaks can be created and the importance of managing your subscriptions.</p>
    <p class="normal">You can now differentiate between imperative and reactive programming paradigms and understand the importance of sticking with reactive programming where possible. Finally, you learned how to implement sophisticated functionality by chaining multiple API calls together. You learned about the signal primitive and how you can use it to build simpler and more performant applications.</p>
    <p class="normal">LocalCast Weather is a straightforward application that we used to cover the basic concepts of Angular. As you saw, Angular is great for building such small and dynamic applications while delivering a minimal amount of framework code to the end user. You should consider leveraging Angular for quick and dirty projects, which is always great practice for building larger applications. You also learned you can use GenAI tools like ChatGPT to give yourself a quick start when beginning a new project.</p>
    <p class="normal">In the next chapter, we will dive into considerations around architecting a web application in an enterprise app and learn where all the monsters are hidden. We will go over how you can build a <strong class="keyWord">Line-of-Business</strong> (<strong class="keyWord">LOB</strong>) application using a router-first approach to designing and architecting scalable Angular applications with first-class authentication and authorization, user experience, and numerous recipes that cover a vast majority of requirements that you may find in LOB applications.</p>
    <h1 id="_idParaDest-75" class="heading-1">Exercises</h1>
    <p class="normal">After completing the <strong class="keyWord">Support international zip codes</strong> feature, did we switch coding paradigms here? Is our implementation above imperative, reactive, or a combination of both? If our implementation is not entirely reactive, how would you implement this function reactively? I’ll leave this as an exercise for the reader.</p>
    <p class="normal">Don’t forget to execute <code class="inlineCode">npm test</code>, <code class="inlineCode">npm run e2e</code>, and <code class="inlineCode">npm run test:a11y</code> before moving on. It is left as an exercise for the reader to fix the unit and end-to-end tests.</p>
    <p class="normal">Visit GitHub to see the unit tests I implemented for this chapter at <a href="https://github.com/duluca/local-weather-app/tree/master/projects/stage6"><span class="url">https://github.com/duluca/local-weather-app/tree/master/projects/stage6</span></a>.</p>
    <h1 id="_idParaDest-76" class="heading-1">Questions</h1>
    <p class="normal">Answer the following questions as best as possible to ensure you’ve understood the key concepts from this chapter without googling anything. Do you know if you got all the answers right? Visit <a href="https://angularforenterprise.com/self-assessment"><span class="url">https://angularforenterprise.com/self-assessment</span></a> for more:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What is the <code class="inlineCode">async</code> pipe?</li>
      <li class="numberedList">Explain how reactive and imperative programming is different and which technique we should prefer.</li>
      <li class="numberedList">What is the benefit of <code class="inlineCode">BehaviorSubject</code>, and what is it used for?</li>
      <li class="numberedList">What are memory leaks and why should they be avoided?</li>
      <li class="numberedList">What is the best method for managing subscriptions?</li>
      <li class="numberedList">How are Angular signals different than RxJS streams?</li>
      <li class="numberedList">What are ways you can use Angular Signals to simplify your application?</li>
    </ol>
  </div>
</body></html>