<html><head></head><body>
		<div>
			<div id="_idContainer300" class="Content">
			</div>
		</div>
		<div id="_idContainer301" class="Content">
			<h1 id="_idParaDest-199"><a id="_idTextAnchor279"/>9. Working with Vuex – State, Getters, Actions, and Mutations</h1>
		</div>
		<div id="_idContainer310" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn how to use Vuex to build more complex Vue applications. You'll learn the specifics concerning how to add Vuex to a Vue application, how to define state with the Vuex store, and then use getters, actions, and mutations to read data from, and update it in, the store. By the end of the chapter, you will have seen multiple examples of how Vuex transforms your Vue applications, preparing them to grow much more complex in a much more manageable fashion.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor280"/>Introduction</h1>
			<p>In the previous chapter, you learned how to use the Event Bus pattern to help solve an important problem: communicating events back and forth between complex and highly nested sets of components. The Event Bus pattern provided a simple <strong class="bold">pub and sub</strong> system by which any component could emit an event and any component could then listen to that event as well. While writing your own solution to this problem is a great way to keep your coding skills sharp, it would be better, in this case, to use an already developed, well-tested solution already in use in the Vue community—<strong class="bold">Vuex</strong> (<a href="https://vuex.vuejs.org/">https://vuex.vuejs.org/</a>):</p>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="image/B15218_09_01.jpg" alt="Figure 9.1: The Vuex home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: The Vuex home page</p>
			<p>Vuex is a core part of the Vue ecosystem and provides what we already built in the previous chapter along with much more. Let's take a high-level look at the main features of Vuex.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor281"/>Store</h2>
			<p>At a high level, a Vuex instance, or one use of Vuex, is considered a <strong class="bold">store</strong>. The store is the top-level container employing everything described in the following subsections.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor282"/>State</h2>
			<p>The most important aspect of Vuex is the <strong class="bold">state</strong>, or data, that it represents. This is the <em class="italic">single source of truth</em> that all components can rely on. As the state changes, every component making use of the state can be assured its copy will always be in sync. Imagine a Vue application that lets you edit blog entries. The store could consist of the blog entries themselves as well as values for the current blog entry you're editing. As blog entries are edited in one place, any other place using them gets updated immediately. </p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor283"/>Getters</h2>
			<p>While Vue can directly read state data from a Vuex instance, sometimes you may need to provide additional logic or an abstraction to the data itself. Much like how Vue provides a <strong class="source-inline">computed</strong> property for virtual or derived data, <strong class="bold">getters</strong> provide an abstraction to the state for cases where you need to manipulate the data before it is returned. Returning to our previous example of working with blog entries, imagine a getter that returns the top blog entries by views. The getter abstracts away the logic of how "popular" blog entries are and lets you easily change that logic in the future.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor284"/>Mutations</h2>
			<p>Components making use of state data in Vuex never directly modify that data. Instead, a component can execute a <strong class="bold">mutation</strong>. Think of it as an order from the component for Vuex to perform a change to its state. By using mutations to wrap changes to state, Vuex can ensure every component making use of that state is kept up to date on changes.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor285"/>Actions</h2>
			<p><strong class="bold">Actions</strong> are like mutations, except that they must be used to handle asynchronous changes. Asynchronous actions are any logic that takes an indeterminate amount of time to finish. The most common example would be a network call to a remote API. Synchronous calls are those that execute and finish immediately. It will make more sense when you see them being used, but generally, anything asynchronous should be done via actions while synchronous logic can be done via mutations. Actions will typically chain to mutations once they have completed whatever asynchronous work they need to do. </p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor286"/>Modules</h2>
			<p>The last aspect of Vuex this chapter will cover is modules. <strong class="bold">Modules</strong> are simply a way to package more complex sets of data for larger applications. While one simple state may be fine for a typical application, a much larger application can have a much more complex state that needs better organization via modules. In <em class="italic">Chapter 11</em>, <em class="italic">Working with Vuex – Organizing Larger Stores</em>, you will see how modules can be used to better organize the Vuex instance.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor287"/>Installing Vuex</h1>
			<p>There are two main methods of using Vuex, depending on the type of Vue application you're building. If you are not using the CLI to scaffold out an application and simply added Vue via a script tag, you can include Vuex the same way. Assuming you've downloaded both Vue and Vuex to a folder named <strong class="source-inline">js</strong>, you would load them both like so:</p>
			<p class="source-code">&lt;script src="js/vue.js"&gt;&lt;/script&gt;</p>
			<p class="source-code">&lt;script src="js/vuex.js"&gt;&lt;/script&gt;</p>
			<p>You can also load both Vue and Vuex via <strong class="bold">Content Delivery Networks</strong> (<strong class="bold">CDNs</strong>):</p>
			<p class="source-code">&lt;script src="https://unpkg.com/vue"&gt;&lt;/script&gt;</p>
			<p class="source-code">&lt;script src="https://unpkg.com/vuex"&gt;&lt;/script&gt;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important that Vuex is loaded after Vue. Doing so makes Vuex available to your Vue code without any other configuration.</p>
			<p>If you created an application using the CLI, remember first that the CLI itself will prompt you during creation if you want to add Vuex:</p>
			<div>
				<div id="_idContainer303" class="IMG---Figure">
					<img src="image/B15218_09_02.jpg" alt="Figure 9.2: Selecting Vuex during application scaffolding&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: Selecting Vuex during application scaffolding</p>
			<p>If you didn't do this though, you can still add Vuex later using the CLI: <strong class="source-inline">vue add vuex</strong>. When Vuex is added (or selected during scaffolding), your Vue application is modified in the ways we'll discuss now.</p>
			<p>First, a new folder, <strong class="source-inline">store</strong>, is added, containing one file, <strong class="source-inline">index.js</strong>:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modules: {</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>This is an empty store with spots prepared for your state, mutations, actions, and modules. Note that there isn't a place for getters defined here, but you can absolutely add them. This is just the default layout for a new store, and you can modify it as you see fit.</p>
			<p>Next, <strong class="source-inline">main.js</strong> is modified to load and install this store:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import App from './App.vue'</p>
			<p class="source-code">import store from './store'</p>
			<p class="source-code">Vue.config.productionTip = false</p>
			<p class="source-code">new Vue({</p>
			<p class="source-code">  store,</p>
			<p class="source-code">  render: h =&gt; h(App)</p>
			<p class="source-code">}).$mount('#app')</p>
			<p>Again, this is how the CLI scaffolds using Vuex, and if you prefer to use another method (perhaps a different folder name than <strong class="source-inline">store</strong>), you are free to do so.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor288"/>Working with State</h1>
			<p>At the lowest level in a Vuex store, you will find the actual data (the state) that Vuex manages. All components have access to the state via a special <strong class="source-inline">$store</strong> variable. While there's more within this variable, to read the state, you can use <strong class="source-inline">$store.state.someStateValue</strong>. So, for example: <strong class="source-inline">Hello, my name is {{ $store.state.name }}</strong> would output the name value from your Vuex store in a component. For simple operations reading from the store, that's all you need.</p>
			<p>We will now learn how to display state values in the following exercise.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor289"/>Exercise 9.01: Displaying State Values</h2>
			<p>In this exercise, you will create an empty Vue application using Vuex. The previous section described how that was done via the CLI, and if you followed along, you've got one ready to go. If not, go ahead and create one now, ensuring you enable Vuex. In this exercise, we'll simply set a few values in the state and display them in a component. </p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/32s4RkN">https://packt.live/32s4RkN</a>.</p>
			<ol>
				<li>Once you've scaffolded the application, open <strong class="source-inline">store/index.js</strong> and modify the <strong class="source-inline">state</strong> block to add three new values. The data here is arbitrary and can be anything that JavaScript can handle (strings, numbers, arrays, and so on):<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    name:"Lindy", </p><p class="source-code">    favoriteColor: "blue", </p><p class="source-code">    profession: "librarian"</p><p class="source-code">  },</p><p class="source-code">  mutations: {</p><p class="source-code">  },</p><p class="source-code">  actions: {</p><p class="source-code">  },</p><p class="source-code">  modules: {</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>Now we need to modify the component to display the values from the state. Open up <strong class="source-inline">App.vue</strong> and modify it like so:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">    My name is {{ $store.state.name }} and </p><p class="source-code">    my favorite color is {{ $store.state.favoriteColor }}. </p><p class="source-code">    My job is a {{ $store.state.profession }}.</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;HelloWorld /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import HelloWorld from '@/components/HelloWorld';</p><p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  components:{</p><p class="source-code">    HelloWorld</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, edit the <strong class="source-inline">HelloWorld.vue</strong> component to also display a value from the state:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">      Hi, I'm a component, and I also have access to state! </p><p class="source-code">      My name is {{ $store.state.name }}.</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  name: 'HelloWorld'</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>To see your application, type <strong class="source-inline">npm run serve</strong> in your terminal. When the CLI is done, you can then open the URL displayed in your browser to see your application, which should appear as follows:</p><p class="source-code">My name is Lindy and my favorite color is blue. My job is a librarian.</p><p class="source-code">Hi, I am a component, and I also have access to state! My name is Lindy.</p></li>
			</ol>
			<p>As you can see, both the main component and the child component have access to the state and see the same values. This shouldn't be a surprise, but it's always nice to confirm that things are working as expected. </p>
			<p>While directly accessing state values makes things easy, let's look at a more complex usage: derived values with getters.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor290"/>Applying Getters</h1>
			<p>In the previous exercise, you saw how simple it was to directly access state, but there are times when you may need more complex views of your state. To make this easier, Vuex supports a feature called <strong class="bold">getters</strong>.</p>
			<p>Getters have their own block within the store, and you can define as many as necessary. Each getter is passed the state as an argument, which lets you use whatever you need to create your value. Finally, the name of the getter is how it will be exposed. Consider this simple example:</p>
			<p class="source-code">state: {</p>
			<p class="source-code">  name: "Raymond",</p>
			<p class="source-code">  gender: "male",</p>
			<p class="source-code">  job: "Developer Evangelist"</p>
			<p class="source-code">},</p>
			<p class="source-code">getters: {</p>
			<p class="source-code">  bio(state) {</p>
			<p class="source-code">    return `My name is ${state.name}. I'm a ${state.job}`;</p>
			<p class="source-code">  } </p>
			<p class="source-code">}</p>
			<p>This store defines three state values (<strong class="source-inline">name</strong>, <strong class="source-inline">gender</strong>, and <strong class="source-inline">job</strong>), and also provides a "virtual" property named <strong class="source-inline">bio</strong> that returns a description of the data. Note that the getter only uses two of the state values, and that's totally fine.</p>
			<p>To reference the getter in your component, you use <strong class="source-inline">$store.getters.name</strong>, where <strong class="source-inline">name</strong> is the name of the getter. So, to access the bio getter defined in the preceding code, you would use the following:</p>
			<p class="source-code">{{ $store.getters.bio }}</p>
			<p>Along with being passed the state, getters are passed <em class="italic">other</em> getters as their second argument, which allows one getter to call another getter, if necessary. </p>
			<p>In the next exercise, we will see an example of putting this to use.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor291"/>Exercise 9.02: Adding Getters to a Vuex Store</h2>
			<p>In this exercise, you will build an example that makes use of the Getters feature. You will add Getters to a Vuex store and add a call to it from the main Vue application. </p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/36ixlyf">https://packt.live/36ixlyf</a>.</p>
			<ol>
				<li value="1">Scaffold a new application, remembering to use Vuex in the settings (and if you forget, just use <strong class="source-inline">vue add vuex</strong>). Type <strong class="source-inline">npm run serve</strong> to start the application and open the URL in your browser.</li>
				<li>Open your store file (<strong class="source-inline">store/index.js</strong>) and then modify it to define two state values and a getter that will return both:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    firstName: "Lindy",</p><p class="source-code">    lastName: "Roberthon"</p><p class="source-code">  },</p><p class="source-code">  getters: {</p><p class="source-code">    name(state) {</p><p class="source-code">      return `${state.firstName} ${state.lastName}`;</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  mutations: {</p><p class="source-code">  },</p><p class="source-code">  actions: {</p><p class="source-code">  },</p><p class="source-code">  modules: {</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>Now open <strong class="source-inline">App.vue</strong> and modify it such that you make use of the <strong class="source-inline">name</strong> getter:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">    My name is {{ $store.getters.name }}</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>As you can see in the following screenshot, this will show the complete name based on the logic used in the getter:</p><p class="source-code">My name is Lindy Roberthon</p><p>While rather simple, hopefully, you can see the power of what Getters achieves here. Right now, we have a concept of a name that consists of a first and last name. That isn't terribly complex logic, but by placing it within the Vuex store, we defined it as one place that's available to all components within our application. If this name definition changed (perhaps with the last name listed first, separated by a comma), you could modify it once and be done. </p></li>
			</ol>
			<p>Next, we'll consider how to enhance Getters with additional logic.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor292"/>Getters with Parameters</h1>
			<p>While Getters can be accessed directly via <strong class="source-inline">$store.getters</strong> properties, you may run into situations where you need a bit more control over how the getter works. Parameters provide a way to customize how Getters works. Consider the following store:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {</p>
			<p class="source-code">    books:[</p>
			<p class="source-code">      {type:'nonfiction', title:'Truth about Cats', pages: 200},</p>
			<p class="source-code">      {type:'nonfiction', title:'Truth about Dogs', pages: 100},</p>
			<p class="source-code">      {type:'fiction', title:'The Cat Said Meow', pages: 400},</p>
			<p class="source-code">      {type:'fiction', title:'The Last Dog', pages: 600},</p>
			<p class="source-code">    ]</p>
			<p class="source-code">  },</p>
			<p class="source-code">  getters: {</p>
			<p class="source-code">    fiction(state) {</p>
			<p class="source-code">      return state.books.filter(book =&gt; book.type === 'fiction');</p>
			<p class="source-code">    },</p>
			<p class="source-code">    nonfiction(state) {</p>
			<p class="source-code">      return state.books.filter(book =&gt; book.type ===         'nonfiction');</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">  },</p>
			<p class="source-code">  modules: {</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>There's only one state value in this store, and it's an array of books. Each book has a type (nonfiction or fiction), title, and page count. To make it easy to get one book versus another, two getters are used. They filter by either fiction or nonfiction books. </p>
			<p>Here's how you could use this in a component. First, we iterate over the <strong class="source-inline">fiction</strong> getter and then the <strong class="source-inline">nonfiction</strong> one:</p>
			<p class="source-code">&lt;h2&gt;Fiction Books&lt;/h2&gt;</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">  &lt;li v-for="book in $store.getters.fiction" :key="book.title"&gt;</p>
			<p class="source-code">  {{ book.title }}</p>
			<p class="source-code">  &lt;/li&gt;</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p class="source-code">&lt;h2&gt;Non-Fiction Books&lt;/h2&gt;</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">    &lt;li v-for="book in $store.getters.nonfiction" :key=      "book.title"&gt;</p>
			<p class="source-code">    {{ book.title }}</p>
			<p class="source-code">    &lt;/li&gt;</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>In the preceding template, two unordered lists are used to iterate over each type of book. The result can be seen as shown here:</p>
			<div>
				<div id="_idContainer304" class="IMG---Figure">
					<img src="image/B15218_09_03.jpg" alt="Figure 9.3: Rendering fiction and non-fiction books via getters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: Rendering fiction and non-fiction books via getters</p>
			<p>Okay, so far so good. But what if you want to get books based on their page count? That isn't a simple boolean or string property, but rather a number. But, because getters can accept parameters, we can create a new getter that lets us ask for a maximum number of pages. (We could support more than one parameter, so, if you wanted a getter that asked for books within a range of values, you could support both a min and max number of pages.) In order to create a getter that accepts a parameter, your code itself must return a function.</p>
			<p>Here's an example where we define a getter that returns a portion of the full name:</p>
			<p class="source-code">shortName(state) {</p>
			<p class="source-code">  return function(length) {</p>
			<p class="source-code">    return ('${state.firstName} ${state.lastName}').      substring(0, length);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The resulting getter can then be used with the <strong class="source-inline">length</strong> parameter: <strong class="source-inline">{{ $store.getters.shortName(10) }}</strong>. </p>
			<p>In the next exercise, you'll build an application that makes use of the Getter with the parameters feature.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor293"/>Exercise 9.03: Employing a Getter with Parameters</h2>
			<p>You will test out this feature in the following exercise. By adding parameters to a getter, you'll be able to build more flexible getters that are more useful across different components. In this exercise, you will create a getter that takes one parameter.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2Ioi2vy">https://packt.live/2Ioi2vy</a>.</p>
			<ol>
				<li value="1">Scaffold yet another application using Vuex and, once open, edit the store to include a set of books and getters for fiction, non-fiction, and page size. This is found in the store directory in <strong class="source-inline">index.js</strong>:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    books:[</p><p class="source-code">      {type:'nonfiction', title:'Truth about Cats', pages: 200},</p><p class="source-code">      {type:'nonfiction', title:'Truth about Dogs', pages: 100},</p><p class="source-code">      {type:'fiction', title:'The Cat Said Meow', pages: 400},</p><p class="source-code">      {type:'fiction', title:'The Last Dog', pages: 600},</p><p class="source-code">    ]</p><p class="source-code">  },</p><p class="source-code">  getters: {</p><p class="source-code">    fiction(state) {</p><p class="source-code">      return state.books.filter(book =&gt; book.type === 'fiction');</p><p class="source-code">    },</p><p class="source-code">    nonfiction(state) {</p><p class="source-code">      return state.books.filter(book =&gt; book.type ===         'nonfiction');</p><p class="source-code">    },</p><p class="source-code">    booksByMaxPages(state) {</p><p class="source-code">      return function(pages) {</p><p class="source-code">        return state.books.filter(book =&gt; book.pages &lt;= pages);</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>Now edit <strong class="source-inline">App.vue</strong> to use all three getters – first the fiction and nonfiction getters, and then books that have <strong class="source-inline">150</strong> or fewer pages:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;h2&gt;Fiction Books&lt;/h2&gt;</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">      &lt;li v-for="book in $store.getters.fiction" :key=        "book.title"&gt;</p><p class="source-code">        {{ book.title }}</p><p class="source-code">      &lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">    &lt;h2&gt;Non-Fiction Books&lt;/h2&gt;</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">      &lt;li v-for="book in $store.getters.nonfiction" :key=        "book.title"&gt;</p><p class="source-code">        {{ book.title }}</p><p class="source-code">      &lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">    &lt;h2&gt;Short Books&lt;/h2&gt;</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">      &lt;li v-for="book in $store.getters.booksByMaxPages(150)"         :key="book.title"&gt;</p><p class="source-code">        {{ book.title }}</p><p class="source-code">      &lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  name: 'app'</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>Once done, you can see the result by starting your Vue application (type <strong class="source-inline">npm run serve</strong> in your terminal) and opening the URL in your browser. Here is what you should see:</p><div id="_idContainer305" class="IMG---Figure"><img src="image/B15218_09_04.jpg" alt="Figure 9.4: The parameterized getter in action&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.4: The parameterized getter in action</p>
			<p>In this exercise, we learned how to use more powerful getters that use parameters. This makes them flexible and more adaptable to what your components may need. Now that you've seen multiple ways of reading data from a Vuex store, it's time to look at how to modify state.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor294"/>Modifying State with Mutations</h1>
			<p>So far, you've seen how to read data from a Vuex store, both with direct access to state and by using getters. But to actually change the state of a store, Vuex supports the idea of mutations. Mutations are methods you define in your store that handle changing state. So, for example, instead of your component simply setting a new value in the state, your component will ask the store to perform a mutation, and the store handles that logic itself. </p>
			<p>Here's a simple example:</p>
			<p class="source-code">state: {</p>
			<p class="source-code">  totalCats: 5,</p>
			<p class="source-code">  name:'Lindy'</p>
			<p class="source-code">},</p>
			<p class="source-code">mutations: {</p>
			<p class="source-code">  newCat(state) {</p>
			<p class="source-code">    state.totalCats++;</p>
			<p class="source-code">  },</p>
			<p class="source-code">  setName(state, name) {</p>
			<p class="source-code">   state.name = name;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding snippet, the store has two values in its state, <strong class="source-inline">totalCats</strong> and <strong class="source-inline">name</strong>. Two mutations exist to allow you to change these values. All mutations are passed a state object that gives you direct access to read and change values. The first mutation, <strong class="source-inline">newCat</strong>, simply increments the <strong class="source-inline">totalCats</strong> value. The second mutation, <strong class="source-inline">setName</strong>, shows an example of a mutation that takes an argument. In this case, you could use <strong class="source-inline">setName</strong> to change the name value in the store.</p>
			<p>In order to execute a mutation, your components will use the <strong class="source-inline">commit</strong> method. See the following, for example:</p>
			<p class="source-code">$store.commit('newCat');</p>
			<p class="source-code">$store.commit('setName', 'Raymond');</p>
			<p>You can also pass multiple values if you pass them as an object instead of a simple value. In the next exercise, you'll get a chance to practice building your own mutations.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor295"/>Exercise 9.04: Working with Mutations</h2>
			<p>In this exercise, you will build an application that uses mutations to modify state data in Vuex. Scaffold a new application and, once ready, open up the store file located in <strong class="source-inline">store/index.js</strong>. Your store is going to be somewhat based on the preceding examples.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/3kcARiN">https://packt.live/3kcARiN</a>.</p>
			<ol>
				<li value="1">Define a <strong class="source-inline">totalCats</strong> state variable and name state value, then three mutations to work with them – one mutation to increase the number of cats, one to reduce it, and one final one to set the name:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    totalCats:5, </p><p class="source-code">    name: "Lindy"</p><p class="source-code">  },</p><p class="source-code">  mutations: {</p><p class="source-code">    adoptCat(state) {</p><p class="source-code">      state.totalCats++;</p><p class="source-code">    },</p><p class="source-code">    placeCat(state) {</p><p class="source-code">      if(state.totalCats &gt; 0) state.totalCats--;</p><p class="source-code">    },</p><p class="source-code">    setName(state, name) {</p><p class="source-code">      state.name = name;</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p><p>Next, you will build a simple interface to work with this store. The template needs to have a UI to report on the name and the number of cats. You also need a text field and button to handle updating the name.</p></li>
				<li>Open <strong class="source-inline">App.vue</strong> and update it to include outputting the current values from the store as well as providing a simple form to allow updates:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;h1&gt;About Me&lt;/h1&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">      My name is {{ $store.state.name }} and </p><p class="source-code">      I have {{ $store.state.totalCats }} cats.</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">      &lt;input v-model="newName"&gt;</p><p class="source-code">      &lt;button @click="setName" :disabled="!newName"&gt;Update Name         &lt;/button&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;Cat/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import Cat from './components/Cat.vue'</p><p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  components: {</p><p class="source-code">    Cat</p><p class="source-code">  },</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      newName:''</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  methods: {</p><p class="source-code">    setName() {</p><p class="source-code">      if(this.newName) {</p><p class="source-code">        this.$store.commit('setName', this.newName);</p><p class="source-code">        this.newName = '';</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Build the <strong class="source-inline">Cat</strong> component. This component will have simple buttons to execute the mutations we defined to both increase and decrease the number of cats:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;button @click="addCat"&gt;More Cats!&lt;/button&gt;</p><p class="source-code">    &lt;button @click="removeCat"&gt;Less Cats :(&lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  name: 'Cat',</p><p class="source-code">  methods: {</p><p class="source-code">    addCat() {</p><p class="source-code">      this.$store.commit('adoptCat');</p><p class="source-code">    },</p><p class="source-code">   removeCat() {</p><p class="source-code">      this.$store.commit('placeCat');</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>Once done, start up your application as you have before with <strong class="source-inline">npm run serve</strong> and open the displayed URL in your browser. Your application should look like so:</p><div id="_idContainer306" class="IMG---Figure"><img src="image/B15218_09_05.jpg" alt="Figure 9.5: Vue application with mutation support&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.5: Vue application with mutation support</p>
			<p>While this was a trivial exercise, there are a few important things to note. First, notice how both the root and child components have no problems interacting with the store. Your component hierarchy can be incredibly deep, and it simply just works. Secondly, notice how the Vue application is simpler because the logic of working with the data is in the store. The two components we worked with simply display data and handle passing off mutation calls to the store. If our logic ever needs to update, we can handle it in the store, and everything will be updated properly.</p>
			<p>So far, you've seen how to implement changes to your store in an immediate, synchronous way. You'll now learn how to handle asynchronous updates.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor296"/>Using Actions for Asynchronous State Changes</h1>
			<p>Actions in Vuex are the primary way of handling asynchronous logic for your store. Mutations have to be synchronous, but actions can be asynchronous if they choose. The other difference is that actions get a <strong class="source-inline">context</strong> object that represents the store itself. This lets actions call mutations or work with the state directly. In general, most developers will call mutations from their actions.</p>
			<p>This probably seems a bit confusing, but in general, think of actions as your asynchronous support for your store. It will make sense once we see an example or two.</p>
			<p>Let's look at a sample action. The following snippet contains one mutation and an asynchronous action that will make use of the mutation:</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">    setBooks(state, books) {</p>
			<p class="source-code">      state.books = books;</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  actions: {</p>
			<p class="source-code">    loadBooks(context) {</p>
			<p class="source-code">      fetch('/data/books.json')</p>
			<p class="source-code">      .then(res =&gt; res.json())</p>
			<p class="source-code">      .then(res =&gt; {</p>
			<p class="source-code">        context.commit('setBooks', res);</p>
			<p class="source-code">      });</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p>Looking at <strong class="source-inline">loadBooks</strong>, you can see it makes a network request, and when done, it makes a call to the preceding mutation and lets it store the result data. </p>
			<p>Calling an action is slightly different than mutations; instead of a <strong class="source-inline">commit</strong> call, you use <strong class="source-inline">dispatch</strong>:</p>
			<p class="source-code">this.$store.dispatch('loadBooks');</p>
			<p>Like mutations, actions can take arguments that get passed to the action method as the second argument. Next, you'll build an example of this in action.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor297"/>Exercise 9.05: Using Actions for Asynchronous Logic</h2>
			<p>In this exercise, you will build an example of an action requiring asynchronous logic in order to complete. This closely resembles many real-world scenarios where the data required for the application is found on a remote API. You'll implement the network call and work with the results in your Vuex store.</p>
			<p>For this example, you will set up a JSON resource available in your <strong class="source-inline">public</strong> folder under a subdirectory named <strong class="source-inline">data</strong>. When Vue builds your code, it will copy anything in the <strong class="source-inline">public</strong> folder to the application, making it available at runtime. The JSON file contains an array of four books. Each book has a type, title, and number of pages.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/3eE6KQd">https://packt.live/3eE6KQd</a>.</p>
			<ol>
				<li value="1">While not necessary, this is how the JSON data looks. Feel free to build your own:<p class="source-code">[</p><p class="source-code">    {</p><p class="source-code">        "type": "nonfiction",</p><p class="source-code">        "title": "Truth about Cats",</p><p class="source-code">        "pages": 200</p><p class="source-code">    }, </p><p class="source-code">     {</p><p class="source-code">        "type": "nonfiction",</p><p class="source-code">        "title": "Truth about Dogs",</p><p class="source-code">        "pages": 100</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">        "type": "fiction",</p><p class="source-code">        "title": "The Cat Said Meow",</p><p class="source-code">        "pages": 400</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">        "type": "fiction",</p><p class="source-code">        "title": "The Last Dog",</p><p class="source-code">        "pages": 600</p><p class="source-code">    }</p><p class="source-code">]</p></li>
				<li>In a new store (located in the usual place at <strong class="source-inline">store/index.js</strong>), set up an empty array for books, and then define an action that will use the Fetch API to retrieve the JSON content. (You'll see more examples of using APIs in <em class="italic">Chapter 10</em>, <em class="italic">Working with Vuex - Fetching Remote Data</em>, as well as a more powerful way of doing HTTP, in the form of the <strong class="source-inline">Axios</strong> library.) When the data is retrieved, it should then call a mutation to store the result:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    books:[]</p><p class="source-code">  },</p><p class="source-code">  mutations: {</p><p class="source-code">    setBooks(state, books) {</p><p class="source-code">      state.books = books;</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  actions: {</p><p class="source-code">    loadBooks(context) {</p><p class="source-code">      fetch('/data/books.json')</p><p class="source-code">      .then(res =&gt; res.json())</p><p class="source-code">      .then(res =&gt; {</p><p class="source-code">        context.commit('setBooks', res);</p><p class="source-code">      });</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>In order to call this action, add a <strong class="source-inline">dispatch</strong> call in your component to run the actions and then add code to display the books:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    Books</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">      &lt;li v-for="book in $store.state.books" :key="book.title"&gt;        {{ book.title }}&lt;/li&gt;</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  created() {</p><p class="source-code">    this.$store.dispatch('loadBooks');</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>In <em class="italic">Figure 9.6</em>, you can see the result of the asynchronous action requesting its data:</p><div id="_idContainer307" class="IMG---Figure"><img src="image/B15218_09_06.jpg" alt="Figure 9.6: An example of data loaded asynchronously&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.6: An example of data loaded asynchronously</p>
			<p>Now you've seen an example of working with asynchronous operations in your Vuex store. Note that you can use actions even if your code is synchronous. This may be a good idea in general if you aren't sure whether your data is going to be asynchronous in the future. Now let's look at a nice way to simplify some boilerplate Vuex syntax.</p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor298"/>Simplifying with mapState and mapGetters</h1>
			<p>As one of the last features we'll cover with Vuex, let's look at <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong>. These are handy utilities that help map state values and getters into your component's computed property. As a practical matter, it makes your HTML templates simpler. So instead of <strong class="source-inline">{{ $store.state.firstName }}</strong>, you can simply use <strong class="source-inline">{{ firstName }}</strong>. Instead of using <strong class="source-inline">{{ $store.getters.name }}</strong>, you can just use <strong class="source-inline">{{ name }}</strong>. </p>
			<p>Both <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong> can either take an array of values to map or an object where each key represents the name you wish to use in your component and the value is the <strong class="source-inline">state value</strong> or <strong class="source-inline">getter</strong> in the Vuex store. They are both used with your Vue application's <strong class="source-inline">computed</strong> block.</p>
			<p>In this first example, two state values and three getters are mapped by their name alone:</p>
			<p class="source-code">mapState(["age", "rank", "serialNumber"]);</p>
			<p class="source-code">mapGetters(["name", "fiction", "nonfiction"]);</p>
			<p>But if those names were perhaps too generic, or perhaps conflicted with existing data, you could specify other names for them:</p>
			<p class="source-code">mapState({</p>
			<p class="source-code">    howOld:"age",</p>
			<p class="source-code">    level:"rank",</p>
			<p class="source-code">    sn:"serialNumber"</p>
			<p class="source-code">});</p>
			<p class="source-code">mapGetters({</p>
			<p class="source-code">    ourName:"name", </p>
			<p class="source-code">    fictionBooks:"fictionBooks",</p>
			<p class="source-code">    nonfictionBooks: "nonfictionBooks"</p>
			<p class="source-code">});</p>
			<p>In order to use both <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong>, you will need to import them first:</p>
			<p class="source-code">import { mapState, mapGetters } from 'vuex';</p>
			<p>Usage of both these features will definitely help reduce the amount of code you write to work with Vuex. </p>
			<p>You will learn how to add <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong> with the help of the following exercise.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor299"/>Exercise 9.06: Adding mapState and mapGetters</h2>
			<p>Let's look at a simple example of this. In <em class="italic">Exercise 9.02</em>, we used getters to create a shortcut for getting a name value. We can simplify that code by applying what we just learned. We can use the map functions to simplify our code.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/3ldBxpb">https://packt.live/3ldBxpb</a>.</p>
			<ol>
				<li value="1">Create a new Vue application with Vuex and then copy over the store (located at <strong class="source-inline">store/index.js</strong>) into this new version. You will need state values for the first and last name, and a getter that returns the complete name:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import Vuex from 'vuex'</p><p class="source-code">Vue.use(Vuex)</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    firstName: "Lindy",</p><p class="source-code">    lastName: "Roberthon"</p><p class="source-code">  },</p><p class="source-code">  getters: {</p><p class="source-code">    name(state) {</p><p class="source-code">      return `${state.firstName} ${state.lastName}`;</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>Edit the main component. You will want to edit all three values from the store (both the state values and the getter), but make use of <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong> to simplify it:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">    My name is {{ firstName }} {{ lastName}}, or just {{ name }}.</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import { mapGetters } from 'vuex';</p><p class="source-code">import { mapState } from 'vuex';</p><p class="source-code">export default {</p><p class="source-code">  name: 'app',</p><p class="source-code">  computed: {</p><p class="source-code">    ...mapState([ "firstName", "lastName" ]),</p><p class="source-code">    ...mapGetters([</p><p class="source-code">      "name"</p><p class="source-code">    ])</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>As you can see, by using <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong>, we've provided a way for the template portion of the app to make use of the data somewhat simpler:</p><p class="source-code">My name is Lindy Roberthon, or just Lindy Roberthon.</p></li>
			</ol>
			<p>When done, you should see exactly the same output as you've seen before. The important part is that the amount of code you needed to write was reduced! </p>
			<p>In the next section, we'll briefly talk about <strong class="source-inline">mapMutations</strong> and <strong class="source-inline">mapActions</strong>.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor300"/>Simplifying with mapMutations and mapActions</h1>
			<p>The final features we'll cover are very similar to the previous one: <strong class="source-inline">mapMutations</strong> and <strong class="source-inline">mapActions</strong>. As you can probably guess, these two features work very similarly to <strong class="source-inline">mapState</strong> and <strong class="source-inline">mapGetters</strong>, in that they provide a shorthand way to connect your code to Vuex mutations and actions without writing boilerplate code.</p>
			<p>They follow the exact same format in that you can specify a list of items to map or specify a list while also providing a different name, as in the following example:</p>
			<p class="source-code">mapMutations(["setBooks"]);</p>
			<p class="source-code">mapActions(["loadBooks"]);</p>
			<p>These can be used in your Vue component's <strong class="source-inline">methods</strong> block: </p>
			<p class="source-code">methods:{</p>
			<p class="source-code">    ...mapMutations(["setBooks"]),</p>
			<p class="source-code">    ...mapActions(["loadBooks"])</p>
			<p class="source-code">}</p>
			<p>This then allows your Vue code to call either <strong class="source-inline">setBooks</strong> or <strong class="source-inline">loadBooks</strong> without specifying the <strong class="source-inline">store</strong> object, or <strong class="source-inline">dispatch</strong> and <strong class="source-inline">commit</strong>. </p>
			<p>Now, let's try to create a simple shopping cart and a price calculator on our own.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor301"/>Activity 9.01: Creating a Simple Shopping Cart and Price Calculator</h2>
			<p>Imagine a hypothetical corporate hardware site that lets employees select products they need shipping to their office. This cart is much simpler than a typical e-commerce site as it doesn't need to process credit cards or even ask the person where they are (IT knows where you sit!). It still needs to present you with a list of items, let you select how much you want, and then provide you with a total price that will be billed to your department.</p>
			<p>In this activity, you need to build a Vuex store that represents the available products and their prices. You will need multiple components to handle the different aspects of the application and properly interact with the store data.</p>
			<p><strong class="bold">Steps:</strong></p>
			<ol>
				<li value="1">Build a store and define an array of products and a cart in the state. Every product will have <strong class="source-inline">name</strong> and <strong class="source-inline">price</strong> properties.</li>
				<li>Define a component that lists out each product and price.</li>
				<li>Modify the component to have buttons to add, or remove, one of the products from your cart.</li>
				<li>Define a second component that shows the current cart (every product and quantity).</li>
				<li>Use a third component that displays the total cart price and has a button to complete the checkout. The total price is the sum of each product in the cart multiplied by the quantity of the product. For this activity, the <strong class="source-inline">checkout</strong> button should simply alert the user that the checkout process is done but take no other steps.</li>
			</ol>
			<p>You should get the following output initially, showing an empty cart:</p>
			<div>
				<div id="_idContainer308" class="IMG---Figure">
					<img src="image/B15218_09_07.jpg" alt="Figure 9.7: Initial display of the cart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7: Initial display of the cart</p>
			<p>As you add and remove items, you'll see the cart and totals update in real time:</p>
			<div>
				<div id="_idContainer309" class="IMG---Figure">
					<img src="image/B15218_09_08.jpg" alt="Figure 9.8: The cart with items of multiple quantities added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8: The cart with items of multiple quantities added</p>
			<p>As you can see, as products are added, the cart display updates to show quantity values and the total in the <strong class="source-inline">Checkout</strong> section accurately reflects the total price.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor399">this link</a>.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor302"/>Summary</h1>
			<p>In this chapter, you have seen most of Vuex's features and should now have an idea of how to both read from and write to the store. You employed mutations for synchronous changes and actions for asynchronous modifications. You created getters to provide access to virtual values based on your state. You have also seen how components look when working with the store. They've got less logic and simply hand off that part to the store. In larger Vue applications, this will become even more important. Your components will handle the UI and UX, but let the store handle the data layer. Having the store as a single source of truth, then, relieves you of so much "grunt" work that you will come to greatly appreciate Vuex, even in smaller applications.</p>
			<p>In the next chapter, you will learn about using remote data with Vuex stores. Working with remote APIs is a common need in modern web applications. Integrating these APIs in Vuex will make it easier for the rest of your Vue application to use the data provided by remote services.</p>
		</div>
		<div>
			<div id="_idContainer311" class="Content">
			</div>
		</div>
	</body></html>