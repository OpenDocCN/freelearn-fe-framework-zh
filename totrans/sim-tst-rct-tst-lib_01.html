<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer013">
			<h1 id="_idParaDest-14"><em class="italic"><a id="_idTextAnchor013"/>Chapter 1</em>: Exploring React Testing Library</h1>
			<p><strong class="bold">React Testing Library</strong> is a modern tool for testing the UI output of React components. It abstracts a lot of boilerplate code, allowing you to write code that is easier to read, and allows you to test the code. The library encourages you to move away from testing implementation details, to avoid many false negative and false positive test cases. Instead, the library's API of tools makes it easy for you to write tests that simulate actual users' behaviors with your components, yielding confidence that the application works as expected for users. Also, because the library urges you to focus on the user when writing tests, you don't need to continuously update tests that fail when you refactor the code's implementation details. The React Testing Library allows you to write tests that fail when critical functionality unexpectedly changes, thus providing more value.</p>
			<p>By the end of this chapter, you will understand what the implementation details are and the disadvantages they bring regarding maintenance and value in your test cases. For many years, it has been common for teams to test their components by focusing on the code's implementation details. Many teams still use this approach today. However, there are better ways to test the components that we will cover in this chapter. You will learn how to add confidence to your test case planning by understanding how to shift your thinking toward testing from the user's perspective. We will introduce you to the ideas behind the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) Testing Library to ease the task of testing before transitioning to the primary focus, the React version of the library.</p>
			<p>Next, you will learn about the Jest testing framework, tasked with executing and asserting our tests' output. Finally, you will learn how to install and use the <strong class="source-inline">jest-dom</strong> utility to enhance test assertions.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Learning about the DOM Testing Library</li>
				<li>Understanding the role of Jest in testing React applications</li>
				<li>Learning about the advantages of using <strong class="source-inline">jest-dom</strong> to test React applications with Jest</li>
				<li>Understanding the disadvantages of implementation detail-focused testing</li>
			</ul>
			<p>The lessons of this chapter will set the foundation for understanding how you will use React Testing Library throughout this book to write better tests that focus on the user's perspective. The skills gained in this chapter will help whether you are new to writing tests for React applications or are an experienced tester looking for better ways to verify that your code works as expected.</p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Technical requirements</h1>
			<p>For the examples in this chapter, you will need to have Node.js installed on your machine. You can find the code examples for this chapter here: <a href="https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01">https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter01</a>.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Introducing the DOM Testing Library</h1>
			<p>The <strong class="bold">DOM Testing Library</strong> is a collection of tools created by Kent C. Dodds and numerous contributors to make our lives easier when our goal is to test our applications' UI from real <a id="_idIndexMarker000"/>users' perspectives. This section will give you an overview of how the library can help make testing efforts focused on users' perspectives a lot easier. </p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>What is the DOM Testing Library?</h2>
			<p>The DOM Testing Library <a id="_idIndexMarker001"/>makes it easier to test the UI of applications like real users to gain confidence that the application works as expected for users. There are no methods to get the component's state value or directly invoke component methods. </p>
			<p>The library encourages you to select DOM elements in ways that are available to all users. The library's API includes accessibility-focused query methods allowing you to interact with the DOM like users with disabilities who require tools such as screen readers or other forms of assistive technology to navigate applications. For example, say you want to select the following element in your test:</p>
			<p class="source-code">&lt;input</p>
			<p class="source-code">  type="text"</p>
			<p class="source-code">  id="firstname"</p>
			<p class="source-code">  placeholder="first name..."</p>
			<p class="source-code">&gt;</p>
			<p>In the preceding code, we have an input element of type <strong class="source-inline">"text"</strong>. You could select the input on the screen by its placeholder value of <strong class="source-inline">"First Name..."</strong> with the DOM Testing Library like so:</p>
			<p class="source-code">screen.getByPlaceholderText(/first name/i) </p>
			<p>The <strong class="source-inline">getByPlaceholderText</strong> method is used from the screen object to select the DOM element by its <a id="_idIndexMarker002"/>placeholder value in the preceding code. The screen object allows you to select elements attached to the body element of the DOM. Notice the regular expression used in the query. It is doubtful that a user would care if the text were in upper or lowercase, so the DOM Testing Library allows you to search for elements by text values regardless of the case.</p>
			<p>Having the ability to select elements by text value regardless of their case increases the test's ability to maintain a passing result despite changes to implementation details of the element. The use of the <strong class="source-inline">getByPlaceholderText</strong> method is a great way to select elements, but we can be even more specific by refactoring the source code:</p>
			<p class="source-code"><strong class="bold">&lt;label for="firstname"&gt;First name:&lt;/label&gt;</strong></p>
			<p class="source-code">&lt;input</p>
			<p class="source-code">  type="text"</p>
			<p class="source-code">  id="firstname"</p>
			<p class="source-code">  <strong class="bold">name="firstname"</strong></p>
			<p class="source-code">  placeholder="first name..."</p>
			<p class="source-code">&gt;</p>
			<p>In the preceding code, we added a <strong class="source-inline">label</strong> element and an accessible <strong class="source-inline">name</strong> attribute to the input. Now all users, including those using screen readers, can access the element. We can select the input element in our test like so:</p>
			<p class="source-code">screen.getByRole('textbox', {</p>
			<p class="source-code">  name: /first name:/i</p>
			<p class="source-code">})</p>
			<p>In the preceding code, we use the <strong class="source-inline">getByRole</strong> method to select the element by its role of a textbox with the name <strong class="source-inline">first name</strong>. Selecting an element by its role is the preferred way to select elements with the DOM Testing Library when available.</p>
			<p>The library is very <a id="_idIndexMarker003"/>flexible in that you can use it with any JavaScript test runner, such as Mocha or Jest, that provides APIs to access the DOM. We will run our tests with Jest in this book and learn more about it in the next section. There are many specific versions of the DOM Testing Library for popular UI frameworks and libraries.</p>
			<p>The particular versions add extra features to the DOM Testing Library's API for more comfortable use. For example, to place a React component under test into the DOM, we can use the <strong class="source-inline">render</strong> method of <strong class="source-inline">ReactDOM</strong> to place the component into an element attached to the DOM:</p>
			<p class="source-code">const div = document.createElement('div');</p>
			<p class="source-code">ReactDOM.render(&lt;SomeComponent /&gt;, div);</p>
			<p class="source-code">document.body.appendChild(div);</p>
			<p class="source-code">screen.getByText('Login');</p>
			<p>In the preceding code, first, we create a <strong class="source-inline">div</strong> element. Next, we attach <strong class="source-inline">SomeComponent</strong> to the <strong class="source-inline">div</strong> element. Then, we attach <strong class="source-inline">div</strong> to the <strong class="source-inline">body</strong> element of the DOM. Finally, we use the <strong class="source-inline">getByText</strong> method of the DOM Testing Library's <strong class="source-inline">screen</strong> object to find an element with the text value of <strong class="source-inline">Login</strong>. If we use React Testing Library, we can replace the first three lines from the preceding code with the <strong class="source-inline">render</strong> method:</p>
			<p class="source-code">render(&lt;SomeComponent /&gt;);</p>
			<p>In the preceding code, we use React Testing Library's <strong class="source-inline">render</strong> method to automatically render the component under test into the DOM for us. We will show you how to use the React version of the library throughout this book. There is even support for many popular end-to-end testing frameworks, such as Cypress (<a href="https://www.cypress.io/">https://www.cypress.io/</a>), which we will cover in <a href="B16887_07_Final_PG_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 7</em></a>, <em class="italic">End-to-End UI Testing with Cypress</em>. The library provides a utility to enhance test assertions with Jest, which we will cover later in this chapter.</p>
			<p>Next, we will cover the guiding<a id="_idIndexMarker004"/> principles behind the DOM Testing Library.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Guiding principles</h2>
			<p>The DOM Testing Library is driven by <a id="_idIndexMarker005"/>providing easy-to-use APIs to test your rendered applications in the DOM. The tools help give you confidence that your tests represent actions that actual users are likely to take. For example, you might build an email form allowing customers to subscribe to your newsletter such as the following:</p>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="Images/Figure_1.1_B16887.jpg" alt="Figure 1.1 – Subscription form component" width="342" height="255"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Subscription form component</p>
			<p>Because you want to be sure that the form works, you'll think about the steps a potential subscriber would take while interacting with the form. You think to yourself, <em class="italic">If I were a user, first, I might look for a label named Email Address or a placeholder that has the text "enter an email."</em> The DOM Testing Library has a method called <strong class="source-inline">getByLabelText</strong> to quickly find the email input by the label displayed on the screen. The DOM Testing Library has another method called <strong class="source-inline">getByPlaceholderText</strong> that allows you to locate an input via its placeholder value.</p>
			<p>After entering the email, you think to yourself, <em class="italic">Next, I would look for a button with the text "Subscribe" and click it</em>. The DOM Testing Library provides a method called <strong class="source-inline">getByText</strong> that allows you to find a button by its text value. Also, the library provides a method called <strong class="source-inline">getByRole</strong> that enables you to query the DOM specifically for an element with the role of <strong class="source-inline">button</strong> with the <strong class="source-inline">subscribe</strong> text value.</p>
			<p>Now that you understand <a id="_idIndexMarker006"/>the DOM Testing Library's general concepts, we will discuss the framework we will use to execute our test cases in the next section.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Executing test cases with Jest</h1>
			<p><strong class="bold">Jest</strong> is a JavaScript testing<a id="_idIndexMarker007"/> framework created by the team at Facebook. In this section, we will cover a brief overview of Jest and how we can use it to verify the output of test cases for React components.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Running tests with Jest</h2>
			<p>Most React projects are<a id="_idIndexMarker008"/> tested with Jest, so it makes sense to introduce this tool alongside learning React Testing Library. When we write our tests using React Testing Library, we need a test runner to execute the test.</p>
			<p>Use the following command to install Jest in your project:</p>
			<p class="source-code">npm install --save-dev jest</p>
			<p>We will run our React tests using Jest. At a high level, Jest provides the <strong class="source-inline">describe</strong>, <strong class="source-inline">it</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">expect</strong> functions to organize and execute tests. You can think of the <strong class="source-inline">describe</strong> function as a test suite. Use the <strong class="source-inline">describe</strong> function to group related tests for specific components. The <strong class="source-inline">it</strong> and <strong class="source-inline">test</strong> functions are for specific tests. The <strong class="source-inline">it</strong> and <strong class="source-inline">test</strong> functions are interchangeable functions used to house and run the code for individual test cases. Use the <strong class="source-inline">expect</strong> function to assert the expected output. Jest also provides mock functions to handle code outside the realm of tests and coverage reporting. A test written with Jest can be as simple as testing the output of a pure function.</p>
			<p>In the following example, we use the <strong class="source-inline">test</strong> and <strong class="source-inline">expect</strong> functions to assert the total number of characters in a provided name:</p>
			<p class="source-code">test('should return the total number of characters', () =&gt; {</p>
			<p class="source-code">  function totalCharsInName(name) {</p>
			<p class="source-code">    return name.length;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  expect(totalCharsInName('Steve')).toEqual(5);</p>
			<p class="source-code">});</p>
			<p>Let's look at an example<a id="_idIndexMarker009"/> test that will assert the details of a <strong class="source-inline">Profile</strong> component created with a class-style React component. The <strong class="source-inline">Profile</strong> component accepts employee information and displays it as a card-style element in the DOM. A user can click a button to hide or show the employee's details on the screen. Here is a screenshot of the component's DOM output:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="Images/Figure_1.2_B16887.jpg" alt="Figure 1.2 – Profile component&#13;&#10;" width="338" height="420"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Profile component</p>
			<p>Let's take a look at the code for the <strong class="source-inline">Profile</strong> component. We create a <strong class="source-inline">state</strong> object with the <strong class="source-inline">showDetails</strong> property initially set to <strong class="source-inline">true</strong>. Next, we create a <strong class="source-inline">setDetails</strong> method that will update the <strong class="source-inline">state</strong> value of <strong class="source-inline">showDetails</strong>:</p>
			<p class="source-code">import React, { Component } from 'react';</p>
			<p class="source-code">export default class Profile extends Component {</p>
			<p class="source-code">  <strong class="bold">state = { showDetails: true };</strong></p>
			<p class="source-code">  <strong class="bold">setDetails = () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    this.setState((prevState) =&gt; ({ showDetails: !prevState.      showDetails }));</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p>Inside the <strong class="source-inline">render</strong> method, we<a id="_idIndexMarker010"/> display the <strong class="source-inline">name</strong> and <strong class="source-inline">title</strong> properties passed into the component:</p>
			<p class="source-code">render() {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">      &lt;div className="card" style={{ width: "18rem" }}&gt;</p>
			<p class="source-code">        &lt;img</p>
			<p class="source-code">          className="card-img-top"</p>
			<p class="source-code">          src="http://fakeimg.pl/286x180?font=lobster"</p>
			<p class="source-code">          alt="Card cap"</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">        &lt;div className="card-body"&gt;</p>
			<p class="source-code">          &lt;h5 className="card-title"&gt;{<strong class="bold">this.props.name</strong>}&lt;/h5&gt;</p>
			<p class="source-code">          &lt;p className="card-subtitle mb-2 text-muted"&gt;{<strong class="bold">this.             props.title</strong>}&lt;/p&gt;</p>
			<p>Note that the <strong class="source-inline">src</strong> image just has a placeholder image, but ideally would accept a passed-in value such as the <strong class="source-inline">name</strong> and <strong class="source-inline">title</strong> property values.</p>
			<p>Lastly, we have a button that invokes the <strong class="source-inline">setDetails</strong> method when clicked. The button's text is set to either <strong class="source-inline">Hide Details</strong> or <strong class="source-inline">Display Details</strong> based on the value of <strong class="source-inline">state.showDetails</strong>. Also, the employee details are displayed based on the value of <strong class="source-inline">state.showDetails</strong>:</p>
			<p class="source-code">button onClick={<strong class="bold">this.setDetails</strong>} className="btn btn-primary"&gt;</p>
			<p class="source-code">            {<strong class="bold">this.state.showDetails ? "Hide Details" : "Display                  Details"</strong>}</p>
			<p class="source-code">          &lt;/button&gt;</p>
			<p class="source-code">          {<strong class="bold">this.state.showDetails</strong> ? (</p>
			<p class="source-code">            <strong class="bold">&lt;p className="card-text details"&gt;{this.props.                  details}&lt;/p&gt;</strong></p>
			<p class="source-code">          ) : null}</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now, let's look at the code for a <strong class="source-inline">Profile</strong><a id="_idIndexMarker011"/> component test that verifies the button with the text <strong class="source-inline">"display details"</strong> is shown when the button with the text <strong class="source-inline">"hide details"</strong> is clicked:</p>
			<p class="source-code">test('Profile, given click "hide details" button, shows "display details" button', () =&gt; {</p>
			<p class="source-code">  const div = document.createElement('div');</p>
			<p class="source-code">  ReactDOM.render(</p>
			<p class="source-code">    &lt;Profile</p>
			<p class="source-code">      name='John Doe'</p>
			<p class="source-code">      title='Team Lead'</p>
			<p class="source-code">      details='This is my 5th year and I love helping others'</p>
			<p class="source-code">    /&gt;,</p>
			<p class="source-code">    div</p>
			<p class="source-code">  );</p>
			<p class="source-code">document.body.appendChild(div);</p>
			<p>In the preceding code, we create a <strong class="source-inline">div</strong> element to later use with the component under test. Next, we use the <strong class="source-inline">render</strong> method of <strong class="source-inline">ReactDOM</strong> to render the <strong class="source-inline">Profile</strong> component with passed-in properties into <strong class="source-inline">div</strong>. Finally, we add <strong class="source-inline">div</strong> with the component to the <strong class="source-inline">body</strong> element of the<a id="_idIndexMarker012"/> DOM. Next, we perform actions on the resulting DOM output:</p>
			<p class="source-code">  const hideDetailsBtn = screen.getByRole('button', { name: /     hide details/i });</p>
			<p class="source-code">  fireEvent.click(hideDetailsBtn);</p>
			<p class="source-code">  const displayDetailsBtn = screen.getByRole('button', {</p>
			<p class="source-code">    name: /display details/i,</p>
			<p class="source-code">  });</p>
			<p>In the preceding code, first we grab the button with the name <strong class="source-inline">hide details</strong>. Next, we fire a click event on the <strong class="source-inline">hide details</strong> button. Then, we grab the button with the name <strong class="source-inline">display details</strong>. Next, we will make assertions:</p>
			<p class="source-code">  expect(displayDetailsBtn).toBeTruthy();</p>
			<p class="source-code">  // Test cleanup</p>
			<p class="source-code">    div.remove();</p>
			<p class="source-code">});</p>
			<p>In the preceding code, first, we expect the <strong class="source-inline">display details</strong> button to be <em class="italic">truthy</em>, meaning the element is found in the DOM. Then, we do some test cleanup by removing <strong class="source-inline">div</strong> from the DOM's <strong class="source-inline">body</strong> element, allowing successive tests to start from a clean slate.</p>
			<p>Let's look at the previous test again by focusing on the Jest parts of the code.</p>
			<p>All the code for a specific test lives inside an <strong class="source-inline">it</strong> or <strong class="source-inline">test</strong> method:</p>
			<p class="source-code"><strong class="bold">test</strong>(Profile, given click "hide details" button, shows "display   details" button', () =&gt; {}</p>
			<p class="source-code"><strong class="bold">it</strong>(Profile, given click "hide details" button, shows "display   details" button', () =&gt; {}</p>
			<p>This method and others in the test file will execute when Jest is run with the <strong class="bold">Node Package Manager</strong> (<strong class="source-inline">npm</strong>) test. Jest will find your<a id="_idIndexMarker013"/> test file, execute tests within it, and show the test <a id="_idIndexMarker014"/>results in the console:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="Images/Figure_1.3_B16887.jpg" alt="Figure 1.3 – Profile test passed console output&#13;&#10;" width="1379" height="281"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Profile test passed console output</p>
			<p>If we had multiple tests for a component, we could organize them together in the <strong class="source-inline">describe</strong> method:</p>
			<p class="source-code"><strong class="bold">describe</strong>(&lt;Profile /&gt;, () =&gt; {</p>
			<p class="source-code"> test(given click "hide details" button, shows "display   details" button', () =&gt; {}</p>
			<p class="source-code"> test('another test for the profile component', () =&gt; {}</p>
			<p class="source-code">}</p>
			<p>The most important part of a test is the assertion. In Jest, you can assert the output of the test using the <strong class="source-inline">expect</strong> method:</p>
			<p class="source-code"><strong class="bold">expect</strong>(displayDetailsBtn)<strong class="bold">.toBeTruthy();</strong></p>
			<p>The <strong class="source-inline">toBeTruthy</strong> method chained off the <strong class="source-inline">expect</strong> method is one of many matcher methods that Jest provides to verify the expected result of the code passed into <strong class="source-inline">expect</strong>.</p>
			<p>Now you understand the role Jest plays in testing React applications. You can install the framework and use its API to organize, write, and execute test cases. Next, you will learn about a utility provided by the<a id="_idIndexMarker015"/> Testing Library to add enhanced Jest assertion matchers to help with testing React components.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Enhancing Jest assertions with jest-dom</h1>
			<p><strong class="source-inline">jest-dom</strong> is a utility tool from <a id="_idIndexMarker016"/>the DOM Testing Library that provides extra Jest <a id="_idIndexMarker017"/>assertions to use in tests. In this section, you will learn how to install <strong class="source-inline">jest-dom</strong> and understand the advantages of using <strong class="source-inline">jest-dom</strong> with Jest.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Adding jest-dom to a project</h2>
			<p>Add <strong class="source-inline">jest-dom</strong> to a project that includes Jest<a id="_idIndexMarker018"/> using the following steps:</p>
			<ol>
				<li>Install the package using <strong class="source-inline">npm</strong>:<p class="source-code"><strong class="bold">npm install –-save-dev @testing-library/jest-dom</strong></p></li>
				<li>Add the following snippet to the top of your test file:<p class="source-code">import '@testing-library/jest-dom/extend-expect';</p></li>
			</ol>
			<p>After installing and importing <strong class="source-inline">jest-dom</strong> into your test file, you can start using the extra assertions as they are now chained off the <strong class="source-inline">expect</strong> method. You will see detailed illustrated use cases in the next section.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Advantages of using jest-dom with Jest</h2>
			<p>You can enhance user-focused testing goals <a id="_idIndexMarker019"/>by including <strong class="source-inline">jest-dom</strong> in React projects that use Jest. <strong class="source-inline">jest-dom</strong> provides two significant enhancements for Jest assertions. First, <strong class="source-inline">jest-dom</strong> provides over 20 custom DOM matchers that create more descriptive test code. Second, <strong class="source-inline">jest-dom</strong> also provides better context-specific error messages. We will show you examples of both advantages in the following subsections.</p>
			<h3>jest-dom descriptive test code examples</h3>
			<p>To illustrate the benefits of using <strong class="source-inline">jest-dom</strong>, first, we will revisit our <strong class="source-inline">Profile</strong> component test file from the previous section, <em class="italic">Introducing the DOM Testing Library</em>. Note that we will only focus on the <a id="_idIndexMarker020"/>assertion code in the test. We asserted the text value of an element:</p>
			<p class="source-code">const displayDetailsBtn = screen.getByRole('button', {</p>
			<p class="source-code">    name: /display details/i,</p>
			<p class="source-code">  });  </p>
			<p class="source-code">expect(displayDetailsBtn).toBeTruthy();</p>
			<p>The syntax of the previous code may not be as clear to some developers who are unfamiliar with the code base. It may not be evident that we are verifying the element is found in the DOM. <strong class="source-inline">jest-dom</strong> has a <strong class="source-inline">toBeInTheDocument()</strong> method to provide a more straightforward syntax.</p>
			<p>Next, we will refactor our code using use the <strong class="source-inline">jest-dom</strong> <strong class="source-inline">toBeInTheDocument()</strong> method to make the code more descriptive: </p>
			<p class="source-code">expect(displayDetailsBtn).<strong class="bold">toBeInTheDocument</strong>();</p>
			<p>Now, from the syntax it is more apparent that we are expecting the element to be in the DOM. We could also assert that the <strong class="source-inline">hide details</strong> button is removed from the DOM when clicked: </p>
			<p class="source-code">    const removedHideDetailsBtn = screen.queryByRole('button',       {</p>
			<p class="source-code">    name: /hide details/i,</p>
			<p class="source-code">  });</p>
			<p class="source-code">  expect(removedHideDetailsBtn).toBeFalsy();</p>
			<p>Jest's <strong class="source-inline">toBeFalsy()</strong> method was used to return a <strong class="source-inline">null</strong> value, which evaluates to <strong class="source-inline">false</strong> in JavaScript. For the test, this means the element was not found in the DOM. However, the syntax is not clear that using <strong class="source-inline">toBeFalsy()</strong> indicates the element wasn't found in the DOM as expected and may confuse some developers looking at the code.</p>
			<p>We can use the <strong class="source-inline">toBeInTheDocument()</strong> method again to provide a more straightforward syntax: </p>
			<p class="source-code">  expect(removedHideDetailsBtn).not.<strong class="bold">toBeInTheDocument()</strong>;</p>
			<p>Now, from the syntax in the previous code it is more apparent that we expect the element to not be in the DOM. Notice<a id="_idIndexMarker021"/> that Jest's <strong class="source-inline">not</strong> property is used before the <strong class="source-inline">jest-dom</strong> method. The <strong class="source-inline">not</strong> property is used to return the opposite value. If we did not use the <strong class="source-inline">not</strong> property, we would be asserting the element is in the DOM.</p>
			<p>For another example, let's say we have the following login form we want to test:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/Figure_1.4_B16887.jpg" alt="Figure 1.4 – Login component&#13;&#10;" width="529" height="531"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Login component</p>
			<p>In the previous screenshot, we have a login form feature that allows a user to enter a username and password and check a <strong class="bold">Remember Me</strong> checkbox. The <strong class="bold">Login</strong> button starts out in a <strong class="source-inline">disabled</strong> state until the user enters values for the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> fields. The login form in this example is currently still in development, so at the moment, nothing happens when a user clicks the <strong class="bold">Login</strong> button. However, we can write a test to verify the functionality of the <strong class="bold">Login</strong> button being enabled when a user enters credentials:</p>
			<p class="source-code">test('Login, given credentials, returns enabled submit button', () =&gt; {</p>
			<p class="source-code">  const div = document.createElement('div');</p>
			<p class="source-code">  ReactDOM.render(&lt;Login /&gt;, div);</p>
			<p class="source-code">  document.body.appendChild(div);</p>
			<p class="source-code">  const username = screen.getByRole('textbox', { name: /     username/i });</p>
			<p class="source-code">  const password = screen.getByLabelText(/password/i);</p>
			<p class="source-code">  const rememberMe = screen.getByRole('checkbox');</p>
			<p class="source-code">  const loginBtn = screen.getByRole('button', { name: /submit/i });</p>
			<p>In the preceding code, we<a id="_idIndexMarker022"/> set up our test by rendering the <strong class="source-inline">Login</strong> component into the <strong class="source-inline">div</strong> tag and attaching it to the <strong class="source-inline">body</strong> element in the DOM. Next, we grab all the form elements, which include the <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, <strong class="source-inline">rememberMe</strong>, and <strong class="source-inline">login</strong> buttons, and place them in variables.</p>
			<p>Next, we will perform user actions on the DOM:</p>
			<p class="source-code">  const fakeData = {</p>
			<p class="source-code">    username: 'test user',</p>
			<p class="source-code">    password: '123password',</p>
			<p class="source-code">  };</p>
			<p class="source-code">  fireEvent.change(username, { target: { value: fakeData.     username } });</p>
			<p class="source-code">  fireEvent.change(password, { target: { value: fakeData.     password } });</p>
			<p class="source-code">  fireEvent.click(rememberMe);</p>
			<p>In the preceding code, we create a <strong class="source-inline">fakeData</strong> object with values to use in the test. Next, we use <strong class="source-inline">fireEvent</strong> to add values to the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> fields and finally, to click the <strong class="source-inline">rememberMe</strong> checkbox. Next, we will make assertions:</p>
			<p class="source-code">  expect(loginBtn.hasAttribute('disabled')).toBe(false);</p>
			<p>In the preceding code, we assert that <strong class="source-inline">loginBtn</strong> has a <strong class="source-inline">disabled</strong> attribute set to <strong class="source-inline">false</strong>. However, we can use a <strong class="source-inline">jest-dom</strong> assertion method for a cleaner syntax:</p>
			<p class="source-code">  expect(loginBtn).not.<strong class="bold">toBeDisabled()</strong></p>
			<p>In the preceding code, we use the <strong class="source-inline">toBeDisabled()</strong> method to verify the <strong class="bold">Login</strong> button is not disabled in a more straightforward syntax. We can also use <strong class="source-inline">jest-dom</strong> methods to verify the <a id="_idIndexMarker023"/>expected state of the form after entering values:</p>
			<p class="source-code">  expect(screen.getByTestId('form')).<strong class="bold">toHaveFormValues</strong>({</p>
			<p class="source-code">    username: fakeData.username,</p>
			<p class="source-code">    password: fakeData.password,</p>
			<p class="source-code">    rememberMe: true,</p>
			<p class="source-code">  });</p>
			<p>In the preceding code, we use the <strong class="source-inline">toHaveFormValues()</strong> method to verify the form inputs have the entered <strong class="source-inline">fakeData</strong> values using an easy-to-read syntax. The great thing about our previous test is that as long as the functionality stays the same, we can continue building out the login form or refactor the internal code without concerns that our current tests will break.</p>
			<p>Now you understand how <strong class="source-inline">jest-dom</strong> methods allow you to write more descriptive test code. Next, we will use the same examples to illustrate how <strong class="source-inline">jest-dom</strong> methods provide better context-specific error messages.</p>
			<h3>jest-dom error message example</h3>
			<p>In the previous section, we <a id="_idIndexMarker024"/>asserted that the <strong class="bold">Login</strong> button was not disabled after a user entered the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> credentials for the <strong class="source-inline">Login</strong> component. We could have also asserted that the <strong class="bold">Login</strong> button is disabled before a user enters credentials. Before using the enhanced <strong class="source-inline">jest-dom assertion</strong> method, we could have mistakenly typed <strong class="source-inline">disable</strong> instead of <strong class="source-inline">disabled</strong> in the <strong class="source-inline">hasAttribute</strong> method:</p>
			<p class="source-code">expect(loginBtn.hasAttribute(<strong class="bold">'disable'</strong>)).toBe(true);</p>
			<p class="source-code">fireEvent.change(username, { target: { value: fakeData.username } });</p>
			<p class="source-code">fireEvent.change(password, { target: { value: fakeData.password } });</p>
			<p>The typo in the previous code would lead to the following test result output:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/Figure_1.5_B16887.jpg" alt="Figure 1.5 – Login component false negative test&#13;&#10;" width="1357" height="404"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Login component false negative test</p>
			<p>In the previous screenshot, the results indicate the test failed from receiving a false value at the point where we expect the <strong class="bold">Login</strong> button to be disabled and return a result of <strong class="source-inline">true</strong>. The result is a false negative because the source code was correct, but our test code was incorrect.</p>
			<p>The error message does not<a id="_idIndexMarker025"/> make it obvious that the assertion code had a typo causing our test not to receive the expected result. We could make a similar test code error by mistakenly using the <strong class="source-inline">not</strong> property with the <strong class="source-inline">jest-dom</strong> <strong class="source-inline">toBeDisabled</strong> method:</p>
			<p class="source-code">expect(loginBtn).<strong class="bold">not.toBeDisabled();</strong></p>
			<p class="source-code">fireEvent.change(username, { target: { value: fakeData.username } });</p>
			<p class="source-code">fireEvent.change(password, { target: { value: fakeData.password } });</p>
			<p class="source-code">fireEvent.click(rememberMe);</p>
			<p>In the previous code, we mistakenly assert the <strong class="bold">Login</strong> button is not disabled at the point in the test when it should be disabled. The test code mistake in the previous code would lead to the following test result output:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="Images/Figure_1.6_B16887.jpg" alt="Figure 1.6 – Second login component false negative test" width="1366" height="311"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Second login component false negative test</p>
			<p>In the previous screenshot, the results indicate the test fails, but we also receive helpful feedback for pinpointing the error while debugging. The test output informs us that the received element is disabled and <a id="_idIndexMarker026"/>logs the element to the console to view all the attributes. The <strong class="source-inline">disabled</strong> attribute is shown in the <strong class="source-inline">element</strong> output, which helps us understand that we need to debug our test code to know why we didn't receive the expected result.</p>
			<p>Now you know how <strong class="source-inline">jest-dom</strong>'s methods provide better context-specific error messages to resolve issues faster. In the next section, we will learn about the disadvantages of including implementation details in our tests.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Testing implementation details</h1>
			<p><strong class="bold">Implementation details</strong> include the <a id="_idIndexMarker027"/>component state's current value or explicitly invoking a method attached to a button in the DOM. Implementation details are the <em class="italic">under-the-hood</em> parts of components abstracted away from the user when they use the component. As an analogy, we can think of the experience of driving a car. To move, you must use the key to start the car, put the car into drive, and press the gas pedal. You don't need to know how everything is wired together in the engine under the vehicle's hood. You probably do not even care. All you care about is that you can drive the car when you perform the behaviors mentioned.</p>
			<p>In this section, you will explore the disadvantages of focusing on implementation details in your tests. We will show you examples of tests with implementation details. Finally, you will learn how to shift your focus away from thinking about implementation details when testing.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Problems with implementation detail-focused tests</h2>
			<p>When you write tests that focus<a id="_idIndexMarker028"/> on your code's internal details, you create a scenario that increases the chance you have of refactoring your tests whenever you change those details. For example, if you have a state object property named <strong class="source-inline">value</strong> and you write a test to assert that <strong class="source-inline">state.value === 3</strong>, that test will fail if you change the name of the state property to <strong class="source-inline">currentValue</strong>. Having your test code rely on the state object property's name is a problem because it adds a lot of unnecessary extra maintenance and slows down your workflow.</p>
			<p>Another problem is that executing this test case yields a false negative because its functionality did not change; only the state name changed. Your tests should give you confidence that the most valuable pieces of your application related to user behavior function as expected and quickly let you know why this is not the case.</p>
			<p>Testing implementation details does not verify application code from the most valuable testers' perspective, that of actual users. For example, if you build an account creation form component and ship it to production, an end user interacting with the form via the UI will care about filling out the form and clicking <strong class="bold">Submit</strong>, and will expect the next step to happen. You could test the implementation details of invoking the <strong class="source-inline">onChange</strong> method or updates to the state object property named <strong class="source-inline">usernameVal</strong> when the user enters new text.</p>
			<p>However, you can reduce risk for users if you test that when a user fills out the form, and they click the <strong class="bold">Submit</strong> button, the expected results happen. A user will not directly interact with methods or state objects; therefore, our tests can be more valuable by focusing on how users will interact with the form in the UI.</p>
			<p>In another example, using the same component, a software engineer is a user who will add the account creation form to the application code along with the required dependencies. The engineer user cares that the component renders as expected when they attempt to use it. Again, you could test the same implementation details mentioned in the first example.</p>
			<p>However, you can gain more confidence that the component will work as expected for users if you test that when an engineer renders the form with the required data, the data is present. Keep in mind that this does not mean you should never test the implementation details of your code. In most scenarios, tests that focus on the user provide more confidence than tests that focus on implementation details.</p>
			<p>Next, we will show you an example of testing implementation details to illustrate this further.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Implementation detail-focused test example</h2>
			<p>Let's look at an example test to<a id="_idIndexMarker029"/> illustrate further problems with testing the implementation details of components. The test will assert the details of a <strong class="source-inline">Profile</strong> component created with a class-style React component. The <strong class="source-inline">Profile</strong> component accepts employee information and displays it as a card-style element in the DOM. A user can click a button to hide or show the employee's details on the screen. Here is a screenshot of the component's DOM output:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="Images/Figure_1.7_B16887.jpg" alt="Figure 1.7 – Profile component&#13;&#10;" width="329" height="419"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Profile component</p>
			<p>Let's take a look at the code for the <strong class="source-inline">Profile</strong> component. We create a state object with the <strong class="source-inline">showDetails</strong> property initially set to <strong class="source-inline">true</strong>. Next, we create a <strong class="source-inline">setDetails</strong> method that will update the state value of <strong class="source-inline">showDetails</strong>:</p>
			<p class="source-code">import React, { Component } from 'react';</p>
			<p class="source-code">export default class Profile extends Component {</p>
			<p class="source-code">  <strong class="bold">state = { showDetails: true };</strong></p>
			<p class="source-code">  <strong class="bold">setDetails = () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    this.setState((prevState) =&gt; ({ showDetails: !prevState.      showDetails }));</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p>Inside the <strong class="source-inline">render</strong> method, we display<a id="_idIndexMarker030"/> the <strong class="source-inline">name</strong> and <strong class="source-inline">title</strong> properties passed into the component:</p>
			<p class="source-code">render() {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">      &lt;div className="card" style={{ width: "18rem" }}&gt;</p>
			<p class="source-code">        &lt;img</p>
			<p class="source-code">          className="card-img-top"</p>
			<p class="source-code">          src="http://fakeimg.pl/286x180?font=lobster"</p>
			<p class="source-code">          alt="Card cap"</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">        &lt;div className="card-body"&gt;</p>
			<p class="source-code">          &lt;h5 className="card-title"&gt;{<strong class="bold">this.props.name</strong>}&lt;/h5&gt;</p>
			<p class="source-code">          &lt;p className="card-subtitle mb-2 text-muted"&gt;{<strong class="bold">this.             props.title</strong>}&lt;/p&gt;</p>
			<p>Note that the <strong class="source-inline">src</strong> image just has a placeholder image, but ideally would accept a passed-in value such as the <strong class="source-inline">name</strong> and <strong class="source-inline">title</strong> property values.</p>
			<p>Lastly, we have a button that invokes the <strong class="source-inline">setDetails</strong> method when clicked. The button's text is set to either <strong class="source-inline">Hide Details</strong> or <strong class="source-inline">Display Details</strong> based on the value of <strong class="source-inline">state.showDetails</strong>. Also, employee details are displayed based on the value of<strong class="source-inline"> state.showDetails</strong>:</p>
			<p class="source-code">button onClick={<strong class="bold">this.setDetails</strong>} className="btn btn-primary"&gt;</p>
			<p class="source-code">            {<strong class="bold">this.state.showDetails ? "Hide Details" : "Display                 Details"</strong>}</p>
			<p class="source-code">          &lt;/button&gt;</p>
			<p class="source-code">          {<strong class="bold">this.state.showDetails</strong> ? (</p>
			<p class="source-code">            <strong class="bold">&lt;p className="card-text details"&gt;{this.props.                details}&lt;/p&gt;</strong></p>
			<p class="source-code">          ) : null}</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now, let's look at the<a id="_idIndexMarker031"/> test code for the <strong class="source-inline">Profile</strong> component. The test is created using Enzyme, which is a React testing utility that makes it difficult to avoid testing implementation details and Jest. In the test file, we have one test with four assertions for the <strong class="source-inline">Profile</strong> component.</p>
			<p>We mount the <strong class="source-inline">Profile</strong> component into the DOM with values set for the required dependencies. We set the <strong class="source-inline">name</strong> property to <strong class="source-inline">"John Doe"</strong>, the <strong class="source-inline">title</strong> property to <strong class="source-inline">"Team Lead"</strong>, and the <strong class="source-inline">details</strong> property to <strong class="source-inline">"This is my 5th year and I love helping others"</strong>:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import { mount } from 'enzyme';</p>
			<p class="source-code">import Profile from './Profile';</p>
			<p class="source-code">test('setDetails sets the state value', () =&gt; {</p>
			<p class="source-code"> const wrapper = mount(</p>
			<p class="source-code">   <strong class="bold">&lt;Profile</strong></p>
			<p class="source-code"><strong class="bold">     name="John Doe"</strong></p>
			<p class="source-code"><strong class="bold">     title="Team Lead"</strong></p>
			<p class="source-code"><strong class="bold">     details="This is my 5th year and I love helping others"</strong></p>
			<p class="source-code"><strong class="bold">   /&gt;</strong></p>
			<p class="source-code">  );</p>
			<p>Next, we make assertions on the resulting DOM output of the <strong class="source-inline">Profile</strong> component. We assert the value of the <strong class="source-inline">showDetails</strong> state property. We search the DOM for an element with the<strong class="source-inline">.card-text.details</strong> class<a id="_idIndexMarker032"/> and assert the value of its text. Then, we invoke the component's <strong class="source-inline">setDetails</strong> method:</p>
			<p class="source-code"> expect(wrapper.state('showDetails')).toEqual(true);</p>
			<p class="source-code"> expect(wrapper.find('.card-text.details').props().children).    toEqual(</p>
			<p class="source-code">  'This is my 5th year and I love helping others'</p>
			<p class="source-code"> );</p>
			<p class="source-code">wrapper.instance().setDetails();</p>
			<p>Finally, we assert that the <strong class="source-inline">showDetails</strong> state property has changed and that the element with the<strong class="source-inline">.card-text.details</strong> class is no longer in the DOM:</p>
			<p class="source-code"> expect(wrapper.state('showDetails')).toEqual(false);</p>
			<p class="source-code"> expect(wrapper.update().find('.card-text.details').exists()).    toBeFalsy();</p>
			<p class="source-code">});</p>
			<p>To summarize, the test makes assertions on the following implementation details:</p>
			<ul>
				<li>The state object</li>
				<li>The <strong class="source-inline">setDetails</strong> method</li>
				<li>The element with the class <strong class="source-inline">.card-text.details</strong></li>
			</ul>
			<p>If one of the state object's properties changes, our test will break. If the <strong class="source-inline">setDetails</strong> method's name is changed or replaced with some other code without affecting the functionality, our test will fail. Lastly, if the class name the test uses to select the element changes, our test will break.</p>
			<p>As you can see, the test's assertions can yield false negative results if the implementation details change as compared to functionality changes. This increases the likelihood of a need to update the test often, and not test based on actual users' behavior.</p>
			<p>Now that you understand the disadvantages of testing implementation details, let's look at better ways to test.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>How to move away from implementation detail testing</h2>
			<p>Now that you understand the<a id="_idIndexMarker033"/> disadvantages of implementation detail-focused testing, how do you write tests to ensure that they will work as expected for users? Simply create your tests as if the software under test was a black box. Your thought process should be, <em class="italic">What are the expectations a software engineer or end user may have while using this piece of software?</em> Let's look at the following <strong class="source-inline">Counter</strong> component with <strong class="bold">Add</strong> and <strong class="bold">Subtract</strong> buttons, which display the current value. The value is increased or decreased by 1 based on the clicked button:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="Images/Figure_1.8_B16887.jpg" alt="Figure 1.8 – Counter component&#13;&#10;" width="245" height="68"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Counter component</p>
			<p>Try to think of as many black-box scenarios a software engineer or end user may perform while using the form.</p>
			<p>Here are a few sample scenarios:</p>
			<ul>
				<li>When the <strong class="source-inline">Counter</strong> component is rendered, the counter is displayed in the DOM.</li>
				<li>When a user clicks the <strong class="bold">Add</strong> button, the current value is increased by 1.</li>
				<li>When a user clicks the <strong class="bold">Subtract</strong> button, the current value is decreased by 1.</li>
			</ul>
			<p>These scenarios provide assurance that our application works as expected for users compared to focusing on things such as state changes or method calls. </p>
			<p>Now you know how to move away from implementation detail-focused test cases and instead focus on actual users. We<a id="_idIndexMarker034"/><a id="_idIndexMarker035"/> have seen numerous examples applying the user-focused test approach from previous sections in this chapter.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Summary</h1>
			<p>In this chapter, you learned about the DOM Testing Library and how it is designed to help you write user-focused tests. You now understand how the design of the DOM Testing Library can help you gain confidence that your software works as intended for users. You learned how to install Jest and understand that it is a test runner and the tool we will use to test React code. You learned about <strong class="source-inline">jest-dom</strong>. You know how it can add better error messages and descriptive DOM matchers for your test assertions. You can now install and use <strong class="source-inline">jest-dom</strong> in a project that uses Jest. Finally, you have gained an understanding of the disadvantages of implementation detail-focused testing.</p>
			<p>In the next chapter, we will learn how to install and start writing tests for React components using React Testing Library.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Questions</h1>
			<ol>
				<li value="1">Install all the tools mentioned in this chapter and write a simple test.</li>
				<li>Search for examples of tests online that focus on implementation details. Identify all implementation details and create a refactored version of the tests using the DOM Testing Library.</li>
				<li>Search MDN Web Docs for articles about ARIA roles. Next, practice writing tests using the <strong class="source-inline">getByRole</strong> query to select various elements.</li>
			</ol>
		</div>
	</div></body></html>