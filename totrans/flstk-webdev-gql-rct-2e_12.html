<html><head></head><body>
		<div id="_idContainer069">
			<h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor183"/>Chapter 10</em>: Real-Time Subscriptions</h1>
			<p>The GraphQL <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) we have built is very advanced, as is the frontend. In the previous chapter, we introduced <strong class="bold">server-side rendering</strong> (<strong class="bold">SSR</strong>) to our application. We provided the user with a lot of information through the news feed, chats, and profile pages. The problem we are facing now, however, is that the user currently has to either refresh the browser or we have set a <strong class="source-inline">pollInterval</strong> property to Apollo Hooks to keep the display up to date. A better solution is to implement Apollo subscriptions through WebSockets. This allows us to refresh the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) of the user with the newest user information in real time without manual user interaction or polling.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Using GraphQL with WebSockets</li>
				<li>Implementing Apollo subscriptions</li>
				<li>JWT authentication with subscriptions</li>
				<li>Notifications with Apollo subscriptions</li>
			</ul>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor184"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository:</p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter10">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter10</a></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor185"/>Using GraphQL with WebSockets</h1>
			<p>In <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>, I explained all the main features <a id="_idIndexMarker790"/>that make GraphQL so useful. We mentioned <a id="_idIndexMarker791"/>that <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) is the <a id="_idIndexMarker792"/>standard network protocol when using GraphQL. The problem with regular HTTP connections, however, is that they are one-time requests. They can only respond with the data that exists at the time of the request. If the database receives a change concerning the posts or the chats, the user won't know about this until they execute another request. The UI shows outdated data in this case.</p>
			<p>To solve this issue, you can refetch all requests in a specific interval, but this is a bad solution because there's no time range that makes polling efficient. Every user would make unnecessary HTTP requests, which neither you nor the user wants.</p>
			<p>The best solution relies on WebSockets instead of HTTP requests. As with HTTP, WebSockets are <a id="_idIndexMarker793"/>also based on the <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>). One of the main features of WebSockets is that they allow bidirectional communication between the client and the server. Arguably, you could <a id="_idIndexMarker794"/>say that HTTP does the same since <a id="_idIndexMarker795"/>you send a request and get a response, but WebSockets work very differently. One requirement is that the web server supports WebSockets in general. If that's the case, the client can open a WebSocket connection to the server. The initial request to establish a WebSocket connection is a standard HTTP request. The server should then respond with a 101 status code. It tells the browser that it agrees to change the protocols from HTTP to WebSockets. If the connection is successful, the server can send updates through this connection to the client. These updates are also called messages or frames. There are no further requests needed by the client to let the server speak with the browser, unlike HTTP, where you always need a request first so that the server can respond to it.</p>
			<p>Using WebSockets or Apollo subscriptions would fix the issue we encounter when using polling. We have one connection that stays open all the time. The server can send messages to <a id="_idIndexMarker796"/>the client whenever data is added or updated. WebSocket <strong class="bold">Uniform Resource Locators</strong> (<strong class="bold">URLs</strong>) start with <strong class="source-inline">ws</strong> or <strong class="source-inline">wss</strong> instead of the ordinary <strong class="source-inline">http</strong> or <strong class="source-inline">https</strong>. With WebSockets, you can also save valuable bandwidth for the users, but these are not included for WebSocket messages. </p>
			<p>One disadvantage is that WebSockets are not a standard approach for implementing APIs. If you make your API public to third parties at some point, a standard HTTP API would likely fit better. Also, HTTP is much more optimized. HTTP requests can be cached and proxied easily with common web servers, such as nginx or Apache, but also by the browser itself, which is hard for WebSockets to do. The most significant impact on performance is that WebSocket connections are kept open as long as the user stays on your site. It's not a problem for one or a few hundred users, but scaling this to more people is likely to present you with some problems. However, it's still a very efficient solution to real-time web communication in contrast to polling, for example.</p>
			<p>Most GraphQL <a id="_idIndexMarker797"/>client libraries are specialized and optimized for the standard HTTP protocol. It's the most common approach, so that's understandable. The people behind Apollo have got you covered; they've built-in support for WebSockets and for the implementation of GraphQL subscriptions. You can use those packages not only with Apollo but also with many other libraries. Let's get started with implementing Apollo subscriptions.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor186"/>Digging deeper into Apollo subscriptions</h1>
			<p>With the earlier versions of Apollo Client, it was required that you install further packages to <a id="_idIndexMarker798"/>support WebSockets. Now, the only requirement is one further package that implements the WebSocket support on the server side.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can <a id="_idIndexMarker799"/>find an excellent overview and more details about Apollo subscriptions in the official documentation at <a href="https://www.apollographql.com/docs/react/data/subscriptions/">https://www.apollographql.com/docs/react/data/subscriptions/</a>.</p>
			<p>The first step is to install all the required packages to get GraphQL subscriptions working. Install them using <strong class="source-inline">npm</strong>, as follows:</p>
			<p class="source-code">npm install --save subscriptions-transport-ws graphql-subscriptions </p>
			<p>The following two packages provide the necessary modules for a subscription system:</p>
			<ul>
				<li>The <strong class="source-inline">graphql-subscriptions</strong> package <a id="_idIndexMarker800"/>provides the ability to connect our GraphQL backend with <a id="_idIndexMarker801"/>a <strong class="bold">publish-subscribe</strong> (<strong class="bold">PubSub</strong>) system. It gives the client the option to subscribe to specific channels and lets the backend publish new data to the client. It is an in-memory implementation that only works with one instance of our backend. It is discouraged for production use but it will help us to get it working locally.</li>
				<li>The <strong class="source-inline">subscriptions-transport-ws</strong> package gives our Apollo Server or other GraphQL <a id="_idIndexMarker802"/>libraries the option to accept WebSocket connections and accept queries, mutations, and subscriptions over WebSockets. Let's take a look at how we can implement subscriptions.</li>
			</ul>
			<p>First, we are going to create a new subscription type next to the <strong class="source-inline">RootQuery</strong> and <strong class="source-inline">RootMutation</strong> types inside the GraphQL schema. You can set up events or entities that a client can subscribe to and receive updates inside the new subscription type. It only works by adding <a id="_idIndexMarker803"/>the matching resolver functions as well. Instead of returning real data for this new subscription type, you return a special object that allows the client to subscribe to events for the specific entity. These entities can be things such as notifications, new chat messages, or comments on a post. Each of them has got its own subscription channel.</p>
			<p>The client can subscribe to these channels. It receives updates any time the backend sends a new WebSocket messageâ€”because data has been updated, for example. The backend calls a <strong class="source-inline">publish</strong> method that sends the new data through the subscription to all clients. You should be aware that not every user should receive all WebSocket messages since the content may include private data such as chat messages. There should be a filter before the update is sent to target only specific users. We'll see this feature later in the <em class="italic">Authentication with Apollo subscriptions</em> section.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor187"/>Subscriptions on Apollo Server</h2>
			<p>We have <a id="_idIndexMarker804"/>now installed all the essential packages. Let's start with the implementation for the backend, as follows: </p>
			<ol>
				<li>As mentioned previously, we are going to rely on WebSockets as they allow real-time communication between the frontend and the backend. We are first going to set up a new transport protocol for the backend.<p>Open the <strong class="source-inline">index.js</strong> file of the server. Import a new Node.js interface at the top of the file, like this:</p><p class="source-code">import { createServer } from 'http';</p><p>The <strong class="source-inline">http</strong> interface is included in Node.js by default. It handles the traditional HTTP protocol, making the use of many HTTP features easy for the developer.</p></li>
				<li>We are going to use the interface to create a standardized Node.js HTTP <strong class="source-inline">server</strong> object because the Apollo <strong class="source-inline">SubscriptionServer</strong> module expects such an object. We'll cover the Apollo <strong class="source-inline">SubscriptionServer</strong> module soon in this section. Add the following line of code beneath the initialization of Express.js, inside the <strong class="source-inline">app</strong> variable:<p class="source-code">const server = createServer(app);</p><p>The <strong class="source-inline">createServer</strong> function creates a new HTTP <strong class="source-inline">server</strong> object, based on the original <strong class="source-inline">Express.js</strong> instance. We pass the Express instance, which we saved inside the <strong class="source-inline">app</strong> variable. As you can see in the preceding code snippet, you only pass the <strong class="source-inline">app</strong> object as a parameter to the <strong class="source-inline">createServer</strong> function. </p></li>
				<li>We're <a id="_idIndexMarker805"/>going to use the new <strong class="source-inline">server</strong> object instead of the <strong class="source-inline">app</strong> variable to let our backend start listening for incoming requests. Remove the old <strong class="source-inline">app.listen</strong> function call from the bottom of the file because we'll be replacing it in a second. To get our server listening again, edit the initialization routine of the services. The <strong class="source-inline">for</strong> loop should now look like this:<p class="source-code">for (let i = 0; i &lt; serviceNames.length; i += 1) {</p><p class="source-code">Â Â const name = serviceNames[i];</p><p class="source-code">Â Â switch (name) {</p><p class="source-code">Â Â Â Â case 'graphql':</p><p class="source-code">Â Â Â Â Â Â (async () =&gt; {</p><p class="source-code">Â Â Â Â Â Â Â Â await services[name].start();</p><p class="source-code">Â Â Â Â Â Â Â Â app.use(graphqlUploadExpress());</p><p class="source-code">Â Â Â Â Â Â Â Â services[name].applyMiddleware({ app });</p><p class="source-code">Â Â Â Â Â Â })();</p><p class="source-code">Â Â Â Â Â Â break;</p><p class="source-code">Â Â Â Â case 'subscriptions':</p><p class="source-code">Â Â Â Â Â Â server.listen(8000, () =&gt; {</p><p class="source-code">Â Â Â Â Â Â Â Â console.log('Listening on port 8000!');</p><p class="source-code">Â Â Â Â Â Â Â Â services[name](server);</p><p class="source-code">Â Â Â Â Â Â });</p><p class="source-code">Â Â Â Â break;</p><p class="source-code">Â Â Â Â default:</p><p class="source-code">Â Â Â Â Â Â app.use('/${name}', services[name]);</p><p class="source-code">Â Â Â Â Â Â break;</p><p class="source-code">Â Â }</p><p class="source-code">}</p><p>Here, we have <a id="_idIndexMarker806"/>changed the old <strong class="source-inline">if</strong> statement to a <strong class="source-inline">switch</strong> statement. Furthermore, we have added a second service beyond <strong class="source-inline">graphql</strong>, called <strong class="source-inline">subscriptions</strong>. We are going to create a new <strong class="source-inline">subscriptions</strong> service next to the <strong class="source-inline">graphql</strong> services folder.</p><p>The <strong class="source-inline">subscriptions</strong> service requires the <strong class="source-inline">server</strong> object as a parameter to start listening for WebSocket connections. Before initializing <strong class="source-inline">SubscriptionServer</strong>, we need to have started listening for incoming requests. That is why we use the <strong class="source-inline">server.listen</strong> method in the preceding code snippet before initializing the new <strong class="source-inline">subscriptions</strong> service that creates an Apollo <strong class="source-inline">SubscriptionServer</strong> instance. We pass the <strong class="source-inline">server</strong> object to the service after it has started listening. The service has to accept this parameter, of course, so keep this in mind. </p></li>
				<li>To add the new service into the preceding <strong class="source-inline">serviceNames</strong> object, edit the <strong class="source-inline">index.js</strong> services file with the following content:<p class="source-code">import graphql from './graphql';</p><p class="source-code">import subscriptions from './subscriptions';</p><p class="source-code">export default utils =&gt; ({</p><p class="source-code">Â Â graphql: graphql(utils),</p><p class="source-code">Â Â subscriptions: subscriptions(utils),</p><p class="source-code">});</p><p>The <strong class="source-inline">subscriptions</strong> service also receives the <strong class="source-inline">utils</strong> object, as with the <strong class="source-inline">graphql</strong> service.</p></li>
				<li>Now, create a <strong class="source-inline">subscriptions</strong> folder next to the <strong class="source-inline">graphql</strong> folder. To fulfill the import of <a id="_idIndexMarker807"/>the preceding <strong class="source-inline">subscriptions</strong> service, insert the service's <strong class="source-inline">index.js</strong> file into this folder. There, we can implement the <strong class="source-inline">subscriptions</strong> service. As a reminder, we pass the <strong class="source-inline">utils</strong> object and also the <strong class="source-inline">server</strong> object from before. The <strong class="source-inline">subscriptions</strong> service must accept two parameters in separate function calls.</li>
				<li>If you have created a new subscription <strong class="source-inline">index.js</strong> file, import all the dependencies at the top of the file, as follows:<p class="source-code">import { makeExecutableSchema } from '@graphql-tools/schema';</p><p class="source-code">import { SubscriptionServer } from 'subscriptions-transport-ws';</p><p class="source-code">import { execute, subscribe } from 'graphql';</p><p class="source-code">import jwt from 'jsonwebtoken';</p><p class="source-code">import Resolvers from '../graphql/resolvers';</p><p class="source-code">import Schema from'../graphql/schema';</p><p class="source-code">import auth from '../graphql/auth';</p><p>The preceding dependencies are almost the same as those that we are using for the <strong class="source-inline">graphql</strong> service, but we've added the <strong class="source-inline">subscriptions-transport-ws</strong> and <strong class="source-inline">@graphql-tools/schema</strong> packages. Furthermore, we've removed the <strong class="source-inline">apollo-server-express</strong> package. <strong class="source-inline">SubscriptionServer</strong> is the equivalent of <strong class="source-inline">ApolloServer</strong> but is used for WebSocket connections rather than HTTP. It usually makes sense to set up Apollo Server for HTTP and <strong class="source-inline">SubscriptionServer</strong> for WebSockets in the same file, as this saves us from processing <strong class="source-inline">Schema</strong> and <strong class="source-inline">Resolvers</strong> twice. It's easier to explain the implementation of subscriptions without the <strong class="source-inline">ApolloServer</strong> code in the same file, though. The last two things that are new in the preceding code snippet are the <strong class="source-inline">execute</strong> and <strong class="source-inline">subscribe</strong> functions that we import from the <strong class="source-inline">graphql</strong> package. You will see why we need these in the next section.</p></li>
				<li>We begin <a id="_idIndexMarker808"/>the implementation of the new service by exporting a function with the <strong class="source-inline">export default</strong> statement and creating an <strong class="source-inline">executableSchema</strong> object (as you saw in <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting up GraphQL with Express.js</em>), as follows:<p class="source-code">export default (utils) =&gt; (server) =&gt; {</p><p class="source-code">Â Â const executableSchema = makeExecutableSchema({</p><p class="source-code">Â Â Â Â typeDefs: Schema,</p><p class="source-code">Â Â Â Â resolvers: Resolvers.call(utils),</p><p class="source-code">Â Â Â Â schemaDirectives: {</p><p class="source-code">Â Â Â Â Â Â auth: auth</p><p class="source-code">Â Â Â Â },</p><p class="source-code">Â Â });</p><p class="source-code">}</p><p>As you can see, we <a id="_idIndexMarker809"/>use the <strong class="bold">ECMAScript 6</strong> (<strong class="bold">ES6</strong>) arrow notation to return two functions at the same time. The first one accepts the <strong class="source-inline">utils</strong> object and the second one accepts the <strong class="source-inline">server</strong> object that we create with the <strong class="source-inline">createServer</strong> function inside the <strong class="source-inline">index.js</strong> file of the server. This approach fixes the problem of passing two parameters in separate function calls. The schema is only created when both functions are called.</p></li>
				<li>The second step is to start <strong class="source-inline">SubscriptionServer</strong> to accept WebSocket connections and, as a result, be able to use the GraphQL subscriptions. Insert the following code under <strong class="source-inline">executableSchema</strong>:<p class="source-code">new SubscriptionServer({</p><p class="source-code">Â Â execute,</p><p class="source-code">Â Â subscribe,</p><p class="source-code">Â Â schema: executableSchema,</p><p class="source-code">}, </p><p class="source-code">{</p><p class="source-code">Â Â server,</p><p class="source-code">Â Â path: '/subscriptions',</p><p class="source-code">}); </p><p>We initialized a new <strong class="source-inline">SubscriptionServer</strong> instance in the preceding code. The first parameter <a id="_idIndexMarker810"/>we pass is a general <strong class="source-inline">options</strong> object for GraphQL and corresponds to the options of the <strong class="source-inline">ApolloServer</strong> class. The options are detailed as follows:</p><p>a. The <strong class="source-inline">execute</strong> property should receive a function that handles all the processing and execution of incoming GraphQL requests. The standard is to pass the <strong class="source-inline">execute</strong> function that we imported from the <strong class="source-inline">graphql</strong> package previously.</p><p>b. The <strong class="source-inline">subscribe</strong> property also accepts a function. This function has to take care of resolving a subscription to <strong class="source-inline">asyncIterator</strong>, which is no more than an asynchronous <strong class="source-inline">for</strong> loop. It allows the client to listen for execution results and reflect them to the user.</p><p>c. The last option we pass is the GraphQL schema. We do this in the same way as for <strong class="source-inline">ApolloServer</strong>.</p><p>The second parameter our new instance accepts is the <strong class="source-inline">socketOptions</strong> object. This holds settings to describe the way in which the WebSockets work, as outlined here:</p><p>d. The <strong class="source-inline">server</strong> field receives our <strong class="source-inline">server</strong> object, which we pass from the <strong class="source-inline">index.js</strong> file of the server as a result of the <strong class="source-inline">createServer</strong> function. <strong class="source-inline">SubscriptionServer</strong> then relies on the existing server.</p><p>e. The <strong class="source-inline">path</strong> field represents the endpoint under which the subscriptions are accessible. All subscriptions use the <strong class="source-inline">/subscriptions</strong> path.</p><p class="callout-heading">Note</p><p class="callout">The official documentation for the <strong class="source-inline">subscriptions-transport-ws</strong> package offers a more advanced <a id="_idIndexMarker811"/>explanation of <strong class="source-inline">SubscriptionServer</strong>. Take a look to get an overview of all its functionalities: <a href="https://github.com/apollographql/subscriptions-transport-ws#subscriptionserver">https://github.com/apollographql/subscriptions-transport-ws#subscriptionserver</a>.</p><p>The client <a id="_idIndexMarker812"/>would be able to connect to the WebSocket endpoint at this point. There are currently no subscriptions, and the corresponding resolvers are set up in our GraphQL API.</p></li>
				<li>Open the <strong class="source-inline">schema.js</strong> file to define our first subscription. Add a new type called <strong class="source-inline">RootSubscription</strong> next to the <strong class="source-inline">RootQuery</strong> and <strong class="source-inline">RootMutation</strong> types, including the new subscription called <strong class="source-inline">messageAdded</strong>, as follows:<p class="source-code">type RootSubscription {</p><p class="source-code">Â Â messageAdded: Message</p><p class="source-code">}</p><p>Currently, if a user sends a new message to another user, this isn't shown to the recipient right away.</p><p>The first option I showed you was to set an interval to request new messages. Our backend is now able to cover this scenario with subscriptions. The event or channel that the client can subscribe to is called <strong class="source-inline">messageAdded</strong>. We can also add further parameters, such as a chat <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>), to filter the WebSocket messages if necessary. When creating a new chat message, it is publicized through this channel.</p></li>
				<li>We have added <strong class="source-inline">RootSubscription</strong>, but we need to extend the schema root tag too. Otherwise, the new <strong class="source-inline">RootSubscription</strong> type won't be used. Change the schema, as follows:<p class="source-code">schema {</p><p class="source-code">Â Â query: RootQuery</p><p class="source-code">Â Â mutation: RootMutation</p><p class="source-code">Â Â subscription: RootSubscription</p><p class="source-code">}</p></li>
			</ol>
			<p>We have successfully configured the tree GraphQL main types. Next, we have to implement <a id="_idIndexMarker813"/>the corresponding resolver functions. Open the <strong class="source-inline">resolvers.js</strong> file and perform the following steps:</p>
			<ol>
				<li value="1">Import all dependencies that allow us to set up our GraphQL API with a <strong class="source-inline">PubSub</strong> system, as follows:<p class="source-code">import { PubSub, withFilter } from 'graphql-subscriptions';</p><p class="source-code">const pubsub = new PubSub();</p><p>The <strong class="source-inline">PubSub</strong> system offered by the <strong class="source-inline">graphql-subscriptions</strong> package is a simple implementation based on the standard Node.js <strong class="source-inline">EventEmitter</strong> class. When going to production, it's recommended to use an external store, such as Redis, with this package.</p></li>
				<li>We've already added the third <strong class="source-inline">RootSubscription</strong> type to the schema, but not the matching property on the <strong class="source-inline">resolvers</strong> object. The following code snippet includes the <strong class="source-inline">messageAdded</strong> subscription. Add it to the resolvers:<p class="source-code">RootSubscription: {</p><p class="source-code">Â Â messageAdded: {</p><p class="source-code">Â Â Â Â subscribe: () =&gt;</p><p class="source-code">Â Â Â Â Â Â pubsub.asyncIterator(['messageAdded']),</p><p class="source-code">Â Â }</p><p class="source-code">},</p><p>The <strong class="source-inline">messageAdded</strong> property isn't a function but just a simple object. It contains a <strong class="source-inline">subscribe</strong> function that returns <strong class="source-inline">AsyncIterable</strong>. It allows our application to subscribe to the <strong class="source-inline">messageAdded</strong> channel by returning a promise that's only <a id="_idIndexMarker814"/>resolved when a new message is added. The next item that's returned is a promise, which is also only resolved when a message has been added. This method makes <strong class="source-inline">asyncIterator</strong> great for implementing subscriptions.</p><p class="callout-heading">Note</p><p class="callout">You can learn <a id="_idIndexMarker815"/>more about how <strong class="source-inline">asyncIterator</strong> works by reading through the proposal at <a href="https://github.com/tc39/proposal-async-iteration">https://github.com/tc39/proposal-async-iteration</a>.</p></li>
				<li>When subscribing to the <strong class="source-inline">messageAdded</strong> subscription, there needs to be another method that publicizes the newly created message to all clients. The best location is the <strong class="source-inline">addMessage</strong> mutation where the new message is created. Replace the <strong class="source-inline">addMessage</strong> resolver function with the following code:<p class="source-code">addMessage(root, { message }, context) {</p><p class="source-code">Â Â logger.log({</p><p class="source-code">Â Â Â Â Â Â level: 'info',</p><p class="source-code">Â Â Â Â Â Â message: 'Message was created',</p><p class="source-code">Â Â });</p><p class="source-code">Â Â return Message.create({</p><p class="source-code">Â Â Â Â Â Â ...message,</p><p class="source-code">Â Â }).then((newMessage) =&gt; {</p><p class="source-code">Â Â Â Â Â Â return Promise.all([</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â newMessage.setUser(context.user.id),</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â newMessage.setChat(message.chatId),</p><p class="source-code">Â Â Â Â Â Â ]).then(() =&gt; {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â pubsub.publish('messageAdded', {</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â messageAdded: newMessage });</p><p class="source-code">Â Â Â Â Â Â Â Â Â Â return newMessage;</p><p class="source-code">Â Â Â Â Â Â });</p><p class="source-code">Â Â Â });</p><p class="source-code">},</p><p>I have edited the <strong class="source-inline">addMessage</strong> mutation so that the correct user from the context is <a id="_idIndexMarker816"/>chosen. All of the new messages that you send are now saved with the correct user ID. This allows us to filter WebSocket messages for the correct users later in the <em class="italic">Authentication with Apollo subscriptions</em> section.</p><p>We use the <strong class="source-inline">pubsub.publish</strong> function to send a new WebSocket frame to all clients that are connected and that have subscribed to the <strong class="source-inline">messageAdded</strong> channel. The first parameter of the <strong class="source-inline">pubsub.publish</strong> function is the subscription, which in this case is <strong class="source-inline">messageAdded</strong>. The second parameter is the new message that we save to the database. All clients that have subscribed to the <strong class="source-inline">messageAdded</strong> subscription through <strong class="source-inline">asyncIterator</strong> now receive this message.</p></li>
			</ol>
			<p>We've finished preparing the backend. The part that required the most work was to get the Express.js and WebSocket transport working together. The GraphQL implementation only involves the new schema entities, correctly implementing the resolver functions for the subscription, and then publishing the data to the client via the <strong class="source-inline">PubSub</strong> system.</p>
			<p>We have to implement the subscription feature in the frontend to connect to our WebSocket endpoint.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor188"/>Subscriptions on Apollo Client</h2>
			<p>As with the <a id="_idIndexMarker817"/>backend code, we also need to make adjustments to the Apollo Client configuration before using subscriptions. In <a href="B17337_04_Final_ASB_ePub.xhtml#_idTextAnchor085"><em class="italic">Chapter 4</em></a>, <em class="italic">Hooking Apollo into React</em>, we set up Apollo Client with the normal <strong class="source-inline">HttpLink</strong> link. Later, we exchanged it with the <strong class="source-inline">createUploadLink</strong> function, which enables the user to upload files through GraphQL.</p>
			<p>We are going to extend Apollo Client by using <strong class="source-inline">WebSocketLink</strong> as well. This allows us to use subscriptions through GraphQL. Both links work side by side. We use the standard HTTP protocol to query data, such as the chat list or the news feed; all of these real-time updates to keep the UI up to date rely on WebSockets.</p>
			<p>To configure Apollo Client correctly, follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">apollo</strong> folder. Import the following dependencies:<p class="source-code">import { ApolloClient, InMemoryCache, from, split } from '@apollo/client';</p><p class="source-code">import { WebSocketLink } from '@apollo/client/link/ws';</p><p class="source-code">import { onError } from "@apollo/client/link/error";</p><p class="source-code">import { getMainDefinition } from '@apollo/client/utilities';</p><p class="source-code">import { createUploadLink } from 'apollo-upload-client';</p><p class="source-code">import { SubscriptionClient } from 'subscriptions-transport-ws';</p><p>To get the subscriptions working, we need <strong class="source-inline">SubscriptionClient</strong>, which uses <strong class="source-inline">WebSocketLink</strong> to subscribe to our GraphQL API using WebSockets.</p><p>We import the <strong class="source-inline">getMainDefinition</strong> function from the <strong class="source-inline">@apollo/client/utilities</strong> package. It's installed by default when using Apollo Client. The purpose of this function is to give you the operation type, which can be <strong class="source-inline">query</strong>, <strong class="source-inline">mutation</strong>, or <strong class="source-inline">subscription</strong>.</p><p>The <strong class="source-inline">split</strong> function from the <strong class="source-inline">@apollo/client</strong> package allows us to conditionally control the flow of requests through different Apollo links based on the operation type or other information. It accepts one condition and one link (or a pair of links) from which it composes a single valid link that Apollo Client can use.</p></li>
				<li>We are <a id="_idIndexMarker818"/>going to create both links for the <strong class="source-inline">split</strong> function. Detect the protocol and port where we send all GraphQL subscriptions and requests. Add the following code beneath the imports:<p class="source-code">const protocol = (location.protocol != 'https:') ? 'ws://': 'wss://';</p><p class="source-code">const port = location.port ? ':'+location.port: '';</p><p>The <strong class="source-inline">protocol</strong> variable saves the WebSocket protocol by detecting whether the client uses <strong class="source-inline">http</strong> or <strong class="source-inline">https</strong>. The <strong class="source-inline">port</strong> variable is either an empty string if we use port <strong class="source-inline">80</strong> to serve our frontend or any other port, such as <strong class="source-inline">8000</strong>, which we currently use. Previously, we had to statically save <strong class="source-inline">http://localhost:8000</strong> in this file. With the new variables, we can dynamically build the URL where all requests should be sent.</p></li>
				<li>The <strong class="source-inline">split</strong> function expects two links to combine them into one. The first link is the normal <strong class="source-inline">httpLink</strong> link, which we must set up before passing the resulting link to the initialization of Apollo Client. Remove the <strong class="source-inline">createUploadLink</strong> function call from the <strong class="source-inline">ApolloLink.from</strong> function and add it before the <strong class="source-inline">ApolloClient</strong> class, as follows:<p class="source-code">const httpLink = createUploadLink({</p><p class="source-code">Â Â uri: location.protocol + '//' + location.hostname +</p><p class="source-code">Â Â Â Â port + '/graphql',credentials: 'same-origin',</p><p class="source-code">});</p><p>We concatenate the <strong class="source-inline">protocol</strong> variable of the server, which is either <strong class="source-inline">http:</strong> or <strong class="source-inline">https:</strong>, with two slashes. The <strong class="source-inline">hostname</strong> variable is, for example, the domain of your application or, if in development, <strong class="source-inline">localhost</strong>. The result of the concatenation is <a href="http://localhost:8000/graphql">http://localhost:8000/graphql</a>.</p></li>
				<li>Add the WebSocket link that's used for the subscriptions next to <strong class="source-inline">httpLink</strong>. It's the second <a id="_idIndexMarker819"/>one we pass to the <strong class="source-inline">split</strong> function. The code is illustrated in the following snippet:<p class="source-code">const SUBSCRIPTIONS_ENDPOINT = protocol +</p><p class="source-code">Â Â location.hostname + port + '/subscriptions';</p><p class="source-code">const subClient = </p><p class="source-code">Â Â new SubscriptionClient(SUBSCRIPTIONS_ENDPOINT, {</p><p class="source-code">Â Â reconnect: true,</p><p class="source-code">Â Â connectionParams: () =&gt; {</p><p class="source-code">Â Â Â Â var token = localStorage.getItem('jwt');</p><p class="source-code">Â Â Â Â if(token) {</p><p class="source-code">Â Â Â Â Â Â return { authToken: token };</p><p class="source-code">Â Â Â Â }</p><p class="source-code">Â Â Â Â return { };</p><p class="source-code">Â Â }</p><p class="source-code">});</p><p class="source-code">const wsLink = new WebSocketLink(subClient);</p><p>We <a id="_idIndexMarker820"/>define the <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>) that's stored inside the <strong class="source-inline">SUBSCRIPTIONS_ENDPOINT</strong> variable. It's built with the <strong class="source-inline">protocol</strong> and <strong class="source-inline">port</strong> variables, which we detected earlier, and the application's <strong class="source-inline">hostname</strong> variable. The URI ends with the specified endpoint of the backend with the same port as the GraphQL API. The URI is the first parameter of <strong class="source-inline">SubscriptionsClient</strong>. The second parameter allows us to pass options, such as the <strong class="source-inline">reconnect</strong> property. It tells the client to automatically reconnect to the backend's WebSocket endpoint when it has lost the connection. This usually happens if the client has temporarily lost their internet connection or the server has gone down.</p><p>Furthermore, we use the <strong class="source-inline">connectionParams</strong> field to specify the <strong class="bold">JavaScript Object Notation </strong>(<strong class="bold">JSON</strong>)<strong class="bold"> Web Token</strong> (<strong class="bold">JWT</strong>) as an authorization token. We define <a id="_idIndexMarker821"/>this property as a function so that the JWT is read from <strong class="source-inline">localStorage</strong> whenever the user logs in. It's sent when the WebSocket is created.</p><p>We initialize <strong class="source-inline">SubscriptionClient</strong> to the <strong class="source-inline">subClient</strong> variable. We pass it to the <strong class="source-inline">WebSocketLink</strong> constructor under the <strong class="source-inline">wsLink</strong> variable with the given settings.</p></li>
				<li>Combine <a id="_idIndexMarker822"/>both links into one. This allows us to insert the composed result into our <strong class="source-inline">ApolloClient</strong> class at the bottom. To do this, we have imported the <strong class="source-inline">split</strong> function. The syntax to combine the two links should look like this:<p class="source-code">const link = split(</p><p class="source-code">Â Â ({ query }) =&gt; {</p><p class="source-code">Â Â Â Â const { kind, operation } =</p><p class="source-code">Â Â Â Â Â Â getMainDefinition(query);</p><p class="source-code">Â Â Â Â return kind === 'OperationDefinition' &amp;&amp; </p><p class="source-code">Â Â Â Â Â Â operation === 'subscription';</p><p class="source-code">Â Â },</p><p class="source-code">Â Â wsLink,</p><p class="source-code">Â Â httpLink,</p><p class="source-code">);</p><p>The <strong class="source-inline">split</strong> function accepts three parameters. The first parameter must be a function with a Boolean return value. If the return value is <strong class="source-inline">true</strong>, the request is sent over the first link, which is the second required parameter. If the return value is <strong class="source-inline">false</strong>, the operation is sent over the second link, which we pass via the optional third parameter. In our case, the function that's passed as the first parameter determines the operation type. If the operation is a subscription, the function returns <strong class="source-inline">true</strong> and sends the operation over the WebSocket link. All other requests are sent via the HTTP Apollo link. We save the result of the <strong class="source-inline">split</strong> function in the <strong class="source-inline">link</strong> variable.</p></li>
				<li>Insert the preceding <strong class="source-inline">link</strong> variable directly before the <strong class="source-inline">onError</strong> link. The <strong class="source-inline">createUploadLink</strong> function shouldn't be inside the <strong class="source-inline">Apollo.from</strong> function.</li>
			</ol>
			<p>We've now <a id="_idIndexMarker823"/>got the basic Apollo Client set up to support subscriptions via WebSockets.</p>
			<p>In <a href="B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 5</em></a>, <em class="italic">Reusable React Components and React Hooks</em>, I gave you some homework to split the complete chat feature into multiple subcomponents. This way, the chat feature would follow the same pattern as we used for the post feed. We split it into multiple components so that it's a clean code base. We're going to use this and have a look at how to implement subscriptions for the chats.</p>
			<p>If you haven't implemented the chat functionality in multiple subcomponents, you can get the working code from the official GitHub repository. I personally recommend you use the code from the repository if it's unclear what the following examples refer to.</p>
			<p>Using chats as an example makes sense because they are, by nature, real time: they require the application to handle new messages and display them to the recipient. We take care of this in the following steps.</p>
			<p>We begin with the main file of our chats feature, which is the <strong class="source-inline">Chats.js</strong> file in the client folder. I've reworked the <strong class="source-inline">return</strong> statement so that all the markup that initially came directly from this file is now entirely rendered by other child components. You can see all the changes in the following code snippet:</p>
			<p class="source-code">return (</p>
			<p class="source-code">Â Â &lt;div className="wrapper"&gt;</p>
			<p class="source-code">Â Â Â Â &lt;div className="chats"&gt;</p>
			<p class="source-code">Â Â Â Â Â Â {chats.map((chat, i) =&gt;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â &lt;ChatItem chat={chat} user={user}</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â openChat={openChat} /&gt;</p>
			<p class="source-code">Â Â Â Â Â Â )}</p>
			<p class="source-code">Â Â Â Â &lt;/div&gt;</p>
			<p class="source-code">Â Â Â Â &lt;div className="openChats"&gt;</p>
			<p class="source-code">Â Â Â Â Â Â {openChats.map((chatId, i) =&gt; &lt;Chat chatId={chatId}</p>
			<p class="source-code">Â Â Â Â Â Â Â Â key={"chatWindow" + chatId} closeChat={closeChat} </p>
			<p class="source-code">Â Â Â Â Â Â Â /&gt; )}</p>
			<p class="source-code">Â Â Â Â &lt;/div&gt;</p>
			<p class="source-code">Â Â &lt;/div&gt;</p>
			<p class="source-code">)</p>
			<p>All the <a id="_idIndexMarker824"/>changes are listed here:</p>
			<ul>
				<li>We have introduced a new <strong class="source-inline">ChatItem</strong> component that handles the logic of the <strong class="source-inline">for</strong> loop. Extracting the logic into a separate file makes it more readable.</li>
				<li>The <strong class="source-inline">ChatItem</strong> component expects <strong class="source-inline">user</strong>, <strong class="source-inline">chat</strong>, and <strong class="source-inline">openChat</strong> properties. Furthermore, we have edited the functions that this component uses to also leverage the <strong class="source-inline">user</strong> object.</li>
				<li>We extract the <strong class="source-inline">user</strong> property from the properties of the <strong class="source-inline">Chats</strong> component. Consequently, we have to wrap the <strong class="source-inline">Chats</strong> component with the <strong class="source-inline">UserConsumer</strong> component to let it pass the user. You can apply this change from within the <strong class="source-inline">Chats.js</strong> file by wrapping the exported component into it. </li>
				<li>The <strong class="source-inline">openChat</strong> and <strong class="source-inline">closeChat</strong> functions are executed either by <strong class="source-inline">ChatItem</strong> or the <strong class="source-inline">Chats</strong> component. All other functions from the <strong class="source-inline">Chats</strong> component have been moved to one or both components: <strong class="source-inline">ChatItem</strong> and <strong class="source-inline">Chat</strong>.</li>
			</ul>
			<p>The changes I have made here had nothing to do with the subscriptions directly, but it's much easier to understand what I'm trying to explain when the code is readable. If you need help implementing these changes by yourself, I recommend you check out the official GitHub repository. All the following examples are based on these changes, but they should be understandable without having the full source code.</p>
			<p>More important, however, is <strong class="source-inline">useGetChatsQuery</strong>, which has a special feature. We want to subscribe to the <strong class="source-inline">messageAdded</strong> subscription to listen for new messages. That's possible by using a new function of the Apollo <strong class="source-inline">useQuery</strong> Hook.</p>
			<p>We need to <a id="_idIndexMarker825"/>extract a <strong class="source-inline">subscribeToMore</strong> function from the <strong class="source-inline">useGetChatsQuery</strong> Hook.</p>
			<p>The <strong class="source-inline">subscribeToMore</strong> function is provided by default with every result of an Apollo <strong class="source-inline">useQuery</strong> Hook. It lets you run an <strong class="source-inline">update</strong> function whenever a message is created. It works in the same way as the <strong class="source-inline">fetchMore</strong> function. We can use this function in the <strong class="source-inline">Chats</strong> component to listen for the new messages.</p>
			<p>Let's have a look at how we can use this function to implement subscriptions on the frontend, as follows:</p>
			<ol>
				<li value="1">Create a new <strong class="source-inline">subscriptions</strong> folder inside the <strong class="source-inline">apollo</strong> folder.</li>
				<li>Create a new <strong class="source-inline">messageAdded.js</strong> file inside this <strong class="source-inline">subscriptions</strong> folder. We need to parse the GraphQL subscription string. The new <strong class="source-inline">messageAdded</strong> subscription has to look like this:<p class="source-code">export const MESSAGES_SUBSCRIPTION = gql'</p><p class="source-code">Â Â subscription onMessageAdded {</p><p class="source-code">Â Â Â Â messageAdded {</p><p class="source-code">Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â text</p><p class="source-code">Â Â Â Â Â Â chat {</p><p class="source-code">Â Â Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â Â Â user {</p><p class="source-code">Â Â Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â Â Â __typename </p><p class="source-code">Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â Â Â __typename </p><p class="source-code">Â Â Â Â }</p><p class="source-code">Â Â }</p><p class="source-code">';</p><p>The subscription looks exactly like all the other queries or mutations we are using. The only difference is that we request the <strong class="source-inline">__typename</strong> field, as it isn't included in the response of our GraphQL API when using subscriptions. From my point of view, this seems like a bug in the current version of <strong class="source-inline">SubscriptionServer</strong>. You should check whether you still need to do this at the time of reading this book.</p><p>We specify <a id="_idIndexMarker826"/>the operation type of the request, which is <strong class="source-inline">subscription</strong>, as you can see in the preceding code snippet. Otherwise, it attempts to execute the default query operation, which leads to an error because there's no <strong class="source-inline">messageAdded</strong> query, only a subscription. The subscription events the client receives when a new message is added hold all fields, as shown in the preceding code snippet.</p></li>
				<li>In the <strong class="source-inline">addMessage</strong> mutation file, we need to rewrite one part of the code. We extract the fragment that we pass to <strong class="source-inline">writeFragment</strong> to be an exported variable itself so that we can reuse that. The code should look like this:<p class="source-code">export const NEW_MESSAGE = gql'</p><p class="source-code">Â Â fragment NewMessage on Chat {</p><p class="source-code">Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â type</p><p class="source-code">Â Â }</p><p class="source-code">';</p></li>
				<li>Import the new GraphQL query in the <strong class="source-inline">Chats.js</strong> file together with some other dependencies, as follows:<p class="source-code">import { MESSAGES_SUBSCRIPTION } from './apollo/queries/messageAdded';</p><p class="source-code">import { NEW_MESSAGE } from './apollo/mutations/addMessage';</p><p class="source-code">import { GET_CHAT } from './apollo/queries/getChat';</p></li>
				<li>The following <a id="_idIndexMarker827"/>properties should be extracted from the <strong class="source-inline">useGetChatsQuery</strong> Hook:<p class="source-code">const { loading, error, data, subscribeToMore } = useGetChatsQuery();</p></li>
				<li>Import the <strong class="source-inline">withApollo</strong> HOC and <strong class="source-inline">UserConsumer</strong>, as follows:<p class="source-code">import { withApollo } from '@apollo/client/react/hoc';</p><p class="source-code">import { UserConsumer } from './components/context/user';</p></li>
				<li>We are going to use direct Apollo Client interaction. This is why we need to export the <strong class="source-inline">Chats</strong> component to be wrapped into the <strong class="source-inline">withApollo</strong> HOC to pass the client into a property. To export your component correctly, use the <strong class="source-inline">withApollo</strong> HOC. The code is illustrated here:<p class="source-code">const ChatContainer = (props) =&gt; &lt;UserConsumer&gt;&lt;Chats {...props} /&gt;&lt;/UserConsumer&gt;</p><p class="source-code">export default withApollo(ChatContainer)</p><p>We wrap the <strong class="source-inline">Chats</strong> component into the <strong class="source-inline">UserConsumer</strong> component to get access to the client. Furthermore, we wrap it into the <strong class="source-inline">withApollo</strong> HOC to get access to the client.</p></li>
				<li>Here's the crucial part. When the component is mounted, we need to subscribe to the <strong class="source-inline">messageAdded</strong> channel. Only then is the <strong class="source-inline">messageAdded</strong> subscription used to receive new data or, to be exact, new chat messages. To start subscribing to the GraphQL subscription, we have to add a new <strong class="source-inline">useEffect</strong> Hook, as follows:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">Â Â subscribeToNewMessages()</p><p class="source-code">}, []);</p></li>
			</ol>
			<p>In the preceding code snippet, we execute a new <strong class="source-inline">subscribeToNewMessages</strong> method inside the <strong class="source-inline">useEffect</strong> Hook of our React component.</p>
			<p>The <strong class="source-inline">useEffect</strong> method only executes on the client-side code as the SSR implementation doesn't throw this event.</p>
			<p>We have to <a id="_idIndexMarker828"/>add the corresponding <strong class="source-inline">subscribeToNewMessages</strong> method as well. We're going to explain every bit of this function in a moment. Insert the following code into the <strong class="source-inline">Chats</strong> component:</p>
			<p class="source-code">const subscribeToNewMessages = () =&gt; {</p>
			<p class="source-code">Â Â subscribeToMore({</p>
			<p class="source-code">Â Â Â Â document: MESSAGES_SUBSCRIPTION,</p>
			<p class="source-code">Â Â Â Â updateQuery: (prev, { subscriptionData }) =&gt; {</p>
			<p class="source-code">Â Â Â Â Â Â if (!subscriptionData.data || (prev.chats &amp;&amp;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â !prev.chats.length)) return prev;</p>
			<p class="source-code">Â Â Â Â Â Â var index = -1;</p>
			<p class="source-code">Â Â Â Â Â Â for(var i = 0; i &lt; prev.chats.length; i++) {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â if(prev.chats[i].id == </p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â subscriptionData.data.messageAdded.chat.id) {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â index = i;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â break;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â Â Â if (index === -1) return prev;</p>
			<p class="source-code">Â Â Â Â Â Â const newValue = Object.assign({},prev.chats[i], {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â lastMessage: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â text: subscriptionData.data.messageAdded.text,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â __typename: </p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â subscriptionData.data.messageAdded.__typename</p>
			<p class="source-code">Â Â Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â Â Â });</p>
			<p class="source-code">Â Â Â Â Â Â var newList = {chats:[...prev.chats]};</p>
			<p class="source-code">Â Â Â Â Â Â newList.chats[i] = newValue;</p>
			<p class="source-code">Â Â Â Â Â Â return newList;</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â });</p>
			<p class="source-code">}</p>
			<p>The preceding <strong class="source-inline">subscribeToNewMessages</strong> method looks very complex, but once we understand <a id="_idIndexMarker829"/>its purpose, it's straightforward. We primarily rely on the <strong class="source-inline">subscribeToMore</strong> function here, which we get from <strong class="source-inline">useGetChatsQuery</strong>. The purpose of this function is to start subscribing to our <strong class="source-inline">messageAdded</strong> channel and to accept the new data from the subscription and merge it with the current state and cache so that it's reflected directly to the user.</p>
			<p>The <strong class="source-inline">document</strong> parameter accepts the parsed GraphQL subscription.</p>
			<p>The second parameter is called <strong class="source-inline">updateQuery</strong>. It allows us to insert a function that implements the logic to update the Apollo Client cache with the new data. This function needs to accept a new parameter, which is the previous data from where the <strong class="source-inline">subscribeToMore</strong> function has been passed. In our case, this object contains an array of chats that already exist in the client's cache.</p>
			<p>The second parameter holds the new message inside the <strong class="source-inline">subscriptionData</strong> index. The <strong class="source-inline">subscriptionData</strong> object has a <strong class="source-inline">data</strong> property that has a further <strong class="source-inline">messageAdded</strong> field under which the real message that's been created is saved.</p>
			<p>We'll quickly go through the logic of the <strong class="source-inline">updateQuery</strong> function so that you can understand how we merge data from a subscription to the application state.</p>
			<p>If <strong class="source-inline">subscriptionData.data</strong> is empty or there are no previous chats in the <strong class="source-inline">prev</strong> object, there's nothing to update. In this case, we return the previous data because a message was sent in <a id="_idIndexMarker830"/>a chat that the client doesn't have in their cache. Otherwise, we loop through all the previous chats of the <strong class="source-inline">prev</strong> object and find the index of the chat for which the subscription has returned a new message by comparing the chat IDs. The found chat's index inside the <strong class="source-inline">prev.chats</strong> array is saved in the <strong class="source-inline">index</strong> variable. If the chat cannot be found, we can check this with the <strong class="source-inline">index variable</strong> and return the previous data. If we find the chat, we need to update it with a new message. To do this, we compose the chat from the previous data and set <strong class="source-inline">lastMessage</strong> to the new message's text. We do this by using the <strong class="source-inline">Object.assign</strong> function, where the chat and the new message are merged. We save the result in the <strong class="source-inline">newValue</strong> variable. It's important that we also set the returned <strong class="source-inline">__typename</strong> property because otherwise, Apollo Client throws an error.</p>
			<p>Now that we have an object that contains the updated chat in the <strong class="source-inline">newValue</strong> variable, we write it to the client's cache. To write the updated chat to the cache, we return an array of all chats at the end of the <strong class="source-inline">updateQuery</strong> function. Because the <strong class="source-inline">prev</strong> variable is read-only, we can't save the updated chat inside it. We have to create a new array to write it to the cache. We set the <strong class="source-inline">newValue</strong> chat object to the <strong class="source-inline">newList</strong> array at the index where we found the original chat. At the end, we return the <strong class="source-inline">newList</strong> variable. We update the cache that's given to us inside the <strong class="source-inline">prev</strong> object with the new array. Importantly, the new cache has to have the same fields as before. The schema of the return value of the <strong class="source-inline">updateQuery</strong> function must match the initial <strong class="source-inline">chats</strong> query schema.</p>
			<p>You can now test the subscription directly in your browser by starting the application with <strong class="source-inline">npm run server</strong>. If you send a new chat message, it's shown directly in the chat panel on the right-hand side.</p>
			<p>We have, however, got one major problem. If you test this with a second user, you'll notice that the <strong class="source-inline">lastMessage</strong> field is updated for both users. That is correct, but the new message isn't visible inside the chat window for the recipient. We've updated the client store for the <strong class="source-inline">chats</strong> GraphQL request, but we haven't added the message to the single <strong class="source-inline">chat</strong> query that's executed when we open a chat window.</p>
			<p>We're going to solve this problem by making use of the <strong class="source-inline">withApollo</strong> HOC. The <strong class="source-inline">Chats</strong> component has no access to the <strong class="source-inline">chat</strong> query cache directly. The <strong class="source-inline">withApollo</strong> HOC gives the exported component a <strong class="source-inline">client</strong> property, which allows us to interact directly with Apollo Client. We can use it to read and write to the whole Apollo Client cache, and it <a id="_idIndexMarker831"/>isn't limited to only one GraphQL request. Before returning the updated <strong class="source-inline">chats</strong> array from the <strong class="source-inline">updateQuery</strong> function, we have to read the state of  <strong class="source-inline">chat</strong> and insert the new data if possible. Insert the following code right before the final <strong class="source-inline">return</strong> statement inside the <strong class="source-inline">updateQuery</strong> function:</p>
			<p class="source-code">if(user.id !== subscriptionData.data.messageAdded.user.id) {</p>
			<p class="source-code">Â Â try {</p>
			<p class="source-code">Â Â Â Â const data = client.readQuery({ query: GET_CHAT,</p>
			<p class="source-code">Â Â Â Â Â Â variables: { chatId: </p>
			<p class="source-code">Â Â Â Â Â Â Â Â subscriptionData.data.messageAdded.chat.id } });</p>
			<p class="source-code">Â Â Â Â client.cache.modify({</p>
			<p class="source-code">Â Â Â Â Â Â id: client.cache.identify(data.chat),</p>
			<p class="source-code">Â Â Â Â Â Â fields: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â messages(existingMessages = []) {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â const newMessageRef = </p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â client.cache.writeFragment({</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â data: subscriptionData.data.messageAdded,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â fragment: NEW_MESSAGE</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â });</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â return [...existingMessages, newMessageRef];</p>
			<p class="source-code">Â Â Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â });</p>
			<p class="source-code">Â Â } catch(e) {}</p>
			<p class="source-code">}</p>
			<p>In the preceding code snippet, we use the <strong class="source-inline">client.readQuery</strong> method to read the cache. This accepts the <strong class="source-inline">GET_CHAT</strong> query as one parameter and the chat ID of the newly sent message to get a single chat in return. The <strong class="source-inline">GET_CHAT</strong> query is the same request we sent in the <strong class="source-inline">Chat.js</strong> file when opening a chat window. We wrap the <strong class="source-inline">readQuery</strong> function in a <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> block because it throws an unhandled error if nothing is found for the specified <strong class="source-inline">query</strong> and <strong class="source-inline">variables</strong>. This can happen if the user hasn't opened a chat window yet, and so no data has been requested with the <strong class="source-inline">GET_CHAT</strong> query for this specific chat. Furthermore, the whole block is wrapped into an <strong class="source-inline">if</strong> condition to check if the new message is from another user and not from ourselves because if we send a message on our own, we do not need to add it into the cache as we already do that on submission of a new message from our side.</p>
			<p>If the message <a id="_idIndexMarker832"/>is from another user, we use the <strong class="source-inline">client.cache.modify</strong> function, as we already know to add the new message to the array of messages in the cache for this specific chat.</p>
			<p>You can test these new changes by viewing the chat window and sending a message from another user account. The new message should appear almost directly for you without the need to refresh the browser.</p>
			<p>In this section, we learned how to subscribe to events sent from a backend through Apollo subscriptions. Currently, we use this feature to update the UI on the fly with the new data. Later, in the <em class="italic">Notifications with Apollo subscriptions</em> section, we'll see another scenario where subscriptions can be useful. Nevertheless, there's one thing left to do: we haven't authorized the user for the <strong class="source-inline">messageAdded</strong> subscription through a JWT, such as our GraphQL API, and still, the user received the new message without verifying its identity. We're going to change this in the next section.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor189"/>Authentication with Apollo subscriptions</h1>
			<p>In <a href="B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication with Apollo and React</em>, we implemented authentication <a id="_idIndexMarker833"/>through the local storage of your browser. The backend generates a signed JWT that the client sends with every request inside the HTTP headers. In <a href="B17337_09_Final_ASB_ePub.xhtml#_idTextAnchor176"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing Server-Side Rendering</em>, we extended this logic to support cookies to allow SSR. Now that we've introduced WebSockets, we need to take care of them separately, as we did with the SRR and our GraphQL API.</p>
			<p>How is it possible for the user to receive new messages when they aren't authenticated on the backend for the WebSocket transport protocol?</p>
			<p>The best way to figure this out is to have a look at your browser's developer tools. Let's assume that <a id="_idIndexMarker834"/>we have one browser window where we log in with user A. This user chats with another user, B. Both send messages to each other and receive the new updates directly in their chat window. Another user, C, shouldn't be able to receive any of the WebSocket updates. We should play through this scenario in reality.</p>
			<p>If you use Chrome as your default browser, go to the <strong class="bold">Network</strong> tab. There, you can filter all network requests by type. Since the data is transported via a WebSocket, you can filter by the <strong class="bold">WS</strong> option. You should see one connection, which is the <strong class="source-inline">subscriptions</strong> endpoint of our backend.</p>
			<p>Try this scenario with the Developer Tools open. You should see the same WebSocket frames for all browsers. It should look like this:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_10.01_B17337.jpg" alt="Figure 10.1 â€“ WebSocket messages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 â€“ WebSocket messages</p>
			<p>In the left panel, you can see all WebSocket connections. In our case, this is only the <strong class="source-inline">subscriptions</strong> connection. If you click on the connection, you will find all the frames that are <a id="_idIndexMarker835"/>sent over this connection. The first frame in the preceding list is the initial connection frame. The second frame is the subscription request to the <strong class="source-inline">messageAdded</strong> channel, which is initiated by the client. Both frames are marked green because the client sends them.</p>
			<p>The last two are marked in red as the server sent them. The first of the red-marked frames is the server's acknowledgment of the established connection. The last frame was sent by our backend to publish a new message to the client. While the frame might look alright at first glance, it represents a vital problem. The last frame was sent to all clients, not just those who are members of the specific chat in which the message was sent. Average users are not likely to notice it since our <strong class="source-inline">cache.modify</strong> function only updates the UI if the chat was found in the client store. Still, an experienced user or developer is able to spy on all users of our social network as it's readable in the <strong class="bold">Network</strong> tab.</p>
			<p>We need to take a look at the backend code that we have written and compare the initialization of <strong class="source-inline">ApolloServer</strong> and <strong class="source-inline">SubscriptionServer</strong>. We have a <strong class="source-inline">context</strong> function for <strong class="source-inline">ApolloServer</strong> that extracts the user from the JWT. It can then be used inside the resolver functions to filter the results by the currently logged-in user. For <strong class="source-inline">SubscriptionServer</strong>, there's no such <strong class="source-inline">context</strong> function at the moment. We have to know the currently logged-in user to filter the subscription messages for the correct users. We can use standard WebSockets events, such as <strong class="source-inline">onConnect</strong> or <strong class="source-inline">onOperation</strong>, to implement the authorization of the user.</p>
			<p>The <strong class="source-inline">onOperation</strong> function is executed for every WebSocket frame that is sent. The best approach is to <a id="_idIndexMarker836"/>implement the authorization in the <strong class="source-inline">onConnect</strong> event in the same way as the <strong class="source-inline">context</strong> function that's taken from <strong class="source-inline">ApolloServer</strong> so that the WebSocket connection is authenticated only once when it's established and not for every frame that's sent.</p>
			<p>In <strong class="source-inline">index.js</strong>, from the <strong class="source-inline">subscriptions</strong> folder of the server, add the following code to the first parameter of the <strong class="source-inline">SubscriptionServer</strong> initialization. It accepts an <strong class="source-inline">onConnect</strong> parameter as a function, which is executed whenever a client tries to connect to the <strong class="source-inline">subscriptions</strong> endpoint. Add the code just before the <strong class="source-inline">schema</strong> parameter:</p>
			<p class="source-code">onConnect: async (params,socket) =&gt; {</p>
			<p class="source-code">Â Â const authorization = params.authToken;</p>
			<p class="source-code">Â Â if(typeof authorization !== typeof undefined) {</p>
			<p class="source-code">Â Â Â Â var search = "Bearer";</p>
			<p class="source-code">Â Â Â Â var regEx = new RegExp(search, "ig");</p>
			<p class="source-code">Â Â Â Â const token = authorization.replace(regEx, '').trim();</p>
			<p class="source-code">Â Â Â Â return jwt.verify(token, JWT_SECRET, function(err,</p>
			<p class="source-code">Â Â Â Â Â Â result) {</p>
			<p class="source-code">Â Â Â Â Â Â if(err) {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â throw new Error('Missing auth token!');</p>
			<p class="source-code">Â Â Â Â Â Â } else {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â return utils.db.models.User.findByPk(</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â result.id).then((user) =&gt; </p>
			<p class="source-code">Â Â Â Â Â Â Â Â {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â return Object.assign({}, socket.upgradeReq, {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â Â Â user });</p>
			<p class="source-code">Â Â Â Â Â Â Â Â });</p>
			<p class="source-code">Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â });</p>
			<p class="source-code">Â Â } else {</p>
			<p class="source-code">Â Â Â Â throw new Error('Missing auth token!');</p>
			<p class="source-code">Â Â }</p>
			<p class="source-code">},</p>
			<p>This code is very similar to the <strong class="source-inline">context</strong> function. We rely on the normal JWT authentication but via the connection parameters of the WebSocket. We implement the WebSocket <a id="_idIndexMarker837"/>authentication inside the <strong class="source-inline">onConnect</strong> event. In the original <strong class="source-inline">context</strong> function of <strong class="source-inline">ApolloServer</strong>, we extract the JWT from the HTTP headers of the request, but here, we are using the <strong class="source-inline">params</strong> variable, which is passed as the first parameter.</p>
			<p>Before the client finally connects to the WebSocket endpoint, an <strong class="source-inline">onConnect</strong> event is triggered where you can implement special logic for the initial connection. With the first request, we send the JWT because we have configured Apollo Client to read the JWT to the <strong class="source-inline">authToken</strong> parameter of the <strong class="source-inline">connectionParams</strong> object when <strong class="source-inline">SubscriptionClient</strong> is initialized. That's why we can access the JWT not from a <strong class="source-inline">request</strong> object directly but from <strong class="source-inline">params.authToken</strong> in the preceding code snippet. The <strong class="source-inline">socket</strong> parameter is also given to us inside the <strong class="source-inline">onConnect</strong> function; there, you can access the initial upgrade request inside the <strong class="source-inline">socket</strong> object. After extracting the JWT from the connection parameters, we can verify it and authenticate the user with that.</p>
			<p>At the end of this <strong class="source-inline">onConnect</strong> function, we return the <strong class="source-inline">upgradeReq</strong> variable and the user, just as we do with a normal <strong class="source-inline">context</strong> function for Apollo Server. Instead of returning the <strong class="source-inline">req</strong> object to <strong class="source-inline">context</strong> if the user isn't logged in, we are now throwing an error. This is because we only implement subscriptions for entities that require you to be logged in, such as chats or posts. It lets the client try to reconnect until it's authenticated. You can change this behavior to match your needs and let the user connect to the WebSocket. Don't forget, however, that every open connection costs you performance <a id="_idIndexMarker838"/>and a user who isn't logged in doesn't need an open connection, at least for the use case of <strong class="bold">Graphbook</strong>.</p>
			<p>We have <a id="_idIndexMarker839"/>now identified the user that has connected to our backend with the preceding code, but we're still sending every frame to all users. This is a problem with the resolver functions because they don't use the context yet. Replace the <strong class="source-inline">messageAdded</strong> subscription with the following code in the <strong class="source-inline">resolvers.js</strong> file:</p>
			<p class="source-code">messageAdded: {</p>
			<p class="source-code">Â Â subscribe: withFilter(() =&gt;</p>
			<p class="source-code">Â Â Â Â pubsub.asyncIterator('messageAdded'), </p>
			<p class="source-code">Â Â Â Â (payload, variables, context) =&gt; {</p>
			<p class="source-code">Â Â Â Â if (payload.messageAdded.UserId !== context.user.id) {</p>
			<p class="source-code">Â Â Â Â Â Â return Chat.findOne({</p>
			<p class="source-code">Â Â Â Â Â Â Â Â where: {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â id: payload.messageAdded.ChatId</p>
			<p class="source-code">Â Â Â Â Â Â Â Â },</p>
			<p class="source-code">Â Â Â Â Â Â Â Â include: [{</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â model: User,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â required: true,</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â through: { where: { userId: context.user.id } },</p>
			<p class="source-code">Â Â Â Â Â Â Â Â }],</p>
			<p class="source-code">Â Â Â Â Â Â }).then((chat) =&gt; {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â if(chat !== null) {</p>
			<p class="source-code">Â Â Â Â Â Â Â Â Â Â return true;</p>
			<p class="source-code">Â Â Â Â Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â Â Â Â Â return false;</p>
			<p class="source-code">Â Â Â Â Â Â })</p>
			<p class="source-code">Â Â Â Â }</p>
			<p class="source-code">Â Â Â Â return false;</p>
			<p class="source-code">Â Â }),</p>
			<p class="source-code">}</p>
			<p>Earlier in this chapter, we imported the <strong class="source-inline">withFilter</strong> function from the <strong class="source-inline">graphql-subscriptions</strong> package. This allows us to wrap <strong class="source-inline">asyncIterator</strong> with a filter. The purpose of this filter is to conditionally send publications through connections to users who should see the new information. If one user shouldn't receive a publication, the return value of <a id="_idIndexMarker840"/>the condition for the <strong class="source-inline">withFilter</strong> function should be <strong class="source-inline">false</strong>. For all users who should receive a new message, the return value should be <strong class="source-inline">true</strong>.</p>
			<p>The <strong class="source-inline">withFilter</strong> function accepts <strong class="source-inline">asyncIterator</strong> as its first parameter. The second parameter is the function that decides whether a user receives a subscription update. We extract the following properties from the function call:</p>
			<ul>
				<li>The <strong class="source-inline">payload</strong> parameter, which is the new message that has been sent in the <strong class="source-inline">addMessage</strong> mutation.</li>
				<li>The <strong class="source-inline">variables</strong> field, which holds all GraphQL parameters that could be sent with the <strong class="source-inline">messageAdded</strong> subscription, not with the mutation. For our scenario, we are not sending any variables with the subscription.</li>
				<li>The <strong class="source-inline">context</strong> variable, which holds all the information that we implemented in the <strong class="source-inline">onConnect</strong> Hook. It includes the regular <strong class="source-inline">context</strong> object with the user as a separate property.</li>
			</ul>
			<p>The <strong class="source-inline">filter</strong> function is executed for every user that has subscribed to the <strong class="source-inline">messageAdded</strong> channel. First, we check whether the user for which the function is executed is the author of the new message by comparing the user IDs. In this case, they don't need to get a subscription notification because they already have the data.</p>
			<p>If this isn't the case, we query the database for the chat where the new message was added. To find out whether a user needs to receive the new message, we select only chats where the logged-in user's ID and the chat ID are included. If a chat is found in the database, the user should see the new message. Otherwise, they aren't allowed to get the new message, and we return <strong class="source-inline">false</strong>.</p>
			<p>Remember that the <strong class="source-inline">withFilter</strong> function is run for each connection. If there are thousands of users, we would have to run the database query very frequently. It's better to keep such filter functions as small and efficient as possible. For example, we could query <a id="_idIndexMarker841"/>the chat once to get the attached users and loop through them manually for all the connections. This solution would save us expensive database operations.</p>
			<p>This is all you need to know about authentication with subscriptions. We now have a working setup that includes SSR with cookies and real-time subscriptions with JWT authentication. The SSR doesn't implement subscriptions because it doesn't make sense to offer real-time updates for the initial rendering of our application. Next, you will see another scenario where Apollo subscriptions can be useful.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor190"/>Notifications with Apollo subscriptions</h1>
			<p>In this section, I'll quickly guide you through the second use case for subscriptions. Showing <a id="_idIndexMarker842"/>notifications to a user is perfectly traditional and commonplace, as you know from Facebook. Instead of relying on the <strong class="source-inline">subscribeToMore</strong> function, we use the <strong class="source-inline">Subscription</strong> component that's provided by Apollo. This component works like the <strong class="source-inline">Query</strong> and <strong class="source-inline">Mutation</strong> components, but for subscriptions.</p>
			<p>Follow these steps to get your first <strong class="source-inline">Subscription</strong> component running:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">subscriptions</strong> folder inside the client's <strong class="source-inline">apollo</strong> folder. You can save all subscriptions that you implement using Apollo's <strong class="source-inline">useSubscription</strong> Hook inside this folder.</li>
				<li>Insert a <strong class="source-inline">messageAdded.js</strong> file into the folder and paste in the following code:<p class="source-code">import { useSubscription, gql } from '@apollo/client';</p><p class="source-code">export const MESSAGES_SUBSCRIPTION = gql'</p><p class="source-code">Â Â subscription onMessageAdded {</p><p class="source-code">Â Â Â Â messageAdded {</p><p class="source-code">Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â text</p><p class="source-code">Â Â Â Â Â Â chat {</p><p class="source-code">Â Â Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â Â Â user {</p><p class="source-code">Â Â Â Â Â Â Â Â id</p><p class="source-code">Â Â Â Â Â Â Â Â __typename</p><p class="source-code">Â Â Â Â Â Â }</p><p class="source-code">Â Â Â Â Â Â __typename</p><p class="source-code">Â Â Â Â }</p><p class="source-code">Â Â }</p><p class="source-code">';</p><p class="source-code">export const useMessageAddedSubscription = (options) =&gt; useSubscription(MESSAGES_SUBSCRIPTION, options);</p><p>The general <a id="_idIndexMarker843"/>workflow for the <strong class="source-inline">useSubscription</strong> component is the same as for the <strong class="source-inline">useMutation</strong> and <strong class="source-inline">useQuery</strong> Hooks. First, we parse the subscription with the <strong class="source-inline">gql</strong> function. Then, we just return the <strong class="source-inline">useSubscription</strong> Hook with the parsed GraphQL query.</p></li>
				<li>Because we want to show notifications to the user when a new message is received, we install a package that takes care of showing pop-up notifications. Install it using <strong class="source-inline">npm</strong>, as follows:<p class="source-code"><strong class="bold">npm install --save react-toastify</strong></p></li>
				<li>To set up <strong class="source-inline">react-toastify</strong>, add a <strong class="source-inline">ToastContainer</strong> component to a global point of the application where all notifications are rendered. This container isn't only used for <a id="_idIndexMarker844"/>notifications of new messages but for all notifications, so choose wisely. I decided to attach <strong class="source-inline">ToastContainer</strong> to the <strong class="source-inline">Chats.js</strong> file. Import the dependency at the top of it, as follows:<p class="source-code">import { ToastContainer, toast } from 'react-toastify';</p></li>
				<li>Inside the <strong class="source-inline">return</strong> statement, the first thing to render should be <strong class="source-inline">ToastContainer</strong>. Add it, like this:<p class="source-code">&lt;div className="wrapper"&gt;</p><p class="source-code">Â Â &lt;ToastContainer/&gt;</p></li>
				<li>In the <strong class="source-inline">Chats.js</strong> file, add one <strong class="source-inline">import</strong> statement to load the subscription Hook, as follows:<p class="source-code">import { useMessageAddedSubscription } from './apollo/subscriptions/messageAdded';</p></li>
				<li>Then, just call this subscription Hook inside the <strong class="source-inline">Chats</strong> component after the other Hook statements, like this:<p class="source-code">useMessageAddedSubscription({</p><p class="source-code">Â Â onSubscriptionData: data =&gt; {</p><p class="source-code">Â Â Â Â if(data &amp;&amp; data.subscriptionData &amp;&amp;</p><p class="source-code">Â Â Â Â Â Â data.subscriptionData.data &amp;&amp;</p><p class="source-code">Â Â Â Â Â Â data.subscriptionData.data.messageAdded)</p><p class="source-code">Â Â Â Â Â Â toast(data.subscriptionData.data.messageAdded.text, </p><p class="source-code">Â Â Â Â Â Â Â Â { position: toast.POSITION.TOP_LEFT });</p><p class="source-code">Â Â }</p><p class="source-code">});</p></li>
				<li>Add a <a id="_idIndexMarker845"/>small <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) rule and import the CSS rules of the <strong class="source-inline">react-toastify</strong> package. Import the <strong class="source-inline">CSS</strong> file in the <strong class="source-inline">App.js</strong> file, like this:<p class="source-code">import 'react-toastify/dist/ReactToastify.css';</p><p>Then, add these few lines to the custom <strong class="source-inline">style.css</strong> file:</p><p class="source-code">.Toastify__toast-container--top-left {</p><p class="source-code">Â Â top: 4em !important;</p><p class="source-code">}</p></li>
			</ol>
			<p>You can <a id="_idIndexMarker846"/>see an example of a notification in the following screenshot:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_10.02_B17337.jpg" alt="Figure 10.2 â€“ Notification&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 â€“ Notification</p>
			<p>The entire subscriptions topic is complex, but we managed to implement it for two use cases and thus provided the user with significant improvements to our application.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor191"/>Summary</h1>
			<p>This chapter aimed to offer the user a real-time UI that allows them to chat comfortably with other users. We also looked at how to make this UI extendable. You learned how to set up subscriptions with any Apollo or GraphQL backend for all entities. We also implemented WebSocket-specific authentication to filter publications so that they are only received by the correct user.</p>
			<p>In the next chapter, you'll learn how to verify and test the correct functionality of your application by implementing automated testing for your code.</p>
		</div>
	</body></html>