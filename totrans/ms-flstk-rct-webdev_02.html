<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Full-Stack Login and Registration for Our Publishing App</h1>
            

            <article>
                
<p class="calibre2"><strong class="calibre1">JSON Web Token</strong> (<strong class="calibre1">JWT</strong>) is a security tokens format, which is relatively new, but works very well. It's an open standard (RFC 7519) that improves oAuth2 and OpenID connection when dealing with the problem of passing claims between parties in a web application environment.</p>
<p class="calibre2">In practice, the flow is as follows:</p>
<ul class="calibre14">
<li class="calibre15">The server assigns an encoded JSON object</li>
<li class="calibre15">After client has been alerted, it sends that encoded token with every request to the server</li>
<li class="calibre15">Based on that token, the server knows who is sending a request</li>
</ul>
<p class="calibre2">It's worth <span>visiting</span> the <a href="http://jwt.io/" class="calibre6"><span>http://jwt.io/</span></a> website and playing with it before you start working with it:</p>
<div class="packt_figure"><img class="image-border15" src="../images/00020.jpeg"/></div>
<p class="calibre2">After successful login, the JWT's solution provides an object to our frontend application that tells us about a current user's authorization:</p>
<pre class="calibre22">
{'iss': 'PublishginAppIssuer','name': 'John Doe','admin':true}
</pre>
<p class="calibre2">The <kbd class="calibre11">iss</kbd> is an issuer property--in our case it will be our publishing app's backend application. The name of the logged user is obvious--<kbd class="calibre11">John Doe</kbd> has logged in successfully. The <kbd class="calibre11">admin</kbd> property is just saying that an identified user (logged into our backend's app with the correct login and password) is an admin <kbd class="calibre11">('admin': true flag)</kbd>. You will learn how to use it in this chapter.</p>
<p class="calibre2">Besides what has been said in the preceding example, the JWT's response also contains information about subjects/claims, a signed SHA256's generated token, and an expiration date. The important rule here is that you must be sure about the issuer of your token. You need to trust the content provided along with the response. It may sound complicated, but it is very simple in real-life applications.</p>
<p class="calibre2">The important thing is that you need to keep the token generated by JWT protected---this will be elaborated upon later in this chapter.</p>
<p class="calibre2">The flow is as follows:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Our client's publishing app requests a token from our express's server.</li>
<li value="2" class="calibre15">The publishing backed app issues a token to the frontend Redux's app.</li>
<li value="3" class="calibre15">After that, each time we fetch data from the backend, we check if a user has access to the requested resources on the backend--the resource consumes the token.</li>
</ol>
<p class="calibre2">In our case, the resource is a falcor-router's route, which has a close relationship with the backend, but this may work as well in more distributed platforms.</p>
<p class="calibre2">Remember that the JWT tokens are similar to private keys--you must keep them secure!</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Structure of JWT token</h1>
            

            <article>
                
<p class="calibre2">The header has information that is required on the backend for recognizing what cryptographic operation to do based on that information (metadata, the algorithms, and keys being used):</p>
<pre class="calibre22">
{ <br class="title-page-name"/>'typ': 'JWT', <br class="title-page-name"/>'alg': 'HS256' <br class="title-page-name"/>}
</pre>
<p class="calibre2">In general, that part is done 100 percent out of the box for us, so we don't have to care about headers while implementing it.</p>
<p class="calibre2">The second part consists of claims provided in the JSON format, such as:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Issuer</strong>: This lets us know who has issued the token</li>
<li class="calibre15"><strong class="calibre1">Audience</strong>: This lets us know that this token has to be consumed by our application</li>
<li class="calibre15"><strong class="calibre1">Issue date</strong>: This lets us know when the token has been created</li>
<li class="calibre15"><strong class="calibre1">Expiration date</strong>: This lets us know when the token is expiring so we have to generate a new one</li>
<li class="calibre15"><strong class="calibre1">Subject</strong>: This lets us know which part of the app can use the token (useful in bigger applications)</li>
</ul>
<p class="calibre2">Besides these claims, we can create custom claims that are specifically defined by the app's creator:</p>
<pre class="calibre22">
{ <br class="title-page-name"/>'iss': 'http://theIssuerAddress', <br class="title-page-name"/>'exp': '1450819372', <br class="title-page-name"/>'aud': 'http://myAppAddress', <br class="title-page-name"/>'sub': 'publishingApp', <br class="title-page-name"/>'scope': ['read'] <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">New MongoDB users collection</h1>
            

            <article>
                
<p class="calibre2">We need to create a users' collection in our database. The users will have privileges allowing them to:</p>
<ul class="calibre14">
<li class="calibre15">Add new articles in our publishing application</li>
<li class="calibre15">Edit existing articles in our publishing application</li>
<li class="calibre15">Delete articles in our publishing application</li>
</ul>
<p class="calibre2">The first step is that we need to create a collection. You can do this from the GUI in Robomongo (introduced at the beginning of the book), but we will use the command line.</p>
<p class="calibre2">First of all we need to create a file called <kbd class="calibre11">initPubUsers.js</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">$ [[you are in the root directory of your project]]</strong><br class="title-page-name"/><strong class="calibre1">$ touch initPubUsers.js</strong>
</pre>
<p class="calibre2">Then add the following content to <kbd class="calibre11">initPubUsers.js</kbd>:</p>
<pre class="calibre22">
[ <br class="title-page-name"/>  { <br class="title-page-name"/>'username' : 'admin', <br class="title-page-name"/>'password' : 'c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852', <br class="title-page-name"/>'firstName' : 'Kamil', <br class="title-page-name"/>'lastName' : 'Przeorski', <br class="title-page-name"/>'email' : 'kamil@mobilewebpro.pl', <br class="title-page-name"/>'role' : 'admin', <br class="title-page-name"/>'verified' : false, <br class="title-page-name"/>'imageUrl' : 'http://lorempixel.com/100/100/people/' <br class="title-page-name"/>  } <br class="title-page-name"/>]
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">The SHA256 string, <kbd class="calibre11">c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852</kbd>, is the equivalent of a password, 123456, with a salt's string equal to <kbd class="calibre11">pubApp</kbd>.</p>
<p class="calibre2">If you want to generate this salted password hash yourself, then go to <a href="http://www.xorbin.com/tools/sha256-hash-calculator" class="calibre6"><span>http://www.xorbin.com/tools/sha256-hash-calculator</span></a> and type <kbd class="calibre11">123456pubApp</kbd> on their website. You will get the following screen:</p>
<div class="packt_figure"><img class="image-border16" src="../images/00021.jpeg"/></div>
<p class="calibre2">These steps are required only at the beginning. Later we need to program a registration form that is salting the password for our own.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Importing the initPubUsers.js file into MongoDB</h1>
            

            <article>
                
<p class="calibre2">After we have the correct content in our <kbd class="calibre11">initPubUsers.js</kbd> file, we can run a command line as follows in order to import the new <kbd class="calibre11">pubUsers</kbd> collection to our database:</p>
<pre class="calibre22">
<strong class="calibre1">mongoimport --db local --collection pubUsers --jsonArrayinitPubUsers.js --host=127.0.0.1</strong>
</pre>
<p class="calibre2">You will get the same terminal output as what we we got after importing the article in <a href="part0021.html#K0RQ0-7870c13caa1244daa9bd53ca5c1e1a42" class="calibre6">Chapter 1</a>, <em class="calibre21">Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor, and Redux</em>, looking similar to this:</p>
<pre class="calibre22">
<strong class="calibre1">2009-04-03T11:36:00.566+0200  connected to: 127.0.0.1</strong><br class="title-page-name"/><strong class="calibre1">2009-04-03T11:36:00.569+0200  imported 1 document</strong>
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working on the login's falcor-route</h1>
            

            <article>
                
<p class="calibre2">Now we need to start working with the falcor-router in order to create a new endpoint that will use the JWT library to provide a unique token for the client-side app.</p>
<p class="calibre2">The first thing that we need to do is to provide <kbd class="calibre11">secret</kbd> on the backend.</p>
<p class="calibre2">Let's create that <kbd class="calibre11">secret</kbd> endpoint's config file:</p>
<pre class="calibre22">
<strong class="calibre1">$ cd server</strong><br class="title-page-name"/><strong class="calibre1">$ touch configSecret.js</strong>
</pre>
<p class="calibre2">Now we need to put in the content of this <kbd class="calibre11">secret</kbd>:</p>
<pre class="calibre22">
export default { <br class="title-page-name"/>'secret': process.env.JWT_SECRET || 'devSecretGoesHere' <br class="title-page-name"/>}
</pre>
<p class="calibre2">In future, we will use environment variables on the production server, so the notation <kbd class="calibre11">process.env.JWT_SECRET || 'devSecretGoesHere'</kbd> means that the environment variable of <kbd class="calibre11">JWT_SECRET</kbd> doesn't exist so use default <kbd class="calibre11">secret</kbd> endpoint's <kbd class="calibre11">string,devSecretGoesHere</kbd>. At this point we don't need any development environment variables.<br class="title-page-name"/></p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating a falcor-router's login (backend)</h1>
            

            <article>
                
<p class="calibre2">In order to make our codebase more organized, instead of adding one more route to our <kbd class="calibre11">server/routes.js</kbd> file, we will make a new file called <kbd class="calibre11">routesSession.js</kbd> and in that file we will keep all the endpoints related to the current logged user's session.</p>
<p class="calibre2">Make sure you are in the <kbd class="calibre11">server</kbd> directory:</p>
<pre class="calibre22">
<strong class="calibre1">$ cd server</strong>
</pre>
<p class="calibre2">First open the <kbd class="calibre11">server.js</kbd> file in order to add one line of code that will allow you to post usernames and passwords to the backend. Add this:</p>
<pre class="calibre22">
app.use(bodyParser.urlencoded({extended: false}));
</pre>
<p class="calibre2">This has to be added under <kbd class="calibre11">app.use(bodyParser.json({extended: false}));</kbd> so you will end up with <kbd class="calibre11">server.js</kbd> code that begins as follows:</p>
<pre class="calibre22">
import http from 'http'; <br class="title-page-name"/>import express from 'express'; <br class="title-page-name"/>import cors from 'cors'; <br class="title-page-name"/>import bodyParser from 'body-parser'; <br class="title-page-name"/>import mongoose from 'mongoose'; <br class="title-page-name"/>import falcor from 'falcor'; <br class="title-page-name"/>import falcorExpress from 'falcor-express'; <br class="title-page-name"/>import Router from 'falcor-router'; <br class="title-page-name"/>import routes from './routes.js'; <br class="title-page-name"/><br class="title-page-name"/>var app = express(); <br class="title-page-name"/>app.server = http.createServer(app); <br class="title-page-name"/><br class="title-page-name"/>// CORS - 3rd party middleware <br class="title-page-name"/>app.use(cors()); <br class="title-page-name"/><br class="title-page-name"/>// This is required by falcor-express middleware to work correctly with falcor-browser <br class="title-page-name"/>app.use(bodyParser.json({extended: false})); <br class="title-page-name"/>app.use(bodyParser.urlencoded({extended: false})); 
</pre>
<p class="calibre2">The last line is a new line that has to be added in order to make it work. Then create a new file in the same directory with:</p>
<pre class="calibre22">
<strong class="calibre1">$ touch routesSession.js <br class="title-page-name"/></strong>
</pre>
<p class="calibre2">And put this initial content into the <kbd class="calibre11">routesSession.js</kbd> file:</p>
<pre class="calibre22">
export default [ <br class="title-page-name"/>  {  <br class="title-page-name"/>    route: ['login'] , <br class="title-page-name"/>    call: (callPath, args) =&gt; <br class="title-page-name"/>      { <br class="title-page-name"/>      const { username, password } = args[0]; <br class="title-page-name"/><br class="title-page-name"/>      const userStatementQuery = { <br class="title-page-name"/>          $and: [ <br class="title-page-name"/>              { 'username': username }, <br class="title-page-name"/>              { 'password': password } <br class="title-page-name"/>          ] <br class="title-page-name"/>        } <br class="title-page-name"/>      } <br class="title-page-name"/>  } <br class="title-page-name"/>];
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How the call routes work </h1>
            

            <article>
                
<p class="calibre2">We have just created an initial call login route in the <kbd class="calibre11">routesSession.js</kbd> file. Instead of using a GET method, we are going to use a <kbd class="calibre11">'call'(**call: async (callPath, args) =&gt; **)</kbd>. That is the equivalent to POST in the old RESTful approach.</p>
<p class="calibre2">The difference between the call and get methods in Falcor's routes is that we can provide arguments with <kbd class="calibre11">args</kbd>. That allows us to get from the client-side the username and the password:</p>
<p class="calibre2">The plan is that after we receive credentials with this:</p>
<pre class="calibre22">
const { username, password } = args[0];
</pre>
<p class="calibre2">Then we will check them against our database with one user admin. A user will need to know that the real plaintext password is <kbd class="calibre11">123456</kbd> in order to get a correct login JWTtoken:</p>
<p class="calibre2">We also have prepared in this step a <kbd class="calibre11">userStatementQuery</kbd>---this will be used later when querying a database:</p>
<pre class="calibre22">
const userStatementQuery = { <br class="title-page-name"/>  $and: [ <br class="title-page-name"/>      { 'username': username }, <br class="title-page-name"/>      { 'password': password } <br class="title-page-name"/>  ] <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Separating the DB configs - configMongoose.js</h1>
            

            <article>
                
<p class="calibre2">We need to separate DB configs from <kbd class="calibre11">routes.js</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">$ [[we are in the server/ directory]]</strong><br class="title-page-name"/><strong class="calibre1">$ touch configMongoose.js</strong>
</pre>
<p class="calibre2">And its new content:</p>
<pre class="calibre22">
import mongoose from 'mongoose'; <br class="title-page-name"/><br class="title-page-name"/>const conf = { <br class="title-page-name"/>  hostname: process.env.MONGO_HOSTNAME || 'localhost', <br class="title-page-name"/>  port: process.env.MONGO_PORT || 27017, <br class="title-page-name"/>  env: process.env.MONGO_ENV || 'local', <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect(&amp;grave;mongodb://${conf.hostname}:  <br class="title-page-name"/>${conf.port}/${conf.env}&amp;grave;); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = { <br class="title-page-name"/>articleTitle:String, <br class="title-page-name"/>articleContent:String <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const Article = mongoose.model('Article', articleSchema,  <br class="title-page-name"/>'articles'); <br class="title-page-name"/><br class="title-page-name"/>export default { <br class="title-page-name"/>  Article <br class="title-page-name"/>};
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">We have just introduced the following new <kbd class="calibre11">env</kbd> variables: <kbd class="calibre11">MONGO_HOSTNAME</kbd>, <kbd class="calibre11">MONGO_PORT</kbd>, and <kbd class="calibre11">MONGO_ENV</kbd>. We will use them when preparing a production environment.</p>
<p class="calibre2">The <kbd class="calibre11">mongodb://${conf.hostname}:${conf.port}/${conf.env}</kbd> expression is using a templating feature available since EcmaScript6.</p>
<p class="calibre2">The rest of <kbd class="calibre11">configMongoose.jsconfig</kbd> will be known to you, as we have introduced it in <a href="part0021.html#K0RQ0-7870c13caa1244daa9bd53ca5c1e1a42" class="calibre6">Chapter 1</a>, <em class="calibre21">Configuring Full-Stack with Node.js, Express.js, MongoDB, Mongoose, Falcor, and Redux</em>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving the routes.js file</h1>
            

            <article>
                
<p class="calibre2">After we have created two new files, <kbd class="calibre11">configMongoose.js</kbd> and <kbd class="calibre11">routesSession.js</kbd>, we have to improve our <kbd class="calibre11">server/routes.js</kbd> file in order to make everything work together.<br class="title-page-name"/>
The first step is to delete from <kbd class="calibre11">routes.js</kbd> the following code:</p>
<pre class="calibre22">
import mongoose from 'mongoose'; <br class="title-page-name"/><br class="title-page-name"/>mongoose.connect('mongodb://localhost/local'); <br class="title-page-name"/><br class="title-page-name"/>const articleSchema = { <br class="title-page-name"/>articleTitle:String, <br class="title-page-name"/>articleContent:String <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const Article = mongoose.model('Article', articleSchema,  <br class="title-page-name"/>'articles');
</pre>
<p class="calibre2">Replace it with the following new code:</p>
<pre class="calibre22">
import configMongoosefrom './configMongoose'; <br class="title-page-name"/>import sessionRoutes from './routesSession'; <br class="title-page-name"/>const Article = configMongoose.Article;
</pre>
<p class="calibre2">Also, we need to spread <kbd class="calibre11">sessionRoutes</kbd> into our current <kbd class="calibre11">PublishingAppRoutes</kbd> as follows:</p>
<pre class="calibre22">
const PublishingAppRoutes = [ <br class="title-page-name"/>    ...sessionRoutes, <br class="title-page-name"/>  { <br class="title-page-name"/>  route: 'articles.length',
</pre>
<p class="calibre2">At the beginning of <kbd class="calibre11">PublishingAppRoutes</kbd> you need to spread <kbd class="calibre11">...sessionRoutes</kbd>, <kbd class="calibre11">routes</kbd>, so the login route will be available to use across the Falcor's routes.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">We got rid of the old code that was helping us to run the first Mongoose query that was fetching the articles, and we moved everything to <kbd class="calibre11">configMongoose</kbd> so that we can use it in different files around our project. We have also imported the session routes and later spread them with the <kbd class="calibre11">...</kbd> spread operation into the array called <kbd class="calibre11">PublishingAppRoutes</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Checking to see if the app works before implementing JWT</h1>
            

            <article>
                
<p class="calibre2">At this point, when doing <kbd class="calibre11">npm start</kbd>, the app should be working and showing the list of articles:</p>
<div class="packt_figure"><img class="image-border17" src="../images/00022.jpeg"/></div>
<p class="calibre2">When running with <kbd class="calibre11">npm start</kbd> you should get the following information, validating that everything works correctly:</p>
<pre class="calibre22">
Hash: eeeb09711c820a7978d5 <br class="title-page-name"/>Version2,: webpack 1.12.14 <br class="title-page-name"/>Time: 2609ms <br class="title-page-name"/> Asset    Size  Chunks             Chunk Names <br class="title-page-name"/>app.js  1.9 MB       0  [emitted]  main <br class="title-page-name"/>   [0] multi main 40 bytes {0} [built] <br class="title-page-name"/>    + 634 hidden modules <br class="title-page-name"/>Started on port 3000
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Creating a Mongoose users' model</h1>
            

            <article>
                
<p class="calibre2">In the file <kbd class="calibre11">configMongoose.js</kbd> we need to create and export a <kbd class="calibre11">User</kbd> model. Add the following code to that file:</p>
<pre class="calibre22">
const userSchema = { <br class="title-page-name"/>'username' : String, <br class="title-page-name"/>'password' : String, <br class="title-page-name"/>'firstName' : String, <br class="title-page-name"/>'lastName' : String, <br class="title-page-name"/>'email' : String, <br class="title-page-name"/>'role' : String, <br class="title-page-name"/>'verified' : Boolean, <br class="title-page-name"/>'imageUrl' : String <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>const User = mongoose.model('User', userSchema, 'pubUsers'); <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>export default { <br class="title-page-name"/>  Article, <br class="title-page-name"/>  User <br class="title-page-name"/>};
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">userSchema</kbd> describes our user's JSON model. The user is our Mongoose's model that is pointing to the <kbd class="calibre11">pubUsers</kbd> collection in our MongoDB. At the end, we are exporting the <kbd class="calibre11">User</kbd> model by adding it to the export default's object.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Implementing JWT in the routesSession.js file</h1>
            

            <article>
                
<p class="calibre2">The first step is to export our <kbd class="calibre11">User</kbd> model into <kbd class="calibre11">routesSession</kbd> scope by adding at the top of that file an <kbd class="calibre11">import</kbd> statement:</p>
<pre class="calibre22">
import configMongoosefrom './configMongoose'; <br class="title-page-name"/>const User = configMongoose.User;
</pre>
<p class="calibre2">Install <kbd class="calibre11">jsonwebtoken</kbd> and <kbd class="calibre11">crypto</kbd> (for SHA256):</p>
<pre class="calibre22">
<strong class="calibre1">$ npmi --save jsonwebtoken crypto</strong>
</pre>
<p class="calibre2">After you have installed <kbd class="calibre11">jsonwebtoken</kbd>, we need to import it to <kbd class="calibre11">routesSession.js</kbd>:</p>
<pre class="calibre22">
import jwt from 'jsonwebtoken'; <br class="title-page-name"/>import crypto from 'crypto'; <br class="title-page-name"/>import jwtSecret from './configSecret';
</pre>
<p class="calibre2">After you have imported everything in the <kbd class="calibre11">routesSession</kbd>, continue on working with the <kbd class="calibre11">route: ['login']</kbd>.</p>
<p class="calibre2">You need to improve <kbd class="calibre11">userStatementQuery</kbd>, so it will have the <kbd class="calibre11">saltedPassword</kbd> instead of plain text:</p>
<pre class="calibre22">
const saltedPassword = password+'pubApp';  <br class="title-page-name"/>// pubApp is our salt string <br class="title-page-name"/>const saltedPassHash = crypto <br class="title-page-name"/>.createHash('sha256') <br class="title-page-name"/>.update(saltedPassword) <br class="title-page-name"/>.digest('hex'); <br class="title-page-name"/>const userStatementQuery = { <br class="title-page-name"/>  $and: [ <br class="title-page-name"/>      { 'username': username }, <br class="title-page-name"/>      { 'password': saltedPassHash } <br class="title-page-name"/>  ] <br class="title-page-name"/>}
</pre>
<p class="calibre2">So instead of plain text, we will query a salted SHA256 password.</p>
<p class="calibre2">Under this <kbd class="calibre11">userStatementQuery</kbd>, return Promise, with the following details:</p>
<pre class="calibre22">
return User.find(userStatementQuery, function(err, user) { <br class="title-page-name"/>   if (err) throw err; <br class="title-page-name"/> }).then((result) =&gt; { <br class="title-page-name"/>   if(result.length) { <br class="title-page-name"/>     return null;  <br class="title-page-name"/>     // SUCCESSFUL LOGIN mocked now (will implement next) <br class="title-page-name"/>   } else { <br class="title-page-name"/>     // INVALID LOGIN <br class="title-page-name"/>     return [ <br class="title-page-name"/>       { <br class="title-page-name"/>         path: ['login', 'token'],  <br class="title-page-name"/>         value: "INVALID" <br class="title-page-name"/>       }, <br class="title-page-name"/>       { <br class="title-page-name"/>         path: ['login', 'error'],  <br class="title-page-name"/>         value: "NO USER FOUND, incorrect login  <br class="title-page-name"/>         information" <br class="title-page-name"/>       } <br class="title-page-name"/>     ]; <br class="title-page-name"/>   } <br class="title-page-name"/>   return result; <br class="title-page-name"/> });
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">User.find</kbd> is a Promise that comes from Mongoose user's model (that we created in <kbd class="calibre11">configMongoose.js</kbd>)--this is a standard method. Then as a first argument we provide <kbd class="calibre11">userStatementQuery</kbd> which is that filter's object with the username and password in it: <kbd class="calibre11">(*{ username, password } = args[0];)</kbd>.</p>
<p class="calibre2">Next, we provide a function that is a callback when the query is done: <kbd class="calibre11">(function(err, user) {)</kbd>. We count the amount of results with <kbd class="calibre11">if(result.length) {</kbd>.</p>
<p class="calibre2">If <kbd class="calibre11">result.length=== 0</kbd> then we have mocked <kbd class="calibre11">return</kbd> statement, and we are getting the <kbd class="calibre11">else</kbd> code running with the following return:</p>
<pre class="calibre22">
 return [ <br class="title-page-name"/>    { <br class="title-page-name"/>      path: ['login', 'token'],  <br class="title-page-name"/>      value: "INVALID" <br class="title-page-name"/>    }, <br class="title-page-name"/>    { <br class="title-page-name"/>      path: ['login', 'error'],  <br class="title-page-name"/>      value: 'NO USER FOUND, incorrect login  <br class="title-page-name"/>      information' <br class="title-page-name"/>    } <br class="title-page-name"/>  ];
</pre>
<p class="calibre2">As you will learn later, we will ask for that token's path on the frontend, <kbd class="calibre11">['login', 'token']</kbd>. In this case, we haven't found the correct username and the password provided so we return the <kbd class="calibre11">"INVALID"</kbd> string, instead of a JWT token. The path <kbd class="calibre11">['login', 'error']</kbd> is describing the error's type in more detail so that message can be shown to a user that has provided the invalid login credentials.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Successful login on falcor-route</h1>
            

            <article>
                
<p class="calibre2">We need to improve the successful login path. We have a case for handling an invalid login; we need to make a case that will handle a successful login, so replace this code:</p>
<pre class="calibre22">
return null; // SUCCESSFUL LOGIN mocked now (will implement next)
</pre>
<p class="calibre2">With this code that is returning the successful login's details:</p>
<pre class="calibre22">
const role = result[0].role; <br class="title-page-name"/>const userDetailsToHash = username+role; <br class="title-page-name"/>const token = jwt.sign(userDetailsToHash, jwtSecret.secret); <br class="title-page-name"/>return [ <br class="title-page-name"/>  { <br class="title-page-name"/>    path: ['login', 'token'], <br class="title-page-name"/>    value: token <br class="title-page-name"/>  }, <br class="title-page-name"/>  { <br class="title-page-name"/>    path: ['login', 'username'], <br class="title-page-name"/>    value: username <br class="title-page-name"/>  }, <br class="title-page-name"/>  { <br class="title-page-name"/>    path: ['login', 'role'], <br class="title-page-name"/>    value: role <br class="title-page-name"/>  }, <br class="title-page-name"/>  { <br class="title-page-name"/>    path: ['login', 'error'], <br class="title-page-name"/>    value: false <br class="title-page-name"/>  } <br class="title-page-name"/>];
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">As you can see, the only thing that we fetch from DB right now is the role <kbd class="calibre11">value === result[0].role</kbd>. We need to add this to hash, because we don't want our app to be vulnerable so a normal user can get an admin role with some hacking. The value of the token is calculated based on <kbd class="calibre11">userDetailsToHash = username+role</kbd>---that's enough for now.</p>
<p class="calibre2">After we are fine with this, the only thing that needs to be done on the backend is returning the paths with values:</p>
<ul class="calibre14">
<li class="calibre15">The login token with <kbd class="calibre11">['login', 'token']</kbd></li>
<li class="calibre15">The username with <kbd class="calibre11">['login', 'username']</kbd></li>
<li class="calibre15">The logged user's role with <kbd class="calibre11">['login', 'role']</kbd></li>
<li class="calibre15">Information that there were no errors at all with <kbd class="calibre11">['login', 'error']</kbd></li>
</ul>
<p class="calibre2">The next step is to use this route on the frontend. Run the app and if everything is working fine, we can start coding on the frontend side.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Frontend side and Falcor</h1>
            

            <article>
                
<p class="calibre2">Let's create a new route for the login in our Redux application. In order to do that, we need to introduce the <kbd class="calibre11">react-router</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">$ npmi --save react-router@1.0.0redux-simple-router@0.0.10redux-thunk@1.0.0</strong>
</pre>
<div class="packt_infobox">It's important to use the correct NPM's version otherwise things get broke!</div>
<p class="calibre2">After we have installed them, we need to add routes in <kbd class="calibre11">src</kbd>:</p>
<pre class="calibre22">
<strong class="calibre1">$ cd src</strong><br class="title-page-name"/><strong class="calibre1">$ mkdir routes</strong><br class="title-page-name"/><strong class="calibre1">$ cd routes</strong><br class="title-page-name"/><strong class="calibre1">$ touch index.js</strong>
</pre>
<p class="calibre2">Then make the content of this <kbd class="calibre11">index.js</kbd> file as follows:</p>
<pre class="calibre22">
import React  from 'react'; <br class="title-page-name"/>import {Route, IndexRoute} from 'react-router'; <br class="title-page-name"/>import CoreLayout  from '../layouts/CoreLayout'; <br class="title-page-name"/>import PublishingApp  from '../layouts/PublishingApp'; <br class="title-page-name"/>import LoginView  from '../views/LoginView'; <br class="title-page-name"/><br class="title-page-name"/>export default ( <br class="title-page-name"/>&lt;Route component={CoreLayout} path='/'&gt; <br class="title-page-name"/>&lt;IndexRoute component={PublishingApp} name='home' /&gt; <br class="title-page-name"/>&lt;Route component={LoginView} path='login' name='login' /&gt; <br class="title-page-name"/>&lt;/Route&gt; <br class="title-page-name"/>);
</pre>
<p class="calibre2">At this point, we are missing two components for our app called <kbd class="calibre11">CoreLayout</kbd> and <kbd class="calibre11">LoginView</kbd> (we will implement them in a minute).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The CoreLayout component</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">CoreLayout</kbd> component is the wrapper for our whole application. Create it by executing the following:</p>
<pre class="calibre22">
<strong class="calibre1">cd ../layouts/ <br class="title-page-name"/>touch CoreLayout.js <br class="title-page-name"/></strong>
</pre>
<p class="calibre2">Then, populate it with the following content:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import {Link} from 'react-router'; <br class="title-page-name"/><br class="title-page-name"/>class CoreLayout extends React.Component { <br class="title-page-name"/>  static propTypes = { <br class="title-page-name"/>    children : React.PropTypes.element <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;span&gt; <br class="title-page-name"/>Links: &lt;Link to='/login'&gt;Login&lt;/Link&gt; |  <br class="title-page-name"/>&lt;Link to='/'&gt;Home Page&lt;/Link&gt; <br class="title-page-name"/>&lt;/span&gt; <br class="title-page-name"/>&lt;br/&gt; <br class="title-page-name"/>          {this.props.children} <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>export default CoreLayout;
</pre>
<p class="calibre2">As you probably know, all the content of a current route will go into the <kbd class="calibre11">{this.props.children}</kbd> target (that is a <kbd class="calibre11">basicReact.JS</kbd> concept that you must know beforehand). We also created two links to our routes as a header.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">The LoginView component</h1>
            

            <article>
                
<p class="calibre2">For the time being, we will create a mocked <kbd class="calibre11">LoginView</kbd> component. Let's create the <kbd class="calibre11">views</kbd> directory:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd</strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the src folder]]]</strong><br class="title-page-name"/><strong class="calibre1">$ mkdir views</strong><br class="title-page-name"/><strong class="calibre1">$ cd views</strong><br class="title-page-name"/><strong class="calibre1">$ touch LoginView.js</strong>
</pre>
<p class="calibre2">The content of the <kbd class="calibre11">LoginView.js</kbd> file is shown in the following code with the <kbd class="calibre11">FORM GOES HERE</kbd> placeholder:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import Falcor from 'falcor'; <br class="title-page-name"/>import falcorModel from '../falcorModel.js'; <br class="title-page-name"/>import {connect} from 'react-redux'; <br class="title-page-name"/>import {bindActionCreators} from 'redux'; <br class="title-page-name"/><br class="title-page-name"/>const mapStateToProps = (state) =&gt; ({ <br class="title-page-name"/>  ...state <br class="title-page-name"/>}); <br class="title-page-name"/><br class="title-page-name"/>// You can add your reducers here <br class="title-page-name"/>const mapDispatchToProps = (dispatch) =&gt; ({}); <br class="title-page-name"/><br class="title-page-name"/>class LoginView extends React.Component { <br class="title-page-name"/>  render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Login view&lt;/h1&gt; <br class="title-page-name"/>          FORM GOES HERE <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>export default connect(mapStateToProps, mapDispatchToProps)(LoginView);
</pre>
<p class="calibre2">We are done with all the missing pieces for the <kbd class="calibre11">routes/index.js</kbd>, but there is some other outstanding stuff to do before our app with the routing will start working.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A root's container for our app</h1>
            

            <article>
                
<p class="calibre2">Because our app is getting more complicated, we need to create a container that it will live in. In order to do that, let's do the following in the <kbd class="calibre11">src</kbd> location:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd</strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the src folder]]]</strong><br class="title-page-name"/><strong class="calibre1">$ mkdir containers</strong><br class="title-page-name"/><strong class="calibre1">$ cd containers</strong><br class="title-page-name"/><strong class="calibre1">$ touch Root.js</strong>
</pre>
<p class="calibre2">The <kbd class="calibre11">Root.js</kbd> is going to be our main root file. The content of this file is as follows:</p>
<pre class="calibre22">
import React  from 'react'; <br class="title-page-name"/>import {Provider}  from 'react-redux'; <br class="title-page-name"/>import {Router}  from 'react-router'; <br class="title-page-name"/>import routes   from '../routes'; <br class="title-page-name"/>import createHashHistory  from 'history/lib/createHashHistory'; <br class="title-page-name"/><br class="title-page-name"/>const noQueryKeyHistory = createHashHistory({ <br class="title-page-name"/>queryKey: false <br class="title-page-name"/>}); <br class="title-page-name"/><br class="title-page-name"/>export default class Root extends React.Component { <br class="title-page-name"/>  static propTypes = { <br class="title-page-name"/>    history : React.PropTypes.object.isRequired, <br class="title-page-name"/>    store   : React.PropTypes.object.isRequired <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;Provider store={this.props.store}&gt; <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;Router history={noQueryKeyHistory}&gt; <br class="title-page-name"/>            {routes} <br class="title-page-name"/>&lt;/Router&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>&lt;/Provider&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">For now it's only a simple container, but later we will implement into it more features for debugging, hot reloading, and so on. The <kbd class="calibre11">noQueryKeyHistory</kbd> is saying to the router, that we don't want to have any random strings in our URL so our routes will be looking nicer (not a big deal, you can change the false flag to true, to see what I am talking about).<br class="title-page-name"/></p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Remaining configuration for configureStore and rootReducer</h1>
            

            <article>
                
<p class="calibre2">Let's create <kbd class="calibre11">rootReducer</kbd> first. Why do we need it? Because in bigger applications you always end up with many different reducers; for example, in our app we will have reducers such as:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Article's reducer</strong>: Which keeps stuff related to articles (<kbd class="calibre11">RETURN_ALL_ARTICLES</kbd> and so on)</li>
<li class="calibre15"><strong class="calibre1">Session's reducer</strong>: Which will be related to our users' sessions (<kbd class="calibre11">LOGIN</kbd>, <kbd class="calibre11">REGISTER</kbd>, and so on)</li>
<li class="calibre15"><strong class="calibre1">Editor's reducer</strong>: Which will be related to the editor's actions (<kbd class="calibre11">EDIT_ARTICLE</kbd>, <kbd class="calibre11">DELETE_ARTICLE</kbd>, <kbd class="calibre11">ADD_NEW_ARTICLE</kbd>, and so on)</li>
<li class="calibre15"><strong class="calibre1">Routing's reducer</strong>: This will manage the state of our routes (out-of-the-box, because it is managed by the redux-simple-router's external lib)</li>
</ul>
<p class="calibre2">Let's create an <kbd class="calibre11">index.js</kbd> file in our <kbd class="calibre11">reducers</kbd> directory:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd</strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the src folder]]]</strong><br class="title-page-name"/><strong class="calibre1">$ cd reducers</strong><br class="title-page-name"/><strong class="calibre1">$ touch index.js</strong>
</pre>
<p class="calibre2">The content for the <kbd class="calibre11">index.js</kbd> is as follows:</p>
<pre class="calibre22">
import {combineReducers} from 'redux'; <br class="title-page-name"/>import {routeReducer} from 'redux-simple-router'; <br class="title-page-name"/>import article  from './article'; <br class="title-page-name"/><br class="title-page-name"/>export default combineReducers({ <br class="title-page-name"/>  routing: routeReducer, <br class="title-page-name"/>  article <br class="title-page-name"/>});
</pre>
<p class="calibre2">The new thing here is that we are introducing a <kbd class="calibre11">combineReducers</kbd> function from Redux. This is exactly what I've written before. We will have more than one reducer---in our case, we have also introduced the <kbd class="calibre11">routeReducer</kbd> from a redux-simple-router's library.</p>
<p class="calibre2">The next step is to create the <kbd class="calibre11">configureStore</kbd> that will be managing our stores and also in order to implement a server rendering later in this book:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd</strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the src folder]]]</strong><br class="title-page-name"/><strong class="calibre1">$ mkdir store</strong><br class="title-page-name"/><strong class="calibre1">$ cd store</strong><br class="title-page-name"/><strong class="calibre1">$ touch configureStore.js</strong>
</pre>
<p class="calibre2">The content for the <kbd class="calibre11">configureStore.js</kbd> file is as follows:</p>
<pre class="calibre22">
import rootReducer  from '../reducers'; <br class="title-page-name"/>import thunk  from 'redux-thunk'; <br class="title-page-name"/>import {applyMiddleware,compose,createStore} from 'redux'; <br class="title-page-name"/><br class="title-page-name"/>export default function configureStore (initialState, debug =  <br class="title-page-name"/>false) { <br class="title-page-name"/>let createStoreWithMiddleware; <br class="title-page-name"/>const middleware = applyMiddleware(thunk); <br class="title-page-name"/><br class="title-page-name"/>createStoreWithMiddleware = compose(middleware); <br class="title-page-name"/><br class="title-page-name"/>const store = createStoreWithMiddleware(createStore)( <br class="title-page-name"/>rootReducer, initialState <br class="title-page-name"/>  ); <br class="title-page-name"/>  return store; <br class="title-page-name"/>}
</pre>
<p class="calibre2">In the preceding code, we are importing the <kbd class="calibre11">rootReducer</kbd> that we've created recently. We also import the <kbd class="calibre11">redux-thunk</kbd> lib which is very useful for server-side rendering (described later in the book).</p>
<p class="calibre2">At the end, we export a store which is composed of many different reducers (currently routing and the article's reducer that you can find in <kbd class="calibre11">reducer/index.js</kbd>) and is able to handle the server-rendering initial state.<br class="title-page-name"/></p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Last tweaks in layouts/PublishingApp.js before running the app</h1>
            

            <article>
                
<p class="calibre2">The last thing that <span>changed</span> in our app is that we have out-of-date code in our publishing app.</p>
<p class="calibre2">Why is it outdated? Because we have introduced <kbd class="calibre11">rootReducer</kbd> and <kbd class="calibre11">combineReducers</kbd>. So if you check your code in the rendering of <kbd class="calibre11">PublishingApp</kbd> here, it won't work:</p>
<pre class="calibre22">
let articlesJSX = []; <br class="title-page-name"/><br class="title-page-name"/>for(let articleKey in this.props) { <br class="title-page-name"/>const articleDetails = this.props[articleKey]; <br class="title-page-name"/><br class="title-page-name"/>const currentArticleJSX = ( <br class="title-page-name"/>&lt;div key={articleKey}&gt; <br class="title-page-name"/>&lt;h2&gt;{articleDetails.articleTitle}&lt;/h2&gt; <br class="title-page-name"/>&lt;h3&gt;{articleDetails.articleContent}&lt;/h3&gt; <br class="title-page-name"/>&lt;/div&gt;); <br class="title-page-name"/><br class="title-page-name"/>articlesJSX.push(currentArticleJSX); <br class="title-page-name"/>}
</pre>
<p class="calibre2">You need to change it to this:</p>
<pre class="calibre22">
let articlesJSX = []; <br class="title-page-name"/><br class="title-page-name"/>for(let articleKey in this.props.article) { <br class="title-page-name"/>const articleDetails = this.props.article[articleKey]; <br class="title-page-name"/><br class="title-page-name"/>const currentArticleJSX = ( <br class="title-page-name"/>&lt;div key={articleKey}&gt; <br class="title-page-name"/>&lt;h2&gt;{articleDetails.articleTitle}&lt;/h2&gt; <br class="title-page-name"/>&lt;h3&gt;{articleDetails.articleContent}&lt;/h3&gt; <br class="title-page-name"/>&lt;/div&gt;); <br class="title-page-name"/><br class="title-page-name"/>articlesJSX.push(currentArticleJSX); <br class="title-page-name"/>}
</pre>
<p class="calibre2">Do you see the difference? The old <kbd class="calibre11">for(let articleKey in this.props)</kbd> has changed into <kbd class="calibre11">for(let articleKey in this.props.article)</kbd> and <kbd class="calibre11">this.props[articleKey]</kbd> has changed to <kbd class="calibre11">this.props.article[articleKey]</kbd>. Why? I will recall again: now every new reducer will be available in our app via its name created in <kbd class="calibre11">routes/index.js</kbd>. We have named our reducer article, so we now had to add this into <kbd class="calibre11">this.props.article</kbd> to make this stuff work together.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Last changes in src/app.js before running the app</h1>
            

            <article>
                
<p class="calibre2">The last thing is to improve the <kbd class="calibre11">src/app.js</kbd> so it will use the root's container. We need to change the old code:</p>
<pre class="calibre22">
// old codebase, to improve: <br class="title-page-name"/>import React from 'react' <br class="title-page-name"/>import { render } from 'react-dom' <br class="title-page-name"/>import { Provider } from 'react-redux' <br class="title-page-name"/>import { createStore } from 'redux' <br class="title-page-name"/>import article from './reducers/article' <br class="title-page-name"/>import PublishingApp from './layouts/PublishingApp' <br class="title-page-name"/><br class="title-page-name"/>const store = createStore(article) <br class="title-page-name"/><br class="title-page-name"/>render( <br class="title-page-name"/>&lt;Provider store={store}&gt; <br class="title-page-name"/>&lt;PublishingApp store={store} /&gt; <br class="title-page-name"/>&lt;/Provider&gt;, <br class="title-page-name"/>document.getElementById('publishingAppRoot') <br class="title-page-name"/>);
</pre>
<p class="calibre2">We need to change the preceding code to the following:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import ReactDOM from 'react-dom'; <br class="title-page-name"/>import createBrowserHistory from 'history/lib/createBrowserHistory'; <br class="title-page-name"/>import {syncReduxAndRouter} from 'redux-simple-router'; <br class="title-page-name"/>import Root from './containers/Root'; <br class="title-page-name"/>import configureStore from './store/configureStore'; <br class="title-page-name"/><br class="title-page-name"/>const target  = document.getElementById('publishingAppRoot'); <br class="title-page-name"/>const history = createBrowserHistory(); <br class="title-page-name"/><br class="title-page-name"/>export const store = configureStore(window.__INITIAL_STATE__); <br class="title-page-name"/><br class="title-page-name"/>syncReduxAndRouter(history, store); <br class="title-page-name"/><br class="title-page-name"/>const node = ( <br class="title-page-name"/>&lt;Root <br class="title-page-name"/>      history={history} <br class="title-page-name"/>      store={store}  /&gt; <br class="title-page-name"/>); <br class="title-page-name"/><br class="title-page-name"/>ReactDOM.render(node, target);
</pre>
<p class="calibre2">We start using the <kbd class="calibre11">Root</kbd> instead of the <kbd class="calibre11">Provider</kbd> directly, and we need to send the store and history's props to the <kbd class="calibre11">Root</kbd> component. The <kbd class="calibre11">***export const store = configureStore(window.__INITIAL_STATE__)***</kbd> part is here for the server-side rendering which we will add in one of the following chapters. We also use the history's library to manage the browser's history with the JavaScript.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Screenshots of our running app</h1>
            

            <article>
                
<p class="calibre2">Currently when you do <kbd class="calibre11">npm start</kbd> then you will see the following two routes.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Home page</h1>
            

            <article>
                
<div class="packt_figure"><img class="image-border18" src="../images/00023.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Login view</h1>
            

            <article>
                
<div class="packt_figure"><img class="image-border19" src="../images/00024.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working on the login form that will call the backend in order to authenticate</h1>
            

            <article>
                
<p class="calibre2">Okay, so we have done a lot of preparation in terms of having an extensible project structure (<kbd class="calibre11">routes</kbd>, <kbd class="calibre11">rootReducer</kbd>, <kbd class="calibre11">configStores</kbd>, and so on).</p>
<p class="calibre2">In order to make our app nicer from a user perspective, we will start using Material Design CSS. For making our work easier with forms, we will start using a <kbd class="calibre11">formsy-react</kbd> library. Let's install it:</p>
<pre class="calibre22">
<strong class="calibre1">$ npm i --save material-ui@0.14.4formsy-react@0.17.0</strong>
</pre>
<p class="calibre2">At the time of writing this book, the version .20.14.4 of Material UI is the best choice; I used this version because the ecosystem is changing so quickly that it's better to mark the used version in here so you won't have any surprises when following the instructions in this book.</p>
<p class="calibre2">The <kbd class="calibre11">formsy-react</kbd> library is a very handy library which will help us to validate our forms in the publishing app. We will use it on pages like login and registration as you will see on the next pages.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Working on LoginForm and DefaultInput components</h1>
            

            <article>
                
<p class="calibre2">After we are done with installing our new dependencies, let's create a folder that will keep files related to dumb components (the components that don't have access to any stores; they communicate with the other parts of our application with the help of callbacks---you will learn more about this later):</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd</strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the src folder]]]</strong><br class="title-page-name"/><strong class="calibre1">$ mkdir components</strong><br class="title-page-name"/><strong class="calibre1">$ cd components</strong><br class="title-page-name"/><strong class="calibre1">$ touch DefaultInput.js</strong>
</pre>
<p class="calibre2">Then make the content of this file as follows:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import {TextField} from 'material-ui'; <br class="title-page-name"/>import {HOC} from 'formsy-react'; <br class="title-page-name"/><br class="title-page-name"/>class DefaultInput extends React.Component { <br class="title-page-name"/>  constructor(props) { <br class="title-page-name"/>    super(props); <br class="title-page-name"/>    this.changeValue = this.changeValue.bind(this); <br class="title-page-name"/>    this.state = {currentText: null} <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>changeValue(e) { <br class="title-page-name"/>this.setState({currentText: e.target.value}) <br class="title-page-name"/>this.props.setValue(e.target.value); <br class="title-page-name"/>this.props.onChange(e); <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  render() { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;TextField <br class="title-page-name"/>          ref={this.props.name} <br class="title-page-name"/>          floatingLabelText={this.props.title} <br class="title-page-name"/>          name={this.props.name} <br class="title-page-name"/>          onChange={this.changeValue} <br class="title-page-name"/>          required={this.props.required} <br class="title-page-name"/>          type={this.props.type} <br class="title-page-name"/>          value={this.state.currentText ?  <br class="title-page-name"/>          this.state.currentText : this.props.value} <br class="title-page-name"/>          defaultValue={this.props.defaultValue} /&gt; <br class="title-page-name"/>        {this.props.children} <br class="title-page-name"/>&lt;/div&gt;); <br class="title-page-name"/>  } <br class="title-page-name"/>}; <br class="title-page-name"/><br class="title-page-name"/>export default HOC(DefaultInput);
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">The <kbd class="calibre11">{HOC}</kbd> from <kbd class="calibre11">formsy-react</kbd> is another way of decorating the component (aka <kbd class="calibre11">mixin</kbd> in React's ECMAScript5) with export default <kbd class="calibre11">HOC(DefaultInput)</kbd>--you can find more information about this at <a href="https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc" class="calibre6"><span>https://github.com/christianalfoni/formsy-react/blob/master/API.md#formsyhoc</span></a>.</p>
<p class="calibre2">We are also using the <kbd class="calibre11">TextField</kbd> from the <kbd class="calibre11">material-ui</kbd>; then it takes different properties. The following are the properties:</p>
<ul class="calibre14">
<li class="calibre15"><kbd class="calibre11">ref</kbd>: We want <kbd class="calibre11">ref</kbd> for each input with its name (username and e-mail).</li>
<li class="calibre15"><kbd class="calibre11">floatingLabelText</kbd>: This is a nice looking floating text (known as label).</li>
<li class="calibre15"><kbd class="calibre11">onChange</kbd>: This tells the function's name that has to be called when someone is typing into the TextField.</li>
<li class="calibre15"><kbd class="calibre11">required</kbd>: This helps us to manage the required inputs in our form.</li>
<li class="calibre15"><kbd class="calibre11">value</kbd>: This is, of course, the current value of our TextField.</li>
<li class="calibre15"><kbd class="calibre11">defaultValue</kbd>: This is a value that is initial. It is very important to remember that it's called just once when a component is calling a constructor of the component.</li>
</ul>
<p class="calibre2">The current text (<kbd class="calibre11">this.state.currentText</kbd>) is the value of the <kbd class="calibre11">DefaultInput</kbd> component---it changes with the new value on every <kbd class="calibre11">changeValue</kbd> event called by the callback given in the <kbd class="calibre11">TextFieldonChange</kbd> prop.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">LoginForm and making it work with LoginView</h1>
            

            <article>
                
<p class="calibre2">The next step is to create <kbd class="calibre11">LoginForm</kbd>. This will use the <kbd class="calibre11">DefaultInput</kbd> component with the following commands:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd</strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the components folder]]]</strong><br class="title-page-name"/><strong class="calibre1">$ touch LoginForm.js</strong>
</pre>
<p class="calibre2">Then the content of our <kbd class="calibre11">src/components/LoginForm.js</kbd> file is as follows:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import Formsy from 'formsy-react'; <br class="title-page-name"/>import {RaisedButton, Paper} from 'material-ui'; <br class="title-page-name"/>import DefaultInput from './DefaultInput'; <br class="title-page-name"/><br class="title-page-name"/>export class LoginForm extends React.Component { <br class="title-page-name"/>  constructor() { <br class="title-page-name"/>    super(); <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  render() { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;Formsy.FormonSubmit={this.props.onSubmit}&gt; <br class="title-page-name"/>&lt;Paper zDepth={1} style={{padding: 32}}&gt; <br class="title-page-name"/>&lt;h3&gt;Log in&lt;/h3&gt; <br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>onChange={(event) =&gt; {}}  <br class="title-page-name"/>name='username' <br class="title-page-name"/>title='Username (admin)' <br class="title-page-name"/>required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>onChange={(event) =&gt; {}}  <br class="title-page-name"/>type='password' <br class="title-page-name"/>name='password' <br class="title-page-name"/>title='Password (123456)' <br class="title-page-name"/>required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;div style={{marginTop: 24}}&gt; <br class="title-page-name"/>&lt;RaisedButton <br class="title-page-name"/>              secondary={true} <br class="title-page-name"/>              type="submit" <br class="title-page-name"/>              style={{margin: '0 auto', display: 'block', width:  <br class="title-page-name"/>              150}} <br class="title-page-name"/>              label={'Log in'} /&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>&lt;/Paper&gt; <br class="title-page-name"/>&lt;/Formsy.Form&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">In the preceding code, we have our <kbd class="calibre11">LoginForm</kbd> component that is using the <kbd class="calibre11">DefaultInput</kbd>'s component. It's a simple <kbd class="calibre11">React.js</kbd> form that after being submit calls the <kbd class="calibre11">this.props.onSubmit</kbd>--this <kbd class="calibre11">onSubmit</kbd> function will be defined in <kbd class="calibre11">src/views/LoginView.js</kbd> smart component in a moment. I won't talk too much about attached styles on the component because it's up to you how you will style it--you will see a screenshot of applied styles of our app in a moment.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Improving the src/views/LoginView.js</h1>
            

            <article>
                
<p class="calibre2">The last part at our development at this stage before running our application is to improve the <kbd class="calibre11">LoginView</kbd> component.</p>
<p class="calibre2">In <kbd class="calibre11">src/views/LoginView.js</kbd> make the following changes. Import our new <kbd class="calibre11">LoginForm</kbd> component:</p>
<pre class="calibre22">
import {LoginForm} from '../components/LoginForm.js'; <br class="title-page-name"/>Add a new constructor of that component: <br class="title-page-name"/> constructor(props) { <br class="title-page-name"/>    super(props); <br class="title-page-name"/>    this.login = this.login.bind(this); <br class="title-page-name"/>    this.state = { <br class="title-page-name"/>      error: null <br class="title-page-name"/>    }; <br class="title-page-name"/>  }
</pre>
<p class="calibre2">Then after you are done with imports and constructors, you need a new function called <kbd class="calibre11">login</kbd>:</p>
<pre class="calibre22">
async login(credentials) { <br class="title-page-name"/>console.info('credentials', credentials); <br class="title-page-name"/><br class="title-page-name"/>    await falcorModel <br class="title-page-name"/>      .call(['login'],[credentials]) <br class="title-page-name"/>      .then((result) =&gt;result); <br class="title-page-name"/><br class="title-page-name"/>const tokenRes = await falcorModel.getValue('login.token'); <br class="title-page-name"/>console.info('tokenRes', tokenRes); <br class="title-page-name"/>    return; <br class="title-page-name"/>  }
</pre>
<p class="calibre2">At this point, the <kbd class="calibre11">login</kbd> function only prints our new JWT token to the console--it's enough for now; later we will build more on top of it.</p>
<p class="calibre2">The last step here is to improve our <kbd class="calibre11">render</kbd> function from:</p>
<pre class="calibre22">
 render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Login view&lt;/h1&gt; <br class="title-page-name"/>          FORM GOES HERE <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">To the new one, as follows:</p>
<pre class="calibre22">
 render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Login view&lt;/h1&gt; <br class="title-page-name"/>&lt;div style={{maxWidth: 450, margin: '0 auto'}}&gt; <br class="title-page-name"/>&lt;LoginForm <br class="title-page-name"/>onSubmit={this.login} /&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">Great! Now we are done! The following is what you will see after running <kbd class="calibre11">npm start</kbd> and running it in your browser:</p>
<div class="packt_figure"><img class="image-border20" src="../images/00025.jpeg"/></div>
<p class="calibre2">As you can see in the browser's console, we can see the submitted credential's object <kbd class="calibre11">(credentials Object {username: "admin", password: "123456"})</kbd> and also a token that has been fetched from the backend <kbd class="calibre11">(tokenRes eyJhbGciOiJIUzI1NiJ9.YWRtaW5hZG1pbg.NKmrphxbqNcL_jFLBdTWGM6Y_Q78xks5E2TxBZRyjDA)</kbd>. All this tells us that we are on track in order to implement the login's mechanism in our publishing application.</p>
<div class="packt_infobox"><span class="packt_screen">Important<br class="calibre24"/></span>If you get an error, then make sure that you have used the <kbd class="calibre23">123456</kbd> password while creating the hash. Otherwise, type in the custom password that is valid to your case.</div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Making DashboardView's component</h1>
            

            <article>
                
<p class="calibre2">At this point, we have a login feature that is not finished, but before continuing the work on it, let's create a simple <kbd class="calibre11">src/views/DashboardView.js</kbd> component that will be shown after a successful login:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd </strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the views folder]]] </strong><br class="title-page-name"/><strong class="calibre1">$ touch DashboardView.js</strong>
</pre>
<p class="calibre2">Add some simple content as follows:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import Falcor from 'falcor'; <br class="title-page-name"/>import falcorModel from '../falcorModel.js'; <br class="title-page-name"/>import { connect } from 'react-redux'; <br class="title-page-name"/>import { bindActionCreators } from 'redux'; <br class="title-page-name"/>import { LoginForm } from '../components/LoginForm.js'; <br class="title-page-name"/><br class="title-page-name"/>const mapStateToProps = (state) =&gt; ({ <br class="title-page-name"/>  ...state <br class="title-page-name"/>}); <br class="title-page-name"/><br class="title-page-name"/>// You can add your reducers here <br class="title-page-name"/>const mapDispatchToProps = (dispatch) =&gt; ({}); <br class="title-page-name"/><br class="title-page-name"/>class DashboardView extends React.Component { <br class="title-page-name"/>render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Dashboard - loggedin!&lt;/h1&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/>export default connect(mapStateToProps, mapDispatchToProps)(DashboardView);
</pre>
<p class="calibre2">This is a simple component, which is static at this point. Later, we will build more features into it.</p>
<p class="calibre2">The last thing regarding the dashboards that we need to create is a new route in the <kbd class="calibre11">src/routes/index.js</kbd> file:</p>
<pre class="calibre22">
import DashboardView from '../views/DashboardView'; <br class="title-page-name"/><br class="title-page-name"/>export default ( <br class="title-page-name"/>&lt;Route component={CoreLayout} path='/'&gt; <br class="title-page-name"/>&lt;IndexRoute component={PublishingApp} name='home' /&gt; <br class="title-page-name"/>&lt;Route component={LoginView} path='login' name='login' /&gt; <br class="title-page-name"/>&lt;Route component={DashboardView} path='dashboard'   name='dashboard' /&gt; <br class="title-page-name"/>&lt;/Route&gt; <br class="title-page-name"/>);
</pre>
<p class="calibre2">We've just added second route using the react-router's config. It uses <kbd class="calibre11">DashboardView</kbd> component located in <kbd class="calibre11">../views/DashboardView</kbd> file.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Finishing the login's mechanism</h1>
            

            <article>
                
<p class="calibre2">The last improvements for login at this point of our publishing app remain at the <kbd class="calibre11">src/views/LoginView.js</kbd> location:</p>
<p class="calibre2">First of all, let's add handling an invalid login:</p>
<pre class="calibre22">
console.info('tokenRes', tokenRes); <br class="title-page-name"/><br class="title-page-name"/>if(tokenRes === 'INVALID') { <br class="title-page-name"/>    const errorRes = await falcorModel.getValue('login.error'); <br class="title-page-name"/>    this.setState({error: errorRes}); <br class="title-page-name"/>    return; <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>return;
</pre>
<p class="calibre2">We have added this <kbd class="calibre11">if(tokenRes === 'INVALID')</kbd> in order to update the error state with <kbd class="calibre11">this.setState({error: errorRes})</kbd>.</p>
<p class="calibre2">The next step is to add into the <kbd class="calibre11">render</kbd> function <kbd class="calibre11">Snackbar</kbd> that will show to the user a type of error. At the top of the <kbd class="calibre11">LoginView</kbd> component add this import:</p>
<pre class="calibre22">
import { Snackbar } from 'material-ui';
</pre>
<p class="calibre2">Then you need to update the <kbd class="calibre11">render</kbd> function as follows:</p>
<pre class="calibre22">
&lt;Snackbar <br class="title-page-name"/>  autoHideDuration={4000} <br class="title-page-name"/>  open={!!this.state.error} <br class="title-page-name"/>  message={this.state.error || ''}  <br class="title-page-name"/>  onRequestClose={() =&gt; null} /&gt;
</pre>
<p class="calibre2">So after adding it, the <kbd class="calibre11">render</kbd> function will look like this:</p>
<pre class="calibre22">
render () { <br class="title-page-name"/>  return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Login view&lt;/h1&gt; <br class="title-page-name"/>&lt;div style={{maxWidth: 450, margin: '0 auto'}}&gt; <br class="title-page-name"/>&lt;LoginForm <br class="title-page-name"/>onSubmit={this.login} /&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>&lt;Snackbar autoHideDuration={4000} <br class="title-page-name"/>          open={!!this.state.error} <br class="title-page-name"/>          message={this.state.error || ''}  <br class="title-page-name"/>onRequestClose={() =&gt; null} /&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>  ); <br class="title-page-name"/>}
</pre>
<p class="calibre2">The <kbd class="calibre11">SnackBar onRequestClose</kbd> is required here otherwise you will get a warning in the developer's console from the Material UI. Okay, so we are handling login's error, now let's work on successful logins.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Handling successful logins in the LoginView's component</h1>
            

            <article>
                
<p class="calibre2">For handling a successful token's backend responses add the login function:</p>
<pre class="calibre22">
if(tokenRes === 'INVALID') { <br class="title-page-name"/>const errorRes = await falcorModel.getValue('login.error'); <br class="title-page-name"/>this.setState({error: errorRes}); <br class="title-page-name"/>      return; <br class="title-page-name"/>    }
</pre>
<p class="calibre2">A new code for handling correct responses, as follows:</p>
<pre class="calibre22">
if(tokenRes) { <br class="title-page-name"/>const username = await falcorModel.getValue('login.username'); <br class="title-page-name"/>const role = await falcorModel.getValue('login.role'); <br class="title-page-name"/><br class="title-page-name"/>localStorage.setItem('token', tokenRes); <br class="title-page-name"/>localStorage.setItem('username', username); <br class="title-page-name"/>localStorage.setItem('role', role); <br class="title-page-name"/><br class="title-page-name"/>this.props.history.pushState(null, '/dashboard'); <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">After we know that the <kbd class="calibre11">tokenRes</kbd> is not <kbd class="calibre11">INVALID</kbd> and it's not undefined (otherwise shows a fatal error to the user), then we follow certain steps:</p>
<p class="calibre2">We are fetching the username from the Falcor's model <kbd class="calibre11">(await falcorModel.getValue('login.username'))</kbd>. We are fetching the user's role <kbd class="calibre11">(await falcorModel.getValue('login.role'))</kbd>. Then we save all the known variables from the backend into <kbd class="calibre11">localStoragewith</kbd>:</p>
<pre class="calibre22">
localStorage.setItem('token', tokenRes); <br class="title-page-name"/>localStorage.setItem('username', username); <br class="title-page-name"/>localStorage.setItem('role', role);
</pre>
<p class="calibre2">At the same end we are sending our user to the <kbd class="calibre11">/dashboard</kbd> route with the use of <kbd class="calibre11">this.props.history.pushState(null, '/dashboard')</kbd>.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">A few important notes about DashboardView and security</h1>
            

            <article>
                
<p class="calibre2">At this point, we won't secure <kbd class="calibre11">DashboardView</kbd> as there isn't any important stuff to secure---we will do it later when we put more assets/features into this route, which at the end of our book will be an editor's dashboard that will give control over all articles in the system.</p>
<p class="calibre2">The only remaining step for us is to make it a <kbd class="calibre11">RegistrationView</kbd> component. This route will also be available for everyone at this point. Later in the book, we will make a mechanism so that only the main admin will be able to add new editors into the system (and manage them).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Starting work on the new editor's registration</h1>
            

            <article>
                
<p class="calibre2">In order to wrap up the registration, let's first make some changes in our user's scheme from Mongoose's config file at the location <kbd class="calibre11">server/configMongoose.js</kbd>:</p>
<pre class="calibre22">
const userSchema = { <br class="title-page-name"/>'username' : String, <br class="title-page-name"/>'password' : String, <br class="title-page-name"/>'firstName' : String, <br class="title-page-name"/>'lastName' : String, <br class="title-page-name"/>'email' : String, <br class="title-page-name"/>'role' : String, <br class="title-page-name"/>'verified' : Boolean, <br class="title-page-name"/>'imageUrl' : String <br class="title-page-name"/>};
</pre>
<p class="calibre2">To the new scheme as follows:</p>
<pre class="calibre22">
const userSchema = { <br class="title-page-name"/>'username' : { type: String, index: {unique: true, dropDups: true }}, <br class="title-page-name"/>'password' : String, <br class="title-page-name"/>'firstName' : String, <br class="title-page-name"/>'lastName' : String, <br class="title-page-name"/>'email' : { type: String, index: {unique: true, dropDups: true }}, <br class="title-page-name"/>'role' : { type: String, default: 'editor' }, <br class="title-page-name"/>'verified' : Boolean, <br class="title-page-name"/>'imageUrl' : String <br class="title-page-name"/>};
</pre>
<p class="calibre2">As you can see, we have added unique indexes to the <kbd class="calibre11">username</kbd> and the <kbd class="calibre11">email</kbd> fields. Also, we have added a default value for a role, as any next user in our collection will be an editor (not an admin).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Adding register's falcor-route</h1>
            

            <article>
                
<p class="calibre2">In the file located at <kbd class="calibre11">server/routesSession.js</kbd>, you need to add a new route (next to the login's route):</p>
<pre class="calibre22">
 {  <br class="title-page-name"/>    route: ['register'], <br class="title-page-name"/>    call: (callPath, args) =&gt; <br class="title-page-name"/>      { <br class="title-page-name"/>        const newUserObj = args[0]; <br class="title-page-name"/>        newUserObj.password = newUserObj.password+'pubApp'; <br class="title-page-name"/>        newUserObj.password = crypto <br class="title-page-name"/>          .createHash('sha256') <br class="title-page-name"/>          .update(newUserObj.password) <br class="title-page-name"/>          .digest('hex'); <br class="title-page-name"/>          const newUser = new User(newUserObj); <br class="title-page-name"/>          return newUser.save((err, data) =&gt; { if (err) return err; }) <br class="title-page-name"/>          .then ((newRes) =&gt; { <br class="title-page-name"/>            /* <br class="title-page-name"/>              got new obj data, now let's get count: <br class="title-page-name"/>             */ <br class="title-page-name"/>             const newUserDetail = newRes.toObject(); <br class="title-page-name"/><br class="title-page-name"/>            if(newUserDetail._id) { <br class="title-page-name"/>              return null; // Mocked for now <br class="title-page-name"/>            } else { <br class="title-page-name"/>              // registration failed <br class="title-page-name"/>              return [ <br class="title-page-name"/>                { <br class="title-page-name"/>                  path: ['register', 'newUserId'],  <br class="title-page-name"/>                  value: 'INVALID' <br class="title-page-name"/>                }, <br class="title-page-name"/>                { <br class="title-page-name"/>                  path: ['register', 'error'],  <br class="title-page-name"/>                  value: 'Registration failed - no id has been                                  <br class="title-page-name"/>                  created' <br class="title-page-name"/>                } <br class="title-page-name"/>              ]; <br class="title-page-name"/>            } <br class="title-page-name"/>            return; <br class="title-page-name"/>          }).catch((reason) =&gt;console.error(reason)); <br class="title-page-name"/>      } <br class="title-page-name"/>  }
</pre>
<p class="calibre2">What this code is actually doing is simply receiving the new user's object from the frontend via <kbd class="calibre11">const newUserObj = args[0]</kbd>.</p>
<p class="calibre2">Then we are salting the password that we will store in our database:</p>
<pre class="calibre22">
newUserObj.password = newUserObj.password+'pubApp'; <br class="title-page-name"/>newUserObj.password = crypto <br class="title-page-name"/>  .createHash('sha256') <br class="title-page-name"/>  .update(newUserObj.password) <br class="title-page-name"/>  .digest('hex');
</pre>
<p class="calibre2">Then we are creating a new user model from Mongoose via <kbd class="calibre11">const newUser = new User(newUserObj)</kbd>, because the <kbd class="calibre11">newUser</kbd> variable is a new model (not saved yet) of the user. <a class="calibre6">Next we need to save it with this code:</a></p>
<pre class="calibre22">
return newUser.save((err, data) =&gt; { if (err) return err; })
</pre>
<p class="calibre2">After it's saved into the db and the Promise has been resolved, we are managing an invalid entry to the db first by making the Mongoose result's object into a simple JSON structure with <kbd class="calibre11">const newUserDetail = newRes.toObject();</kbd>.</p>
<p class="calibre2">And after we are done with it, then we are returning an <kbd class="calibre11">INVALID</kbd> information to the Falcor's model:</p>
<pre class="calibre22">
 // registration failed <br class="title-page-name"/>    return [ <br class="title-page-name"/>      { <br class="title-page-name"/>        path: ['register', 'newUserId'],  <br class="title-page-name"/>        value: 'INVALID' <br class="title-page-name"/>      }, <br class="title-page-name"/>      { <br class="title-page-name"/>        path: ['register', 'error'],  <br class="title-page-name"/>        value: 'Registration failed - no id has been created' <br class="title-page-name"/>      }
</pre>
<p class="calibre2">So, we are done with handling an invalid user registration from Falcor. The next step is to replace this:</p>
<pre class="calibre22">
// you shall already have this in your codebase, just a recall <br class="title-page-name"/>if(newUserDetail._id) { <br class="title-page-name"/>  return null; // Mocked for now <br class="title-page-name"/>} <br class="title-page-name"/>The preceding code needs to be replaced with: <br class="title-page-name"/>if(newUserDetail._id) { <br class="title-page-name"/>const newUserId = newUserDetail._id.toString(); <br class="title-page-name"/><br class="title-page-name"/>  return [ <br class="title-page-name"/>    { <br class="title-page-name"/>      path: ['register', 'newUserId'],  <br class="title-page-name"/>      value: newUserId <br class="title-page-name"/>    }, <br class="title-page-name"/>    { <br class="title-page-name"/>      path: ['register', 'error'],  <br class="title-page-name"/>      value: false  <br class="title-page-name"/>    } <br class="title-page-name"/>  ]; <br class="title-page-name"/>}
</pre>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Explanation</h1>
            

            <article>
                
<p class="calibre2">We need to cast our new user's ID into the string, <kbd class="calibre11">newUserId = newUserDetail._id.toString()</kbd> (otherwise it will break the code).</p>
<p class="calibre2">As you can see, we have a standard return statement that complements the model in Falcor.</p>
<p class="calibre2">To quickly recall, after it returns correctly on the backend, we will be able to request this value on the frontend as follows: <kbd class="calibre11">const newUserId = await falcorModel.getValue(['register', 'newUserId']);</kbd> (this is just an example of how to fetch this new <kbd class="calibre11">UserId</kbd> on the client-side--don't write it into your code, we will do it in a minute).</p>
<p class="calibre2">You will get used to it after few more examples.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Frontend implementation (RegisterView and RegisterForm)</h1>
            

            <article>
                
<p class="calibre2">Let's first create a component that will manage on the frontend, the register's form with the following actions:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd <br class="title-page-name"/>$ [[[you shall be at the components folder]]] <br class="title-page-name"/>$ touch RegisterForm.js <br class="title-page-name"/></strong>
</pre>
<p class="calibre2">The content of that file will be:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import Formsy from 'formsy-react'; <br class="title-page-name"/>import {RaisedButton, Paper} from 'material-ui'; <br class="title-page-name"/>import DefaultInput from './DefaultInput'; <br class="title-page-name"/><br class="title-page-name"/>export class RegisterForm extends React.Component { <br class="title-page-name"/>  constructor() { <br class="title-page-name"/>    super(); <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  render() { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;Formsy.FormonSubmit={this.props.onSubmit}&gt; <br class="title-page-name"/>&lt;Paper zDepth={1} style={{padding: 32}}&gt; <br class="title-page-name"/>&lt;h3&gt;Registration form&lt;/h3&gt; <br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>  onChange={(event) =&gt; {}}  <br class="title-page-name"/>  name='username' <br class="title-page-name"/>  title='Username' <br class="title-page-name"/>  required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>  onChange={(event) =&gt; {}}  <br class="title-page-name"/>  name='firstName' <br class="title-page-name"/>  title='Firstname' <br class="title-page-name"/>  required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>  onChange={(event) =&gt; {}}  <br class="title-page-name"/>  name='lastName' <br class="title-page-name"/>  title='Lastname' <br class="title-page-name"/>  required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>  onChange={(event) =&gt; {}}  <br class="title-page-name"/>  name='email' <br class="title-page-name"/>  title='Email' <br class="title-page-name"/>  required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;DefaultInput <br class="title-page-name"/>  onChange={(event) =&gt; {}}  <br class="title-page-name"/>  type='password' <br class="title-page-name"/>  name='password' <br class="title-page-name"/>  title='Password' <br class="title-page-name"/>  required /&gt; <br class="title-page-name"/><br class="title-page-name"/>&lt;div style={{marginTop: 24}}&gt; <br class="title-page-name"/>&lt;RaisedButton <br class="title-page-name"/>              secondary={true} <br class="title-page-name"/>              type="submit" <br class="title-page-name"/>              style={{margin: '0 auto', display:                      <br class="title-page-name"/>              'block', width: 150}} <br class="title-page-name"/>              label={'Register'} /&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>&lt;/Paper&gt; <br class="title-page-name"/>&lt;/Formsy.Form&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>}
</pre>
<p class="calibre2">The preceding registration component is creating a form exactly the same way as on <kbd class="calibre11">LoginForm</kbd>. After a user clicks the <kbd class="calibre11">Register</kbd> button, it sends a callback to the <kbd class="calibre11">src/views/RegisterView.js</kbd> component (we will create this in a moment).</p>
<p class="calibre2">Remember that in the components' directory we keep only DUMB components so all the communication with the rest of the app must to be done via callbacks like in this example.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">RegisterView</h1>
            

            <article>
                
<p class="calibre2">Let's create a <kbd class="calibre11">RegisterView</kbd> file:</p>
<pre class="calibre22">
<strong class="calibre1">$ pwd </strong><br class="title-page-name"/><strong class="calibre1">$ [[[you shall be at the views folder]]] </strong><br class="title-page-name"/><strong class="calibre1">$ touch RegisterView.js</strong>
</pre>
<p class="calibre2">Its content is:</p>
<pre class="calibre22">
import React from 'react'; <br class="title-page-name"/>import falcorModel from '../falcorModel.js'; <br class="title-page-name"/>import { connect } from 'react-redux'; <br class="title-page-name"/>import { bindActionCreators } from 'redux'; <br class="title-page-name"/>import { Snackbar } from 'material-ui'; <br class="title-page-name"/>import { RegisterForm } from '../components/RegisterForm.js'; <br class="title-page-name"/><br class="title-page-name"/>const mapStateToProps = (state) =&gt; ({  <br class="title-page-name"/>  ...state  <br class="title-page-name"/>}); <br class="title-page-name"/>const mapDispatchToProps = (dispatch) =&gt; ({});
</pre>
<p class="calibre2">These are standard things that we use in our smart components (we need <kbd class="calibre11">falcorModel</kbd> in order to communicate with the backend and <kbd class="calibre11">mapStateToProps</kbd> and <kbd class="calibre11">mapDispatchToProps</kbd> in order to communicate with our Redux's store/reducer).</p>
<p class="calibre2">Okay, that's not all for the register view; next let's add a component:</p>
<pre class="calibre22">
const mapDispatchToProps = (dispatch) =&gt; ({}); <br class="title-page-name"/><br class="title-page-name"/>class RegisterView extends React.Component { <br class="title-page-name"/>  constructor(props) { <br class="title-page-name"/>    super(props); <br class="title-page-name"/>    this.register = this.register.bind(this); <br class="title-page-name"/>    this.state = { <br class="title-page-name"/>      error: null <br class="title-page-name"/>    }; <br class="title-page-name"/>  } <br class="title-page-name"/><br class="title-page-name"/>  render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;h1&gt;Register&lt;/h1&gt; <br class="title-page-name"/>&lt;div style={{maxWidth: 450, margin: '0 auto'}}&gt; <br class="title-page-name"/>&lt;RegisterForm <br class="title-page-name"/>onSubmit={this.register} /&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/>export default connect(mapStateToProps, mapDispatchToProps)(RegisterView);
</pre>
<p class="calibre2">As you can see in the preceding code snippet, we are missing the <kbd class="calibre11">register</kbd> function, so between the <kbd class="calibre11">constructor</kbd> and the <kbd class="calibre11">render</kbd> function add the function, as follows:</p>
<pre class="calibre22">
async register (newUserModel) {console.info("newUserModel",  newUserModel); <br class="title-page-name"/><br class="title-page-name"/>    await falcorModel <br class="title-page-name"/>      .call(['register'],[newUserModel]) <br class="title-page-name"/>      .then((result) =&gt;result); <br class="title-page-name"/><br class="title-page-name"/>      const newUserId = await falcorModel.getValue(['register',  <br class="title-page-name"/>      'newUserId']); <br class="title-page-name"/><br class="title-page-name"/>    if(newUserId === 'INVALID') { <br class="title-page-name"/>      const errorRes = await falcorModel.getValue('register.error'); <br class="title-page-name"/><br class="title-page-name"/>      this.setState({error: errorRes}); <br class="title-page-name"/>      return; <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    this.props.history.pushState(null, '/login'); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">As you can see, the <kbd class="calibre11">async register (newUserModel)</kbd> function is asynchronous and friendly to the awaits. Next we are just logging into the console what a user has submitted with <kbd class="calibre11">console.info("newUserModel", newUserModel)</kbd>. After that, we query the falcor-router with a call:</p>
<pre class="calibre22">
await falcorModel <br class="title-page-name"/>      .call(['register'],[newUserModel]) <br class="title-page-name"/>      .then((result) =&gt; result);
</pre>
<p class="calibre2">After we have called the router, we fetch the response with:</p>
<pre class="calibre22">
const newUserId = await falcorModel.getValue(['register', 'newUserId']);
</pre>
<p class="calibre2">Depending on the response from the backend, we do the following:</p>
<ul class="calibre14">
<li class="calibre15">For <kbd class="calibre11">INVALID</kbd> we are fetching and setting error message into the component's state (<kbd class="calibre11">this.setState({error: errorRes}))</kbd></li>
<li class="calibre15">If the user has registered correctly, then we have their new ID and we are asking the user to login with the history's push state <kbd class="calibre11">(this.props.history.pushState(null, '/login');)</kbd></li>
</ul>
<p class="calibre2">We didn't create a route inside <kbd class="calibre11">routes/index.js</kbd> for <kbd class="calibre11">RegisterView</kbd> and there is no link in <kbd class="calibre11">CoreLayout</kbd> so our user is unable to use it. Add new imports in <kbd class="calibre11">routes/index.js</kbd>:</p>
<pre class="calibre22">
import RegisterView from '../views/RegisterView';
</pre>
<p class="calibre2">Then add a route, so the export default from <kbd class="calibre11">routes/index.js</kbd> will look like this:</p>
<pre class="calibre22">
export default ( <br class="title-page-name"/>&lt;Route component={CoreLayout} path='/'&gt; <br class="title-page-name"/>&lt;IndexRoute component={PublishingApp} name='home' /&gt; <br class="title-page-name"/>&lt;Route component={LoginView} path='login' name='login' /&gt; <br class="title-page-name"/>&lt;Route component={DashboardView} path='dashboard'  name='dashboard' /&gt; <br class="title-page-name"/>&lt;Route component={RegisterView} path='register' name='register' /&gt; <br class="title-page-name"/>&lt;/Route&gt; <br class="title-page-name"/>);
</pre>
<p class="calibre2">And finally, add a link inside the <kbd class="calibre11">src/layoutsCoreLayout.js</kbd> file's <kbd class="calibre11">render</kbd> method:</p>
<pre class="calibre22">
render () { <br class="title-page-name"/>    return ( <br class="title-page-name"/>&lt;div&gt; <br class="title-page-name"/>&lt;span&gt; <br class="title-page-name"/>   Links:<a class="calibre25">&lt;Link to='/register'&gt;Register&lt;/Link&gt;</a> <br class="title-page-name"/>  &lt;Link to='/login'&gt;Login&lt;/Link&gt; <br class="title-page-name"/>  &lt;Link to='/'&gt;Home Page&lt;/Link&gt; <br class="title-page-name"/>&lt;/span&gt; <br class="title-page-name"/>  &lt;br/&gt; <br class="title-page-name"/> {this.props.children} <br class="title-page-name"/>&lt;/div&gt; <br class="title-page-name"/>    ); <br class="title-page-name"/>  }
</pre>
<p class="calibre2">At this point ,we should be able to register with this form:</p>
<div class="packt_figure"><img class="image-border21" src="../images/00026.jpeg"/></div>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In the next chapter, we will start working on the server-side rendering of our app. This means that on each request to our Express's server, we will generate the HTML markup based on the request from the client side. That feature is very useful for apps like ours where the speed of web loading is very important for such users as ours.</p>
<p class="calibre2">You can imagine that most of the news sites are for entertainment and that means a short attention span from our potential users. The speed of loading is important. There are also some opinions that the server-side rendering also helps for search engine optimization reasons.</p>
<p class="calibre2">The crawlers have easier ways to <em class="calibre21">read</em> the text from our article as they don't need to execute the JavaScript in order to fetch it from the server (in comparison to non-server-side rendering single-page apps).</p>
<p class="calibre2">At least one thing is certain: if you have a server-side rendering on your articles' publishing app then Google may see that you care about the fast loading of your app and so it will probably give you some disadvantage over full single-page websites that don't care about server-side rendering.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>