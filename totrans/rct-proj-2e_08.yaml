- en: '*Chapter 8*: Building an Animated Game Using React Native and Expo'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用React Native和Expo构建动画游戏'
- en: One of the taglines for development with React is *"learn once, write anywhere,"*
    which is due to the existence of React Native. With React Native, you can write
    native mobile applications using JavaScript and React, and easily run and deploy
    these applications using a toolchain called **Expo**. The previous applications
    created in this book were all web applications, meaning that they will run in
    a browser. A downside of running applications in a browser is the lack of interaction
    when you click on a button or navigate to a different page. When building a mobile
    application that runs directly on a mobile phone, your users expect animations
    and gestures that make using the application easy and familiar. This is something
    that you'll focus on in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React开发的口号之一是*"一次学习，到处编写"，"这得益于React Native的存在。使用React Native，您可以使用JavaScript和React编写原生移动应用程序，并使用名为**Expo**的工具链轻松运行和部署这些应用程序。本书中创建的先前应用程序都是Web应用程序，这意味着它们将在浏览器中运行。在浏览器中运行应用程序的缺点是在您点击按钮或导航到不同页面时缺乏交互。当构建直接在手机上运行的移动应用程序时，您的用户期望有使应用程序使用起来容易且熟悉的动画和手势。这就是您在本章中要关注的内容。
- en: In this chapter, you'll create a React Native application with add animations
    and gestures using the Animated API from React Native, a package called `GestureHandler`.
    Together, they make it possible for us to create applications that make the best
    use of a mobile's interaction methods, which is perfect for a game such as the
    *Higher/Lower* game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将创建一个React Native应用程序，使用React Native的Animated API和一个名为`GestureHandler`的包添加动画和手势。它们一起使我们能够创建充分利用移动设备交互方法的应用程序，这对于像*高/低*这样的游戏来说非常完美。
- en: 'To create this game, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个游戏，以下主题将被涵盖：
- en: Setting up React Native with Expo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Expo设置React Native
- en: Adding gestures and animations to React Native
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向React Native添加手势和动画
- en: Advanced animations with Lottie
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lottie的高级动画
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will be creating an animated *Higher/Lower* game build with
    React Native and Expo, which uses the Animated API to add basic animations, Lottie
    for advanced animations, and `GestureHandler` from Expo to handle native gestures.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用React Native和Expo创建一个动画*高/低*游戏，它使用Animated API添加基本动画，Lottie进行高级动画，以及来自Expo的`GestureHandler`来处理原生手势。
- en: The build time is 1.5 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为1.5小时。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter is using React Native version 0.64.3 and Expo SDK version 44\.
    As React Native and Expo are updated frequently, make sure that you're working
    with this version to ensure the patterns described in this chapter are behaving
    as expected.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用React Native版本0.64.3和Expo SDK版本44。由于React Native和Expo更新频繁，请确保您使用的是这个版本，以确保本章中描述的模式按预期运行。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The complete source code for the project we build in this chapter can be found
    on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08).
    Also, the `winner.json` file that is needed in the final section of this chapter
    can be found at [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08-assets](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08-assets).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们构建的项目完整源代码可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08)。此外，本章最后部分所需的`winner.json`文件可以在[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08-assets](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter08-assets)找到。
- en: You need to have the Expo Go application installed on a mobile iOS or Android
    device to run the project on a physical device. Once you've downloaded the application,
    you need to create an Expo account to make the development process smoother. Make
    sure to store your account details somewhere safe, as you will need these later
    on in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在iOS或Android移动设备上安装Expo Go应用程序，以便在物理设备上运行项目。一旦您下载了应用程序，您需要创建一个Expo账户以使开发过程更加顺畅。请确保将您的账户详细信息保存在安全的地方，因为您在本章的后续部分需要使用这些信息。
- en: 'Alternatively, you can install either Xcode or Android Studio on your computer
    to run the application on a virtual device:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在计算机上安装Xcode或Android Studio来在虚拟设备上运行应用程序：
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/workflow/ios-simulator/](https://docs.expo.io/workflow/ios-simulator/).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 iOS**：有关如何设置本地机器以运行 iOS 模拟器的信息，请在此处查看：[https://docs.expo.io/workflow/ios-simulator/](https://docs.expo.io/workflow/ios-simulator/).'
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/workflow/android-studio-emulator/](https://docs.expo.io/workflow/android-studio-emulator/).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于 Android**：有关如何设置本地机器以从 Android Studio 运行模拟器的信息，请在此处查看：[https://docs.expo.io/workflow/android-studio-emulator/](https://docs.expo.io/workflow/android-studio-emulator/).'
- en: Note
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It's *highly recommended* to use the Expo Client application to run the project
    from this chapter on a physical device. Receiving notifications is currently only
    supported on physical devices, and running the project on either the iOS simulator
    or Android Studio emulator will result in error messages.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**强烈推荐**使用 Expo 客户端应用程序从本章开始在一个物理设备上运行项目。目前，仅支持在物理设备上接收通知，在 iOS 模拟器或 Android
    Studio 模拟器上运行项目将导致错误信息。'
- en: Creating an animated game application with React Native and Expo
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Native 和 Expo 创建一个动画游戏应用程序
- en: In this section, you'll build an animated game with React Native and Expo that
    runs directly on a mobile device. React Native allows you to use the same syntax
    and patterns you already know from React, as it's using the core React library.
    Also, Expo makes it possible to prevent having to install and configure Xcode
    (for iOS) or Android Studio to start creating native applications on your machine.
    Therefore, you can write applications for both the iOS and Android platforms from
    any machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用 React Native 和 Expo 构建一个在移动设备上直接运行的动画游戏。React Native 允许您使用您已经从 React
    熟悉的相同语法和模式，因为它使用核心 React 库。此外，Expo 使得您无需安装和配置 Xcode（对于 iOS）或 Android Studio 即可开始在您的机器上创建原生应用程序。因此，您可以从任何机器上为
    iOS 和 Android 平台编写应用程序。
- en: Expo combines both React APIs and JavaScript APIs to the React Native development
    process, such as JSX components, Hooks, and native features such as camera access.
    Briefly, the Expo toolchain consists of multiple tools that help you with React
    Native, such as the Expo CLI, which allows you to create React Native projects
    from your terminal, with all the dependencies that you need to run React Native.
    With the Expo client, you can open these projects from iOS and Android mobile
    devices that are connected to your local network, and Expo SDK is a package that
    contains all the libraries that make it possible to run your application on multiple
    devices and platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Expo 将 React API 和 JavaScript API 结合到 React Native 开发过程中，例如 JSX 组件、Hooks 以及如相机访问等原生功能。简而言之，Expo
    工具链由多个工具组成，这些工具可以帮助您使用 React Native，例如 Expo CLI，它允许您从终端创建 React Native 项目，并包含运行
    React Native 所需的所有依赖项。使用 Expo 客户端，您可以从连接到本地网络的 iOS 和 Android 移动设备上打开这些项目，而 Expo
    SDK 是一个包含所有库的包，使得您的应用程序能够在多个设备和平台上运行。
- en: Setting up React Native with Expo
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Expo 设置 React Native
- en: Applications that we previously created in this book used Create React App or
    Next.js to set up a starter application. For React Native, a similar boilerplate
    is available, which is part of the Expo CLI and can be set up just as easily.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中之前创建的应用程序使用了 Create React App 或 Next.js 来设置起始应用程序。对于 React Native，有一个类似的样板代码可用，它是
    Expo CLI 的一部分，可以同样轻松地设置。
- en: 'You need to globally install the Expo CLI with the following command, using
    `Yarn`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用以下命令全局安装 Expo CLI，使用 `Yarn`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can use `npm`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `npm`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Expo is using Yarn as its default package manager, but you can still use it
    with npm instead as weve done in the previous React chapters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Expo 使用 Yarn 作为其默认的包管理器，但您仍然可以使用 npm，就像我们在之前的 React 章节中所做的那样。
- en: 'This will start the installation process, which can take some time, as it will
    install the Expo CLI with all its dependencies to help you develop mobile applications.
    After that, you will be able to create a new project using the `init` command
    from the Expo CLI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动安装过程，这可能需要一些时间，因为它将安装带有所有依赖项的 Expo CLI，以帮助您开发移动应用程序。之后，您将能够使用 Expo CLI 的
    `init` 命令创建一个新项目：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Expo will now create the project for you, but before that, it will ask you whether
    you want to create just a blank template, a blank template with TypeScript configuration,
    or a sample template with some example screens set up. For this chapter, you'll
    need to choose the first option. Expo automatically detects whether you have Yarn
    installed on your machine; if so, it will use Yarn to install the other dependencies
    that are needed to set up your computer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Expo将为您创建项目，但在那之前，它会询问您是想创建一个空白模板、带有TypeScript配置的空白模板，还是带有一些示例屏幕的样本模板。对于本章，您需要选择第一个选项。Expo会自动检测您的机器上是否已安装Yarn；如果是，它将使用Yarn安装设置计算机所需的其它依赖项。
- en: 'Your application will now be created, using the setting you''ve previously
    selected. This application can now be started by moving into the directory that
    was just created by Expo, using the following commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在将根据您之前选择的设置创建。您现在可以通过进入Expo刚刚创建的目录，使用以下命令启动此应用程序：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will start Expo and give you the ability to start your project from both
    the terminal and your browser. In the terminal, you will now see a QR code, which
    you can scan with the Expo application from your mobile device, or you can start
    either the iOS or Android emulator if you have Xcode or Android studio installed.
    Also, *Expo DevTools* will be opened in your browser after running the `start`
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Expo，并允许您从终端和浏览器启动您的项目。在终端中，您现在将看到一个QR码，您可以使用移动设备上的Expo应用程序扫描，或者如果您已安装Xcode或Android
    Studio，您还可以启动iOS或Android模拟器。此外，在运行`start`命令后，*Expo DevTools*将在您的浏览器中打开：
- en: '![Figure 8.1 – Expo DevTools when running Expo'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 运行Expo时的Expo DevTools截图](img/Figure_8.01_B17390.jpg)'
- en: '](img/Figure_8.01_B17390.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.01 – Expo DevTools运行时的截图](img/Figure_8.01_B17390.jpg)'
- en: Figure 8.1 – Expo DevTools when running Expo
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 运行Expo时的Expo DevTools
- en: On this page, you will see a sidebar on the left and the logs from your React
    Native application on the right. If you're using an Android device, you can scan
    the QR code directly from the Expo Go application. On iOS, you need to use your
    camera to scan the code, which will ask you to open the Expo client. Alternatively,
    the sidebar in Expo DevTools has buttons to start the iOS or Android emulator,
    for which you need to have either Xcode installed or Android Studio installed.
    Otherwise, you can also find a button to send a link to the application by email.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，您将在左侧看到一个侧边栏，以及您的React Native应用程序的日志在右侧。如果您使用的是Android设备，您可以直接从Expo Go应用程序扫描QR码。在iOS上，您需要使用相机扫描代码，这将要求您打开Expo客户端。或者，Expo
    DevTools中的侧边栏有按钮可以启动iOS或Android模拟器，您需要安装Xcode或Android Studio。否则，您还可以找到按钮通过电子邮件发送应用程序链接。
- en: It doesn't matter whether you've opened the application using the emulator for
    iOS or Android, or from an iOS or Android device; the application at this point
    should be a white screen displaying **Open up App.js to start working on your
    app!**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用iOS或Android模拟器打开的应用程序，还是从iOS或Android设备打开，此时应用程序应该是一个显示**打开App.js以开始您的应用程序开发**的白色屏幕。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't see the application, but a red screen displaying an error, you
    should make sure that you're running the correct version of React Native and Expo
    on your local machine and mobile device. These versions should be React Native
    version 0.64.3 and Expo version 44\. Using any other version can lead to errors,
    as the versions for React Native and Expo should be in sync.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到应用程序，而是显示错误信息的红色屏幕，您应该确保您在本地机器和移动设备上运行的是正确的React Native和Expo版本。这些版本应该是React
    Native版本0.64.3和Expo版本44。使用任何其他版本都可能导致错误，因为React Native和Expo的版本应该保持同步。
- en: 'The project structure from this React Native application created with Expo
    is quite similar to the React projects you''ve created in the previous chapters:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Expo创建的此React Native应用程序的项目结构与您在前几章中创建的React项目非常相似：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `assets` directory, you can find the images that are used as the application
    icon on the home screen once you've installed this application on your mobile
    device and the image that will serve as the splash screen, which is displayed
    when you start the application. The `App.js` file is the actual entry point of
    your application, where you'll put code that will be rendered when the application
    mounts. Configurations for your application – for example, the App Store – are
    placed in `app.json`, while `babel.config.js` holds specific Babel configurations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`assets`目录中，一旦你在移动设备上安装了此应用程序，你就可以找到用作主屏幕应用程序图标的图像，以及将作为启动屏幕使用的图像，该屏幕在启动应用程序时显示。`App.js`文件是应用程序的实际入口点，你将在这里放置在应用程序挂载时将被渲染的代码。应用程序的配置（例如，应用商店）放置在`app.json`中，而`babel.config.js`包含特定的Babel配置。
- en: Adding basic routing
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加基本路由
- en: 'For web applications created with React, we''ve used React Router for navigation,
    while with Next.js, the routing was already built in using the filesystem. For
    React Native, we''ll need a different routing library that supports both iOS and
    Android. The most popular library for this is `react-navigation`, which we can
    install from `Yarn`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用React创建的Web应用程序，我们使用了React Router进行导航，而对于Next.js，路由已经通过文件系统内置。对于React Native，我们需要一个支持iOS和Android的不同路由库。这个最受欢迎的库是`react-navigation`，我们可以从`Yarn`安装它：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will install the core library, but we need to extend our current Expo
    installation with dependencies that are needed for `react-navigation` by running
    the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装核心库，但我们需要通过运行以下命令来扩展我们当前的Expo安装，以包含`react-navigation`所需的依赖项：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To add routing to your React Native application, you will need to understand
    the difference between routing in a browser and a mobile application. History
    in React Native doesn't behave the same way as in a browser, where users can navigate
    to different pages by changing the URL in the browser and previously visited URLs
    are added to the browser history. Instead, you will need to keep track of transitions
    between pages yourself and store local history in your application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要将路由添加到你的React Native应用程序中，你需要了解浏览器和移动应用程序中路由的区别。React Native中的历史记录在行为上与浏览器不同，在浏览器中，用户可以通过更改浏览器中的URL来导航到不同的页面，并且之前访问过的URL会被添加到浏览器历史记录中。相反，你需要自己跟踪页面之间的转换并存储应用程序中的本地历史记录。
- en: 'With React Navigation, you can use multiple different navigators to help you
    do this, including a stack navigator and a tab navigator. The stack navigator
    behaves in a way that is very similar to a browser, as it stacks pages after transition
    on top of each other and lets you navigate using native gestures and animations
    for iOS and Android. Let''s get started:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Navigation，你可以使用多个不同的导航器来帮助你完成这项工作，包括栈导航器和标签导航器。栈导航器的行为非常类似于浏览器，因为它在过渡后将页面堆叠在一起，并允许你使用iOS和Android的原生手势和动画进行导航。让我们开始吧：
- en: 'First, we need to install the library to use stack navigation and an additional
    library with navigation elements from `react-navigation`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装这个库来使用栈导航以及来自`react-navigation`的带有导航元素的附加库：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From this library and the core library from `react-navigation`, we need to
    import the following to create a stack navigator in `App.js`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个库和`react-navigation`的核心库中，我们需要在`App.js`中导入以下内容来创建栈导航器：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From the `App` component, we need to return this stack navigator, which also
    needs a component to return to the home screen. Therefore, we need to create a
    `Home` component in a new directory called `screens`. This component can be created
    in a file called `Home.js` with the following content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`App`组件中，我们需要返回这个栈导航器，它还需要一个组件来返回主屏幕。因此，我们需要在名为`screens`的新目录中创建一个`Home`组件。这个组件可以在名为`Home.js`的文件中创建，内容如下：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `App.js`, we need to import this `Home` component and set up the stack navigator
    by returning a `NavigationContainer` component from the `App` component. Inside
    this component, the stack navigator is created by the `Navigator` component from
    the `Stack` component, and the home screen is described in a `Stack.Screen` component.
    Also, the status bar for the mobile device is defined here:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.js`中，我们需要导入这个`Home`组件，并通过从`App`组件返回一个`NavigationContainer`组件来设置栈导航器。在这个组件内部，栈导航器是通过`Stack`组件中的`Navigator`组件创建的，主屏幕在`Stack.Screen`组件中描述。此外，移动设备的状态栏也在这里定义：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Make sure that you still have Expo running from your terminal; otherwise, start
    it again with the yarn start command. The application on your mobile device or
    emulator should now look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您仍在终端中运行 Expo；否则，请使用`yarn start`命令重新启动。现在，您的移动设备或模拟器上的应用程序应该看起来像这样：
- en: '![Figure 8.2 – The application with a stack navigator'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 带有堆栈导航器的应用程序'
- en: '](img/Figure_8.02_B17390.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B17390.jpg)'
- en: Figure 8.2 – The application with a stack navigator
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 带有堆栈导航器的应用程序
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To reload the application in Expo Go, you can shake the device when you're using
    an iOS or Android phone. By shaking the device, a menu with an option to reload
    the application will appear. In this menu, you must also select to enable a *fast
    refresh* to refresh the application automatically when you make changes to the
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Expo Go 中重新加载应用程序时，您可以使用 iOS 或 Android 手机摇晃设备。通过摇晃设备，将出现一个菜单，其中包含重新加载应用程序的选项。在此菜单中，您还必须选择启用*快速刷新*，以便在您对代码进行更改时自动刷新应用程序。
- en: We've got our stack navigator with the first page set up, so let's add more
    pages and create buttons to navigate between them in the next part of this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了堆栈导航器的第一个页面，所以让我们在下一部分添加更多页面，并创建按钮在它们之间导航。
- en: Navigate between screens
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕之间导航
- en: Navigating between screens in React Native also works a bit differently than
    in the browser, as again there are no URLs. Instead, you need to use the navigation
    object that is available as a prop from components that are rendered by the stack
    navigator, or by calling the `useNavigation` Hook from `react-navigation`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中在屏幕之间导航的工作方式与在浏览器中略有不同，因为再次没有 URL。相反，您需要使用堆栈导航器渲染的组件可用的导航对象，或者通过从`react-navigation`调用`useNavigation`钩子。
- en: 'Before learning how to navigate between screens, we need to add another screen
    to navigate to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何在屏幕之间导航之前，我们需要添加另一个屏幕进行导航：
- en: 'This screen can be added by creating a new component in a file called `Game.js`
    in the `screens` directory with the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在`screens`目录下名为`Game.js`的文件中创建一个新的组件来添加此屏幕，代码如下：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This component must be imported in `App.js` and added as a new screen to the
    stack navigator. Also, on the navigator, we need to set the default screen that
    must be displayed by setting the `initialRouteName` prop:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此组件必须在`App.js`中导入，并作为新屏幕添加到堆栈导航器中。此外，在导航器上，我们需要设置`initialRouteName`属性来设置必须显示的默认屏幕：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the `Home` component in `screens/Home.js`, we can get the navigation object
    from the `useNavigation` Hook and create a button that will navigate to the `Game`
    screen when pressed. This is done by using the `navigate` method from the `navigation`
    object and passing it to the `onPress` prop of the `Button` component from React
    Native:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`screens/Home.js`中的`Home`组件，我们可以从`useNavigation`钩子中获取导航对象，并创建一个按钮，当按下时将导航到`Game`屏幕。这是通过使用`navigation`对象的`navigate`方法并将其传递给React
    Native的`Button`组件的`onPress`属性来完成的：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the application, you can now move between the **Home** and **Game** screen
    by using the button that we just created or by using the button in the header.
    This header is automatically generated by react-navigation, but you can also customize
    this, which we''ll do in [*Chapter 9*](B17390_09_Final_NM_ePub.xhtml#_idTextAnchor109),
    *Building a Full-Stack Social Media Application with React Native and Expo*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过使用我们刚刚创建的按钮或使用页眉中的按钮在**主页**和**游戏**屏幕之间进行切换。此页眉是由react-navigation自动生成的，但您也可以自定义它，我们将在[*第
    9 章*](B17390_09_Final_NM_ePub.xhtml#_idTextAnchor109)中这样做，*使用 React Native 和 Expo
    构建全栈社交媒体应用程序*：
- en: '![Figure 8.3 – Our application with basic routing](img/Figure_8.03_B17390.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 带有基本路由的我们的应用程序](img/Figure_8.03_B17390.jpg)'
- en: Figure 8.3 – Our application with basic routing
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 带有基本路由的我们的应用程序
- en: 'At this point, we''ve added basic routing to our application, but we don''t
    have a game yet. In the `screens/Game.js` file, the logic for the *Higher/Lower*
    game can be added by using local state management, using the `useState` and `useEffect`
    Hooks. These Hooks work the same in React Native as they do in a React web application.
    Let''s add the game logic:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向应用程序添加了基本路由，但我们还没有游戏。在`screens/Game.js`文件中，可以通过使用本地状态管理（使用`useState`和`useEffect`钩子）来添加*高/低*游戏的逻辑。这些钩子在React
    Native中的工作方式与在React网络应用程序中相同。让我们添加游戏逻辑：
- en: 'Import these Hooks from React in the Game component, next to the `Button` and
    `Alert` components from React Native. After importing them, we need to create
    a local state variable to store the user''s choice and create the randomized number
    and score for the game. Also, import the `useNavigation` Hook from `react-navigation`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Game` 组件中，从 React 导入这些钩子，在 `Button` 和 `Alert` 组件旁边。导入它们之后，我们需要创建一个本地状态变量来存储用户的选择，并为游戏创建随机数和分数。还要从
    `react-navigation` 中导入 `useNavigation` 钩子：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `baseNumber` value is the number that starts the game with an initial random
    value between 1 and 100, created with a `Math` method from JavaScript. The score
    value also has a random number as a value, and this value is used to compare with
    `baseNumber`. The `choice` local state variable is used to store the choice of
    the user if a score is either higher or lower than `baseNumber`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseNumber` 的值是游戏开始时带有 1 到 100 之间的初始随机值的数字，使用 JavaScript 中的 `Math` 方法创建。分数值也有一个随机数作为值，这个值用于与
    `baseNumber` 进行比较。`choice` 本地状态变量用于存储用户的选项，如果分数高于或低于 `baseNumber`。'
- en: 'To be able to make a choice, we need to add two `Button` components that set
    the value for a choice to be higher or lower, depending on which button you''ve
    pressed:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要能够做出选择，我们需要添加两个 `Button` 组件，根据你按下的哪个按钮设置选择值是更高或更低：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From an `useEffect` Hook, we can compare the values for `baseNumber` and `score`
    and, based on the value choice, show an alert. Depending on the choice, the user
    sees an `Alert` component displayed with a message saying whether they''ve won
    or not, and the score. Next to displaying the alert, the values for `baseNumber`,
    `score`, and `choice` the navigation object will be used to navigate back to the
    previous page. This will reset the `Game` component as well:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `useEffect` 钩子中，我们可以比较 `baseNumber` 和 `score` 的值，并根据值选择显示一个警告。根据选择，用户会看到一个显示消息说明他们是否获胜以及得分的
    `Alert` 组件。在显示警告的同时，将使用 `baseNumber`、`score` 和 `choice` 的值来导航回上一页。这将重置 `Game`
    组件：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You're now able to play the game and choose whether you think the score will
    be higher or lower than the displayed `baseNumber`. But we haven't added any styling
    yet, which we'll do in the next part of this section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够玩游戏并选择你认为分数是否会高于或低于显示的 `baseNumber`。但我们还没有添加任何样式，这将在本节下一部分完成。
- en: Styling in React Native
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: React Native 中的样式
- en: 'You might have seen in the previous components that we changed or added to
    the project that we used a variable called `StyleSheet`. Using this variable from
    React Native, we can create an object of styles, which we can attach to React
    Native components by passing it as a prop called `style`. We''ve already used
    this to style the components with a style called `container`, but let''s make
    some changes to also add styling to the other components:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在前面的组件中看到，我们更改或添加到项目中使用了名为 `StyleSheet` 的变量。使用这个变量从 React Native 中，我们可以创建一个样式对象，我们可以通过传递一个名为
    `style` 的属性将其附加到 React Native 组件上。我们已经使用它来使用名为 `container` 的样式来设置组件样式，但让我们做一些更改，也为其他组件添加样式：
- en: 'In `screens/Home.js`, we need to replace the `Button` component with a `TouchableHighlight`
    component, as `Button` components in React Native are hard to style. This `TouchableHighlight`
    component is an element that can be pressed, and it gives the user feedback by
    getting highlighted when pressed. Inside this component, a `Text` component must
    be added to display the label for the button:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `screens/Home.js` 中，我们需要将 `Button` 组件替换为 `TouchableHighlight` 组件，因为 React
    Native 中的 `Button` 组件难以设置样式。这个 `TouchableHighlight` 组件是一个可按的元素，当按下时会高亮显示，为用户提供反馈。在这个组件内部，必须添加一个
    `Text` 组件来显示按钮的标签：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `TouchableHighlight` and `Text` components use the `button` and `buttonText`
    styles from the `styles` object, which we need to add to the `create` method of
    `StyleSheet` at the bottom of the file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TouchableHighlight` 和 `Text` 组件使用 `styles` 对象中的 `button` 和 `buttonText` 样式，我们需要将其添加到文件底部的
    `StyleSheet` 的 `create` 方法中：'
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating styles with React Native means you need to use *camelCase* notation
    instead of *kebab-case* as we're used to with CSS – for example, `background-color`
    becomes `backgroundColor`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Native 创建样式意味着你需要使用 *camelCase* 表示法，而不是我们习惯的 CSS 中的 *kebab-case* –
    例如，`background-color` 变为 `backgroundColor`。
- en: 'We also need to make styling additions to the buttons on the `Game` screen
    by opening the `screens/Game.js` file. In this file, we again need to replace
    the `Button` components from React Native with a `TouchableHighlight` component
    with an inner `Text`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要通过打开 `screens/Game.js` 文件来为 `Game` 屏幕上的按钮添加样式修改。在这个文件中，我们再次需要用带有内部 `Text`
    的 `TouchableHighlight` 组件替换 React Native 的 `Button` 组件：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `styles` object must have the new `baseNumber`, `button`, and `buttonText`
    styles, which we can add at the bottom of the file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`styles` 对象必须包含新的 `baseNumber`、`button` 和 `buttonText` 样式，我们可以在文件底部添加这些样式：'
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, both buttons will now have the same white background. We can change
    this by adding additional styling to them. The `style` prop on React Native components
    can also take an array of styling objects instead of just a single object:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，现在两个按钮都将拥有相同的白色背景。我们可以通过为它们添加额外的样式来改变这一点。React Native 组件上的 `style` 属性也可以接受一个样式对象的数组，而不仅仅是单个对象：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These `buttonGreen` and `buttonRed` objects must also be added to the styling
    object:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些 `buttonGreen` 和 `buttonRed` 对象也必须添加到样式对象中：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With these additions, the application is now styled, which makes it more appealing
    to play. We''ve used the `StyleSheet` object from React Native to apply this styling,
    making your application look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些添加，应用程序现在已经被样式化，这使得它更具吸引力。我们使用了 React Native 的 `StyleSheet` 对象来应用这种样式，使你的应用程序看起来像这样：
- en: '![Figure 8.4 – The styled React Native application'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 样式化的 React Native 应用程序'
- en: '](img/Figure_8.04_B17390.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B17390.jpg)'
- en: Figure 8.4 – The styled React Native application
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 样式化的 React Native 应用程序
- en: Mobile games often have flashy animations that make the user want to keep playing
    and make the game more interactive. The *Higher/Lower* game that is already functioning
    uses no animations so far and just has some transitions that have been built in
    with React Navigation. In the next section, you'll be adding animations and gestures
    to the application, which will improve the game interface and make the user feel
    more comfortable while playing the game.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 移动游戏通常有令人眼花缭乱的动画，这些动画会让用户想要继续玩游戏，并使游戏更具互动性。目前功能正常的 *Higher/Lower* 游戏还没有使用动画，只是内置了一些
    React Navigation 创建的过渡效果。在下一节中，你将为应用程序添加动画和手势，这将改善游戏界面，并让用户在玩游戏时感到更加舒适。
- en: Adding gestures and animations in React Native
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 React Native 中添加手势和动画
- en: There are multiple ways to use animations in React Native, and one of those
    is to use the Animated API, which can be found at the core of React Native. With
    the Animated API, you can create animations for the `View`, `Text`, `Image`, and
    `ScrollView` components from React Native by default. Alternatively, you can use
    the `createAnimatedComponent` method to create your own.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 中使用动画有多种方式，其中之一是使用 Animated API，这是 React Native 的核心。使用 Animated
    API，你可以为 React Native 的 `View`、`Text`、`Image` 和 `ScrollView` 组件创建默认的动画。或者，你也可以使用
    `createAnimatedComponent` 方法来创建自己的组件。
- en: Creating a basic animation
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基本动画
- en: 'One of the simplest animations you can add is fading an element in or out by
    changing the value for the opacity of that element. In the *Higher/Lower* game
    you created previously, the buttons were styled. These colors already show a small
    transition, since you''re using the `TouchableHighlight` element to create the
    button. However, it''s possible to add a custom transition to this by using the
    Animated API. To add an animation, the following code blocks must be changed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加的最简单的动画之一是通过改变元素的透明度值来使元素淡入或淡出。在之前创建的 *Higher/Lower* 游戏中，按钮已经被样式化了。这些颜色已经显示出微小的过渡，因为你在创建按钮时使用了
    `TouchableHighlight` 元素。然而，你可以通过使用 Animated API 来添加一个自定义的过渡效果。要添加动画，必须更改以下代码块：
- en: 'Start by creating a new directory called `components`, which will hold all
    our reusable `components`. In this directory, create a file called `AnimatedButton.js`,
    which will contain the following code to construct the new component:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `components` 的新目录，它将包含我们所有的可重用 `components`。在这个目录中，创建一个名为 `AnimatedButton.js`
    的文件，它将包含以下代码来构建新的组件：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following styling to the bottom of this file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下样式添加到文件底部：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, this component is comparable to the buttons we have in `screens/Game.js`.
    Therefore, we can remove the `TouchableHighlight` buttons in that file and replace
    them with the `AnimatedButton` component. Make sure to pass the correct values
    for `action` and `onPress` as a prop to this component:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，这个组件与我们在`screens/Game.js`中拥有的按钮相似。因此，我们可以从该文件中删除`TouchableHighlight`按钮，并用`AnimatedButton`组件替换它们。确保将正确的`action`和`onPress`值作为属性传递给此组件：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'No visible changes are present if you look at the application on your mobile
    device or the emulator on your computer, since we need to change the clickable
    element from a `TouchableHighlight` element to a `TouchableWithoutFeedback` element
    first. That way, the default transition with the highlight will be gone, and we
    can replace this with our own effect. The `TouchableWithoutFeedback` element can
    be imported from React Native in `components/AnimatedButton.js` and should be
    placed around a `View` element, which will hold the default styling for the button:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在移动设备上的应用程序或电脑上的模拟器中查看，则不会看到任何可见的变化，因为我们首先需要将可点击元素从`TouchableHighlight`元素更改为`TouchableWithoutFeedback`元素。这样，带有高亮的默认过渡就会消失，我们可以用我们自己的效果来替换它。`TouchableWithoutFeedback`元素可以从React
    Native的`components/AnimatedButton.js`中导入，并且应该放在一个`View`元素周围，该元素将保留按钮的默认样式：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To create a transition when we click on the button, we can use the Animated
    API. We''ll use this to change the opacity of the `AnimatedButton` component from
    the moment it''s pressed. A new instance of the Animated API starts by specifying
    a value that should be changed during the animation that we created with the Animated
    API. This value should be changeable by the Animated API in your entire component,
    so you can add this value to the top of the component. This value should be created
    with a `useRef` Hook, since you want this value to be changeable later on. Also,
    we need to import `Animated` from React Native:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在点击按钮时创建过渡效果，我们可以使用Animated API。我们将使用它来改变`AnimatedButton`组件在被按下时的不透明度。Animated
    API的新实例通过指定在动画过程中应该改变值的值来开始。这个值应该在组件的整个范围内可改变，因此你可以将这个值添加到组件的顶部。这个值应该使用`useRef`钩子创建，因为你希望这个值以后可以改变。此外，我们还需要从React
    Native中导入`Animated`：
- en: '[PRE27]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This value can now be changed by the Animated API using any of the three animations
    types that are built in. These are `decay`, `spring`, and `timing`, where you''ll
    be using the `timing` method from the Animated API to change the animated value
    within a specified time frame. The Animated API can be triggered from the `onPress`
    event on `TouchableWithoutFeedback` and calls the `onPress` prop after finishing
    the animation:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用内置的任何三种动画类型来改变这个值。这些是`decay`、`spring`和`timing`，其中你将使用Animated API的`timing`方法在指定的时间范围内改变动画值。Animated
    API可以从`TouchableWithoutFeedback`上的`onPress`事件触发，并在动画完成后调用`onPress`属性：
- en: '[PRE28]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `timing` method takes the `opacity` that you've specified at the top of
    your component and an object with the configuration for the Animated API. We need
    to take the current value of the opacity, as this is a `ref` value. One of the
    fields is `toValue`, which will become the value for `opacity` when the animation
    has ended. The other field is for the field's duration, which specifies how long
    the animation should last.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`timing`方法接受你在组件顶部指定的`opacity`以及一个包含Animated API配置的对象。我们需要获取当前的不透明度值，因为这个是一个`ref`值。其中一个字段是`toValue`，当动画结束时，它将成为`opacity`的值。另一个字段是用于指定动画持续时间的字段。'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The other built-in animation types next to `timing` are `decay` and `spring`.
    Whereas the `timing` method changes gradually over time, the `decay` type has
    animations that change fast in the beginning and gradually slow down until the
    end of the animation. With `spring`, you can create animations that move a little
    outside of their edges at the end of the animation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与`timing`并列的内置动画类型还有`decay`和`spring`。而`timing`方法在一段时间内逐渐改变，`decay`类型具有在开始时快速改变并在动画结束时逐渐减慢的动画。使用`spring`，你可以在动画结束时创建稍微超出其边缘的动画。
- en: 'The `View` component can be replaced by an `Animated.View` component. This
    component uses the `opacity` variable created by the `useRef` Hook to set its
    opacity:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以用`Animated.View`组件替换`View`组件。该组件使用由`useRef`钩子创建的`opacity`变量来设置其不透明度：
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, when you press any of the buttons on the `Game` screen, they will fade
    out, since the opacity transitions from `1` to `0.2` in 400 milliseconds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你按下`Game`屏幕上的任何按钮时，它们将会淡出，因为不透明度从`1`过渡到`0.2`需要400毫秒。
- en: 'Something else you can do to make the animation appear smoother is to add an
    `easing` field to the `Animated` object. The value for this field comes from the
    `Easing` module, which can be imported from React Native. The `Easing` module
    has three standard functions: `linear`, `quad`, and `cubic`. Here, the `linear`
    function can be used for smoother timing animations:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使动画看起来更平滑，你可以向`Animated`对象添加一个`easing`字段。这个字段的值来自`Easing`模块，可以从React Native导入。`Easing`模块有三个标准函数：`linear`、`quad`和`cubic`。在这里，`linear`函数可以用于更平滑的时间动画：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this last change, the animation is complete, and the game interface already
    feels smoother, since the buttons are being highlighted using our own custom animation.
    In the next part of this section, we will combine some of these animations to
    make the user experience for this game even more advanced.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这个最后的修改，动画就完成了，游戏界面已经感觉更平滑了，因为按钮是通过我们自己的自定义动画来高亮的。在本节的下一部分，我们将结合一些这些动画，使游戏的用户体验更加先进。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also combine animations – for example, with the `parallel` method –
    from the Animated API. This method will start the animations that are specified
    within the same moment and take an array of animations as its value. Next to the
    `parallel` function, three other functions help you with animation composition.
    These functions are `delay`, `sequence`, and `stagger`, which can also be used
    in combination with each other. The `delay` function starts any animation after
    a predefined delay, the `sequence` function starts animations in the order you've
    specified and waits until an animation is resolved before starting another one,
    and the `stagger` function can start animations both in order and parallel with
    specified delays in between.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以结合动画——例如，使用`parallel`方法——从Animated API。这个方法将启动在同一时刻指定的动画，并将一个动画数组作为其值。在`parallel`函数旁边，还有三个其他函数可以帮助你进行动画组合。这些函数是`delay`、`sequence`和`stagger`，它们也可以组合使用。`delay`函数在预定延迟后开始任何动画，`sequence`函数按照你指定的顺序开始动画，并在一个动画解决之前等待，然后开始另一个动画，而`stagger`函数可以在指定延迟之间按顺序和并行地开始动画。
- en: Handling gestures with Expo
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Expo处理手势
- en: Gestures are an important feature of mobile applications, as they make the difference
    between a mediocre and a good mobile application. In the *Higher/Lower* game you've
    created, several gestures can be added to make the game more appealing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 手势是移动应用程序的一个重要特性，因为它们区分了平庸和优秀的移动应用程序。在你创建的*高低*游戏中，可以添加几个手势来使游戏更具吸引力。
- en: Previously, you used the `TouchableHighlight` element, which gives the user
    feedback after they press it by changing it. Another element that you could have
    used for this was the `TouchableOpacity` element. These gestures give the user
    an impression of what happens when they make decisions within your application,
    leading to improved user experience. These gestures can be customized and added
    to other elements as well, making it possible to have custom touchable elements
    as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你使用了`TouchableHighlight`元素，它在用户按下后会通过改变它来提供用户反馈。另一种你可以用来实现这个功能的元素是`TouchableOpacity`元素。这些手势给用户一种印象，即当他们在你的应用程序中做出决策时会发生什么，从而改善了用户体验。这些手势可以自定义并添加到其他元素中，使得可以拥有自定义的可触摸元素。
- en: For this, you can use a package called `react-native-gesture-handler`, which
    helps you access native gestures on every platform. All of these gestures will
    be run in the native thread, which means you can add complex gesture logic without
    having to deal with the performance limitations of React Native's gesture responder
    system. Some of the gestures it supports include *tap*, *rotate*, *drag*, and
    *pan*, and a *long press*. In the previous section, we installed this package,
    as it's a requirement for `react-navigation`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你可以使用一个名为`react-native-gesture-handler`的包，它可以帮助你在每个平台上访问原生手势。所有这些手势都将运行在原生线程上，这意味着你可以在不处理React
    Native手势响应系统性能限制的情况下添加复杂的手势逻辑。它支持的一些手势包括*点击*、*旋转*、*拖动*、*平移*和*长按*。在前一节中，我们已经安装了这个包，因为它是`react-navigation`的要求。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use gestures directly from React Native, without having to use
    an additional package. However, the gesture responder system that React Native
    currently uses doesn't run in the native thread. Not only does this limit the
    possibilities of creating and customizing gestures, but you can also run into
    cross-platform or performance problems. Therefore, it's advised that you use the
    `react-native-gesture-handler` package, but this isn't necessary for using gestures
    in React Native.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接从React Native使用手势，而无需使用额外的包。然而，React Native当前使用的响应者系统不在原生线程中运行。这不仅限制了创建和自定义手势的可能性，还可能导致跨平台或性能问题。因此，建议使用`react-native-gesture-handler`包，但这对于在React
    Native中使用手势并不是必需的。
- en: 'The gesture we will implement is a *long press* gesture, which will be added
    to the start button in our `Home` screen, located at `screens/Home.js`. Here,
    we''ll use the `TapGestureHandler` element from `react-native-gesture-handler`,
    which runs in the native thread, instead of the `TouchableWithoutFeedback` element
    from React Native, which uses the gesture responder system. To implement this,
    we need to do the following this becomes number 2 please make sure the rest of
    the numbers are updated accordingly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的动作是长按手势，它将被添加到我们的`主页`屏幕上的开始按钮中，位于`screens/Home.js`。在这里，我们将使用来自`react-native-gesture-handler`的`TapGestureHandler`元素，它在原生线程中运行，而不是使用React
    Native的`TouchableWithoutFeedback`元素，后者使用手势响应系统。为了实现这一点，我们需要做以下操作，请确保其余的数字都相应更新：
- en: 'Install using Expo:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Expo进行安装：
- en: '[PRE31]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Import `TapGestureHandler` and `State` from `react-native-gesture-handler`,
    next to `View` and `Alert` from React Native. The `TouchableHighlight` import
    can be removed, as this will be replaced:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`react-native-gesture-handler`导入`TapGestureHandler`和`State`，紧挨着从React Native导入的`View`和`Alert`。可以移除`TouchableHighlight`的导入，因为这将被替换：
- en: '[PRE32]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can replace the `TouchableHighlight` component with `TapGestureHandler`,
    and we need to put a `View` component inside it, to which we apply the styling.
    `TapGestureHandler` doesn''t take an `onPress` prop but an `onHandlerStateChange`
    prop instead, to which we pass the new `on` `Tap` function. In this function,
    we need to check whether the state of the tap event is active. For this, you need
    to know that the tap event goes through different states: `UNDETERMINED`, `FAILED`,
    `BEGAN`, `CANCELLED`, `ACTIVE`, and `END`. The naming of these states is pretty
    straightforward, and usually, the handler will have the following flow: `UNDETERMINED`
    > `BEGAN` > `ACTIVE` > `END` > `UNDETERMINED`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`TouchableHighlight`组件替换为`TapGestureHandler`，并在其中放置一个`View`组件，然后对其应用样式。`TapGestureHandler`不接收`onPress`属性，而是接收`onHandlerStateChange`属性，我们将新的`on`
    `Tap`函数传递给它。在这个函数中，我们需要检查触摸事件的状态是否为活动状态。为此，你需要知道触摸事件会经过不同的状态：`UNDETERMINED`、`FAILED`、`BEGAN`、`CANCELLED`、`ACTIVE`和`END`。这些状态的名字相当直观，通常处理器的流程如下：`UNDETERMINED`
    > `BEGAN` > `ACTIVE` > `END` > `UNDETERMINED`：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you now press the start button on the `Home` screen, you will receive the
    message that you need to long press the button to start the game. To add this
    long press gesture, we need to add a `LongPressGestureHandler` component inside
    the `TapGestureHandler` component. Also, we need to create a function that can
    be called by the `LongPressGestureHandler` component, which navigates us to the
    `Game` screen:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在在“主页”屏幕上按下开始按钮，你会收到需要长按按钮以开始游戏的消息。为了添加这个长按手势，我们需要在`TapGestureHandler`组件内部添加一个`LongPressGestureHandler`组件。此外，我们还需要创建一个可以被`LongPressGestureHandler`组件调用的函数，该函数将带我们进入`游戏`屏幕：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside the `TapGestureHandler` the newly imported `LongPressGestureHandler`
    component should be placed. This component takes the function to navigate to the
    game, and a prop to set the minimal duration of the long press. If you dont set
    this prop, the minimal duration will be 500ms by default::'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TapGestureHandler`内部应放置新导入的`LongPressGestureHandler`组件。该组件接收导航到游戏的函数，以及一个设置长按最小持续时间的属性。如果你不设置此属性，默认的最小持续时间将是500ms：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this latest change, you can only start the game by long pressing the **start**
    button on the **Home** screen. These gestures can be customized even more, since
    you can use composition to have multiple tap events that respond to each other.
    By creating so-called **cross-handler interactions**, you can create a touchable
    element that supports a *double-tap* gesture and a *long-press* gesture.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最新的更改，您只能通过在 **主页** 屏幕上长按 **开始** 按钮来启动游戏。这些手势可以进一步自定义，因为您可以使用组合来拥有多个相互响应的点击事件。通过创建所谓的
    **交叉处理程序交互**，您可以创建一个支持 *双击* 和 *长按* 手势的可触摸元素。
- en: The next section will show you how to handle even more advanced animations,
    such as displaying animated graphics when any of two players win. For this, we'll
    use the Lottie package, since it supports more functionalities than the built-in
    Animated API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向您展示如何处理更高级的动画，例如在任意两位玩家获胜时显示动画图形。为此，我们将使用 Lottie 包，因为它比内置的 Animated API
    支持更多的功能。
- en: Advanced animations with Lottie
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Lottie 的高级动画
- en: The React Native Animated API is great for building simple animations, but building
    more advanced animations can be harder. Luckily, Lottie offers a solution for
    creating advanced animations in React Native by making it possible for us to render
    After Effects animations in real time for iOS, Android, and React Native.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Animated API 对于构建简单的动画来说很棒，但构建更高级的动画可能更困难。幸运的是，Lottie 通过使我们能够在
    iOS、Android 和 React Native 中实时渲染 After Effects 动画，为 React Native 提供了创建高级动画的解决方案。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using Lottie, you don't have to create these After Effects animations yourself;
    there's a whole library full of resources that you can customize and use in your
    project. This library is called `LottieFiles` and is available at [https://lottiefiles.com/](https://lottiefiles.com/).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Lottie 时，您不必自己创建这些 After Effects 动画；有一个完整的资源库，您可以在项目中自定义并使用。这个库叫做 `LottieFiles`，可在
    [https://lottiefiles.com/](https://lottiefiles.com/) 获取。
- en: 'Since we''ve already added animations to the buttons of our game, a nice place
    to add more advanced animations would be the message that is displayed when you
    win or lose the game. This message can be displayed on a screen instead of an
    alert, where a trophy can be displayed if the user won. Let''s do this now:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为游戏按钮添加了动画，添加更多高级动画的好地方是在显示您赢或输游戏的消息上。这个消息可以显示在屏幕上而不是弹窗中，如果用户赢了，可以显示奖杯。让我们现在就做这个：
- en: 'To get started with Lottie, run the following command, which will install Lottie
    to our project:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用 Lottie，运行以下命令，它将安装 Lottie 到我们的项目中：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After the installation is completed, we can create a new screen component called
    `screens/Result.js` with the following content:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以创建一个新的屏幕组件，名为 `screens/Result.js`，其内容如下：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add this screen to the stack navigator so that it can be used in the navigation
    for this mobile application by importing it in App.js. Also, the navigation element
    `HeaderBackButton` should be imported:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此屏幕添加到堆栈导航器中，以便可以通过在 App.js 中导入它来在移动应用的导航中使用。此外，还应该导入导航元素 `HeaderBackButton`：
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also imported the `HeaderBackButton` component from React Navigation when
    adding the `Result` screen, as we also want to change the `Home` screen instead
    of the `Game` screen so that the user can start a new game after finishing it:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当添加 `Result` 屏幕时，我们也从 React Navigation 导入了 `HeaderBackButton` 组件，因为我们还想要更改 `主页`
    屏幕而不是 `游戏` 屏幕，以便用户在完成游戏后可以开始新游戏：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From the `Game` screen in `screens/Game.js`, we can navigate the user to the
    `Result` screen after playing the game and also pass a param to this screen. Using
    this param, a message can be displayed with the result of the game:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `screens/Game.js` 中的 `Game` 屏幕中，我们可以在游戏后引导用户到 `Result` 屏幕并传递一个参数给这个屏幕。使用此参数，可以显示游戏的结果消息：
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From the `Result` screen in the `screens/Result.js` file, we can import `LottieView`
    from `lottie-react-native` and get the param from the `route` object using the
    `useRoute` Hook from React Navigation. Using this param, we can return a message
    if the user has won or lost:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `screens/Result.js` 文件中的 `Result` 屏幕中，我们可以从 `lottie-react-native` 导入 `LottieView`，并使用
    React Navigation 的 `useRoute` 钩子从 `route` 对象中获取参数。使用此参数，如果用户赢了或输了，我们可以返回一条消息：
- en: '[PRE41]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The imported `Lottie` component can render any Lottie file that you either
    create yourself or that is downloaded from the `LottieFiles` library. In the GitHub
    repository for this chapter, you will find a Lottie file that can be used in this
    project called `winner.json`. This file must be placed in the `assets` directory
    and can be rendered by the `LottieView` component when you add it to the source,
    and the `width` and `height` values of the animation can be set by passing a `style`
    object. Also, you should add the `autoPlay` prop to start the animation once the
    component renders:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入的`Lottie`组件可以渲染你自行创建或从`LottieFiles`库下载的任何Lottie文件。在本章的GitHub仓库中，你可以找到一个名为`winner.json`的Lottie文件，该文件可用于本项目。此文件必须放置在`assets`目录中，并且可以通过将组件添加到源代码中由`LottieView`组件渲染。动画的`width`和`height`值可以通过传递一个`style`对象来设置。此外，你应该添加`autoPlay`属性以在组件渲染后开始动画：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As a finishing touch, we can add some styling to the message that is displayed
    on this screen and make it bigger:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的润色，我们可以在屏幕上显示的消息中添加一些样式，并使其更大：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the `Result` screen component receives the `winner` param with the `true`
    value, instead of the board, the user will see the trophy animation being rendered.
    An example of how this will look when you''re running the application with the
    iOS simulator or on an iOS device can be seen here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Result`屏幕组件接收到带有`true`值的`winner`参数时，用户将看到渲染的奖杯动画，而不是游戏板。当你使用iOS模拟器或iOS设备运行应用程序时，这个效果的样子可以在这里看到：
- en: '![Figure 8.5 – The Lottie animation after winning a game'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – 游戏获胜后的Lottie动画'
- en: '](img/Figure_8.05_B17390.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.05_B17390.jpg]'
- en: Figure 8.5 – The Lottie animation after winning a game
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 游戏获胜后的Lottie动画
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you find the speed of this animation too fast, you can reduce it by combining
    the Animated API with Lottie. The `LottieView` component can take a `progress`
    prop that determines the speed of the animation. When passing a value that is
    created by the Animated API, you can tweak the speed of the animation as per your
    preference.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这个动画的速度太快，你可以通过结合Animated API和Lottie来降低速度。`LottieView`组件可以接受一个`progress`属性，该属性决定了动画的速度。当你传递由Animated
    API创建的值时，你可以根据你的偏好调整动画的速度。
- en: By adding this animation using Lottie, we've created a mobile application with
    an animated game that you can play for hours.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Lottie添加此动画，我们创建了一个可以玩数小时的动画游戏移动应用程序。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've created a React Native application with Expo. React Native
    uses the same principles as React and can be used to create mobile applications.
    We've added basic routing with React Navigation, based on stack navigation. We've
    also added basic and more complex gestures to the game, which run in the native
    thread thanks to the `react-native-gesture-handler` package. Finally, animations
    were created using the React Native Animated API and Lottie, which is available
    from the Expo CLI.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Expo创建了一个React Native应用程序。React Native使用与React相同的原理，可以用来创建移动应用程序。我们基于堆栈导航添加了基本的路由，即React
    Navigation。我们还向游戏中添加了基本和更复杂的手势，这些手势通过`react-native-gesture-handler`包在本地线程中运行。最后，我们使用React
    Native Animated API和Lottie创建了动画，这些API可通过Expo CLI获取。
- en: The project that we'll create in the next chapter will explore handling data
    in React Native. We'll also learn about the differences in styling between iOS
    and Android.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个探索在React Native中处理数据的工程项目。我们还将了解iOS和Android之间在样式上的差异。
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Expo: [https://docs.expo.io/](https://docs.expo.io/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expo：[https://docs.expo.io/](https://docs.expo.io/)
- en: 'Various Lottie files: [https://lottiefiles.com/](https://lottiefiles.com/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种Lottie文件：[https://lottiefiles.com/](https://lottiefiles.com/)
- en: 'More on the Animated API: [https://facebook.github.io/react-native/docs/animated](https://facebook.github.io/react-native/docs/animated)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Animated API的信息：[https://facebook.github.io/react-native/docs/animated](https://facebook.github.io/react-native/docs/animated)
- en: Gesture Handler:[https://docs.swmansion.com/react-native-gesture-handler/](https://docs.swmansion.com/react-native-gesture-handler/)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手势处理器：[https://docs.swmansion.com/react-native-gesture-handler/](https://docs.swmansion.com/react-native-gesture-handler/)
