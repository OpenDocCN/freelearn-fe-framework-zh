- en: Advanced Functionality and Styling the To-Do List App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级功能与待办事项应用程序的样式设计
- en: 'Having built an MVP for `Tasks`, our to-do list app, it''s time to delve into
    building out advanced functionality, and styling the application to make it look
    nice. This chapter will explore the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `Tasks` 应用程序构建了 MVP（最小可行产品）之后，现在是时候深入构建高级功能，并对应用程序进行样式设计，使其看起来更美观。本章将探讨以下主题：
- en: Utilizing the `NavigatorIOS` component to build an edit screen to add details
    to a task
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `NavigatorIOS` 组件构建一个编辑屏幕，以便添加任务的详细信息
- en: Taking in a date and time for tasks to be due with `DatePickerIOS`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DatePickerIOS` 捕获任务截止日期和时间
- en: Creating a custom collapsible component for our app and utilizing `LayoutAnimation`
    to give us fluid transitions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一个自定义可折叠组件，并利用 `LayoutAnimation` 来实现流畅的过渡
- en: Building a `Button` component for our UI to clear a to-do item's due date
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的 UI 构建一个 `Button` 组件，以清除待办事项的截止日期
- en: Saving the data of an edited task and rendering a due date, if applicable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存已编辑任务的资料，如果适用，则渲染截止日期
- en: Porting the application over to Android, swapping out `DatePickerIOS` for `DatePickerAndroid`
    and `TimePickerAndroid` and `NavigatorIOS` for `Navigator`, and exploring the
    control flow in deciding which component is used
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序移植到 Android，用 `DatePickerAndroid` 和 `TimePickerAndroid` 替换 `DatePickerIOS`，用
    `Navigator` 替换 `NavigatorIOS`，并探索在决定使用哪个组件时的控制流程
- en: Navigator and NavigatorIOS
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航器和 NavigatorIOS
- en: Implementing navigation in a mobile application helps us control how our users
    interact with and experience our apps. It lets us assign context to situations
    that would otherwise not have any--for example, in `Tasks`, it will not make sense
    to show a user an edit view for a task that they haven't selected; only showing
    this to the user when they select a task to edit builds situational context and
    awareness.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用程序中实现导航有助于我们控制用户如何与我们的应用程序互动和体验。它让我们为那些原本没有任何上下文的情况赋予上下文——例如，在 `Tasks`
    中，向用户展示一个尚未选择的任务的编辑视图是没有意义的；只有当用户选择编辑任务时，才向用户展示此视图，这样可以构建情境上下文和意识。
- en: React Native's `Navigator` component handles the transitions between different
    views in your application. Glancing at the documentation, you may note that there's
    both a `Navigator` and `NavigatorIOS` component. `Navigator` is available on iOS
    and Android and implemented with JavaScript. On the other hand, `NavigatorIOS`
    is specifically available for iOS and is a wrapper around iOS's native `UINavigationController`,
    animating it and behaving the way you would expect from any iOS application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 的 `Navigator` 组件负责处理应用程序中不同视图之间的转换。浏览文档时，您可能会注意到存在一个 `Navigator`
    和 `NavigatorIOS` 组件。`Navigator` 在 iOS 和 Android 上都可用，并使用 JavaScript 实现。另一方面，`NavigatorIOS`
    仅适用于 iOS，并且是 iOS 原生 `UINavigationController` 的包装器，它动画化并按照您从任何 iOS 应用程序中期望的方式表现。
- en: Later in this chapter, we will take a closer look at the Navigator.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将更详细地探讨 Navigator。
- en: An important note about NavigatorIOS
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 NavigatorIOS 的重要说明
- en: While `NavigatorIOS` supports UIKit animations and is a great choice for building
    the iOS version of `Tasks`, one thing to keep in mind is that `NavigatorIOS` happens
    to be a community-driven component of the React Native SDK. Facebook has openly
    stated from the beginning that it utilizes `Navigator` heavily in its own applications,
    but all support for future improvements and additions to the `NavigatorIOS` component
    will come directly from open source contributions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `NavigatorIOS` 支持UIKit动画，并且是构建 `Tasks` iOS 版本的绝佳选择，但需要记住的是，`NavigatorIOS`
    事实上是 React Native SDK 的一个社区驱动组件。Facebook 从一开始就公开表示，它在自己的应用程序中大量使用了 `Navigator`，但
    `NavigatorIOS` 组件未来改进和添加的所有支持都将直接来自开源贡献。
- en: Looking at NavigatorIOS
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 NavigatorIOS
- en: 'The `NavigatorIOS` component is set up at the top level of your React Native
    app. We''ll provide at least one object, identified as `routes`, in order to identify
    each view in our app. Additionally, `NavigatorIOS` looks for a `renderScene` method,
    which is responsible for rendering each scene in our app. Here''s an example of
    how you can render a basic scene with `NavigatorIOS`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigatorIOS` 组件在您的 React Native 应用程序的最顶层设置。我们将提供至少一个对象，标识为 `routes`，以便识别我们应用程序中的每个视图。此外，`NavigatorIOS`
    会查找一个 `renderScene` 方法，该方法负责渲染我们应用程序中的每个场景。以下是一个使用 `NavigatorIOS` 渲染基本场景的示例：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is just a rudimentary example. All we''re doing is initializing the `NavigatorIOS`
    component and rendering it as a basic route with a simple `text` component. What
    we''re really interested in doing is switching between `routes` to edit a task.
    Let''s break down this goal into a number of subtasks that are easier to tackle:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的示例。我们正在初始化 `NavigatorIOS` 组件，并以一个简单的 `text` 组件作为基本路由进行渲染。我们真正感兴趣的是在
    `routes` 之间切换以编辑任务。让我们将这个目标分解成一系列更容易处理的子任务：
- en: Create a new `EditTask` component. It can start off as a simple screen with
    some filler info on it.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `EditTask` 组件。它可以从一个带有一些填充信息的简单屏幕开始。
- en: Set up `NavigatorIOS` to route to `EditTask` when a task is long-pressed.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `NavigatorIOS` 以在任务长按时路由到 `EditTask`。
- en: Build logic for `EditTask` to accept the exact task as a prop in the component
    to render task-specific data. Add appropriate input fields to allow this component
    to be marked as complete from the edit screen as well as for it to have the ability
    to set a due date and tag.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `EditTask` 构建逻辑，使其能够接受作为组件属性的精确任务以渲染特定于任务的数据。添加适当的输入字段，以便此组件可以从编辑屏幕标记为完成，以及具有设置截止日期和标签的能力。
- en: When edits are saved, add logic to save the edited data to `AsyncStorage`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编辑保存时，添加逻辑将编辑后的数据保存到 `AsyncStorage`。
- en: We'll take some time to complete each step and go over them when necessary.
    Take a few minutes to build a simple `EditTask` component, and then refer to how
    I built mine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花一些时间来完成每个步骤，并在必要时进行回顾。花几分钟时间构建一个简单的 `EditTask` 组件，然后参考我是如何构建的。
- en: A simple EditTasks component
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 EditTasks 组件
- en: 'In my application folder structure, my `EditTasks` component is nested as such:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的应用程序文件夹结构中，我的 `EditTasks` 组件嵌套如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a basic component just to have something appear on the screen:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的组件，只是为了在屏幕上显示一些内容：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code returns text to render to the screen for now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码现在返回要渲染到屏幕上的文本。
- en: 'Now comes the fun part. Let''s set up `NavigatorIOS` to play nicely with `TasksList`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候设置 `NavigatorIOS` 以与 `TasksList` 顺利协作了：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we should modify `TasksList` so that it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该修改 `TasksList` 以使其：
- en: Adds a function, called `_editTask`, to push the `EditTask` component to the
    Navigator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为 `_editTask` 的函数，将 `EditTask` 组件推送到 Navigator
- en: Passes the `_editTask` function into `TasksListCell` as a prop, titled `onLongPress`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `_editTask` 函数作为名为 `onLongPress` 的属性传递给 `TasksListCell`
- en: 'Then, we should modify `EditTask` so that the `TouchableHighlight` component
    in its `render` method calls this prop during its own `onLongPress` callback:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该修改 `EditTask` 以确保其 `render` 方法中的 `TouchableHighlight` 组件在其自己的 `onLongPress`
    回调期间调用此属性：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We added a Boolean set to disable the automatic adjustment of content insets.
    With this defaulting to `true`, we saw an inset of `~55px` between our `Input`
    and `ListView` components. In our styling for both this component and `EditTask`,
    we started importing the `Navigator` component.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个布尔值，用于禁用内容内边距的自动调整。默认设置为 `true`，我们在 `Input` 和 `ListView` 组件之间看到了 `~55px`
    的内边距。在我们的组件和 `EditTask` 的样式设置中，我们开始导入 `Navigator` 组件。
- en: This is so that we can set the `paddingTop` property of our container to take
    into consideration the height of the navigation bar so that content is not left
    tucked behind the navigation bar. The reason this happens is because the navigation
    bar is rendered over our components after they are done loading.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以设置容器 `paddingTop` 属性，考虑到导航栏的高度，以便内容不会被留在导航栏后面。这种情况发生的原因是导航栏在组件加载完成后被渲染。
- en: 'Call the `push` method of `NavigatorIOS`, rendering the `EditTask` component
    that we just imported:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `NavigatorIOS` 的 `push` 方法，渲染我们刚刚导入的 `EditTask` 组件：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assign `TasksListCell` a callback, titled `onLongPress`, that executes the
    `_editTask` method we just defined:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `TasksListCell` 分配一个名为 `onLongPress` 的回调，执行我们刚刚定义的 `_editTask` 方法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Setting the `paddingTop` property to the height of the Navigator solves the
    issue of our navigation bar hiding the content of our app behind it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `paddingTop` 属性设置为 Navigator 的高度，解决了我们的导航栏隐藏其后面的应用内容的问题：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using DatePickerIOS
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DatePickerIOS
- en: A key feature in `Tasks` is the ability to set a reminder for when a task is
    due. Ideally, our users can set a day as well as a time for when a task should
    be completed so that they can be reminded of the due date. To accomplish this,
    we'll use an iOS component named `DatePickerIOS`. This is a component that renders
    a date and time selector that we can utilize in our application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tasks`中，一个关键特性是能够为任务到期时设置提醒。理想情况下，我们的用户可以为任务完成设定日期和时间，以便他们能够被提醒到期日期。为了实现这一点，我们将使用一个名为`DatePickerIOS`的iOS组件。这是一个可以用于我们应用程序中的日期和时间选择器组件。
- en: 'Listed here are the two props that we will be using with our `DatePickerIOS`
    component. Other props exist in the React Native documentation in case you are
    interested:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了我们将与`DatePickerIOS`组件一起使用的两个属性。如果你感兴趣，React Native文档中还有其他属性：
- en: '`date`: This is one of the two required props that track the current selected
    date. Ideally, this information is stored within the state of the component that
    renders `DatePickerIOS`. The `date` should be an instance of the `Date` object
    in JavaScript.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`: 这是两个必需属性之一，用于跟踪当前选定的日期。理想情况下，此信息存储在渲染`DatePickerIOS`组件的状态中。`date`应该是JavaScript中的`Date`对象实例。'
- en: '`onDateChange`: This is the other required prop and is fired when a user changes
    the `date` or `time` in the component. It accepts one argument, which is the `Date`
    object representing the new date and time.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDateChange`: 这是另一个必需的属性，当用户在组件中更改`日期`或`时间`时触发。它接受一个参数，即表示新日期和时间的`Date`对象。'
- en: 'Here''s how a simple `DatePicker` component looks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的`DatePicker`组件的示例：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It creates a new instance of the JavaScript `Date` object and saves it to state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个新的JavaScript `Date`对象实例并将其保存到状态中。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This results in rendering a `DatePickerIOS` component using the `date` value
    in the component state as its prop of the same name.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致使用组件状态中的`date`值作为同名的属性来渲染`DatePickerIOS`组件。
- en: 'The callback to change the `date` in the component state when the user interacts
    with the `DatePickerIOS` component:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与`DatePickerIOS`组件交互时，在组件状态中更改`date`的回调：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is how the `DatePicker`, when rendered, will look:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是渲染后的`DatePicker`的外观：
- en: '![](img/image_02_001-1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001-1.png)'
- en: This leaves a lot to be desired. For one, the `DatePickerIOS` component is always
    visible! Normally, when we interact with this type of selector in iOS applications,
    it is collapsed and only expands when tapped on. What we want is to replicate
    that exact experience, that is, render a touchable row that either displays the
    current set due date or something along the lines of *No Due Date Set*, animating
    the expansion of `DatePickerIOS` when the row is tapped on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有许多不足之处。首先，`DatePickerIOS`组件始终可见！通常，当我们在iOS应用程序中与这类选择器交互时，它是折叠的，只有当点击时才会展开。我们想要复制的正是这种确切的经验，即渲染一个可触摸的行，显示当前设置的到期日期或类似*未设置到期日期*的内容，当行被点击时，动画展开`DatePickerIOS`。
- en: Writing a collapsible component
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可折叠组件
- en: 'Our collapsible component should accomplish the following goals:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可折叠组件应实现以下目标：
- en: It should show and hide other components passed to it when tapped on
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击时，它应显示和隐藏传递给它的其他组件
- en: An animation will accompany this component, adding to the user experience of
    our app
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个组件将伴随动画，增强我们应用程序的用户体验
- en: The component should not make any assumptions about the type of data it is showing
    and hiding; it should not be strictly specific to `DatePickerIOS` in case we want
    to reuse the component for other purposes in the future
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件不应对其显示和隐藏的数据类型做出任何假设；它不应严格特定于`DatePickerIOS`，以防我们将来想要将组件用于其他目的
- en: We'll need to take advantage of React Native's fantastic `LayoutAnimation` API,
    which is designed to let us create fluid and meaningful animations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要利用React Native的出色`LayoutAnimation` API，该API旨在让我们创建流畅且富有意义的动画。
- en: 'To begin, I''ve created an `ExpandableCell` component within the `components`
    folder of our project, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我在项目的`components`文件夹中创建了一个名为`ExpandableCell`的组件，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The LayoutAnimation API
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局动画API
- en: Our goal is to tap on the `date`/`time` component in `EditTask` and then have
    it expand downward to reveal the hidden `DatePickerIOS` component. React Native
    has an API, called `LayoutAnimation`, that allows us to create automatically animating
    layouts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在`EditTask`中点击`date`/`time`组件，然后使其向下展开以显示隐藏的`DatePickerIOS`组件。React Native有一个名为`LayoutAnimation`的API，允许我们创建自动动画布局。
- en: '`LayoutAnimation` comes with three methods representing default animation curves:
    `easeInEaseOut`, `linear`, and `spring`. These dictate how the animation behaves
    throughout its transition. You can simply call one of the three methods under
    the `componentWillUpdate` life cycle method and, should a change in your component''s
    state trigger a rerender, `LayoutAnimation` will add its animation to your changes.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`LayoutAnimation` 包含三个表示默认动画曲线的方法：`easeInEaseOut`、`linear` 和 `spring`。这些决定了动画在其过渡过程中的行为。你可以在
    `componentWillUpdate` 生命周期方法下简单地调用这三个方法之一，如果组件状态的变化触发了重新渲染，`LayoutAnimation` 将将其动画添加到你的更改中。'
- en: To hide and show the children components passed to `ExpandableCell`, I can manipulate
    its `maxHeight` style based on whether or not the component should be shown or
    hidden. Additionally, I can hide the component when not needed by setting its
    `overflow` property to `hidden`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏和显示传递给 `ExpandableCell` 的子组件，我可以根据组件是否应该显示或隐藏来操作其 `maxHeight` 样式。此外，我可以通过将
    `overflow` 属性设置为 `hidden` 来在不需要时隐藏组件。
- en: Take some time to hide the children components passed into `ExpandableCell`
    and set up some logic to show and hide this content as needed. When you're ready,
    look at my implementation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间隐藏传递给 `ExpandableCell` 的子组件，并设置一些逻辑来根据需要显示和隐藏此内容。准备好后，查看我的实现。
- en: Basic ExpandableCell implementation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本ExpandableCell实现
- en: 'This is how we can start building `ExpandableCell`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们开始构建 `ExpandableCell` 的方法：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This sets the `title` as an expected string `PropTypes` for the component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `title` 设置为组件期望的 `PropTypes` 字符串：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we track a Boolean named `expanded` in the component `state`. By default,
    our child components should not be visible:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们跟踪组件 `state` 中的布尔值 `expanded`。默认情况下，我们的子组件不应可见：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set the `LayoutAnimation` style for whenever this component changes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此组件更改时的 `LayoutAnimation` 样式：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Wrap a `TouchableHighlight` component around the `Text` of the `ExpandableCell`.
    It calls `_onExpand` when pressed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `TouchableHighlight` 组件包裹在 `ExpandableCell` 的 `Text` 组件周围。当按下时，它会调用 `_onExpand`
    方法：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a ternary operator to add a `maxHeight` property to the styling of this
    `View` in the event that the component is not expanded:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件未展开的情况下，向此 `View` 的样式添加一个 `maxHeight` 属性，使用三元运算符：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This renders any children nested within the component itself:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染组件本身嵌套的任何子组件：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is a callback to toggle the `expanded` Boolean in the component
    state:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个回调，用于在组件状态中切换 `expanded` 布尔值：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the styling for `ExpandableCell`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `ExpandableCell` 的样式：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A basic implementation of this in `EditTask` will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `EditTask` 中的基本实现如下所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Render an ExpandableCell component with a title:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染一个带有标题的 ExpandableCell 组件：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Nest `DatePickerIOS` within `ExpandableCell` so that it initially stays hidden:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ExpandableCell` 内嵌套 `DatePickerIOS` 以使其最初保持隐藏：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Ideally, this component will show one of the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，此组件将显示以下之一：
- en: The due date of the selected task, if it exists
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，则选择任务的截止日期
- en: A blank placeholder to select a date if a due date does not exist
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不存在截止日期，则选择日期的空白占位符
- en: 'We''ll worry about things such as clearing the due date later but, for now,
    we should modify `EditTask` so that the `title` prop it passes to `ExpandableCell`
    is dependent on whether the task has a due date assigned to it or not. This is
    how the component should currently look:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后处理诸如清除截止日期等问题，但现在，我们应该修改 `EditTask`，使其传递给 `ExpandableCell` 的 `title` 属性取决于任务是否分配了截止日期。组件当前应该看起来是这样的：
- en: '![](img/image_02_002-1.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002-1.png)'
- en: 'Here is how I solved the problem. The only file changed since the last example
    is the `EditTask` component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决这个问题的方法。自上一个示例以来，唯一更改的文件是 `EditTask` 组件：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Set two strings to show the `title` prop for `ExpandableCell`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 设置两个字符串以显示 `ExpandableCell` 的 `title` 属性。
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Use a ternary operator to decide which string to pass in to `ExpandableCell`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符来决定传递给 `ExpandableCell` 的字符串。
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I also imported `moment` from `npm` to use its powerful date formatting capabilities.
    Moment is a very popular, widely-used library that allows us to manipulate dates
    with JavaScript. Installing it was as simple as opening the Terminal to the project''s
    root folder and typing as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我还从 `npm` 导入了 `moment` 以使用其强大的日期格式化功能。Moment 是一个非常流行、广泛使用的库，它允许我们使用 JavaScript
    操作日期。安装它就像打开项目根目录的终端并输入以下内容一样简单：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The MomentJS library is well documented and its main page, found at [https://
    momentjs.com](https://www.momentjs.com), will show you all the ways you can utilize
    it. For this file, I used Moment's the format method and set the formatting to
    show an abbreviated month name, followed by the day and year in numbers and the
    time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MomentJS 库有很好的文档，其主页位于 [https:// momentjs.com](https://www.momentjs.com)，将展示你如何使用它的所有方法。对于这个文件，我使用了
    Moment 的格式化方法，并设置为显示缩写月份名称，后跟数字日期和年份，以及时间。
- en: 'A sample Moment date formatted with the `''lll''` flag will appear like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `'lll'` 标志格式化的 Moment 日期示例如下：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are different ways to format your dates with Moment, and I would encourage
    you to play around with the library to find a date format that works best for
    you.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Moment 格式化日期有不同的方式，我鼓励你玩一玩这个库，找到最适合你的日期格式。
- en: 'Set `dateSelected` to `true` and add the Moment-formatted version of the date
    to state, which in turn fires the `render` method of this component again to update
    the `title` string passed into `ExpandableCell`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dateSelected` 设置为 `true`，并将日期的 Moment 格式版本添加到状态中，这将反过来触发此组件的 `render` 方法再次更新传递给
    `ExpandableCell` 的 `title` 字符串：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By the end of this section, your app should look something like the following
    screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你的应用应该看起来像以下截图：
- en: '![](img/image_02_003-1.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003-1.png)'
- en: Using onLayout
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 onLayout
- en: In our preceding example, we don't need to specify the height of the `DatePickerIOS`
    component when expanded. However, there may be scenarios in which you may need
    to manually get the dimensions of a component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们不需要指定 `DatePickerIOS` 组件在展开时的高度。然而，可能存在需要手动获取组件尺寸的场景。
- en: 'To calculate a component''s height, we can utilize its `onLayout` property
    to fire a callback and then use that callback to save properties passed to the
    callback. The `onLayout` property is an event that is invoked on mount and layout
    changes, giving the event object a `nativeEvent` object that nests the component''s
    layout properties. Using `DatePickerIOS` as an example, you can pass a callback
    to its `onLayout` prop like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算组件的高度，我们可以利用其 `onLayout` 属性来触发一个回调，然后使用该回调保存传递给回调的属性。`onLayout` 属性是一个在挂载和布局更改时被调用的事件，它给事件对象一个
    `nativeEvent` 对象，该对象嵌套了组件的布局属性。以 `DatePickerIOS` 为例，你可以像这样将其 `onLayout` 属性传递一个回调：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `event` from `onLayout` gives access to the following property:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`onLayout` 事件提供了以下属性：'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Button
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮
- en: Let's build a *clear due date* button for the `EditTask` component and only
    selectively enable it if a due date has been selected for the to-do item. The
    `Button` component in React Native should help us render one quickly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `EditTask` 组件构建一个 *清晰的截止日期* 按钮，并且只有当待办事项已选择截止日期时才选择性地启用它。React Native 中的
    `Button` 组件应该能帮助我们快速渲染。
- en: 'The `Button` component accepts a couple of props; the following four will be
    used in our application:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button` 组件接受一些属性；以下四个将在我们的应用程序中使用：'
- en: '`color`: This is a string (or stringified hex) that sets either the text color
    on iOS or the background color on Android'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`：这是一个字符串（或字符串化的十六进制值），用于设置 iOS 上的文本颜色或 Android 上的背景颜色'
- en: '`disabled`: This is a Boolean that disables the button if set to `true`; it
    defaults to `false`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled`：这是一个布尔值，如果设置为 `true`，则禁用按钮；默认为 `false`'
- en: '`onPress`: This is a callback that is fired when a button is pressed'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPress`：这是一个在按钮被按下时触发的回调'
- en: '`title`: This is the text to display within the button'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：这是要在按钮内显示的文本'
- en: 'A sample `Button` component can be rendered like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例 `Button` 组件可以渲染如下：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Modify `EditTask` so that it has the following features:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `EditTask` 以使其具有以下功能：
- en: It contains a Boolean, titled `expanded`, in its state to control the open/closed
    status of the `ExpandableCell`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在其状态中包含一个布尔值，标题为 `expanded`，用于控制 `ExpandableCell` 的打开/关闭状态。
- en: It modifies the rendering of `ExpandableCell` to accept the `expanded` and `onPress`
    props. The `expanded` prop should point to the `expanded` Boolean in `EditTask's`
    state and the `onPress` prop should fire a method that flips the `expanded` Boolean.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它修改了 `ExpandableCell` 的渲染，以接受 `expanded` 和 `onPress` 属性。`expanded` 属性应指向 `EditTask`
    状态中的 `expanded` 布尔值，而 `onPress` 属性应触发一个翻转 `expanded` 布尔值的方法。
- en: Add an `onLayout` callback to `DatePickerIOS` to calculate its height, saving
    it to state.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `onLayout` 回调添加到 `DatePickerIOS` 以计算其高度，并将其保存到状态中。
- en: Include a `Button` component with a `title` prop that prompts the user to clear
    the due date. Give it an `onPress` prop that will clear the `dateSelected` Boolean
    in state. Also, selectively disable it if the `dateSelected` Boolean is set to
    `false`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个具有`title`属性的`Button`组件，提示用户清除截止日期。给它一个`onPress`属性，当按下时会清除状态中的`dateSelected`布尔值。如果`dateSelected`布尔值设置为`false`，则选择性地禁用它。
- en: Clearing due date example
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除截止日期示例
- en: 'Here''s what I did to get the button to clear a selected date and expand/collapse
    our cells to play nicely:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我为了使按钮能够清除选定的日期并展开/折叠我们的单元格以良好地工作所做的事情：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I wrapped a new `View` around `ExpandableCell`. Its styling is modified based
    on the expanded `Boolean` in the state of `EditTask`. If the component is expanded,
    then its `maxHeight` property is set to the height of its child component. Otherwise,
    it is set to `40` pixels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`ExpandableCell`周围包裹了一个新的`View`。其样式根据`EditTask`状态中的展开`Boolean`进行修改。如果组件被展开，则其`maxHeight`属性设置为子组件的高度。否则，它被设置为`40`像素。
- en: 'Then, pass in the `expanded` and `onPress` props to this component:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`expanded`和`onPress`属性传递给此组件：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Call `_getDatePickerHeight` during the `onLayout` event:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onLayout`事件期间调用`_getDatePickerHeight`：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Button` component is also encapsulated in its own `View`. This is so that
    the `Button` and `ExpandableCell` stack on top of each other:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`组件也被封装在其自己的`View`中。这样做是为了使`Button`和`ExpandableCell`堆叠在一起：'
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set the `dateSelected` Boolean in state to `false`, changing the `title` that
    `ExpandableCell` is passed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态中的`dateSelected`布尔值设置为`false`，更改`ExpandableCell`传递的`title`：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This saves the width of the `DatePickerIOS` component to state:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`DatePickerIOS`组件的宽度保存到状态中：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I added a `clearDateButtonContainer` style to this component''s `StyleSheet`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我向此组件的`StyleSheet`添加了`clearDateButtonContainer`样式：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's continue working on this and build a couple more features into this screen.
    Next up, we should have a field to edit the name of the task at the very top followed
    by a `Switch` component to toggle a complete or an incomplete state for the task.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续工作并在这个屏幕上添加一些更多功能。接下来，我们应该有一个字段来编辑任务名称，紧随其后的是一个用于切换任务完成或不完成状态的`Switch`组件。
- en: Switch
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开关
- en: Switch is a component that renders a Boolean input and allows the user to toggle
    back and forth.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch`是一个渲染布尔输入并允许用户切换的组件。'
- en: 'With `Switch`, these are the props that we will use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Switch`，我们将使用以下属性：
- en: '`onValueChange`: This is a callback that is invoked with the new value of the
    switch when the value changes'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onValueChange`: 这是一个回调，当开关的值改变时，会使用新的开关值被调用'
- en: '`value`: This is a Boolean that determines whether the switch is set to its
    ''on'' position or not; it defaults to `false`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 这是一个布尔值，用于确定开关是否设置为''开启''位置；默认为`false`'
- en: 'A simple `Switch` component can look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`Switch`组件可能看起来像这样：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As stated earlier, `Switch` has two props that are required: its `value` and
    a callback to change its value when toggled.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Switch`有两个必需的属性：其`value`和一个当切换时更改其值的回调。
- en: Using this knowledge, let's make changes to the `TasksList` component so that
    it passes the `completed`, `due`, `formattedDate`, and `text` properties of each
    row to the `EditTask` component for use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，让我们对`TasksList`组件进行修改，使其将每行的`completed`、`due`、`formattedDate`和`text`属性传递给`EditTask`组件以供使用。
- en: 'Then, make additions to the `EditTask` component so that it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向`EditTask`组件添加一些修改，使其：
- en: Expects the `completed`, `due`, `formattedDate`, and `text` props as part of
    its `propTypes` declaration.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望其`propTypes`声明中包含`completed`、`due`、`formattedDate`和`text`属性。
- en: Contains a `TextInput` field that is preloaded with the name of the to-do list
    item and allows the user to edit the name.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个预加载待办事项列表项名称的`TextInput`字段，并允许用户编辑名称。
- en: Adds a `Switch` component that is preloaded with the completion status of the
    to-do list item. When toggled, its completion status should change.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个预加载待办事项列表项完成状态的`Switch`组件。当切换时，其完成状态应改变。
- en: 'This is the solution that I came up with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想出的解决方案：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Pass in the four required fields for `EditTask` so that the view has access
    to rendering a to-do list item's existing details. If the row does not contain
    one or more of these fields, it will pass in `undefined`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将`EditTask`所需的四个字段传递进去，以便视图可以访问渲染待办事项列表项的现有详细信息。如果行不包含这些字段之一或多个，它将传递`undefined`。
- en: Declare the four `propTypes` that this component expects. Since `completed`
    and `text` are the only two that are set when a to-do list item is created by
    the app, they are marked as the required props.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 声明此组件期望的四个`propTypes`。由于当应用程序创建待办事项列表项时，只有`completed`和`text`是设置的，因此它们被标记为必需属性。
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using `props` in state is considered an anti-pattern, but we have them here
    for good reason since we will be modifying these as part of the component.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态中使用`props`被认为是一种反模式，但在这里我们有很好的理由，因为我们将会作为组件的一部分修改这些属性。
- en: In the next section, we will also create a Save button that lets us save the
    to-do item's updated details, and so we need a locally available copy of that
    data in state to reflect the `EditTask` component's changes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们还将创建一个保存按钮，以便我们可以保存待办事项的更新详情，因此我们需要在状态中有一个本地可用的数据副本来反映`EditTask`组件的更改。
- en: 'Render a `TextInput` component to handle changing a to-do list item''s name:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染一个`TextInput`组件来处理更改待办事项列表项的名称：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Render the `Switch` below `ExpandableCell` but above the clear due date `Button`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ExpandableCell`下方但在清除截止日期`Button`上方渲染`Switch`：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following callback methods change the values of `TextInput` and `Switch`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下回调方法更改`TextInput`和`Switch`的值：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A few styling additions for the new components:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为新组件添加一些样式改进：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save button
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存按钮
- en: 'In this section, we will create a button in the upper-right corner of the navigation
    bar that is labeled as `Save`. When it is tapped on, the following two things
    must happen:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在导航栏的右上角创建一个标签为`Save`的按钮。当它被点击时，必须发生以下两件事：
- en: The changes the user made to the to-do item (such as its name, completion status,
    and due date) must be saved to `AsyncStorage`, overwriting its previous details
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户对待办事项所做的更改（如名称、完成状态和截止日期）必须保存到`AsyncStorage`，覆盖其以前的详细信息
- en: The `TasksList` must be updated so that the user visually sees the changes they
    made right away
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TasksList`必须更新，以便用户能够立即看到他们所做的更改'
- en: 'Rendering the `Save` button is easy with React Native. The object that gets
    pushed to `NavigatorIOS` needs to receive the following two key/value pairs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native渲染`Save`按钮很容易。将被推送到`NavigatorIOS`的对象需要接收以下两个键/值对：
- en: '`rightButtonTitle`: This is a string that renders the text shown in that area'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rightButtonTitle`：这是一个字符串，用于显示该区域的文本'
- en: '`onRightButtonPress`: This is a callback that is fired when that button is
    pressed'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRightButtonPress`：这是一个在按下该按钮时触发的回调'
- en: At face value, this looks simple. However, we can't pass any information to
    the `onRightButtonPress` method of `NavigatorIOS` from a rendered child. Instead,
    we have to keep a copy of the changes we make inside our `TasksList` component
    as well, and update them as the `DatePickerIOS`, `TextInput`, and `Switch` components
    within `EditTask` are updated.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，这似乎很简单。然而，我们不能从渲染的子组件传递任何信息到`NavigatorIOS`的`onRightButtonPress`方法。相反，我们必须在我们的`TasksList`组件内部保留我们做出的更改的副本，并在`DatePickerIOS`、`TextInput`和`EditTask`中的`Switch`组件更新时更新它们。
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is no longer an asynchronous function. The part of the function that took
    advantage of `async`/`await` is broken off into `_saveAndUpdateSelectedTask`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这不再是一个异步函数。利用`async`/`await`的部分被拆分为`_saveAndUpdateSelectedTask`。
- en: 'Set the currently edited task object to state:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前编辑的任务对象设置为状态：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add an `onRightButtonPress` callback and string for the right button''s title:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为右按钮添加一个`onRightButtonPress`回调和字符串：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Pass in four new functions to `EditTask` that deal with the item''s details:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 向`EditTask`传递四个新函数来处理项目的详细信息：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add arguments for `_editTask` to accept:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为`_editTask`添加参数以接受：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is the logic previously found in `componentDidMount`. It was broken into
    its own function since `_saveCurrentEditedTask` needs to call it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前在`componentDidMount`中找到的逻辑。由于`_saveCurrentEditedTask`需要调用它，因此将其拆分为自己的函数：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To save the current edited task, we pass the object and `rowID` to `_saveAndUpdateSelectedtask`,
    and then call `pop` on the navigator:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存当前编辑的任务，我们将对象和`rowID`传递给`_saveAndUpdateSelectedtask`，然后对导航器调用`pop`：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function updates the `date` and `formattedDate` of the current edited
    task object:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数更新当前编辑的任务对象的`date`和`formattedDate`：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following function accepts a key and value, creates a clone of `currentEditedTaskObject`
    with the new value, and sets it in state:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受一个键和一个值，创建一个带有新值的`currentEditedTaskObject`的克隆，并将其设置在状态中：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The last two functions'' purpose is to update the `TasksList` local state copy
    of the object being edited. This is done for two reasons:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个函数的目的是更新正在编辑的对象的 `TasksList` 本地状态副本。这是出于两个原因：
- en: Any updates we make to `EditTask`, such as changing the name, completion status,
    and due date, currently do not propagate up to its parent
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对 `EditTask` 所做的任何更新，例如更改名称、完成状态和截止日期，目前都不会传播到其父组件
- en: Additionally, we can't just point the values in `EditTask` to what gets passed
    in as props since the `EditTask` component does not rerender whenever the props
    being passed to it change
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们不能仅仅将 `EditTask` 中的值指向作为 props 传递的内容，因为 `EditTask` 组件不会在传递给它的 props 发生变化时重新渲染。
- en: '`EditTask` gets a couple of changes including new `propTypes` for the component
    to expect:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditTask` 获得了几个更改，包括组件预期的新 `propTypes`：'
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The changes that `EditTask` receives involve calling the functions that are
    passed to it as props to update the parent component''s data for saving:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditTask` 收到的更改涉及调用作为 props 传递给它的函数来更新父组件的数据以保存：'
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: TasksListCell modifications
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`TasksListCell` 修改'
- en: Finally, we want to edit each row rendered by our `ListView` to display the
    due date, if one exists.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望编辑由我们的 `ListView` 渲染的每一行，以显示截止日期（如果存在）。
- en: To do this, we will have to write some conditional logic to show the formatted
    date, if one is assigned to the to-do item we are rendering. This is also a good
    time to create a custom `styles` folder for this component as we will be needing
    it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将不得不编写一些条件逻辑来显示格式化的日期，如果分配给我们要渲染的任务项，这将也是一个创建自定义 `styles` 文件夹的好时机，因为我们将需要它。
- en: 'Spend some time creating your version of this feature. My solution is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间创建您版本的此功能。我的解决方案如下：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You might notice from the above import statement that `TasksListCell` now imports
    its `StyleSheet`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到上面的导入语句中，`TasksListCell` 现在导入了它的 `StyleSheet`。
- en: 'Add `formattedDate` to `propTypes` as an optional string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `formattedDate` 添加到 `propTypes` 中作为可选字符串：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Call `_getDueDate` to render a string for the due date, if it exists:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `_getDueDate` 来渲染截止日期的字符串，如果存在：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This component has been modified to support a second line of text to show a
    due date, but only if it exists.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件已被修改以支持显示截止日期的第二行文本，但前提是它存在。
- en: The logic is set to only display the due date should the task not be marked
    as completed, so that a user won't be confused if they see a due date on a task
    they've already checked off.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑设置为仅在任务未标记为完成时显示截止日期，这样用户就不会在看到他们已经完成的任务的截止日期时感到困惑。
- en: 'Additionally, styling''s been added to make the two lines appear on the same
    row:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还添加了样式以使两行显示在同一行：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here''s a screenshot of how this looks:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![](img/image_02_005-1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_005-1.png)'
- en: 'This is a pretty neat application at this point, and you will be able to make
    more enhancements to it with the skills you''ll pick up in our next project. As
    we wind down this project, I want to turn your attention to a question I often
    receive:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是一个相当不错的应用程序，您将能够使用我们在下一个项目中获得的技能对其进行更多改进。随着我们结束这个项目，我想将您的注意力转向我经常收到的问题：
- en: How would we do it on Android?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 Android 上做这件事？
- en: It's a great question and one that we will explore at the end of each project
    in this book. I will assume that you have already set up your development environment
    to work on Android apps in React Native. If not, go do that before proceeding
    further. If developing for Android is not of any interest to you, feel free to
    skip this portion and move on to the next chapter!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题，我们将在本书每个项目的末尾进行探索。我将假设您已经设置了您的开发环境，以便在 React Native 中开发 Android 应用。如果没有，请在继续之前先做这件事。如果您对开发
    Android 没有兴趣，请随意跳过这部分内容，继续下一章！
- en: Modifying tasks for Android
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 Android 任务
- en: 'First, we need to point to the Android SDK directory in our app''s `Android`
    folder under a new `local.properties` file that you will create. Add the following
    line, where `USERNAME` is your machine''s username:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的应用的 `Android` 文件夹下创建一个新的 `local.properties` 文件，并指向 Android SDK 目录。添加以下行，其中
    `USERNAME` 是您的机器用户名：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If your Android SDK is installed in a different location from the preceding
    example, you will need to modify this file to point to the right place.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Android SDK 安装在与前一个示例不同的位置，您需要修改此文件以指向正确的位置。
- en: 'Then, launch an **Android Virtual Device** (**AVD**) and execute the `react-native
    run-android` command in your project''s root folder. You will see the following
    screen, which looks just like the default template when we first built `Tasks`
    for iOS:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动一个**Android虚拟设备**（**AVD**），在项目根目录下执行`react-native run-android`命令。您将看到以下屏幕，这与我们最初为iOS构建`Tasks`时的默认模板看起来几乎一样：
- en: '![](img/image_02_006-1.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_006-1.png)'
- en: When working in Android, press `RR` to reload the app and *Command* + *M* to
    enter the Developer menu.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上工作时，按`RR`重新加载应用，并使用*Command* + *M*进入开发者菜单。
- en: You may find that, with remote JS debugging turned on, animations from simple
    things, such as `TouchableHighlight` shadows and navigation, can be painfully
    slow. At the time of writing, some technical solutions are being proposed to address
    this issue but, for the time being, it's strongly recommended that you enable
    and disable remote JS debugging as necessary.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现，当远程JS调试开启时，从简单事物（如`TouchableHighlight`阴影和导航）的动画可能会非常缓慢。在撰写本文时，一些技术解决方案正在被提出以解决这个问题，但在此期间，强烈建议您根据需要启用和禁用远程JS调试。
- en: Navigator
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航器
- en: 'The `Navigator` component works a bit differently from its native iOS component,
    but it''s still very powerful to work with. One of the changes with using `Navigator`
    is that your routes should be explicitly defined. We can do this by setting up
    an array of routes and rendering a specific scene based on which route we''re
    accessing. Here''s a sample:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Navigator`组件的工作方式与其原生iOS组件略有不同，但它仍然非常强大。使用`Navigator`的一个变化是，您的路由应该明确定义。我们可以通过设置路由数组并根据我们访问的路由渲染特定的场景来实现这一点。以下是一个示例：'
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Create a `routes` array, as shown in the preceding code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`routes`数组，如前述代码所示。
- en: 'You might notice that we are explicitly defining our routes from the beginning,
    setting up an initial route and then passing in props to each route''s component
    here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们从一开始就明确定义了我们的路由，设置了一个初始路由，然后在这里将属性传递给每个路由的组件：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The route object passed in to `_renderScene` contains a `passProps` object,
    which we can set when pushing the navigator.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`_renderScene`的路由对象包含一个`passProps`对象，我们可以在推送导航时设置它。
- en: 'Instead of passing our component when pushing into the `Navigator`, we pass
    it an `index`; this is where the `_renderScene` method of `Navigator` identifies
    which scene to show the user. Here is how pushing to the `Navigator` looks:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在将组件推送到`Navigator`时，我们不传递组件，而是传递一个`index`；这是`Navigator`的`_renderScene`方法确定要向用户显示哪个场景的地方。以下是推送`Navigator`的方式：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is how we would use the Navigator component to push different routes.
    Notice that instead of passing a component like in in `NavigatorIOS`, we are passing
    the index of the route:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用导航器组件推送不同路由的方式。请注意，与`NavigatorIOS`中传递组件的方式不同，我们传递的是路由的索引：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you're comparing this to how we rendered `EditTask` in iOS, you'll note that
    we're not setting up our navigation bar at all. Android apps typically handle
    navigation through a combination of `Drawer` and `ToolbarAndroid` components that
    we will address in a later project. This will help our app by making it look and
    feel the way any Android app should.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此与我们在iOS中渲染`EditTask`的方式进行比较，您会注意到我们根本就没有设置导航栏。Android应用通常通过`Drawer`和`ToolbarAndroid`组件的组合来处理导航，我们将在稍后的项目中解决这些问题。这将帮助我们的应用看起来和感觉就像任何Android应用一样。
- en: Navigator example
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航器示例
- en: 'The following code is an example for Navigator:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是导航器的示例：
- en: '[PRE67]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Again, establish routes for our app.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为我们的应用建立路由。
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Import the `Navigator` component and render it for the user. It starts at `index:``0`,
    which returns the `TasksList` component.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`Navigator`组件并为用户渲染它。它从`index:``0`开始，返回`TasksList`组件。
- en: 'It returns `TasksList` if the index is `0`. This is the default `route`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引是`0`，则返回`TasksList`。这是默认的`route`：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the route index is 1, return `EditTask`. It will receive the aforementioned
    props via the `passProps` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由索引是1，则返回`EditTask`。它将通过`passProps`方法接收上述属性：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: At this stage, without making further modifications, we can create new to-do
    items and mark them as completed. However, because the `Navigator` component's
    push method accepts different arguments than the push method of iOS, we will need
    to create some conditional logic in the `TasksList` file to accommodate it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，无需进行进一步修改，我们就可以创建新的待办事项并将它们标记为已完成。然而，由于`Navigator`组件的推送方法接受的参数与iOS的推送方法不同，我们将在`TasksList`文件中创建一些条件逻辑来适应它。
- en: Platform
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台
- en: When your files have such little variance in the differences between their iOS
    and Android functionalities, it's okay to use the same file. Utilizing the `Platform`
    API, we can identify the type of mobile device the user is on and conditionally
    send them down a specific path.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的文件在iOS和Android功能之间的差异很小，使用相同的文件是可以的。利用`Platform` API，我们可以识别用户所使用的移动设备类型，并条件性地将他们引导到特定的路径。
- en: 'Import the `Platform` API along with the rest of your React Native components:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的其他React Native组件一起导入`Platform` API：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then call its `OS` property within a component:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在组件中调用其`OS`属性：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This lets us control the path our app takes and allows for a little bit of code
    reuse.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够控制应用所走的路径，并允许进行一些代码复用。
- en: Android-specific filesIf we need to create a file that is supposed to only run
    on Android devices, simply name it `<FILENAME>.android.js`, just like the two
    index files. React Native will know exactly which file to build with, and this
    lets us create components that are platform-specific when we need to add a lot
    of logic that one universal `index.js` file shouldn't handle. Name files `<FILENAME>.ios.js`
    to set iOS-specific files too.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Android特定文件如果需要创建一个仅在Android设备上运行的文件，只需将其命名为`<FILENAME>.android.js`，就像两个索引文件一样。React
    Native将确切知道要构建哪个文件，这让我们能够在需要添加大量逻辑而一个通用的`index.js`文件无法处理时创建特定平台的组件。将文件命名为`<FILENAME>.ios.js`以设置iOS特定文件。
- en: 'Using the `Platform` API, we can create conditional logic to decide how the
    `Navigator` should push the next component depending on the user''s platform.
    Import the `Platform` API:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Platform` API，我们可以创建条件逻辑来决定`Navigator`应根据用户的平台如何推送下一个组件。导入`Platform` API：
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Modify the styling of `TextInput` based on the user''s platform so that it
    has a design language that resonates with its platform. On Android, it is usually
    displayed as a single underline without any border; so, we eliminate the border
    in the Android-specific styling of this component:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的平台修改`TextInput`的样式，使其具有与其平台相呼应的设计语言。在Android上，它通常显示为没有边框的单条下划线；因此，我们在该组件的Android特定样式中消除了边框：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'I changed the `_editTask` function to run conditional logic. If our platform
    is iOS, we call `_renderIOSEditTaskComponent`; otherwise, our platform must be
    Android and we call `_renderAndroidEditTaskComponent` instead:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`_editTask`函数改为运行条件逻辑。如果我们的平台是iOS，我们调用`_renderIOSEditTaskComponent`；否则，我们的平台必须是Android，我们调用`_renderAndroidEditTaskComponent`代替：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding code pushes the `index` of `EditTask` to the Navigator. It passes
    the same props that the iOS version of the app previously passed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`EditTask`的`index`推送到导航器。它传递了iOS版本的应用之前传递的相同属性。
- en: 'The contents of `_renderIOSEditTaskComponent` are the same as those that `_editTask`
    previously contained:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`_renderIOSEditTaskComponent`的内容与`_editTask`之前包含的内容相同：'
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the following code we added a custom Android style for `TextInput`, omitting
    the border:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们为`TextInput`添加了一个自定义的Android样式，省略了边框：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: DatePickerAndroid and TimePickerAndroid
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DatePickerAndroid 和 TimePickerAndroid
- en: Setting a time and date on Android is much different from iOS. With iOS, you
    have a `DatePickerIOS` component that includes both the date and time. On Android,
    this is split into two native modals, `DatePickerAndroid` for the date and `TimePickerAndroid`
    for the time. It's not a component to render either, it's an asynchronous function
    that opens the modal and waits for a natural conclusion before applying logic
    to it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上设置时间和日期与iOS大不相同。在iOS上，你有一个包含日期和时间的`DatePickerIOS`组件。在Android上，这被分为两个原生模态，`DatePickerAndroid`用于日期，`TimePickerAndroid`用于时间。它不是一个用于渲染的组件，而是一个异步函数，它打开模态并等待自然结束，然后再应用逻辑。
- en: 'To open one of these, wrap an asynchronous function around it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开其中一个，将其包裹在一个异步函数中：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Both the `DatePickerAndroid` and `TimePickerAndroid` components return an object,
    and we can grab the properties of each object by using ES6 destructuring assignment,
    as shown in the preceding snippet.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePickerAndroid`和`TimePickerAndroid`组件都返回一个对象，我们可以通过使用ES6解构赋值来获取每个对象的属性，如前一个片段所示。'
- en: As these components will render as modals by default, we also don't have any
    use for the `ExpandableCell` component that we built for the iOS version of the
    app. To implement Android-specific date and time pickers, we should create an
    Android-specific `EditTask` component to handle it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些组件默认将渲染为模态，所以我们也没有必要使用为iOS版本的应用构建的`ExpandableCell`组件。为了实现Android特定的日期和时间选择器，我们应该创建一个处理此功能的Android特定`EditTask`组件。
- en: Rather than an expanding cell, we should create another `Button` component to
    open and close the dialog boxes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是扩展单元格，我们应该创建另一个 `Button` 组件来打开和关闭对话框。
- en: In the example given in the following section, I cloned the iOS `index.js` file
    for `EditTask` and renamed it `index.android.js` before making changes to it.
    Any code that has not changed from the iOS version has been omitted. Anything
    that has been deleted has also been noted.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节给出的示例中，我克隆了 `EditTask` 的 iOS `index.js` 文件，并将其重命名为 `index.android.js`，然后再对其进行修改。省略了未从
    iOS 版本更改的任何代码。已删除的内容也已注明。
- en: DatePickerAndroid and TimePickerAndroid example
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DatePickerAndroid 和 TimePickerAndroid 示例
- en: 'Remove `DatePickerIOS` and `ExpandableCell` from the import statements:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从导入语句中移除 `DatePickerIOS` 和 `ExpandableCell`：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'I removed the `expanded` Boolean from state in this component''s `constructor`
    function:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我已从该组件的 `constructor` 函数中移除了状态中的 `expanded` 布尔值：
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This new `Button` for `DatePicker` calls `_showAndroidDatePicker` when pressed.
    It is placed right below `TextInput` and replaces `ExpandableCell`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `DatePicker` 按钮在按下时会调用 `_showAndroidDatePicker`。它放置在 `TextInput` 下方并替换了
    `ExpandableCell`：
- en: '[PRE81]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'There have been no changes to the clear due date `Button`, but its styling
    has changed:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 清除截止日期的 `Button` 没有发生变化，但其样式已更改：
- en: '[PRE82]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'An asynchronous function that calls `open` on `DatePickerAndroid` extracts
    the `action`, `year`, `month`, and `day`, sets them to state, and then calls `_showAndroidTimePicker`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一个异步函数在 `DatePickerAndroid` 上调用 `open`，提取 `action`、`year`、`month` 和 `day`，将它们设置为状态，然后调用
    `_showAndroidTimePicker`：
- en: '[PRE83]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following is the same strategy we used with `_showAndroidDatePicker` before,
    but calls `_onDateChange` at the end:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前用于 `_showAndroidDatePicker` 的相同策略，但在最后调用 `_onDateChange`：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create a new instance of the `Date` object using the five combined values that
    `DatePickerAndroid` and `TimePickerAndroid` return:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DatePickerAndroid` 和 `TimePickerAndroid` 返回的五个组合值创建一个新的 `Date` 对象：
- en: '[PRE85]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'I removed `_getDatePickerHeight` and `_onExpand` since they pertain to parts
    of `EditTask` that are not available in the `Android` version of the app. I added
    some styling changes to this component as well:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我已移除 `_getDatePickerHeight` 和 `_onExpand`，因为它们与 `EditTask` 的部分相关，这些部分在 `Android`
    版本的 app 中不可用。我还为此组件添加了一些样式更改：
- en: '[PRE86]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Saving updates
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存更新
- en: As we aren't using a navigation bar with the Android version of the app, we
    should create a Save button that handles the same save logic.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不在 Android 版本的 app 中使用导航栏，我们应该创建一个处理相同保存逻辑的保存按钮。
- en: 'First, we should modify `index.android.js` to pass a `saveCurrentEditedTask`
    prop to `EditTask` from the `TasksList` component:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该修改 `index.android.js` 以将 `saveCurrentEditedTask` 属性从 `TasksList` 组件传递给
    `EditTask`：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, modify `TasksList` to pass the `_saveCurrentEditedTask` method to `EditTask`
    in `_renderAndroidEditTaskComponent`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改 `TasksList` 以在 `_renderAndroidEditTaskComponent` 中将 `_saveCurrentEditedTask`
    方法传递给 `EditTask`：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'After this, modify the Android version of `EditTask` to contain a new `Button`
    that calls its `saveCurrentEditedTask` when pressed:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，修改 `EditTask` 的 Android 版本以包含一个新按钮，当按下时会调用其 `saveCurrentEditedTask` 方法：
- en: '[PRE89]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, add some styling with a new `saveButton` property:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用新的 `saveButton` 属性添加一些样式：
- en: '[PRE90]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: BackAndroid
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BackAndroid
- en: The last thing we need to handle is the back button. A universal back button,
    either a hardware or software implementation, is found on each Android device.
    We will need to use the `BackAndroid` API to detect back button presses and set
    our own custom functionality. If we don't do this, the back button will automatically
    close the app each time it is pressed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的最后一件事是返回按钮。每个 Android 设备上都有一个通用的返回按钮，无论是硬件还是软件实现。我们需要使用 `BackAndroid`
    API 来检测返回按钮的按下并设置我们自己的自定义功能。如果我们不这样做，每次按下返回按钮时，应用程序都会自动关闭。
- en: To use it, we can add an event listener during the `componentWillMount` life
    cycle event that will pop the navigator when a back button press is detected.
    We can also remove the listener when the component is unmounted.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们可以在 `componentWillMount` 生命周期事件中添加一个事件监听器，当检测到返回按钮按下时会弹出导航器。我们还可以在组件卸载时移除监听器。
- en: 'During `componentWillMount`, add an event listener to the `BackAndroid` API
    for a `hardwareButtonPress` event, firing `_backButtonPress` when triggered:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `componentWillMount` 期间，向 `BackAndroid` API 添加一个 `hardwareButtonPress` 事件的事件监听器，当触发时调用
    `_backButtonPress`：
- en: '[PRE91]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Remove the same listener if the component is unmounted:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件被卸载，则移除相同的监听器：
- en: '[PRE92]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Call `pop` on the navigator with `_backButtonPress`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `_backButtonPress` 在导航器上调用 `pop`：
- en: '[PRE93]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a long chapter! We accomplished a lot of things. First, we used `NavigatorIOS`
    to establish custom routes and created a component to edit a to-do item's details,
    including marking it as completed and adding a due date.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章很长的内容！我们完成了很多事情。首先，我们使用`NavigatorIOS`来建立自定义路由，并创建了一个组件来编辑待办事项的详细信息，包括将其标记为已完成和添加截止日期。
- en: Then, we built a custom, reusable component with fluid animations to expand
    and collapse a child component, allowing `DatePickerIOS` to expand and collapse
    as needed. Afterward, we implemented logic to save the changes we make to a task
    using the navigation bar.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了一个具有流畅动画的自定义、可重用组件，用于展开和折叠子组件，使得`DatePickerIOS`可以根据需要展开和折叠。之后，我们实现了逻辑，以便使用导航栏保存我们对任务所做的更改。
- en: We also ported our app to support the Android operating system! We started by
    swapping out `NavigatorIOS` for `Navigator`, using the `Platform` API to trigger
    conditional logic depending on the type of mobile device our user is on, and creating
    iOS-and Android-specific components by appending `.android` and `.ios` to each
    index file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将我们的应用程序移植到支持Android操作系统！我们首先将`NavigatorIOS`替换为`Navigator`，使用`Platform` API根据用户所使用的移动设备类型触发条件逻辑，并通过在每个索引文件后附加`.android`和`.ios`来创建iOS和Android特定的组件。
- en: We finished up the port to Android by rendering date and time pickers on Android,
    which are two separate popups, and creating a save button within our Android-specific
    `EditTask` component so that our users can save the changes they made. Finally,
    listening for back button presses with the `BackAndroid` API allowed our users
    to go back from editing a to-do item to the to-do list screen instead of leaving
    the app entirely.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在Android上渲染日期和时间选择器完成了对Android的移植，这两个选择器是两个独立的弹出窗口，并在我们特定的`EditTask`组件内创建了一个保存按钮，以便我们的用户可以保存他们所做的更改。最后，通过使用`BackAndroid`
    API监听返回按钮的点击，允许我们的用户从编辑待办事项返回到待办事项列表屏幕，而不是完全离开应用程序。
