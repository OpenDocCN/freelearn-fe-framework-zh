- en: Introduction to ReasonML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReasonML 简介
- en: The last decade has seen numerous paradigm shifts in the way we build user interfaces.
    Web applications have moved from server-side frameworks to client-side frameworks
    in order to provide better user experiences. Devices and browsers have become
    powerful enough to run robust client-side applications, and the JavaScript language
    itself has seen many improvements over the years. Progressive web apps provides
    a native-like user experience and WebAssembly allows for native-like performance on
    the web platform. An increasing number of applications are being built for the
    browser, resulting in larger client-side codebases needing to be maintained.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过去十年，我们在构建用户界面的方式上经历了多次范式转变。Web应用程序已经从服务器端框架转移到客户端框架，以提供更好的用户体验。设备和浏览器已经足够强大，可以运行健壮的客户端应用程序，而JavaScript语言本身在多年中也经历了许多改进。渐进式Web应用程序提供了类似原生的用户体验，WebAssembly允许在Web平台上实现类似原生的性能。越来越多的应用程序正在为浏览器构建，导致需要维护的客户端代码库越来越大。
- en: During this period, several frameworks, libraries, tools, and general best practices
    gained and then lost popularity, resulting in **JavaScript fatigue** for many
    developers. Companies are becoming increasingly cautious in committing to newer
    technologies due to their impact on hiring and retaining engineering talent, as
    well as productivity and maintainability. It can be an expensive mistake if you
    introduce the wrong technology (or the right technology at the wrong time) to
    your team.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时期，几个框架、库、工具和一般最佳实践获得了流行，然后又失去了流行，导致许多开发者感到**JavaScript疲劳**。由于新技术对招聘和保留工程人才、生产力和可维护性的影响，公司越来越谨慎地承诺采用新技术。如果向团队引入错误的技术（或错误时机上的正确技术），这可能是一个代价高昂的错误。
- en: For many companies and developers, React has proven to be a solid choice. In
    2013, Facebook made the library open source after having used it internally since
    2011\. They challenged us to rethink best practices ([https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be))
    and it has since taken over frontend development ([https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76)).
    Encapsulating markup, behavior, and style into reusable components has become
    a huge productivity and maintainability win. The abstraction of the DOM has allowed
    for components to be simple, declarative functions of its props that are easy
    to reason about, compose, and test.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多公司和开发者来说，React已经被证明是一个可靠的选择。2013年，Facebook在2011年开始内部使用该库后将其开源。他们挑战我们重新思考最佳实践([https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be))，并且它已经接管了前端开发([https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76))。将标记、行为和样式封装到可重用组件中已经成为一个巨大的生产力和可维护性的胜利。DOM的抽象使得组件可以简单地成为其props的声明性函数，这使得推理、组合和测试变得容易。
- en: Via React, Facebook has done an incredible job educating the frontend-developer
    community on traditional functional programming paradigms that make it easier
    to reason about and maintain code. And now, Facebook believes the time is right
    for ReasonML.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过React，Facebook已经在前端开发者社区中做了令人难以置信的工作，教育他们关于传统的函数式编程范式，这些范式使得推理和维护代码变得更加容易。现在，Facebook认为现在是ReasonML的时机。
- en: 'This is a two-year chart from [npmtrends.com](https://www.npmtrends.com/) that
    shows the number of weekly npm downloads for some of the top JavaScript libraries
    and frameworks. ReactJS looks to be a clear winner and has reached over 2,500,000
    downloads per week:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张来自[npmtrends.com](https://www.npmtrends.com/)的两年图表，显示了某些顶级JavaScript库和框架每周的npm下载量。ReactJS看起来是一个明显的赢家，每周下载量超过2,500,000次：
- en: '![](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)'
- en: npmtrends.com
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: npmtrends.com
- en: 'In this chapter, we''ll do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行以下内容：
- en: Discuss what ReasonML is and what problems it tries to solve
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论ReasonML是什么以及它试图解决的问题
- en: Understand some of the reasons why Facebook chose ReasonML as the future of
    ReactJS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Facebook选择ReasonML作为ReactJS未来的原因
- en: Experiment with ReasonML in an online playground and examine its compiled (JavaScript)
    output
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在在线沙盒中尝试ReasonML并检查其编译（JavaScript）输出
- en: What is ReasonML?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReasonML是什么？
- en: Reason is a layer of syntax & tooling on top of OCaml, a language Facebook uses
    actively. Jordan [Walke] started the concept of Reason before React, in fact.
    We’re taking it and using it as an actual frontend language (among other uses)
    because we think that after three and half years, the React experiment has succeeded
    and people are now ready for Reason...
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 是 OCaml 语法和工具层，Facebook 正在积极使用的一种语言。乔丹 [Walke] 在 React 之前就提出了 Reason
    的概念。事实上，我们正在将其用作实际的（前端）语言（以及其他用途），因为我们认为经过三年半的时间，React 的实验已经成功，人们现在准备好使用 Reason
    了...
- en: – Cheng Lou, January, 2017
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: – Cheng Lou，2017 年 1 月
- en: ([https://www.reactiflux.com/transcripts/cheng-lou/](https://www.reactiflux.com/transcripts/cheng-lou/))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://www.reactiflux.com/transcripts/cheng-lou/](https://www.reactiflux.com/transcripts/cheng-lou/))
- en: Let's expand on this quote. ReasonML is not a new language; it's a new syntax
    for the OCaml language that is meant to be familiar to JavaScript developers.
    Reason, as we'll call it from now on, has the exact same AST as OCaml, so Reason
    and OCaml only differ by syntax. The semantics are the same. By learning Reason,
    you're also learning OCaml. In fact, there's a command-line tool that converts
    between OCaml and Reason syntax, called `refmt`, which formats Reason/OCaml code
    similar to JavaScript's prettier—in fact, prettier was inspired by `refmt`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这句话。ReasonML 不是一个新的语言；它是 OCaml 语言的全新语法，旨在让 JavaScript 开发者感到熟悉。从现在起，我们将称之为
    Reason，它具有与 OCaml 完全相同的抽象语法树（AST），因此 Reason 和 OCaml 只在语法上有所不同。语义是相同的。通过学习 Reason，你也在学习
    OCaml。实际上，有一个命令行工具可以在 OCaml 和 Reason 语法之间进行转换，称为 `refmt`，它将 Reason/OCaml 代码格式化为类似
    JavaScript 的 prettier——实际上，prettier 就是受到了 `refmt` 的启发。
- en: OCaml is a general-purpose programming language with an emphasis on expressiveness
    and safety. It was initially released in 1996 and has an advanced type system
    that helps catch your mistakes without getting in the way. Like JavaScript, OCaml
    features garbage collection for automatic memory management and first-class functions
    that can be passed around as arguments to other functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OCaml 是一种注重表达性和安全性的通用编程语言。它最初于 1996 年发布，拥有一个高级类型系统，可以帮助你捕捉错误而不会妨碍你的工作。和 JavaScript
    一样，OCaml 具有垃圾回收功能，用于自动内存管理，以及可以像其他函数的参数一样传递的一等函数。
- en: Reason is also a toolchain that makes getting started easier for those coming
    from a JavaScript background. This toolchain allows us to take advantage of both
    the JavaScript and OCaml ecosystems. We will dive deeper here in [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml),
    *Setting Up a Development Environment*. For now, we'll experiment directly in
    the online playground by visiting Reason's online playground at [https://reasonml.github.io/try](https://reasonml.github.io/try).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 也是一个工具链，对于那些来自 JavaScript 背景的人来说，它使得入门变得更加容易。这个工具链允许我们利用 JavaScript 和
    OCaml 生态系统的优势。我们将在[第 2 章](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml)“设置开发环境”中深入探讨。现在，我们将直接在在线沙盒中通过访问
    Reason 的在线沙盒 [https://reasonml.github.io/try](https://reasonml.github.io/try)
    来进行实验。
- en: 'Try typing in this Hello World example into the online playground:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将这个“Hello World”示例输入到在线沙盒中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are two things you''ll notice:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到两件事：
- en: The OCaml syntax is automatically generated in the lower-left section of the
    editor (not shown)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCaml 语法将在编辑器的左下角自动生成（未显示）
- en: 'The Reason/OCaml code is compiled to JavaScript directly in the browser:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reason/OCaml 代码直接在浏览器中编译成 JavaScript：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may be wondering how the Reason/OCaml code is being compiled from within
    the browser. BuckleScript, Reason's partner project, compiles the OCaml AST to
    JavaScript. Since Reason and OCaml both get converted into the same OCaml AST,
    BuckleScript supports both Reason and OCaml. Furthermore, since BuckleScript is
    itself written in OCaml, it can be compiled to JavaScript and run directly in
    the browser.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道 Reason/OCaml 代码是如何在浏览器中编译的。BuckleScript，Reason 的合作伙伴项目，将 OCaml AST 编译成
    JavaScript。由于 Reason 和 OCaml 都会被转换成相同的 OCaml AST，BuckleScript 支持Reason 和 OCaml。此外，由于
    BuckleScript 本身是用 OCaml 编写的，它可以编译成 JavaScript 并直接在浏览器中运行。
- en: 'Inspecting the compiled JavaScript reveals just how readable it is. Looking
    closer, you''ll notice that the compiled output has also been optimized: within
    the `console.log` statement, the `"Hello World"` string has been inlined directly
    instead of using the `message` variable.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 检查编译后的 JavaScript 可以发现它有多么易于阅读。仔细观察，你会发现编译后的输出也进行了优化：在 `console.log` 语句中，`"Hello
    World"` 字符串被直接内联，而不是使用 `message` 变量。
- en: BuckleScript, using features of the OCaml type-system and compiler implementation
    is able to provide many optimizations during offline compilation, allowing the
    runtime code to be extremely fast.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript利用OCaml类型系统和编译器实现的功能，能够在离线编译期间提供许多优化，使得运行时代码非常快速。
- en: – BuckleScript docs
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: – BuckleScript文档
- en: ([https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)
- en: 'Notably, BuckleScript also supports string interpolation ([https://bucklescript.github.io/docs/en/common-data-types.html#interpolation](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，BuckleScript还支持字符串插值([https://bucklescript.github.io/docs/en/common-data-types.html#interpolation](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation))：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Why Reason?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Reason？
- en: What makes Reason so compelling? What can Reason do that TypeScript or Flow
    cannot? Is it just about having a static type-checker? These are some of the questions
    I had when first getting started with Reason.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Reason为什么如此吸引人？Reason能做什么是TypeScript或Flow所不能做的？仅仅是拥有静态类型检查器吗？这些问题是我刚开始接触Reason时产生的疑问。
- en: Support for immutability and purity
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不可变性和纯度
- en: Reason isn't just about having a static type system. Also important is the fact
    that Reason is immutable by default. Immutability is an important concept in functional
    programming. In practice, using immutable data structures (data structures that
    can't change) results in safer, easier-to-reason-about, and more maintainable
    code than their mutable counterparts. This will be a recurring theme throughout
    this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Reason不仅仅是拥有静态类型系统。同样重要的是，Reason默认是不可变的。不可变性是函数式编程中的一个重要概念。在实践中，使用不可变的数据结构（无法改变的数据结构）比它们可变的对应物产生更安全、更容易推理和更易于维护的代码。这一点将在整本书中反复出现。
- en: 'Purity is another important concept in functional programming. A function is
    said to be pure if its output is determined only by its input, without observable
    side-effects. In other words, a pure function doesn''t do anything outside of
    returning a value. The following is an example of a pure function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 纯度是函数式编程中的另一个重要概念。如果一个函数的输出仅由其输入决定，没有可观察的副作用，那么这个函数被认为是纯函数。换句话说，一个纯函数除了返回一个值之外，不做任何其他事情。以下是一个纯函数的示例：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, this is an example of an impure function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是一个不纯函数的示例：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The side-effect in this case is writing to the browser's console. That's why,
    in our preceding `Hello World` example, BuckleScript included the `/* Not a pure
    module */` comment at the end of the compiled output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，副作用是向浏览器的控制台写入。这就是为什么在我们的前一个`Hello World`示例中，BuckleScript在编译输出的末尾包含了`/*
    Not a pure module */`注释。
- en: 'Mutating a global variable is also a side-effect. Consider the following JavaScript:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 修改全局变量也是一种副作用。考虑以下JavaScript代码：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The global object was mutated, and now its `total` property is `42`. We now
    have to be aware of all areas where this `globalObject` is mutated whenever using
    it. Forgetting that this object is both global and mutable can lead to hard-to-debug
    problems. One idiomatic solution to this problem is to move `globalObject` into
    a module where it's no longer global. This way, only that module has access to
    it. However, we'd still need to be aware of all areas within this module that
    can update the object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象被修改了，现在它的`total`属性是`42`。我们现在必须意识到所有在使用`globalObject`时可能对其进行修改的区域。忘记这个对象既是全局的又是可变的可能会导致难以调试的问题。解决这个问题的惯用方法是将`globalObject`移动到一个模块中，使其不再全局。这样，只有那个模块可以访问它。然而，我们仍然需要意识到这个模块内所有可以更新该对象的区域。
- en: 'If `globalObject` was immutable instead, there would be no way to mutate it.
    Therefore, we wouldn''t need an awareness of all the areas that can mutate `globalObject`,
    since there wouldn''t be any of these areas. We''ll see that, with Reason, it''s
    fairly simple and natural to build real applications in this way by creating updated
    copies of the original data. Consider the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`globalObject`是不可变的，那么将无法对其进行修改。因此，我们不需要意识到所有可能修改`globalObject`的区域，因为这些区域将不存在。我们将看到，使用Reason，通过创建原始数据的更新副本，以这种方式构建真实的应用程序相当简单且自然。考虑以下示例：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The syntax feels quite natural. As we'll see later in this book, immutability—changing
    by returning updated copies instead of applying destructive changes in place—fits
    the React/Redux way of doing things quite well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 语法感觉非常自然。正如我们将在本书后面看到的那样，不可变性——通过返回更新后的副本而不是在原地应用破坏性更改来改变——非常适合React/Redux的工作方式。
- en: 'The original `foo` was not mutated; it was shadowed. Once shadowed, the old
    `foo` binding is unavailable. Bindings can be shadowed in local scopes as well
    as global scopes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`foo`没有被修改；它被阴影了。一旦被阴影，旧的`foo`绑定就不可用了。绑定可以在局部作用域以及全局作用域中被阴影：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Trying to mutate `foo` results in a compilation error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改`foo`会导致编译错误：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that immutability and purity are related topics. Having a language
    that supports immutability allows you to program in a pure way without side-effects.
    However, what if there are times when purity would cause the code to become more
    complex and harder to reason about than using side-effects? You may be relieved
    to learn that Reason (interchangeable with OCaml throughout the rest of this book)
    is a pragmatic language that let's us cause side-effects when needed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到不可变性和纯度是相关的话题。拥有支持不可变性的语言允许你在没有副作用的情况下以纯方式编程。然而，如果纯度会导致代码比使用副作用更复杂、更难以推理，你可能会感到欣慰。Reason（在本书的其余部分与OCaml可互换）是一种实用主义语言，它允许我们在需要时产生副作用。
- en: The key thing when using a language like [Reason] is not to avoid side-effects,
    because avoiding side-effects is equivalent to avoiding doing anything useful.
    It turns out, in reality, programs don't just *compute* things, they *do *things.
    They send messages and they write files and they do all sorts of stuff. The doing
    of things is automatically involving side-effects. The thing that a language which
    supports purity gives you, is it gives you the ability to, by and large, segment
    out the part that is side-effecting to clear and controlled areas of your code,
    and that makes it much easier to reason about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像[Reason]这样的语言时，关键不是避免副作用，因为避免副作用等同于避免做任何有用的事情。实际上，程序不仅仅是*计算*事物，它们*做*事情。它们发送消息，写入文件，做各种各样的事情。做事情的过程会自动涉及副作用。支持纯度的语言给你带来的好处是，它让你能够大致地将涉及副作用的代码部分分割出来，使其成为清晰且可控的代码区域，这使得推理变得更加容易。
- en: – Yaron Minsky
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: – Yaron Minsky
- en: ([https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s))
- en: It's also important to know that immutability doesn't come at the cost of performance.
    Under the hood, there are optimizations in place that keeps Reason's immutable
    data structures fast.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是，不可变性不会以性能为代价。在底层，有优化措施在位，以保持Reason的不可变数据结构快速。
- en: Module system
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统
- en: Reason has a sophisticated module system that allows for modular development
    and code organization. All modules are globally available in Reason, and module
    interfaces can be used to hide implementation details when needed. We will be
    exploring this concept in [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml),
    *Effective ML*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Reason有一个复杂的模块系统，允许模块化开发和代码组织。在Reason中，所有模块都是全局可用的，并且当需要时，模块接口可以用来隐藏实现细节。我们将在[第5章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)，*有效的ML*中探讨这个概念。
- en: Type system
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统
- en: Reason's type system is sound, which means that, once compiled, there won't
    be runtime type errors. There is no `null` in the language, nor are there any
    bugs related to `null`. In JavaScript, when something is of the `number` type,
    it can also be `null`. Reason uses a special type for things that can also be
    `null`, and forces the developer to handle those cases appropriately by refusing
    to compile otherwise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Reason的类型系统是健全的，这意味着一旦编译，就不会有运行时类型错误。语言中没有`null`，也没有与`null`相关的任何错误。在JavaScript中，当某物是`number`类型时，它也可以是`null`。Reason为也可以是`null`的事物使用一个特殊的类型，并强制开发者通过拒绝编译来适当地处理这些情况。
- en: So far, we've already written some, albeit basic, Reason code without even talking
    about types. Reason infers types automatically. As we'll learn throughout this
    book, the type system is a tool that provides guarantees without getting in our
    way, and when used properly, can allow us to offload things to the compiler that
    we used to keep in our heads.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在不讨论类型的情况下编写了一些，尽管是基本的，Reason代码。Reason可以自动推断类型。正如我们将在整本书中学到的，类型系统是一个提供保证而不妨碍我们的工具，并且当正确使用时，可以让我们将以前需要记住的事情卸载到编译器中。
- en: Reason's support for immutable programming, sound type system, and sophisticated
    module system are big parts of why Reason is so great, and there's something to
    be said about using all of these features together in one language that was built
    with these features in mind. When Facebook initially released React, they asked
    us to give it five minutes ([https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes))
    and, hopefully, that same frame of mind will pay off here as well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 对不可变编程、稳健的类型系统和复杂的模块系统的支持是Reason之所以如此出色的主要原因之一，而且在使用一个考虑到这些特性的语言中同时使用所有这些特性确实有可说之处。当Facebook最初发布React时，他们要求我们给它五分钟的时间([https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes))，并且，希望同样的心态在这里也能得到回报。
- en: Cross-platform
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台
- en: Building React applications with Reason is a lovely experience and, what's more,
    since OCaml is able to compile to native, we will be able to use these same skills
    to build apps that compile to assembly, iOS/Android, and much more. In fact, Jared
    Forsyth has already created a game called Gravitron ([https://github.com/jaredly/gravitron](https://github.com/jaredly/gravitron))
    that compiles to iOS, Android, web, and macOS from one Reason codebase. That being
    said, the frontend JavaScript story is much more polished as of this writing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Reason构建React应用是一种愉快的体验，更重要的是，由于OCaml能够编译成原生代码，我们将能够使用这些相同的技能来构建编译成汇编、iOS/Android等更多平台的app。实际上，Jared
    Forsyth已经创建了一个名为Gravitron([https://github.com/jaredly/gravitron](https://github.com/jaredly/gravitron))的游戏，它可以从一个Reason代码库编译到iOS、Android、网页和macOS。尽管如此，截至本文撰写时，前端JavaScript的故事已经变得更加完善。
- en: Maintainability
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: Reason may take some time to get comfortable with, but you can think of this
    time as an investment in the maintenance and confidence of your future product.
    Although languages with gradual type systems, such as TypeScript, may be easier
    to get started with, they don't provide the sorts of guarantees that a sound type
    system such as Reason's can provide. Reason's true benefits cannot be completely
    conveyed within simple examples, and only really shine when they save you time
    and energy in reasoning about, refactoring, and maintaining your code. Put it
    this way; if someone told me they were 99% sure a spider wasn't in my bed, I would
    still have to check the entire bed because I don't like bugs!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Reason可能需要一些时间才能适应，但你可以将这段时间视为对你未来产品维护和信心的投资。尽管像TypeScript这样的渐进式类型系统的语言可能更容易上手，但它们并不提供像Reason这样的稳健类型系统所能提供的保证。Reason的真正好处不能完全通过简单的例子来传达，只有在节省你推理、重构和维护代码的时间和精力时才能真正显现。用这种方式来说；如果有人告诉我他们有99%的把握床里没有蜘蛛，我仍然会检查整个床，因为我不喜欢虫子！
- en: As long as you're 100% in Reason and your code compiles, the type system guarantees
    there will be no runtime type errors. It's true that when you are interoperating
    with non-Reason code (JavaScript, for example), you introduce the possibility
    of runtime type errors. Reason's sound type system allows you to trust that the
    Reason parts of the application won't cause runtime type errors, which therefore
    allows you to focus extra attention on ensuring that these areas of the application
    are safe. In my experience, programming in a dynamic language can feel noticeably
    dangerous. Reason on the other hand feels like it always has your back.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你在Reason中100%投入并且代码能够编译，类型系统就能保证不会有运行时类型错误。确实，当你与非Reason代码（例如JavaScript）进行互操作时，你会引入运行时类型错误的可能性。Reason的稳健类型系统让你可以相信应用中的Reason部分不会引起运行时类型错误，因此你可以额外关注确保这些应用区域的安全性。根据我的经验，在动态语言中编程可能会感觉特别危险。另一方面，Reason则感觉它总是在背后支持你。
- en: Interoperability
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性
- en: That being said, sometimes—and especially when first learning about type systems—you
    may be unsure as to how to get your code to compile. Reason, through BuckleScript,
    allows you to drop down to raw JavaScript when you need to, either via bindings
    or directly inside your Reason (`.re`) files. This gives you the freedom to figure
    things out as you go along in JavaScript, and then once you're ready, convert
    that section of the code to type-safe Reason.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有时——尤其是在刚开始学习类型系统时——你可能会不确定如何让你的代码编译。通过BuckleScript，Reason允许你在需要时直接降级到原始JavaScript，无论是通过绑定还是直接在你的Reason（`.re`）文件中。这给了你在JavaScript中边走边解决问题的自由，一旦你准备好了，就可以将代码的这一部分转换为类型安全的Reason。
- en: BuckleScript also lets us bind to idiomatic JavaScript in a very reasonable
    way. As you'll learn in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*, BuckleScript is an incredibly powerful
    part of Reason.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript还允许我们以非常合理的方式将JavaScript的惯用语法绑定。正如你将在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)，“BuckleScript，Belt和互操作性”中了解到的那样，BuckleScript是Reason的一个非常强大的组成部分。
- en: ES2030
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2030
- en: Writing in Reason feels like writing in a future version of JavaScript. Some
    Reason language features, including the pipe operator ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)) and
    pattern matching ([https://github.com/tc39/proposal-pattern-matching](https://github.com/tc39/proposal-pattern-matching)),
    are currently being proposed to the TC39 Committee to add into the JavaScript
    language. With Reason, we can take advantage of these features, and much more,
    today.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用Reason编写感觉就像是在编写JavaScript的未来版本。Reason的一些语言特性，包括管道操作符([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))和模式匹配([https://github.com/tc39/proposal-pattern-matching](https://github.com/tc39/proposal-pattern-matching))，目前正在被提议添加到JavaScript语言中。有了Reason，我们可以利用这些特性以及更多，今天就可以做到。
- en: Community
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区
- en: The Reason community is, hands down, one of the most helpful, supportive, and
    inclusive communities I've ever been a part of. If you have a question, or are
    stuck on something, the Reason Discord channel is the place to go for realtime
    support.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Reason社区是我曾经参与过的最有帮助、最有支持性和最具包容性的社区之一。如果你有问题，或者在某件事上遇到了困难，Reason Discord频道是获取实时支持的地方。
- en: 'Reason Discord channel:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Reason Discord频道：
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
- en: Often, when starting with a new technology, talking to someone with experience
    for five minutes can save you hours of frustration. I've personally asked questions
    at all hours of the day (and night) and am so incredibly grateful for and amazed
    by how quickly someone helps me out. Take a moment to join the Discord channel,
    introduce yourself, ask questions, and share your feedback on how to make Reason
    better!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当开始使用新技术时，与有经验的人交谈五分钟可以节省你数小时的挫败感。我亲自在一天中的任何时间（包括夜晚）提问，并对有人如此迅速地帮助我感到无比感激和惊讶。花点时间加入Discord频道，自我介绍，提问，并分享你对如何使Reason变得更好的反馈！
- en: The Future of ReactJS
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS的未来
- en: In practice, few real-world applications use just ReactJS. Additional technologies,
    such as Babel, ESLint, Redux, Flow/TypeScript, and Immutable.js, are typically
    brought in to help increase the maintainability of a codebase. Reason replaces
    the need for these additional technologies with its core language features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，很少有实际应用只使用ReactJS。通常还会引入其他技术，如Babel、ESLint、Redux、Flow/TypeScript和Immutable.js，以帮助提高代码库的可维护性。Reason通过其核心语言特性取代了这些额外技术的需求。
- en: ReasonReact is a Reason library that binds to ReactJS and provides a simpler,
    safer way to build ReactJS components. Just like ReactJS is just JavaScript, ReasonReact
    is just Reason. Additionally, it's easy to incrementally adopt because it was
    made by the same person who created ReactJS.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact是一个Reason库，它将ReactJS绑定并提供了一种更简单、更安全的方式来构建ReactJS组件。就像ReactJS只是JavaScript一样，ReasonReact只是Reason。此外，它易于逐步采用，因为它是由创建了ReactJS的同一个人所制作的。
- en: ReasonReact comes with a built in router, Redux-like data management, and JSX.
    You'll feel quite at home coming from a ReactJS background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact自带内置路由器、类似Redux的数据管理以及JSX。如果你有ReactJS背景，你会感到非常自在。
- en: It's important to mention that Reason/ReasonReact is already being used by several
    companies in production, including within one of the largest codebases in the
    world. Facebook's messenger.com codebase is already over 50% converted to ReasonReact.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提到，Reason/ReasonReact 已经被几家公司在生产中使用，包括世界上最大的代码库之一。Facebook 的 messenger.com
    代码库已经超过 50% 转换为 ReasonReact。
- en: Every ReasonReact feature has been extensively tested on the messenger.com codebase.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 ReasonReact 功能都在 messenger.com 代码库上进行了广泛的测试。
- en: – Cheng Lou
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: – 程楼
- en: ([https://reason.town/reason-philosophy](https://reason.town/reason-philosophy))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://reason.town/reason-philosophy](https://reason.town/reason-philosophy))
- en: As a result, new releases of Reason and ReasonReact come with code mods that
    automate much, if not all, of the upgrade process for your code base. New features
    are thoroughly tested internally at Facebook before they're released to the public,
    and this results in a pleasant developer experience.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Reason 和 ReasonReact 的新版本都附带代码修改，自动化了代码库升级过程的大部分，如果不是全部。在发布给公众之前，新功能在 Facebook
    内部进行了彻底的测试，这为开发者带来了愉快的体验。
- en: Exploring Reason
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Reason
- en: 'Ask yourself whether the following is a statement or an expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请问以下内容是语句还是表达式：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In JavaScript, it's a statement, but in Reason, it's an expression. Another
    example of an expression is `4 + 3`, which can also be represented as `4 + (2
    + 1)`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，这是一个语句，但在 Reason 中，它是一个表达式。另一个表达式的例子是 `4 + 3`，它也可以表示为 `4 + (2
    + 1)`。
- en: 'Many things in Reason are expressions, including control structures such as `if-else`,
    `switch`, `for` and `while`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 中的许多事物都是表达式，包括控制结构，如 `if-else`、`switch`、`for` 和 `while`：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also have ternaries in Reason. Here is another way to express the preceding
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 中也有三元运算符。以下是另一种表达前面代码的方式：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even anonymous block scopes are expressions that evaluate to the last line''s
    expression:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是匿名块作用域也是表达式，它们评估为最后一行的表达式：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A `tuple` is an immutable data structure that can hold different types of values
    and can be of any length:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple` 是一个不可变的数据结构，可以存储不同类型的值，并且可以是任何长度：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s use what we know so far and dive right in with the `FizzBuzz` example
    from Reason''s online playground. `FizzBuzz` was a popular interview question
    to determine whether a candidate is able to code. The challenge is to write a
    problem that prints the numbers from `1` to `100`, but instead prints `Fizz` for
    multiples of three, `Buzz` for multiples of five, and `FizzBuzz` for multiples
    of both three and five:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用目前已知的知识，直接从 Reason 在线沙盒中的 `FizzBuzz` 示例入手。`FizzBuzz` 是一个流行的面试问题，用于判断候选人是否具备编码能力。挑战是编写一个从
    `1` 到 `100` 打印数字的问题，但打印 `Fizz` 作为三的倍数，`Buzz` 作为五的倍数，以及 `FizzBuzz` 作为三和五的公倍数：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `fizzbuzz` is a function that accepts an integer and returns a string.
    An imperative `for` loop logs its output to the console.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fizzbuzz` 是一个接受整数并返回字符串的函数。一个命令式的 `for` 循环将其输出记录到控制台。
- en: 'In Reason, a function''s last expression becomes the function''s return value.
    The `switch` expression is the only `fizzbuzz` expression, so whatever that evaluates
    to becomes the output of `fizzbuzz`. Like JavaScript, the `switch` evaluates an
    expression and the first matched case gets its branch executed. In this case,
    the `switch` evaluates the tuple expression: `(i mod 3, i mod 5)`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，函数的最后一个表达式成为函数的返回值。`switch` 表达式是唯一的 `fizzbuzz` 表达式，所以它评估的结果成为 `fizzbuzz`
    的输出。像 JavaScript 一样，`switch` 评估一个表达式，第一个匹配的案例执行其分支。在这种情况下，`switch` 评估元组表达式：`(i
    mod 3, i mod 5)`。
- en: Given `i=1`, `(i mod 3, i mod 5)` becomes `(1, 1)`. Since `(1, 1)` isn't matched
    by `(0, 0)`, `(0, _)`, or `(_, 0)`, in that order, the last case of `_` (that
    is, *anything*) is matched, and `"1"` is returned. Similarly, `fizzbuzz` returns
    `"2"` when given `i=2`. When given `i=3`, `"Fizz"` is returned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `i=1`，`(i mod 3, i mod 5)` 变为 `(1, 1)`。由于 `(1, 1)` 不匹配 `(0, 0)`、`(0, _)`
    或 `(_, 0)`，按照这个顺序，最后的情况 `_`（即任何东西）被匹配，并返回 `"1"`。同样，当给定 `i=2` 时，`fizzbuzz` 返回 `"2"`。当给定
    `i=3` 时，返回 `"Fizz"`。
- en: 'Alternatively, we could have implemented `fizzbuzz` using `if-else`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用 `if-else` 实现 `fizzbuzz`：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, the switch version is much more readable. And as we'll see later in
    this chapter, the switch expression, also called **pattern matching**, is much
    more powerful than we've seen so far.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`switch` 版本的可读性更高。并且正如我们将在本章后面看到的那样，`switch` 表达式，也称为**模式匹配**，比我们之前看到的更强大。
- en: Data structures and types
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和类型
- en: 'A type is a set of values. More concretely, `42` has the `int` type because
    it''s a value that''s contained in the set of integers. A float is a number that
    includes a decimal point, that is, `42.` and `42.0`. In Reason, integers and floating
    point numbers have separate operators:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是一组值。更具体地说，`42`有`int`类型，因为它是一个包含在整数集合中的值。浮点数是一个包含小数点的数字，即`42.`和`42.0`。在Reason中，整数和浮点数有单独的操作符：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same is true for `-.`, `-`, `*.`, `*`, `/.`, and `/`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`-.`、`-`、`*.`、`*`、`/.`和`/`也是如此。
- en: Reason uses double quotes for the `string` type and single quotes for the `char` type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Reason使用双引号表示`string`类型，单引号表示`char`类型。
- en: Creating our own types
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的类型
- en: 'We can also create our types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建我们的类型：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s how we create a person of the `person` type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建`person`类型人的方法：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also annotate any expression with its type:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用类型注解任何表达式：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pattern matching
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'We can use pattern matching on our person:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在我们的`person`上使用模式匹配：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s use a record instead of a tuple for our person. Records are similar
    JavaScript objects except they''re much lighter and are immutable by default:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用记录代替元组来表示我们的`person`。记录与JavaScript对象类似，但它们更轻量，默认是不可变的：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use pattern matching on records too:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在记录上使用模式匹配：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like JavaScript, `{name: "Zoe", age: age}` can be represented as `{name: "Zoe",
    age}`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '与JavaScript一样，`{name: "Zoe", age: age}`可以表示为`{name: "Zoe", age}`。'
- en: 'We can create a new record from an existing one using the spread ( `...` )
    operator:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展（`...`）操作符从一个现有记录创建一个新的记录：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Records require type definitions before they can be used. Otherwise, the compiler
    will error with something like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在使用之前需要类型定义。否则，编译器会报错，如下所示：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A record must be the same shape as its type. Therefore, we cannot add arbitrary
    fields to our `person` record:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记录必须与它的类型形状相同。因此，我们不能随意向我们的`person`记录添加字段：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tuples and records are examples of product types. In our recent examples, our `person` type
    required both an `int` and an `age`. Almost all of JavaScript's data structures
    are product types; one exception is the `boolean` type, which is either `true`
    or `false`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和记录是产品类型的例子。在我们的最近例子中，我们的`person`类型需要`int`和`age`。JavaScript的大多数数据结构都是产品类型；一个例外是`boolean`类型，它可以是`true`或`false`。
- en: 'Reason''s variant type, which is an example of a sum type, allows us to express
    this or that. We can define the `boolean` type as a variant:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Reason的变体类型，它是和类型的一个例子，允许我们表达“这个”或“那个”。我们可以将`boolean`类型定义为变体：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can have as many constructors as we need:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有我们需要的构造函数数量：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Yes`, `No`, and `Maybe` are called constructors because we can use them to
    construct values. They''re also commonly called **tags**. Because these tags can
    construct values, variants are both a type and a data structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yes`、`No`和`Maybe`被称为构造函数，因为我们可以使用它们来构造值。它们也通常被称为**标签**。因为这些标签可以构造值，所以变体既是类型也是数据结构：'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And, of course, we can pattern match on `decision`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以在`decision`上使用模式匹配：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we were to forget to handle a case, the compiler would warn us:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记处理一个情况，编译器会警告我们：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we'll learn in [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml), *Setting
    Up a Development Environment*, the compiler can be configured to turn this warning
    into an error. Let's see one way to help make our code more resilient to future
    refactors by taking advantage of these exhaustiveness checks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第2章](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml)《设置开发环境》中学习的，编译器可以被配置为将这个警告转换为错误。让我们看看一种利用这些完备性检查来帮助使我们的代码更适应未来重构的方法。
- en: 'Take the following example where we are tasked with calculating the price of
    a concert venue''s seat given its section. Floor seats are $55, while all other
    seats are $45:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下例子为例，我们被要求根据座位所在的区域计算音乐厅座位的票价。楼层座位是$55，而其他所有座位是$45：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If, later, the concert venue allows the sale of seats in the orchestra pit
    area for $65, we would first add another constructor to `seat`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后来音乐厅允许以$65的价格出售乐池区域的座位，我们首先会在`seat`中添加另一个构造函数：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, due to the usage of the catch-all `_` case, our compiler doesn't complain
    after this change. It would be much better if it did since that would help us
    during our refactoring process. Stepping through compiler messages after changing
    type definitions is how Reason (and the ML family of languages in general) makes
    refactoring and extending code a safer, more pleasant process. This is, of course,
    not limited to variant types. Adding another field to our `person` type would
    also result in the same process of stepping through compiler messages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于使用了通配符 `_` 情况，编译器在这次更改后并没有抱怨。如果它真的这样做，那会更好，因为这有助于我们在重构过程中。在更改类型定义后逐步查看编译器消息是
    Reason（以及一般而言的 ML 家族语言）使重构和扩展代码成为一个更安全、更愉快的过程。当然，这不仅仅限于变体类型。向我们的 `person` 类型添加另一个字段也会导致相同的逐步查看编译器消息的过程。
- en: 'Instead, we should reserve using `_` for an infinite number of cases (such
    as our `fizzbuzz` example). We can refactor `getSeatPrice` to use explicit cases
    instead:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该保留使用 `_` 来表示无限多种情况（例如我们的 `fizzbuzz` 示例）。我们可以重构 `getSeatPrice` 以使用显式的情况：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we welcome the compiler nicely informing us of our unhandled case and
    then add it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们欢迎编译器友好地通知我们未处理的案例，然后添加它：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s now imagine that each seat, even ones in the same section (that is,
    ones that have the same tag) can have different prices. Well, Reason variants
    can also hold data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，每个座位，即使是同一区域（即具有相同标签）的座位，也可以有不同的价格。嗯，Reason 变体也可以存储数据：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And we can access this data with pattern matching:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过模式匹配来访问这些数据：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Variants are not just limited to one piece of data. Let''s imagine that we
    want our `seat` type to store its price as well as whether it''s still available.
    If it''s not available, it should store the ticket holder''s information:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 变体不仅限于存储一条数据。让我们想象一下，我们希望我们的 `seat` 类型不仅存储价格，还要存储是否仍然可用。如果不可用，它应该存储持票人的信息：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before explaining what the `option` type is, let''s have a look at its implementation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释 `option` 类型之前，让我们看看它的实现：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `''a` in the preceding code is called a **type variable**. Type variables
    always start with a `''`. This type definition uses a type variable so that it
    could work for any type. If it didn''t, we would need to create a `personOption` type
    that would only work for the `person` type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`'a` 被称为**类型变量**。类型变量总是以 `'` 开头。这个类型定义使用类型变量，以便它可以适用于任何类型。如果不这样做，我们就需要创建一个仅适用于
    `person` 类型的 `personOption` 类型：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What if we wanted an option for another type as well? Instead of repeating this
    type declaration over and over, we declare a polymorphic type. A polymorphic type
    is a type that includes a type variable. The `'a` (pronounced alpha) type variable
    will be swapped with `person` in our example. Since this type definition is so
    common, it's included in Reason's standard library, so there's no need to declare
    the `option` type in your code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还想为另一种类型提供选项呢？而不是一遍又一遍地重复这个类型声明，我们应该声明一个多态类型。多态类型是一个包含类型变量的类型。在我们的例子中，`'a`（发音为
    alpha）类型变量将被 `person` 替换。由于这个类型定义非常常见，它包含在 Reason 的标准库中，因此不需要在您的代码中声明 `option`
    类型。
- en: 'Jumping back to our `seat` example, we store its price as an `int` and its
    holder as an `option(person)`. If there''s no holder, it''s still available. We
    could have an `isAvailable` function that would take a `seat` and return a `bool`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `seat` 示例，我们将其价格存储为 `int`，并将其持有人存储为 `option(person)`。如果没有持有人，它仍然可用。我们可以有一个
    `isAvailable` 函数，它接受一个 `seat` 并返回一个 `bool`：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s take a step back and look at the implementations of `getSeatPrice` and
    `isAvailable`. It''s a shame that both functions need to be aware of the different
    constructors when they don''t have anything to do with the price or availability
    of the seat. Taking another look at our `seat` type, we see that `(int, option(person))`
    is repeated for each constructor. Also, there isn''t really a nice way to avoid
    using the `_` case in `isAvailable`. These are all signs that another type definition
    might serve our needs better. Let''s remove the arguments from the `seat` type
    and rename it `section`. We''ll declare a new record type, called `seat`, with
    fields for `section`, `price`, and `person`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看 `getSeatPrice` 和 `isAvailable` 的实现。很遗憾，这两个函数需要知道不同的构造函数，尽管它们与座位的价格或可用性无关。再次看看我们的
    `seat` 类型，我们看到 `(int, option(person))` 在每个构造函数中都被重复。此外，避免在 `isAvailable` 中使用 `_`
    情况并没有很好的方法。这些都是表明另一个类型定义可能更好地满足我们需求的迹象。让我们从 `seat` 类型中移除参数，并将其重命名为 `section`。我们将声明一个新的记录类型，称为
    `seat`，它包含 `section`、`price` 和 `person` 字段：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, our `getSeatPrice` and `isAvailable` functions have a higher signal-to-noise
    ratio, and don't need to change when the `section` type changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`getSeatPrice`和`isAvailable`函数具有更高的信号与噪声比，并且当`section`类型改变时不需要更改。
- en: As a side note, `_` is used to prefix a variable to prevent the compiler from
    warning us about the variable being unused.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，`_`用于变量前缀，以防止编译器警告我们该变量未使用。
- en: Making Invalid States Impossible
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使无效状态成为不可能
- en: 'Let''s say that we''d like to add a field to `seat` to hold the date a seat
    was purchased:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在`seat`中添加一个字段来保存座位购买日期：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we''ve introduced the possibility of an invalid state in our code. Here''s
    an example of such a state:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在我们的代码中引入了无效状态的可能性。以下是一个此类状态的示例：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In theory, the `dateSold` field should only hold a date when the `person` field
    holds a ticket holder. The ticket has a sold date, but no owner. We could look
    through our imaginary implementation to verify that this state would never happen,
    but there would still be the possibility that we missed something, or that some
    minor refactor introduced a bug that was overlooked.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`dateSold`字段只应在`person`字段包含持票人时持有日期。票有售出日期，但没有所有者。我们可以检查我们的假设实现以验证这种状态永远不会发生，但仍然存在我们可能遗漏了某些内容，或者某些微小的重构引入了被忽视的错误的可能。
- en: Since we now have the power of Reason's type system at our disposal, let's offload
    this work to the compiler. We are going to use the type system to enforce invariants
    in our code. If our code breaks these rules, it won't compile.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以利用Reason的类型系统，让我们将这项工作委托给编译器。我们将使用类型系统来强制执行代码中的不变性。如果我们的代码违反了这些规则，它将无法编译。
- en: 'One giveaway that this invalid state could exist is the use of `option` types
    within our record field. In these cases, there may be a way to use a variant instead
    such that each constructor only holds the relevant data. In our case, our sold-date
    and ticket-holder data should only exist when the seat has been sold:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种无效状态可能存在的一个迹象是在我们的记录字段中使用`option`类型。在这些情况下，可能有一种方法可以使用一个变体，使得每个构造函数只包含相关的数据。在我们的例子中，我们的售出日期和持票人数据只应在座位售出时存在：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Check out our new `status` type. The `Available` constructor holds no data,
    and `Sold` holds the sold date as well as the ticket holder.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的新`status`类型。`Available`构造函数不包含任何数据，而`Sold`构造函数包含售出日期以及持票人。
- en: With this `seat` type, there's no way to represent the previous invalid state
    of having a sold date without a ticket holder. It's also a good sign that our
    `seat` type no longer includes `option` types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种`seat`类型，无法表示没有持票人的售出日期的先前无效状态。这也表明我们的`seat`类型不再包含`option`类型。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got a feel for what Reason is and what problems it tries
    to solve. We saw how Reason's type inference removes much of the burden associated
    with statically-typed languages. We learned that the type system is a tool that
    can be used to provide codebases with powerful guarantees that provide an excellent
    developer experience. While Reason may take some time to get used to, it's well
    worth the investment for medium-sized to larger codebases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们感受到了Reason是什么以及它试图解决的问题。我们看到了Reason的类型推断如何减轻与静态类型语言相关的许多负担。我们了解到类型系统是一个工具，可以用来为代码库提供强大的保证，从而提供出色的开发者体验。虽然Reason可能需要一些时间来适应，但对于中等规模到较大的代码库来说，这种投资是非常值得的。
- en: In the next chapter, we'll learn about Reason's toolchain when we set up our
    development environment. In [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml),
    *Creating ReasonReact Components*, we'll start to build an application that we'll
    use throughout the rest of this book. By the end of this book, you'll be comfortable
    building real-world React applications in Reason.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习在设置我们的开发环境时如何使用Reason的工具链。在[第3章](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml)“创建ReasonReact组件”中，我们将开始构建一个我们将在这本书的其余部分中使用的应用程序。到这本书的结尾，你将能够舒适地使用Reason构建真实的React应用程序。
