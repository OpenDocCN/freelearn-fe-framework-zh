- en: Using React for the Client-Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 进行客户端开发
- en: So far, we have seen how to build web applications and microservices with Angular
    as the client-side framework. AngularJS was the most popular client-side framework
    until the new Angular 2 framework was released. Angular 2 caused a major disruption
    due to its backward incompatible architecture and gave way to more people migrating
    to React. Hence, the tides have shifted and now  React is the most popular and
    sought-after client-side framework, followed by Angular. JHipster added experimental
    support for React with version 4.11 and with JHipster Version 5.0; React support
    will become BETA and ready for mainstream use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用 Angular 作为客户端框架构建 Web 应用程序和微服务。AngularJS 是最流行的客户端框架，直到新版本的
    Angular 2 发布。由于 Angular 2 的向后不兼容架构，它导致了重大的颠覆，并让更多的人转向 React。因此，潮流已经转变，现在 React
    是最受欢迎和最被寻求的客户端框架，其次是 Angular。JHipster 从 4.11 版本开始添加了对 React 的实验性支持，并且随着 JHipster
    版本 5.0 的发布；React 支持将成为 BETA 并准备好用于主流使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generating an application with React client-side
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 客户端生成应用程序
- en: Technical stack and source code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术栈和源代码
- en: Generating an entity with React client side
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 客户端生成实体
- en: Generating an application with React client side
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 客户端生成应用程序
- en: 'Let''s dive in straight away and create a React application with JHipster.
    You will need to open a Terminal to run the commands:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接深入创建一个 JHipster React 应用程序。您需要打开一个终端来运行命令：
- en: Create a new folder and navigate to it by running `mkdir jhipster-react && cd jhipster-react`.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并通过运行 `mkdir jhipster-react && cd jhipster-react` 来导航到它。
- en: Now run the `jhipster` command in the Terminal. If you are running JHipster
    version 4.x instead of 5.x, then you will have to pass the experimental flag by
    running `jhipster --experimental`.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在终端中运行 `jhipster` 命令。如果您正在运行 JHipster 4.x 版本而不是 5.x，那么您需要通过运行 `jhipster --experimental`
    来传递实验性标志。
- en: JHipster will start with prompts; let's select default options for everything
    except for the question Which *Framework* would you like to use for the client? For
    this question, choose **[BETA] React** and proceed.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JHipster 将从提示开始；让我们为所有问题选择默认选项，除了询问您想为客户端使用哪个 *框架* 的问题。对于这个问题，请选择 **[BETA] React**
    并继续。
- en: Once all the prompts are completed, JHipster will generate the application and
    start installing dependencies before formatting the code using Prettier ([https://prettier.io/](https://prettier.io/))
    and starting the webpack build.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成所有提示，JHipster 将生成应用程序并开始安装依赖项，在格式化代码之前使用 Prettier ([https://prettier.io/](https://prettier.io/))
    并启动 webpack 构建。
- en: You can run `yarn prettier:format` to format the client-side code anytime. It
    will also be automatically run whenever you commit something with a git pre-commit
    hook.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时运行 `yarn prettier:format` 来格式化客户端代码。每当您使用 git 预提交钩子提交某些内容时，它也会自动运行。
- en: 'Our selected options will look as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的选择将如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it; we are done. Our first JHipster React application was created successfully.
    Now let's start the application to play around.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们完成了。我们的第一个 JHipster React 应用程序已成功创建。现在让我们启动应用程序来探索一下。
- en: We will choose the default Maven build option which JHipster created a wrapper
    for already, so let's start our server by running `./mvnw` in a Terminal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择默认的 Maven 构建选项，JHipster 已经为它创建了一个包装器，所以让我们通过在终端中运行 `./mvnw` 来启动我们的服务器。
- en: 'Maven will download the necessary dependencies and will start the Spring Boot
    application using the embedded Undertow container. You could choose Gradle instead
    of Maven if you prefer. Once the application successfully starts, we will see
    the following in the console:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 将下载必要的依赖项，并使用嵌入的 Undertow 容器启动 Spring Boot 应用程序。如果您更喜欢 Gradle，可以选择 Maven。一旦应用程序成功启动，我们将在控制台中看到以下内容：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Visit the URL(`http://localhost:8080`) in your favorite browser to see the
    application in action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在您最喜欢的浏览器中访问 URL (`http://localhost:8080`) 以查看应用程序的实际运行情况：
- en: '![](img/f4770fb9-2961-45b2-9fee-b47583320aed.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4770fb9-2961-45b2-9fee-b47583320aed.png)'
- en: You will see the home screen with the hipster dude looking back at you. Notice
    the React tattoo on his neck.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到主屏幕，上面有一个看起来回头的嬉皮士。注意他脖子上的 React 纹身。
- en: Go ahead and log in using the default admin user and play around.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的管理员用户登录并探索一下。
- en: The application looks exactly same as the Angular application we built earlier,
    except for the image, of course, and has all the same account and administration
    modules. This will make it more interesting for us to see the technical stack
    and source code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Technical stack and source code
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the generated code, let's talk about the technical stack.
    We already looked at React in [Chapter 2](7fc7275a-b035-4a45-9b55-3a3310572b3a.xhtml), *Getting
    Started with JHipster*, but let's recap.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: React is a view rendering library created by Jordan Walke in 2011, and was open
    sourced in May 2013\. It is maintained and backed by Facebook and has a huge community
    behind it. React follows the JS approach for HTML, where the markup code is written
    using JavaScript. To reduce verbosity, React uses a syntax sugar for Javascript
    called JSX ([https://reactjs.org/docs/introducing-jsx.html](https://reactjs.org/docs/introducing-jsx.html))
    to describe view elements. It looks similar to HTML, but it is not exactly HTML
    as some of the standard HTML attributes such as class, for example, is renamed
    to className, and attribute names are written using camelCase rather than dash-case.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is a JSX snippet. You always need to have to use
    React in context for JSX to work:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When it comes to TypeScript, the JSX extension becomes TSX.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: React uses a concept called Virtual DOM to improve the rendering efficiency.
    Virtual DOM is a lightweight copy of the actual DOM, and by comparing the virtual
    DOM after an update against the virtual DOM snapshot before the update, React
    can decide what exactly changed and render only that on to the actual DOM, hence
    making render cycles efficient and fast.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: React components can have their own state and you can pass properties to a component,
    which are available to the component as props.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Angular, React is not a full-fledged MVVM framework. It is just a view
    rendering library and hence when building React applications, we would always
    have to add a few more libraries for things like state management, routing, and
    so on.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Technical stacks
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical stacks used by JHipster when React is chosen
    as the client side framework:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Rendering**: React written using TypeScript'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State management**: Redux + React Redux  + Redux Promise Middleware + Redux
    Thunk'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: React router'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP**: Axios'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive design**: Bootstrap 4 + Reactstrap'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linting**: Tslint'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities**: Lodash'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testing**: Karma + Mocha + Chai + Enzyme'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: Webpack'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at some of the most important components of the stack.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client side is built using React, but instead of going with the traditional
    Javascript ES6, we are using TypeScript as the language of choice. This gives
    you the flexibility to use some of the concepts that you may be already familiar
    with if you come from a server-side background. It also provides static type checking,
    which makes development more efficient and less error-prone.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用React构建，但不是使用传统的JavaScript ES6，而是选择TypeScript作为编程语言。这为您提供了使用一些可能已经熟悉的从服务器端背景出发的概念的灵活性。它还提供了静态类型检查，这使得开发更加高效且错误率更低。
- en: Visit [https://github.com/piotrwitek/react-redux-typescript-guide](https://github.com/piotrwitek/react-redux-typescript-guide)
    to learn about how to make the most out of Typescript + React.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://github.com/piotrwitek/react-redux-typescript-guide](https://github.com/piotrwitek/react-redux-typescript-guide)
    了解如何充分利用TypeScript + React。
- en: State management with Redux and friends
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redux及其相关工具进行状态管理
- en: React provides basic state management within React components, but sometimes
    it is not sufficient, especially when your application needs to share state between
    multiple components. State management solutions like Flux, Redux, and MobX and
    quite popular in the React world and JHipster uses Redux as the state management
    layer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: React在React组件内提供了基本的州管理，但有时这并不足够，尤其是当您的应用程序需要在多个组件之间共享状态时。在React世界中，像Flux、Redux和MobX这样的状态管理解决方案非常流行，JHipster使用Redux作为状态管理层。
- en: When should you use the React component state?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何时使用React组件状态？
- en: '**If the variable can always be calculated using a prop**: Don''t use component
    state, calculate the variable during rendering'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果变量总是可以通过属性计算得出**：不要使用组件状态，在渲染期间计算变量'
- en: '**If the variable is not used in rendering but to hold data**: Don''t use component state,
    use private class fields'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果变量不在渲染中使用但用于存储数据**：不要使用组件状态，使用私有类字段'
- en: '**If the variable is obtained from an API and is required by more than one
    component**: Don''t use component state, use Redux global state and pass the variable
    as a prop'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果变量是从API获取且需要被多个组件使用**：不要使用组件状态，使用Redux全局状态并将变量作为属性传递'
- en: Redux ([https://redux.js.org/](https://redux.js.org/)) is a predictable state
    management solution for JavaScript, evolved from the Flux concept ([https://facebook.github.io/flux/](https://facebook.github.io/flux/)).
    Redux provides a global immutable store which can only be updated by emitting
    or dispatching actions. An action is an object which describes what changed, and
    it uses a pure reducer function to transform the state. A reducer is a pure function
    which takes in the current state and action and returns a new state.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Redux ([https://redux.js.org/](https://redux.js.org/)) 是JavaScript的一个可预测的状态管理解决方案，它源自Flux概念
    ([https://facebook.github.io/flux/](https://facebook.github.io/flux/))。Redux提供了一个全局不可变存储，只能通过发出或分发动作来更新。一个动作是一个对象，它描述了发生了什么变化，并使用一个纯函数来转换状态。一个reducer是一个纯函数，它接受当前状态和动作，并返回一个新的状态。
- en: 'React Redux is a binding for Redux that provides a higher order component called
    `connect` for React, which is used to connect React components to the Redux store.
    Let''s take a look at `src/main/webapp/app/modules/home/home.tsx`, for example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: React Redux 是Redux的一个绑定，它为React提供了一个名为 `connect` 的高阶组件，用于将React组件连接到Redux存储。以
    `src/main/webapp/app/modules/home/home.tsx` 为例：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `mapStateToProps` function is used to map properties from the global Redux
    store to the components props. The `mapDispatchToProps` function is used to wrap
    the given functions with the Redux dispatch call.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps` 函数用于将全局Redux存储中的属性映射到组件属性。`mapDispatchToProps` 函数用于将给定的函数包装在Redux的dispatch调用中。'
- en: Redux Promise Middleware ([https://github.com/pburtchaell/redux-promise-middleware](https://github.com/pburtchaell/redux-promise-middleware))
    is used to handle asynchronous action payloads. It accepts a Promise and dispatches
    pending, fulfilled, and rejected actions based on the Promise state. It is useful
    when Redux actions are making HTTP requests or performing async operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Promise Middleware ([https://github.com/pburtchaell/redux-promise-middleware](https://github.com/pburtchaell/redux-promise-middleware))
    用于处理异步动作负载。它接受一个Promise，并根据Promise的状态分发挂起、已解决和拒绝的动作。当Redux动作进行HTTP请求或执行异步操作时，它非常有用。
- en: Redux Thunk ([https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk))
    is another middleware used to chain actions. It is useful when an action has to
    call another action based on certain conditions or in general to handle side effects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Thunk ([https://github.com/gaearon/redux-thunk](https://github.com/gaearon/redux-thunk))
    是另一种用于链式操作的中间件。当动作需要根据某些条件调用另一个动作或通常处理副作用时，它非常有用。
- en: Routing with React Router
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Router 进行路由
- en: React Router ([https://reacttraining.com/react-router/web/guides/philosophy](https://reacttraining.com/react-router/web/guides/philosophy))
    is used for client-side routing. The default setup with JHipster is to use Hash
    History-based routing. It provides a simple component-based routing along with
    a flexible API for advanced routing setups. Routes can be defined anywhere in
    the application alongside the normal React rendering code. JHipster provides some
    custom wrappers such as `PrivateRoute` to enable authorization-based routing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: React Router ([https://reacttraining.com/react-router/web/guides/philosophy](https://reacttraining.com/react-router/web/guides/philosophy))
    用于客户端路由。JHipster 的默认设置是使用基于 Hash History 的路由。它提供了一个简单的基于组件的路由，以及一个灵活的 API，用于高级路由设置。路由可以在应用程序的任何位置定义，与正常的
    React 渲染代码并列。JHipster 提供了一些自定义包装器，例如 `PrivateRoute`，以启用基于授权的路由。
- en: 'Let''s take a look at `src/main/webapp/app/routes.tsx`, for example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看 `src/main/webapp/app/routes.tsx`：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: HTTP requests using Axios
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Axios 进行 HTTP 请求
- en: Axios ([https://github.com/axios/axios](https://github.com/axios/axios)) is
    a Promise-based HTTP client. It is a powerful and flexible library with a very
    straightforward API. It is used to fetch data from the JHipster application's
    server-side REST endpoints from Redux actions. The resulting Promise is resolved
    by the Redux Promise Middleware to provide data to the reducer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Axios ([https://github.com/axios/axios](https://github.com/axios/axios)) 是一个基于
    Promise 的 HTTP 客户端。它是一个功能强大且灵活的库，具有非常直观的 API。它用于从 Redux 动作中获取 JHipster 应用程序的服务器端
    REST 端点数据。结果 Promise 由 Redux Promise 中间件解析，以提供数据给 reducer。
- en: 'The following shows a Redux action with an asynchronous payload:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了一个带有异步负载的 Redux 动作：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Bootstrap components using Reactstrap
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Reactstrap 的 Bootstrap 组件
- en: JHipster uses Bootstrap 4 as its UI framework and since we are building a React
    application, it makes sense to use a Native React binding instead of Bootstrap's
    JQuery-based components. Reactstrap ([https://reactstrap.github.io/](https://reactstrap.github.io/))
    provides pure React components for Bootstrap 4\. We also make use of the Availity
    reactstrap Validation ([https://availity.github.io/availity-reactstrap-validation/](https://availity.github.io/availity-reactstrap-validation/))
    library, which provides form validation support for Reactstrap form elements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 使用 Bootstrap 4 作为其 UI 框架，由于我们正在构建一个 React 应用程序，因此使用原生 React 绑定而不是 Bootstrap
    的基于 jQuery 的组件是有意义的。Reactstrap ([https://reactstrap.github.io/](https://reactstrap.github.io/))
    为 Bootstrap 4 提供了纯 React 组件。我们还使用了 Availity reactstrap Validation ([https://availity.github.io/availity-reactstrap-validation/](https://availity.github.io/availity-reactstrap-validation/))
    库，该库为 Reactstrap 表单元素提供表单验证支持。
- en: 'Let''s take a look at `src/main/webapp/app/modules/login/login-modal.tsx`,
    for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看 `src/main/webapp/app/modules/login/login-modal.tsx`：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unit testing setup
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试设置
- en: JHipster uses a combination of Karma, Mocha, Chai, and Enzyme to unit test the
    client-side components.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 使用 Karma、Mocha、Chai 和 Enzyme 的组合来对客户端组件进行单元测试。
- en: Karma ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html))
    is used as the test runner and Mocha ([https://mochajs.org/](https://mochajs.org/))
    is used as the testing framework. Chai ([http://chaijs.com/](http://chaijs.com/))
    is an assertion library with great plugin support. We use its BDD (Behavior-driven
    development) style assertions. Enzyme ([http://airbnb.io/enzyme/](http://airbnb.io/enzyme/))
    is a testing utility for React which makes it easy to unit test React components.
    In combination, these libraries provide a rich and intuitive testing environment
    for React.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Karma ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html))
    被用作测试运行器，Mocha ([https://mochajs.org/](https://mochajs.org/)) 被用作测试框架。Chai ([http://chaijs.com/](http://chaijs.com/))
    是一个具有出色插件支持的断言库。我们使用其 BDD（行为驱动开发）风格的断言。Enzyme ([http://airbnb.io/enzyme/](http://airbnb.io/enzyme/))
    是一个用于 React 的测试实用工具，它使得对 React 组件进行单元测试变得容易。结合使用，这些库为 React 提供了一个丰富且直观的测试环境。
- en: Let's run the generated unit tests. Run `yarn test` in a Terminal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的单元测试。在终端中运行 `yarn test`。
- en: Generating source code
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成源代码
- en: 'Let''s take a look at the generated code. Since we already saw the server-side
    code in previous chapters, we will only look at the client-side code here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成的代码。由于我们已经在之前的章节中看到了服务器端代码，所以我们在这里只看客户端代码：
- en: '![](img/8bd704bd-2a60-4067-adf4-cede92f2035d.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8bd704bd-2a60-4067-adf4-cede92f2035d.png)'
- en: The structure is quite similar to what we saw for Angular, but the React code
    is organized slightly differently. We are concerned only about the code inside
    `src/main/webapp/app` as everything else is exactly the same as what we saw for
    the Angular application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结构与我们之前看到的 Angular 非常相似，但 React 代码的组织方式略有不同。我们只关注 `src/main/webapp/app` 内部的代码，因为其他所有内容都与我们在
    Angular 应用程序中看到的一模一样。
- en: 'Let''s take a look at some of the important parts of the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码的一些重要部分：
- en: '`index.tsx`: This is the entry point of our application. This is where we bootstrap
    React to the `root div` and initialize the Redux store:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.tsx`：这是我们的应用程序入口点。这是我们将 React 引导到 `root div` 并初始化 Redux 存储的地方：'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`app.tsx`: This is our main application component. We declare the React router
    and the main application UI structure here:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.tsx`：这是我们的主要应用程序组件。我们在这里声明 React 路由和主要应用程序 UI 结构：'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`routes.tsx`: The application''s main parent routes are defined here and they
    are imported in the `app.tsx` from here.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes.tsx`：应用程序的主要父级路由在这里定义，并且它们从这里导入 `app.tsx`。'
- en: '`config`: This is where framework level configurations are done:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：这是进行框架级配置的地方：'
- en: '`axios-interceptor.ts`: HTTP interceptors are configured here. This is where
    the JWT tokens are set to requests and errors are handled.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`axios-interceptor.ts`：在这里配置 HTTP 拦截器。这是将 JWT 令牌设置到请求中并处理错误的地方。'
- en: '`constants.ts`: Application constants.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constants.ts`：应用程序常量。'
- en: '`*-middleware.ts`: Error, Notification, and Logging middleware for Redux are
    configured here.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*-middleware.ts`：在这里配置 Redux 的错误、通知和日志中间件。'
- en: '`store.ts`: Redux store configuration is done here. Middlewares are registered
    during this stage.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store.ts`：在这里完成 Redux 存储配置。中间件在此阶段注册。'
- en: 'The order of the middlewares in the array is important as they act like a pipeline,
    passing actions from one middleware to another as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件在数组中的顺序很重要，因为它们就像一个管道，将动作从一个中间件传递到另一个中间件，如下所示：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`translation.ts`: i18n-related configurations are done here.'
  id: totrans-93
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translation.ts`：在这里完成 i18n 相关的配置。'
- en: '`entities`: The entity modules are present here.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entities`：实体模块在这里。'
- en: '`modules`: Application UI modules are here:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules`：应用程序 UI 模块在这里：'
- en: '`account`: Account pages like settings, password reset, and so on are here'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account`：账户页面，如设置、密码重置等在这里'
- en: '`administration`: The admin screens like metric, health, user-management, and
    so on are here'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`administration`：如度量、健康、用户管理等管理屏幕在这里'
- en: '`home`: Home screen of the application'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home`：应用程序的主屏幕'
- en: '`login`: Login and logout components'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`：登录和注销组件'
- en: '`shared`: Shared components and reducers:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared`：共享组件和减法器：'
- en: '`layout`: Layout related components like header, footer, and so on'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout`：与头部、尾部等相关布局组件。'
- en: '`model`: Typescript model for entities'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：实体的 TypeScript 模型。'
- en: '`reducers`: shared reducers used by the application:'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducers`：应用程序使用的共享减法器：'
- en: '`authentication.ts`: This is for authentication-related actions and reducers.
    Let''s use the `LOGIN` action. The action accepts username, password, and rememberMe
    and dispatches the `ACTION_TYPES.LOGIN` with an asynchronous payload from an HTTP
    call to authenticate our credentials. We use the **async/await** feature from
    ES7 to avoid complex callbacks here. The result from the dispatch is obtained
    from when we extract the JWT `bearerToken` and store it in the local or session
    storage of the browser based on the remember me setting passed. The dispatch of `ACTION_TYPES.LOGIN`
    will trigger the appropriate case in the reducer based on the status of the promise:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authentication.ts`：这是与身份验证相关的动作和减法器。让我们使用 `LOGIN` 动作。该动作接受用户名、密码和 rememberMe，并通过对
    HTTP 调用的异步有效载荷执行 `ACTION_TYPES.LOGIN` 来验证我们的凭据。我们使用 ES7 的 **async/await** 功能来避免这里的复杂回调。从我们提取
    JWT `bearerToken` 并根据传递的 remember me 设置将其存储在浏览器的本地或会话存储中的结果，是从我们触发基于承诺状态的 `ACTION_TYPES.LOGIN`
    的减法器中获得的。`ACTION_TYPES.LOGIN` 的分发将根据承诺的状态触发减法器中的适当情况：'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`util`: Utility functions.'
  id: totrans-106
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`：实用函数。'
- en: 'The folder structure of the unit test code is also quite similar:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码的文件夹结构也非常相似：
- en: '![](img/f7382a4c-1090-4947-b0ce-f4e4e3f10586.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7382a4c-1090-4947-b0ce-f4e4e3f10586.png)'
- en: Generating an entity with React client side
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 客户端生成实体
- en: 'Let''s see how we can create an entity using the JHipster entity generator
    with a React client side. We will create a simple Employee entity with the name,
    age, and date of birth fields:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 JHipster 实体生成器以及 React 客户端创建一个实体。我们将创建一个简单的 Employee 实体，包含姓名、年龄和出生日期字段：
- en: Open a Terminal and navigate to the folder of the React app and run `jhipster
    entity employee`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到 React 应用程序的文件夹，然后运行 `jhipster entity employee`。
- en: Create the fields one by one, select yes for the question Do you want to add
    a field to your entity?, and start filling in the field name for the next question, What
    is the name of your field?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个创建字段，对于问题“是否要为实体添加字段？”选择“是”，并开始填写下一个问题的字段名称，“你的字段名称是什么？”
- en: Select String as the field type for the next question, What is the type of your
    field?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个问题，“你的字段类型是什么？”选择 String。
- en: For the question Which validation rules do you want to add?, choose Required for
    name field and proceed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于问题“你想要添加哪些验证规则？”选择名称字段的“必需”，然后继续。
- en: Continue the process for the following fields. `age` and `dob. age` are of type
    Integer and `dob` is of type Instant.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续处理以下字段。`age` 和 `dob` 的类型为 Integer，`dob` 的类型为 Instant。
- en: When asked again, Do you want to add a field to your entity?, choose no.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当再次被问及时，选择“否”，即是否要为实体添加字段。
- en: For the next question, Do you want to add a relationship to another entity?,
    choose yes.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个问题，“是否要为另一个实体添加关系？”，选择“是”。
- en: Provide `user` as the name of the other entity and as the name of the relationship
    for the following questions.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `user` 作为其他实体的名称以及关系的名称，用于以下问题。
- en: For the next question, What is the type of the relationship?, let's create a one-to-one
    relationship with the user.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个问题，“关系的类型是什么？”让我们创建一个与用户的一对一关系。
- en: Choose no for the next question and no again when asked to add another relationship.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个问题选择“否”，当被要求添加另一个关系时再次选择“否”。
- en: For the following questions, select the default options and proceed.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于以下问题，选择默认选项并继续。
- en: 'The command will produce the following console output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将产生以下控制台输出：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: JHipster will generate the entity and run Prettier and the webpack build.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 将生成实体并运行 Prettier 和 webpack 构建。
- en: If your server is not running, start it in a Terminal by running `./mvnw`. If
    it is already running, then just compile the new code by running `./mvnw compile`,
    and Spring DevTools will restart the app automatically.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的服务器没有运行，请在终端中通过运行 `./mvnw` 启动它。如果它已经运行，那么只需通过运行 `./mvnw compile` 编译新代码，Spring
    DevTools 将自动重启应用程序。
- en: 'Start BrowserSync in another Terminal by running `yarn start` and check the
    employee entity we just created:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中通过运行 `yarn start` 启动 BrowserSync 并检查我们刚刚创建的员工实体：
- en: '![](img/8be985b1-c5a9-463b-ae41-62f7391c6c32.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8be985b1-c5a9-463b-ae41-62f7391c6c32.png)'
- en: 'Create an entity to check everything works fine:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实体以检查一切是否正常工作：
- en: '![](img/bbd46aae-8a9e-4b10-8791-b51d77707319.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbd46aae-8a9e-4b10-8791-b51d77707319.png)'
- en: 'For the entity we created, JHipster generated/updated the following files:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的实体，JHipster 生成了/更新了以下文件：
- en: '![](img/a74d2eb8-9f8b-4cf9-8590-59ec5498f7ee.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a74d2eb8-9f8b-4cf9-8590-59ec5498f7ee.png)'
- en: 'On the React client side, we have the following files:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 客户端，我们有以下文件：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `index.ts` file declares the routes for the entity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.ts` 文件声明了实体的路由：'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`employee.reducer.ts` declares the actions and reducer for the entity, for
    example, let''s use the action and reducer to create an entity. The `createEntity`
    action dispatches the `ACTION_TYPES.CREATE_EMPLOYEE` with the HTTP payload and
    metadata for notifications. Once the HTTP request resolves, we dispatch the `getEntities`
    action to fetch the updated entity list.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`employee.reducer.ts` 声明了实体的动作和 reducer，例如，让我们使用动作和 reducer 来创建实体。`createEntity`
    动作通过带有 HTTP 有效载荷和通知元数据的 `ACTION_TYPES.CREATE_EMPLOYEE` 分发。一旦 HTTP 请求解决，我们分发 `getEntities`
    动作以获取更新的实体列表。'
- en: 'The reducer is common for create and update actions. Let''s take a look at
    the create action and reducer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 对于创建和更新动作是通用的。让我们看看创建动作和 reducer：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`employee.tsx`, `employee-dialog.tsx`, `employee-detail.tsx`, and  `employee-delete-dialog.tsx`
    declare the entity listing, entity model dialog, entity detail, and entity delete
    dialog respectively. Let''s look at `employee.tsx`, for example. We define the
    type for the props using a TypeScript interface, `IEmployeeProps`, which is passed
    as the generic for the `React.Component` type. We trigger the actions to fetch
    entities and users when our component mounts using the `componentDidMount` lifecycle
    method. The render method returns the JSX for the UI.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`employee.tsx`、`employee-dialog.tsx`、`employee-detail.tsx` 和 `employee-delete-dialog.tsx`
    分别声明了实体列表、实体模型对话框、实体详情和实体删除对话框。以 `employee.tsx` 为例，我们使用 TypeScript 接口 `IEmployeeProps`
    定义了 props 的类型，并将其作为 `React.Component` 类型的泛型传递。我们使用 `componentDidMount` 生命周期方法在组件挂载时触发获取实体和用户的动作。渲染方法返回
    UI 的 JSX。'
- en: 'The component is connected to the Redux store using the higher-order component.
    Let''s take a look:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件通过高阶组件连接到 Redux 存储。让我们看一下：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The other components also follow a similar approach. Codewise React code has
    much less boilerplate and is more concise compared to Angular.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其他组件也遵循类似的方法。与 Angular 相比，React 代码在编码上具有更少的样板代码，并且更加简洁。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned general concepts about React, Redux, and other libraries
    on the React ecosystem. We also learned how to create a React app using JHipster
    and generated entities for it. We saw how we can make use of TypeScript with React
    and also walked through the generated code. We also ran and tested our created
    application. In the next chapter, we will conclude the book with best practices
    from the JHipster community and next steps to make use of what you've learned
    so far.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于 React、Redux 以及 React 生态系统上其他库的一般概念。我们还学习了如何使用 JHipster 创建 React
    应用程序以及为其生成的实体。我们看到了如何利用 TypeScript 与 React 一起使用，并浏览了生成的代码。我们还运行并测试了我们创建的应用程序。在下一章中，我们将通过
    JHipster 社区的最佳实践和下一步如何利用你迄今为止所学的内容来结束本书。
