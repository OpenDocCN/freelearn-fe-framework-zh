- en: Chapter 9. A jQuery Heat Map
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。 一个jQuery热图
- en: A heat map can tell you a lot about how your website is used. It's a valuable
    tool in the world of analytics that can tell you which features of your website
    are the most used, and which areas might need some improvement in order to truly
    engage visitors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 热图可以告诉您有关您的网站如何使用的很多信息。在分析领域，这是一种有价值的工具，可以告诉您网站的哪些功能被最多使用，以及哪些区域可能需要一些改进以真正吸引访问者。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project we're going to build our own heat map to record which areas
    of any page are clicked the most. We'll need to build a way of actually recording
    where every click occurs and a way of transmitting that information somewhere
    so that it can be stored.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将建立自己的热图，记录任何页面的哪些区域被点击最多。我们需要建立一种实际记录每次点击发生的位置以及将该信息传输到某个地方以便存储的方法。
- en: We'll actually be building two different bits of the overall heat map – the
    client-side part that is executed in visitors' browsers to capture the clicks,
    and an admin console that displays the heat map to the owner of the site.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上将构建整个热图的两个不同部分 - 客户端部分在访问者的浏览器中执行以捕获点击，并且一个管理控制台，向网站的所有者显示热图。
- en: We'll need to account for different resolutions and devices in order to capture
    the maximum amount of information and ensure that our script is efficient enough
    to run in the background unnoticed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑不同的分辨率和设备，以便捕获尽可能多的信息，并确保我们的脚本足够高效地在后台运行而不被注意到。
- en: 'Nothing visible will happen at the client side of course (all that part will
    do is record and store the clicks) but at the end of the project we''ll be able
    to display detailed information in the admin console on the number and positions
    of all clicks on a page, as shown in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在客户端不会发生任何可见的事情（所有这部分将做的就是记录和存储点击），但是在项目结束时，我们将能够在管理控制台中显示有关页面上所有点击的数量和位置的详细信息，如以下屏幕截图所示：
- en: '![Mission Briefing](img/9106OS_09_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/9106OS_09_01.jpg)'
- en: Why Is It Awesome?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它为什么很棒？
- en: All analytics are useful to the owner of a website and can give detailed information
    about the people visiting the site, including things such as their computing environment,
    which pages they enter the site on, which pages they leave from, and how many
    pages they visit.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的分析对网站的所有者都是有用的，并且可以提供有关访问网站的人的详细信息，包括他们的计算环境，他们进入网站的页面，他们离开的页面以及他们访问的页面数量。
- en: A heat map can be just as informative, but from a developer's point of view
    instead of an owner's. Which bits of your pages are clicked most frequently? A
    heat map can tell you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，热图同样具有信息量。您页面的哪些部分被点击最频繁？热图可以告诉您。
- en: The heat map that we'll build will be for responsive websites that are able
    to change their layout to suit the screen width of the device being used to view
    the site. A single project is not nearly enough to cover all aspects of responsive
    design, and because we're focusing mainly on the script itself, we won't be covering
    it in much detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的热图将适用于能够根据设备屏幕宽度改变其布局以适应的响应式网站。单个项目远远不足以涵盖响应式设计的所有方面，因为我们主要关注脚本本身，所以我们不会详细介绍它。
- en: If you've used responsive techniques already then you won't need the additional
    information. If you haven't worked with responsive principles before, this should
    be a gentle introduction to the subject that should act as a primer for the subject.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用过响应式技术，那么您将不需要额外的信息。如果您之前没有使用过响应式原理，那么这应该是一个关于该主题的温和介绍，应该作为该主题的入门手册。
- en: Your Hotshot Objectives
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的热门目标
- en: 'In this project we''ll cover the following tasks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将涵盖以下任务：
- en: Determining and saving the environment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定并保存环境
- en: Capturing visitor clicks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获访问者的点击
- en: Saving the click data
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存点击数据
- en: Adding the management console
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加管理控制台
- en: Requesting click data
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求点击数据
- en: Displaying a heat map
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示热图
- en: Allowing different layouts to be selected
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许选择不同的布局
- en: Showing heat maps for each layout
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示每个布局的热图
- en: Mission Checklist
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: This is the only project where we aren't going to build the HTML and CSS that
    we need ourselves. We want our heat map to work with a variety of layouts and
    the best way to test that is with a responsive layout. Were we to code this ourselves,
    it would take us most of this project to code and discuss just the layout, before
    we even got to the heat map.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一一个我们不打算自己构建所需的HTML和CSS的项目。我们希望我们的热图能够与各种布局配合使用，测试这一点的最佳方法是使用响应式布局。如果我们自己编写代码，我们会在此项目的大部分时间里仅编写和讨论布局，甚至在开始制作热图之前。
- en: 'We''ll use a prebuilt responsive template for this project then, so that we
    can jump straight into the fun part without getting distracted. The template that
    we''ll use is called Simplex, but unfortunately it''s no longer available online.
    You''ll need to use the template files found in the accompanying download for
    this book. Simply copy the `simplex` folder from the downloaded archive in to
    the main `jquery-hotshots` project directory. All we need to do is add a few script
    references to each of the HTML pages in the template. The files that should be
    updated are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个项目中使用一个预先构建的响应式模板，这样我们就可以直接进入有趣的部分，而不会分心。我们将使用的模板称为Simplex，但不幸的是，它已经不再在线上提供了。您需要使用本书附带下载的模板文件。只需将下载存档中的`simplex`文件夹复制到主`jquery-hotshots`项目目录中即可。我们需要做的就是在模板的每个HTML页面中添加几个脚本引用。应该更新的文件是：
- en: '`contact.html`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contact.html`'
- en: '`gallery.html`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gallery.html`'
- en: '`index.html`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '`who-we-are.html`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`who-we-are.html`'
- en: 'The new `<script>` elements can go at the bottom of the `<body>` in each of
    the four pages. First we need jQuery obviously:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`<script>`元素可以放在每个页面的`<body>`底部。首先，我们需要jQuery：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll also be making use of the imagesLoaded plugin that we used in the last
    project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用我们在上一个项目中使用的imagesLoaded插件：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this project we''ll create two scripts, one to run on the client and one
    for the admin console. Initially we''ll be working with the client script, so
    we should add the following to each page:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建两个脚本，一个用于客户端，一个用于管理控制台。最初，我们将使用客户端脚本，因此我们应该在每个页面中添加以下内容：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file doesn't exist yet of course, so while we're getting set up we can
    go ahead and create this now. It should be saved in the `js` directory along with
    our other scripts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个文件还不存在，所以在我们进行设置时，我们可以先创建这个文件。它应该保存在`js`目录中，与我们的其他脚本一起。
- en: Determining and saving the environment
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定并保存环境
- en: In our first task we'll store some information about the current browsing environment,
    such as the URL of the current page. We'll also parse any attached style sheets
    looking for media queries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个任务中，我们将存储一些关于当前浏览环境的信息，例如当前页面的URL。我们还将解析任何附加的样式表，查找媒体查询。
- en: Prepare for Lift Off
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备升空
- en: 'We''ll start with our `document ready` shortcut, as we have in most of our
    other projects. In the `heat-map-client.js` file, add the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像我们在大多数其他项目中所做的那样，从我们的`document ready`快捷方式开始。在`heat-map-client.js`文件中，添加以下代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the additional code we add to this file will go into this callback function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到这个文件的所有附加代码都将放在此回调函数中。
- en: Engage Thrusters
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: We'll first set a series of variables that will be used throughout the script.
    We'll also need to parse any attached style sheets and look for **media queries**
    so that we can determine which breakpoints are defined for the different layouts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一系列在整个脚本中将使用的变量。我们还需要解析任何附加的样式表，并查找**媒体查询**，以便我们可以确定为不同布局定义了哪些断点。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Media queries are a way to specify in CSS that a group of styles should only
    be applied if certain conditions are met, such as the width of the screen. For
    more information see [http://en.wikipedia.org/wiki/Media_queries](http://en.wikipedia.org/wiki/Media_queries).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询是一种在CSS中指定一组样式的方法，只有在满足某些条件时才会应用，例如屏幕的宽度。有关更多信息，请参阅[http://en.wikipedia.org/wiki/Media_queries](http://en.wikipedia.org/wiki/Media_queries)。
- en: 'Add the following code inside the callback function we just added:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们刚刚添加的回调函数中：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Objective Complete - Mini Debriefing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 迷你总结
- en: We start out by defining a series of variables. We cache a reference to the
    `document` object and wrap it with jQuery functionality. We then create an object
    called `clickStats` which we'll use as a general storage container for the session.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一系列变量。我们缓存了对`document`对象的引用，并使用jQuery功能对其进行了包装。然后我们创建了一个名为`clickStats`的对象，我们将用作会话的通用存储容器。
- en: Within the object we store the URL of the page and define an empty array called
    `clicks` which will be used to store each click that occurs. Lastly we create
    another array, this time outside of our `clickStats` object, which we'll use to
    store objects representing each layout for the document.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象内部，我们存储页面的 URL，并定义一个名为`clicks`的空数组，用于存储每次点击事件。最后，我们创建另一个数组，这次在我们的`clickStats`对象之外，我们将使用它来存储代表文档每个布局的对象。
- en: We also set some defaults for any AJAX requests using jQuery's `ajaxSetup()`
    method, which accepts an object containing the options to set. We'll be making
    a couple of requests, so it makes sense to set defaults for any options that we
    set in both requests. In this example we'll need to set the `type` to `POST`,
    the `contentType` to `application/json`, and the `dataType` to `json`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 jQuery 的`ajaxSetup()`方法为任何 AJAX 请求设置一些默认值，该方法接受包含要设置的选项的对象。我们将进行几个请求，因此设置在两个请求中都设置的任何选项的默认值是有意义的。在本例中，我们需要将`type`设置为`POST`，将`contentType`设置为`application/json`，并将`dataType`设置为`json`。
- en: Our next block of code is concerned with parsing any style sheets attached to
    the document via `<link>` elements and extracting any media queries defined in
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个代码块涉及解析通过`<link>`元素附加到文档的任何样式表，并提取其中定义的任何媒体查询。
- en: We start by using jQuery's `each()` method to iterate the style sheet objects
    stored in the `StyleSheets` collection of the `document` object. For each style
    sheet, there will be an object in the collection that contains all of its selectors
    and rules, including any media queries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 jQuery 的`each()`方法来迭代存储在`document`对象的`StyleSheets`集合中的样式表对象。对于每个样式表，集合中都会有一个对象，其中包含其所有选择器和规则，包括任何媒体查询。
- en: The collection that we're iterating consists of objects, so the callback function
    we pass to the `each()` method will receive the index of the current object, which
    we set to `x`, and the current object itself, which we set to `ss` as arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在迭代的集合由对象组成，因此我们传递给`each()`方法的回调函数将接收当前对象的索引（我们将其设置为`x`）和当前对象本身（我们将其设置为`ss`）作为参数。
- en: Within our callback function we again use jQuery's `each()` method. This time
    we're iterating the `rules` collection of the `ss` object passed into the callback
    function. This collection will contain a series of objects. The callback function
    we pass to this incantation of the method will receive the index once again, this
    time set to `y`, and the current object, this time set to `rule`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的回调函数内部，我们再次使用 jQuery 的`each()`方法。这次，我们正在迭代传递给回调函数的`ss`对象的`rules`集合。此集合将包含一系列对象。我们传递给该方法的回调函数将再次接收索引（这次设置为`y`）和当前对象（这次设置为`rule`）作为参数。
- en: The type of object will differ depending on what it is. It may be a `CSSImportRule`
    for `@import` statements, a `CSSFontFaceRule` for `@font-face` rules, a `CSSStyleRule`
    for any selectors defined by the style sheet, or a `CSSMediaRule` for any media
    queries.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型将取决于其是什么。它可能是一个`CSSImportRule`，用于`@import`语句，一个`CSSFontFaceRule`，用于`@font-face`规则，一个`CSSStyleRule`，用于样式表定义的任何选择器，或者一个`CSSMediaRule`，用于任何媒体查询。
- en: We are only interested in the `CSSMediaRule` objects, so within the callback
    in the nested `each()` we first check whether the rule object has a `media` property
    and if the media property has a `length`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对`CSSMediaRule`对象感兴趣，因此在嵌套的`each()`回调中，我们首先检查规则对象是否具有`media`属性，以及媒体属性是否具有`length`。
- en: Only `CSSMediaRule` objects will have a `media` property, but this property
    may be empty, so we can check for the presence of this property and check that
    it has `length` using an `if` conditional within the nested callback.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`CSSMediaRule`对象会有一个`media`属性，但是此属性可能为空，因此我们可以在嵌套的回调中使用`if`条件检查此属性的存在并检查其是否具有`length`。
- en: If both of these conditions are `true` (or truthy) we know we've found a media
    query. We first set a couple of new variables. The first variable is the first
    item of the `media` collection, which will contain the text string defining the
    media query, and the second is an object called `mq` that we'll use to store the
    breakpoints of the media query.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个条件都为`true`（或者是真值），我们就知道我们找到了一个媒体查询。我们首先设置一些新变量。第一个变量是`media`集合的第一项，它将包含定义媒体查询的文本字符串，第二个是一个称为`mq`的对象，我们将使用它来存储媒体查询的断点。
- en: We set two properties of this object – the `min` and `max` values of the media
    query. We set the `min` property by checking whether the text string contains
    the word `min`. If it does we first split the string on the term `min-width:`
    and take the second item in the array that the `split()` function will return,
    and then split this resulting string on the term `px` and take the first item.
    We can chain `split()` like this because the function returns an array, which
    is also what it is called on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了该对象的两个属性 - 媒体查询的`min`和`max`值。我们通过检查文本字符串是否包含单词`min`来设置`min`属性。如果是，我们首先在术语`min-width:`上拆分字符串，然后获取`split()`函数将返回的数组中的第二项，然后在结果字符串上拆分术语`px`并获取第一项。我们可以像这样链式调用`split()`，因为该函数返回一个数组，这也是它被调用的方式。
- en: If the string does not contain the word `min` we set the value to `0`. We do
    the same to extract the `max-width` if there is one. If there isn't a `max-width`,
    we set it to the string `none`. Once we've created our `layout` object we push
    it into the `layouts` array.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串不包含单词`min`，我们将值设置为`0`。如果存在`max-width`，我们也执行同样的操作来提取它。如果没有`max-width`，我们将其设置为字符串`none`。创建`layout`对象后，我们将其推送到`layouts`数组中。
- en: Lastly we sort our breakpoints array so that it is in ascending order. We can
    do this by passing a sorting function to JavaScript's `sort()` method, which is
    called on an array. The function we pass in will receive two items from the array
    we are sorting.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对我们的断点数组进行排序，以便按升序排列。我们可以通过向JavaScript的`sort()`方法传递一个排序函数来做到这一点，该方法在数组上调用。我们传递的函数将从我们正在排序的数组中接收两个项目。
- en: If the `min` property of first object is less than the `min` property of the
    second `b` object, the function will return a negative number, which puts the
    smaller number before the larger number in the array – exactly what we want.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个对象的`min`属性小于第二个对象`b`的`min`属性，则函数将返回一个负数，这会将较小的数字放在数组中较大的数字之前 - 这正是我们想要的。
- en: So we'll end up with an array where each item is a specific breakpoint, which
    increases throughout the array, making checking against it later on to detect
    which breakpoint is being applied much easier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到一个数组，其中每个项目都是一个特定的断点，它在数组中逐渐增加，从而使稍后检查哪个断点正在应用变得更加容易。
- en: Lastly we need to send this data to the server, potentially so that it can be
    saved. The only options we need to set for this request are the URL to make the
    request to, and the `data` option which we use to post the URL of the page and
    the array of media queries to the server. The AJAX defaults we set earlier will
    also be used of course.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这些数据发送到服务器，可能是为了保存。对于这个请求，我们需要设置的唯一选项是要发送请求的URL，以及我们用来将页面的URL和媒体查询数组发送到服务器的`data`选项。当然，我们之前设置的AJAX默认值也会被使用。
- en: Classified Intel
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类情报
- en: If you're familiar with media queries already, feel free to skip to the start
    of the next task; if not we'll just look at them briefly here so that we all know
    what our script is trying to do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉媒体查询，请随意跳到下一个任务的开始；如果没有，我们在这里简要地看一下它们，以便我们都知道我们的脚本试图做什么。
- en: 'A media query is like an `if` conditional, but expressed in CSS. A media query
    in a CSS file will look something like the following code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询类似于CSS中的`if`条件语句。CSS文件中的媒体查询将类似于以下代码片段：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The statement begins with `@media` to signify a media query. The query specifies
    a medium, such as `screen`, and optionally additional conditions, such as `max-width`
    or `min-width`. The styles contained within the query will only be applied if
    the query is satisfied.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句以`@media`开头表示媒体查询。查询指定了一个媒介，例如`screen`，以及可选的附加条件，例如`max-width`或`min-width`。只有在满足查询条件时，查询中包含的样式才会被应用。
- en: Media queries are one of the staples of responsive web design, the other being
    relative dimensions. Typically, a responsively built web page will have one or
    more media queries that allow us to specify different layouts for a range of screen
    sizes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体查询是响应式网页设计的主要组成部分之一，另一个是相对尺寸。通常，一个响应式构建的网页将有一个或多个媒体查询，允许我们为一系列屏幕尺寸指定不同的布局。
- en: Each media query we include will set a breakpoint between layouts. When a breakpoint
    is exceeded, such as when the maximum width of the device is less than `320px`
    in the previous media query, the layout changes as directed by the media query.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含的每个媒体查询都将设置布局之间的断点。当断点超过时，例如在前一个媒体查询中设备的最大宽度小于`320px`时，布局会按照媒体查询指示进行更改。
- en: Capturing visitor clicks
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获访客点击
- en: In this task we need to build the part that captures any clicks that occur on
    the page. While the page is open we want to record information about the layout
    and the click itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们需要构建捕获页面上发生的任何点击的部分。在页面打开时，我们希望记录有关布局和点击本身的信息。
- en: Engage Thrusters
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We can capture clicks and record the other information we want to store using
    the following code, which should be added directly after the `ajax()` method that
    we added to `heat-map-client.js` in the last task:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码捕获点击并记录我们想要存储的其他信息，该代码应直接添加到上一个任务中我们添加到`heat-map-client.js`中的`ajax()`方法之后：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Objective Complete - Mini Debriefing
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: We can listen for clicks on the page by adding a handler using jQuery's `on()`
    method, and we'll also want to ensure that any images in the page have loaded
    fully before we start capturing clicks, because images will affect the height
    of the document, and that in turn will affect our calculations. Therefore we need
    to attach our event handler inside the callback function for the `imagesLoaded()`
    method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用jQuery的`on()`方法添加处理程序来监听页面上的点击，我们还希望确保页面中的任何图像在我们开始捕获点击之前已完全加载，因为图像将影响文档的高度，进而影响我们的计算。因此，我们需要将我们的事件处理程序附加到`imagesLoaded()`方法的回调函数内。
- en: We specify `click` as the event to listen for as the first argument, but also
    namespace the event with `jqHeat`. We'll probably want to use this on a range
    of pages, each of which may have its own event handling code that we don't want
    to interfere with this code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`click`指定为要监听的事件，但同时使用`jqHeat`对事件进行命名空间化。我们可能希望在一系列页面上使用此代码，每个页面可能具有自己的事件处理代码，我们不希望干扰此代码。
- en: Within the event handler we first need to set up some variables. The function
    receives the event object as an argument and we use this to set our first two
    variables, which store the `x` and `y` positions of the click. This figure will
    represent pixel points on the page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序中，我们首先需要设置一些变量。该函数将事件对象作为参数接收，我们使用它来设置我们的前两个变量，这些变量存储点击的`x`和`y`位置。此数字将表示页面上的像素点。
- en: We then store the width and height of the document. The reason we store this
    on every click is because the width, and therefore the height of the document,
    may change while the page is open.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后存储文档的宽度和高度。我们每次点击都存储这个的原因是因为页面的宽度，以及因此文档的高度，在页面打开期间可能会发生变化。
- en: People say that only developers resize their browsers while they are testing
    responsive builds, but this is not always the case. Depending on the breakpoints
    defined by any media queries in use, a change in device orientation could affect
    the width and height of the document, which could happen at any time after the
    page has loaded.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说只有开发人员在测试响应式构建时调整浏览器大小，但这并不总是事实。根据正在使用的媒体查询定义的断点，设备方向的变化可能会影响文档的宽度和高度，这可能会在页面加载后的任何时间发生。
- en: We define the `layout` variable next but we don't assign a value to this for
    now. We also create a new object to represent the click. Within this object we
    initially store the click coordinates as percentages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义`layout`变量，但我们暂时不为其分配值。我们还创建一个新对象来表示点击。在此对象中，我们最初将点击坐标存储为百分比。
- en: Converting the pixel coordinates into percentage coordinates is a trivial operation
    that simply involves dividing the pixel coordinate by the width (or height) of
    the document and then multiplying the figure by `100`. We use JavaScript's `Math.ceil()`
    function so that the number is rounded up to the next integer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将像素坐标转换为百分比坐标是一个微不足道的操作，只需将像素坐标除以文档的宽度（或高度），然后将该数字乘以`100`即可。我们使用JavaScript的`Math.ceil()`函数使数字向上舍入到下一个整数。
- en: Next we need to determine which layout we are in. We can iterate our `layouts`
    array using jQuery's `each()` method again. The callback function receives the
    index of the current item in the `layouts` array as the first argument and the
    second is the actual object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定我们处于哪种布局中。我们可以再次使用jQuery的`each()`方法迭代我们的`layouts`数组。回调函数的第一个参数接收`layouts`数组中当前项目的索引，第二个参数是实际对象。
- en: Inside the callback function we first set our variables. This time the variables
    we need are the minimum width of the layout, which we set to either the `min`
    property of the object, or zero if there is no `min` defined. We also set the
    `max` variable to either the `max` property of the current item, or the `width`
    of the document if there is no `max` property.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数内部，我们首先设置我们的变量。这次我们需要的变量是布局的最小宽度，我们将其设置为对象的`min`属性，如果没有定义`min`，则设置为零。我们还将`max`变量设置为当前项目的`max`属性，或者如果没有`max`属性，则设置为文档的宽度。
- en: Our last variable simply adds `1` to the current index. The index will be zero-based
    but it makes more sense for our layouts to be labeled `1` to the number of layouts
    instead of `0` to the number of layouts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的变量只是将当前索引加`1`。索引是从零开始的，但是对于我们的布局来说，将其标记为`1`到布局数目比标记为`0`到布局数目更有意义。
- en: We then use an `if` conditional to figure out which layout is currently being
    applied. We first check whether the current document width is greater or equal
    to the minimum value for the media query and less than or equal to the maximum.
    If it is, we know we're inside the current layout and so save the converted layout
    index to our `click` object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个`if`条件来确定当前应用的是哪个布局。我们首先检查当前文档宽度是否大于或等于媒体查询的最小值，并且小于或等于最大值。如果是，我们就知道我们在当前布局内，因此将转换后的布局索引保存到我们的`click`对象中。
- en: If we haven't matched any of our layouts, the browser must be larger than the
    highest `max-width` value defined by a media query, so we set the layout to the
    converted layout plus one again. Lastly we add the `click` object that we've created
    to the `clicks` array in our `clickStats` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有匹配到任何布局，那么浏览器的大小必须大于媒体查询定义的最大`max-width`值，所以我们将布局设置为转换后的布局再加一。最后，我们将创建的`click`对象添加到我们的`clickStats`对象的`clicks`数组中。
- en: Saving the click data
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存点击数据
- en: Someone has visited a page on which our heat map client script is running, they've
    clicked around, and our script so far has recorded each of those clicks. Now what?
    Now we need a way of transmitting that information to the server for permanent
    storage and display in the management console. This is what we'll look at in this
    task.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有人访问了一个我们的热图客户端脚本正在运行的页面，他们点击了一些内容，到目前为止我们的脚本已记录了每次点击。现在呢？现在我们需要一种将这些信息传输到服务器以进行永久存储并在管理控制台中显示的方法。这就是我们将在本任务中看到的内容。
- en: Engage Thrusters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We can ensure that any captured clicks are sent to the server for permanent
    storage using the following code, which should be added after the `imagesLoaded()`callback
    function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保将捕获的任何点击都发送到服务器以进行永久存储，使用以下代码，应在`imagesLoaded()`回调函数之后添加：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Objective Complete - Mini Debriefing
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你简报
- en: We attached a handler for the `beforeunload` event to the `window` object in
    order to post the data to the server before leaving the page. Unfortunately, this
    event isn't handled 100 percent of the time – there may be occasions when it doesn't
    fire.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`window`对象附加了一个`beforeunload`事件处理程序，以便在离开页面之前将数据发送到服务器。不幸的是，这个事件并不总是被完全处理
    - 有时它可能不会触发。
- en: In order to minimize this as much as possible we've attached the event handler
    directly to the native `window` object, not the jQuery wrapped one, which we can
    access via the first item in the array that is the jQuery object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽量将此功能减少到最小，我们直接将事件处理程序附加到原生的`window`对象上，而不是jQuery包装的对象，我们可以通过数组中的第一个项目访问该对象，该项目是jQuery对象。
- en: Using any jQuery method, including `on()`, adds overhead in that jQuery method,
    and as the underlying JavaScript functions are invoked. To reduce this overhead
    as much as possible we avoid using jQuery here and revert back to the old-school
    way of attaching event handlers by prefixing the event name with `on` and assigning
    a function as their value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何jQuery方法，包括`on()`，都会增加额外开销，因为会调用jQuery方法以及底层的JavaScript函数。为了尽量减少这种开销，我们在这里避免使用jQuery，并恢复到使用旧式方法来附加事件处理程序，即以`on`作为事件名的前缀，并将函数分配为它们的值。
- en: All we need to do inside this function is post the data to the server so that
    it can be inserted into a database. We use jQuery's `ajax()` method to make the
    request, and set the `async` option to `false` to make the request synchronous.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们需要做的就是将数据发送到服务器，以便将其插入到数据库中。我们使用jQuery的`ajax()`方法发起请求，并将`async`选项设置为`false`以使请求同步进行。
- en: This is important and will ensure the request is made in Chrome. We're not interested
    in a response from the server anyway – we just need to ensure the request is made
    before the page unloads.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，并且将确保请求在 Chrome 中发出。无论如何，我们对服务器的响应不感兴趣 - 我们只需确保在页面卸载之前发出请求即可。
- en: We also set the `type` to `POST` as we're sending data to the server, and set
    the `contentType` to `application/json`, which will set the appropriate headers
    for the request to ensure that the data is handled correctly on the server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `type` 设置为 `POST`，因为我们正在向服务器发送数据，并将 `contentType` 设置为 `application/json`，这将为请求设置适当的头，以确保服务器正确处理数据。
- en: The `url` is clearly the URL for the web service that we're sending the data
    to, and we set the `dataType` to `json`, which again can help to make consuming
    the data on the server easier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`url` 明显是我们要发送数据到的 Web 服务的 URL，并且我们将 `dataType` 设置为 `json`，这样可以更容易地在服务器上消耗数据。'
- en: Lastly we stringify the `clicks` array and wrap it in an object using the browser's
    native JSON engine. We send the stringified data to the server using the `data`
    option.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `clicks` 数组转换为字符串并使用浏览器的原生 JSON 引擎将其包装在对象中。我们使用 `data` 选项将字符串化的数据发送到服务器。
- en: At this point, when a page that this script is attached to is opened, the script
    will run quietly in the background recording the coordinates of any points on
    the page that are clicked. When the user leaves the page, the click data they've
    generated is dispatched to the server for storage.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，当打开连接到该脚本的页面时，脚本将在后台静静运行，记录页面上点击的任何点的坐标。当用户离开页面时，他们生成的点击数据将被发送到服务器进行存储。
- en: Classified Intel
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: Browsers that do not have a JSON engine, such as Version 7 of Internet Explorer
    and below, will not be able to run the code we added in this task, although there
    are polyfill scripts that can be used in these situations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不具有 JSON 引擎的浏览器，比如 Internet Explorer 的第 7 版及更低版本，将无法运行我们在此任务中添加的代码，尽管存在可在这些情况下使用的
    polyfill 脚本。
- en: For more information see the JSON repository at Github ([https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅 Github 上的 JSON 仓库（[https://github.com/douglascrockford/JSON-js](https://github.com/douglascrockford/JSON-js)）。
- en: Adding the management console
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加管理控制台
- en: I said at the start of this project that we wouldn't need to write any HTML
    or CSS. That was a minor exaggeration; we'll have to build the management console
    page ourselves, but don't worry, we won't have to write much – most of what we'll
    display on the page will be created dynamically.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我在项目开始时说过我们不需要编写任何 HTML 或 CSS。那是一个小小的夸张；我们将不得不自己构建管理控制台页面，但不用担心，我们不需要写太多代码 -
    我们在页面上显示的大部分内容都将是动态创建的。
- en: Prepare for Lift Off
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: Create a new HTML page based on our standard template file called `console.html`
    and save it in the `simplex` directory that we've been working in for this project.
    Next create a new script file called `console.js` and save it in the same folder.
    Lastly, create a new style sheet called `console.css` and save it in the `css`
    folder inside the `simplex` directory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的标准模板文件创建一个名为 `console.html` 的新 HTML 页面，并将其保存在我们为此项目工作的 `simplex` 目录中。接下来创建一个名为
    `console.js` 的新脚本文件，并将其保存在相同的文件夹中。最后，创建一个名为 `console.css` 的新样式表，并将其保存在 `simplex`
    目录内的 `css` 文件夹中。
- en: 'We should link to the new style sheet from the `<head>` of our new HTML page:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从新的 HTML 页面的 `<head>` 中链接到新样式表：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We should also link to jQuery and our new script file at the bottom of the
    `<body>`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该在 `<body>` 的底部链接到 jQuery 和我们的新脚本文件：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, we should add the class name `jqheat` to the `<body>` element:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该将类名 `jqheat` 添加到 `<body>` 元素中：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Engage Thrusters
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'The page will need to display an interface that can be used to select a page
    to view the click stats for. Add the following code to the `<body>` of `console.html`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 页面将需要显示一个界面，用于选择要查看点击统计信息的页面。将以下代码添加到 `console.html` 的 `<body>` 中：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also add some very basic CSS for these elements. Add the following code
    to `console.css`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为这些元素添加一些非常基本的 CSS。将以下代码添加到 `console.css` 中：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this task we won''t add any real functionality, but we can prepare our script
    file with the usual `document ready` handler in preparation for the next task.
    In `console.js`, add the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们不会添加任何实际功能，但我们可以准备好我们的脚本文件，以便在下一个任务中使用通常的 `document ready` 处理程序。在 `console.js`
    中，添加以下代码：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Objective Complete - Mini Debriefing
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标已完成 - 迷你总结
- en: Our page starts out with a `<header>` element that contains a heading for the
    page in `<h1>` and `<fieldset>`. Inside the `<fieldset>` is the mandatory `<legend>`
    and a very simple UI for the page, which consists of a single `<input>` and a
    `<button>` element. Both the `<input>` and the `<button>` elements have `id` attributes
    so that we can easily select them from the page in our script.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的页面首先包含一个包含`<h1>`和`<fieldset>`中页面标题的`<header>`元素。在`<fieldset>`内是必须的`<legend>`和一个非常简单的页面UI，它包含一个`<input>`和一个`<button>`元素。`<input>`和`<button>`元素都有`id`属性，以便我们可以在脚本中轻松选择它们。
- en: The main content area of the page consists of a `<section>` element, which is
    given a `role` attribute of `main`. It's standard practice to markup the main
    content area of the page using this attribute, which helps clarify the intent
    of the area to assistive technologies.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的主要内容区域由一个`<section>`元素组成，该元素具有`role`属性为`main`。使用此属性标记页面的主要内容区域是标准做法，有助于澄清该区域对辅助技术的意图。
- en: Inside the `<section>` is an `<iframe>`. We'll use the `<iframe>` to display
    the page the user wants to view click statistics for. For now it just has an `id`
    attribute, again so that we can select it easily, and the non-standard `scrolling`
    attribute set to `no`. I'm not a huge fan of using non-standard attributes, but
    in this case it is the simplest way to prevent the `<iframe>` having a pointless
    scrollbar when the content document is loaded into it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`<section>`内部是一个`<iframe>`。我们将使用`<iframe>`来显示用户想要查看点击统计信息的页面。目前，它只有一个`id`属性，这样我们就可以轻松选择它，并且非标准的`scrolling`属性设置为`no`。我不太喜欢使用非标准属性，但在这种情况下，这是防止在加载内容文档时`<iframe>`出现无意义滚动条的最简单方法。'
- en: There is a high chance of the page causing a scrollbar, and rather than have
    the movement that occurs when the scrollbar appears, we may as well set the `<body>`
    of our page to have a vertical scrollbar permanently, which we do in the CSS.
    Other than this, the CSS is mostly just positional stuff which we won't look at
    too deeply.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 页面很可能会导致滚动条出现，而我们可以设置页面的`<body>`永久具有垂直滚动条，而不是在滚动条出现时发生的移动。除此之外，CSS主要是一些定位相关的东西，我们不会深入研究。
- en: Classified Intel
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: We used the HTML5 `placeholder` attribute on our `<input>` element, which in
    supporting browsers displays the text added as the value of the attribute inside
    the `<input>`, acting as an inline label.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`<input>`元素上使用了HTML5的`placeholder`属性，在支持的浏览器中，该属性的值会显示在`<input>`内部，作为内联标签。
- en: This is useful because it means we don't have to add a whole new element just
    to display a `<label>`, but support, while good at the time of writing, is not
    100 percent. Luckily there are some excellent `polyfills` that handle providing
    a sensible fallback in un-supporting browsers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为这意味着我们不必添加一个全新的元素来显示一个`<label>`，但是在撰写时，支持并不是100%。幸运的是，有一些出色的`polyfills`可以在不支持的浏览器中提供合理的回退。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a whole range of `placeholder` polyfills (and many more besides) recommended
    by the Modernizr team. You can see the list in full by visiting [https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr团队推荐了一整套`placeholder` polyfills（还有许多其他推荐）。您可以通过访问[https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)来查看完整列表。
- en: Requesting click data
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求点击数据
- en: The console page starts out almost empty, containing mostly a form for loading
    the page that we want to view click data for. In this task we'll look at how we
    can load that page and request its data from the server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台页面几乎为空，主要包含一个用于加载我们想要查看点击数据的页面的表单。在这个任务中，我们将看看如何加载该页面并从服务器请求其数据。
- en: Engage Thrusters
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Start out by adding the following code to the empty function in `console.js`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`console.js`中的空函数中添加以下代码：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then add a click handler for the `<button>` element:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为`<button>`元素添加一个点击处理程序：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we can add an event handler for the custom `iframeloaded` event:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为自定义的`iframeloaded`事件添加事件处理程序：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective Complete - Mini Debriefing
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: We began, as we usually do, by setting some variables. We stored a reference
    to the `document` object wrapped in jQuery, which we can use to select any element
    on the page using this reference as a starting point, without creating a new jQuery
    object each time we select an element or bind an event handler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样开始，设置了一些变量。我们存储了一个包装在jQuery中的`document`对象的引用，我们可以使用这个引用作为起点在页面上选择任何元素，而无需每次选择元素或绑定事件处理程序时都创建一个新的jQuery对象。
- en: We also stored a reference to the `<input>` element that will contain the URL
    of the page, a reference to the `<button>` next to the `<input>`, and the `<iframe>`
    that we'll render the requested page into. Lastly we set an undefined variable
    called canvas, which we'll use to store a reference to a `<canvas>` element that
    we create using JavaScript's `createElement()` function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还存储了一个包含页面URL的`<input>`元素的引用，一个紧挨着`<input>`的`<button>`的引用，以及我们将加载请求页面的`<iframe>`的引用。最后，我们设置了一个未定义的变量叫做`canvas`，我们将使用`createElement()`函数使用JavaScript创建一个`<canvas>`元素的引用。
- en: We could use jQuery to create this element of course, but we're only creating
    a single element as opposed to a complex DOM structure, so we may as well use
    plain JavaScript and get a performance boost at the same time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用jQuery来创建这个元素，但我们只是创建一个单独的元素，而不是复杂的DOM结构，所以我们可以使用纯JavaScript同时获得性能提升。
- en: As before we can use the `ajaxSetup()` method to set the `type`, `contentType`,
    and `dataType` options for the requests that we'll be making to the server. We
    also used a converter to transform the data that will be returned by the server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们可以使用`ajaxSetup()`方法来设置将发送到服务器的请求的`type`、`contentType`和`dataType`选项。我们还使用了一个转换器来转换服务器将返回的数据。
- en: The `converters` option takes an object where the data type the converter should
    be used for is specified as a key, and the function to use as the converter is
    specified as a value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`converters` 选项接受一个对象，其中指定要用于数据类型的转换器的键，指定要用作转换器的函数的值。'
- en: Some servers will return JSON data wrapped in an object and stored in the property
    `d` for security, while other servers do not do this. Usually the `text json`
    data type would be parsed using jQuery's `parseJSON()` method, but in this case
    our code would still need to extract the actual data from the object before it
    could be used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器将返回包裹在属性`d`中的对象中的JSON数据，以增加安全性，而其他服务器不会这样做。通常，`text json`数据类型将使用jQuery的`parseJSON()`方法进行解析，但在这种情况下，我们的代码仍然需要从对象中提取实际数据，然后才能使用它。
- en: Instead our converter parses the JSON using the browser's native JSON parser
    and then returns either the contents of `d` if it exists, or the parsed data.
    This means that the code which processes the data is the same regardless of whether
    the data is wrapped in an object or not.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们的转换器使用浏览器的原生JSON解析器解析JSON，然后返回`d`的内容（如果存在）或解析的数据。这意味着处理数据的代码在数据是否包裹在对象中都是相同的。
- en: While not critical in this particular example, converters can be extremely useful
    in situations where code is being distributed and the platform on which it will
    run is not known in advance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个特定的例子中并不是必需的，但转换器在代码分发和将在其上运行的平台事先未知的情况下，可以非常有用。
- en: Next we added a click handler to the `document` using jQuery's `on()` method
    in event-delegation mode. To add a delegated handler, we attach the handler to
    a parent element, in this case `document`, and use the second argument to `on()`
    to provide a selector that events should be filtered against.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用jQuery的`on()`方法在事件代理模式下向`document`添加了一个点击处理程序。为了添加一个代理处理程序，我们将处理程序附加到一个父元素，即`document`，并使用`on()`的第二个参数来提供事件应该被过滤的选择器。
- en: Events bubble up the page, from the triggering element right up to the outer
    `window` object. The handler is only executed when the triggering element matches
    the selector passed as the second argument. The first argument is of course the
    type of event, and the third argument is the handler function itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事件从触发元素一直冒泡到外部的`window`对象。只有当触发元素与传递为第二个参数的选择器匹配时，处理程序才会被执行。第一个参数当然是事件类型，第三个参数是处理程序函数本身。
- en: Within the function we first prevent the default browser action for the event
    and then store the value of the `<input>` element in the variable `url`. We also
    set an undefined variable called `len`. We don't need to use that yet, but we
    will later on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们首先阻止事件的默认浏览器操作，然后将`<input>`元素的值存储在名为`url`的变量中。我们还设置了一个未定义的变量叫做`len`。我们现在不需要使用它，但以后会用到。
- en: Next we check whether the `url` variable we set has a truthy value, like a string
    with length for example. If it does, we remove the class name `empty` if the `<input>`
    element has it, then set the contents of the `<input>` as the element's data using
    jQuery's `data()` method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查我们设置的 `url` 变量是否具有真值，比如长度不为零的字符串。如果是，则如果 `<input>` 元素具有 `empty` 类名，则删除它，然后使用
    jQuery 的 `data()` 方法将 `<input>` 的内容设置为元素的数据。
- en: Associating the URL to the element in this way is a great way to persist the
    data so that it can be obtained from other functions in the code which do not
    have access to the event handler's scope. We also disable the `<button>` to prevent
    duplicate requests. We can enable it later on when the heat map has been painted
    to the screen.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式将 URL 关联到元素是一种很好的持久化数据的方法，这样可以从代码中的其他函数中获取数据，而这些函数无法访问事件处理程序的作用域。我们还禁用了
    `<button>` 以防止重复请求。在热图绘制到屏幕上后，我们可以随后启用它。
- en: We then added the URL that we obtained from the `<input>` element as the `src`
    property of the `<inframe>`, which causes the `<iframe>` to load the page the
    URL is for. We add a handler for the `load` event that will be fired by the `<iframe>`
    once the page has loaded. Inside this handler we fire a custom `iframeloaded`
    event using jQuery's `trigger()` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从 `<input>` 元素获得的 URL 添加为 `<inframe>` 的 `src` 属性，这会导致 `<iframe>` 加载该 URL
    所指向的页面。我们为 `<iframe>` 添加了一个 `load` 事件的处理程序，一旦页面加载完成，该处理程序将被触发。在这个处理程序内部，我们使用 jQuery
    的 `trigger()` 方法触发了一个自定义的 `iframeloaded` 事件。
- en: If the `url` variable does not contain a truthy value, we add the `empty` class
    to the `<input>` and enable the `<button>` once more.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `url` 变量不包含真值，则将 `empty` 类添加到 `<input>` 中，并再次启用 `<button>`。
- en: Lastly we added an event handler for the custom `iframeloaded` event. Custom
    events will bubble up to the `document` just like regular events so we can attach
    the handler to our cached `<body>` element and it will still be triggered at the
    appropriate time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为自定义的 `iframeloaded` 事件添加了一个事件处理程序。自定义事件会像常规事件一样冒泡到 `document`，因此我们可以将处理程序附加到我们缓存的
    `<body>` 元素，它仍然会在适当的时间被触发。
- en: Within this handler we get the URL for the page that has been loaded by recalling
    the data associated with the `<input>` element. We then make a request to the
    server using jQuery's `ajax()` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个处理程序中，我们通过回顾与 `<input>` 元素相关联的数据来获取已加载页面的 URL。然后，我们使用 jQuery 的 `ajax()` 方法向服务器发出请求。
- en: We've already set some of the required AJAX options as defaults using `ajaxSetup()`
    once again, so for this request we just set the `url` and the `data` options.
    This time the data we send is a stringified object containing the URL of the page,
    and the layout to get click data for. In response to this, we expect a JSON object
    containing a series of click objects, where each object contains `x` and `y` coordinates
    that refer to a specific point on the page.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经再次使用 `ajaxSetup()` 设置了一些必需的 AJAX 选项为默认值，因此对于此请求，我们只设置了 `url` 和 `data` 选项。这次发送的数据是一个包含页面
    URL 和获取点击数据的布局的字符串化对象。作为响应，我们期望收到一个 JSON 对象，其中包含一系列点击对象，每个对象包含指向页面上特定点的 `x` 和
    `y` 坐标。
- en: Note that at this point, we're hardcoding which layout to load into the request,
    which we set to number `4`. We'll come back to this in the next part and allow
    the user to select which layout to view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时我们正在硬编码要加载的布局，我们将其设置为 `4`。我们将在下一部分回来，并允许用户选择要查看的布局。
- en: Displaying a heat map
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示热图
- en: We're all set to display a heat map. In this task we'll process the click data
    in order to generate the heat map, and then display it using the `<canvas>` element
    on top of the `<iframe>`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好显示热图了。在这个任务中，我们将处理点击数据以生成热图，然后使用 `<canvas>` 元素显示在 `<iframe>` 上方。
- en: Engage Thrusters
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can add a success handler for the AJAX request we made at the
    end of the last task. We can do this by chaining the `done()` method to the `ajax()`
    method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以为上一个任务末尾所做的 AJAX 请求添加一个成功处理程序。我们可以通过将 `done()` 方法链接到 `ajax()` 方法来实现这一点：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then add a handler for the custom `canvasready` event. This should be
    added directly after the `iframeloaded` event handler:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为自定义的 `canvasready` 事件添加一个处理程序。这应该直接添加在 `iframeloaded` 事件处理程序之后：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Objective Complete - Mini Debriefing
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: Once the AJAX request has completed, we first store the height of the document
    that has been loaded in the `<iframe>`. The jQuery method may be passed a second
    argument after the selector, which sets the context that should be searched to
    match the selector. We can set the context to be the `contentDocument` object
    of the first `<iframe>` on the page, which we can access using `frame[0]`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 AJAX 请求完成，我们首先存储已在 `<iframe>` 中加载的文档的高度。jQuery 方法可以在选择器之后传递第二个参数，该参数设置应该被搜索以匹配选择器的上下文。我们可以将上下文设置为页面上第一个
    `<iframe>` 的 `contentDocument` 对象，我们可以使用 `frame[0]` 访问它。
- en: Setting the `height` of the `<section>` element will automatically make the
    `<iframe>` and the `<canvas>` element that we created earlier the `width` and
    `height` of the `<section>` so that the page can be viewed full size.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `<section>` 元素的 `height` 将自动使之前创建的 `<iframe>` 和 `<canvas>` 元素的 `width` 和
    `height` 等于 `<section>` 的宽度和高度，以便可以全屏查看页面。
- en: Next we set the `width` and `height` properties of the `<canvas>` element we
    created in the last task. We haven't set the `width` or `height` attributes of
    the `<canvas>` element yet, so by default it will only be 300 x 300 pixels in
    size, regardless of its visible size as set by the CSS. We therefore set the attributes
    to the correct sizes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了上一个任务中创建的 `<canvas>` 元素的 `width` 和 `height` 属性。我们尚未设置 `<canvas>` 元素的
    `width` 或 `height` 属性，因此默认情况下，无论 CSS 设置的可见大小如何，它都只有 300 x 300 像素的大小。因此，我们将属性设置为正确的大小。
- en: We can then append the new `<canvas>` to the `<section>` element on the page,
    and then fire the custom `canvasready` event. We're going to want to use the data
    passed by the server in an event handler for this event, so we pass this to the
    handler function using the second argument of the `trigger()` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将新的 `<canvas>` 添加到页面上的 `<section>` 元素中，然后触发自定义的 `canvasready` 事件。我们将要在此事件的事件处理程序中使用服务器传递的数据，因此我们使用
    `trigger()` 方法的第二个参数将其传递给处理程序函数。
- en: We then added a handler for the `canvasready` event. This function receives
    the event object and the click data as parameters. Within the function we first
    get the `width` and `height` of the `<canvas>` element. We stored the click data
    as percentages and we'll need to convert them back to pixel values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着为 `canvasready` 事件添加了一个处理程序。该函数接收事件对象和点击数据作为参数。在函数内部，我们首先获取 `<canvas>` 元素的
    `width` 和 `height`。我们将点击数据存储为百分比，需要将其转换为像素值。
- en: In order to paint on the `<canvas>`, we'll need to get a context. We can get
    a 2D context for the `<canvas>` and store it in a variable using the `getContext()`
    function of the canvas object. If the `<canvas>` element isn't supported, the
    `ctx` variable will be set to `null`. We can then only proceed to interact with
    the canvas if the context is not `null`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `<canvas>` 上绘制，我们需要获取一个上下文。我们可以使用 canvas 对象的 `getContext()` 函数获取 `<canvas>`
    的 2D 上下文并将其存储在一个变量中。如果不支持 `<canvas>` 元素，则 `ctx` 变量将被设置为 `null`。因此，只有在上下文不为 `null`
    时，我们才能继续与画布交互。
- en: If `ctx` is not `null`, we first clear the `<canvas>` using the `clearRect()`
    function of the canvas API and then set the color that we'll be painting on the
    canvas. We can set it to the RGBA (Red, Green, Blue, Alpha) string `0,0,255,.05`
    which is a semi-transparent blue. This only needs to be set once.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ctx` 不为 `null`，我们首先使用 canvas API 的 `clearRect()` 函数清除 `<canvas>`，然后设置我们将要在画布上绘制的颜色。我们可以将其设置为
    RGBA（红、绿、蓝、透明度）字符串 `0,0,255,.05`，这是一种半透明的蓝色。这只需要设置一次。
- en: We then iterate over the click data returned by the server using jQuery's `each()`
    method. The iterator function, which will be executed for the number of items
    in the clicks array, is passed the index of the current item in the array and
    the `click` object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 jQuery 的 `each()` 方法迭代服务器返回的点击数据。迭代器函数将执行数组中项目的数量，传递当前项目在数组中的索引和 `click`
    对象。
- en: We first store the `x` and `y` positions of each pixel that was clicked. These
    figures are currently percentages, so we need to convert them back to pixel values.
    This is just the opposite calculation that we performed in the client part of
    the heat map. We just multiply the percentage by the `width` or `height` of the
    `<canvas>` and then divide that figure by `100`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先存储每个点击的像素的 `x` 和 `y` 位置。这些数字目前是百分比，因此我们需要将它们转换回像素值。这只是在热力图的客户端部分执行的相反计算。我们只需将百分比乘以
    `<canvas>` 的 `width` 或 `height`，然后将该数字除以 `100`。
- en: We can then paint a dot on the `<canvas>` where the click occurred. We do this
    by starting a new path using the `beginPath()` method of the canvas object. The
    dot is drawn using the `arc()` method, which is passed a number of arguments.
    The first two are the coordinates of the center of the arc, which we set to the
    `x` and `y` values we've just calculated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在点击发生的地方在`<canvas>`上绘制一个点。我们通过使用 canvas 对象的`beginPath()`方法开始一个新路径来实现这一点。点是使用`arc()`方法绘制的，该方法传递了一些参数。前两个是圆弧中心的坐标，我们将其设置为刚计算的`x`和`y`值。
- en: The third argument is the radius of the circle. If we set the dot to be a single
    pixel the data would be quite difficult to interpret, so using a large dot instead
    of a single pixel improves the appearance of the heat map dramatically.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是圆的半径。如果我们将点设置为单个像素，数据将非常难以解释，因此使用大点而不是单个像素将大大提高热图的外观。
- en: The third and fourth arguments are the angles to start and stop the arc at,
    and are in radians not degrees. We can paint a complete circle by starting at
    zero radians and ending on about 6.5 radians.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个和第四个参数是弧开始和结束的角度，以弧度而不是度表示。我们可以通过从零弧度开始，到约 6.5 弧度结束来绘制完整的圆。
- en: Once the arc has been defined, we can close the path using the `closePath()`
    method and fill the arc with color using the `fill()` method. At this point we
    should be able to run the console in a browser, enter the URL of one of the template
    pages, and see the page with dots on it corresponding to the clicks.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了弧之后，我们可以使用`closePath()`方法关闭路径，并使用`fill()`方法填充弧形颜色。此时，我们应该能够在浏览器中运行控制台，输入模板页面之一的
    URL，并看到对应于点击的点的页面。
- en: Allowing different layouts to be selected
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许选择不同的布局
- en: In this task of the project, we need to allow the user to select each layout
    supported by the page. We can do this by using a `<select>` box which we populate
    at page load with each of the different layouts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的这个任务中，我们需要允许用户选择页面支持的每个布局。我们可以通过使用`<select>`框来实现这一点，在页面加载时用不同的布局填充它。
- en: Engage Thrusters
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can add the `<select>` element to the page. This can go in
    between the search field and the button at the top of the page in `console.html`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将`<select>`元素添加到页面中。这可以放在`console.html`顶部的搜索字段和按钮之间：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next we need to make a request at page load to populate the `<select>`element
    with an `<option>` for each of the different layouts. We can do this in the click
    handler for the `<button>` that we added in `console.js` earlier.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在页面加载时进行请求，为`<select>`元素填充每个不同布局的`<option>`。我们可以在之前在`console.js`中添加的`<button>`的点击处理程序中执行此操作。
- en: 'It will need to go into the first branch of the conditional that checks a URL
    has been entered into the `<input>`, directly before where we set the `src` of
    the `<iframe>`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要放在条件语句的第一个分支中，该条件语句检查是否已将 URL 输入到`<input>`中，直接在我们设置`<iframe>`的`src`之前。
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also add a little CSS for our new `<select>` element. We can just drop
    this into the bottom of `console.css`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们的新`<select>`元素添加一点 CSS。我们可以将这些内容放在`console.css`的底部：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Objective Complete - Mini Debriefing
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: First of all, we make the request to the server to get the layout information.
    The `url` is set to a web service that returns the layouts and the `data` is the
    URL of the page we'd like the layouts for.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向服务器发出请求以获取布局信息。`url`设置为返回布局的 Web 服务，`data`是我们想要布局的页面的 URL。
- en: We set a success handler using the `done()` method as is the recommended technique
    for adding success handlers to promise objects for when they become resolved.
    Within the handler we first set some variables.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`done()`方法设置了一个成功处理程序，这是向承诺对象添加成功处理程序的推荐技术，以便在它们解决时调用。在处理程序中，我们首先设置了一些变量。
- en: We create an `<option>` element as we'll need one of these for each layout and
    so can clone it as many times as we need by using the `clone()` method. We also
    update the `len` variable that we created earlier but left undefined, to the number
    of layouts, which is the `length` of the array the function will receive, and
    an undefined variable called `max`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`<option>`元素，因为我们每个布局都需要一个，所以可以使用`clone()`方法克隆它，需要多少次就可以克隆多少次。我们还更新了之前创建但未定义的`len`变量，将其更新为布局的数量，即函数将接收的数组的`length`，以及一个未定义的变量`max`。
- en: Next we define a function called `optText()` that we can use to generate the
    text for each `<option>` element we create. This function will accept the type
    of string to create, the index, and the min and max values.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个名为`optText()`的函数，我们可以使用它来为我们创建的每个`<option>`元素生成文本。该函数将接受要创建的字符串类型、索引和`min`和`max`值。
- en: Inside this function we set a couple of variables. The first, called `s`, is
    undefined at this point. The second variable `t1` is used to store some simple
    text that is used in each variant of the string.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，我们设置了几个变量。第一个变量称为`s`，在这一点上是未定义的。第二个变量`t1`用于存储在字符串的每个变体中使用的一些简单文本。
- en: Then we use a `switch` conditional to determine which string to build based
    on the type, which will be passed into the function as the first parameter and
    will be set to `normal`, `lastNoMax`, or `lastWithMax`, and which should account
    for the different types of media query that may be found.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`switch`条件来确定要构建的字符串，该字符串基于类型确定，该类型将作为第一个参数传递到函数中，并将设置为`normal`、`lastNoMax`或`lastWithMax`，并应该考虑可能找到的不同类型的媒体查询。
- en: In the `normal case`, we specify the `min` and `max` values. When there is no
    `max` value, we build the string using the `min` value and when there is a `max`
    value, we build the string using the `max` value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，我们指定了`min`和`max`值。当没有`max`值时，我们使用`min`值构建字符串，当有`max`值时，我们使用`max`值构建字符串。
- en: Each string is constructed using an array, then at the end of the function we
    return a string by joining whichever array was created.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符串都使用数组构造，然后在函数末尾，我们通过连接所创建的任一数组来返回一个字符串。
- en: We then use jQuery's `each()` method to iterate over the `layouts` object returned
    by the server. As always, the iterator function is passed the index of the current
    item and the current item itself as parameters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用jQuery的`each()`方法来迭代服务器返回的`layouts`对象。与往常一样，迭代器函数会传入当前项的索引和当前项本身作为参数。
- en: Within the iterator function, we set our variables, which in this case are the
    `min` and `max` property values from the current layout object, and the normal
    variant of the text string, which we're definitely going to use at least once.
    We call our `optText()` function and store the result for later use.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代器函数内部，我们设置了变量，这些变量在这种情况下是当前布局对象的`min`和`max`属性值，以及文本字符串的普通变体，我们肯定会至少使用一次。我们调用我们的`optText()`函数并将结果存储供以后使用。
- en: We then check whether we're on the last iteration, which we'll know when the
    index is equal to the length of the `layouts` array, which we stored earlier,
    minus `1`. If we are on the last iteration we then check whether the `max` value
    is equal to the string `none`. If it is, we call our `optText()` function again
    and set the text to the `lastNoMax` type, which generates the required text string
    for us. If it isn't we set the `max` variable, which we initially declared as
    undefined to the `max` value of the current object. Lastly, we create the `<option>`
    element required for each object in the `layouts` array. The `<option>` is given
    the text that we've set, and the value of the index plus `1`. Once created, the
    `<option>` is appended to the `<select>` element.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查是否处于最后一次迭代，我们会在索引等于之前存储的`layouts`数组长度减去`1`时知道。如果我们处于最后一次迭代，我们会检查`max`值是否等于字符串`none`。如果是，我们再次调用我们的`optText()`函数，并将文本设置为`lastNoMax`类型，该类型为我们生成所需的文本字符串。如果不是，则将`max`变量设置为当前对象的`max`值，该变量最初被声明为未定义。最后，我们为`layouts`数组中的每个对象创建所需的`<option>`元素。给定我们设置的文本，以及索引加`1`的值。创建完成后，将`<option>`追加到`<select>`元素中。
- en: Lastly we check whether the `max` variable has a truthy value. If it does, we
    call our `optText()` function once more, this time using the `lastWithMax` type,
    and create another `<option>` element, which we set as the selected item. This
    is required because we have one more layout than we have objects in the `layouts`
    array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查`max`变量是否有一个真值。如果是，我们再次调用我们的`optText()`函数，这次使用`lastWithMax`类型，并创建另一个`<option>`元素，将其设置为选定项。这是必需的，因为我们的布局比`layouts`数组中的对象多一个。
- en: When we run the page in a browser now, we should find that as soon as we enter
    a URL into the `<input>` and hit the load page, the `<select>` element becomes
    populated with an `<option>` for each of the layouts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行页面时，我们应该发现，当我们在`<input>`中输入URL并点击加载页面时，`<select>`元素会填充一个`<option>`，每个布局对应一个选项。
- en: Classified Intel
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: The middle `case` (`lastNoMax`) in the `switch` statement in our `optText()`
    function actually won't be used in this example because of how the media queries
    in the template we're using are structured. In this example the media query for
    the last break point is `769px` to `1024px`. Sometimes, media queries may be structured
    so that the final breakpoint contains just a `min-width`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`optText()`函数中，`switch`语句中的中间`case`（`lastNoMax`）实际上在这个示例中不会被使用，因为我们使用的模板中的媒体查询的结构如何。在这个示例中，最后一个断点的媒体查询是`769px`到`1024px`。有时，媒体查询可能结构化，使得最后一个断点只包含`min-width`。
- en: I've included this `case` of the `switch` to make the code support this other
    type of media query format as it is quite common and you're likely to run into
    it when using media queries yourself.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了`switch`的这个`case`，以使代码支持这种其他类型的媒体查询格式，因为这是相当常见的，当您自己使用媒体查询时，您可能会遇到它。
- en: Showing heat maps for each layout
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示每个布局的热图
- en: Now that we have each of the layouts in the `<select>` element, we can wire
    it up so that when the selected layout is changed, the page is updated to show
    the heat map for that layout.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`<select>`元素中有每个布局后，我们可以将其连接起来，以便当所选布局更改时，页面更新为显示该布局的热图。
- en: Engage Thrusters
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: In this task we'll need to modify some of the code written in a previous task.
    We need to change the click handler for the `<button>` so that the layout isn't
    hardcoded into the request.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们需要修改先前任务中编写的一些代码。我们需要更改`<button>`的点击处理程序，以便布局不会硬编码到请求中。
- en: 'First of all we need to pass the `len` variable to the handler for the `iframeloaded`
    event. We can do this by adding a second argument to the `trigger()` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将`len`变量传递给`iframeloaded`事件的处理程序。我们可以通过向`trigger()`方法添加第二个参数来实现这一点：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we need to update the callback function so that this object is received
    by the function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新回调函数，以便该对象由该函数接收：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can change the bit where we hardcoded layout `4` into the data passed
    to the server when making the request for click data:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改硬编码的布局`4`的位，在向服务器请求点击数据时传递给服务器的数据中：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we''re ready to update the heat map when `<select>` is changed. Add the
    following code directly after the `canvasready` handler in `console.js`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好在`<select>`更改时更新热图了。在`console.js`的`canvasready`处理程序之后直接添加以下代码：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Objective Complete - Mini Debriefing
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 小结
- en: We begin by delegating our handler to the document as we have with most of our
    other event handlers. This time we're listening for the `change` event triggered
    by the element with an `id` of `layouts`, which is the `<select>` element we added
    in the last task.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先委派我们的处理程序给文档，就像我们大多数其他事件处理程序一样。这次，我们正在监听由具有`id`为`layouts`的元素触发的`change`事件，这是我们在上一个任务中添加的`<select>`元素。
- en: We then continue following the previous form by setting a few variables. We
    get the URL saved as the `data` of the `<input>` element. We also cache the `<select>`
    element and the value of the selected `<option>`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续遵循以前的形式，设置一些变量。我们获取保存为`<input>`元素的`data`的URL。我们还缓存了`<select>`元素和所选`<option>`的值。
- en: Next we need to make an AJAX request to get the heat map for the selected layout.
    We set the `url` to a web service that will return this information, and send
    the `url` we want the heat map for, and the layout, as part of the request. Don't
    forget that this request will also use the defaults we set using `ajaxSetup()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要发起一个AJAX请求来获取所选布局的热图。我们将`url`设置为将返回此信息的Web服务，并将我们想要的热图的`url`和布局作为请求的一部分发送。不要忘记，此请求也将使用我们使用`ajaxSetup()`设置的默认值。
- en: We use the `done()` method once again to add a success handler for the request.
    When the response is received we first remove the existing `<canvas>` element
    from the page, and then set some more variables.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`done()`方法添加一个请求的成功处理程序。当收到响应时，我们首先从页面中删除现有的`<canvas>`元素，然后设置一些更多的变量。
- en: The first two variables are undefined to begin with; we'll populate these in
    just a moment. We store the `<option>` that was selected so that we can get its
    text, which is stored in the next variable. We get the minimum width of the breakpoint
    by splitting the text that we've just stored, and then cache a reference to the
    `<section>` on the page. Lastly we create a new `<canvas>` element to display
    the new heat map.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量一开始是未定义的；我们马上会填充这些。我们存储了所选的`<option>`，以便我们可以获取其文本，该文本存储在下一个变量中。我们通过分割我们刚刚存储的文本来获取断点的最小宽度，然后缓存页面上的`<section>`的引用。最后，我们创建一个新的`<canvas>`元素来显示新的热图。
- en: The conditional if statement that follows the variable deals with setting the
    first of our undefined variables – `width`. The first branch tests whether the
    layout requested is the last layout, and if so, sets the new `<canvas>` to the
    width of the screen.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的条件if语句处理设置我们的第一个未定义变量 - `width`。第一个分支测试所请求的布局是否是最后一个布局，如果是，则将新的`<canvas>`设置为屏幕的宽度。
- en: If the last layout was not requested, the next branch of the conditional checks
    whether the minimum width of the layout is greater than `0`. If it is, the `width`
    variable is set to the minimum breakpoint.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未请求最后一个布局，则条件的下一个分支检查布局的最小宽度是否大于`0`。如果是，则将`width`变量设置为最小断点。
- en: The final branch is used when the minimum width of the breakpoint is `0`. If
    the minimum width is `0`, we use the maximum `width` of the breakpoint instead,
    which we can obtain by splitting the text of the `<option>` once more.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当断点的最小宽度为`0`时，使用最终分隔`<option>`文本获得的最大断点`width`。
- en: We then set the width of the `<section>` element and the new `<canvas>` element
    using the width that we've just computed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用刚刚计算出的宽度来设置`<section>`元素和新的`<canvas>`元素的宽度。
- en: Following this we can define our second undefined variable – `loadedHeight`.
    This is calculated in the same way as it was before, by reaching into the document
    loaded into the `<iframe>` and getting the height of its `document` object using
    jQuery's `outerHeight()` method, which includes any padding the element may have.
    Once we have this value, we can then set the height of the `<section>` element
    and the new `<canvas>` element.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义我们的第二个未定义变量 - `loadedHeight`。这个变量的计算方式与之前相同，通过访问加载到`<iframe>`中的文档，并使用jQuery的`outerHeight()`方法获取其`document`对象的高度来获取，其中包括元素可能具有的任何填充。一旦我们有了这个值，我们就可以设置`<section>`元素和新的`<canvas>`元素的高度。
- en: We're about to trigger our `canvasready` event once more, as this will consume
    the click data and generate the heat map. Before we do that however, we just need
    to save the newly created `<canvas>` element back to the `canvas` variable that
    we set right at the top of `console.js`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们消耗点击数据并生成热图时，我们将再次触发我们的`canvasready`事件。不过，在此之前，我们只需将新创建的`<canvas>`元素保存回我们在`console.js`顶部设置的`canvas`变量即可。
- en: 'At this point we should be able to load the default heat map for a URL, then
    use the `<select>` element to view the heat map for another layout:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够加载URL的默认热图，然后使用`<select>`元素查看另一个布局的热图：
- en: '![Objective Complete - Mini Debriefing](img/9106OS_09_02.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![目标完成 - 小结](img/9106OS_09_02.jpg)'
- en: Classified Intel
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: I've used an **MS SQL** database to store the data, and a **c#** web service
    containing various web methods required for this project. Included in the code
    download accompanying this book is a backup of the database and a copy of the
    web service file for you to use if you wish.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了**MS SQL**数据库来存储数据，并使用包含此项目所需的各种Web方法的**C#** Web服务。在本书附带的代码下载中包含了数据库的备份和Web服务文件的副本，供您使用。
- en: MS SQL express is a free version of SQL server which the database can be restored
    to, and Visual Studio 2012 for web, which is also free, will happily run the web
    service through its built-in development server.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: MS SQL express是SQL服务器的免费版本，可以将数据库恢复到该版本，而免费的Visual Studio 2012 for web将愉快地通过其内置的开发服务器运行Web服务。
- en: If you don't have these products installed, and you have access to a Windows
    machine, I'd strongly recommend you install them so that you can see the code
    used in this project in action. The open source alternatives PHP and MySQL could
    also be used just as easily, although you'll need to write this code yourself.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装这些产品，并且您可以访问Windows机器，我强烈建议您安装它们，这样您就可以看到此项目中使用的代码运行情况。也可以轻松地使用开源替代产品PHP和MySQL，尽管您将需要自己编写此代码。
- en: Mission Accomplished
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: In this project we built a simple heat map generator that captured click data
    on web pages built using responsive techniques. We built two parts to the heat
    map generator – some code that runs in the browsers of the visitors of the website
    to capture every click on the screen, and a part that is used in conjunction with
    a simple management console in which the URL of the page the heat map is for,
    and the layout to display can be selected.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们构建了一个简单的热图生成器，用于捕获使用响应式技术构建的网页上的点击数据。我们将热图生成器分为两部分——一些在网站访问者的浏览器中运行的代码，用于捕获屏幕上的每次点击，以及一个与之配合使用的简单管理控制台，可以在其中选择要为其生成热图的页面的URL和要显示的布局。
- en: While we have to allow a margin of error to account for the pixel-to-percentage
    conversion and back again, different screen resolutions, and the range between
    different breakpoints, this easy-to-implement heat map can still give us valuable
    information about how our site is used, which features are popular, and which
    features are wasted screen space.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们必须允许一定的误差范围，以考虑像素到百分比的转换及其逆过程，不同的屏幕分辨率，以及不同断点之间的范围，但这个易于实现的热图仍然可以为我们提供有价值的信息，了解我们的网站如何使用，哪些功能受欢迎，哪些功能浪费了屏幕空间。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好全力以赴了吗？挑战热血青年
- en: One thing we haven't dealt with is color. Our heat map is built by dots of a
    uniform blue. As they're semi-opaque, they get darker as more dots appear in a
    condensed area, but with enough data, we should aim to change the color, going
    through red, yellow, and right up to white for the most-clicked areas. See if
    you can add this functionality yourself to really top the project off.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有处理的一个问题是颜色。我们的热图由均匀蓝色的点构成。由于它们是半透明的，在密集区域出现更多点时会变暗，但是随着足够多的数据，我们应该尽量改变颜色，从红色、黄色一直到白色为最多点击的区域。看看你是否能自己添加这个功能，真正为项目锦上添花。
