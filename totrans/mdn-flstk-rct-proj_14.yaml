- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Backend with a GraphQL API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have only been interfacing with REST APIs. For more complex
    APIs that have deeply nested objects, we can use GraphQL to allow selective access
    to certain parts of large objects. In this chapter, we are first going to learn
    what GraphQL is and when it is useful. Then, we are going to experiment with making
    GraphQL queries and mutations. After that, we are going to implement GraphQL in
    a backend. Finally, we are going to briefly cover advanced GraphQL concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is GraphQL?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a GraphQL API in a backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing GraphQL authentication and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of advanced GraphQL concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016)*,
    Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028)*,
    Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you are having an issue with the code and steps
    provided in this book, please try using the versions mentioned in *Chapters 1*
    and *2.*
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch11).'
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/6gP0uM-XaVo](https://youtu.be/6gP0uM-XaVo).'
  prefs: []
  type: TYPE_NORMAL
- en: What is GraphQL?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start learning how to use GraphQL, let’s first focus on what GraphQL
    is. Like REST, it is a way to query APIs. However, it is also much more than that.
    GraphQL includes a server-side runtime for executing queries and a type system
    to define your data. It works with many database engines and can be integrated
    into your existing backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL services are created by defining types (such as a `User` type), fields
    on types (such as a `username` field), and functions to resolve values of fields.
    Let’s assume we have defined the following `User` type with a function to get
    a username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then define a `Query` type and a function to get the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: The **Query** type is a special type that defines the “entry point” into the
    GraphQL schema. It allows us to define which fields are allowed to be queried
    using the GraphQL API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined types with fields and functions to resolve those fields,
    we can make a GraphQL query to get the username of the current user. GraphQL queries
    look like JavaScript objects, but they only list the field names that you want
    to query. The GraphQL API will then return a JavaScript object that has the same
    structure as the query, but with the values filled in. Let’s find out how a query
    to get the username of the current user would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That query would then return a JSON result that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the result has the same shape as the query. This is one of
    the essential concepts of GraphQL: the client can specifically ask for the fields
    that it needs, and the server will return exactly those fields. If we need more
    data about a user, we can just add new fields to the type and query.'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL validates queries and results against the defined types. This ensures
    that we do not break the contract between the client and server. The GraphQL types
    serve as that contract between the client and server. After validating the query,
    it is executed by a GraphQL server, which then returns a result that looks exactly
    like the shape requested by the query. Each requested field executes a function
    on the server. These functions are called **resolvers**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Interaction between GraphQL client and server](img/B19385_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Interaction between GraphQL client and server
  prefs: []
  type: TYPE_NORMAL
- en: 'Types and queries can also be deeply nested. For example, a user could have
    a field that returns all the posts that this user is an author of. We can then
    make a sub-selection of fields in those post objects as well. This works for objects
    within objects and even arrays of objects within objects, in multiple nesting
    levels. GraphQL will keep resolving fields until only simple values (scalars),
    such as strings and numbers are left. For example, the following query could fetch
    the IDs and titles of all posts that the current user created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, GraphQL allows us to define arguments for fields, which will
    be passed to the functions that resolve our fields. We can use arguments to, for
    example, get all posts with a certain tag. In GraphQL we can pass arguments to
    any field, even when they are deeply nested. Arguments can even be passed to single
    value fields, for instance, to transform a value. For example, the following query
    would get a post by ID and return the post title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL is especially useful if you build the backend yourself or with it in
    mind, as it can allow for patterns where deeply nested and interconnected data
    can be queried easily. However, if there are existing REST backends that you are
    not in control of, it is usually not worth it to add GraphQL as a separate, independent
    layer, due to its schema-based restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned about queries, let’s move on to mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In REST, any request could cause a side effect (such as writing data to the
    database). But, as we have learned, GET requests should only return data, and
    should not cause such side effects. Only POST/PUT/PATCH/DELETE requests should
    cause data in the database to change. In GraphQL, there is a similar concept:
    theoretically, any field function could cause the database state to change. However,
    in GraphQL, we define a mutation instead of a query to explicitly state that we
    want to change the database state. Besides being defined with the `mutation` keyword,
    mutations have the same structure as queries. There is one difference, though:
    queries fetch fields in parallel, while mutations run in series, executing the
    first field function first, then the next, and so on. This behavior ensures that
    we do not end up with race conditions in mutations.'
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the built-in **Query** type, there is also a **Mutation** type
    to define the allowed mutation fields.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned the basics of what GraphQL is and how it works, let’s
    get started using it in practice by implementing GraphQL in our blog application
    backend!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a GraphQL API in a backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to set up GraphQL in our existing blog application backend
    in addition to the REST API. Doing so will allow us to see how GraphQL compares
    to and differs from a REST API. Follow these steps to get started setting up GraphQL
    on the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the existing **ch10** folder to a new **ch11** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **ch11** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, let’s install a VS Code extension to add GraphQL language support. Go
    to the **Extensions** tab and search for the **GraphQL.vscode-graphql** extension
    developed by the GraphQL Foundation. Install the extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, install the **graphql** and **@apollo/server** libraries in the backend
    using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apollo Server is a production-ready GraphQL server implementation that supports
    multiple backend web frameworks, including Express.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/graphql/** folder. Inside it, create a **backend/src/graphql/query.js**
    file, inside which we define a **Query** schema, which is the entry point of our
    GraphQL API (listing all supported queries for our backend), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to add a `#graphql` directive at the beginning of the template
    string, so that the string is recognized as GraphQL syntax and properly highlighted
    in a code editor. Inside our schema, we defined a `test` field, for which we define
    a resolver now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a **queryResolver** object which contains a function to resolve the
    **test** field to a static string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new **backend/src/graphql/index.js** file and import the **querySchema**
    and **queryResolver** there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, export an array called **typeDefs**, which includes all schemas (for
    now, only the query schema) and an array called **resolvers**, which contains
    all resolvers (for now, only the query resolver):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **backend/src/app.js** and import **ApolloServer** and **expressMiddleware**
    from the **@****apollo/server** library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, import **typeDefs** and **resolvers**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all other middleware and before the route definitions, create a new Apollo
    server using the schema type definitions and defined resolvers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, after the server is ready, mount **expressMiddleware** to a **/graphql**
    route, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the backend in development mode by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go to **http://localhost:3001/graphql** in your browser; you should see the
    Apollo interface to input a query on the left side, and the results on the right
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove all comments from the editor on the left and input the following GraphQL
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press the **Play** button to run the query, and you will see the following
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Successful execution of our first GraphQL query!](img/B19385_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Successful execution of our first GraphQL query!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our query for the `test` field returns our previously defined
    static string!
  prefs: []
  type: TYPE_NORMAL
- en: After implementing a basic field, let’s implement some fields that access our
    service functions and retrieve data from MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing fields that query posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the fields to query posts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **backend/src/graphql/query.js** and import the relevant service functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adjust the schema to include a **posts** field, which returns an array of posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, define fields for querying posts by **author** and **tag**, both
    of which accept a required argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, define a field to query a post by **id**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined the schema, we still need to provide resolvers for
    all those fields. Thanks to our service functions, this is quite straightforward:
    we can simply call our service functions with the relevant arguments in **async**
    functions, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resolver functions always receive the `parent` object as the first argument
    and an object with all arguments as a second argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have successfully defined fields to query posts. However, the `Post`
    type is not defined yet, so our GraphQL queries will not work yet. Let’s do that
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Post type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining the `Query` type, we continue by defining the `Post` type, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/graphql/post.js** file, where we import the **getUserInfoById**
    function to resolve the author of a post later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define **postSchema**. Note that **Post** consists of **id**, **title**,
    **author**, **contents**, **tags**, and the **createdAt** and **updatedAt** timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we use `[String!]` for the tags, and not `[String!]!`, because
    the `tags` field can also be non-existent/`null`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `createdAt` and `updatedAt` timestamps are too large to fit into a 32-bit
    signed integer, so their type needs to be `Float` instead of `Int`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, define a resolver for the **author** field that gets the user using the
    service function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The resolvers for getting posts are already part of the `Query` schema, so we
    do not need to define how to get a post here. GraphQL knows that the query fields
    return `Post` arrays and then allows us to resolve further fields on the posts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit **backend/src/graphql/index.js** and add the **postSchema** and **postResolver**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After defining the `Post` type, let’s continue with the `User` type.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the User type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When defining the `Post` type, we used the `User` type to define the author
    of a post. However, we have not defined the `User` type yet. Let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/graphql/user.js** file and import the **listPostsByAuthor**
    function here, as we are going to add a way to resolve the posts of a user when
    getting a user object, to show how GraphQL can deal with deeply nested relations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define **userSchema**. Each **User** in our GraphQL schema has **username**
    and a **posts** field, in which we will resolve all posts that the user has written:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: We do not specify any other properties here, as we are only returning the username
    in our **getUserInfoById** service function. If we wanted to get the user ID here
    too, we would have to return it from that function. We are not just returning
    the full user object, as that could be a potential security vulnerability, exposing
    internal data such as the password (or billing info in some apps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define **userResolver**, which gets all posts from the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **backend/src/graphql/index.js** and add the **userSchema** and **userResolver**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After defining the `User` type, let’s try out some deeply nested queries!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out deeply nested queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have successfully defined our GraphQL schemas and resolvers, we
    can start querying our database using GraphQL!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can now get a full list of all posts, with their ID, title,
    and the username of the author, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Execute the preceding query in the Apollo interface. As we can see, the query
    gets all posts, selects `id`, `title`, and `author` for each post, and then resolves
    `username` for each `author` instance. This query allows us to get all the data
    we need on the overview page in a single request, and we do not need to make separate
    requests to resolve the author usernames anymore!
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: We did not specify the **password** field on the **User** type, so GraphQL will
    not allow us to access it, even if the resolver function returns a user object
    that contains the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try out a query that gets a post by ID and then finds other posts
    by the same author. This could be used to, for example, recommend other articles
    to view from the same author after someone has finished reading a post:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can automatically generate a query in the Apollo interface by clearing the
    contents of the **Operation** textbox and then selecting **Query** from **Root
    Types** in the **Documentation** sidebar on the left. Now click on the **+** button
    next to the **postById** field on the left, which automatically defines a query
    variable for us, which looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: "![Figure 11.\uFEFF3 – Automatically generating a query using the Apollo interface](img/B19385_11_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Automatically generating a query using the Apollo interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the post, we can now get the **title**, **contents**, and **author**
    values of the post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **author** field, we get **username** and the IDs and titles of
    their posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the Apollo interface, there is a **Variables** section, which
    we need to fill with an ID that exists in our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the query, and you will see that the post and author are resolved, and
    all posts written by that same author are also listed properly, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 11.\uFEFF4 – Running deeply nested queries in GraphQL](img/B19385_11_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Running deeply nested queries in GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn how to provide arguments to fields by defining input types.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing input types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already learned how to define regular types in GraphQL, but what if
    we have a common way to provide arguments to fields? For example, the options
    to query posts are always the same (`sortBy` and `sortOrder`). We cannot use a
    regular type for this, instead, we need to define an input type. Follow these
    steps to implement query options in GraphQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **backend/src/graphql/query.js** and define an input type in the schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the input type as an argument to fields, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, edit the resolvers to pass on **options** to the service functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try out the following query to see whether the posts are sorted properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the query by pressing the **Play** button, and you should see that the response
    is sorted by the **updatedAt** timestamp ascending!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have successfully implemented functionality to query our database
    using GraphQL, let’s move on to implementing a way to create a new post using
    GraphQL Mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GraphQL authentication and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to implement a way to create new posts using GraphQL. To define
    fields that change the database state, we need to create them under the `mutation`
    type. Before we can do that, however, we first need to implement authentication
    in GraphQL, so that we can access the currently logged-in user when creating a
    post.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication to GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because we are using GraphQL with Express, we can use any Express middleware
    with GraphQL and pass it to our resolvers as `context`. As such, we can use the
    existing `express-jwt` middleware to parse the JWT. Let’s get started adding authentication
    to GraphQL now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current configuration of the **requireAuth** middleware ensures that the
    user is logged in and throws an error if they are not. However, this is an issue
    when passing the **auth** context to GraphQL, because not all queries require
    authentication. We are now going to create a new **optionalAuth** middleware that
    does not require credentials to process a request. Edit **backend/src/middleware/jwt.js**
    and define the following new middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, edit **backend/src/app.js** and import the **optionalAuth** middleware
    there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the **app.use()** call where we defined the **/graphql** route and add
    the **optionalAuth** middleware to it, similarly to how we did it for routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a second argument to the Apollo **expressMiddleware**, defining a
    **context** function that provides **req.auth** to the GraphQL resolvers as context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let’s move on to implementing mutations in GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have added authentication to GraphQL, we can define our mutations.
    Follow these steps to create mutations for signup, login, and creating posts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **backend/src/graphql/mutation.js** file and import **GraphQLError**
    (for throwing an **UNAUTHORIZED** error when the user is not logged in), as well
    as the **createUser**, **loginUser**, and **createPost** functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define **mutationSchema**, in which we first define fields to sign up and log
    in users. The **signupUser** field returns a user object, and the **loginUser**
    field returns a JWT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define a field to create a new post from some given **title**, **contents**
    (optional), and **tags** (optional). It returns a newly created post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the resolver, in which we first define the **signupUser** and **loginUser**
    fields, which are quite straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the **createPost** field. Here, we first access the arguments
    passed to the field, and as a third argument to the resolver function, we get
    the context we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the user is not logged in, the **auth** context will be **null**. We throw
    an error in that case and do not create a new post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we use **auth.sub** (which contains the user ID) and the provided
    arguments to create a new post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **backend/src/graphql/index.js** and add the **mutationSchema** and **mutationResolver**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After implementing mutations, let’s learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Using mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining the possible mutations, we can use them by running them in the
    Apollo interface. Follow these steps to first sign up a user, then log them in,
    and finally create a post – all using GraphQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **http://localhost:3001/graphql** to view the Apollo interface. Define
    a new mutation that signs up a user with a given username and password, and returns
    the username if the signup was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can use the **Documentation** section on the left by going back to **Root
    Types**, clicking on **Mutation**, and then clicking on the **+** icon next to
    **signupUser**. Then, click on the **+** icon next to the **username** field.
    This will automatically create the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the variables at the bottom and enter a username and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the **SignupUser** mutation by pressing the play button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a new mutation to log in a user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enter the same variables as before and press the play button, the response contains
    a JWT. Copy and store the JWT somewhere for later use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a new mutation to create a post. This mutation returns **Post**, so
    we can get the **id**, **title**, and **username** values for **author**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is an example of where GraphQL really shines. We can resolve the username
    of the author after creating the post to see whether it was really created with
    the correct user, because we can access the resolvers defined for `Post`, even
    in mutations! As you can see, GraphQL is very flexible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the **Headers** tab, press the **New header** button, enter **Authorization**
    for **header key**, and **Bearer <Paste previously copied JWT here>** for **value**.
    Then press the **Play** button to submit the mutation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Adding the Authorization header in the Apollo interface](img/B19385_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Adding the Authorization header in the Apollo interface
  prefs: []
  type: TYPE_NORMAL
- en: In the response, you can see that the post was successfully created, and the
    author is set and resolved correctly!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having implemented GraphQL queries and mutations for our blog applications,
    let’s wrap up the chapter by giving an overview of advanced GraphQL concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of advanced GraphQL concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Out of the box, GraphQL comes with a set of scalar types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Int**: A signed 32-bit integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float**: A signed double-precision floating-point value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: A UTF-8 encoded character sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean**: Can be true or false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ID**: A unique identifier, serialized as a **String**, but meant to signify
    that it is not human readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GraphQL also allows the definition of enums, which are a special kind of scalar.
    They are restricted to certain values. For example, we could have the following
    enum to distinguish different types of posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In Apollo, enums will be handled as strings that can only have certain values,
    but this may be different in other GraphQL implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Many GraphQL implementations also allow defining custom scalar types. Apollo,
    for example, supports the definition of custom scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the same kind of fields are regularly accessed, we can create a fragment
    to simplify and standardize access to them. For example, if we often resolve users,
    and users have fields such as `username`, `profilePicture`, `fullName`, and `biography`,
    we could create the following fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This fragment can then be used in queries. For example, see this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Fragments are especially useful when the same kind of field structure is used
    multiple times in the same query. For example, if an author had `followedBy` and
    `follows` fields, we could resolve all users like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Introspection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introspection allows us to query the defined schemas themselves to get a feeling
    for the data that the server can provide for us. It is essentially querying the
    schemas defined by the GraphQL server. We can use the `__schema` field to get
    all schemas. A schema consists of `types`, which have `name` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use the following query to get all types defined by our
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you execute this query on our server, you will get (among other types) our
    defined `Query`, `Post`, `User`, and `Mutation` types.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection queries are very powerful, and you can get a lot of information
    about the possible queries and mutations from it. Actually, the Apollo interface
    uses introspection to render the **Documentation** sidebar and to auto-complete
    fields for us!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what GraphQL is and how it can be more flexible
    than REST while requiring less boilerplate code, especially when querying deeply
    nested objects. Then, we implemented GraphQL in our backend and created various
    types, queries, and mutations. We also learned how to integrate JWT authentication
    in GraphQL. Finally, we wrapped up the chapter by learning about advanced concepts,
    such as the type system, fragments, and introspection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 12*](B19385_12.xhtml#_idTextAnchor232)*, Interfacing
    with GraphQL on the Frontend Using Apollo Client*, we are going to learn how to
    access and integrate GraphQL in our frontend using React and the Apollo Client
    library.
  prefs: []
  type: TYPE_NORMAL
