- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E2E Tests in Angular with Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An app having a couple of **End-to-End** (**E2E**) tests surely promises more
    reliability than an app having no tests at all, and in today’s world, with emerging
    businesses and complex applications, it becomes essential at some point to have
    E2E tests written to capture the entire flow of an application. Cypress is one
    of the best tools out there today when it comes to E2E tests for web applications.
    In this chapter, you’ll learn how to test your E2E flows in an Angular app with
    Cypress. Here are the recipes we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Cypress test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating if a DOM element is visible on the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing form inputs and submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for **XMLHttpRequests** (**XHRs**) to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress bundled packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress fixtures to provide mock data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter11](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Cypress test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been writing E2E tests already, you might have been doing this using
    Protractor. Working with Cypress is a completely different experience, though.
    In this recipe, you’ll set up Cypress with an existing Angular application and
    write your first E2E test with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter11/ng-cypress-starter`
    inside the cloned repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the app in a new browser tab, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.1: ng-cypress-starter app running on localhost:4200'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we’re working with is a simple counter application. It has minimum
    and maximum values and some buttons that can increment, decrement, and reset the
    counter’s value. We’ll start by configuring Cypress for our application and will
    then move toward writing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re using an NX workspace, the setup here looks different from a regular
    Angular application. Open a new terminal window/tab and make sure you’re inside
    the workspace’s root folder. Once inside, run the following command to install
    **Cypress** in our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the following command from the workspace’s root folder to create a
    `cypress` project for the app as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When (or if) asked, choose the `Vite` bundler for Cypress during the installation
    since Vite is a faster bundler and provides a faster development server as well.
    And select the “Ap provided” so we have the folder `ng-cy-starter-e2e` created
    in `start/apps/chapter11` folder. You’ll see that a new folder named `ng-cypress-starter-e2e`
    will be created inside the `start/apps` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us run a script to rename our app from `chapter11-ng-cypress-starter-e2e`
    to `ng-cypress-starter-e2e`. This will make it easier for us to run the `e2e`
    tests for this recipe and the next. Use the following command from the workspace’s
    root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can run the following command to start the Cypress tests from the workspace’s
    root folder (outside of the `start` folder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should be able to use a browser to start running the tests. I will be using
    Chrome as the browser for `e2e` tests in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the `app.cy.ts` in the `cypress-chrome` window (the browser window opened
    as a result of *step 4*) to run the default-created tests. We will be modifying
    this file in the recipe to write our own tests. Once you run the tests, you’ll
    see them failing. But do not worry about it since we have not written our own
    tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us create our first test now. We will just check whether the title in the
    header of our app says `Your first Cypress test in Angular`. Let us replace the
    entire content of the `src/e2e/support/app.po.ts` file by creating a **PO** (**Page
    Object**) in the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now import the `getHeaderTitle` in the `src/e2e/app.cy.ts` file and
    replace the first test as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you look again at the Cypress window, you should see the test passing as
    follows:![](img/B18469_11_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.2: Our first Cypress test passes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Easy, right?* Now that you know how to configure Cypress for an Angular app
    (especially in NX), see the next section to understand how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cypress can be integrated with absolutely any framework and web development
    project. One interesting fact is that Cypress uses Mocha as the test runner behind
    the scenes. The tooling for Cypress watches for code changes so that you do not
    have to recompile the tests repeatedly. Cypress also adds a shell around the application
    being tested to capture logs and access DOM elements during the tests, and some
    functionality for debugging tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the very top of our `app.cy.ts` file, we use the `describe` method, which
    defines the test suite, defining the context of the tests about to be written
    inside. Then, we use a `beforeEach` method to specify what should happen before
    each test is executed. Since each test starts with no data, we first must make
    sure that Cypress navigates to our application’s URL: `http://localhost:4200`.
    The reason we just specify `cy.visit(''/'')` and it still works is that NX automagically
    configures it with the `@nx/cypress` package. If you add Cypress to a standard
    Angular app (not in an NX workspace), you will have to specify the `baseUrl` in
    the Cypress config file (`cypress.config.ts`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, NX does this for us for the recipes of this book. Therefore, we just
    have to provide relative URLs in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of our tests, we use the `it` method to specify the title for them.
    You will notice that in the `app.cy.ts` file, we are importing the `getHeaderTitle`
    method from the `support/app.po` file. As mentioned earlier in the recipe, **PO**
    means **page object**. This is a widespread practice to use these objects to contain
    functions that return **Document Object Module** (**DOM**) elements. This keeps
    our tests clear of code that interacts with the DOM to retrieve elements, and
    we have reusable functions for our tests. In the `app.po` file, you can see that
    we use the `cy.get` method to retrieve a single element that has the class `toolbar__title`
    applied to it. All the Angular applications for the recipes in this book have
    a header and a title that shows what the recipe is about. Notice that in the `app.cy.ts`
    file, we use the `getHeaderTitle` method to get the target element from our HTML
    page. And then we use the `should()` method to compare the text of the title with
    the expected value `Your first Cypress test in Angular`. Notice that we are using
    ‘`contain.text`'' instead of `''have.text''` because there can be whitespace in
    the target element. The following are some other examples of the `should` method
    with some different statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`should(''be.visible'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should(''be.empty'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should(''be.visible'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should(''have.class''''my-class'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should(''have.id''''newUserId'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should(''be.visible'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`should(''have.focus'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you understand how the recipe works, see the next section for some
    useful links.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cy.get` documentation: [https://docs.cypress.io/api/commands/get](https://docs.cypress.io/api/commands/get)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cypress documentation – W*riting Your First Test*: [https://docs.cypress.io/guides/getting-started/writing-your-first-test.html](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating if a DOM element is visible on the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most web applications, there is at least one element/view that is shown based
    on a certain condition. Otherwise, it is hidden. When it comes to making sure
    the end users see the right content in the right situations, it becomes necessary
    to test them well. In this recipe, you are going to learn how to check if an element
    is visible on the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter11/ng-cy-element-visibility`
    inside the cloned repository. However, the `e2e` tests are in the folder `start/apps/chapter11/ng-cy-element-visibility-e2e`.
    In this recipe, we are going to modify files in both folders. Let’s run the e2e
    tests first by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to run the e2e tests for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the Cypress window. Select Chrome for testing and click the
    `app.cy.ts` file to run the tests and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.3: Cypress tests running for the ng-cy-element-visibility app'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the app and the Cypress tests running locally, let us see the
    steps of the recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the same old counter app from the previous recipe. However, some things
    have changed. We now have a button at the top that toggles the visibility of the
    counter component `(CounterComponent)`. Also, we must hover over the counter card
    to see the **Increment**, **Decrement**, and **Reset** action buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the page objects necessary for our tests. We’ll create functions
    to return the toggle button and the counter card from the page object `app.po.ts`
    file. Update the `src/support/app.po.ts` file in the `start/apps/chapter11/ng-cy-element-visibility-e2e`
    folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add the relevant test IDs now to the HTML. We’ll add the `test-id` attributes
    for both the toggle-counter button and the counter element. Modify the file `ng-cy-element-visibility/src/app/app.component.html`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will write a test to ensure that our counter card is shown and hidden
    when we click the toggle-counter button. To do this, update the `ng-cy-element-visibility-e2e/src/e2e/app.cy.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll write another test to check if our action buttons (`Increment`,`Decrement`,and`Reset`)
    show up when we hover over the `Counter` component. Update the `app.cy.ts` file
    again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the Cypress window now, you should see the test failing, as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.4: Unable to get action buttons on hovering'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reason for the test’s failure is that Cypress does not currently provide
    a **CSS** hover effect. To work around this, we will install a package in the
    next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Stop running the e2e tests and then install the `cypress-real-events` package,
    as follows from the workspace’s root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `src/support/e2e.ts` file in the `ng-cy-element-visibility-e2e`
    project and update it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `app.cy.ts` file to use the `realHover` method from the package
    on the `counter card` element, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the `npm run e2e ng-cy-element-visibility` command again from the
    workspace root (if it is not running already). You should see all the tests passing,
    as shown in *Figure 11.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18469_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: All tests passing'
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! You’ve just learned how to check the visibility of DOM elements in
    different scenarios. These are, of course, not the only options available to identify
    and interact with DOM elements. You can refer to the Cypress documentation for
    more possibilities. Now that you have finished the recipe, see the next section
    to understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started the recipe by building the POs. It is a good idea to do so to have
    the functions ready for when we write the tests. And if a function doesn’t exist
    to get a particular page object, we can create it on the go. Notice that we check
    `getCounterCard` with a `should('exist')` statement. If you don’t already know,
    we could have used `should('be.visible')` as well, and that would work too. But
    when we want to make sure that it is not visible, we can’t use the `should('not.be.visible')`
    statement. And now you’ll be thinking, ‘‘What??’’ Exactly! Since `'visible'` in
    Cypress is built so that the element exists in the DOM and is visible too, it
    can’t accommodate cases where an element doesn’t exist in the DOM if we use `'be.visible'`
    or `'not.be.visible'`. And since we use the `*ngIf` directive to show or hide
    our `Counter` `component`, it ends up either *existing* in the DOM or not. Hence,
    using `should('exist')` and `should('not.exis')` is the appropriate choice here.
  prefs: []
  type: TYPE_NORMAL
- en: For the next test, we wanted to see if hovering (or doing a mouse over) on the
    counter card displays the action buttons. For this, we could use the `trigger`
    method on the counter card with the `mouseover` event. However, that won’t work.
    Why? Because all the hover workarounds in Cypress eventually lead to triggering
    the JavaScript events and doesn’t affect the CSS pseudo selectors, and since we
    have our action buttons (with the `'.counter__actions__action'` selector) shown
    on the `:hover` (CSS) of the element with the `'.counter'` selector, our tests
    fail because, in the tests, our action buttons are not actually shown. To tackle
    the issue, we use the `cypress-real-events` package, which has the `realHover`
    method that affects the pseudo selectors and eventually shows our action buttons.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress official documentation on the visibility of items: [https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility](https://docs.cypress.io/guides/core-concepts/interacting-with-elements.html#Visibility)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cypress-real-events` project repository: [https://github.com/dmtrKovalenko/cypress-real-events](https://github.com/dmtrKovalenko/cypress-real-events)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing form inputs and submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re building a web app, there’s a high chance that you’re going to have
    at least one form in it, and when it comes to forms, we need to make sure that
    we have the right **User Experience** (**UX**) and the right business logic in
    place. What better way to make sure everything works as expected than writing
    E2E tests for them? In this recipe, we’re going to test a form using Cypress and
    validate if the correct errors are being shown in appropriate situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter11/ng-cy-forms`
    inside the cloned repository. However, the e2e tests are in the folder `start/apps/chapter11/ng-cy-forms-e2e`.
    In this recipe, we’re going to modify files in both folders. Let’s run the e2e
    tests first by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to run the e2e tests for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the Cypress window. Select Chrome for testing and click the
    `app.cy.ts` file to run the tests and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.6: Cypress tests running for the app ng-cy-forms'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to make sure that we see a **new log** when the form is successfully
    submitted with a new version. We also need to make sure that we see relevant errors
    if the version input is empty, or if the value of the version input is an invalid
    value. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the page objects required for our tests. We already have the `data-test-id`
    attribute on the items we want to use in the tests. So, we can reference them
    in the page object file. Update the `start/apps/chapter11/ng-cy-forms-e2e/src/support/app.po.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will first validate that our form cannot be submitted unless we have a valid
    version. To do that, let’s make sure that the **Submit** button is disabled when
    the input gets cleared after typing, or when there’s an invalid value. Open the
    `src/e2e/app.cy.ts` file in the e2e project and add a test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the Cypress window and exapand the tests, you should see the
    tests passing, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.7: Checking if the Submit button is disabled when there is invalid
    input'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add another test that validates that we see a new version log when submitting
    a valid version. Add another test in the `app.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll add another test now to make sure that we can see the latest version
    above the version logs. Let’s modify the `app.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add a test that will verify if the user sees the error `''Version
    number is required''` when the version input is cleared after typing something,
    i.e., before the value is submitted. Add the test in the `app.cy.ts` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let us write a test to make sure we show an error message on invalid
    inputs. Add another test in the `app.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the **Tests** window now, you should see all the tests passing,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.8: All tests passing for the app'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Awesome! You now know how to use Cypress to test forms with some interesting
    use cases and assertions. See the next section to understand how it all works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by implementing some page objects in our `app.po.ts` file since we
    can reuse those methods to get the elements easily. Since our app’s logic has
    a rule that the **Submit** button should be disabled until we have a valid version
    in the version input, we use the `''be.disabled''` assertion on the **Submit**
    button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We then use the `getVersionInput().type('...')` function to type the desired
    values in the version input and check if the button is disabled either when we
    have an invalid value for the version input, or no value entered at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we check if there is a new log added to the logs list when a valid version
    is submitted. The important chunk of code for this test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we get the list of logs, i.e., the log items. Then we use `eq(1)`
    to get the second element from the list. Then we use the `then` method to get
    the `jQuery<HTMLElement>` so we can use the `trim` method on the text content
    of the element. This is because when writing HTML templates for Angular applications,
    we might end up writing the content in the HTML tags in a formatted way that ends
    up including whitespaces in the text content. So, it is a clever idea to trim
    the text before using the `expect` function against the expected value. Alternatively,
    you can use the `.should('contain.text', 'EXPECTED_TEXT')` assertion instead of
    the `.should('have.text', 'EXPECTED_TEXT')` assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the cases where we want to check that the appropriate errors are being
    displayed, we ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The error element exists on the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error element is visible to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error element has the appropriate error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we use the `then` method to get the error elements to trim the text
    content before our test assertions, like what we did for the log item’s text content
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress recipes – Form interactions: [https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/testing-dom__form-interactions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cypress recipes – Login form: [https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms](https://github.com/cypress-io/cypress-example-recipes/tree/master/examples/logging-in__html-web-forms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for XHRs to finish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing **User Interface** (**UI**) transitions is the essence of E2E testing.
    While it is important to test the predicted outcome of an action right away, there
    might be cases where the outcome has a dependency. For instance, if a user fills
    out the **Login** form, we can’t show the success toast until we have a successful
    response from the backend server, hence we can’t test whether the success toast
    is shown right away. In this recipe, you’re going to learn how to wait for a specific
    XHR call to be completed before performing an assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter11/ng-cy-http-requests`
    inside the cloned repository. However, the e2e tests are in the folder `start/apps/chapter11/ng-cy-http-requests-e2e`.
    In this recipe, we’re going to modify files for the e2e project only. Let’s run
    the e2e tests by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to run the e2e tests for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the Cypress window. Select Chrome for testing and click the
    `app.cy.ts` file to run the tests, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_09.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.9: Cypress tests running for the ng-cy-http-requests app'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start with some tests that will work just fine. However, if
    there’s a delay in the response for the HTTP calls, they will fail. That is because
    Cypress has a timeout of 4,000 **milliseconds** (**ms**) (4 seconds), during which
    it tries the assertion again and again until the assertion passes. What if our
    XHR takes more than 4,000 ms? Let’s try it out in the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write our test first. We’ll make sure that we get 10 users from the
    HTTP call’s response. But before that, we will create the desired page objects
    for this recipe in the `users.po.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the users.cy.ts file to add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will write another test to check if we get the searched users based on the
    search input’s value. Add another test in the `users.cy.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see both tests passing, as shown in *Figure 11.10*. However, this
    is not the best way of writing UI tests as they should be *independent* of the
    data received from actual API servers. In practice, we usually mock the API calls,
    which you will learn about in the *Using Cypress fixtures to provide mock data*
    recipe later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_10.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.10: Tests for the user page passing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First of all, we need to simulate the scenario where the desired result occurs
    after 4,000 ms. We’ll use the `delay` operator from `rxjs` for this, with a delay
    of 5,000 ms. Let’s apply it in the `user.service.ts` file in the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now check the Cypress tests, you should see a test failing, as shown
    in *Figure 11.11*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_11.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.11: Assertion failing for the test for searching a particular user'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now try to fix this, so it doesn’t matter how long the XHR takes—we’ll
    always wait for it to be completed before making an assertion. Let’s intercept
    the XHR call and create an alias for it so that we can use it later to wait for
    the XHR call. Update the `users.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s use the alias to wait for the XHR call to complete before the assertion.
    Update the `users.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you check the Cypress tests now for `users.cy.ts`, you should see all of
    them pass, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_12.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.12: Tests waiting for the XHR call to be completed before the assertion'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to implement E2E tests with Cypress that include waiting
    for a particular XHR call to finish before an assertion. To understand all the
    magic behind the recipe, see the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we use something called variable aliasing. We first use the `cy.intercept`
    method so that Cypress can listen to the network call. Note that we use the specific
    URL that is `/assets/users.json` as the parameter, and then we use the `.as('searchUsers')`
    statement to give an alias for this interception. Notice that we modified the
    `user.service.ts`, which causes a delay of 5,000 ms before the API call is made.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress has a default timeout of 4,000 ms, and we don’t want to restrict our
    API calls to be handled in our tests within 4,000 ms. Therefore, we use the `cy.wait('@searchUsers');`
    statement, using the `searchUsers` alias to inform Cypress that it must wait until
    the aliased interception happens—that is, until the network call is made, regardless
    of how long it takes until Cypress’s second timeout (30,000 ms for network calls)
    is reached. This makes our current tests pass, even though the default 4,000 ms
    Cypress timeout and 5,000 ms (about 5 seconds) timeout for HTTP calls in Cypress
    have already passed before actually making the network call. Magic, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Note that Cypress has a default timeout of 4,000 ms for assertions such as checking
    if an element is visible or has a particular text. It has a default timeout of
    5,000 ms for HTTP calls to be initiated. This made our test a bit tricky since
    we are delaying the initiation of the HTTP call while trying to simulate that
    the response is delayed from the server. Due to this, we had to use the `options`
    argument for `cy.wait` including setting the timeout to 10,000 ms. This allows
    Cypress to wait for the call to be initiated in 5,000 ms (which we added to the
    user service). In a real-world scenario, your HTTP call will be instantly initiated,
    and the response may be delayed. Cypress waits for 5,000 ms for the call to be
    initiated, so you should be fine. As soon as the call is initiated, Cypress defaults
    to the 30,000 ms timeout to wait for the response.
  prefs: []
  type: TYPE_NORMAL
- en: Well, I hope you liked this recipe—see the next section for a link for further
    reading.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Waiting in Cypress: [https://docs.cypress.io/api/commands/wait](https://docs.cypress.io/api/commands/wait)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress bundled packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cypress provides a bunch of bundled tools and packages that we can use in our
    tests to make things easier, not because writing tests with Cypress is otherwise
    hard but because these libraries are used by many developers already and so they’re
    familiar with them. In this recipe, we’re going to look at the bundled jQuery,
    Lodash, and Minimatch libraries to test some of our use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter11/ng-cy-bun-pack`
    inside the cloned repository. However, the e2e tests are in the folder `start/apps/chapter11/ng-cy-bun-pack-e2e`.
    And in the recipe, we’re going to modify files for the e2e project only. Let’s
    run the e2e tests by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to run the e2e tests for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the Cypress window. Select **Chrome** for testing and click
    the `users.cy.ts` file to run the tests, and you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_13.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.13: ng-cy-bun-pack app tests running with Cypress'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we have the `users` list and a search app that fetches some
    users from a JSON file using an HTTP request. We’re going to assert a few conditions
    for the DOM, validate the response from the API, and assert the URL changes as
    well. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll try out the bundled `jQuery` library along with Cypress. We can
    access this using `Cypress.$`. Let’s add another test and log out some DOM elements.
    Update the `users.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the tests (Cypress window) now, and specifically the console,
    you should see the log, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_14.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.14: Search input logged using jQuery via Cypress.$'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s try to change the value of the search input so we can see the `''No
    results''` message. Update the test further as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add a new page object element in the `users.po.ts` file so we can get
    the `noResults` message. Update the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s log the ‘‘`no results`''’ message using the `jQuery` element by using
    the page object in combination with the `then` method. Update the test in the
    `users.cy.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the no results message in the console in the Cypress window,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_15.png)Figure 11.15: noResults message logged using jQuery
    via Cypress.$'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the `jQuery` element is logged in the console. We’ll now use
    the Chai assertions to validate that it exists and has a message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the test further to check that the element exists and has the following
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you see the test now in Cypress, it should be passing, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_16.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.16: Test passing with the usage of jQuery via Cypress'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’re now going to use the `lodash.js` package that is bundled with Cypress
    to iterate over each card and ensure the date of birth is correctly formatted.
    Write another test in the `users.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add another test to use `lodash` again. We’ll ensure that all the names
    of the users are unique on the view, that is, there are no duplicate user cards.
    Add another test in the `users.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next package we’ll explore is the `minimatch` package. When we tap on a
    user card, it opens the user details. Since we append a timestamp to the URL as
    a query parameter, we can’t compare the URL as an exact match with our assertion.
    Let’s use the `minimatch` package to assert using a pattern instead. Add a new
    test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The tests have now all passed using the bundled packages with Cypress. Now that
    we’ve finished the recipe, let’s see how it all works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress bundles `jQuery` with it and we use it via the `Cypress.$` property.
    This allows us to perform everything that the `jQuery` function permits us to.
    For example, you can use the following functions from the bundled `jQuery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`each`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage: `$(elements).each(function(index, element) {})`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: Iterates over a jQuery object, executing a function for each matched
    element'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage: `$(selector).text()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: Gets the combined text contents of each element in the set of
    matched elements, including their descendants'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage: `$(selector).val()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: Gets the current value of the first element in the set of matched
    elements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasClass`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage: `$(selector).hasClass(className)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: Determines whether any of the matched elements are assigned to
    the given class'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addClass`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage: `$(selector).addClass(className)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: Adds the specified class(es) to each element in the set of matched
    elements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeClass`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage: `$(selector).removeClass(className)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Description: Removes a single class, multiple classes, or all classes from
    each element in the set of matched elements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: IMPORTANT NOTE
  prefs: []
  type: TYPE_NORMAL
- en: '`Cypress.$` can only fetch from the document elements that are available immediately
    on the DOM. This is great for debugging the DOM using the Chrome DevTools in the
    Cypress test window. However, it is important to understand that it doesn’t have
    any context about the Angular change detection. Also, you can’t query any element
    that isn’t visible on the page right from the beginning, as we experienced in
    the recipe—that is, it doesn’t wait for XHR calls for the elements to be visible.'
  prefs: []
  type: TYPE_NORMAL
- en: Cypress also bundles `lodash` and exposes it via the `Cypress._` object. In
    the recipe, we use the `_.each()` method to iterate over the card items to perform
    several tasks. We also use the `_.uniq` method, which takes an array and returns
    an array of unique items. We then compare the lengths of both the original array
    and the unique array to ensure that our original array has all unique names. Note
    that we can use any `lodash` method in our Cypress tests and not just the mentioned
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `minimatch` package, which Cypress exposes via the `Cypress.minimatch`
    object. The `minimatch` package is great for matching and testing glob patterns
    against strings. We use it to test the URL after navigating to a user’s detail
    page using a pattern. One important thing to know when using `minimatch` is that
    it compares the globs, which should contain the entire URL and not a string *acting
    like a Regex*. That’s why we use the `` `{location.origin}/users/${uuid}*` ``
    statement to include the `location.origin`.
  prefs: []
  type: TYPE_NORMAL
- en: Easy peasy. Now that you understand how the recipe works, see the next section
    for some useful links.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress bundled libraries: [https://docs.cypress.io/guides/references/bundled-tools](https://docs.cypress.io/guides/references/bundled-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jQuery`: [https://jquery.com/](https://jquery.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lodash`: [https://lodash.com](https://lodash.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minimatch.js`: [https://github.com/isaacs/minimatch](https://github.com/isaacs/minimatch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cypress fixtures to provide mock data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to writing E2E tests, fixtures play a great role in making sure
    the tests are not flaky (don’t have different results in different test runs).
    Consider that your tests rely on fetching data from your API server, or your tests
    include snapshot testing, which includes fetching images from a **Content Delivery
    Network** (**CDN**) or a third-party API. Although they’re technically required
    for the tests to run successfully, it is not important that the server data and
    the images are fetched from the original source; therefore, we can create fixtures
    for them. In this recipe, we’ll create fixtures for the bucket data to avoid having
    to run the server for the e2e tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app that we are going to work with resides in `start/apps/chapter11/ng-cy-mock-data`
    inside the cloned repository. However, the e2e tests are in the folder `start/apps/chapter11/ng-cy-mock-data-e2e`.
    In this recipe, we’re going to modify files for the e2e project only. Let’s run
    the e2e tests by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the code repository in your code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to run the e2e tests for the project with an API server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the Cypress window along with the server. Select Chrome for
    testing and click the `app.cy.ts` file to run the tests, and you should see the
    following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_17.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.17: ng-cy-mock-data tests running with Cypress'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the Cypress tests running, let’s see the steps of the recipe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the bucket app, which we have used in many recipes in this book. However,
    we’ll write some e2e tests in this one with Cypress. The interesting part is that
    the app talks to a backend server to manage the bucket items. Our tests are going
    to break when we add or remove items from the bucket with the real API. Let’s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our backend (`fake-be`) returns four bucket items by default. See the *How
    it works…* section to understand how. We will add a new test to the `app.cy.ts`
    file later to ensure that we are able to add another item to the bucket. But before
    that, let’s add some page objects in the `app.po.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can add our test to ensure that we’re able to add an item to the bucket.
    Add the following test to the `app.cy.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the point where our tests start to break, as shown in *Figure 11.18*.
    Since our test adds an item every time it runs to the actual server, we cannot
    expect the server to return the same number of items (four items) as our test,
    until we restart the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_18.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.18: Tests failing because of adding data to a real server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will first create a fixture for our HTTP call to the `fake-be` backend.
    Create a new file under the `src/fixtures` folder, named `get-bucket.json`. Then
    add the following JSON data to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s use the fixture in our `app.cy.ts` file. We’ll use it in the `beforeEach`
    life cycle hook since we want to use the fixture for all the tests in the file.
    Update the `app.cy.ts` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This does not fix the issue since the add item to bucket call is still sent
    to the real API. We’ll have to create the fixture for it as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file inside the `src/fixtures` folder. Name it `add-bucket-item.json`
    and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now use the `add-bucket-item` fixture in our tests file. Update the
    `app.cy.ts` file, as follows to use the fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now if you run the e2e tests, you should see all the tests passing. It does
    not matter how many times you refresh the Cypress window; they will always pass
    because the responses are the same every time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_19.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.19: Tests passing for add-bucket-item with fixtures'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now create a test for deleting an item and ensuring that we see the
    toast and one item is removed from the view. Let’s add another test in the `app.cy.ts`
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the tests now, you’ll see that the `delete item` test fails because
    it can’t find the item. That’s because this `DELETE` call is still being sent
    to the actual server. If you had your server running, you would see an error,
    as shown in *Figure 11.20*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_20.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.20: Item not found error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We’ll create a new fixture in the `src/fixtures` folder named `delete-bucket-item.json`.
    Add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s use the fixture in the `app.cy.ts` file in the `beforeEach()` hook,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you see the tests now, all of them should be passing, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B18469_11_21.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.21: All tests passing after using fixtures'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great! You now know how to use fixtures in Cypress E2E tests. Now that you’ve
    finished the recipe, see the next section for how this works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We had an initial test in the `app.cy.ts` file to ensure that we get four bucket
    items from the server when the app loads. You can see the backend file that sends
    the default bucket data, which resides at `<workspace-root>/codewithahsan/e2e/fake-be/src/app/bucket/bucket.service.ts`.
    However, as soon as we start adding items to the bucket via our tests, our tests
    break because we’re working with real data. And we should rarely be doing that
    to ensure we can make assertions accurately. That’s why big teams have test environments
    where they seed the data into the database if they really want to work with real
    data. Since our bucket app is super small, and we don’t really need to work with
    real data, we add fixtures in this recipe. Fixtures in a Cypress test are registered
    with the `cy.fixture` method, which allows us to use data from a file. In this
    recipe, we use fixtures for all the HTTP calls the app makes to the `fake-be`
    server, that is, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all bucket data – `GET` `http://localhost:3333/api/bucket`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add item to the bucket – `POST` `http://localhost:3333/api/bucket`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete item from the bucket – `DELETE` `http://localhost:3333/api/bucket/ITEM_ID`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that for each HTTP call, we use the `cy.fixture('FIXTURE_NAME')` without
    the `.json` extension, which essentially points to the `cypress/fixture/FIXTURE_NAME.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use the `cy.fixture` method to register the fixture (or to fetch it).
    Then we use the `then` method to get the contents of the fixture (JSON) file.
    Then we use the `cy.intercept` method to intercept the HTTP call using the `GET`/`POST`/`DELETE`
    method and the URL pattern as a `Minimatch` glob pattern to intercept the HTTP
    call to get the fixture response and provide it as the response for the HTTP call.
    As a result, all the intercepted calls matching the glob patterns use our fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how the recipe works, see the next section for some
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cypress fixtures documentation: [https://docs.cypress.io/api/commands/fixture](https://docs.cypress.io/api/commands/fixture)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cy.intercept` method documentation: [https://docs.cypress.io/api/commands/intercept](https://docs.cypress.io/api/commands/intercept)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/AngularCookbook2e](Chapter_11.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1388317275422265.png)'
  prefs: []
  type: TYPE_IMG
