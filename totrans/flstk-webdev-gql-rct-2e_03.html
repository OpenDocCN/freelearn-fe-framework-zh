<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-31"><em class="italic"><a id="_idTextAnchor032"/>Chapter 2</em>: Setting Up GraphQL with Express.js</h1>
			<p>The basic setup and prototype for our frontend are now complete. Now, we need to get our GraphQL server running to begin implementing the backend. Apollo and Express.js are going to be used to build the foundation of our backend.</p>
			<p>This chapter will explain the installation process for Express.js, as well as the configuration for our GraphQL endpoint. We will quickly go through all the essential features of Express.js and the debugging tools for our backend.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li>Express.js installation and explanation</li>
				<li>Routing in Express.js</li>
				<li>Middleware in Express.js</li>
				<li>Binding Apollo Server to a GraphQL endpoint</li>
				<li>Sending our first GraphQL requests</li>
				<li>Backend debugging and logging</li>
			</ul>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository:</p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter02</a></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Getting started with Node.js and Express.js</h1>
			<p>One of the primary goals of this book is to set up a GraphQL API, which is then consumed by our React frontend. To accept network requests – especially GraphQL requests – we are going to set up a Node.js web server.</p>
			<p>The most significant<a id="_idIndexMarker074"/> competitors in the Node.js web server area are Express.js, Koa, and Hapi. In this book, we are going to use Express.js. Most tutorials and articles about Apollo rely on it.</p>
			<p>Express.js is also the most used Node.js web server out there and describes itself as a Node.js web<a id="_idIndexMarker075"/> framework, offering all the main features needed to build web applications.</p>
			<p>Installing Express.js is easy. We can use <strong class="source-inline">npm</strong> in the same way as we did in the previous chapter:</p>
			<p class="source-code">npm install --save express</p>
			<p>This command adds the latest version of Express to <strong class="source-inline">package.json</strong>.</p>
			<p>In the previous chapter, we created all the JavaScript files directly in the <strong class="source-inline">src/client</strong> folder. Now, let's create a separate folder for our server-side code. This separation gives us a tidy directory structure. We can create this folder with the following command:</p>
			<p class="source-code">mkdir src/server</p>
			<p>Now, we can continue configuring Express.js.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Setting up Express.js</h2>
			<p>As always, we need a root file that's loaded with all the main<a id="_idIndexMarker076"/> components to combine them into a real application.</p>
			<p>Create an <strong class="source-inline">index.js</strong> file in the <strong class="source-inline">server</strong> folder. This file is the starting point for the backend. Here's how we do this:</p>
			<ol>
				<li>First, we must import <strong class="source-inline">express</strong> from <strong class="source-inline">node_modules</strong>, which we just installed:<p class="source-code">import express from 'express';</p><p>We can use <strong class="source-inline">import</strong> here since our backend gets transpiled by Babel. We are also going to set up webpack for the server-side code later in <a href="B17337_09_Final_ASB_ePub.xhtml#_idTextAnchor176"><em class="italic">Chapter 9</em></a>, <em class="italic">Implementing Server-Side Rendering</em>.</p></li>
				<li>Next, we must initialize the server with the <strong class="source-inline">express</strong> command. The result is stored in the <strong class="source-inline">app</strong> variable. Everything our backend does is executed through this object:<p class="source-code">const app = express();</p></li>
				<li>Then, we must specify<a id="_idIndexMarker077"/> the routes that accept requests. For this straightforward introduction, we accept all HTTP <strong class="source-inline">GET</strong> requests that match any path by using the <strong class="source-inline">app.get</strong> method. Other HTTP methods can be caught with <strong class="source-inline">app.post</strong> and <strong class="source-inline">app.put</strong>:<p class="source-code">app.get('*', (req, res) =&gt; res.send('Hello World!'));</p><p class="source-code">app.listen(8000, () =&gt; console.log('Listening on port 8000!'));</p></li>
			</ol>
			<p>To match all the paths, you can use an asterisk, which generally stands for <strong class="source-inline">any</strong> in the programming field, as we did in the preceding <strong class="source-inline">app.get</strong> line.</p>
			<p>The first parameter for all the <strong class="source-inline">app.METHOD</strong> functions is the path to match. From here, you can provide an unlimited list of callback functions, which are executed one by one. We are going to look at this feature later in the <em class="italic">Routing with Express.js</em> section.</p>
			<p>A callback always receives the client request as the first parameter and the response as the second parameter, which the server is going to send. Our first callback is going to use the <strong class="source-inline">send</strong> response method.</p>
			<p>The <strong class="source-inline">send</strong> function merely sends the HTTP response. It sets the HTTP body as specified. So, in our case, the body shows <strong class="source-inline">Hello World!</strong>, while the <strong class="source-inline">send</strong> function takes care of all the necessary standard HTTP headers, such as <strong class="source-inline">Content-Length</strong>. </p>
			<p>The last step is to tell Express.js which port the server should listen for requests on. In our code, we are using <strong class="source-inline">8000</strong> as the first parameter of <strong class="source-inline">app.listen</strong>. You can replace <strong class="source-inline">8000</strong> with any port or URL you want to listen on. The callback is executed when the HTTP server is bound to that port and requests can be accepted.</p>
			<p>This is the easiest setup we can have for Express.js.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Running Express.js in development</h2>
			<p>To launch our server, we have to add a new script to our <strong class="source-inline">package.json</strong> file.</p>
			<p>Let's add the following line<a id="_idIndexMarker078"/> to the <strong class="source-inline">scripts</strong> property of the <strong class="source-inline">package.json</strong> file:</p>
			<p class="source-code">"server": "nodemon --exec babel-node --watch src/server src/server/index.js"</p>
			<p>As you can see, we are using<a id="_idIndexMarker079"/> a command called <strong class="source-inline">nodemon</strong>. We need to install it first:</p>
			<p class="source-code">npm install --save nodemon</p>
			<p><strong class="source-inline">nodemon</strong> is an excellent tool for running a Node.js application. It can restart your server when the source changes.</p>
			<p>For example, to get the preceding command working, follow these steps:</p>
			<ol>
				<li value="1">First, we must install the <strong class="source-inline">@babel/node</strong> package since we are transpiling the backend code with Babel using the <strong class="source-inline">--exec babel-node</strong> option. This allows us to use the <strong class="source-inline">import</strong> statement:<p class="source-code"><strong class="bold">npm install --save-dev @babel/node</strong></p></li>
				<li>Providing the <strong class="source-inline">--watch</strong> option to <strong class="source-inline">nodemon</strong> when following a path or file will permanently track the changes on that file or folder and reload the server to represent the latest state of your application. The last parameter refers to the actual file being the starting execution point for the backend.</li>
				<li>Start the server:<p class="source-code"><strong class="bold">npm run server</strong></p></li>
			</ol>
			<p>Now, when you go to your browser and enter <strong class="source-inline">http://localhost:8000</strong>, you will see the text <strong class="bold">Hello World!</strong> from our Express.js callback function.</p>
			<p><a href="B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Connecting to the Database</em>, covers how Express.js routing works in detail.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/>Routing in Express.js</h1>
			<p>Understanding routing<a id="_idIndexMarker080"/> is essential to extending our backend code. In this section, we are going to play through some simple routing examples.</p>
			<p>In general, routing handles how and where an application responds to specific endpoints and methods.</p>
			<p>In Express.js, one path can respond to different HTTP methods and can have multiple handler functions. These handler functions are executed one by one in the order they were specified in the code. A path can be a simple string, but also a complex regular expression or pattern.</p>
			<p>When you're using multiple handler functions – either provided as an array or as multiple parameters – be sure to pass <strong class="source-inline">next</strong> to every callback function. When you call <strong class="source-inline">next</strong>, you hand over the execution from one callback function to the next function in the row. These functions can also be middleware. We'll cover this in the next section.</p>
			<p>Here is a simple example. Replace this with the current <strong class="source-inline">app.get</strong> line:</p>
			<p class="source-code">app.get('/', function (req, res, next) {</p>
			<p class="source-code">  console.log('first function');</p>
			<p class="source-code">  next();</p>
			<p class="source-code">}, function (req, res) {</p>
			<p class="source-code">  console.log('second function');</p>
			<p class="source-code">  res.send('Hello World!');</p>
			<p class="source-code">});</p>
			<p>When you refresh your browser, look at the server logs in the Terminal; you will see that both <strong class="source-inline">first function</strong> and <strong class="source-inline">second function</strong> are printed. If you remove the execution of <strong class="source-inline">next</strong> and try to reload the browser tab, the request will time out and only <strong class="source-inline">first function</strong> will be printed. This problem occurs because neither <strong class="source-inline">res.send</strong> nor <strong class="source-inline">res.end</strong>, nor any alternative, is called. The second handler function is never executed when <strong class="source-inline">next</strong> is not run.</p>
			<p>As we mentioned previously, the <strong class="bold">Hello World!</strong> message is nice but not the best we can get. In development, it is completely okay for us to run two separate servers – one for the frontend and one for the backend.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/>Serving our production build</h2>
			<p>We can serve<a id="_idIndexMarker081"/> our production build of the frontend through Express.js. This approach is not great for development purposes but is useful for testing the build process and seeing how our live application will act.</p>
			<p>Again, replace the previous routing example with the following code:</p>
			<p class="source-code">import path from 'path';</p>
			<p class="source-code">const root = path.join(__dirname, '../../');</p>
			<p class="source-code">app.use('/', express.static(path.join(root, 'dist/client')));</p>
			<p class="source-code">app.use('/uploads', express.static(path.join(root, </p>
			<p class="source-code">  'uploads')));</p>
			<p class="source-code">app.get('/', (req, res) =&gt; {</p>
			<p class="source-code">  res.sendFile(path.join(root, '/dist/client/index.html'));</p>
			<p class="source-code">});</p>
			<p>The <strong class="source-inline">path</strong> module offers many functionalities for working with the directory structures.</p>
			<p>We use the global <strong class="source-inline">__dirname</strong> variable to get our project's root directory. The variable holds the path of the current file. Using <strong class="source-inline">path.join</strong> with <strong class="source-inline">../../</strong> and <strong class="source-inline">__dirname</strong> gives us the real root of our project.</p>
			<p>Express.js provides the <strong class="source-inline">use</strong> function, which runs a series of commands when a given path matches. When executing this function without a path, it is executed for every request.</p>
			<p>We use this feature to serve our static files (the avatar images) with <strong class="source-inline">express.static</strong>. They include <strong class="source-inline">bundle.js</strong> and <strong class="source-inline">bundle.css</strong>, which are created by <strong class="source-inline">npm run client:build</strong>.</p>
			<p>In our case, first, we pass <strong class="source-inline">'/'</strong> with <strong class="source-inline">express.static</strong> following it. The result of this is that all the files and folders in <strong class="source-inline">dist</strong> are served beginning with <strong class="source-inline">'/'</strong>. The other paths in the first parameter of <strong class="source-inline">app.use</strong>, such as <strong class="source-inline">'/example'</strong>, would lead to our <strong class="source-inline">bundle.js</strong> file being able to be downloaded under <strong class="source-inline">'/example/bundle.js'</strong> instead.</p>
			<p>For example, all the avatar images are served under <strong class="source-inline">'/uploads/'</strong>.</p>
			<p>We are now prepared to let the client download all the necessary files. The initial route for our client is <strong class="source-inline">'/'</strong>, as specified by <strong class="source-inline">app.get</strong>. The response to this path is <strong class="source-inline">index.html</strong>. We run <strong class="source-inline">res.sendFile</strong> and the file path to return this file – that is all we have to do here.</p>
			<p>Be sure to execute <strong class="source-inline">npm run client:build</strong> first. Otherwise, you will receive an error message, stating that these files were not found. Furthermore, when running <strong class="source-inline">npm run client</strong>, the <strong class="source-inline">dist</strong> folder is deleted, so you must rerun the build process.</p>
			<p>Refreshing your browser<a id="_idIndexMarker082"/> now will present you with the <em class="italic">post</em> feed and form from <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>.</p>
			<p>The next section focuses on the great functionality of middleware functions in Express.js.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>Using Express.js middleware</h1>
			<p>Express.js provides<a id="_idIndexMarker083"/> us with great ways to write efficient backends without duplicating code.</p>
			<p>Every middleware function receives a request, a response, and <strong class="source-inline">next</strong>. It needs to run <strong class="source-inline">next</strong> to pass control to the next handler function. Otherwise, you will receive a timeout. Middleware allows us to pre- or post-process the request or response object, execute custom code, and much more. Previously, we covered a simple example of handling requests in Express.js.</p>
			<p>Express.js can have multiple routes for the same path and HTTP method. The middleware can decide which function should be executed.</p>
			<p>The following code is an easy example that shows what can generally be accomplished with Express.js. You can test this by replacing the current <strong class="source-inline">app.get</strong> routes:</p>
			<ol>
				<li value="1">The root path, <strong class="source-inline">'/'</strong>, is used to catch any requests:<p class="source-code">app.get('/', function (req, res, next) {</p></li>
				<li>Here, we will randomly generate a number with <strong class="source-inline">Math.random</strong> between 1 and 10:<p class="source-code">var random = Math.random() * (10 -1) + 1;</p></li>
				<li>If the number is higher than <strong class="source-inline">5</strong>, we run the <strong class="source-inline">next('route')</strong> function to skip to the next <strong class="source-inline">app.get</strong> with the same path:<p class="source-code">if (random &gt; 5) next('route')</p><p>This route will log <strong class="source-inline">'second'</strong>.</p></li>
				<li>If the number is lower<a id="_idIndexMarker084"/> than <strong class="source-inline">0.5</strong>, we execute the <strong class="source-inline">next</strong> function without any parameters and go to the next handler function. This handler will log <strong class="source-inline">'first'</strong>:<p class="source-code">  else next()</p><p class="source-code">}, function (req, res, next) {</p><p class="source-code">  res.send('first');</p><p class="source-code">})</p><p class="source-code">app.get('/', function (req, res, next) {</p><p class="source-code">  res.send('second');</p><p class="source-code">})</p></li>
			</ol>
			<p>You do not need to copy this code as it is just an explanatory example. This functionality can come in handy when we cover special treatments such as admin users and error handling.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor040"/>Installing important middleware</h2>
			<p>For our application, we have already used one<a id="_idIndexMarker085"/> built-in Express.js middleware: <strong class="source-inline">express.static</strong>. Throughout this book, we will continue to install other pieces of middleware:</p>
			<p class="source-code">npm install --save compression cors helmet</p>
			<p>Now, add the <strong class="source-inline">import</strong> statement for the new packages inside the server's <strong class="source-inline">index.js</strong> file so that all the dependencies are available within the file:</p>
			<p class="source-code">import helmet from 'helmet';</p>
			<p class="source-code">import cors from 'cors';</p>
			<p class="source-code">import compress from 'compression';</p>
			<p>Let's see what these packages<a id="_idIndexMarker086"/> do and how we can use them.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Express Helmet</h2>
			<p>Helmet is a tool that allows you to set various HTTP headers to secure your application.</p>
			<p>We can enable the Express.js Helmet middleware<a id="_idIndexMarker087"/> as follows in the server's <strong class="source-inline">index.js</strong> file. Add the following code snippet directly beneath the <strong class="source-inline">app</strong> variable:</p>
			<p class="source-code">app.use(helmet());</p>
			<p class="source-code">app.use(helmet.contentSecurityPolicy({</p>
			<p class="source-code">  directives: {</p>
			<p class="source-code">    defaultSrc: ["'self'"],</p>
			<p class="source-code">    scriptSrc: ["'self'", "'unsafe-inline'"],</p>
			<p class="source-code">    styleSrc: ["'self'", "'unsafe-inline'"],</p>
			<p class="source-code">    imgSrc: ["'self'", "data:", "*.amazonaws.com"]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}));</p>
			<p class="source-code">app.use(helmet.referrerPolicy({ policy: 'same-origin' }));</p>
			<p>We are doing multiple things here at once. In the preceding<a id="_idIndexMarker088"/> code, we added some <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) protection tactics and removed the <strong class="source-inline">X-Powered-By</strong> HTTP header, as well as some other useful things, just by using the <strong class="source-inline">helmet()</strong> function in the first line.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can look up the default parameters, as well as the other functionalities of Helmet, at <a href="https://github.com/helmetjs/helmet">https://github.com/helmetjs/helmet</a>. Always be conscious when implementing security features and do your best to verify your attack protection methods.</p>
			<p>Furthermore, to ensure that no one can inject malicious code, we used the <strong class="source-inline">Content-Security-Policy</strong> HTTP header or CSP for short. This header prevents attackers from loading resources from external URLs. </p>
			<p>As you can see, we also specified the <strong class="source-inline">imgSrc</strong> field, which tells our client that only images<a id="_idIndexMarker089"/> from these URLs should be loaded, including <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>). We will learn how to upload images to it in <a href="B17337_07_Final_ASB_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Image Uploads</em>.</p>
			<p>You can read more about CSP and<a id="_idIndexMarker090"/> how it can make your platform more secure at <a href="https://helmetjs.github.io/docs/csp/">https://helmetjs.github.io/docs/csp/</a>.</p>
			<p>The last enhancement is to set the <strong class="source-inline">Referrer</strong> HTTP header, but only when making requests on the same host. When we're going from domain A to domain B, for example, we do not include the referrer, which is the URL the user is coming from. This enhancement stops any internal routing or requests from being exposed to the internet.</p>
			<p>It is important to initialize<a id="_idIndexMarker091"/> Helmet very high in your Express router so that all the responses are affected.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Compression with Express.js</h2>
			<p>Enabling compression<a id="_idIndexMarker092"/> for Express.js saves you and your user bandwidth, and this is easy to do. The following code must also be added to the server's <strong class="source-inline">index.js</strong> file:</p>
			<p class="source-code">app.use(compress());</p>
			<p>This middleware compresses all the responses going through it. Remember to add it very high in your routing order so that all the requests are affected.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Whenever you have middleware like this or multiple routes that match the same path, you need to check the initialization order. Only the first matching route is executed unless you run the <strong class="source-inline">next</strong> command. All the routes that are defined afterward will not be executed.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>CORS in Express.js</h2>
			<p>We want our GraphQL API to be accessible from any website, app, or system. A good idea might be to build an app<a id="_idIndexMarker093"/> or offer the API to other companies or developers so that<a id="_idIndexMarker094"/> they can use it. When you're using APIs via Ajax, the main problem is that the API needs to send the correct <strong class="source-inline">Access-Control-Allow-Origin</strong> header.</p>
			<p>For example, if you build the API, publicize it under <strong class="source-inline">https://api.example.com</strong>, and try to access it from <strong class="source-inline">https://example.com</strong> without setting the correct header, it won't work. The API would need to set at least <strong class="source-inline">example.com</strong> inside the <strong class="source-inline">Access-Control-Allow-Origin</strong> header to allow this domain to access its resources. This seems a bit tedious, but it makes your API open to cross-site requests, which you should always be aware of.</p>
			<p>Allow <strong class="bold">cross-origin resource sharing</strong> (<strong class="bold">CORS</strong>) requests by adding the following command to the <strong class="source-inline">index.js</strong> file:</p>
			<p class="source-code">app.use(cors());</p>
			<p>This command handles all the problems we usually have with cross-origin requests at once. It merely sets a wildcard with <strong class="source-inline">*</strong> inside of <strong class="source-inline">Access-Control-Allow-Origin</strong>, allowing anyone from anywhere to use your API, at least in the first instance. You can always secure your API by offering API keys or by only allowing access to logged-in users. Enabling CORS only allows the requesting site to receive the response.</p>
			<p>Furthermore, the command also implements the <strong class="source-inline">OPTIONS</strong> route for the whole application.</p>
			<p>The <strong class="source-inline">OPTIONS</strong> method or request is made every time we use <strong class="source-inline">CORS</strong>. This action is what's called a <strong class="bold">preflight</strong> request, which ensures that the responding server<a id="_idIndexMarker095"/> trusts you. If the server does not respond correctly to the <strong class="source-inline">OPTIONS</strong> preflight, the actual method, such as <strong class="source-inline">POST</strong>, will not be made by the browser at all.</p>
			<p>Our application is now ready to serve all the routes appropriately and respond with the right headers.</p>
			<p>Now, let's set up a GraphQL server.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor044"/>Combining Express.js with Apollo</h1>
			<p>First things first; we need to install the Apollo and GraphQL dependencies:</p>
			<p class="source-code">npm install --save apollo-server-express graphql @graphql-tools/schema </p>
			<p>Apollo offers an Express.js-specific package<a id="_idIndexMarker096"/> that integrates itself into the web<a id="_idIndexMarker097"/> server. There is also a standalone version without Express.js. Apollo allows you to use the available Express.js middleware. In some scenarios, you may need to offer non-GraphQL routes to proprietary clients who do not implement GraphQL or are not able to understand JSON responses. There are still reasons to offer some fallbacks to GraphQL. In those cases, you can rely on Express.js since you are already using it.</p>
			<p>Create a separate folder for services. A service can be GraphQL or other routes:</p>
			<p class="source-code">mkdir src/server/services/</p>
			<p class="source-code">mkdir src/server/services/graphql</p>
			<p>Create an <strong class="source-inline">index.js</strong> file in the <strong class="source-inline">graphql</strong> folder to act as the start point for our GraphQL service. It must handle multiple things for initialization. Let's go through all of them one by one and add them to the <strong class="source-inline">index.js</strong> file:</p>
			<ol>
				<li value="1">First, we must import the <strong class="source-inline">apollo-server-express</strong> and <strong class="source-inline">@graphql-tools/schema</strong> packages:<p class="source-code">import { ApolloServer } from 'apollo-server-express';</p><p class="source-code">import { makeExecutableSchema } from '@graphql-tools/schema';</p></li>
				<li>Next, we must combine the GraphQL schema with the <strong class="source-inline">resolver</strong> functions. We must import the corresponding schema and resolver functions at the top from separate files. The GraphQL schema is the representation of the API – that is, the data and functions a client can request or run. Resolver functions are the implementation of the schema. Both need to match. You cannot return a field or run a mutation that is not inside the schema:<p class="source-code">import Resolvers from './resolvers';</p><p class="source-code">import Schema from './schema';</p></li>
				<li>The <strong class="source-inline">makeExecutableSchema</strong> function of the <strong class="source-inline">@graphql-tools/schema</strong> package merges the GraphQL schema and the resolver functions, resolving the data we are going to write. The <strong class="source-inline">makeExecutableSchema</strong> function throws an error when you define a query or mutation<a id="_idIndexMarker098"/> that is not in the schema. The resulting schema<a id="_idIndexMarker099"/> is executed by our GraphQL server resolving the data or running the mutations we request:<p class="source-code">const executableSchema = makeExecutableSchema({</p><p class="source-code">  typeDefs: Schema,</p><p class="source-code">  resolvers: Resolvers</p><p class="source-code">});</p></li>
				<li>We pass this as a <strong class="source-inline">schema</strong> parameter to the Apollo Server. The <strong class="source-inline">context</strong> property contains the <strong class="source-inline">request</strong> object of Express.js. In our resolver functions, we can access the request if we need to:<p class="source-code">const server = new ApolloServer({</p><p class="source-code">  schema: executableSchema,</p><p class="source-code">  context: ({ req }) =&gt; req</p><p class="source-code">});</p></li>
				<li>This <strong class="source-inline">index.js</strong> file exports the initialized server object, which handles all GraphQL requests:<p class="source-code">export default server;</p></li>
			</ol>
			<p>Now that we are exporting the Apollo Server, it needs to be imported somewhere else. I find it convenient to have one <strong class="source-inline">index.js</strong> file on the services layer so that we only rely on this file if a new service is added.</p>
			<p>Create an <strong class="source-inline">index.js</strong> file in the <strong class="source-inline">services</strong> folder and enter the following code:</p>
			<p class="source-code">import graphql from './graphql';</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  graphql,</p>
			<p class="source-code">};</p>
			<p>The preceding code requires our <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">graphql</strong> folder and re-exports all the services into one big object. We can define more services here if we need them.</p>
			<p>To make our GraphQL server publicly<a id="_idIndexMarker100"/> accessible to our clients, we are going<a id="_idIndexMarker101"/> to bind the Apollo Server to the <strong class="source-inline">/graphql</strong> path.</p>
			<p>Import the services <strong class="source-inline">index.js</strong> file into the <strong class="source-inline">server/index.js</strong> file, as follows:</p>
			<p class="source-code">import services from './services';</p>
			<p>The <strong class="source-inline">services</strong> object only holds the <strong class="source-inline">graphql</strong> index. Now, we must bind the GraphQL server to the Express.js web server with the following code:</p>
			<p class="source-code">const serviceNames = Object.keys(services);</p>
			<p class="source-code">for (let i = 0; i &lt; serviceNames.length; i += 1) {</p>
			<p class="source-code">  const name = serviceNames[i];</p>
			<p class="source-code">  if (name === 'graphql') {</p>
			<p class="source-code">    (async () =&gt; {</p>
			<p class="source-code">      await services[name].start();</p>
			<p class="source-code">      services[name].applyMiddleware({ app });</p>
			<p class="source-code">    })();</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    app.use('/${name}', services[name]);</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>For convenience, we loop through all indexes of the <strong class="source-inline">services</strong> object and use the index as the name of the route the service will be bound to. The path would be <strong class="source-inline">/example</strong> for the <strong class="source-inline">example</strong> index in the <strong class="source-inline">services</strong> object. For a typical service, such as a REST interface, we rely on the standard <strong class="source-inline">app.use</strong> method of Express.js.</p>
			<p>Since the Apollo Server is kind of special, when binding it to Express.js, we need to run the <strong class="source-inline">applyMiddleware</strong> function, which is provided by the initialized Apollo Server, and avoid using the <strong class="source-inline">app.use</strong> function from Express.js. Apollo automatically binds itself to the <strong class="source-inline">/graphql</strong> path because it is the default option. You could also include a <strong class="source-inline">path</strong> parameter if you want it to respond from a custom route.</p>
			<p>The Apollo Server<a id="_idIndexMarker102"/> requires us to run the <strong class="source-inline">start</strong> command before applying<a id="_idIndexMarker103"/> the middleware. As this is an asynchronous function, we are wrapping the complete block into a wrapping <strong class="source-inline">async</strong> function so that we can use the <strong class="source-inline">await</strong> statement.</p>
			<p>Two things are missing now: the schema and the resolvers. Once we've done that, we will execute some test GraphQL requests. The schema is next on our to-do list.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Writing your first GraphQL schemas</h2>
			<p>Let's start by creating a <strong class="source-inline">schema.js</strong> inside the <strong class="source-inline">graphql</strong> folder. You can also stitch multiple smaller schemas<a id="_idIndexMarker104"/> into one bigger schema. This would be cleaner and would make sense when your application, types, and fields grow. For this book, one file is okay and we can insert the following code into the <strong class="source-inline">schema.js</strong> file:</p>
			<p class="source-code">const typeDefinitions = '</p>
			<p class="source-code">  type Post {</p>
			<p class="source-code">    id: Int</p>
			<p class="source-code">    text: String</p>
			<p class="source-code">  }</p>
			<p class="source-code">  type RootQuery {</p>
			<p class="source-code">    posts: [Post]</p>
			<p class="source-code">  }</p>
			<p class="source-code">  schema {</p>
			<p class="source-code">    query: RootQuery</p>
			<p class="source-code">  }</p>
			<p class="source-code">';</p>
			<p class="source-code">export default [typeDefinitions];</p>
			<p>The preceding code represents a basic schema, which would be able to at least serve the fake posts array from <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>, excluding the users.</p>
			<p>First, we must define a new type called <strong class="source-inline">Post</strong>. A <strong class="source-inline">Post</strong> type has an <strong class="source-inline">id</strong> of <strong class="source-inline">Int</strong> and a <strong class="source-inline">text</strong> value of <strong class="source-inline">String</strong>.</p>
			<p>For our GraphQL server, we need a type called <strong class="source-inline">RootQuery</strong>. The <strong class="source-inline">RootQuery</strong> type wraps all of the queries <a id="_idIndexMarker105"/>a client can run. It can be anything from requesting all posts, all users, posts by just one user, and so on. You can compare this to all <strong class="source-inline">GET</strong> requests as you find them with common REST APIs. The paths would be <strong class="source-inline">/posts</strong>, <strong class="source-inline">/users</strong>, and <strong class="source-inline">/users/ID/posts</strong> to represent the GraphQL API as a REST API. When using GraphQL, we only have one route, and we send the query as a JSON-like object.</p>
			<p>The first query we will have is going to return an array of all of the posts we have got.</p>
			<p>If we query for all posts and want to return each user with its corresponding post, this would be a sub-query that would not be represented in our <strong class="source-inline">RootQuery</strong> type but in the <strong class="source-inline">Post</strong> type itself. You will see how this is done later.</p>
			<p>At the end of the JSON-like schema, we add <strong class="source-inline">RootQuery</strong> to the <strong class="source-inline">schema</strong> property. This type is the starting point for the Apollo Server.</p>
			<p>Later, we are going to add the mutation key to the schema, where we will implement a <strong class="source-inline">RootMutation</strong> type. It is going to serve all of the actions a user can run. Mutations are comparable to the <strong class="source-inline">POST</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">DELETE</strong> requests of a REST API.</p>
			<p>At the end of the file, we export<a id="_idIndexMarker106"/> the schema as an array. If we wanted to, we could push other schemas to this array to merge them.</p>
			<p>The last thing that's missing here is the implementation of our resolvers.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Implementing GraphQL resolvers</h2>
			<p>Now that the schema is ready, we need<a id="_idIndexMarker107"/> the matching resolver functions.</p>
			<p>Create a <strong class="source-inline">resolvers.js</strong> file in the <strong class="source-inline">graphql</strong> folder, as follows:</p>
			<p class="source-code">const resolvers = {</p>
			<p class="source-code">  RootQuery: {</p>
			<p class="source-code">    posts(root, args, context) {</p>
			<p class="source-code">      return []; </p>
			<p class="source-code">    }, </p>
			<p class="source-code">  }, </p>
			<p class="source-code">}; </p>
			<p class="source-code">export default resolvers;</p>
			<p>The <strong class="source-inline">resolvers</strong> object holds all types as a property. Here, we set up <strong class="source-inline">RootQuery</strong>, holding the <strong class="source-inline">posts</strong> query in the same way as we did in our schema. The <strong class="source-inline">resolvers</strong> object must equal the schema but be recursively merged. If you want to query a subfield, such as the user of a post, you have to extend the <strong class="source-inline">resolvers</strong> object with a <strong class="source-inline">Post</strong> object containing a <strong class="source-inline">user</strong> function next to <strong class="source-inline">RootQuery</strong>.</p>
			<p>If we send a query for all posts, the <strong class="source-inline">posts</strong> function is executed. There, you can do whatever you want, but you need to return something that matches the schema. So, if you have an array of <strong class="source-inline">posts</strong> as the response type of <strong class="source-inline">RootQuery</strong>, you cannot return something different, such as just one post object instead of an array. In that case, you would receive an error.</p>
			<p>Furthermore, GraphQL checks the data type of every property. If <strong class="source-inline">id</strong> is defined as <strong class="source-inline">Int</strong>, you cannot return a regular MongoDB <strong class="source-inline">id</strong> since these IDs are of the <strong class="source-inline">String</strong> type. GraphQL would throw an error too.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">GraphQL will parse or cast specific data types for you if the value type is matching. For example, a <strong class="source-inline">string</strong> with a value of <strong class="source-inline">2.1</strong> is parsed to <strong class="source-inline">Float</strong> without any problems. On the other hand, an empty string cannot be converted into a <strong class="source-inline">Float</strong>, and an error would be thrown. It is better to directly have the correct data types because this saves you from casting and also prevents unwanted problems.</p>
			<p>To prove that everything<a id="_idIndexMarker108"/> is working, we will continue by performing a real GraphQL request against our server. Our <strong class="source-inline">posts</strong> query will return an empty array, which is a correct response for GraphQL. We will come back to the <strong class="source-inline">resolver</strong> functions later. You should be able to start the server again so that we can send a demo request. </p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>Sending GraphQL queries</h2>
			<p>We can test this query<a id="_idIndexMarker109"/> using any HTTP client, such as Postman, Insomnia, or any you are used to. The next section covers HTTP clients. If you want to send the following queries on your own, then you can read the next section and come back here.</p>
			<p>You can test our new function when you send the following JSON as a <strong class="source-inline">POST</strong> request to <strong class="source-inline">http://localhost:8000/graphql</strong>:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "operationName": null,</p>
			<p class="source-code">  "query": "{ </p>
			<p class="source-code">    posts { </p>
			<p class="source-code">      id</p>
			<p class="source-code">      text </p>
			<p class="source-code">    }</p>
			<p class="source-code">  }", </p>
			<p class="source-code">  "variables": {} </p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">operationName</strong> field is not required to run a query, but it is great for logging purposes.</p>
			<p>The <strong class="source-inline">query</strong> object is a JSON-like representation of the query we want to execute. In this example, we run the <strong class="source-inline">RootQuery</strong> posts and request the <strong class="source-inline">id</strong> and <strong class="source-inline">text</strong> fields of every post. We do not need to specify <strong class="source-inline">RootQuery</strong> because it is the highest layer of our GraphQL API.</p>
			<p>The <strong class="source-inline">variables</strong> property can hold parameters such as the user IDs that we want to filter the posts by. If you want to use variables, they need to be defined in the query by their name too.</p>
			<p>For developers who are not used to tools such as Postman, there is also the option to open the <strong class="source-inline">/graphql</strong> endpoint in a separate browser tab. You will be presented with a GraphQLi instance that's made for sending queries easily. Here, you can insert the content of the <strong class="source-inline">query</strong> property<a id="_idIndexMarker110"/> and hit the play button. Because we set up Helmet to secure our application, we need to deactivate it in development. Otherwise, the GraphQLi instance is not going to work. Just wrap the complete Helmet initialization inside the <strong class="source-inline">server/index.js</strong> file with the following <strong class="source-inline">if</strong> statement in curly braces:</p>
			<p class="source-code">if(process.env.NODE_ENV === 'production')</p>
			<p>This short condition only activates Helmet when the environment is in development. Now, you can send the request with GraphQLi or any HTTP client.</p>
			<p>The response of the <strong class="source-inline">POST</strong> request, when combined with the preceding body, should look as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": { </p>
			<p class="source-code">    "posts": [] </p>
			<p class="source-code">  } </p>
			<p class="source-code">}</p>
			<p>Here, we received the empty posts array, as expected.</p>
			<p>Going further, we want to respond with the fake data we statically wrote in our client so that it comes from our backend. Copy the <strong class="source-inline">initialPosts</strong> array from <strong class="source-inline">App.js</strong> above the <strong class="source-inline">resolvers</strong> object but rename it <strong class="source-inline">posts</strong>. We can respond to the GraphQL request with this filled <strong class="source-inline">posts</strong> array.</p>
			<p>Replace the content of the <strong class="source-inline">posts</strong> function in the GraphQL resolvers with this:</p>
			<p class="source-code">return posts;</p>
			<p>You can rerun the <strong class="source-inline">POST</strong> request and receive both fake posts. The response does not include the user object<a id="_idIndexMarker111"/> we have in our fake data, so we must define a user property on the <strong class="source-inline">post</strong> type in our schema to fix this issue.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>Using multiple types in GraphQL schemas</h2>
			<p>Let's create a <strong class="source-inline">User</strong> type and use<a id="_idIndexMarker112"/> it with our posts. First, add it to the schema:</p>
			<p class="source-code">type User {</p>
			<p class="source-code">  avatar: String</p>
			<p class="source-code">  username: String</p>
			<p class="source-code">}</p>
			<p>Now that we have a <strong class="source-inline">User</strong> type, we need to use it inside the <strong class="source-inline">Post</strong> type. Add it to the <strong class="source-inline">Post</strong> type, as follows:</p>
			<p class="source-code">user: User</p>
			<p>The <strong class="source-inline">user</strong> field allows us to have a sub-object inside our posts, along with the post's author information.</p>
			<p>Our extended query to test this looks like this:</p>
			<p class="source-code">"query":"{</p>
			<p class="source-code">  posts {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    text</p>
			<p class="source-code">    user {</p>
			<p class="source-code">      avatar</p>
			<p class="source-code">      username</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}"</p>
			<p>You cannot just specify the user as a property of the query. Instead, you need to provide a sub-selection of fields. This is required whenever you have multiple GraphQL types nested inside each other. Then, you need to select the fields your result should contain.</p>
			<p>Running the updated query gives<a id="_idIndexMarker113"/> us the fake data, which we already have in our frontend code; just the <strong class="source-inline">posts</strong> array as-is.</p>
			<p>We have made good progress with querying data, but we also want to be able to add and change data.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Writing your first GraphQL mutation</h2>
			<p>One thing our client has already<a id="_idIndexMarker114"/> offered was adding new posts to the fake data temporarily. We can implement this in the backend by using GraphQL mutations.</p>
			<p>Starting with the schema, we need to add the mutation, as well as the input types, as follows:</p>
			<p class="source-code">input PostInput {</p>
			<p class="source-code">  text: String!</p>
			<p class="source-code">}</p>
			<p class="source-code">input UserInput {</p>
			<p class="source-code">  username: String!</p>
			<p class="source-code">  avatar: String!</p>
			<p class="source-code">}</p>
			<p class="source-code">type RootMutation {</p>
			<p class="source-code">  addPost (</p>
			<p class="source-code">    post: PostInput!</p>
			<p class="source-code">    user: UserInput!</p>
			<p class="source-code">  ): Post</p>
			<p class="source-code">}</p>
			<p>GraphQL inputs are no more than types. Mutations can use them as parameters inside requests. They may look weird because our current output types look almost the same. However, it would be wrong to have an <strong class="source-inline">id</strong> property on <strong class="source-inline">PostInput</strong>, for example, since the backend chooses the ID and the client cannot provide it. Consequently, it does make sense to have separate objects for input and output types.</p>
			<p>The <strong class="source-inline">addPost</strong> function receiving our two new required input types – <strong class="source-inline">PostInput</strong> and <strong class="source-inline">UserInput</strong> – is a new feature. Those<a id="_idIndexMarker115"/> functions are called mutations since they mutate the current state of the application. The response to this mutation is an ordinary <strong class="source-inline">Post</strong> object. When creating a new post with the <strong class="source-inline">addPost</strong> mutation, we will directly get the created post from the backend in response.</p>
			<p>The exclamation mark<a id="_idIndexMarker116"/> in the schema tells GraphQL that the field is a required parameter.</p>
			<p>The <strong class="source-inline">RootMutation</strong> type corresponds to the <strong class="source-inline">RootQuery</strong> type and is an object that holds all GraphQL mutations.</p>
			<p>The last step is to enable the mutations in our schema for the Apollo Server by applying the <strong class="source-inline">RootMutation</strong> type to the <strong class="source-inline">schema</strong> object:</p>
			<p class="source-code">schema {</p>
			<p class="source-code">  query: RootQuery</p>
			<p class="source-code">  mutation: RootMutation</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Usually, the client does not send the user with the mutation. This is because the user is authenticated first, before adding a post, and through that, we already know which user initiated the Apollo request. However, we will ignore this for the moment and implement authentication later in <a href="B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication with Apollo and React</em>.</p>
			<p>Now, the <strong class="source-inline">addPost</strong> resolver function<a id="_idIndexMarker117"/> needs to be implemented in the <strong class="source-inline">resolvers.js</strong> file.</p>
			<p>Add the following <strong class="source-inline">RootMutation</strong> object to <strong class="source-inline">RootQuery</strong> in <strong class="source-inline">resolvers.js</strong>:</p>
			<p class="source-code">RootMutation: {</p>
			<p class="source-code">  addPost(root, { post, user }, context) {</p>
			<p class="source-code">    const postObject = { </p>
			<p class="source-code">      ...post,</p>
			<p class="source-code">      user,</p>
			<p class="source-code">      id: posts.length + 1,</p>
			<p class="source-code">    };</p>
			<p class="source-code">    posts.push(postObject);</p>
			<p class="source-code">    return postObject;</p>
			<p class="source-code">  },</p>
			<p class="source-code">},</p>
			<p>This resolver extracts the <strong class="source-inline">post</strong> and <strong class="source-inline">user</strong> objects from the mutation's parameters, which are passed in the second argument of the function. Then, we build the <strong class="source-inline">postObject</strong> variable. We want to add our <strong class="source-inline">posts</strong> array as a property by destructuring the <strong class="source-inline">post</strong> input and adding the <strong class="source-inline">user</strong> object. The <strong class="source-inline">id</strong> field is just the length of the <strong class="source-inline">posts</strong> array plus one.</p>
			<p>Now, the <strong class="source-inline">postObject</strong> variable looks like a <strong class="source-inline">post</strong> from the <strong class="source-inline">posts</strong> array. Our implementation does the same as the frontend is already doing. The return value of our <strong class="source-inline">addPost</strong> function is <strong class="source-inline">postObject</strong>. To get this working, you need to change the initialization of the <strong class="source-inline">posts</strong> array from <strong class="source-inline">const</strong> to <strong class="source-inline">let</strong>. Otherwise, the array will be static and unchangeable.</p>
			<p>You can run this mutation<a id="_idIndexMarker118"/> via your preferred HTTP client, like so:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "operationName": null,</p>
			<p class="source-code">  "query": "mutation addPost($post : PostInput!, </p>
			<p class="source-code">    $user: UserInput!) {</p>
			<p class="source-code">    addPost(post : $post, user: $user) { </p>
			<p class="source-code">      id</p>
			<p class="source-code">      text</p>
			<p class="source-code">      user {</p>
			<p class="source-code">        username</p>
			<p class="source-code">        avatar</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }",</p>
			<p class="source-code">  "variables": {</p>
			<p class="source-code">    "post": { </p>
			<p class="source-code">      "text": "You just added a post."</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "user": {</p>
			<p class="source-code">      "avatar": "/uploads/avatar3.png",</p>
			<p class="source-code">      "username": "Fake User"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>First, we pass the word <strong class="source-inline">mutation</strong> and the actual function name – in this case, <strong class="source-inline">addPost</strong> – that we want to run, including a selection of response fields inside the <strong class="source-inline">query</strong> property, to the normal data query for the posts.</p>
			<p>Second, we use the <strong class="source-inline">variables</strong> property to send the data we want to insert into our backend. We need to pass them as parameters within the <strong class="source-inline">query</strong> string. We can define both parameters with a dollar sign and the awaited data type inside the <strong class="source-inline">operation</strong> string. The variables marked with dollar signs are then mapped into the actual action we want to trigger on the backend.</p>
			<p>When we send this mutation, the request will have a <strong class="source-inline">data</strong> object, including an <strong class="source-inline">addPost</strong> field. The <strong class="source-inline">addPost</strong> field holds the post, which we send with our request.</p>
			<p>If you query the posts<a id="_idIndexMarker119"/> again, you will see that there are now three posts. Great – it worked!</p>
			<p>As with our client, this is only temporary until we restart the server. We'll cover how to persist data in a SQL database in <a href="B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Connecting to the Database</em>.</p>
			<p>Next, we'll cover the various ways you can debug your backend.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Backend debugging and logging</h1>
			<p>Two things are very important for debugging. The first is that we need to implement logging<a id="_idIndexMarker120"/> for our backend in case we receive<a id="_idIndexMarker121"/> errors from our users, while the second is that we need to look into Postman to debug our GraphQL API efficiently.</p>
			<p>So, let's get started with logging.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/>Logging in Node.js</h2>
			<p>The most popular logging package for Node.js is called <strong class="source-inline">winston</strong>. Install and configure <strong class="source-inline">winston</strong> by following<a id="_idIndexMarker122"/> these steps:</p>
			<ol>
				<li value="1">Install <strong class="source-inline">winston</strong> with <strong class="source-inline">npm</strong>:<p class="source-code"><strong class="bold">npm install --save winston</strong></p></li>
				<li>Next, create a new folder for all of the helper functions from the backend:<p class="source-code"><strong class="bold">mkdir src/server/helpers</strong></p></li>
				<li>Then, insert a <strong class="source-inline">logger.js</strong> file into <a id="_idIndexMarker123"/>the new folder with the following content:<p class="source-code">import winston from 'winston';</p><p class="source-code">let transports = [</p><p class="source-code">  new winston.transports.File({</p><p class="source-code">    filename: 'error.log',</p><p class="source-code">    level: 'error',</p><p class="source-code">  }),</p><p class="source-code">  new winston.transports.File({</p><p class="source-code">    filename: 'combined.log',</p><p class="source-code">    level: 'verbose',</p><p class="source-code">  }),</p><p class="source-code">];</p><p class="source-code">if (process.env.NODE_ENV !== 'production') {</p><p class="source-code">  transports.push(new winston.transports.Console());</p><p class="source-code">}</p><p class="source-code">const logger = winston.createLogger({</p><p class="source-code">  level: 'info',</p><p class="source-code">  format: winston.format.json(),</p><p class="source-code">  transports,</p><p class="source-code">});</p><p class="source-code">export default logger;</p></li>
			</ol>
			<p>This file can be imported everywhere we want to log.</p>
			<p>In the preceding code, we defined the standard <strong class="source-inline">transports</strong> for <strong class="source-inline">winston</strong>. A transport is nothing<a id="_idIndexMarker124"/> more than how <strong class="source-inline">winston</strong> separates and saves various log types in different files.</p>
			<p>The first <strong class="source-inline">transport</strong> generates an <strong class="source-inline">error.log</strong> file where only real errors are saved.</p>
			<p>The second transport is a combined log where we save all the other log messages, such as warnings or information logs.</p>
			<p>If we are running the server in a development environment, which we are currently doing, we must add a third transport. We will also directly log all the messages to the console while developing on the server.</p>
			<p>Most people who are used to JavaScript development know the difficulty with <strong class="source-inline">console.log</strong>. By directly using <strong class="source-inline">winston</strong>, we can see all the messages in the Terminal, but we do not need to clean the code from <strong class="source-inline">console.log</strong> either, so long as the things we log make sense.</p>
			<p>To test this out, we can try the <strong class="source-inline">winston</strong> logger in the only mutation we have.</p>
			<p>In <strong class="source-inline">resolvers.js</strong>, add the following code to the top of the file:</p>
			<p class="source-code">import logger from '../../helpers/logger';</p>
			<p>Now, we can extend the <strong class="source-inline">addPost</strong> function by adding the following before the <strong class="source-inline">return</strong> statement:</p>
			<p class="source-code">logger.log({ level: 'info', message: 'Post was created' });</p>
			<p>When you send the mutation now, you will see that the message was logged to the console.</p>
			<p>Furthermore, if you look in the root folder of your project, you will see the <strong class="source-inline">error.log</strong> and <strong class="source-inline">combined.log</strong> files. The <strong class="source-inline">combined.log</strong> file should contain the log from the console.</p>
			<p>Now that we can log all the operations on the server, we should explore Postman so that we can send requests comfortably.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Debugging with Postman</h2>
			<p><strong class="bold">Postman</strong> is one of the most widely used HTTP clients<a id="_idIndexMarker125"/> there is. It not only provides raw HTTP client functionality but also teams and collections, along with letting you synchronize all the requests you saved in Postman.</p>
			<p>You can install Postman by<a id="_idIndexMarker126"/> downloading the appropriate file from <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Numerous other HTTP client<a id="_idIndexMarker127"/> tools are useful for debugging your application. You are free to use your tool of choice. Some other great clients that I use are Insomnia, SoapUI, and Stoplight, but there are many more. In this book, we will use Postman, as it is the most popular from my point of view.</p>
			<p>When you have finished the installation, it should look something like this:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.1_B17337.jpg" alt="Figure 2.1 – Postman screen after installing the Book collection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Postman screen after installing the Book collection</p>
			<p>As you can see, I have already created a collection called <strong class="bold">Book</strong> in the left-hand panel. This collection includes<a id="_idIndexMarker128"/> our two requests: one to request all posts and one to add a new post.</p>
			<p>As an example, the following screenshot shows you what the <strong class="bold">Add Post</strong> mutation looks like in Postman:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_2.2_B17337.jpg" alt="Figure 2.2 – The Add Post mutation in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Add Post mutation in Postman</p>
			<p>The URL is <strong class="source-inline">localhost</strong> and includes port <strong class="source-inline">8000</strong>, as expected.</p>
			<p>The request body looks pretty much like what we saw previously. Be sure to select <strong class="source-inline">application/json</strong> as <strong class="source-inline">Content-Type</strong> next to the <strong class="source-inline">raw</strong> format.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In my case, I need to write the query inline because Postman is not able to handle multi-row text inside JSON. If this is not the case for you, please ignore it.</p>
			<p>Since the newer version of Postman was released, there is also the option to select GraphQL instead of JSON. If you do that, you can write the GraphQL code in multiple lines and write the variables in a separate window. The result should look like this:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.3_B17337.jpg" alt="Figure 2.3 – Postman with GraphQL selected&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Postman with GraphQL selected</p>
			<p>If you add a new request, you can use the <em class="italic">Ctrl</em> + <em class="italic">S</em> shortcut to save it. You need to select a collection and a name to save it with. One major downfall of using Postman (at least with GraphQL APIs) is that we are only using <strong class="source-inline">POST</strong>. It would be great to have some kind of indication of what<a id="_idIndexMarker129"/> we are doing here – for example, a query or a mutation. We will learn how to use authorization in Postman once we have implemented it.</p>
			<p>Postman also has other great features, such as automated testing, monitoring, and mocking a fake server.</p>
			<p>Later in this book, it will become more complicated to configure Postman for all requests. In such cases, I like to use the Apollo Client Developer Tools, which perfectly integrate into the frontend and make use of Chrome DevTools. What's great about the Apollo Client <a id="_idIndexMarker130"/>Developer Tools is that they use the Apollo Client we configure in the frontend code, which means they reuse the authentication we built into our frontend.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor053"/>Summary</h1>
			<p>In this chapter, we set up our Node.js server with Express.js and bound the Apollo Server to respond to requests on a GraphQL endpoint. We can handle queries, return fake data, and mutate that data with GraphQL mutations.</p>
			<p>Furthermore, we can log every process in our Node.js server. Debugging an application with Postman leads to a well-tested API, which can be used later in our frontend.</p>
			<p>In the next chapter, we will learn how to persist data in a SQL server. We will also implement models for our GraphQL types and cover migrations for our database. We need to replace our current <strong class="source-inline">resolver</strong> functions with queries via Sequelize.</p>
			<p>There is a lot to do, so read on for more!</p>
		</div>
	</body></html>