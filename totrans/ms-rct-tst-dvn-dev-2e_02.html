<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-40"><a id="_idTextAnchor038"/>2 </h1>
<h1 id="_idParaDest-41"><a id="_idTextAnchor039"/>Rendering Lists and Detail Views</h1>
<p>The previous chapter introduced the core TDD cycle: red, green, refactor. You had the chance to try it out with two simple tests. Now, it’s time to apply that to a bigger React component.</p>
<p>At the moment, your application displays just a single item of data: the customer’s name. In this chapter, you’ll extend it so that you have a view of all appointments for the current day. You’ll be able to choose a time slot and see the details for the appointment at that time. We will start this chapter by sketching a mock-up to help us plan how we’ll build out the component. Then, we’ll begin implementing a list view and showing appointment details.</p>
<p>Once we’ve got the component in good shape, we’ll build the entry point with webpack and then run the application in order to do some manual testing. </p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Sketching a mock-up</li>
<li>Creating the new component</li>
<li>Specifying list item content</li>
<li>Selecting data to view</li>
<li>Manually testing our changes</li>
</ul>
<p>By the end of this chapter, you’ll have written a decent-sized React component using the TDD process you’ve already learned. You’ll also have seen the app running for the first time.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor040"/>Technical requirements</h1>
<p>The code files for this chapter can be found at <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter02">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter02</a>.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor041"/>Sketching a mock-up</h1>
<p>Let’s start with a little <a id="_idIndexMarker157"/>more up-front design. We’ve got an <strong class="source-inline">Appointment</strong> component that takes an appointment and displays it. We will build an <strong class="source-inline">AppointmentsDayView</strong> component around it that takes an array of <strong class="source-inline">appointment</strong> objects and displays them as a list. It will also display a single <strong class="source-inline">Appointment</strong>: the appointment that is currently selected. To select an appointment, the user simply clicks on the time of day that they’re interested in.</p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<img alt="Figure 2.1 – A mock-up of our appointment system UI " height="595" src="image/Figure_2.01_B18423.jpg" width="1091"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – A mock-up of our appointment system UI</p>
<p class="callout-heading">Up-front design</p>
<p class="callout">When you’re using TDD to build new features, it’s important to do a little up-front design so that you have a <a id="_idIndexMarker158"/>general idea of the direction your implementation needs to take.</p>
<p>That’s all the design we need for now; let’s jump right in and build the new <strong class="source-inline">AppointmentsDayView </strong>component.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor042"/>Creating the new component</h1>
<p>In this section, we’ll create<a id="_idIndexMarker159"/> the basic form of <strong class="source-inline">AppointmentsDayView</strong>: a list of appointment times for the day. We won’t build any interactive behavior for it just yet.  </p>
<p>We’ll add our new component into the same file we’ve been using already because so far there’s not much code in there. Perform the following steps:</p>
<p class="callout-heading">Placing components</p>
<p class="callout">We don’t always need a <a id="_idIndexMarker160"/>new file for each component, particularly when the components are short functional components, such as our <strong class="source-inline">Appointment</strong> component (a one-line function). It can help to group related components or small sub-trees of components in one place.</p>
<ol>
<li>In <strong class="source-inline">test/Appointment.test.js</strong>, create a new <strong class="source-inline">describe</strong> block under the first one, with a single test. This test <a id="_idIndexMarker161"/>checks that we render a <strong class="source-inline">div</strong> with a particular ID. That’s important in this case because we load a CSS file that looks for this element. The expectations in this test <a id="_idIndexMarker162"/>use the DOM method, <strong class="source-inline">querySelector</strong>. This searches the DOM tree for a single element with the tag provided:<p class="source-code">describe("AppointmentsDayView", () =&gt; {</p><p class="source-code">  let container;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    container = document.createElement("div");</p><p class="source-code">    document.body.replaceChildren(container);</p><p class="source-code">  });</p><p class="source-code">  const render = (component) =&gt;</p><p class="source-code">    act(() =&gt;      </p><p class="source-code">      ReactDOM.createRoot(container).render(component)</p><p class="source-code">    );</p><p class="source-code">  it("renders a div with the right id", () =&gt; {</p><p class="source-code">    render(&lt;AppointmentsDayView appointments={[]} /&gt;);</p><p class="source-code">    expect(</p><p class="source-code">      document.querySelector(</p><p class="source-code">        "div#appointmentsDayView"</p><p class="source-code">      )</p><p class="source-code">    ).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">It isn’t usually<a id="_idIndexMarker163"/> necessary to wrap <a id="_idIndexMarker164"/>your component in a <strong class="source-inline">div</strong> with an ID or a class. We tend to do it when we have CSS that we want to attach to the entire group of HTML elements that will be rendered by the component, which, as you’ll see later, is the case for <strong class="source-inline">AppointmentsDayView</strong>.</p>
<p>This test uses the <a id="_idIndexMarker165"/>exact same <strong class="source-inline">render</strong> function from the first <strong class="source-inline">describe</strong> block as well as the same <strong class="source-inline">let container</strong> declaration and <strong class="source-inline">beforeEach</strong> block. In other words, we’ve introduced duplicated code. By duplicating code from our first test suite, we’re making a mess straight after cleaning up our code! Well, we’re allowed to do it when we’re in the first stage of the TDD cycle. Once we’ve got the test passing, we can think about the right structure for the code.</p>
<ol>
<li value="2">Run <strong class="source-inline">npm test</strong> and look at the output:<p class="source-code"><strong class="bold">FAIL test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (18ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders another customer first name (2ms)</strong></p><p class="source-code"><strong class="bold">  AppointmentsDayView</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✕</strong><strong class="bold"> renders a div with the right id (7ms)</strong></p><p class="source-code"><strong class="bold">  </strong><strong class="bold">●</strong><strong class="bold"> AppointmentsDayView › renders a div with the right id</strong></p><p class="source-code"><strong class="bold">    ReferenceError: AppointmentsDayView is not defined</strong></p></li>
</ol>
<p>Let’s work on getting<a id="_idIndexMarker166"/> this test to pass by performing the following steps: </p>
<ol>
<li value="1">To fix this, change the last <strong class="source-inline">import</strong> statement in your test file to read as follows:<p class="source-code">import {</p><p class="source-code">  Appointment<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  AppointmentsDayView,</strong></p><p class="source-code">} from "../src/Appointment";</p></li>
<li>In <strong class="source-inline">src/Appointment.js</strong>, add this functional component below <strong class="source-inline">Appointment</strong> as shown:<p class="source-code">export const AppointmentsDayView = () =&gt; {};</p></li>
<li>Run your tests again. You'll see output like this:<p class="source-code"><strong class="bold">●</strong><strong class="bold"> AppointmentsDayView › renders a div with the right id</strong></p><p class="source-code"><strong class="bold">expect(received).not.toBeNull()</strong></p></li>
<li>Finally, a test failure! Let’s<a id="_idIndexMarker167"/> get that <strong class="source-inline">div</strong> in place as follows:<p class="source-code">export const AppointmentsDayView = () =&gt; <strong class="bold">(</strong></p><p class="source-code"><strong class="bold">  &lt;div id="appointmentsDayView"&gt;&lt;/div&gt;</strong></p><p class="source-code"><strong class="bold">);</strong></p></li>
<li>Your test should<a id="_idIndexMarker168"/> now be passing. Let’s move on to the next test. Add the following text, just below the last test in <strong class="source-inline">test/Appointment.test.js</strong>, still inside the <strong class="source-inline">AppointmentsDayView</strong> <strong class="source-inline">describe</strong> block:<p class="source-code">it("renders an ol element to display appointments", () =&gt; {</p><p class="source-code">  render(&lt;AppointmentsDayView appointments={[]} /&gt;);</p><p class="source-code">  const listElement = document.querySelector("ol");</p><p class="source-code">  expect(listElement).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Run your tests again and you'll see output matching the text shown below:<p class="source-code"><strong class="bold">●</strong><strong class="bold"> AppointmentsDayView › renders an ol element to display appointments</strong></p><p class="source-code"><strong class="bold">expect(received).not.toBeNull()</strong></p><p class="source-code"><strong class="bold">Received: null</strong></p></li>
<li>To make that pass, add the <strong class="source-inline">ol</strong> element as follows:<p class="source-code">export const AppointmentsDayView = () =&gt; (</p><p class="source-code">  &lt;div id="appointmentsDayView"&gt; </p><p class="source-code"><strong class="bold">    &lt;ol /&gt;</strong></p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p></li>
<li>Alright, now let’s<a id="_idIndexMarker169"/> fill that <strong class="source-inline">ol</strong> with an item for each appointment. For that, we’ll need (at least) two <a id="_idIndexMarker170"/>appointments to be passed<a id="_idIndexMarker171"/> as the value of the <strong class="source-inline">appointments</strong> prop, as<a id="_idIndexMarker172"/>. Add the next test, as shown:<p class="source-code">it("renders an li for each appointment", () =&gt; {</p><p class="source-code">  const today = new Date();</p><p class="source-code">  const twoAppointments = [</p><p class="source-code">    { startsAt: today.setHours(12, 0) },</p><p class="source-code">    { startsAt: today.setHours(13, 0) },</p><p class="source-code">  ];</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentsDayView </p><p class="source-code">      appointments={twoAppointments}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const listChildren =</p><p class="source-code">    document.querySelectorAll("ol &gt; li");</p><p class="source-code">  expect(listChildren).toHaveLength(2);</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Testing dates and times</p>
<p class="callout">In the test, the <strong class="source-inline">today</strong> constant is defined to be <strong class="source-inline">new Date()</strong>. Each of the two records then uses this as a base date. Whenever we’re dealing with dates, it’s important that we base all events on the same moment in time, rather than asking the system for the current time more than once. Doing that is a subtle bug waiting to happen.</p>
<ol>
<li value="9">Run <strong class="source-inline">npm test</strong> again<a id="_idIndexMarker173"/> and you'll see this output:<p class="source-code"><strong class="bold">●</strong><strong class="bold"> AppointmentsDayView › renders an li for each appointment</strong></p><p class="source-code"><strong class="bold">expect(received).toHaveLength(expected)</strong></p><p class="source-code"><strong class="bold">Expected length: 2</strong></p><p class="source-code"><strong class="bold">Received length: 0</strong></p><p class="source-code"><strong class="bold">Received object: []</strong></p></li>
<li>To fix <a id="_idIndexMarker174"/>this, we map<a id="_idIndexMarker175"/> over the provided <strong class="source-inline">appointments</strong> prop and render an empty <strong class="source-inline">li</strong> element:<p class="source-code">export const AppointmentsDayView = (</p><p class="source-code">  <strong class="bold">{ appointments }</strong></p><p class="source-code">) =&gt; (</p><p class="source-code">  &lt;div id="appointmentsDayView"&gt; </p><p class="source-code">    &lt;ol&gt;</p><p class="source-code"><strong class="bold">      {appointments.map(() =&gt; (</strong></p><p class="source-code"><strong class="bold">        &lt;li /&gt;</strong></p><p class="source-code"><strong class="bold">      ))}</strong></p><p class="source-code">    &lt;/ol&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Ignoring unused function arguments</p>
<p class="callout">The <strong class="source-inline">map</strong> function will provide an <strong class="source-inline">appointment</strong> argument to the function passed to it. Since we don’t use the <a id="_idIndexMarker176"/>argument (yet), we don’t need to mention it in the function signature—we can just pretend that our function has no arguments instead, hence the empty brackets. Don’t worry, we’ll need the argument for a subsequent test, and we’ll add it in then.</p>
<ol>
<li value="11">Great, let’s see<a id="_idIndexMarker177"/> what Jest thinks. Run <strong class="source-inline">npm test</strong> again:<p class="source-code"><strong class="bold">  console.error</strong></p><p class="source-code"><strong class="bold">    Warning: Each child in a list should have a unique "key" prop.</strong></p><p class="source-code"><strong class="bold">    Check the render method of AppointmentsDayView.</strong></p><p class="source-code"><strong class="bold">    ...</strong></p><p class="source-code"><strong class="bold">PASS test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (19ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders another customer first name (2ms)</strong></p><p class="source-code"><strong class="bold">  AppointmentsDayView</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders a div with the right id (7ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders an ol element to display appointments (16ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders an li for each appointment (16ms)</strong></p></li>
<li>Our test passed, but we got a warning from React. It’s telling us to set a key value on each child element. We can use <strong class="source-inline">startsAt</strong> as a key, like this:<p class="source-code">&lt;ol&gt;</p><p class="source-code">  {appointments.map(<strong class="bold">appointment</strong> =&gt; (</p><p class="source-code">    &lt;li<strong class="bold"> key={appointment.startsAt}</strong> /&gt;</p><p class="source-code">  ))}</p><p class="source-code">&lt;/ol&gt;</p></li>
</ol>
<p class="callout-heading">Testing keys</p>
<p class="callout">There’s no easy way for us to test key values in React. To do it, we’d need to rely on internal React properties, which <a id="_idIndexMarker178"/>would introduce a risk of tests breaking if the React team were to ever change those properties.</p>
<p class="callout">The best we can do is set a key to get rid of this warning message. In an ideal world, we’d have a test that uses the <strong class="source-inline">startsAt</strong> timestamp for each <strong class="source-inline">li</strong> key. Let’s just imagine that we have that test in place.</p>
<p>This section has covered <a id="_idIndexMarker179"/>how to render the basic structure of a list and its list items. Next, it’s time to fill in those items.</p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor043"/>Specifying list item content</h1>
<p>In this section, you’ll add a test that <a id="_idIndexMarker180"/>uses an array of example appointments to specify that the list items should show the time of each appointment, and then you’ll use that test to support the implementation.</p>
<p>Let’s start with <a id="_idIndexMarker181"/>the <a id="_idIndexMarker182"/>test:</p>
<ol>
<li value="1">Create a<a id="_idIndexMarker183"/> fourth test in the new <strong class="source-inline">describe</strong> block as shown:<p class="source-code">it("renders the time of each appointment", () =&gt; {</p><p class="source-code">  const today = new Date();</p><p class="source-code">  const twoAppointments = [</p><p class="source-code">    { startsAt: today.setHours(12, 0) },</p><p class="source-code">    { startsAt: today.setHours(13, 0) },</p><p class="source-code">  ];</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentsDayView </p><p class="source-code">      appointments={twoAppointments}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const listChildren = </p><p class="source-code">    document.querySelectorAll("li");</p><p class="source-code">  expect(listChildren[0].textContent).toEqual(</p><p class="source-code">    "12:00"</p><p class="source-code">  );</p><p class="source-code">  expect(listChildren[1].textContent).toEqual(</p><p class="source-code">    "13:00"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p>Jest will <a id="_idIndexMarker184"/>show the<a id="_idIndexMarker185"/> following <a id="_idIndexMarker186"/>error:</p>
<p class="source-code"><strong class="bold">●</strong><strong class="bold"> AppointmentsDayView › renders the time of each appointment</strong></p>
<p class="source-code"><strong class="bold">expect(received).toEqual(expected) // deep equality</strong></p>
<p class="source-code"><strong class="bold">Expected: "12:00"</strong></p>
<p class="source-code"><strong class="bold">Received: ""</strong></p>
<p class="callout-heading">The toEqual matcher</p>
<p class="callout">This matcher is a <a id="_idIndexMarker187"/>stricter version of <strong class="source-inline">toContain</strong>. The expectation only passes if the text content is an exact match. In this case, we <a id="_idIndexMarker188"/>think it makes sense to use <strong class="source-inline">toEqual</strong>. However, it’s often best to be as loose as possible with your expectations. Tight expectations have a habit of breaking any time you make the slightest change to your code base.</p>
<ol>
<li value="2">Add the <a id="_idIndexMarker189"/>following function to <strong class="source-inline">src/Appointment.js</strong>, which converts a Unix timestamp (which we get from the return value from <strong class="source-inline">setHours</strong>) into a time of day. It doesn’t matter where in the file you put it; we usually like to define constants before we use them, so this would go at <a id="_idIndexMarker190"/>the top of the file:<p class="source-code">const appointmentTimeOfDay = (startsAt) =&gt; {</p><p class="source-code">  const [h, m] = new Date(startsAt)</p><p class="source-code">    .toTimeString()</p><p class="source-code">    .split(":");</p><p class="source-code">  return `${h}:${m}`;</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Understanding syntax</p>
<p class="callout">This function uses <em class="italic">destructuring assignment</em> and <em class="italic">template literals</em>, which are language features that you can use to keep your functions concise.</p>
<p class="callout">Having good unit tests can help teach advanced language syntax. If we’re ever unsure about what a function does, we can look up the tests that will help us figure it out.</p>
<ol>
<li value="3">Use the preceding<a id="_idIndexMarker191"/> function to update <strong class="source-inline">AppointmentsDayView</strong> as follows:<p class="source-code">&lt;ol&gt;</p><p class="source-code">  {appointments.map(appointment =&gt; (</p><p class="source-code">    &lt;li key={appointment.startsAt}<strong class="bold">&gt;</strong></p><p class="source-code"><strong class="bold">      {appointmentTimeOfDay(appointment.startsAt)}</strong></p><p class="source-code">    <strong class="bold">&lt;/li&gt;</strong></p><p class="source-code">  ))}</p><p class="source-code">&lt;/ol&gt;</p></li>
<li>Running tests <a id="_idIndexMarker192"/>should show everything as green:<p class="source-code"><strong class="bold">PASS test/Appointment.test.js</strong></p><p class="source-code"><strong class="bold">  Appointment</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the customer first name (19ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders another customer first name (2ms)</strong></p><p class="source-code"><strong class="bold">  AppointmentsDayView</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders a div with the right id (7ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders an ol element to display appointments (16ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders an li for each appointment (6ms)</strong></p><p class="source-code"><strong class="bold">    </strong><strong class="bold">✓</strong><strong class="bold"> renders the time of each appointment (3ms)</strong></p></li>
</ol>
<p>This is a great chance to refactor. The last two <strong class="source-inline">AppointmentsDayView</strong> tests use the same <strong class="source-inline">twoAppointments</strong> prop value. This definition, and the <strong class="source-inline">today</strong> constant, can be lifted out into the <strong class="source-inline">describe</strong> scope, the same way we did with <strong class="source-inline">customer</strong> in the <strong class="source-inline">Appointment</strong> tests. This time, however, it can remain as <strong class="source-inline">const</strong> declarations as they never change.</p>
<ol>
<li value="5">To do that, move the <strong class="source-inline">today</strong> and <strong class="source-inline">twoAppointments</strong> definitions from one of the tests to the top of the <strong class="source-inline">describe</strong> block, above <strong class="source-inline">beforeEach</strong>. Then, delete the definitions from both tests.</li>
</ol>
<p>That’s it for this <a id="_idIndexMarker193"/>test. Next, it’s time to focus on adding click behavior.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor044"/>Selecting data to view</h1>
<p>Let’s add in some dynamic behavior<a id="_idIndexMarker194"/> to our page. We’ll make each of the list items a link that the user can click on to view that appointment.</p>
<p>Thinking through our design a little, there<a id="_idIndexMarker195"/> are a few pieces we’ll <a id="_idIndexMarker196"/>need:</p>
<ul>
<li>A <strong class="source-inline">button</strong> element within our <strong class="source-inline">li</strong></li>
<li>An <strong class="source-inline">onClick</strong> handler that is attached to that <strong class="source-inline">button</strong> element</li>
<li>Component state to record which appointment is currently being viewed</li>
</ul>
<p>When we test React actions, we do it by observing the consequences of those actions. In this case, we can click on a button and then check that its corresponding appointment is now rendered on the screen.</p>
<p>We’ll break this section into two parts: first, we’ll specify how the component should initially appear, and second, we’ll handle a click event for changing the content.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor045"/>Initial selection of data</h2>
<p>Let’s start by asserting that <a id="_idIndexMarker197"/>each <strong class="source-inline">li</strong> element has a <strong class="source-inline">button</strong> element:</p>
<ol>
<li value="1">We want to display a message to the user if there are no appointments scheduled for today. In the <strong class="source-inline">AppointmentsDayView</strong> <strong class="source-inline">describe</strong> block, add the following test:<p class="source-code">it("initially shows a message saying there are no appointments today", () =&gt; {</p><p class="source-code">  render(&lt;AppointmentsDayView appointments={[]} /&gt;);</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "There are no appointments scheduled for today."</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Make the test pass by adding in a message at the bottom of the rendered output. We don’t need a <a id="_idIndexMarker198"/>check for an empty <strong class="source-inline">appointments</strong> array just yet; we’ll need another test to triangulate to that. The message is as follows:<p class="source-code">return (</p><p class="source-code">  &lt;div id="appointmentsDayView"&gt;</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">&lt;p&gt;There are no appointments scheduled for today.&lt;/p&gt;</strong></p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p></li>
<li>When the component first loads, we should show the first appointment of the day. A straightforward way to check that happens is to look for the customer's first name is shown on the page. Add the next test which does just that, shown below:<p class="source-code">it("selects the first appointment by default", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentsDayView </p><p class="source-code">      appointments={twoAppointments}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Ashley"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Since we’re <a id="_idIndexMarker199"/>looking for the customer’s name, we’ll need to make sure that’s available in the <strong class="source-inline">twoAppointments</strong> array. Update it now to include the customer’s first name as follows:<p class="source-code">const twoAppointments = [</p><p class="source-code">  {</p><p class="source-code">    startsAt: today.setHours(12, 0)<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">    customer: { firstName: "Ashley" },</strong></p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    startsAt: today.setHours(13, 0)<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">    customer: { firstName: "Jordan" },</strong></p><p class="source-code">  },</p><p class="source-code">];</p></li>
<li>Make the test pass by modifying the <strong class="source-inline">Appointment</strong> component. Change the last line of the <strong class="source-inline">div</strong> component to read as follows:<p class="source-code">&lt;div id="appointmentsDayView"&gt;</p><p class="source-code">  ...</p><p class="source-code">  <strong class="bold">{appointments.length === 0 ? (</strong></p><p class="source-code">    &lt;p&gt;There are no appointments scheduled for today.&lt;/p&gt;</p><p class="source-code">  <strong class="bold">) : (</strong></p><p class="source-code"><strong class="bold">    &lt;Appointment {...appointments[0]} /&gt;</strong></p><p class="source-code"><strong class="bold">  )}</strong></p><p class="source-code">&lt;/div&gt;</p></li>
</ol>
<p>Now we’re ready to let the user make a selection.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor046"/>Adding events to a functional component</h2>
<p>We’re about to add <em class="italic">state</em> to our<a id="_idIndexMarker200"/> component. The component will show<a id="_idIndexMarker201"/> a button for each appointment. When the button is clicked, the component stores the array index of the appointment that it refers to. To do that, we’ll use the <strong class="source-inline">useState</strong> hook.</p>
<p class="callout-heading">What are hooks?</p>
<p class="callout"><strong class="bold">Hooks</strong> are a feature of React that <a id="_idIndexMarker202"/>manages various non-rendering related operations. The <strong class="source-inline">useState</strong> hook stores <a id="_idIndexMarker203"/>data across multiple renders<a id="_idIndexMarker204"/> of your function. The call to <strong class="source-inline">useState</strong> returns both the current value in storage and a setter function that allows it to be set.</p>
<p class="callout">If you’re new to hooks, check out the <em class="italic">Further reading</em> section at the end of this chapter. Alternatively, you could just follow along and see how much you can pick up just by reading the tests!</p>
<p>We’ll start by asserting that <a id="_idIndexMarker205"/>each <strong class="source-inline">li</strong> element has a <strong class="source-inline">button</strong> element:</p>
<ol>
<li value="1">Add the following test below the last one you added. The second expectation is peculiar in that it is checking the <strong class="source-inline">type</strong> attribute of the button element to be <strong class="source-inline">button</strong>. If you haven’t seen this before, it’s idiomatic <a id="_idIndexMarker206"/>when using <strong class="source-inline">button</strong> elements to define its<a id="_idIndexMarker207"/> role by setting the <strong class="source-inline">type</strong> attribute as<a id="_idIndexMarker208"/> shown in this test:<p class="source-code">it("has a button element in each li", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentsDayView </p><p class="source-code">      appointments={twoAppointments}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const buttons =</p><p class="source-code">   document.querySelectorAll("li &gt; button");</p><p class="source-code">  expect(buttons).toHaveLength(2);</p><p class="source-code">  expect(buttons[0].type).toEqual("button");</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Testing element positioning</p>
<p class="callout">We don’t need<a id="_idIndexMarker209"/> to be pedantic<a id="_idIndexMarker210"/> about checking the content or placement <a id="_idIndexMarker211"/>of the <strong class="source-inline">button</strong> element within its<a id="_idIndexMarker212"/> parent. For example, this test would pass if we put an empty <strong class="source-inline">button</strong> child at the end of <strong class="source-inline">li</strong>. But, thankfully, doing the right thing is just as simple as doing the wrong thing, so we can opt to do the right thing instead. All we need to do to make this test pass is wrap the existing content in the new tag.</p>
<ol>
<li value="2">Make the test pass by <a id="_idIndexMarker213"/>wrapping the appointment time with a <strong class="source-inline">button</strong> element in the <strong class="source-inline">AppointmentsDayView</strong> component, as follows:<p class="source-code">...</p><p class="source-code">&lt;li key={appointment.startsAt}&gt;</p><p class="source-code">  <strong class="bold">&lt;button type="button"&gt;</strong></p><p class="source-code">    {appointmentTimeOfDay(appointment.startsAt)}</p><p class="source-code">  <strong class="bold">&lt;/button&gt;</strong></p><p class="source-code">&lt;/li&gt;</p><p class="source-code">...</p></li>
<li>We can now test what<a id="_idIndexMarker214"/> happens when the button is clicked. Back in <strong class="source-inline">test/Appointment.test.js</strong>, add the following as the next test. This uses the <strong class="source-inline">click</strong> function<a id="_idIndexMarker215"/> on the DOM <a id="_idIndexMarker216"/>element to raise a DOM click event:<p class="source-code">it("renders another appointment when selected", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentsDayView </p><p class="source-code">      appointments={twoAppointments}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const button = </p><p class="source-code">    document.querySelectorAll("button")[1];</p><p class="source-code">  act(() =&gt; button.click());</p><p class="source-code">  expect(document.body.textContent).toContain(</p><p class="source-code">    "Jordan"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Synthetic events and Simulate</p>
<p class="callout">An <a id="_idIndexMarker217"/>alternative to using the <strong class="source-inline">click</strong> function is to use the <strong class="source-inline">Simulate</strong> namespace from React’s test utilities to raise a <strong class="bold">synthetic</strong> event. While<a id="_idIndexMarker218"/> the interface for using <strong class="source-inline">Simulate</strong> is somewhat simpler than the DOM <a id="_idIndexMarker219"/>API for raising events, it’s also unnecessary for testing. There’s no need to use extra APIs when the DOM API will suffice. Perhaps more importantly, we also want our tests to reflect the real browser environment as much as possible.</p>
<ol>
<li value="4">Go <a id="_idIndexMarker220"/>ahead and run <a id="_idIndexMarker221"/>the test. The output will look like this:<p class="source-code"><strong class="bold">  </strong><strong class="bold">●</strong><strong class="bold"> AppointmentsDayView › renders appointment when selected</strong></p><p class="source-code"><strong class="bold">    expect(received).toContain(expected)</strong></p><p class="source-code"><strong class="bold">    </strong></p><p class="source-code"><strong class="bold">    Expected substring: "Jordan"</strong></p><p class="source-code"><strong class="bold">    Received string:    "12:0013:00Ashley"</strong></p></li>
</ol>
<p>Notice the full text in the received string. We’re getting the text content of the list too because we’ve used <strong class="source-inline">document.body.textContent</strong> in our expectation rather than something more <a id="_idIndexMarker222"/>specific.</p>
<p class="callout-heading">Specificity of expectations</p>
<p class="callout">Don’t be too bothered about <em class="italic">where</em> the customer’s name appears on the screen. Testing <strong class="source-inline">document.body.textContent</strong> is like saying <em class="italic">“I want this text to appear somewhere, but I don’t care where.”</em> Often, this is enough for a test. Later on, we’ll see techniques for expecting text in specific places.</p>
<p>There’s a lot we now need to get in place in order to make the test pass. We need to introduce state and <a id="_idIndexMarker223"/>we need to <a id="_idIndexMarker224"/>add the handler. Perform the following steps:</p>
<ol>
<li value="1">Update the import at the top of the file to pull in the <strong class="source-inline">useState</strong> function as follows:<p class="source-code">import React<strong class="bold">, { useState }</strong> from "react";</p></li>
<li>Wrap the constant definition in curly braces, and then return the existing value as follows:<p class="source-code">export const AppointmentsDayView = (</p><p class="source-code">  { appointments }</p><p class="source-code">) =&gt;<strong class="bold"> {</strong></p><p class="source-code">  <strong class="bold">return (</strong></p><p class="source-code">    &lt;div id="appointmentsDayView"&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>Add the following line of code above the <strong class="source-inline">return</strong> statement:<p class="source-code">const [selectedAppointment, setSelectedAppointment] =</p><p class="source-code">  useState(0);</p></li>
<li>We can now use <strong class="source-inline">selectedAppointment</strong> rather than hardcoding an index selecting the right <a id="_idIndexMarker225"/>appointment. Change the return value to use this new state value when selecting an appointment, like this:<p class="source-code">&lt;div id="appointmentsDayView"&gt;</p><p class="source-code">  ...</p><p class="source-code">  &lt;Appointment</p><p class="source-code">    {...appointments[<strong class="bold">selectedAppointment</strong>]}</p><p class="source-code">  /&gt;</p><p class="source-code">&lt;/div&gt;</p></li>
<li>Change the <strong class="source-inline">map</strong> call to include an index in its arguments. Let’s just name that <strong class="source-inline">i</strong> as<a id="_idIndexMarker226"/> shown here:<p class="source-code">{appointments.map(<strong class="bold">(appointment, i)</strong> =&gt; (</p><p class="source-code">  &lt;li key={appointment.startsAt}&gt;</p><p class="source-code">    &lt;button type="button"&gt;</p><p class="source-code">      {appointmentTimeOfDay(appointment.startsAt)}</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">  &lt;/li&gt;</p><p class="source-code">))}</p></li>
<li>Now call <strong class="source-inline">setSelectedAppointment</strong> from within the <strong class="source-inline">onClick</strong> handler on the <strong class="source-inline">button</strong> element <a id="_idIndexMarker227"/>as follows:<p class="source-code">&lt;button</p><p class="source-code">  type="button"</p><p class="source-code"><strong class="bold">  onClick={() =&gt; setSelectedAppointment(i)}</strong></p><p class="source-code"><strong class="bold">&gt;</strong></p></li>
<li>Run your tests, and you should find they’re all green:<p class="source-code">PASS test/Appointment.test.js</p><p class="source-code">  Appointment</p><p class="source-code">    ✓ renders the customer first name (18ms)</p><p class="source-code">    ✓ renders another customer first name (2ms)</p><p class="source-code">  AppointmentsDayView</p><p class="source-code">    ✓ renders a div with the right id (7ms)</p><p class="source-code">    ✓ renders multiple appointments in an ol element (16ms)</p><p class="source-code">    ✓ renders each appointment in an li (4ms)</p><p class="source-code">    ✓ initially shows a message saying there are no appointments today (6ms)</p><p class="source-code">    ✓ selects the first element by default (2ms)</p><p class="source-code">    ✓ has a button element in each li (2ms)</p><p class="source-code">    ✓ renders another appointment when selected (3ms)</p></li>
</ol>
<p>We’ve covered a lot<a id="_idIndexMarker228"/> of detail in this section, starting with specifying the initial state of the view through to adding a <strong class="source-inline">button</strong> element and handling its <strong class="source-inline">onClick</strong> event.</p>
<p>We now have enough functionality that it makes sense to try it out and see where we’re at.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor047"/>Manually testing our changes</h1>
<p>The words <em class="italic">manual testing</em> should strike fear into the heart of every TDDer because it takes up <em class="italic">so</em> much time. Avoid it when<a id="_idIndexMarker229"/> you can. Of course, we can’t avoid it entirely –  when we’re done with a complete feature, we need to give it a once-over to <a id="_idIndexMarker230"/>check we’ve done the right thing.</p>
<p>As it stands, we can’t yet run our app. To do that, we’ll need to add an entry point and then use webpack to bundle our code.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor048"/>Adding an entry point</h2>
<p>React applications are <a id="_idIndexMarker231"/>composed of a hierarchy of components that are rendered at the root. Our application entry point should render this root component.</p>
<p>We tend to <em class="italic">not</em> test-drive entry points because any test that loads our entire application can become quite brittle as we add more and more dependencies into it. In <em class="italic">Part 4, Behavior-Driven Development with Cucumber</em>, we’ll look at using Cucumber tests to write some tests that <em class="italic">will</em> cover the entry point.</p>
<p>Since we aren’t test-driving it, we follow a couple of general rules:</p>
<ul>
<li>Keep it as brief as possible</li>
<li>Only use it to instantiate dependencies for your root component and to call <strong class="source-inline">render</strong></li>
</ul>
<p>Before we run our app, we’ll need<a id="_idIndexMarker232"/> some sample data. Create a file named <strong class="source-inline">src/sampleData.js</strong> and fill it with the following code:</p>
<pre class="source-code">
const today = new Date();
const at = (hours) =&gt; today.setHours(hours, 0);
export const sampleAppointments = [
  { startsAt: at(9), customer: { firstName: "Charlie" } },
  { startsAt: at(10), customer: { firstName: "Frankie" } },
  { startsAt: at(11), customer: { firstName: "Casey" } },
  { startsAt: at(12), customer: { firstName: "Ashley" } },
  { startsAt: at(13), customer: { firstName: "Jordan" } },
  { startsAt: at(14), customer: { firstName: "Jay" } },
  { startsAt: at(15), customer: { firstName: "Alex" } },
  { startsAt: at(16), customer: { firstName: "Jules" } },
  { startsAt: at(17), customer: { firstName: "Stevie" } },
];</pre>
<p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline">Chapter02/Complete</strong> directory in the GitHub repository contains a more complete set of sample data.</p>
<p>This list also doesn’t <a id="_idIndexMarker233"/>need to be test-driven for the following couple of reasons:</p>
<ol>
<li value="1">It’s a list of static data with no behavior. Tests are all about specifying behavior, and there’s none here.</li>
<li>This module will be removed once we begin using our backend API to pull data.</li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">TDD is often a pragmatic choice. Sometimes, not test-driving is the right thing to do.</p>
<p>Create a new file, <strong class="source-inline">src/index.js</strong>, and enter the following code:</p>
<pre class="source-code">
import React from "react";
import ReactDOM from "react-dom/client";
import { AppointmentsDayView } from "./Appointment";
import { sampleAppointments } from "./sampleData";
ReactDOM.createRoot(
  document.getElementById("root")
).render(
  &lt;AppointmentsDayView appointments={sampleAppointments} /&gt;
);</pre>
<p>That’s all you’ll <a id="_idIndexMarker234"/>need.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor049"/>Putting it all together with webpack</h2>
<p>Jest uses Babel to transpile all our <a id="_idIndexMarker235"/>code when it’s run in the test environment. But what about when we’re serving our code via our website? Jest won’t be able to help us there.</p>
<p>That’s where webpack comes in, and we can introduce it now to help us do a quick manual test as follows:</p>
<ol>
<li value="1">Install webpack using the<a id="_idIndexMarker236"/> following command:<p class="source-code"><strong class="bold">npm install --save-dev webpack webpack-cli babel-loader</strong></p></li>
<li>Add the following code to the <strong class="source-inline">scripts</strong> section of your <strong class="source-inline">package.json</strong> file:<p class="source-code">"build": "webpack",</p></li>
<li>You’ll also need to set some configuration for webpack. Create the <strong class="source-inline">webpack.config.js</strong> file in your project root directory with the following content:<p class="source-code">const path = require("path");</p><p class="source-code">const webpack = require("webpack");</p><p class="source-code">module.exports = {</p><p class="source-code">  mode: "development",</p><p class="source-code">  module: {</p><p class="source-code">    rules: [</p><p class="source-code">      {</p><p class="source-code">        test: /\.(js|jsx)$/,</p><p class="source-code">        exclude: /node_modules/,</p><p class="source-code">        loader: "babel-loader",</p><p class="source-code">      },</p><p class="source-code">    ],</p><p class="source-code">  },</p><p class="source-code">};</p></li>
</ol>
<p>This configuration <a id="_idIndexMarker237"/>works for webpack in development mode. Consult the webpack documentation for information on setting up production builds.</p>
<ol>
<li value="4">In your source directory, run<a id="_idIndexMarker238"/> the following commands:<p class="source-code"><strong class="bold">mkdir dist</strong></p><p class="source-code"><strong class="bold">touch dist/index.xhtml</strong></p></li>
<li>Add the following content to the file you just created:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;title&gt;Appointments&lt;/title&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;div id="root"&gt;&lt;/div&gt;</p><p class="source-code">    &lt;script src="main.js"&gt;&lt;/script&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
<li>You’re now ready to run the build using the following command:<p class="source-code"><strong class="bold">npm run build</strong></p></li>
</ol>
<p>You should see output such as the following:</p>
<p class="source-code">modules by path ./src/*.js 2.56 KiB</p>
<p class="source-code">  ./src/index.js 321 bytes [built] [code generated]</p>
<p class="source-code">  ./src/Appointment.js 1.54 KiB [built] [code generated]</p>
<p class="source-code">  ./src/sampleData.js 724 bytes [built] [code generated]</p>
<p class="source-code">webpack 5.65.0 compiled successfully in 1045 ms</p>
<ol>
<li value="7">Open <strong class="source-inline">dist/index.xhtml</strong> in your browser and behold your creation!</li>
</ol>
<p>The following screenshot<a id="_idIndexMarker239"/> shows the application once the <em class="italic">Exercises</em> are <a id="_idIndexMarker240"/>completed, with added CSS and extended sample data. To include the CSS, you’ll need to pull <strong class="source-inline">dist/index.xhtml</strong> and <strong class="source-inline">dist/styles.css</strong> from the <strong class="source-inline">Chapter02/Complete</strong> directory.</p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 2.2 – The application so far " height="591" src="image/Figure_2.02_B18423.jpg" width="1128"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The application so far</p>
<p class="callout-heading">Before you commit your code into Git...</p>
<p class="callout">Make sure to <a id="_idIndexMarker241"/>add <strong class="source-inline">dist/main.js</strong> to your <strong class="source-inline">.gitignore</strong> file as follows:</p>
<p class="callout"><strong class="bold">echo "dist/main.js" &gt;&gt; .gitignore</strong></p>
<p class="callout">The <strong class="source-inline">main.js</strong> file is generated by webpack, and as with most generated files, you shouldn’t check it in.</p>
<p class="callout">You may also want to add <strong class="source-inline">README.md</strong> at this point to remind yourself how to run tests and how to build the application.</p>
<p>You’ve now seen how to put <a id="_idIndexMarker242"/>TDD aside while you created an entry point: since the entry point is small and unlikely to change frequently, we’ve opted not to test-drive it.</p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor050"/>Summary</h1>
<p>In this chapter, you’ve been able to practice the TDD cycle a few times and get a feel for how a feature can be built out using tests as a guide.</p>
<p>We started by designing a quick mock-up that helped us decide our course of action. We have built a container component (<strong class="source-inline">AppointmentsDayView</strong>) that displayed a list of appointment times, with the ability to display a single <strong class="source-inline">Appointment</strong> component depending on which appointment time was clicked.</p>
<p>We then proceeded to get a basic list structure in place, then extended it to show the initial <strong class="source-inline">Appointment</strong> component, and then finally added the <strong class="source-inline">onClick</strong> behavior.</p>
<p>This testing strategy, of starting with the basic structure, followed by the initial view, and finishing with the event behavior, is a typical strategy for testing components. </p>
<p>We’ve only got a little part of the way to fully building our application. The first few tests of any application are always the hardest and take the longest to write. We are now over that hurdle, so we’ll move quicker from here onward.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor051"/>Exercises</h1>
<ol>
<li value="1">Rename <strong class="source-inline">Appointment.js</strong> and <strong class="source-inline">Appointment.test.js</strong> to <strong class="source-inline">AppointmentsDayView.js</strong> and <strong class="source-inline">AppointmentsDayView.test.js</strong>. While it’s fine to include multiple components in one file if they form a hierarchy, you should always name the file after the root component for that hierarchy.</li>
<li>Complete the <strong class="source-inline">Appointment</strong> component by displaying the following fields on the page. You should use a <strong class="source-inline">table</strong> HTML element to give the data some visual structure. This shouldn’t affect how you write your tests. The fields that should be displayed are the following: <ul><li>Customer last name, using the <strong class="source-inline">lastName</strong> field</li>
<li>Customer telephone number, using the <strong class="source-inline">phoneNumber</strong> field</li>
<li>Stylist name, using the <strong class="source-inline">stylist</strong> field</li>
<li>Salon service, using the <strong class="source-inline">service</strong> field</li>
<li>Appointment notes, using the <strong class="source-inline">notes</strong> field</li>
</ul></li>
<li>Add a heading to <strong class="source-inline">Appointment</strong> to make it clear which appointment time is being viewed.</li>
<li>There is some<a id="_idIndexMarker243"/> repeated sample data. We’ve used sample data in our tests, and we also have <strong class="source-inline">sampleAppointments </strong>in <strong class="source-inline">src/sampleData.js</strong>, which we used to manually test our application. Do you think it is worth drying this up? If so, why? If not, why not?</li>
</ol>
<h1 id="_idParaDest-54"><a id="_idTextAnchor052"/>Further reading</h1>
<p>Hooks are a relatively recent addition to React. Traditionally, React used classes for building components with state. For an overview of how hooks work, take a look at React’s own comprehensive documentation at the following link: </p>
<p><a href="https://reactjs.org/docs/hooks-overview.xhtml">https://reactjs.org/docs/hooks-overview.xhtml</a>.</p>
</div>
<div>
<div id="_idContainer013">
</div>
</div>
</div></body></html>