- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Managing State in a Simple React App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在简单的 React 应用程序中管理状态
- en: 'In the previous chapter, we went over a brief history of web development, **JavaScript**,
    **ReactJS**, and **React Native**. Even though historical knowledge is not required
    to write great code, I find it useful. Once we learn why specific library creators
    encourage some patterns and discourage others, we can write code that is less
    error-prone and more performant. Ah yes! Writing code! That’s why you’re here,
    dear reader, isn’t it? Well, I have good news. In this chapter, we will dive into
    code examples. We will start by looking at the most basic data and state management
    strategies in React: using state and props. We will then dive into a comparison
    of stateful and stateless components. Once we have a good understanding of how
    state works in React applications, we will move on to talking about hooks. We
    will finish off this chapter by completing a setup and configuration of our own
    little app.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要回顾了网络开发、**JavaScript**、**ReactJS** 和 **React Native** 的历史。尽管历史知识不是编写出色代码的必要条件，但我发现它很有用。一旦我们了解到为什么特定的库创建者鼓励某些模式并阻止其他模式，我们就可以编写出更少错误和更高效的代码。啊，是的！编写代码！这就是你在这里的原因，亲爱的读者，不是吗？好消息是，在本章中，我们将深入研究代码示例。我们将从查看
    React 中最基本的数据和状态管理策略开始：使用状态和属性。然后，我们将深入比较有状态和无状态组件。一旦我们对 React 应用程序中状态的工作方式有了很好的理解，我们将继续讨论
    hooks。我们将通过完成我们自己的小应用程序的设置和配置来结束本章。
- en: 'Here are the bullet points of what we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要涵盖的要点：
- en: What is state and how is it different from props?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是什么？它与属性有何不同？
- en: What are stateful and stateless components?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态和无状态组件是什么？
- en: What are hooks and why use them?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 hooks？为什么使用它们？
- en: Setting up the example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置示例应用程序
- en: By the end of this chapter, you should feel comfortable with React code. We
    will also set up the base for our application. Even though applications can be
    very different from one another, this basic setup will remain the same for most
    of them. Feel free to reuse it for any other project you may want to work on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对 React 代码感到舒适。我们还将为我们的应用程序设置基础。尽管应用程序可能彼此非常不同，但这个基本设置对于大多数应用程序来说都将保持不变。请随意将其用于你想要工作的任何其他项目。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you are familiar with **ReactJS** but you have not worked with **React Native**
    yet, you will be able to follow along with this section without any problem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 **ReactJS** 但尚未使用过 **React Native**，你将能够毫无问题地跟随本节内容。
- en: If you have never read or written any **ReactJS** or **React Native** code,
    it’s important that you learn the basic concepts. Please head over to the official
    **React Native** documentation at [https://reactnative.dev/docs/intro-react](https://reactnative.dev/docs/intro-react)
    and familiarize yourself with key concepts such as **components, JSX, state,**
    **and props**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未阅读或编写过任何 **ReactJS** 或 **React Native** 代码，学习基本概念非常重要。请访问官方 **React Native**
    文档[https://reactnative.dev/docs/intro-react](https://reactnative.dev/docs/intro-react)，并熟悉如
    **组件、JSX、状态** 和 **属性** 等关键概念。
- en: A minimum requirement for this chapter is knowledge of Git, basic knowledge
    of **command-line interfaces** (**CLIs**), and a working knowledge of JavaScript.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最低要求是了解 Git、基本的 **命令行界面**（**CLIs**）知识，以及 JavaScript 的实际应用。
- en: What is state and how is it different from props?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态是什么？它与属性有何不同？
- en: Every **React Native** application is created to display some sort of data.
    It can be weather data, images, market data, maps… Using **React Native**, we
    manage how this data is displayed on our users’ screens. **React Native** offers
    robust tools for styling and animating content. However, in this book, we are
    concentrating on the raw material of data used in your app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 **React Native** 应用程序都是为了显示某种类型的数据而创建的。这可能包括天气数据、图片、市场数据、地图……使用 **React Native**，我们管理这些数据如何在用户屏幕上显示。**React
    Native** 提供了强大的工具来样式化和动画化内容。然而，在这本书中，我们专注于你的应用程序中使用的数据的原始材料。
- en: In order to have a dynamic piece of data, existing **automagically** in sync
    with our component, we need to declare the list as a component state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个动态的数据片段，它能够自动与我们的组件保持同步，我们需要将列表声明为组件状态。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The most important thing to remember about state is this: state is managed
    within the component; it is the component **memory**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于状态，需要记住的最重要的事情是：状态是在组件内部管理的；它是组件的 **内存**。
- en: 'Any changes in state will cause your component and all its children to re-render.
    This is an expected behavior: if your data changes, you want your UI to change
    as well. However, multiple component re-renders may cause your app to encounter
    performance issues.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的任何变化都会导致你的组件及其所有子组件重新渲染。这是一个预期的行为：如果你的数据发生变化，你希望你的UI也相应地改变。然而，多个组件的重新渲染可能会导致你的应用遇到性能问题。
- en: 'Let’s look at an example to better understand state. We will start off with
    a very basic component, containing a `<Text>` element and a `<Pressable>` element.
    `<Pressable>` is the recommended component to use in React Native applications
    in places where a web developer would use a `<``button>` tag:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来更好地理解状态。我们将从一个非常基本的组件开始，包含一个`<Text>`元素和一个`<Pressable>`元素。`<Pressable>`是React
    Native应用中推荐使用的组件，在Web开发者会使用`<button>`标签的地方：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can probably observe, dear reader, nothing will happen when the `<Pressable>`
    component is tapped because we haven’t provided an `onPress` function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经观察到，亲爱的读者，当点击`<Pressable>`组件时不会发生任何事，因为我们还没有提供`onPress`函数。
- en: 'We will now add state to this simple component. We will set a checked/unchecked
    text inside the `<Text>` component, linked to the component state:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向这个简单的组件添加状态。我们将在`<Text>`组件内设置一个选中/未选中的文本，并将其与组件状态相关联：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Testing React Native code is a little more complicated than testing code made
    to run in browsers (as with JavaScript or ReactJS). Lucky for us, the good people
    at Expo created an online tool for testing code snippets. It’s called Expo Snack
    and you can use it to test the preceding code at [https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-1](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试React Native代码比测试在浏览器中运行的代码（如JavaScript或ReactJS）要复杂一些。幸运的是，Expo的好人们创建了一个在线工具来测试代码片段。它被称为Expo
    Snack，你可以用它来测试前面的代码，网址是[https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-1](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-1)。
- en: 'Let’s walk through the changes one by one. We start by adding an import of
    the `useState` hook from the React library on the first line. Then, inside the
    component, we set this variable:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看这些变化。我们首先在第一行添加从React库中导入`useState`钩子的语句。然后，在组件内部，我们设置这个变量：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `useState` hook accepts an array, where the first item is the state value,
    and the second item is the function that will set the value. If you will not change
    the state in your component, you can omit the second argument. There is no official
    rule as per the names of the items in the array, but it is an accepted convention
    to name the setter function similarly to the state value, but with the `"set"`
    keyword. Last but not least, the `"unchecked"` string is passed to the `useState`
    hook. This is the default value of the `useState` hook. If you do not wish to
    set a default state, you may leave the parentheses empty.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`钩子接受一个数组，其中第一个元素是状态值，第二个元素是设置值的函数。如果你在组件中不会改变状态，你可以省略第二个参数。关于数组中元素的名称没有官方规则，但将设置函数命名为与状态值类似，但使用“set”关键字是一种公认的习惯。最后但同样重要的是，将“unchecked”字符串传递给`useState`钩子。这是`useState`钩子的默认值。如果你不希望设置默认状态，你可以将括号留空。'
- en: 'Now that we have the state hook imported and the component state set with the
    `useState` hook, we can use it in our component. Hence, this line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了状态钩子，并使用`useState`钩子设置了组件状态，我们可以在组件中使用它。因此，这一行：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The curly braces surrounding the state are part of **JSX**. **JSX** is a syntax
    extension to **JavaScript**, and it’s the syntax used to write all **React** components.
    "*What does that mean in regular English?"* you ask, dear reader. It means that
    when writing in **JSX**, you can write any **JavaScript** code, plus you can write
    additional stuff, such as **component state** wrapped in curly braces. You could
    look at **JSX** compared to **JavaScript** as if it were a pirate speaking as
    compared to plain English. All English pirates will understand all English phrases,
    but a regular Englishman will not understand all pirate phrases. All right, matey?
    Let’s move on then, yo ho ho!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 包围状态的括号是**JSX**的一部分。**JSX**是**JavaScript**的语法扩展，它是编写所有**React**组件所使用的语法。*"这对你来说意味着什么？"*你，亲爱的读者，问。这意味着在编写**JSX**时，你可以编写任何**JavaScript**代码，并且还可以编写额外的内容，例如用括号包裹的**组件状态**。你可以将**JSX**与**JavaScript**相比，就像海盗说话与普通英语相比一样。所有说英语的海盗都会理解所有的英语短语，但一个普通的英语人可能不会理解所有的海盗短语。好吧，伙计？那么我们就继续吧，嘿嘿嘿！
- en: 'We have the state set up, but our `<Pressable>` component still doesn’t do
    anything, does it? Let’s add an `onPress` function, which will set the state.
    The simplest way to achieve this is to pass the `setCheckedState` function from
    the `useState` hook right into the `onPress` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了状态，但我们的`<Pressable>`组件仍然没有任何作用，对吧？让我们添加一个`onPress`函数，它将设置状态。实现这一点最简单的方法是将`setCheckedState`函数从`useState`钩子直接传递到`onPress`函数中：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, when the `<Pressable>` button is pressed, it will change the state of the
    component, which in turn will change the text displayed in the `<``Text>` component.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当按下`<Pressable>`按钮时，它将改变组件的状态，这反过来又会改变`<Text>`组件中显示的文本。
- en: There is much more you can achieve with the `useState` hook. You can set it
    to any value you like, including an object. Every component can have multiple
    pieces of state, as many as you’d like, actually! If you would like to look at
    other examples of how state can be implemented in a React component, I invite
    you to check the first link from the *Further* *reading* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`useState`钩子实现更多的事情。你可以将其设置为任何你喜欢的值，包括一个对象。每个组件都可以有多个状态，实际上可以有很多！如果你想看看如何在React组件中实现状态的其它示例，我邀请你查看*进一步阅读*部分的第一个链接。
- en: 'Let’s move on to the second hero of this section: props. Props is a short name
    for **properties**. Props are **JavaScript** objects just like state; the biggest
    difference between them is that props are read-only.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到本节第二个英雄：props。Props是**属性**的简称。Props就像state一样是JavaScript对象；它们之间最大的区别是props是只读的。
- en: Important note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The most important thing to remember about props is this: props are immutable
    (or read-only).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于props，最重要的是记住这一点：props是不可变的（或只读的）。
- en: 'A natural flow of a `"checked"`/`"unchecked"` state. The parent component has
    children: components with images or text, and so on, to whom we pass the state
    in the form of a prop. The children can `"checked"` or `"unchecked"`, in this
    case. But the children will never **change** the state of the text. The **state**
    of the text can only be changed within the parent component where state was declared.
    Let’s update our code example to include a parent and a child component, with
    state set in the parent and passed to the child through props:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`"checked"`/`"unchecked"`状态的天然流动。父组件有子组件：带有图像或文本的组件等，我们将状态以prop的形式传递给它们。在这种情况下，子组件可以是`"checked"`或`"unchecked"`。但是，子组件永远不会**改变**文本的状态。文本的状态只能在声明状态的父组件内部改变。让我们更新我们的代码示例，包括一个父组件和一个子组件，状态在父组件中设置并通过props传递给子组件：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can find the preceding code in this Expo Snack: [https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-2](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-2).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下Expo Snack中找到前面的代码：[https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-2](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-2)。
- en: 'Let’s start with what remained the same as in the previous example. We have
    our `<ParentComponent>`, which, OK, was named `<ManagedButton>` before. But let’s
    be honest, this component didn’t change much from the previous version. The only
    change here is that instead of a `<Text>` component, we see a `<ManagedText>`
    component, with a mysterious `checkedState` property. This property is passed
    to the `<ManagedText>` component and then to the `<Text>` component inside it.
    Pressing the `<Pressable>` component will change the state of `<ParentComponent>`,
    which will also be reflected in the child component: `<ManagedText>`. I believe,
    dear reader, that the parent/child nomenclature is quite understandable and doesn’t
    need additional explanations. As per the `checkedState` property, or prop for
    short, you should know that you can name it whatever you would like; there is
    no need to set the name of the prop to be the same as its value. You could write
    something like this, for example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从与上一个示例相同的地方开始。我们有我们的`<ParentComponent>`，之前它被命名为`<ManagedButton>`。但是说句实话，这个组件与上一个版本相比变化不大。这里唯一的改变是，我们看到了一个`<ManagedText>`组件，而不是一个`<Text>`组件，它有一个神秘的`checkedState`属性。这个属性被传递给`<ManagedText>`组件，然后传递给它内部的`<Text>`组件。按下`<Pressable>`组件将改变`<ParentComponent>`的状态，这也会反映在子组件`<ManagedText>`中。我相信，亲爱的读者，父/子命名法是非常容易理解的，不需要额外的解释。至于`checkedState`属性，或者简称为prop，你应该知道你可以给它取任何你喜欢的名字；没有必要将prop的名字设置为与它的值相同。例如，你可以这样写：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re curious to learn more about props and state, you can head over to
    articles recommended by the official React team. They are listed in the *Further*
    *reading* section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于props和状态的信息，可以查看官方React团队推荐的文章。它们列在*进一步阅读*部分。
- en: Now that you know what state and props are and how they are different from each
    other, in the following section, we will look at stateful and stateless components.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了状态和props是什么，以及它们彼此之间的不同，在接下来的部分，我们将探讨有状态组件和无状态组件。
- en: What are stateful and stateless components?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是有状态组件和无状态组件？
- en: Whether you’re completely new to the **React** world, or you’ve been here for
    a little while, you have probably heard the terms **stateful** and **stateless**
    components. These terms were especially useful before the introduction of hooks
    in **ReactJS** v16.8\. Don’t worry about hooks right now—we’ll get to them toward
    the end of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是完全新接触React世界，还是在这里已经有一段时间了，你很可能已经听说过**有状态**和**无状态**组件这两个术语。在ReactJS v16.8引入hooks之前，这些术语特别有用。现在不用担心hooks——我们将在本章末尾讨论它们。
- en: From a high-level perspective, **ReactJS** and **React Native** components are
    nothing more than **JavaScript** functions. The **React** library adds some specific
    features to those functions. One of those features is **state**, a special kind
    of component memory that we looked at in the previous section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个高层次的角度来看，**ReactJS**和**React Native**组件不过是**JavaScript**函数。React库为这些函数添加了一些特定的功能。其中之一就是**状态**，这是一种我们在上一节中探讨的特殊类型的组件内存。
- en: 'A React component that can accept state may look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以接受状态的React组件可能看起来像这样：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This type of component is also commonly called a “class component” because of
    the way it needs to be declared. Class components, or stateful components, were
    first-class citizens until `componentDidMount()`, `componentWillUnmount()`, `shouldComponentUpdate()`,
    and a few others. These functions were a lifesaver for many developers facing
    edge cases. For example, they needed some data to be loaded before the rest of
    the **component**, or maybe they needed to make sure to clean up some side effect
    functions before the **component** unmounted. Unfortunately, this also meant that
    their **components** became increasingly complex logically. Trying to understand
    the flow of the code in a file containing multiple **“lifecycle methods”** is
    a real challenge. If you would like to learn more about lifecycle methods, please
    look at the *Further reading* section, where you will find a link to an article
    in the ReactJS documentation entitled *Adding Lifecycle Methods to* *a Class*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的组件也通常被称为“类组件”，因为它需要以这种方式声明。类组件，或称有状态组件，在`componentDidMount()`、`componentWillUnmount()`、`shouldComponentUpdate()`以及一些其他函数出现之前是一等公民。这些函数对于许多面临边缘情况的开发者来说是一大救星。例如，他们需要在**组件**的其他部分加载一些数据之前，或者在他们确保在**组件**卸载前清理一些副作用函数之前。不幸的是，这也意味着他们的**组件**在逻辑上变得越来越复杂。试图理解包含多个**“生命周期方法”**的文件的代码流程是一项真正的挑战。如果你想了解更多关于生命周期方法的信息，请查看*进一步阅读*部分，那里你可以找到一个链接到ReactJS文档中一篇题为*在类中添加生命周期方法*的文章。
- en: '**Stateful components** are also more difficult to test than **stateless components**,
    plus they compile slower and are bigger after compilation.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**有状态组件**比**无状态组件**更难测试，而且它们编译速度较慢，编译后体积也更大。'
- en: '**Stateless components**, also known as **functional components**, are the
    lightweight brothers of class components. Here’s an example of a stateless component:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**无状态组件**，也称为**函数组件**，是类组件的轻量级兄弟。以下是一个无状态组件的例子：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comparing the two example **components** shown in the preceding snippet, you
    should notice a big difference in the number of lines of code needed to write
    the given **component**. Our simple stateful **component** needed nine lines for
    what the **functional component** achieved in three!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 比较前面片段中显示的两个示例**组件**，你应该注意到编写给定**组件**所需的代码行数有很大的差异。我们简单的有状态**组件**需要九行代码，而**函数组件**在三个代码行内就实现了相同的功能！
- en: This means `constructor` or special `componentDidUpdate`. They do, of course,
    have the great downside of not being able to manage state. So, an ideal **ReactJS**
    or **React Native** app would include at least one parent, a stateful component,
    which then would pass props to all kinds of stateless children components. However,
    there are hardly any ideal apps in the real world. Developers would very often
    write stateful components and add lifecycle methods to manage when UI updates
    should and should not happen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`constructor`或特殊的`componentDidUpdate`。当然，它们有一个很大的缺点，就是无法管理状态。所以，一个理想的**ReactJS**或**React
    Native**应用至少应该包含一个父组件，一个有状态的组件，然后它会将属性传递给各种无状态的子组件。然而，在现实世界中几乎没有理想的应用。开发者经常会编写有状态的组件，并添加生命周期方法来管理何时以及何时不应更新UI。
- en: This trend changed with the aforementioned **ReactJS** v16.8 when the concept
    of hooks was introduced in the **ReactJS** world, which we are going to look at
    in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种趋势随着之前提到的**ReactJS** v16.8的发布而改变，当时在**ReactJS**世界中引入了钩子的概念，我们将在下一节中探讨。
- en: What are hooks and why use them?
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子是什么？为什么使用它们？
- en: As I mentioned before, stateless components are generally easier to write and
    test. They should be the go-to component of `useState` is a function that returns
    a stateful value and a function to update it. You may recognize it from our previous
    section about state in React components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，无状态组件通常更容易编写和测试。当`useState`是一个返回状态值和更新它的函数时，它们应该是`useState`的默认组件。你可能在我们之前关于React组件状态的章节中见过它。
- en: 'Let’s go back to our example of a stateful component, change it to a functional
    one, and add the `useState` hook, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前的有状态组件的例子，将其改为函数式组件，并添加`useState`钩子，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ta-da! It looks so much cleaner than the previous example! We still have a component
    capable of holding and managing state changes, but it’s much shorter than the
    stateful class component. I also feel this type of component has a very nice logical
    flow, where we declare the state value and the state setter function on one line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 哇塞！这看起来比之前的例子干净多了！我们仍然有一个能够持有和管理状态变化的组件，但它比有状态类组件要短得多。我还觉得这种组件的逻辑流程非常好，我们可以在一行中声明状态值和状态设置函数。
- en: If you want to see this code in action, you can go to [https://snack.expo.dev/@p-syche/example-of-functional-component-with-usestate](https://snack.expo.dev/@p-syche/example-of-functional-component-with-usestate).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到这段代码的实际应用，你可以访问[https://snack.expo.dev/@p-syche/example-of-functional-component-with-usestate](https://snack.expo.dev/@p-syche/example-of-functional-component-with-usestate)。
- en: This is an **Expo Snack**—an equivalent of code snippets for web development.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**Expo Snack**——类似于网络开发的代码片段。
- en: Which hooks should you know?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该了解哪些钩子？
- en: 'The first hook we spoke about was `useState`, and that one is the absolute
    first you should familiarize yourself with. The second most used hook is `useEffect`.
    I also believe this is one of the best-named hooks. You can use it to add all
    sorts of side effects to your components. "*What is a side effect?"* you may ask,
    my dear reader. Let’s try to grasp this concept using examples: imagine a social
    media app (much like the app we will be building in this book!). Now, let’s imagine
    you are tasked with adding a likes counter. You have your parent `<Text>` **component**
    with a counter. It would look something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的第一个钩子是`useState`，这是你应该首先熟悉的一个。第二个最常用的钩子是`useEffect`。我也相信这是命名最好的钩子之一。你可以用它给你的组件添加各种副作用。你可能会问，“什么是副作用？”亲爱的读者，让我们通过例子来尝试理解这个概念：想象一个社交媒体应用（就像我们在本书中将要构建的应用一样！）现在，让我们想象你被分配了一个添加点赞计数器的任务。你有一个带有计数的父`<Text>`组件。它看起来可能像这样：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are passing `counterNumber` from `<LikesParentComponent>` as a prop. Let’s
    assume this parent component handles retrieving the number of likes from an API
    using the very nicely named `someFunctionRetrievingDataFromAPI()` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将`counterNumber`从`<LikesParentComponent>`作为属性传递。让我们假设这个父组件使用名为`someFunctionRetrievingDataFromAPI()`的非常贴切的功能来从API获取点赞数。
- en: 'This is looking pretty good so far, right? We load our components; they retrieve
    the likes data from an API and pass it to our `<LikesComponent>`, which displays
    it nicely. But wait! What happens if the user touches the `<Pressable>` component?
    We will set `<Text>` to `liked`, but the counter will not go up! We simply cannot
    leave it like this! This is a classic side effect: a user action requires additional
    changes in component state. First of all, we cannot change `counterNumber` from
    within `<LikesComponent>` because, as we learned in the previous section on state
    and props, props are immutable. What can we do, then? We can use the state setter
    function from the parent component. This function can be passed as a prop. This
    means `<LikesParentComponent>` will invoke its child, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，看起来相当不错，对吧？我们加载了组件；它们从 API 中检索点赞数据并将其传递给我们的 `<LikesComponent>`，它以很好的方式显示。但是等等！如果用户触摸了
    `<Pressable>` 组件会发生什么？我们将 `<Text>` 设置为 `liked`，但计数器不会增加！我们绝对不能就这样留下！这是一个经典的副作用：用户操作需要组件状态中的额外更改。首先，我们不能在
    `<LikesComponent>` 内部更改 `counterNumber`，因为我们之前在状态和属性部分学到的是属性是不可变的。那么我们能做什么呢？我们可以使用父组件的状态设置函数。这个函数可以作为属性传递。这意味着
    `<LikesParentComponent>` 将像这样调用其子组件：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, so good. Now, all we need to do is call this setter function at an
    appropriate time, which means when the button is pressed in `<LikesComponent>`.
    This is what it would look like using the `useEffect` hook:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在，我们只需要在适当的时候调用这个设置函数，这意味着在 `<LikesComponent>` 中按下按钮时。这就是使用 `useEffect`
    钩子时的样子：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you may notice, the `useEffect` hook looks very different from the `useState`
    hook. Don’t worry too much about this. These two hooks are the most used, and
    you will get used to the way they are conceived and consumed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，`useEffect` 钩子看起来与 `useState` 钩子非常不同。不必过于担心这一点。这两个钩子是最常用的，您会习惯它们的构思和消费方式。
- en: The inside of our example `useEffect` hook is a common `if`/`else` statement
    checking whether the value of the state equals `"liked"` or not. The most crucial
    and interesting part of this hook is the array at the very end. This array is
    called a dependency array. It is used to inform the hook function when it should
    run. In our case, the `useEffect` hook should run when the value of `likeState`
    changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的 `useEffect` 钩子内部是一个常见的 `if`/`else` 语句，用于检查状态的值是否等于 `"liked"`。这个钩子最关键和有趣的部分是位于最后的数组。这个数组被称为依赖数组。它用于通知钩子函数何时运行。在我们的例子中，当
    `likeState` 的值发生变化时，`useEffect` 钩子应该运行。
- en: 'The `useEffect` hook can be used to update different pieces of the app, to
    help with data fetching, for user-driven interactions, and so on. This hook is
    very powerful, but it has a very big risk: it can cause many re-renders when written
    incorrectly.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子可以用来更新应用的不同部分，帮助数据获取、用户驱动的交互等等。这个钩子非常强大，但它有一个非常大的风险：如果编写不当，它会导致许多重新渲染。'
- en: The most important thing to remember about useEffect
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `useEffect` 最重要的事情要记住
- en: Make sure the dependency array of `useEffect` is correct!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 确保正确设置 `useEffect` 的依赖数组！
- en: As you may find in the official `useEffect`’s dependency array. If we set that,
    our effect will run *only* if any items in the dependency array change.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能在官方 `useEffect` 的依赖数组中找到的那样。如果我们设置它，那么我们的效果将仅在依赖数组中的任何项目发生变化时运行。
- en: There are a few other built-in hooks. You don’t have to know them all when starting
    to write `useState` and `useEffect`—will be enough to get you started. When you
    get to a point where those two hooks are not enough, you can go back to the **ReactJS**
    documentation and read about other hooks. You can also write your own custom hooks
    useful for your particular app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个其他的内置钩子。在开始编写 `useState` 和 `useEffect` 时，您不必了解它们的所有内容——这足以让您开始。当您到达这两个钩子不足以满足需求的时候，您可以回到
    **ReactJS** 文档中阅读关于其他钩子的内容。您还可以编写适用于您特定应用的自己的自定义钩子。
- en: Now that we know what hooks are and why we use them, let’s get started with
    setting up our sample app!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了什么是钩子以及为什么我们要使用它们，让我们开始设置我们的示例应用！
- en: Setting up the example app
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置示例应用
- en: 'Ah! The moment you’ve probably been waiting for: actually creating an app!'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！您可能一直在等待的时刻：实际上创建一个应用！
- en: We will start by preparing our development environment. You will need an **integrated
    development environment** (**IDE**) such as VS Code, Sublime Text, Atom, or anything
    else you may prefer. An IDE is all you need to write **React Native** code. But
    we also need a way to see what the code renders, don’t we?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先准备我们的开发环境。你需要一个 **集成开发环境**（**IDE**）例如 VS Code、Sublime Text、Atom 或你可能喜欢的任何其他东西。IDE
    是你编写 **React Native** 代码所需的一切。但我们还需要一种方式来查看代码的渲染效果，不是吗？
- en: 'In the case of web development, we would simply use the browser to see and
    test our code. However, **React Native** apps cannot be easily tested in a web
    browser. They can and should be tested on real or simulated devices. In an ideal
    situation, you would have access to multiple phones, which you would plug into
    your computer via a USB in order to see your app. Most of us don’t have multiple
    phones, though. That’s why we can use phone simulators. There are two major players
    in the mobile world: Android and Apple. Android simulators are available for virtually
    any desktop platform thanks to the Android Studio app. Unfortunately, iPhone simulators
    can be run exclusively on Mac computers.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页开发的情况下，我们只需使用浏览器来查看和测试我们的代码。然而，**React Native** 应用不能在网页浏览器中轻松测试。它们可以在真实或模拟设备上进行测试。在理想情况下，你会拥有多部手机，并将它们通过
    USB 插入电脑以查看你的应用。尽管如此，我们大多数人并没有多部手机。这就是为什么我们可以使用手机模拟器。在移动世界中，有两个主要玩家：Android 和
    Apple。由于 Android Studio 应用，Android 模拟器几乎可以在任何桌面平台上使用。不幸的是，iPhone 模拟器只能在 Mac 电脑上运行。
- en: Setting up simulators can be a daunting task, but don’t worry too much! There’s
    **Expo**!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置模拟器可能是一项艰巨的任务，但不必过于担心！有 **Expo** 帮助！
- en: 'I spoke about **Expo** in the first chapter. If you skipped that part, let
    me give you a quick rundown: **Expo** is **React Native** development tooling.
    It makes building, testing, and publishing apps much easier. **Expo** is a wrapper
    on top of **React Native**, aimed at making the developer experience smoother.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我在第一章中提到了 **Expo**。如果你跳过了那部分，让我快速介绍一下：**Expo** 是 **React Native** 开发工具。它使得构建、测试和发布应用变得更加容易。**Expo**
    是在 **React Native** 之上的一层包装，旨在使开发者体验更加流畅。
- en: Environment setup
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境设置
- en: 'Let’s make sure your development environment is ready. As listed on the Expo
    website, you will need the latest Node, Git, and Watchman. Links to all of these
    can be found in Expo’s documentation at [https://docs.expo.dev/get-started/installation/](https://docs.expo.dev/get-started/installation/).
    We will be using Yarn during development, so please make sure you have it installed.
    You can find detailed instructions here: [https://classic.yarnpkg.com/en/docs/install](https://classic.yarnpkg.com/en/docs/install).
    Once you have gone through the links, follow these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保你的开发环境已经准备好。根据 Expo 网站上的说明，你需要最新的 Node、Git 和 Watchman。所有这些的链接都可以在 Expo
    的文档中找到，地址是 [https://docs.expo.dev/get-started/installation/](https://docs.expo.dev/get-started/installation/)。我们在开发过程中将使用
    Yarn，所以请确保你已经安装了它。你可以在这里找到详细说明：[https://classic.yarnpkg.com/en/docs/install](https://classic.yarnpkg.com/en/docs/install)。一旦你浏览了这些链接，请按照以下步骤操作：
- en: 'When you’re ready, go ahead and install Expo’s CLI tools:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你准备好时，请继续安装 Expo 的 CLI 工具：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Verify that the installation was successful by running `expo whoami`. You’re
    not logged in yet, so you will see `expo register`, or you can log in to an existing
    account with `expo login`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `expo whoami` 来验证安装是否成功。你还没有登录，所以你会看到 `expo register`，或者你可以使用 `expo login`
    登录现有的账户。
- en: The next step is to install the Expo Go app on your phone. You can find it in
    the Android Store at [https://play.google.com/store/apps/details?id=host.exp.exponent](https://play.google.com/store/apps/details?id=host.exp.exponent)
    and on the App Store at [https://apps.apple.com/app/expo-go/id982107779](https://apps.apple.com/app/expo-go/id982107779).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在你的手机上安装 Expo Go 应用。你可以在 Android 商店中找到它，地址是 [https://play.google.com/store/apps/details?id=host.exp.exponent](https://play.google.com/store/apps/details?id=host.exp.exponent)，以及在
    App Store 中的 [https://apps.apple.com/app/expo-go/id982107779](https://apps.apple.com/app/expo-go/id982107779)。
- en: Thanks to Expo, it does not matter if you have a Mac computer or a Windows computer
    and what kind of phone you have. The **Expo Go** app will “automagically” work
    on Android and Apple devices.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 Expo，无论你使用的是 Mac 电脑还是 Windows 电脑，以及你拥有什么类型的手机，**Expo Go** 应用都会“自动”在 Android
    和 Apple 设备上运行。
- en: 'We’re all set—it’s time to create the app. Go to your terminal and run the
    following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了——是时候创建应用了。打开你的终端并运行以下命令：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When prompted about templates, please choose **blank**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被提示选择模板时，请选择 **空白**。
- en: You can choose any name you like for your app. I suggested using “`Funbook`”
    because it sounds a little like “Facebook” and we’ll be creating a social media
    app clone. Sticking with the same name as me will probably make it easier to follow
    along with code examples.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的应用选择任何你喜欢的名字。我建议使用“`Funbook`”，因为它听起来有点像“Facebook”，我们将创建一个社交媒体应用克隆。保持和我一样的名字可能会使跟随代码示例更容易。
- en: 'After app initialization is successfully run, you can go to your app’s folder
    by running the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用初始化成功运行后，你可以通过运行以下命令进入你的应用文件夹：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And run the development server, like so:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行开发服务器，如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or, if you’re using Yarn, run this command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用Yarn，运行这个命令：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Expo CLI starts Metro Bundler, which is an HTTP server that compiles the JavaScript
    code of our app. You should see a QR code that you can now scan using the Expo
    Go app on your phone. You can run your Funbook app on as many devices as you’d
    like.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Expo CLI启动Metro Bundler，这是一个编译我们应用JavaScript代码的HTTP服务器。你应该会看到一个二维码，你现在可以使用手机上的Expo
    Go应用扫描它。你可以在你想要的任何设备上运行你的Funbook应用。
- en: App development can seem a little daunting at first, but don’t worry if not
    everything works perfectly on the first try. There’s a big chance you will find
    the culprit in your terminal window. The terminal output is the best source of
    information for you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应用开发一开始可能会显得有些令人畏惧，但如果第一次尝试不是所有东西都完美运行，请不要担心。有很大可能性你会在终端窗口中找到罪魁祸首。终端输出是你获取信息的最佳来源。
- en: 'If you see any errors in the terminal, or you feel a little bit lost, make
    sure to check the Expo installation documentation: [https://docs.expo.dev/get-started/create-a-new-app/](https://docs.expo.dev/get-started/create-a-new-app/).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到终端中有任何错误，或者感觉有点迷茫，请确保查看Expo安装文档：[https://docs.expo.dev/get-started/create-a-new-app/](https://docs.expo.dev/get-started/create-a-new-app/)。
- en: 'I set up a public repository that we will use throughout this book. You can
    find it here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我设置了一个公共存储库，我们将在这本书的整个过程中使用它。你可以在这里找到它：[https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native)。
- en: On the `main` branch of this repository, you will find an app that is already
    set up. Feel free to clone or fork this repository. Remember that if you want
    to run this app on your computer, you will still need to install `node`, `watchman`,
    and `yarn`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个存储库的`main`分支上，你会找到一个已经设置好的应用。你可以随意克隆或分叉这个存储库。记住，如果你想在你电脑上运行这个应用，你仍然需要安装`node`、`watchman`和`yarn`）。
- en: App structure
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用结构
- en: Let us consider which surfaces and components we will need for a simplistic
    social media app. By “surface," I mean what would be in web development a “page."
    That is a big building block of the app, composed of many components, presented
    together on the screen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们需要哪些界面和组件来构建一个简单的社交媒体应用。在这里，“界面”指的是在网页开发中通常所说的“页面”。这是应用的一个大块，由许多组件组成，一起呈现在屏幕上。
- en: Our app will definitely need a login surface, a social media feed surface, and
    a personal profile surface. We will also add a screen containing favorited posts
    and another one where the user can add their post. We will use fake data for the
    feed and profile, and a single username and password for logging in. We won’t
    be implementing a registration flow in order to stay on the simple side of things.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用肯定需要一个登录界面、一个社交媒体信息流界面和一个个人资料界面。我们还会添加一个包含收藏帖子的屏幕，以及一个用户可以添加他们帖子的屏幕。我们将为信息流和个人资料使用假数据，并为登录使用单个用户名和密码。我们不会实现注册流程，以便保持事情简单。
- en: 'We want to concentrate on data flows, so we will use a free social media UI
    kit to get the design “out of the way," so to speak. Here’s a link to the design
    file we will use: [https://www.pixeltrue.com/free-ui-kits/social-media-app](https://www.pixeltrue.com/free-ui-kits/social-media-app).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想专注于数据流，所以我们将使用一个免费的社交媒体UI工具包来“移除”设计，换句话说。以下是我们将使用的设计文件链接：[https://www.pixeltrue.com/free-ui-kits/social-media-app](https://www.pixeltrue.com/free-ui-kits/social-media-app)。
- en: App root
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用根目录
- en: Our app will consist of at least five surfaces, which means we need to set up
    navigation to be able to move between those surfaces. The user will start off
    on the login surface. They will fill in their information and they will be redirected
    to the social media feed surface.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将至少包含五个界面，这意味着我们需要设置导航以便在那些界面之间移动。用户将从登录界面开始。他们将填写他们的信息，然后将被重定向到社交媒体信息流界面。
- en: 'Obviously, we need a way for our users to move around the app. One of the most
    used navigation libraries is called **React Navigation**. This is a library created
    especially for **React Native** applications. It provides three types of navigation
    out of the box: Drawer navigation, Tab navigation, and Stack navigation. Drawer
    navigation is when you have a little drawer on the side of your app with links
    to different places in your app. Tab navigation will display tabs (either bottom
    or top) with links to different places. Stack navigation works like a stack of
    cards—each screen is a card having the ability to redirect to any other card.
    If you would like to know more about this library, you can find a link to the
    documentation in the *Further* *reading* section.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: There are other navigation libraries out there, but React Navigation is by far
    the most popular one in the **React Native** community. It is also actively maintained
    and updated to work with the newest **React** **Native** versions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start by adding the library as a dependency to our project. To do
    that, follow these steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the library by running the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you visit the documentation website, you will notice there are different
    CLI commands for “**Expo** managed projects” and “bare **React Native** projects."
    Make sure to follow the instructions for Expo-managed projects. In our case, we
    need to run the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will need to display a login surface first, which will redirect our users
    to the main app screen. In order to do that, we will use a Stack navigator. Let’s
    add its dependencies to our project, as listed here at [https://reactnavigation.org/docs/stack-navigator/](https://reactnavigation.org/docs/stack-navigator/):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The last setup step for the stack navigator is importing the gesture handler
    library at the very top of our `App.js` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The stack navigator will be very useful to manage the login state of our app,
    but we will also need bottom tab navigation to move between the other screens
    once the user is logged in. Tab navigation feels very natural for app users. It
    is visible on all screens and makes using the app easy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'As for now, we will only need to run one command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command adds bottom tab navigation as a dependency to our project so that
    we will be able to use it later.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we needed to add so many different dependencies separately.
    This is caused by how the **React Navigation** authors decided to structure their
    library. They were certain most people will not need every kind of navigation
    in their **app**, so why should they include it in their app bundle? Every library
    user can decide which part of **React Navigation** will be useful to them and
    include only that part.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to adding a little bit of structure to our basic app. Every app
    is built with at least a couple of different surfaces, which in turn are built
    with components. Our basic social media clone app will need a login surface and
    a main surface, visible after login. Since we’re creating a social media app,
    we will go ahead and call the main surface “**Feed**”, since it will house the
    user’s newsfeed. As we progress, we will surely add more surfaces, but those two
    will be a good starting point.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Setting up surfaces
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The login surface will need an input field for the username, an input field
    for the password, and a button to log in. But for now, we will create a dummy
    component with some text.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating the login surface. You may wonder what it means to
    “create a surface." What I mean by it is that some of the components will be wrappers
    for entire surfaces of the app. Some people prefer to call them screens, and in
    web development, you would call them sites or pages. From a coding standpoint,
    they are components just like any other component. But we decide that, logically,
    they represent a bigger piece of the app, and we put them in a special folder,
    called `surfaces`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our login surface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you may notice it is, in fact, a dummy component, named `Login`, and placed
    in the `surfaces` folder.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Using that same logic, we will create a `Feed` surface, which should be displayed
    after the users log in:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have the two basic pieces of the app ready; now we need to put them together.
    This is where React Navigation comes into play.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Every React Native app needs a root file, just as every website needs an `index.html`
    file at the root. This root file is usually called `App.js`. This is the **source
    of truth** (**SOT**) for displaying anything and everything. You can think of
    it as a trunk of a tree, with many branches sprouting from it. The branches are
    different app surfaces in this metaphor. You got that, right? I’m sure you did!
    You’re smart! After all, you *are reading* *my* book.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set up the parent component to display the correct flow—first, the login
    screen, and then, the feed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can find the preceding code in this Expo Snack: [https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-3](https://snack.expo.dev/@p-syche/simplifying-state-management---chapter-2-example-3).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, you will notice we used the `useState` hook. This way,
    we easily added state to our functional `App` component. We set up our initial
    state to be `false`—users opening the app for the first time are not supposed
    to be logged in. When the user logs in, they are redirected to the second “card”
    in our stack. This “card” is the `Home` component. This is a wrapper component
    used to hold the bigger part of our app: all other surfaces besides `Login` with
    tabbed bottom navigation. As you may notice, the navigators are nested: tabbed
    navigation is inside the stack navigator. This is a common and useful practice
    in **React Native** apps. You can read more about nesting navigators in the **React
    Navigation** documentation here: [https://reactnavigation.org/docs/nesting-navigators](https://reactnavigation.org/docs/nesting-navigators).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: And there we go! We have set up an app using **Expo**. We added multiple components
    representing the future surfaces of the app. We also added and configured the
    **React** **Navigation** library. Our app is not very pretty right now, but it
    should work. You can see it on your phone through the Expo Go app, or in phone
    simulators on your computer screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'I set up a public repository on GitHub so that you, dear reader, can more easily
    follow along with the code snippets and examples presented in this book. You can
    find the repo here: [https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native](https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native).
    Feel free to clone or fork it. The `main` branch includes the basic app setup.
    Every state management library implementation is on a different branch. We will
    discuss the details as we move forward. If you decide to use this repository,
    you will notice the styles from the UI kit are implemented. We will not focus
    on styling in this book, but it is a nice addition to any app.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have done some really good work here! We started out by looking at simple
    code examples necessary to understand some ReactJS coding concepts such as component
    state and props, lifecycle methods, and hooks. It is important to understand and
    internalize the differences between state and props, and stateful and stateless
    components. A good grasp of those concepts can determine whether your app will
    run smoothly or not.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: After diving into important React concepts and examples, we moved on to actually
    setting up our app. This is a very exciting moment! We have our foundation, and
    we are ready to build a real-life social media clone app. In the next chapter,
    we will get comfortable previewing and debugging our app. We will set up all necessary
    surfaces, we will add example data, and finally, we will style the app. I can’t
    wait!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Native’s documentation—example of components with state: [https://reactnative.dev/docs/intro-react#state.](https://reactnative.dev/docs/intro-react#state)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'State versus Props:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://lucybain.com/blog/2016/react-state-vs-pros/.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/uberVU/react-guide/blob/master/props-vs-state.md](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding Lifecycle Methods to a Class—ReactJS docs:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'A full blogpost about hooks:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://pl.reactjs.org/blog/2019/02/06/react-v16.8.0.html.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'ReactJS documentation on hooks:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://reactjs.org/docs/hooks-reference.html#useeffect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'React Navigation documentation:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://reactnavigation.org/docs/getting-started/.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'React Navigation—bottom tab navigation: [https://reactnavigation.org/docs/tab-based-navigation.](https://reactnavigation.org/docs/tab-based-navigation)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React Navigation guide on authentication flow: [https://reactnavigation.org/docs/auth-flow.](https://reactnavigation.org/docs/auth-flow)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React Navigation guide on nesting navigators: [https://reactnavigation.org/docs/nesting-navigators](https://reactnavigation.org/docs/nesting-navigators).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2 – Creating a Real, Working App
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will concentrate on building a real, functioning mobile app.
    Readers will learn to plan out app features and configure the real setup of the
    Funbook app; then, they will learn how to style a React Native app so that it
    matches a given design, and how to pull in real data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18396_03.xhtml#_idTextAnchor040), [*Planning and Setting Up
    the Funbook App*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=552b05fa-8391-bf2a-d8d5-61f378c66211)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18396_04.xhtml#_idTextAnchor048), [*Styling and Populating the
    Funbook App*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=e4875054-2e9a-297d-67db-61f3786c1c05)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
