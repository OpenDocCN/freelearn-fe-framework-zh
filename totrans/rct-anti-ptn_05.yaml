- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Testing in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的测试
- en: Welcome to this immersive chapter on testing in React. In this chapter, we will
    learn the importance of software testing, understand the different types of testing
    – including unit, integration, and **end-to-end** (**E2E**) testing – and delve
    into the use of popular testing tools such as Cypress, Jest, and the React Testing
    Library. In addition, we will demystify concepts such as stubbing and mocking,
    ensuring you are well-equipped to handle complex testing scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本章节，我们将深入了解React中的测试。在本章中，我们将学习软件测试的重要性，了解不同类型的测试——包括单元测试、集成测试和**端到端**（**E2E**）测试——并深入研究Cypress、Jest和React
    Testing Library等流行测试工具的使用。此外，我们还将揭开诸如stubbing和mocking等概念的面纱，确保你能够应对复杂的测试场景。
- en: Our overarching goal is to foster a solid understanding of testing strategies
    and their implementation in React. We aim to enhance your ability to write tests
    that make your application resilient to bugs and regressions and ensure the seamless
    addition of new features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的总目标是培养对测试策略及其在React中实现的深入理解。我们旨在提高你编写测试的能力，使你的应用程序能够抵御bug和回归，并确保新功能的无缝添加。
- en: By the end of this chapter, you’ll have a comprehensive understanding of React
    testing and be ready to implement efficient testing practices in your projects.
    So, let’s get started and step into the exciting world of React testing!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将全面理解React测试，并准备好在你的项目中实施高效的测试实践。那么，让我们开始吧，进入激动人心的React测试世界！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding why we need tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们需要测试
- en: Learning about different types of tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同类型的测试
- en: Testing individual units with Jest
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest测试单个单元
- en: Learning about integration tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解集成测试
- en: Learning about E2E tests using Cypress
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用Cypress进行端到端测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch5)找到推荐的结构。
- en: Understanding why we need tests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解为什么我们需要测试
- en: 'Testing is not just an optional best practice; it’s a critical part of building
    reliable and maintainable software. Without tests, you’re essentially navigating
    the complex seas of software development without a compass. Let’s understand the
    multiple benefits that testing brings:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不仅仅是一个可选的最佳实践；它是构建可靠和可维护软件的关键部分。没有测试，你就像在没有指南针的情况下在复杂的软件开发海洋中航行。让我们了解测试带来的多重好处：
- en: '**Ensuring code correctness**: Tests serve as a seal of validation that your
    code performs exactly the way it’s supposed to. A well-written test verifies that
    your functions return the expected output for a given input, your components render
    correctly, and your application behaves as anticipated.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保代码正确性**：测试作为验证代码按预期执行的一种保证。一个编写良好的测试可以验证你的函数对于给定的输入返回预期的输出，你的组件渲染正确，以及你的应用程序表现如预期。'
- en: '**Preventing regression**: As applications grow and evolve, new code can sometimes
    unintentionally break existing functionality. This is known as a **regression**.
    Automated tests act as a safety net, catching these regressions before they reach
    production.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止回归**：随着应用程序的增长和演变，新代码有时会无意中破坏现有的功能。这被称为**回归**。自动化测试充当一个安全网，在它们达到生产环境之前捕捉这些回归。'
- en: '**Facilitating refactoring and maintenance**: Fear often surrounds the process
    of refactoring or updating legacy code. Tests alleviate this fear. They provide
    a comfort zone, assuring that if you accidentally break something during the update
    or refactoring process, your tests will catch it.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进重构和维护**：重构或更新遗留代码的过程常常伴随着恐惧。测试可以缓解这种恐惧。它们提供了一个安全区域，确保如果你在更新或重构过程中意外破坏了某些内容，你的测试将会捕捉到它。'
- en: '**Boosting confidence in code quality**: Tests elevate the confidence level
    of your team. When a suite of well-written tests backs your code, you have a quantifiable
    measure of your code’s quality. This assurance is especially beneficial when you’re
    adding new features or making changes to the system.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升代码质量信心**：测试提高了团队的信心水平。当一系列精心编写的测试支持你的代码时，你就有了一个衡量代码质量的量化指标。这种保证在添加新功能或对系统进行更改时特别有益。'
- en: '**Documentation**: Tests also serve as a form of documentation. They provide
    a clear understanding of what a function or component is supposed to do, helping
    new developers on the team understand the project’s functionality.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：测试也是一种文档形式。它们提供了对函数或组件预期功能的清晰理解，帮助新加入团队的开发者理解项目的功能。'
- en: In the subsequent sections, we’ll delve deeper into the various types of testing
    you’ll commonly use in React applications and learn how to use testing tools effectively.
    Buckle up for an engaging ride into the realm of software testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入了解你在React应用程序中常用的各种测试类型，并学习如何有效地使用测试工具。准备好开始一段引人入胜的软件测试之旅。
- en: Learning about different types of tests
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不同类型的测试
- en: Testing, in the realm of software development, isn’t a one-size-fits-all approach.
    Rather, it is categorized into different types, each serving a distinct purpose
    and offering unique insights into the functionality and reliability of the application.
    It is important to understand these categories to ensure the overall health and
    robustness of your application. Typically, you will have unit tests, integration
    tests, and E2E tests in one code base.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域，测试并不是一种一刀切的方法。相反，它被分为不同的类型，每种类型都服务于不同的目的，并为应用程序的功能和可靠性提供独特的见解。了解这些类别对于确保应用程序的整体健康和稳健性至关重要。通常，你将在一个代码库中拥有单元测试、集成测试和端到端（E2E）测试。
- en: 'We will define each type here briefly and discuss each type in detail in the
    following sections:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里简要定义每种类型，并在接下来的章节中详细讨论每种类型：
- en: '**Unit tests**: These tests focus on testing individual components or functions
    in isolation to ensure they work as expected'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试专注于在隔离状态下测试单个组件或函数，以确保它们按预期工作。'
- en: '**Integration tests**: These tests examine the interactions between different
    modules or services to verify they work together cohesively'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试检查不同模块或服务之间的交互，以验证它们是否协同工作。'
- en: '**E2E tests**: These tests test the entire application flow from start to finish,
    mimicking real-world user behavior to validate that the system works as a whole'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端（E2E）测试**：这些测试从开始到结束测试整个应用程序流程，模拟真实世界的用户行为，以验证系统作为一个整体是否正常工作。'
- en: How you structure your tests in a project also matters. For example, you should
    have a lot of unit tests that run fast and can provide detailed feedback, and
    you should have only a few E2E tests to ensure all the parts work together. This
    approach aligns with the principles of the test pyramid.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中如何组织测试结构也很重要。例如，你应该有很多运行速度快且能提供详细反馈的单元测试，同时只应该有少量端到端（E2E）测试来确保所有部分协同工作。这种方法与测试金字塔的原则相一致。
- en: 'Originally conceived by Mike Cohn, the **test pyramid** recommends having a
    larger number of unit tests compared to integration or E2E tests. The reasoning
    is simple – unit tests are quicker, simpler, and more cost-effective to maintain:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试金字塔**最初由Mike Cohn提出，建议单元测试的数量应比集成测试或端到端（E2E）测试多。理由很简单——单元测试更快、更简单，且维护成本更低：'
- en: '![Figure 5.1: The traditional test pyramid](img/B31103_05_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：传统的测试金字塔](img/B31103_05_01.jpg)'
- en: 'Figure 5.1: The traditional test pyramid'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：传统的测试金字塔
- en: However, in the modern frontend world, this model is evolving. More value is
    being placed on integration and E2E tests due to the increasing complexity and
    interactivity of frontend applications. Tools such as Cypress and Puppeteer facilitate
    writing E2E tests that emulate user behavior on the browser, while libraries such
    as the React Testing Library encourage more integration tests by making it easier
    to test component interactions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现代前端世界中，这种模式正在演变。由于前端应用程序的复杂性和交互性的增加，越来越多的价值被放在了集成和端到端（E2E）测试上。像Cypress和Puppeteer这样的工具使得编写模拟浏览器中用户行为的端到端（E2E）测试变得容易，而像React
    Testing Library这样的库通过简化组件交互测试，鼓励更多的集成测试。
- en: New types of tests are also introduced in frontend applications. The visual
    regression tests is one of them. **Visual regression testing** is a method of
    testing in which the visual aspects of a web application are captured and compared
    to previous states or versions. This type of testing is particularly useful in
    catching unintended visual bugs and changes in a user interface that may be introduced
    during development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端应用中也引入了新的测试类型。视觉回归测试就是其中之一。**视觉回归测试**是一种测试方法，它捕捉并比较Web应用的视觉方面与之前的状态或版本。这种类型的测试在捕捉开发过程中可能引入的不期望的视觉错误和用户界面变化方面特别有用。
- en: Visual regression tests work by taking screenshots (or snapshots) of web pages
    or components at different stages, and then comparing these screenshots pixel
    by pixel to identify any visual differences. When a difference is detected, it
    is flagged for review. The review can then determine if the change is expected
    (due to a new feature or design update) or if it’s an unintended regression that
    needs to be fixed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉回归测试通过在不同阶段对网页或组件进行截图（或快照），然后逐像素比较这些截图以识别任何视觉差异来工作。当检测到差异时，它会标记为待审查。然后审查可以确定变化是否是预期的（由于新功能或设计更新）或者是否是不期望的回归，需要修复。
- en: In frontend testing, **static checks** involve analyzing code without executing
    it to identify errors and ensure coding standards. This includes checking for
    syntax errors, enforcing coding style through linting, verifying correct data
    types with type checking, analyzing code complexity, examining dependencies, and
    identifying security vulnerabilities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端测试中，**静态检查**涉及在不执行代码的情况下分析代码以识别错误并确保编码标准。这包括检查语法错误、通过linting强制执行编码风格、通过类型检查验证正确的数据类型、分析代码复杂性、检查依赖关系以及识别安全漏洞。
- en: 'The exact shape of your test pyramid might vary depending on your application’s
    needs, but the critical takeaway is to have a balanced testing strategy that provides
    quick and useful feedback at different levels of your application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试金字塔的确切形状可能取决于你的应用需求，但关键是要有一个平衡的测试策略，在不同的应用层级提供快速和有用的反馈：
- en: '![Figure 5.2: The enhanced test pyramid](img/B31103_05_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：增强的测试金字塔](img/B31103_05_02.jpg)'
- en: 'Figure 5.2: The enhanced test pyramid'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：增强的测试金字塔
- en: The next sections in this chapter will give you hands-on experience in writing
    these types of tests for a React application, ensuring that you are well-equipped
    to bring these concepts into your projects. Let’s forge ahead!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来的部分将为你提供编写React应用这类测试的实践经验，确保你能够将这些概念应用到你的项目中。让我们继续前进！
- en: Testing individual units with Jest
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest 测试单个单元
- en: Unit tests are the smallest and most foundational part of the testing pyramid,
    verifying the behavior of individual units of code in isolation, such as functions,
    methods, or components. These tests are quick to write and execute, offering immediate
    feedback to developers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是测试金字塔中最小和最基础的部分，它验证代码各个单元的行为，例如函数、方法或组件。这些测试编写和执行速度快，为开发者提供即时反馈。
- en: We’ll use Jest to write unit tests and integration tests in this book. Jest
    is a comprehensive JavaScript testing framework built by Facebook, with a strong
    focus on simplicity. It’s feature-rich and supports asynchronous testing, mocking,
    and snapshot testing, making it a great choice for React applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 Jest 编写单元测试和集成测试。Jest 是由Facebook构建的全面的JavaScript测试框架，它注重简单性。它功能丰富，支持异步测试、模拟和快照测试，是React应用的绝佳选择。
- en: Writing your first test
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写你的第一个测试
- en: 'Let’s write a simple test. Say you have an `add` function in a file called
    `math.ts`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的测试。假设你有一个名为 `math.ts` 的文件中的 `add` 函数：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To test this function, you must create a `math.test.ts` file in the same directory:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个函数，你必须在同一目录下创建一个 `math.test.ts` 文件：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You’ve now written your first test! The `test` function takes two arguments:
    a string description of the test and a callback function that implements the test.
    `expect` is a Jest function that takes the actual value, and `toBe` is a matcher
    function that compares the actual value with the expected value.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经编写了你的第一个测试！`test` 函数接受两个参数：一个测试的字符串描述和一个实现测试的回调函数。`expect` 是一个 Jest 函数，它接受实际值，而
    `toBe` 是一个匹配函数，它比较实际值与预期值。
- en: 'Another way of writing a test is to use the `it` function. In Jest, `test`
    and `it` are actually the same function and can be used interchangeably; the names
    just come from different testing conventions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写测试的方法是使用`it`函数。在Jest中，`test`和`it`实际上是同一个函数，可以互换使用；名称只是来自不同的测试约定：
- en: '`test`: This is a common name for a test function in many testing frameworks
    and languages. If you come from a background of using other testing libraries,
    you might find `test` to be more intuitive or familiar.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：这是许多测试框架和语言中测试函数的常见名称。如果你来自使用其他测试库的背景，你可能会发现`test`更直观或熟悉。'
- en: '`it`: This comes from **behavior-driven development** (**BDD**) style frameworks
    such as Jasmine or Mocha.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it`：这来自像Jasmine或Mocha这样的**行为驱动开发**（**BDD**）风格的框架。'
- en: The idea of using `it` is to make the tests read more like sentences. For example,
    `it("adds 1 + 2 to equal 3", () => expect(1 + 2).toBe(3))` reads like “it adds
    1 + 2 to equal 3.”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`it`的想法是使测试读起来更像句子。例如，`it("adds 1 + 2 to equal 3", () => expect(1 + 2).toBe(3))`读起来像是“它将1
    + 2相加等于3。”
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: BDD is a software development approach that emphasizes collaboration between
    developers, QA, and non-technical participants in a software project. It highlights
    the need to start with a clear understanding of desired behavior before development
    starts, thereby aligning development with business needs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是一种软件开发方法，强调开发人员、QA和非技术参与者在软件项目中的协作。它强调了在开发开始之前，对期望行为有明确理解的需要，从而将开发与业务需求对齐。
- en: BDD encourages expressing software behaviors in plain, descriptive language
    that can be read and understood by all stakeholders. It leverages executable specifications,
    often written in a language such as Gherkin, that guide development and serve
    as acceptance criteria.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: BDD鼓励用所有利益相关者都能阅读和理解的简单、描述性语言表达软件行为。它利用可执行的规范，通常用Gherkin等语言编写，这些规范指导开发并作为验收标准。
- en: BDD aims to reduce misunderstandings by encouraging collaboration, making the
    behavior of a system explicit and understandable by all, and ensuring that the
    software developed truly meets the needs of the business.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: BDD旨在通过鼓励协作、使系统的行为对所有人明确且可理解，并确保开发的软件真正满足业务需求，来减少误解。
- en: It’s a matter of team preference and what aligns best with your team’s testing
    philosophy – some teams prefer the sentence-like structure that it provides as
    it often makes it clearer what a test is trying to verify, especially to non-developers,
    while others might find `test` to be more straightforward and less verbose. We’re
    going to write tests that follow the BDD style in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于团队偏好以及什么最适合你团队的测试哲学——一些团队可能更喜欢它提供的句子结构，因为它通常可以使测试试图验证的内容更清晰，尤其是对非开发者来说，而另一些团队可能认为`test`更直接且更简洁。我们将在这本书中编写遵循BDD风格的测试。
- en: Grouping tests
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组测试
- en: Grouping related tests in one block significantly improves the readability of
    your test files. By clearly delineating different areas of functionality, a block
    allows anyone reading the tests to understand the context of the test suite at
    a glance. This enhanced understanding is crucial for comprehension of what functionality
    is being verified. In a large code base, with numerous tests, this organization
    can greatly decrease the cognitive load required to understand how different parts
    of the application are tested.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关的测试分组在一个块中可以显著提高你的测试文件的可读性。通过清晰地划分不同的功能区域，一个块可以让阅读测试的人一眼就能理解测试套件的上下文。这种增强的理解对于理解正在验证的功能至关重要。在一个大型代码库中，有众多测试的情况下，这种组织可以大大减少理解应用程序不同部分如何被测试所需的认知负荷。
- en: 'In Jest, we can use the `describe` function to group related tests into one
    unit. For instance, consider a function, `add`, that includes multiple cases:
    the addition of negative numbers, the combination of one negative and one positive
    number, decimal sums, or even computations involving imaginary numbers. It would
    be prudent to gather all these distinct cases under one `describe` block, like
    so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jest中，我们可以使用`describe`函数将相关的测试分组到一个单元中。例如，考虑一个包含多个情况的函数`add`：负数的加法、一个负数和一个正数的组合、小数的总和，甚至涉及虚数的计算。明智的做法是将所有这些不同的案例收集在一个`describe`块下，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `describe` function is used to group related tests – in this case, tests
    for some math functions. Within this group, there are two `it` functions, each
    representing a single test. The first test checks if the `add` function correctly
    adds two positive numbers, and the second test checks if the `add` function correctly
    adds two negative numbers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 函数用于分组相关的测试——在这个例子中，是对一些数学函数的测试。在这个组内，有两个 `it` 函数，每个代表一个单独的测试。第一个测试检查
    `add` 函数是否正确地加上了两个正数，第二个测试检查 `add` 函数是否正确地加上了两个负数。'
- en: 'With Jest, you can nest `describe` blocks to organize your tests more systematically.
    For example, suppose we’re expanding our suite to include subtraction, multiplication,
    and division in our calculator functionality. We can structure our test suite
    in the following manner:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jest，你可以嵌套 `describe` 块来更系统地组织你的测试。例如，假设我们正在扩展我们的测试套件以包括计算器的减法、乘法和除法功能。我们可以按照以下方式构建我们的测试套件：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code snippet, we have a top-level `describe` block labeled `calculator`.
    Within this block, we have nested `describe` blocks for each mathematical operation.
    For instance, in the `addition` block, we have individual `it` tests for different
    scenarios of adding numbers. Similarly, we start a new describe block for `subtraction`.
    This nested structure makes our test suite more organized, readable, and easier
    to navigate, particularly when dealing with a large number of tests or complex
    scenarios.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们有一个标记为 `calculator` 的顶级 `describe` 块。在这个块内部，我们为每个数学运算嵌套了 `describe`
    块。例如，在 `addition` 块中，我们有针对加法不同场景的单独 `it` 测试。同样，我们为 `subtraction` 开始一个新的 `describe`
    块。这种嵌套结构使我们的测试套件更加有序、可读，并且更容易导航，尤其是在处理大量测试或复杂场景时。
- en: Testing React components
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 React 组件
- en: As we mentioned previously, Jest is a great tool for testing different types
    of applications, and it supports React applications out of the box. Although it’s
    possible to use Jest alone, it would be a bit more cumbersome and verbose than
    using a dedicated library such as the **React** **Testing Library**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Jest 是一个出色的测试不同类型应用程序的工具，并且它默认支持 React 应用程序。尽管可以单独使用 Jest，但与使用如 **React**
    **Testing Library** 这样的专用库相比，它可能会稍微繁琐和冗长一些。
- en: The React Testing Library is a lightweight yet powerful library for testing
    React components. It’s built on top of the popular JavaScript testing framework,
    Jest, and adds specific utilities for working with React components. The philosophy
    of the React Testing Library is to encourage writing tests that closely resemble
    how your software is used. It encourages you to interact with your app just like
    how users would, meaning you test the functionality and not the implementation
    details. This approach leads to more robust and maintainable tests that will give
    you confidence that your app will work in production.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: React Testing Library 是一个轻量级但功能强大的库，用于测试 React 组件。它建立在流行的 JavaScript 测试框架 Jest
    之上，并为处理 React 组件添加了特定的实用工具。React Testing Library 的哲学是鼓励编写与你的软件使用方式相似的测试。它鼓励你像用户一样与你的应用程序交互，这意味着你测试的是功能而不是实现细节。这种方法导致更健壮和可维护的测试，这将让你有信心你的应用程序在生产环境中能够正常工作。
- en: In the code provided in this book, the project has already been set up for you
    with the React Testing Library. Simply clone the code mentioned in the *Technical
    requirements* section into your local directory and you are good to go.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书提供的代码中，项目已经为你设置好了 React Testing Library。只需将 *技术要求* 部分中提到的代码克隆到你的本地目录中，你就可以开始了。
- en: 'All right – let’s start with a simple React component to see how we can test
    it with the React Testing Library. The `Section` component is a presentational
    component that accepts two props, `heading` and `content`, and renders the props
    in an `article` tag:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——让我们从一个简单的 React 组件开始，看看我们如何使用 React Testing Library 来测试它。`Section` 组件是一个展示组件，它接受两个属性
    `heading` 和 `content`，并在 `article` 标签中渲染这些属性：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test the component, we can create a new file next to `Section.tsx`, which
    we will call `Section.test.tsx`. This is where our test code will live. Then,
    we’ll use the React Testing Library to check the `Section` component:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试组件，我们可以在 `Section.tsx` 旁边创建一个新文件，我们将称之为 `Section.test.tsx`。这是我们的测试代码将存在的地方。然后，我们将使用
    React Testing Library 来检查 `Section` 组件：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This test code makes use of `@testing-library/react` to verify that the `Section`
    component behaves as expected – the text `@testing-library/react` is used to render
    the `Section` component with specific props: a heading of **Basic** and content
    of **Hello world**.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试代码使用了`@testing-library/react`来验证`Section`组件的行为是否符合预期——`@testing-library/react`文本用于使用特定的属性渲染`Section`组件：标题为**基本**，内容为**Hello
    world**。
- en: Following the rendering, the `screen.getByText` function is used to query the
    DOM (which represents the rendered output of the `Section` component) for elements
    containing specific text.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染完成后，使用`screen.getByText`函数查询DOM（代表`Section`组件的渲染输出）中包含特定文本的元素。
- en: Next, `expect` and `toBeInTheDocument` are then used to make assertions about
    the state of these elements. Specifically, the test is asserting that there is
    an element with the `Section` component has correctly rendered its heading and
    content props.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`expect`和`toBeInTheDocument`来对这些元素的状态进行断言。具体来说，测试断言`Section`组件正确渲染了其标题和内容属性。
- en: This straightforward unit test for a React component serves as a useful starting
    point. However, in complex real-world projects, we often encounter scenarios where
    multiple components need to interact harmoniously. For instance, consider a checkout
    page that integrates an address collection component, a payment component, and
    a price calculation logic component.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个针对React组件的简单单元测试是一个有用的起点。然而，在复杂的实际项目中，我们经常遇到多个组件需要和谐交互的场景。例如，考虑一个集成了地址收集组件、支付组件和价格计算逻辑组件的结账页面。
- en: 'To confidently ensure the seamless interaction of these distinct components,
    we must employ a more comprehensive testing strategy: integration tests.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自信地确保这些不同组件的无缝交互，我们必须采用更全面的测试策略：集成测试。
- en: Learning about integration tests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解集成测试
- en: Integration tests are positioned above unit tests in the pyramid, validating
    the interactions between multiple units of code. These could be component interactions
    or interactions between the client side and server side. Integration tests aim
    to identify issues that may arise when different parts of the system are combined.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试位于金字塔的单元测试之上，验证多个代码单元之间的交互。这些可能是组件之间的交互，或者是客户端和服务器之间的交互。集成测试旨在识别当系统的不同部分组合时可能出现的潜在问题。
- en: One such scenario involves testing the interaction between two separate components
    to verify that they function correctly together – this is integration testing
    at a UI component level. Additionally, if you’re looking to ensure smooth collaboration
    between your frontend code and backend services, the tests you write for this
    purpose would also be classified as integration tests, which verify that different
    layers of your application are working correctly together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个场景涉及测试两个独立组件之间的交互，以验证它们是否能够正确协同工作——这是在UI组件级别的集成测试。此外，如果您想确保前端代码和后端服务之间的协作顺畅，为此编写的测试也会被归类为集成测试，这些测试验证了应用程序的不同层是否能够正确协同工作。
- en: 'Let’s have a look at an example of an integration test for a React component.
    In *Figure 5**.3*, there is a **Terms and Conditions** section, which includes
    a long text about the legal information, and a checkbox for the user to consent.
    There is also a **Next** button, which is disabled by default. However, once the
    user selects **Accept the Terms and Conditions**, the button will be enabled,
    and the user can proceed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个React组件的集成测试示例。在*图5*.3中，有一个**条款和条件**部分，其中包含关于法律信息的长文本，以及用户同意的复选框。还有一个**下一步**按钮，默认情况下是禁用的。然而，一旦用户选择**接受条款和条件**，按钮将被启用，用户可以继续操作：
- en: '![Figure 5.3: The Terms and Conditions component](img/B31103_05_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：条款和条件组件](img/B31103_05_03.jpg)'
- en: 'Figure 5.3: The Terms and Conditions component'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：条款和条件组件
- en: 'This integration test can be described using the following code snippet – we
    are not testing the **Checkbox** and **Next** buttons separately, but verifying
    the interaction between them:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集成测试可以用以下代码片段来描述——我们不是单独测试**复选框**和**下一步**按钮，而是验证它们之间的交互：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `describe` function is used to group all tests associated with the `TermsAndConditions`
    component, forming a so-called test suite. Within this suite, we have a single
    test case denoted by the it function. The description of this test is **renders
    learn react link**, which appears to be a misnomer considering the operations
    carried out in this test. A more suitable description might be **Enables the next
    button upon accepting terms** **and conditions**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`describe`函数来分组与`TermsAndConditions`组件相关的所有测试，形成一个所谓的测试套件。在这个套件中，我们有一个由`it`函数表示的单个测试用例。这个测试的描述是**渲染学习React链接**，考虑到这个测试中执行的操作，这似乎是一个误称。一个更合适的描述可能是**在接受条款和条件后启用下一步按钮**
    **和条件**。
- en: Initially, the `render` function is invoked to display the `TermsAndConditions`
    component. This function produces a series of output, or render results, that
    can be queried in various ways to assess whether the component behaves as expected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，调用`render`函数来显示`TermsAndConditions`组件。这个函数产生一系列输出，或渲染结果，可以通过各种方式查询以评估组件是否按预期工作。
- en: We then try to find a button by its text, `screen.getByText` function – which
    returns the element found on the page. At this point, we expect this button to
    be disabled, so we confirm this expectation by calling `expect(button).toBeDisabled()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试通过文本找到按钮，使用`screen.getByText`函数——它返回页面上的元素。在这个时候，我们预计这个按钮将被禁用，因此我们通过调用`expect(button).toBeDisabled()`来确认这个预期。
- en: Next, we look for the checkbox using the `screen.getByRole` function. This function
    allows us to find the checkbox based on its role, which is `checkbox`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`screen.getByRole`函数查找复选框。这个函数允许我们根据其角色找到复选框，其角色是`checkbox`。
- en: The user interaction of ticking the checkbox is simulated using the `userEvent.click`
    function, which is wrapped in React’s `act` function. The `act` function ensures
    that all updates related to these actions are processed and applied before moving
    forward; this way, our assertions will examine the component in its updated state.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`userEvent.click`函数模拟用户点击复选框的交互，该函数被React的`act`函数包裹。`act`函数确保在继续之前处理并应用与这些操作相关的所有更新；这样，我们的断言将检查组件的更新状态。
- en: Finally, we verify that the button is enabled after the checkbox has been clicked.
    This is done using `expect(button).toBeEnabled()`. If this statement holds true,
    we know that our component behaves as intended – that is, disabling the **Next**
    button until the user accepts the terms and conditions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们验证在点击复选框之后按钮是否被启用。这是通过使用`expect(button).toBeEnabled()`来完成的。如果这个语句为真，我们知道我们的组件表现如预期——也就是说，在用户接受条款和条件之前禁用**下一步**按钮。
- en: 'Now, let’s look at how the code is written. The `TermsAndConditions` component
    under test is composed of a few components – `heading`, `LegalContent`, and `UserConsent`.
    Plus, `UserConsent` itself is composed of `CheckBox` and `Button`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码是如何编写的。正在测试的`TermsAndConditions`组件由几个组件组成——`heading`、`LegalContent`和`UserConsent`。此外，`UserConsent`本身由`CheckBox`和`Button`组成：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The sole component that gets exported in this code is `TermsAndConditions`,
    which is the primary subject of our testing strategy. In our tests, we employ
    `userEvent.click` to initiate a click event within the realm of a `jsdom` environment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，唯一被导出的组件是`TermsAndConditions`，这是我们测试策略的主要主题。在我们的测试中，我们使用`userEvent.click`在`jsdom`环境中引发点击事件。
- en: Essentially, our focus is not on testing the isolated React components (such
    as `CheckBox` and `Button`; they should have their own unit tests), but rather
    on the DOM elements and their interactions. It’s important to clarify that we’re
    not invoking a full-fledged browser here, but rather a headless `jsdom` variant
    that exists in memory. Yet, despite the simulated environment of these integration
    tests, they still provide us with the confidence that the click event and button
    enablement are functioning as expected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的重点不是测试独立的React组件（如`CheckBox`和`Button`；它们应该有自己的单元测试），而是DOM元素及其交互。重要的是要澄清，我们在这里没有调用一个完整的浏览器，而是一个存在于内存中的无头`jsdom`变体。尽管这些集成测试是在模拟环境中进行的，但它们仍然为我们提供了信心，即点击事件和按钮启用是按预期工作的。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**jsdom** is a JavaScript-based headless browser that can be used to create
    a realistic testing environment that simulates a web browser’s environment. It
    is an implementation of web standards such as HTML, DOM, CSS, and others, entirely
    in JavaScript.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**jsdom**是一个基于JavaScript的无头浏览器，可以用来创建一个模拟浏览器环境的真实测试环境。它是在JavaScript中实现HTML、DOM、CSS等网络标准的实现。'
- en: When we run JavaScript that manipulates the DOM in a browser, the browser provides
    the DOM. However, when we are running tests using a testing framework such as
    Jest in a Node.js environment, there isn’t a DOM by default. This is where `jsdom`
    comes into play. `jsdom` provides a virtual DOM, thereby allowing our tests to
    run as though they were in a browser-like environment, even when they’re running
    in Node.js.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行操作DOM的JavaScript时，浏览器提供DOM。然而，当我们使用Jest等测试框架在Node.js环境中运行测试时，默认情况下并没有DOM。这就是`jsdom`发挥作用的地方。`jsdom`提供了一个虚拟DOM，从而使我们的测试能够在类似浏览器的环境中运行，即使它们在Node.js中运行。
- en: Why do we need `jsdom`? In modern frontend development, particularly with frameworks
    such as React, Angular, and Vue, our JavaScript code often interacts directly
    with the DOM. For our tests to be useful, they need to be able to simulate this
    interaction. `jsdom` allows us to do this without needing to open a browser window.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要`jsdom`？在现代前端开发中，尤其是在使用React、Angular和Vue等框架时，我们的JavaScript代码通常会直接与DOM交互。为了使我们的测试变得有用，它们需要能够模拟这种交互。`jsdom`允许我们做到这一点，而无需打开浏览器窗口。
- en: In integration tests, we concentrate on the interactions between various modules.
    However, even if these interactions function as expected, there’s still a possibility
    that the broader system may break. User journeys often involve multiple steps,
    so it’s essential to have a process that seamlessly connects these steps to ensure
    the software continues to work reliably.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，我们关注的是各个模块之间的交互。然而，即使这些交互按预期工作，仍然有可能整个系统会崩溃。用户旅程通常涉及多个步骤，因此确保这些步骤无缝连接的过程对于软件持续可靠地工作至关重要。
- en: Learning about E2E tests using Cypress
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用Cypress进行端到端测试
- en: E2E tests are at the top of the test pyramid. E2E tests simulate real user flows
    and interactions, testing the system as a whole. These tests help ensure that
    all parts of the application work together as expected, from the user interface
    to the backend systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试位于测试金字塔的顶部。端到端测试模拟真实用户流程和交互，测试整个系统。这些测试有助于确保应用程序的所有部分按预期协同工作，从用户界面到后端系统。
- en: We’re going to use Cypress as the E2E test framework in this book. **Cypress**
    is a powerful tool for E2E testing of modern web applications. Its unique approach
    sets it apart from many other testing tools – instead of using Selenium, a common
    engine for many testing systems, Cypress operates directly on the actual browser,
    resulting in more reliable tests and a superior debugging experience.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中使用Cypress作为端到端测试框架。**Cypress**是现代Web应用端到端测试的强大工具。其独特的方法使其与其他许多测试工具区别开来
    – 与使用Selenium（许多测试系统的常见引擎）不同，Cypress直接在真实浏览器上操作，从而产生更可靠的测试和更好的调试体验。
- en: Installing Cypress
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Cypress
- en: 'You can either install Cypress into an existing project (like what we’re doing
    in this book) or install it in another folder other than your project. Cypress
    has been added as a project dependency in the code base in GitHub (provided in
    the *Technical requirements* section), so you only need to run `npm install` in
    the project root (refer to the official documentation for more information: [https://docs.cypress.io/guides/getting-started/installing-cypress](https://docs.cypress.io/guides/getting-started/installing-cypress)).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Cypress安装到现有项目（就像我们在本书中所做的那样）或安装到项目以外的另一个文件夹中。Cypress已被添加到GitHub代码库中的项目依赖项（在*技术要求*部分提供），因此您只需在项目根目录中运行`npm
    install`（有关更多信息，请参阅官方文档：[https://docs.cypress.io/guides/getting-started/installing-cypress](https://docs.cypress.io/guides/getting-started/installing-cypress))。
- en: 'Once you have installed the package, simply run `npx cypress open` to launch
    the configuration wizard:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，只需运行`npx cypress open`即可启动配置向导：
- en: '![Figure 5.4: The Cypress wizard – choosing a test type](img/B31103_05_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4：Cypress向导 – 选择测试类型](img/B31103_05_04.jpg)'
- en: 'Figure 5.4: The Cypress wizard – choosing a test type'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：Cypress向导 – 选择测试类型
- en: 'Follow the wizard to configure **E2E Testing**, and choose **Chrome** as the
    browser for running all the tests. After that, choose **Create** **new spec**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按照向导配置**端到端测试**，并将**Chrome**作为运行所有测试的浏览器。之后，选择**创建****新的spec**：
- en: '![Figure 5.5: The Cypress wizard – creating a spec from a template](img/B31103_05_05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5：Cypress向导 – 从模板创建spec](img/B31103_05_05.jpg)'
- en: 'Figure 5.5: The Cypress wizard – creating a spec from a template'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：Cypress向导 – 从模板创建spec
- en: 'Cypress will create a folder with all the necessary files for us:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress将为我们创建一个包含所有必要文件的文件夹：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s break his structure down:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下它的结构：
- en: At the top level, we have the `cypress` directory, which is the root directory
    for all the Cypress-related files.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶级目录中，我们有`cypress`目录，这是所有与Cypress相关的文件的根目录。
- en: The `downloads` directory is usually where files downloaded during Cypress tests
    would be stored; we’re not going to use it here as we don’t have anything to save
    at this stage.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`downloads`目录通常是Cypress测试期间下载的文件存储的地方；我们在这里不会使用它，因为我们在这个阶段没有要保存的内容。'
- en: The `e2e` directory is where E2E test files are located. In this case, it contains
    `quote-of-the-day.spec.cy.js` (generated from the Cypress wizard), a Cypress test
    file for testing the quote-of-the-day feature of an application.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e`目录是端到端测试文件所在的位置。在这个例子中，它包含`quote-of-the-day.spec.cy.js`（由Cypress向导生成），这是一个用于测试应用程序每日引言功能的Cypress测试文件。'
- en: The `fixtures` directory is a place to put external static data that your tests
    will use. We can put some static files that can be used in our tests (for example,
    if our tests need some JSON data for mocking the network’s response).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixtures`目录是一个放置外部静态数据的地方，你的测试将使用这些数据。我们可以放置一些可以在测试中使用的静态文件（例如，如果我们的测试需要一些JSON数据来模拟网络的响应）。'
- en: The `support` directory houses Cypress commands and support files, which we
    will not touch either.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`support`目录包含Cypress命令和支持文件，我们也不会触摸它。'
- en: Once we have the folder structure set up, we can proceed and write our first
    test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了文件夹结构，我们就可以继续编写我们的第一个测试。
- en: Running our first E2E test
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的第一个端到端测试
- en: Let’s modify the `quote-of-the-day.spec.cy.js` file to make it access a remote
    website. Cypress will actively watch the files under the `cypress/e2e/` folder,
    and whenever the content changes, it will rerun the test.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`quote-of-the-day.spec.cy.js`文件，使其访问远程网站。Cypress将积极监视`cypress/e2e/`文件夹下的文件，并且每当内容发生变化时，它将重新运行测试。
- en: 'Make sure you have launched cypress in a terminal window (either Terminal for
    MacOS/Linux or Windows Terminal) with `npx` `cypress open`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在终端窗口（无论是MacOS/Linux的Terminal还是Windows Terminal）中启动了cypress，使用`npx cypress
    open`：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code snippet, `describe` is used to declare a test suite – in this case,
    for the quote of the day feature. Within this suite, there’s a single test case
    defined by it, labeled `display the heading`. The purpose of this test case is
    to visit a web page – in this instance, [https://icodeit-juntao.github.io/quote-of-the-day/](https://icodeit-juntao.github.io/quote-of-the-day/)
    – and this web page returns a random quote each time the user refreshes the page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`describe`用于声明一个测试套件——在这个例子中，是为每日引言功能。在这个套件中，定义了一个由它指定的单个测试用例，标记为`显示标题`。这个测试用例的目的是访问一个网页——在这个例子中，[https://icodeit-juntao.github.io/quote-of-the-day/](https://icodeit-juntao.github.io/quote-of-the-day/)——并且每次用户刷新页面时，这个网页都会返回一个随机引言。
- en: 'However, it’s important to note that this test case doesn’t perform any actual
    tests or assertions yet. It merely navigates to the page. To make this a meaningful
    test, you would typically add assertions to check the state of specific elements
    on the page, such as the heading or a quote displayed:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，这个测试用例目前还没有执行任何实际的测试或断言。它只是导航到页面。为了使这个测试有意义，你通常会添加断言来检查页面特定元素的状态，例如标题或显示的引言：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code snippet is a meaningful test now. After visiting `https://icodeit-juntao.github.io/quote-of-the-day/`,
    this test now contains an additional check with the `cy.contains()` method. The
    `cy.contains()` method is used to search for and get a DOM element that contains
    the specified text – in this case, **Quote of the day**. This method will get
    the first element it finds that contains the text, and it will fail the test if
    no such element is found.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段现在是一个有意义的测试。在访问`https://icodeit-juntao.github.io/quote-of-the-day/`之后，这个测试现在包含了一个使用`cy.contains()`方法的额外检查。`cy.contains()`方法用于搜索和获取包含指定文本的DOM元素——在这个例子中，是**每日引言**。这个方法将获取它找到的第一个包含文本的元素，如果找不到这样的元素，它将使测试失败。
- en: 'If the test can pass, we’re confident that the URL is accessible to the public,
    and the page doesn’t throw any exceptions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试可以通过，我们就相信该URL对公众是可访问的，并且页面不会抛出任何异常：
- en: '![Figure 5.6: Running E2E tests inside Cypress Test Runner](img/B31103_05_06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6：在Cypress测试运行器中运行端到端测试](img/B31103_05_06.jpg)'
- en: 'Figure 5.6: Running E2E tests inside Cypress Test Runner'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：在Cypress测试运行器中运行端到端测试
- en: Note that in *Figure 5**.6*, on the right-hand side of the screen, you can see
    what is displayed on the real browser, while on the left-hand side, you can see
    the test cases and steps. You can even use the mouse to hover on a step to see
    the page snapshot at that point.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在*图5**.6*的右侧屏幕上，你可以看到真实浏览器上显示的内容，而在左侧，你可以看到测试用例和步骤。你甚至可以使用鼠标悬停在某个步骤上，以查看该点的页面快照。
- en: 'In addition, we can add another test case to verify that a quote container
    is present on the page; that is the most important part of the quote of the day
    application – to make sure a quote shows up:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以添加另一个测试用例来验证页面上是否存在引用容器；这是每日引用应用最重要的部分——确保引用能够显示：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this test, the `cy.get()` method is used to retrieve a DOM element by its
    `data-testid` attribute. This attribute is typically used for testing, allowing
    you to select elements without the need to worry about their CSS selectors or
    contents, which might change over time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，使用`cy.get()`方法通过其`data-testid`属性检索DOM元素。这个属性通常用于测试，允许你选择元素而无需担心它们的CSS选择器或内容，这些可能会随时间改变。
- en: The element that’s being selected in this test has a `data-testid` attribute
    of `quote-container`. Once the element is retrieved, the `should()` method is
    invoked to assert something about the state of that element. In this case, it
    checks that the length of the element (that is, the number of matching elements)
    is `1`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，被选择的元素具有`data-testid`属性为`quote-container`。一旦检索到元素，就会调用`should()`方法来断言有关该元素状态的内容。在这种情况下，它检查元素的长度（即匹配元素的数量）为`1`。
- en: So, in this test, after navigating to the web page, it looks for an element
    with the `data-testid` attribute of `quote-container`, and checks that exactly
    one such element exists. If it does, the test will pass; if not (either because
    there are no matching elements or more than one), the test will fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个测试中，在导航到网页后，它会寻找具有`data-testid`属性为`quote-container`的元素，并检查是否存在恰好一个这样的元素。如果存在，测试将通过；如果不（无论是由于没有匹配的元素还是多于一个），测试将失败。
- en: 'That is awesome, but there is a problem here: what if the page isn’t blank
    and the heading is rendered correctly, but the actual content of a quote doesn’t
    show up for some reason? Alternatively, what if the quotes are visible but we’re
    uncertain about the expected quotes when we’re writing the tests? Consider, for
    instance, the [https://icodeit-juntao.github.io/quote-of-the-day/](https://icodeit-juntao.github.io/quote-of-the-day/)
    website, which generates random quotes each time it’s accessed. Different users
    may encounter different quotes at various times. To address these variables, we
    need a structured method for testing applications with such unpredictable behavior.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但这里有一个问题：如果页面不是空的，标题渲染正确，但引用的实际内容由于某种原因没有显示出来怎么办？或者，如果我们编写测试时不确定预期的引用是什么，引用是可见的怎么办？以[https://icodeit-juntao.github.io/quote-of-the-day/](https://icodeit-juntao.github.io/quote-of-the-day/)网站为例，每次访问都会生成随机的引用。不同的用户可能在不同的时间遇到不同的引用。为了解决这些变量，我们需要一种结构化的方法来测试具有这种不可预测行为的应用程序。
- en: Intercepting the network request
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 截获网络请求
- en: In some cases, we don’t want to send actual network requests for the UI to work,
    while in other cases, it’s not practical to rely on the response directly. We
    want to verify whether the quote is rendered correctly by checking the content,
    but as the quoted content is generated randomly, we cannot predict it before we
    make the network request. This means we need a mechanism to pin down the response,
    but we would also like to send the request.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不想发送实际的网络请求以使UI工作，而在其他情况下，直接依赖响应并不实际。我们希望通过检查内容来验证引用是否正确渲染，但由于引用内容是随机生成的，我们无法在网络请求之前预测它。这意味着我们需要一种机制来锁定响应，但我们又希望发送请求。
- en: One way to achieve that is to intercept the network request that’s sent to the
    endpoint and return some fixed data. In Cypress, we can do that through the `cy.intercept`
    API.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一种方法是通过截获发送到端点的网络请求并返回一些固定数据。在Cypress中，我们可以通过`cy.intercept` API来实现。
- en: 'Firstly, we can define a data array in the `quote-of-the-day.spec.cy.js` file.
    It’s a normal JavaScript array that contains the data we expect to return from
    the server side:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在`quote-of-the-day.spec.cy.js`文件中定义一个数据数组。它是一个普通的JavaScript数组，包含我们期望从服务器端返回的数据：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the testing code, we aim to capture any network requests that are sent to
    URLs beginning with `https://api.quotable.io/quotes/random`. Whenever the request
    is sent from React, Cypress will cancel the request and return the `quotes` array
    instead; this means the test doesn’t depend on whether the remote service is working
    or not. That way, our test is more stable. We can see the code here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码中，我们的目标是捕获发送到以 `https://api.quotable.io/quotes/random` 开头的 URL 的任何网络请求。每当请求从
    React 发送时，Cypress 将取消请求并返回 `quotes` 数组；这意味着测试不依赖于远程服务是否工作。这样，我们的测试就更加稳定。我们可以在以下代码中看到：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `cy.intercept` function is being used to stub the HTTP GET request to the
    quote API. When such a request is detected, rather than letting the request go
    through to the actual API, Cypress will respond with a predefined HTTP response.
    This response has a status code of 200, indicating success, and the body of the
    response is set to be our predefined quotes data. This technique allows us to
    control the data being returned, making our test more deterministic and isolated
    from any potential instability or variation in the actual API.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`cy.intercept` 函数正在被用来模拟对报价 API 的 HTTP GET 请求。当检测到此类请求时，而不是让请求通过到实际 API，Cypress
    将以预定义的 HTTP 响应来响应。此响应的状态码为 200，表示成功，响应体被设置为我们的预定义报价数据。这种技术使我们能够控制返回的数据，使我们的测试更加确定性和独立于实际
    API 的任何潜在不稳定或变化。'
- en: The test then navigates to the quote web page. After the page is loaded, it
    verifies if the page contains the expected quote text and the quote author. If
    these two checks pass, the test case succeeds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后导航到报价网页。页面加载后，它验证页面是否包含预期的报价文本和报价作者。如果这两个检查都通过，则测试用例成功。
- en: Something is interesting here that we need to highlight. An E2E test, by definition,
    tests the whole software stack from the frontend through to the backend, including
    all the intermediate layers, such as databases and network infrastructure. E2E
    testing aims to simulate real-world scenarios and confirm that the entire application
    is functioning correctly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情需要我们强调。端到端测试，根据定义，测试整个软件栈，从前端到后端，包括所有中间层，如数据库和网络基础设施。端到端测试旨在模拟现实世界场景，并确认整个应用程序是否正常工作。
- en: However, when we use the `cy.intercept` function to stub HTTP requests, we are
    indeed modifying this behavior. We are no longer testing the complete E2E flow
    because we are controlling and replacing the actual backend response with a mock
    response. This technique transforms the test from an E2E test into something more
    akin to an integration test for the frontend as we are testing the integration
    of different components of the frontend while mocking the backend responses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用 `cy.intercept` 函数来模拟 HTTP 请求时，我们实际上正在修改这种行为。我们不再测试完整的端到端流程，因为我们正在控制和替换实际的后端响应为模拟响应。这种技术将测试从端到端测试转变为更类似于前端集成测试，因为我们正在测试前端不同组件的集成，同时模拟后端响应。
- en: This is not necessarily a bad thing, however. Often, in testing, especially
    in complex systems, it is beneficial to isolate different parts of the system
    to gain more control over what we are testing and to ensure we can test different
    scenarios more reliably and deterministically.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不一定是一件坏事。在测试中，尤其是在复杂的系统中，将系统的不同部分隔离开来以获得对我们测试的更多控制，并确保我们可以更可靠和确定性地测试不同的场景，通常是很有益的。
- en: With that, we’ve covered the basics of Cypress for E2E testing and you’re now
    equipped to write robust E2E tests for your web applications.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经涵盖了 Cypress 的端到端测试基础知识，你现在可以编写健壮的端到端测试用例来测试你的 Web 应用程序。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on an exploration of the world of testing in a
    React application. We understood that the necessity of testing goes beyond mere
    validation of code correctness; it paves the path toward maintainability, improves
    readability, and drives the evolution of our application, ultimately ensuring
    we build software that meets expectations consistently.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了对 React 应用程序测试世界的探索。我们了解到测试的必要性不仅仅是对代码正确性的验证；它铺就了可维护性的道路，提高了可读性，并推动了我们应用程序的进化，最终确保我们构建的软件始终符合预期。
- en: Testing is a vital practice in software development – one that ensures our application
    not only works correctly but is also resilient to future changes. The React ecosystem,
    with tools such as Jest, the React Testing Library, and Cypress, provides us with
    a powerful arsenal to implement comprehensive testing strategies, thus bolstering
    the robustness and reliability of our applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发中的关键实践——它确保我们的应用程序不仅工作正确，而且能够适应未来的变化。React生态系统，包括Jest、React Testing Library和Cypress等工具，为我们提供了强大的武器库，以实施全面的测试策略，从而增强我们应用程序的健壮性和可靠性。
- en: In the next chapter, we’ll look into the common refactoring techniques and see
    how tests can help us during the refactoring process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨常见的重构技术，并了解测试如何在重构过程中帮助我们。
