<html><head></head><body>
<div id="_idContainer353">
<p><a id="_idTextAnchor462"/></p>
<h1 class="chapter-number" id="_idParaDest-253"><a id="_idTextAnchor463"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-254"><a id="_idTextAnchor464"/><span class="koboSpan" id="kobo.2.1">End-to-End Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will look at how to create an </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">End-to-End</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">E2E</span></strong><span class="koboSpan" id="kobo.7.1">) test suite for a Vue.js application with Cypress. </span><span class="koboSpan" id="kobo.7.2">In order to write robust tests, we’ll look at common pitfalls and best practices, such as intercepting HTTP requests and waiting for elements to appear </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">without timeouts.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">As we proceed, you will gain an understanding of E2E testing and its use cases. </span><span class="koboSpan" id="kobo.9.2">You will see how Cypress can be configured to test a Vue.js application and also interact with and inspect a </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">User Interface</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">UI</span></strong><span class="koboSpan" id="kobo.13.1">) using it. </span><span class="koboSpan" id="kobo.13.2">Throughout the chapter, you will gain familiarity with the pitfalls of arbitrary timeouts and how to avoid them with Cypress’ </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">waiting functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Toward the end of the chapter, you will also learn when, why, and how to intercept HTTP requests </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">with Cypress.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Understanding E2E testing and its </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">use cases</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Configuring Cypress for a </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Vue.js application</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Using Cypress to interact with and inspect a </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Vue.js UI</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Triggering and waiting for UI updates </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">with Cypress</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Intercepting </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">HTTP requests</span></span></li>
</ul>
<h1 id="_idParaDest-255"><a id="_idTextAnchor465"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">There are no technical requirements for this chapter beyond the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">git</span></strong><span class="koboSpan" id="kobo.32.1"> CLI, which you will have already used by now. </span><span class="koboSpan" id="kobo.32.2">You can find this chapter’s source </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">here: </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12</span></span></a></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor466"/><span class="koboSpan" id="kobo.35.1">Understanding E2E testing and its use cases</span></h1>
<p><span class="koboSpan" id="kobo.36.1">Most developers will have seen a version</span><a id="_idIndexMarker1321"/><span class="koboSpan" id="kobo.37.1"> of the testing</span><a id="_idIndexMarker1322"/><span class="koboSpan" id="kobo.38.1"> pyramid shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer331">
<span class="koboSpan" id="kobo.40.1"><img alt="Figure 12.1 – A diagram of the testing pyramid" src="image/Figure_12.01_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.41.1">Figure 12.1 – A diagram of the testing pyramid</span></p>
<p><span class="koboSpan" id="kobo.42.1">E2E tests fall under the UI testing</span><a id="_idIndexMarker1323"/><span class="koboSpan" id="kobo.43.1"> category. </span><span class="koboSpan" id="kobo.43.2">The type of test we’ll be looking at in this chapter is automated E2E tests </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">using Cypress.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">E2E and UI tests provide a level of confidence higher than unit or integration tests. </span><span class="koboSpan" id="kobo.45.2">They’re testing the application as used by the end user. </span><span class="koboSpan" id="kobo.45.3">The end user doesn’t care why or where a bug is happening, just that there is </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">a bug.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The where and why of a bug tends to be the concern of unit and system-level tests. </span><span class="koboSpan" id="kobo.47.2">Unit and system-level tests check that the internals of a system work as the specification or code describes them. </span><span class="koboSpan" id="kobo.47.3">UI-level tests validate that application flows are working </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">as expected.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">A strong E2E test suite that runs quickly, has few false negatives (where a test fails but the application works), and even fewer false</span><a id="_idIndexMarker1324"/><span class="koboSpan" id="kobo.50.1"> positives (where all tests pass but the application is broken) enables </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Continuous Deployment</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.53.1">CD</span></strong><span class="koboSpan" id="kobo.54.1">). </span><span class="koboSpan" id="kobo.54.2">CD, as its name suggests, involves deploying a project or </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">application continuously.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">In this kind of setup, an application version is validated by the E2E suite and is then automatically deployed </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">to production.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor467"/><span class="koboSpan" id="kobo.58.1">Configuring Cypress for a Vue.js application</span></h1>
<p><span class="koboSpan" id="kobo.59.1">Cypress is a JavaScript E2E testing</span><a id="_idIndexMarker1325"/><span class="koboSpan" id="kobo.60.1"> framework. </span><span class="koboSpan" id="kobo.60.2">It’s designed</span><a id="_idIndexMarker1326"/><span class="koboSpan" id="kobo.61.1"> to solve the very specific need of writing E2E tests using JavaScript. </span><span class="koboSpan" id="kobo.61.2">This is in contrast to other full-fledged browser</span><a id="_idIndexMarker1327"/><span class="koboSpan" id="kobo.62.1"> automation</span><a id="_idIndexMarker1328"/><span class="koboSpan" id="kobo.63.1"> solutions, such</span><a id="_idIndexMarker1329"/><span class="koboSpan" id="kobo.64.1"> as WebdriverIO (</span><a href="https://webdriver.io/"><span class="koboSpan" id="kobo.65.1">https://webdriver.io/</span></a><span class="koboSpan" id="kobo.66.1">), Selenium WebDriver (</span><a href="https://www.selenium.dev/"><span class="koboSpan" id="kobo.67.1">https://www.selenium.dev/</span></a><span class="koboSpan" id="kobo.68.1">), Puppeteer (</span><a href="https://developers.google.com/web/tools/puppeteer/"><span class="koboSpan" id="kobo.69.1">https://developers.google.com/web/tools/puppeteer/</span></a><span class="koboSpan" id="kobo.70.1">), and Playwright (</span><a href="https://github.com/microsoft/playwright"><span class="koboSpan" id="kobo.71.1">https://github.com/microsoft/playwright</span></a><span class="koboSpan" id="kobo.72.1">), which are commonly</span><a id="_idIndexMarker1330"/><span class="koboSpan" id="kobo.73.1"> used to write </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">E2E tests.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">The big difference with Cypress compared to these other solutions is its singular focus on writing E2E tests (as opposed to generic browser automation). </span><span class="koboSpan" id="kobo.75.2">Tests can only be written using JavaScript (Selenium supports other languages), and require Chrome, Edge, or Firefox (WebKit support is </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">in development).</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Cypress has a </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Graphical User Interface</span></strong><span class="koboSpan" id="kobo.79.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.80.1">GUI</span></strong><span class="koboSpan" id="kobo.81.1">) to run and debug tests locally</span><a id="_idIndexMarker1331"/><span class="koboSpan" id="kobo.82.1"> and comes with built-in assertion and </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">stubbing/mocking libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">To add Cypress to a new Vue project, simply enable it </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">when prompted:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer332">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 12.2 – Enabling Cypress when creating a new Vue 3 project" src="image/Figure_12.02_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 12.2 – Enabling Cypress when creating a new Vue 3 project</span></p>
<p><span class="koboSpan" id="kobo.88.1">To add Cypress to an existing project, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">npm install @</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">cypress/vue@next --dev</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">The plugin adds a </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">test:e2e</span></strong><span class="koboSpan" id="kobo.94.1"> script that we can run using the following two commands. </span><span class="koboSpan" id="kobo.94.2">The first prepares a build of the Vue application. </span><span class="koboSpan" id="kobo.94.3">The second actually starts the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">Cypress app:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.96.1">
npm run build
npm run test:e2e</span></pre>
<p><span class="koboSpan" id="kobo.97.1">You will be asked to use a browser for testing first, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.98.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.99.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer333">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 12.3 – Cypress asking for the preferred browser to use for testing" src="image/Figure_12.03_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 12.3 – Cypress asking for the preferred browser to use for testing</span></p>
<p><span class="koboSpan" id="kobo.103.1">After selecting</span><a id="_idIndexMarker1332"/><span class="koboSpan" id="kobo.104.1"> a browser, the main</span><a id="_idIndexMarker1333"/><span class="koboSpan" id="kobo.105.1"> Cypress UI </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">is displayed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer334">
<span class="koboSpan" id="kobo.107.1"><img alt="Figure 12.4 – Cypress testing UI" src="image/Figure_12.04_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.108.1">Figure 12.4 – Cypress testing UI</span></p>
<p><span class="koboSpan" id="kobo.109.1">If you click</span><a id="_idIndexMarker1334"/><span class="koboSpan" id="kobo.110.1"> on the example</span><a id="_idIndexMarker1335"/><span class="koboSpan" id="kobo.111.1"> link, you’ll see the test running and </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer335">
<span class="koboSpan" id="kobo.113.1"><img alt="Figure 12.5 – Cypress running a test" src="image/Figure_12.05_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.114.1">Figure 12.5 – Cypress running a test</span></p>
<p><span class="koboSpan" id="kobo.115.1">Cypress creates a default</span><a id="_idIndexMarker1336"/><span class="koboSpan" id="kobo.116.1"> test for us at </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">cypress/e2e/example.cy.js</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">The test navigates</span><a id="_idIndexMarker1337"/><span class="koboSpan" id="kobo.119.1"> to the root of the Vue application and looks for an </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">h1</span></strong><span class="koboSpan" id="kobo.121.1"> tag that contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">You </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">did it!</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
// https://docs.cypress.io/api/introduction/api.html
describe('My First Test', () =&gt; {
  it('visits the app root url', () =&gt; {
    cy.visit('/')
    cy.contains('h1', 'You did it!')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.126.1">This will work in a default Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">3 project.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">We can try</span><a id="_idIndexMarker1338"/><span class="koboSpan" id="kobo.129.1"> visiting </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">google.com</span></strong><span class="koboSpan" id="kobo.131.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">cy.visit(url)</span></strong><span class="koboSpan" id="kobo.133.1"> and check</span><a id="_idIndexMarker1339"/><span class="koboSpan" id="kobo.134.1"> that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">input</span></strong><span class="koboSpan" id="kobo.136.1"> element that’s synonymous with the Google home page is there by selecting the input elements on the page with </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">cy.get('input')</span></strong><span class="koboSpan" id="kobo.138.1"> first and then using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">should('exist')</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1"> assertion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
describe('My First Test', () =&gt; {
  it('Opens an arbitrary URL', () =&gt; {
    cy.visit('https://google.com')
    cy.get('input').should('exist')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.143.1">The Cypress window will automatically load and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">new test:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer336">
<span class="koboSpan" id="kobo.145.1"><img alt="Figure 12.6 – Cypress tests running in Chrome while visiting the Google home page" src="image/Figure_12.06_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.146.1">Figure 12.6 – Cypress tests running in Chrome while visiting the Google home page</span></p>
<p><span class="koboSpan" id="kobo.147.1">We’ve now seen how to install</span><a id="_idIndexMarker1340"/><span class="koboSpan" id="kobo.148.1"> and use Cypress to visit web</span><a id="_idIndexMarker1341"/><span class="koboSpan" id="kobo.149.1"> pages. </span><span class="koboSpan" id="kobo.149.2">In the next section, we’ll see how Cypress can be used to interact with and inspect </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">a UI.</span></span></p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor468"/><span class="koboSpan" id="kobo.151.1">Using Cypress to interact with and inspect a Vue.js UI</span></h1>
<p><span class="koboSpan" id="kobo.152.1">In order to E2E test</span><a id="_idIndexMarker1342"/><span class="koboSpan" id="kobo.153.1"> a new application, Commentator</span><a id="_idIndexMarker1343"/><span class="koboSpan" id="kobo.154.1"> Pro, we should start</span><a id="_idIndexMarker1344"/><span class="koboSpan" id="kobo.155.1"> by adding something</span><a id="_idIndexMarker1345"/><span class="koboSpan" id="kobo.156.1"> to test. </span><span class="koboSpan" id="kobo.156.2">In this case, we’ll have a heading (</span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">h2</span></strong><span class="koboSpan" id="kobo.158.1">) with the name of the application. </span><span class="koboSpan" id="kobo.158.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">App.vue</span></strong><span class="koboSpan" id="kobo.160.1"> file, we’ll have the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
&lt;template&gt;
&lt;h2&gt;Commentator Pro&lt;/h2&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.163.1">In order to test this with Cypress, we can change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">cypress/e2e/example.cy.js</span></strong><span class="koboSpan" id="kobo.165.1"> file with the following code. </span><span class="koboSpan" id="kobo.165.2">We’ll go to the running application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">cy.visit('/')</span></strong><span class="koboSpan" id="kobo.167.1"> and then check that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">h2</span></strong><span class="koboSpan" id="kobo.169.1"> on the page contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Commentator Pro</span></strong><span class="koboSpan" id="kobo.171.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">cy.contains('h2', 'Commentator Pro')</span></strong><span class="koboSpan" id="kobo.173.1">. </span><span class="koboSpan" id="kobo.173.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">cy.contains</span></strong><span class="koboSpan" id="kobo.175.1"> function is overloaded and can be used with one parameter (the text to match against) or two parameters (the selector for the container and the text to </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">match against):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
describe('Commentator Pro', () =&gt; {
  it('Has a h2 with "Commentator Pro"', () =&gt; {
    cy.visit('/')
    cy.contains('h2', 'Commentator Pro')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.178.1">We can then run </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">example.cy.js</span></strong><span class="koboSpan" id="kobo.180.1"> using the Cypress UI, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer337">
<span class="koboSpan" id="kobo.182.1"><img alt="Figure 12.7 – A heading content test running successfully in Chrome" src="image/Figure_12.07_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.183.1">Figure 12.7 – A heading content test running successfully in Chrome</span></p>
<p><span class="koboSpan" id="kobo.184.1">Now that we’ve</span><a id="_idIndexMarker1346"/><span class="koboSpan" id="kobo.185.1"> seen how to visit</span><a id="_idIndexMarker1347"/><span class="koboSpan" id="kobo.186.1"> a page and assert</span><a id="_idIndexMarker1348"/><span class="koboSpan" id="kobo.187.1"> its content, we’ll see</span><a id="_idIndexMarker1349"/><span class="koboSpan" id="kobo.188.1"> how we can use Cypress to automate tests for a new feature in a </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Vue.js application.</span></span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor469"/><span class="koboSpan" id="kobo.190.1">Exercise 12.01 – adding a New Comment button and a corresponding E2E test</span></h2>
<p><span class="koboSpan" id="kobo.191.1">In order for the </span><a id="_idIndexMarker1350"/><span class="koboSpan" id="kobo.192.1">Commentator</span><a id="_idIndexMarker1351"/><span class="koboSpan" id="kobo.193.1"> Pro application</span><a id="_idIndexMarker1352"/><span class="koboSpan" id="kobo.194.1"> to be useful, we should have an </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.196.1"> button to allow users to </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">add comments.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">We will add a blue jumbo button with </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.200.1"> as text and write the corresponding E2E test </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">with Cypress.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">The complete code can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.01"><span class="No-Break"><span class="koboSpan" id="kobo.204.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.01</span></span></a></p>
<p><span class="koboSpan" id="kobo.205.1">To do this, perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.207.1">To add a button in the app, we’ll add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">button</span></strong><span class="koboSpan" id="kobo.209.1"> element with some text </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">src/App.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
&lt;h2&gt;Commentator Pro&lt;/h2&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.215.1">
&lt;button&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.216.1">
Add a New Comment</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.217.1">
&lt;/button&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
&lt;/template&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.219.1">The output should show </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer338">
<span class="koboSpan" id="kobo.221.1"><img alt="Figure 12.8 – The Commentator Pro application with the Add a New Comment button" src="image/Figure_12.08_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.222.1">Figure 12.8 – The Commentator Pro application with the Add a New Comment button</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.223.1">Next, we’ll create a new E2E test</span><a id="_idIndexMarker1353"/><span class="koboSpan" id="kobo.224.1"> at </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">cypress/e2e/add-new-comment.cy.js</span></strong><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">We’ll set</span><a id="_idIndexMarker1354"/><span class="koboSpan" id="kobo.227.1"> the name</span><a id="_idIndexMarker1355"/><span class="koboSpan" id="kobo.228.1"> of the suite and description of the test to </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Adding a New Comment</span></strong><span class="koboSpan" id="kobo.230.1">, and the home page should have a button with the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">right text:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.232.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.233.1">
  it('the homepage should have a button with the right</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.234.1">
  text', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.235.1">
    // test will go here</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.236.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.237.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.238.1">In order to test the home page, we’ll have to navigate to it </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">cy.visit('/')</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.242.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.243.1">
  it('the homepage should have a button with the right</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.244.1">
  text', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.245.1">
    cy.visit('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.246.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.248.1">Finally, we can write the assertion that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">button</span></strong><span class="koboSpan" id="kobo.250.1"> instance containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.252.1"> text is on </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">the page:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.254.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.255.1">
  it('the homepage should have a button with the right</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.256.1">
  text', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.257.1">
    cy.visit('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.258.1">
    cy.contains('button', 'Add a New Comment')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.259.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.260.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.261.1">We can run this</span><a id="_idIndexMarker1356"/><span class="koboSpan" id="kobo.262.1"> test using</span><a id="_idIndexMarker1357"/><span class="koboSpan" id="kobo.263.1"> the Cypress UI first by running</span><a id="_idIndexMarker1358"/><span class="koboSpan" id="kobo.264.1"> a new build (</span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">npm run build</span></strong><span class="koboSpan" id="kobo.266.1">), and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">npm run test:e2e</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">If you already had Cypress running, you do not need to restart it. </span><span class="koboSpan" id="kobo.268.3">You can visit the list of tests by clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">Specs</span></strong><span class="koboSpan" id="kobo.270.1"> navigation item in the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">left-hand menu.</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer339">
<span class="koboSpan" id="kobo.272.1"><img alt="Figure 12.9 – The add-new-comment.cy.js test displaying in the Cypress UI" src="image/Figure_12.09_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.273.1">Figure 12.9 – The add-new-comment.cy.js test displaying in the Cypress UI</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.274.1">When we run</span><a id="_idIndexMarker1359"/><span class="koboSpan" id="kobo.275.1"> the test (by clicking on it), we’ll get the following</span><a id="_idIndexMarker1360"/><span class="koboSpan" id="kobo.276.1"> output in Chrome. </span><span class="koboSpan" id="kobo.276.2">The test</span><a id="_idIndexMarker1361"/><span class="koboSpan" id="kobo.277.1"> passes since there is a button with the relevant text on the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">home page:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer340">
<span class="koboSpan" id="kobo.279.1"><img alt="Figure 12.10 – Cypress running our add-new-comment test in Chrome" src="image/Figure_12.10_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">Figure 12.10 – Cypress running our add-new-comment test in Chrome</span></p>
<p><span class="koboSpan" id="kobo.281.1">We’ve now seen how to visit</span><a id="_idIndexMarker1362"/><span class="koboSpan" id="kobo.282.1"> pages and assert against</span><a id="_idIndexMarker1363"/> <span class="No-Break"><span class="koboSpan" id="kobo.283.1">their </span></span><span class="No-Break"><a id="_idIndexMarker1364"/></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">content.</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">In the next section, we will look at using Cypress to test interactive behavior. </span><span class="koboSpan" id="kobo.285.2">Cypress has automatic selector retries, which makes it a great fit for testing highly interactive Vue.js applications. </span><span class="koboSpan" id="kobo.285.3">We’ll see how to use Cypress to interact with the UI and assert the effect of </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">our interactions.</span></span></p>
<h1 id="_idParaDest-260"><a id="_idTextAnchor470"/><span class="koboSpan" id="kobo.287.1">Triggering and waiting for UI updates with Cypress</span></h1>
<p><span class="koboSpan" id="kobo.288.1">The tests we’ve written</span><a id="_idIndexMarker1365"/><span class="koboSpan" id="kobo.289.1"> up until now are quite simple</span><a id="_idIndexMarker1366"/><span class="koboSpan" id="kobo.290.1"> and only check</span><a id="_idIndexMarker1367"/><span class="koboSpan" id="kobo.291.1"> that the application</span><a id="_idIndexMarker1368"/><span class="koboSpan" id="kobo.292.1"> isn’t crashing on load in </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">One of the strengths of E2E tests is testing that the UI behaves as expected when a user interacts with it with high fidelity. </span><span class="koboSpan" id="kobo.294.2">We’ll use Cypress’ selection (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">.get()</span></strong><span class="koboSpan" id="kobo.296.1"> function), event triggering (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">.click()</span></strong><span class="koboSpan" id="kobo.298.1"> function), and assertion (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">.should()</span></strong><span class="koboSpan" id="kobo.300.1"> function) functionality to test a Vue.js application in </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Cypress’ automatic retries on DOM selection will allow us to write E2E tests without explicit wait or timeout conditions. </span><span class="koboSpan" id="kobo.302.2">Waits and timeouts are a staple of other E2E testing systems and tend to be a source of flakiness </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">in tests.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">To begin with, we will add a comment editor to our Commentator Pro application. </span><span class="koboSpan" id="kobo.304.2">Displaying the editor (a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">textarea</span></strong><span class="koboSpan" id="kobo.306.1">) will be toggled by clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">Add a New </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.308.1">Comment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> button.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">In order to keep writing tests without wrangling complicated and brittle selectors, we’ll start adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">data-test-id</span></strong><span class="koboSpan" id="kobo.312.1"> attributes; to begin with, we can add one to the </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.314.1"> button in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">App.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.316.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
&lt;template&gt;
&lt;h2&gt;Commentator Pro&lt;/h2&gt;
&lt;button data-test-id="new-comment-button"&gt;
Add a New Comment
&lt;/button&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.318.1">Next, we’ll add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">showEditor</span></strong><span class="koboSpan" id="kobo.320.1"> property</span><a id="_idIndexMarker1369"/><span class="koboSpan" id="kobo.321.1"> to the Vue.js </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">data()</span></strong><span class="koboSpan" id="kobo.323.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">App</span></strong><span class="koboSpan" id="kobo.325.1"> component. </span><span class="koboSpan" id="kobo.325.2">We’ll use this </span><a id="_idIndexMarker1370"/><span class="koboSpan" id="kobo.326.1">expression in </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">v-if</span></strong><span class="koboSpan" id="kobo.328.1"> for the editor. </span><span class="koboSpan" id="kobo.328.2">We</span><a id="_idIndexMarker1371"/><span class="koboSpan" id="kobo.329.1"> can also</span><a id="_idIndexMarker1372"/><span class="koboSpan" id="kobo.330.1"> set the </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.332.1"> button to toggle this </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">instance property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
&lt;template&gt;
&lt;h2&gt;Commentator Pro&lt;/h2&gt;
&lt;button @click="showEditor = !showEditor"
  data-test-id="new-comment-button"&gt;
Add a New Comment
&lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      showEditor: false
    }
  }
}
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.335.1">We can add our editor with </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">new-comment-editor</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.337.1">data-test-id</span></strong><span class="koboSpan" id="kobo.338.1"> that is toggled </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">showEditor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
&lt;template&gt;
&lt;!-- rest of template --&gt;
&lt;div v-if="showEditor"&gt;
  &lt;p&gt;
  &lt;textarea data-test-id="new-comment-editor"&gt;&lt;/textarea&gt;
  &lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.343.1">In order to test</span><a id="_idIndexMarker1373"/><span class="koboSpan" id="kobo.344.1"> the toggling, we can</span><a id="_idIndexMarker1374"/><span class="koboSpan" id="kobo.345.1"> add a test</span><a id="_idIndexMarker1375"/><span class="koboSpan" id="kobo.346.1"> that opens that app and checks</span><a id="_idIndexMarker1376"/><span class="koboSpan" id="kobo.347.1"> that the comment editor is not initially shown, as well as checking whether or not it is displayed depending on how many clicks are triggered </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">new-comment-button</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
describe('Adding a New Comment', () =&gt; {
  // other tests
  it('the Add a New Comment button should toggle the editor
  display on and off', () =&gt; {
    cy.visit('/')
    cy.get('[data-test-id="new-comment-editor"]')
      .should('not.exist')
    cy.get('[data-test-id="new-comment-button"]').click()
    cy.get('[data-test-id="new-comment-editor"]')
      .should('be.visible')
    cy.get('[data-test-id="new-comment-button"]').click()
    cy.get('[data-test-id="new-comment-editor"]')
      .should('not.exist')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.352.1">The preceding code</span><a id="_idIndexMarker1377"/><span class="koboSpan" id="kobo.353.1"> will generate</span><a id="_idIndexMarker1378"/><span class="koboSpan" id="kobo.354.1"> the following</span><a id="_idIndexMarker1379"/><span class="koboSpan" id="kobo.355.1"> result </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">in</span></span><span class="No-Break"><a id="_idIndexMarker1380"/></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1"> Cypress:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer341">
<span class="koboSpan" id="kobo.358.1"><img alt="Figure 12.11 – Cypress running add-new-comment tests, including the new editor-toggling test" src="image/Figure_12.11_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.359.1">Figure 12.11 – Cypress running add-new-comment tests, including the new editor-toggling test</span></p>
<p><span class="koboSpan" id="kobo.360.1">We’ve now seen how</span><a id="_idIndexMarker1381"/><span class="koboSpan" id="kobo.361.1"> to write Cypress</span><a id="_idIndexMarker1382"/><span class="koboSpan" id="kobo.362.1"> tests that select</span><a id="_idIndexMarker1383"/><span class="koboSpan" id="kobo.363.1"> and assert over </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">DOM</span></span><span class="No-Break"><a id="_idIndexMarker1384"/></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1"> elements.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.366.1">Note</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">data-test-id</span></strong><span class="koboSpan" id="kobo.368.1"> instances, as a convention, are a way</span><a id="_idIndexMarker1385"/><span class="koboSpan" id="kobo.369.1"> to decouple tests from application-specific and styling-specific selectors. </span><span class="koboSpan" id="kobo.369.2">This is especially useful if the people writing the tests aren’t always the ones writing the code. </span><span class="koboSpan" id="kobo.369.3">In that situation, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">data-test-id</span></strong><span class="koboSpan" id="kobo.371.1"> allows the markup structure and classes to change, but the tests will keep passing as long as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">test-id</span></strong><span class="koboSpan" id="kobo.373.1"> instances remain on the </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">correct element.</span></span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor471"/><span class="koboSpan" id="kobo.375.1">Exercise 12.02 – adding new comment editor input and a Submit functionality</span></h2>
<p><span class="koboSpan" id="kobo.376.1">To be able</span><a id="_idIndexMarker1386"/><span class="koboSpan" id="kobo.377.1"> to send</span><a id="_idIndexMarker1387"/><span class="koboSpan" id="kobo.378.1"> the new </span><a id="_idIndexMarker1388"/><span class="koboSpan" id="kobo.379.1">comment text to an API, we will need</span><a id="_idIndexMarker1389"/><span class="koboSpan" id="kobo.380.1"> to store the text in a Vue.js state. </span><span class="koboSpan" id="kobo.380.2">The other prerequisite to adding a comment is to have a dummy </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.381.1">Submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> button.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">The complete code can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.02"><span class="No-Break"><span class="koboSpan" id="kobo.385.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.02</span></span></a></p>
<p><span class="koboSpan" id="kobo.386.1">To accomplish this, perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">following steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.388.1">To store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">textarea</span></strong><span class="koboSpan" id="kobo.390.1"> (editor) content in memory, we’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">v-model</span></strong><span class="koboSpan" id="kobo.392.1">. </span><span class="koboSpan" id="kobo.392.2">We’ll create a new data (state) variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">newComment</span></strong><span class="koboSpan" id="kobo.394.1">, that gets initialized to </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">""</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">v-model</span></strong><span class="koboSpan" id="kobo.398.1"> will two-way bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">textarea</span></strong><span class="koboSpan" id="kobo.400.1"> content </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">newComment</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
&lt;!-- rest of template --&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
  &lt;p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
  &lt;textarea data-test-id="new-comment-editor"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.408.1">
    v-model="newComment"&gt;&lt;/textarea&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
  &lt;/p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
&lt;!-- rest of template --&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.411.1">
&lt;/template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.412.1">
&lt;script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.413.1">
export default {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
  data() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
    return {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.416.1">
      showEditor: false,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.417.1">
      newComment: ''</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.418.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.419.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.421.1">
&lt;/script&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.422.1">We’ll add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">submit</span></strong><span class="koboSpan" id="kobo.424.1"> button</span><a id="_idIndexMarker1390"/><span class="koboSpan" id="kobo.425.1"> inside the editor, which should</span><a id="_idIndexMarker1391"/><span class="koboSpan" id="kobo.426.1"> only appear when the editor </span><a id="_idIndexMarker1392"/><span class="koboSpan" id="kobo.427.1">is </span><a id="_idIndexMarker1393"/><span class="koboSpan" id="kobo.428.1">toggled on. </span><span class="koboSpan" id="kobo.428.2">We also make sure to include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">data-test-id="new-comment-submit"</span></strong><span class="koboSpan" id="kobo.430.1"> attribute in order to be able to select it with </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">Cypress later:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.432.1">
&lt;!-- rest of template --&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.433.1">
&lt;div v-if="showEditor"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.434.1">
  &lt;p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.435.1">
  &lt;textarea data-test-id="new-comment-editor"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.436.1">
    v-model="newComment"&gt;&lt;/textarea&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.437.1">
  &lt;/p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.438.1">
  &lt;p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.439.1">
  &lt;button data-test-id="new-comment-submit"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.440.1">
    Submit</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.441.1">
  &lt;/button&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.442.1">
  &lt;/p&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.443.1">
&lt;/div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.444.1">
&lt;!-- rest of template --&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.445.1">It’s now time to add an E2E test to test that </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">new-comment-editor</span></strong><span class="koboSpan" id="kobo.447.1"> works as expected when we type text into it. </span><span class="koboSpan" id="kobo.447.2">In order to achieve this, we need to load up the application and click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">new-comment</span></strong><span class="koboSpan" id="kobo.449.1"> button so that the </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">editor displays.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.451.1">We can then select </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">new-comment-editor</span></strong><span class="koboSpan" id="kobo.453.1"> (by </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">data-test-id</span></strong><span class="koboSpan" id="kobo.455.1">) and use the Cypress </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">.type</span></strong><span class="koboSpan" id="kobo.457.1"> function</span><a id="_idIndexMarker1394"/><span class="koboSpan" id="kobo.458.1"> to add some </span><a id="_idIndexMarker1395"/><span class="koboSpan" id="kobo.459.1">text. </span><span class="koboSpan" id="kobo.459.2">We </span><a id="_idIndexMarker1396"/><span class="koboSpan" id="kobo.460.1">can</span><a id="_idIndexMarker1397"/><span class="koboSpan" id="kobo.461.1"> chain </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">.should('have.value', 'Just saying...')</span></strong><span class="koboSpan" id="kobo.463.1"> to validate that our interaction with </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">textarea</span></strong><span class="koboSpan" id="kobo.465.1"> was successful. </span><span class="koboSpan" id="kobo.465.2">Remember to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">npm run build</span></strong><span class="koboSpan" id="kobo.467.1"> when adding </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">new tests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
describe('Adding a New Comment', () =&gt; {
  // other tests
  it('the new comment editor should support text
  input', () =&gt; {
    cy.visit('/')
    // Get the editor to show
    cy.get('[data-test-id="new-comment-button"]')
      .click()
    cy.get('[data-test-id="new-comment-editor"]')
      .should('be.visible')
    cy.get('[data-test-id="new-comment-editor"]')
      .type('Just saying...')
      .should('have.value', 'Just saying...')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.470.1">When run using the Cypress UI, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">add-new-comment</span></strong><span class="koboSpan" id="kobo.472.1"> test suite should yield the </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">following result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer342">
<span class="koboSpan" id="kobo.474.1"><img alt="Figure 12.12 – Cypress running add-new-comment tests, including the new editor text input test" src="image/Figure_12.12_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.475.1">Figure 12.12 – Cypress running add-new-comment tests, including the new editor text input test</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.476.1">Finally, we can add an E2E test</span><a id="_idIndexMarker1398"/><span class="koboSpan" id="kobo.477.1"> to check that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">submit</span></strong><span class="koboSpan" id="kobo.479.1"> button</span><a id="_idIndexMarker1399"/><span class="koboSpan" id="kobo.480.1"> does not appear</span><a id="_idIndexMarker1400"/><span class="koboSpan" id="kobo.481.1"> by </span><a id="_idIndexMarker1401"/><span class="koboSpan" id="kobo.482.1">default but does appear when we click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">new-comment</span></strong><span class="koboSpan" id="kobo.484.1"> button. </span><span class="koboSpan" id="kobo.484.2">We can also check the text content of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">new-comment-submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.486.1"> button:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.487.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.488.1">
  // other tests</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.489.1">
  it('the new comment editor should have a submit</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.490.1">
  button', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.491.1">
    cy.visit('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.492.1">
    cy.get('[data-test-id="new-comment-submit"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.493.1">
      .should('not.exist')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.494.1">
    // Get the editor to show</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.495.1">
    cy.get('[data-test-id="new-comment-button"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.496.1">
      .click()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.497.1">
    cy.get('[data-test-id="new-comment-submit"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.498.1">
      .should('be.visible')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.499.1">
    cy.contains('[data-test-id="new-comment-submit"]',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.500.1">
                'Submit')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.501.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.502.1">
})</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.503.1">When this test is run</span><a id="_idIndexMarker1402"/><span class="koboSpan" id="kobo.504.1"> through the Cypress UI, we </span><a id="_idIndexMarker1403"/><span class="koboSpan" id="kobo.505.1">see </span><a id="_idIndexMarker1404"/><span class="koboSpan" id="kobo.506.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">following</span></span><span class="No-Break"><a id="_idIndexMarker1405"/></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1"> result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer343">
<span class="koboSpan" id="kobo.509.1"><img alt="Figure 12.13 – Cypress running add-new-comment tests, including the new submit button test" src="image/Figure_12.13_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.510.1">Figure 12.13 – Cypress running add-new-comment tests, including the new submit button test</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.511.1">One more feature we can add is to disable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">submit</span></strong><span class="koboSpan" id="kobo.513.1"> button until there’s text in the text editor. </span><span class="koboSpan" id="kobo.513.2">To do this, we can bind </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">:disabled</span></strong><span class="koboSpan" id="kobo.515.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">!newComment</span></strong><span class="koboSpan" id="kobo.517.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">new-comment-submit</span></strong><span class="koboSpan" id="kobo.519.1"> button. </span><span class="koboSpan" id="kobo.519.2">As an aside, one of the major reasons we added a two-way binding between </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">newComment</span></strong><span class="koboSpan" id="kobo.521.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">textarea</span></strong><span class="koboSpan" id="kobo.523.1"> is to enable UI validations such as </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">this one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.525.1">
&lt;button data-test-id="new-comment-submit"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.526.1">
  :disabled="!newComment"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.527.1">
  Submit</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.528.1">
&lt;/button&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.529.1">The </span><a id="_idIndexMarker1406"/><span class="koboSpan" id="kobo.530.1">relevant </span><a id="_idIndexMarker1407"/><span class="koboSpan" id="kobo.531.1">test</span><a id="_idIndexMarker1408"/><span class="koboSpan" id="kobo.532.1"> will look at whether or not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">new-comment-submit</span></strong><span class="koboSpan" id="kobo.534.1"> button</span><a id="_idIndexMarker1409"/><span class="koboSpan" id="kobo.535.1"> is disabled when the text editor content is empty using Cypress’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">should('be.disabled')</span></strong><span class="koboSpan" id="kobo.537.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">should('not.be.disabled')</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> assertions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.540.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.541.1">
  // other tests</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.542.1">
  it('the new comment submit button should be disabled</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.543.1">
  based on "new comment" content', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.544.1">
    cy.visit('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.545.1">
    // Get the editor to show</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.546.1">
    cy.get('[data-test-id="new-comment-button"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.547.1">
      .click()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.548.1">
    cy.get('[data-test-id="new-comment-submit"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.549.1">
      .should('be.visible')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.550.1">
    cy.get('[data-test-id="new-comment-submit"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
      .should('be.disabled')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.552.1">
    cy.get('[data-test-id="new-comment-editor"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
      .type('Just saying...')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.554.1">
    cy.get('[data-test-id="new-comment-submit"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.555.1">
      .should('not.be.disabled')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.556.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.557.1">
})</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.558.1">This yields the </span><a id="_idIndexMarker1410"/><span class="koboSpan" id="kobo.559.1">following</span><a id="_idIndexMarker1411"/><span class="koboSpan" id="kobo.560.1"> output</span><a id="_idIndexMarker1412"/><span class="koboSpan" id="kobo.561.1"> when run through Cypress UI</span><a id="_idIndexMarker1413"/><span class="koboSpan" id="kobo.562.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">Chrome automation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer344">
<span class="koboSpan" id="kobo.564.1"><img alt="Figure 12.14 – Cypress running add-new-comment tests, including the new-comment-submit button disabled test" src="image/Figure_12.14_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.565.1">Figure 12.14 – Cypress running add-new-comment tests, including the new-comment-submit button disabled test</span></p>
<p><span class="koboSpan" id="kobo.566.1">We’ve now seen how to use Cypress to select, click, and input text. </span><span class="koboSpan" id="kobo.566.2">We’ve also seen approaches to check element visibility, text content, input values, and </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">disabled states.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">Anyone familiar with other automation frameworks will have noticed that in Cypress tests, there are no </span><a id="_idIndexMarker1414"/><span class="koboSpan" id="kobo.569.1">explicit waits or retries. </span><span class="koboSpan" id="kobo.569.2">This is because</span><a id="_idIndexMarker1415"/><span class="koboSpan" id="kobo.570.1"> Cypress waits and retries assertions and </span><a id="_idIndexMarker1416"/><span class="koboSpan" id="kobo.571.1">selections </span><a id="_idIndexMarker1417"/><span class="koboSpan" id="kobo.572.1">automatically. </span><span class="koboSpan" id="kobo.572.2">Most of the tests we’ve written don’t showcase this in a major way, but the next exercise, where we bring asynchronicity into the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">mix, will.</span></span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor472"/><span class="koboSpan" id="kobo.574.1">Exercise 12.03 – adding a submitting state to the new comment editor</span></h2>
<p><span class="koboSpan" id="kobo.575.1">In order to showcase</span><a id="_idIndexMarker1418"/><span class="koboSpan" id="kobo.576.1"> Cypress’s impressive, automatic </span><a id="_idIndexMarker1419"/><span class="koboSpan" id="kobo.577.1">retry/wait</span><a id="_idIndexMarker1420"/><span class="koboSpan" id="kobo.578.1"> capability, we will look at adding and testing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">submitting</span></strong><span class="koboSpan" id="kobo.580.1"> state for the new </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">comment editor.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">In effect, we’ll be reacting to a click on the </span><strong class="bold"><span class="koboSpan" id="kobo.583.1">Submit</span></strong><span class="koboSpan" id="kobo.584.1"> button and showing a loading state for </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">2.5</span></strong><span class="koboSpan" id="kobo.586.1"> seconds to simulate a reasonably slow HTTP request to a backend API. </span><span class="koboSpan" id="kobo.586.2">The loading state is simply a CSS class that makes the button have </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">italic text.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">This test will be an example that showcases Cypress’ ability to automatically wait and retry selections. </span><span class="koboSpan" id="kobo.588.2">This feature reduces the need for arbitrary waits and the flakiness associated </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">The complete code can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.03"><span class="No-Break"><span class="koboSpan" id="kobo.592.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.03</span></span></a></p>
<p><span class="koboSpan" id="kobo.593.1">Let’s do this by following </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">these steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.595.1">In order to show</span><a id="_idIndexMarker1421"/><span class="koboSpan" id="kobo.596.1"> a loading state, we add</span><a id="_idIndexMarker1422"/><span class="koboSpan" id="kobo.597.1"> a new class to </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">the component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
&lt;style scoped&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
.submitting {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
  font-style: italic;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.602.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.603.1">
&lt;/style&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.604.1">Next, we need to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">isSubmitting</span></strong><span class="koboSpan" id="kobo.606.1"> state to the Vue.js application in </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">data()</span></strong><span class="koboSpan" id="kobo.608.1">, which will allow us to toggle the state for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">submit</span></strong><span class="koboSpan" id="kobo.610.1"> button. </span><span class="koboSpan" id="kobo.610.2">We will initialize it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">false</span></strong><span class="koboSpan" id="kobo.612.1"> since we are not submitting anything until the user clicks on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.613.1">Submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1"> button:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.615.1">
&lt;script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.616.1">
export default {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.617.1">
  data() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.618.1">
    return {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.619.1">
      // other properties</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.620.1">
      isSubmitting: false</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
&lt;/script&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.625.1">Next, we will add</span><a id="_idIndexMarker1423"/><span class="koboSpan" id="kobo.626.1"> a click handler</span><a id="_idIndexMarker1424"/><span class="koboSpan" id="kobo.627.1"> for</span><a id="_idIndexMarker1425"/><span class="koboSpan" id="kobo.628.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">submit</span></strong><span class="koboSpan" id="kobo.630.1"> button (as </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">methods.submitNewComment</span></strong><span class="koboSpan" id="kobo.632.1">). </span><span class="koboSpan" id="kobo.632.2">It will simulate a 2.5-second load time </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">setTimeout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
&lt;script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
export default {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.638.1">
  // other component properties</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.639.1">
  methods: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.640.1">
    submitNewComment() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.641.1">
      this.isSubmitting = true</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
      setTimeout(() =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.643.1">
        this.isSubmitting = false;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.644.1">
        this.newComment = '';</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.645.1">
      }, 2500)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.646.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.648.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.649.1">
&lt;/script&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.650.1">Now that we’ve got a fake </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">submit</span></strong><span class="koboSpan" id="kobo.652.1"> handler, we should bind it to click events on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">new-comment-submit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.654.1"> button:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.655.1">
&lt;template&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.656.1">
  &lt;!-- rest of template --&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.657.1">
  &lt;div v-if="showEditor"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.658.1">
  &lt;!-- rest of editor --&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.659.1">
  &lt;button data-test-id="new-comment-submit"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.660.1">
    :disabled="!newComment"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.661.1">
      @click="submitNewComment()"&gt;Submit</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.662.1">
  &lt;/button&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.663.1">
  &lt;/div&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.664.1">
&lt;/template&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.665.1">Now comes the part</span><a id="_idIndexMarker1426"/><span class="koboSpan" id="kobo.666.1"> where we need to</span><a id="_idIndexMarker1427"/><span class="koboSpan" id="kobo.667.1"> react</span><a id="_idIndexMarker1428"/><span class="koboSpan" id="kobo.668.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">submit</span></strong><span class="koboSpan" id="kobo.670.1"> button. </span><span class="koboSpan" id="kobo.670.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">submitting</span></strong><span class="koboSpan" id="kobo.672.1"> class will show when </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">isSubmitting</span></strong><span class="koboSpan" id="kobo.674.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">true</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">To do this, we simply need to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">submitting</span></strong><span class="koboSpan" id="kobo.678.1"> class to be added when </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">isSubmitting</span></strong><span class="koboSpan" id="kobo.680.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">true</span></strong><span class="koboSpan" id="kobo.682.1">. </span><span class="koboSpan" id="kobo.682.2">In addition to this, we’ll disable the button when </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">isSubmitting</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.684.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.687.1">
&lt;button data-test-id="new-comment-submit"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.688.1">
:disabled="!newComment || isSubmitting"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.689.1">
:class="{submitting:isSubmitting}"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.690.1">
@click="submitNewComment()"&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.691.1">
Submit</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.692.1">
&lt;/button&gt;</span></pre></li>
<li><span class="koboSpan" id="kobo.693.1">Finally, we can add a test to check that the button applies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">submitting</span></strong><span class="koboSpan" id="kobo.695.1"> class when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">submit</span></strong><span class="koboSpan" id="kobo.697.1"> button is clicked. </span><span class="koboSpan" id="kobo.697.2">To begin with, we’ll need to set up the text editor so that when clicking on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">add-new-comment</span></strong><span class="koboSpan" id="kobo.699.1"> button and setting a text value for the comment, the text editor is shown </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">and enabled.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.701.1">Next, we can click on the enabled </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">new-comment-submit</span></strong><span class="koboSpan" id="kobo.703.1"> button and check that it is disabled and has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">submitting</span></strong><span class="koboSpan" id="kobo.705.1"> class (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">should()</span></strong><span class="koboSpan" id="kobo.707.1"> function). </span><span class="koboSpan" id="kobo.707.2">After</span><a id="_idIndexMarker1429"/><span class="koboSpan" id="kobo.708.1"> that, we should write another</span><a id="_idIndexMarker1430"/><span class="koboSpan" id="kobo.709.1"> assertion</span><a id="_idIndexMarker1431"/><span class="koboSpan" id="kobo.710.1"> that the button does not show the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">submitting</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.713.1">
  it('the new comment editor should show a submitting
  class on submit', () =&gt; {
    cy.visit('/')
    // Get the editor to show
    cy.get('[data-test-id="new-comment-button"]')
      .click()
    cy.get('[data-test-id="new-comment-submit"]')
      .should('be.visible')
    cy.get('[data-test-id="new-comment-editor"]')
      .type('Just saying...')
    cy.get('[data-test-id="new-comment-submit"]')
      .should('not.be.disabled')
      .click()
      .should('have.class', 'submitting')
      .should('be.disabled')
      // eventually, the submitting class should be
         removed
    cy.get('[data-test-id="new-comment-submit"]')
      .should('not.have.class', 'submitting')
  })</span></pre>
<p><span class="koboSpan" id="kobo.714.1">Despite the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">2.5</span></strong><span class="koboSpan" id="kobo.716.1"> seconds during which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">submitting</span></strong><span class="koboSpan" id="kobo.718.1"> class is shown, this test still passes due to Cypress’ automatic </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">retry/wait functionality:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer345">
<span class="koboSpan" id="kobo.720.1"><img alt="Figure 12.15 – Cypress running add-new-comment tests, including the comment submission loading state test" src="image/Figure_12.15_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.721.1">Figure 12.15 – Cypress running add-new-comment tests, including the comment submission loading state test</span></p>
<p><span class="koboSpan" id="kobo.722.1">We’ve now</span><a id="_idIndexMarker1432"/><span class="koboSpan" id="kobo.723.1"> seen how</span><a id="_idIndexMarker1433"/><span class="koboSpan" id="kobo.724.1"> Cypress </span><a id="_idIndexMarker1434"/><span class="koboSpan" id="kobo.725.1">allows us to seamlessly work around asynchronicity in the application by automatically waiting/retrying where an assertion or selection </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">would fail.</span></span></p>
<h1 id="_idParaDest-263"><a id="_idTextAnchor473"/><span class="koboSpan" id="kobo.727.1">Intercepting HTTP requests</span></h1>
<p><span class="koboSpan" id="kobo.728.1">As mentioned in previous sections, Cypress</span><a id="_idIndexMarker1435"/><span class="koboSpan" id="kobo.729.1"> is designed as a JavaScript E2E testing solution. </span><span class="koboSpan" id="kobo.729.2">This means that it comes with built-ins such as assertions, automatic wait/retries, sane defaults for running the application, and extensive </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">mocking functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">HTTP requests can be slow and tend to introduce flaky behavior into tests. </span><span class="koboSpan" id="kobo.731.2">What’s meant by flaky is intermittent false negatives – that is, failures that are not caused by an application issue but rather by connectivity issues (for example, between the server running the tests and the </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">backend hosts).</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">We would also be testing</span><a id="_idIndexMarker1436"/><span class="koboSpan" id="kobo.734.1"> the implementation of the backend system. </span><span class="koboSpan" id="kobo.734.2">When using </span><strong class="bold"><span class="koboSpan" id="kobo.735.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.736.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.737.1">CI</span></strong><span class="koboSpan" id="kobo.738.1">), this would mean having to run the backend systems in whichever CI pipeline step needs to run </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">E2E tests.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">Usually, when the backend</span><a id="_idIndexMarker1437"/><span class="koboSpan" id="kobo.741.1"> requests are intercepted and a mock response is sent, we also say that the HTTP requests are </span><em class="italic"><span class="koboSpan" id="kobo.742.1">stubbed</span></em><span class="koboSpan" id="kobo.743.1"> in order to avoid tests flaking (meaning intermittent failures not linked to </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">application changes).</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">Seeing that the requests do not go all the way through the stack (including the backend API), this is technically not a full E2E test of the system anymore. </span><span class="koboSpan" id="kobo.745.2">We can, however, consider it an E2E test of the frontend application since the whole application is made up of separate exercises and is </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">not implementation-specific.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">In order to mock requests in Cypress, we’ll need to </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">cy.intercept()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">To showcase HTTP interception, we’ll fetch a list of comments from </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">JSONPlaceholder</span></strong><span class="koboSpan" id="kobo.753.1"> and store them under a </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">comments</span></strong><span class="koboSpan" id="kobo.755.1"> reactive instance variable. </span><span class="koboSpan" id="kobo.755.2">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">fetch</span></strong><span class="koboSpan" id="kobo.757.1"> to do this in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">mounted()</span></strong><span class="koboSpan" id="kobo.759.1"> life cycle event </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.761.1">
&lt;script&gt;
// imports
export default {
  data() {
    return {
      // other data properties
      comments: []
    }
  },
  mounted() {
    fetch('https://jsonplaceholder.typicode.com/comments')
      .then(res =&gt; res.json())
      .then(comments =&gt; {
        this.comments = comments
      })
  }
  // other component properties
}
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.762.1">A sample comment</span><a id="_idIndexMarker1438"/><span class="koboSpan" id="kobo.763.1"> includes an ID, a body, and an email, among </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">other properties.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">That means we can render the comments by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">div</span></strong><span class="koboSpan" id="kobo.767.1"> container, which only shows if there are comments (</span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">comments.length &gt; 0)</span></strong><span class="koboSpan" id="kobo.769.1">. </span><span class="koboSpan" id="kobo.769.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">div</span></strong><span class="koboSpan" id="kobo.771.1"> container, we can render a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">div</span></strong><span class="koboSpan" id="kobo.773.1"> elements using </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">v-for</span></strong><span class="koboSpan" id="kobo.775.1">. </span><span class="koboSpan" id="kobo.775.2">Each card will render the body of the comment and the author’s email inside a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">mailto:</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1"> link.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">Note how we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">comments-list</span></strong><span class="koboSpan" id="kobo.780.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">comment-card</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.782.1">data-test-ids</span></strong><span class="koboSpan" id="kobo.783.1"> for the list container and the list </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">items respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.785.1">
&lt;div v-if="comments.length &gt; 0" data-test-id="comments-list"&gt;
&lt;div v-for="(comment, index) in comments":key="comment.id + index"data-test-id="comment"&gt;
  &lt;p&gt;{{ comment.body }}&lt;/p&gt;
  &lt;p&gt;&lt;a :href="'mailto:' + comment.email"&gt;
    {{ comment.email }}&lt;/a&gt;
  &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.786.1">If we were to test this without HTTP interception, we would have to keep the assertions quite generic. </span><span class="koboSpan" id="kobo.786.2">For example, we can check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">comments-list</span></strong><span class="koboSpan" id="kobo.788.1"> is visible and that there</span><a id="_idIndexMarker1439"/><span class="koboSpan" id="kobo.789.1"> is a number (greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">0</span></strong><span class="koboSpan" id="kobo.791.1">) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">comment-card</span></strong><span class="koboSpan" id="kobo.793.1"> instances in a new E2E </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">test file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
describe('Loading Existing Comments', () =&gt; {
  it('should load &amp; display comments', () =&gt; {
    cy.visit('/')
    cy.get('[data-test-id="comments-list"]')
      .should('be.visible')
    cy.get('[data-test-id="comment-card"]')
      .should('have.length.gt', 0)
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.796.1">The following test run using the Cypress GUI passes but the tests are quite generic. </span><span class="koboSpan" id="kobo.796.2">We can’t make any assertions about the specific number of comments or </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">their content:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer346">
<span class="koboSpan" id="kobo.798.1"><img alt="Figure 12.16 – Cypress running load-comments tests, including a generic load and display test" src="image/Figure_12.16_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.799.1">Figure 12.16 – Cypress running load-comments tests, including a generic load and display test</span></p>
<p><span class="koboSpan" id="kobo.800.1">To intercept the request, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">cy.intercept</span></strong><span class="koboSpan" id="kobo.802.1">. </span><span class="koboSpan" id="kobo.802.2">It lets us define</span><a id="_idIndexMarker1440"/><span class="koboSpan" id="kobo.803.1"> a route and a static response – in our case, an array of comments. </span><span class="koboSpan" id="kobo.803.2">We’ll use a fictitious email address in </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">our stubs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.805.1">
it('should load and display comments correctly', () =&gt; {
  cy.intercept('**/comments', [
    {
      body: 'Vue is getting great adoption',
      email: 'evan@vuejs.org',
      id: 100,
    },
    {
      body: 'Just saying...',
      email: 'evan@vuejs.org',
      id: 10
    },
    {
      body: 'The JS ecosystem is great',
      email: 'evan@vuejs.org',
      id: 1
    }
  ]).as('getComments')
}</span></pre>
<p><span class="koboSpan" id="kobo.806.1">Once we’ve got our stub route</span><a id="_idIndexMarker1441"/><span class="koboSpan" id="kobo.807.1"> set up, we can visit the page and wait for the comment fetching to finish using </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">cy.wait('@getComments')</span></strong><span class="koboSpan" id="kobo.809.1">, since we’ve previously set the alias of the comments’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">fetch</span></strong><span class="koboSpan" id="kobo.811.1"> route to </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">getComments</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.813.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">.as('getComments')</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
describe('Loading Existing Comments', () =&gt; {
  // other tests
  it('should load and display comments correctly', () =&gt; {
    // test setup
    cy.visit('/')
    cy.wait('@getComments')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.817.1">We can then start asserting, first off, that </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">comments-list</span></strong><span class="koboSpan" id="kobo.819.1"> is visible, and then assert the number of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">comment-card</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.821.1"> elements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.822.1">
describe('Loading Existing Comments', () =&gt; {
  // other tests
  it('should load and display comments correctly', () =&gt; {
    // test setup
    cy.get('[data-test-id="comments-list"]')
      .should('be.visible')
    cy.get('[data-test-id="comment-card"]')
      .should('have.length', 3)
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.823.1">We can also assert the specific contents</span><a id="_idIndexMarker1442"/><span class="koboSpan" id="kobo.824.1"> of the cards using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">contains()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.827.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.828.1">
describe('Loading Existing Comments', () =&gt; {
  // other tests
  it('should load and display comments correctly', () =&gt; {
    // test setup
    cy.contains('[data-test-id="comment-card"]', 'Vue is
      getting great adoption').contains('evan@vuejs.org')
    cy.contains('[data-test-id="comment-card"]',
      'Just saying...').contains('evan@vuejs.org')
    cy.contains('[data-test-id="comment-card"]', 'The JS
      ecosystem is great').contains('evan@vuejs.org')
  })
})</span></pre>
<p><span class="koboSpan" id="kobo.829.1">We can then run the suite with the Cypress GUI and see </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">it passing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer347">
<span class="koboSpan" id="kobo.831.1"><img alt="Figure 12.17 – Cypress running load-comments tests, including our stubbed comments test" src="image/Figure_12.17_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.832.1">Figure 12.17 – Cypress running load-comments tests, including our stubbed comments test</span></p>
<p><span class="koboSpan" id="kobo.833.1">We’ve now seen how</span><a id="_idIndexMarker1443"/><span class="koboSpan" id="kobo.834.1"> and why we might stub HTTP requests </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">using Cypress.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor474"/><span class="koboSpan" id="kobo.836.1">Exercise 12.04 – POST comment to the API on submission</span></h2>
<p><span class="koboSpan" id="kobo.837.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">new-comment-submit</span></strong><span class="koboSpan" id="kobo.839.1"> button currently</span><a id="_idIndexMarker1444"/><span class="koboSpan" id="kobo.840.1"> only sets a </span><a id="_idIndexMarker1445"/><span class="koboSpan" id="kobo.841.1">loading state for a few seconds</span><a id="_idIndexMarker1446"/><span class="koboSpan" id="kobo.842.1"> and then resets – the comment is not actually being </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">sent anywhere.</span></span></p>
<p><span class="koboSpan" id="kobo.844.1">Let’s use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">JSONPlaceholder</span></strong><span class="koboSpan" id="kobo.846.1"> API as the place to send our new comment. </span><span class="koboSpan" id="kobo.846.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">POST</span></strong><span class="koboSpan" id="kobo.848.1"> request to the API succeeds, we’ll add the comment to the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">comment list.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">The complete code can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.04"><span class="No-Break"><span class="koboSpan" id="kobo.852.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Exercise12.04</span></span></a></p>
<p><span class="koboSpan" id="kobo.853.1">To complete the exercise, we will perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">following steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.855.1">Start by making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">submitNewComment</span></strong><span class="koboSpan" id="kobo.857.1"> method actually</span><a id="_idIndexMarker1447"/><span class="koboSpan" id="kobo.858.1"> post data using </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">fetch</span></strong><span class="koboSpan" id="kobo.860.1">. </span><span class="koboSpan" id="kobo.860.2">New comments </span><a id="_idIndexMarker1448"/><span class="koboSpan" id="kobo.861.1">require an email address, which our application doesn’t </span><a id="_idIndexMarker1449"/><span class="koboSpan" id="kobo.862.1">have, but we can set a fake email in our data </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">as well:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.864.1">
&lt;script&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.865.1">
// imports</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.866.1">
export default {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.867.1">
  // other component properties</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.868.1">
  data: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.869.1">
    // other data</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.870.1">
    email:'fakeemail@email.com'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.871.1">
  },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.872.1">
  methods: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.873.1">
    submitNewComment() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.874.1">
      this.isSubmitting = true</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.875.1">
  fetch('https://jsonplaceholder.typicode.com/comments  ', {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.876.1">
       method: 'POST',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.877.1">
       headers: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.878.1">
         'Content-Type': 'application/json'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.879.1">
       },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.880.1">
       body: JSON.stringify({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.881.1">
         email: this.email,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.882.1">
         body: this.newComment</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.883.1">
       })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.884.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.885.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.886.1">
  }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.887.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.888.1">
&lt;/script&gt;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.889.1">Unfortunately, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">fetch()</span></strong><span class="koboSpan" id="kobo.891.1"> call doesn’t update</span><a id="_idIndexMarker1450"/><span class="koboSpan" id="kobo.892.1"> the data by itself or come</span><a id="_idIndexMarker1451"/><span class="koboSpan" id="kobo.893.1"> out of the loading</span><a id="_idIndexMarker1452"/><span class="koboSpan" id="kobo.894.1"> state. </span><span class="koboSpan" id="kobo.894.2">In order to do so, we need to chain some </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">.then()</span></strong><span class="koboSpan" id="kobo.896.1"> function calls to handle the response, and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">.catch</span></strong><span class="koboSpan" id="kobo.898.1"> function call in case we have </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.900.1">On success (</span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">.then</span></strong><span class="koboSpan" id="kobo.902.1">), we should get the JSON output of the request and add it to the front of a copy of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">comments</span></strong><span class="koboSpan" id="kobo.904.1"> array. </span><span class="koboSpan" id="kobo.904.2">We should also reset </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">isSubmitting</span></strong><span class="koboSpan" id="kobo.906.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">newComment</span></strong><span class="koboSpan" id="kobo.908.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">showEditor</span></strong><span class="koboSpan" id="kobo.910.1">. </span><span class="koboSpan" id="kobo.910.2">On error (</span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">.catch</span></strong><span class="koboSpan" id="kobo.912.1">), we will just reset the loading state, </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">isSubmitting</span></strong><span class="koboSpan" id="kobo.914.1">, to </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">false</span></strong><span class="koboSpan" id="kobo.916.1">; we won’t clear the editor or close it since the user might want to try to submit </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">it again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.918.1">
&lt;script&gt;
// imports
export default {
  // other component properties
  methods: {
    submitNewComment() {
      this.isSubmitting = true
      fetch(
        // fetch params
      ).then(res =&gt; res.json())
       .then(data =&gt; {
          this.comments = [
          data,
          ...this.comments,
          ]
          this.isSubmitting = false
          this.newComment = ''
       })
       .catch(() =&gt; {
          this.isSubmitting = false
       })
    }
  }
}
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.919.1">We should now add new tests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">cypress/e22/add-new-comment.js</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.921.1">test suite.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.922.1">First of all, to be good users</span><a id="_idIndexMarker1453"/><span class="koboSpan" id="kobo.923.1"> of the JSON</span><a id="_idIndexMarker1454"/><span class="koboSpan" id="kobo.924.1"> placeholder, we’ll stub out all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">GET</span></strong><span class="koboSpan" id="kobo.926.1"> requests</span><a id="_idIndexMarker1455"/><span class="koboSpan" id="kobo.927.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">/comments</span></strong><span class="koboSpan" id="kobo.929.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">add-new-comment</span></strong><span class="koboSpan" id="kobo.931.1"> suite. </span><span class="koboSpan" id="kobo.931.2">In order to do this, we’ll use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">beforeEach</span></strong><span class="koboSpan" id="kobo.933.1"> hook that will intercept requests matching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">**/comments</span></strong><span class="koboSpan" id="kobo.935.1"> glob and return an </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">empty array:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.937.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.938.1">
  beforeEach(() =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.939.1">
    cy.intercept('GET','**/comments', []);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.940.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.941.1">
  // tests</span></pre></li>
<li><span class="koboSpan" id="kobo.942.1">We can then proceed</span><a id="_idIndexMarker1456"/><span class="koboSpan" id="kobo.943.1"> to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">the new comment editor should show a submitting class on submit</span></strong><span class="koboSpan" id="kobo.945.1"> test since</span><a id="_idIndexMarker1457"/><span class="koboSpan" id="kobo.946.1"> we’re not using </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">setTimeout</span></strong><span class="koboSpan" id="kobo.948.1"> anymore </span><a id="_idIndexMarker1458"/><span class="koboSpan" id="kobo.949.1">but an HTTP request. </span><span class="koboSpan" id="kobo.949.2">To start with, we need to stub out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">/comments</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.951.1">POST</span></strong><span class="koboSpan" id="kobo.952.1"> request, for which we’ll use the configuration object syntax for </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">cy.intercept</span></strong><span class="koboSpan" id="kobo.954.1"> in order to introduce a delay into the HTTP request so that it doesn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">respond immediately.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.956.1">We alias this request </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">.as('newComment')</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.960.1">
it('the new comment editor should show a submitting class on submit', () =&gt; {
  cy.intercept('POST', '**/comments', (req) =&gt; {
    req.reply({
      delay: 1500, response: {}
  });
}).as('newComment');</span></pre>
<ol>
<li value="4"><span class="koboSpan" id="kobo.961.1">Instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">// eventually, the submitting class should be removed</span></strong><span class="koboSpan" id="kobo.963.1">, we can now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">cy.wait()</span></strong><span class="koboSpan" id="kobo.965.1"> to wait for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">newComment</span></strong><span class="koboSpan" id="kobo.967.1"> HTTP request to complete before checking that the spinner </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">is gone:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.969.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.970.1">
  // setup &amp; tests</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.971.1">
  it('the new comment editor should show a spinner on</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.972.1">
  submit', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.973.1">
    // test setup</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.974.1">
    // click the "submit" button</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.975.1">
    // check the submitting class appears</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.976.1">
    cy.wait('@newComment')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.977.1">
    // check that the submitting class is gone</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.978.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.979.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.980.1">Upon successfully</span><a id="_idIndexMarker1459"/><span class="koboSpan" id="kobo.981.1"> posting a new comment, the comment</span><a id="_idIndexMarker1460"/><span class="koboSpan" id="kobo.982.1"> text is cleared. </span><span class="koboSpan" id="kobo.982.2">We</span><a id="_idIndexMarker1461"/><span class="koboSpan" id="kobo.983.1"> should test that this happens when a comment is posted. </span><span class="koboSpan" id="kobo.983.2">We’ll use a similar skeleton to the updated loading state test, with the setup of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">POST</span></strong><span class="koboSpan" id="kobo.985.1"> comments route stubbing </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">cy.intercept('POST', '**/comments', {}</span></strong><span class="koboSpan" id="kobo.987.1">, aliased </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">as .</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">as('newComment')</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.991.1">We can then get the new comment editor to display, add some text, and submit the form. </span><span class="koboSpan" id="kobo.991.2">We’ll then proceed to wait for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">POST</span></strong><span class="koboSpan" id="kobo.993.1"> request to complete before checking that the comment has </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">been cleared:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.995.1">
    it('adding a new comment should clear the comment
    text', () =&gt; {
      cy.intercept('POST', '**/comments', {
        body: {
          body: 'Just saying...',
          email: 'hi@raymondcamden.com'
        }
      }).as('newComment');
      cy.visit('/')
      // Get the editor to show
      cy.get('[data-test-id="new-comment-button"]')
        .click()
      cy.get('[data-test-id="new-comment-submit"]')
        .should('be.visible')
      cy.get('[data-test-id="new-comment-editor"]')
        .type('Just saying...')
      cy.get('[data-test-id="new-comment-submit"]')
        .should('not.be.disabled')
        .click()
      cy.wait('@newComment');
      cy.get('[data-test-id="new-comment-editor"]')
        .should('have.value','')
    });</span></pre>
<p><span class="koboSpan" id="kobo.996.1">This </span><a id="_idIndexMarker1462"/><span class="koboSpan" id="kobo.997.1">test</span><a id="_idIndexMarker1463"/><span class="koboSpan" id="kobo.998.1"> can now be run with the Cypress GUI</span><a id="_idIndexMarker1464"/><span class="koboSpan" id="kobo.999.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">will pass:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer348">
<span class="koboSpan" id="kobo.1001.1"><img alt="Figure 12.18 – Cypress running add-new-comment tests, including the editor comment text being cleared" src="image/Figure_12.18_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1002.1">Figure 12.18 – Cypress running add-new-comment tests, including the editor comment text being cleared</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1003.1">The second bit of functionality</span><a id="_idIndexMarker1465"/><span class="koboSpan" id="kobo.1004.1"> that we’ve added</span><a id="_idIndexMarker1466"/><span class="koboSpan" id="kobo.1005.1"> is that on completion of the HTTP request, the </span><a id="_idIndexMarker1467"/><span class="koboSpan" id="kobo.1006.1">new comment is added to the top of the comments list. </span><span class="koboSpan" id="kobo.1006.2">To test this, it’s better to change the response of the comments’ </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">GET</span></strong><span class="koboSpan" id="kobo.1008.1"> request to have at least one element (so that we can check that the new comment is added to the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">the list):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1010.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1011.1">
  // setup &amp; other tests</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1012.1">
  it('submitting a new comment should POST to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
  /comments and adds response to top of comments</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1014.1">
  list', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1015.1">
    cy.intercept('GET', '**/comments', [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1016.1">
      {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1017.1">
        email: 'evan@vuejs.org',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
        body: 'Existing comment'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
      }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
    ]).as('newComment')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.1023.1">We can then stub the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">POST</span></strong><span class="koboSpan" id="kobo.1025.1"> request with</span><a id="_idIndexMarker1468"/><span class="koboSpan" id="kobo.1026.1"> some mock data, add text</span><a id="_idIndexMarker1469"/><span class="koboSpan" id="kobo.1027.1"> to the</span><a id="_idIndexMarker1470"/><span class="koboSpan" id="kobo.1028.1"> editor, and submit </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">the form:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1030.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
  // setup &amp; other tests</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
  it('submitting a new comment should POST to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1033.1">
  /comments and adds response to top of comments</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
  list', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
    // GET request stubbing</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
    cy.intercept({</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
      method: 'POST',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1038.1">
      url: '**/comments',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1039.1">
      response: {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1040.1">
        email: 'evan@vuejs.org',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1041.1">
        body: 'Just saying...',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1042.1">
      },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1043.1">
    }).as('newComment')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1044.1">
    cy.visit('/')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
    cy.get('[data-test-id="comment-card"]').should</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
      ('have.length', 1)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1047.1">
    cy.get('[data-test-id="new-comment-button"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1048.1">
      .click()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1049.1">
    cy.get('[data-test-id="new-comment-editor"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1050.1">
      .type('Just saying...')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
    cy.get('[data-test-id="new-comment-submit"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
      .should('not.be.disabled')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
      .click()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1054.1">
    cy.wait('@newComment')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
})</span></pre></li>
<li><span class="koboSpan" id="kobo.1057.1">Finally, we can assert</span><a id="_idIndexMarker1471"/><span class="koboSpan" id="kobo.1058.1"> the fact that the first comment</span><a id="_idIndexMarker1472"/><span class="koboSpan" id="kobo.1059.1"> is the newly added comment</span><a id="_idIndexMarker1473"/><span class="koboSpan" id="kobo.1060.1"> using a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1062.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">.first()</span></strong><span class="koboSpan" id="kobo.1064.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">.contains()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1068.1">
describe('Adding a New Comment', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
  // setup &amp; other tests</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1070.1">
  it('submitting a new comment should POST to</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1071.1">
  /comments and adds response to top of comments</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1072.1">
  list', () =&gt; {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1073.1">
    // setup &amp; wait for POST completion</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1074.1">
    cy.get('[data-test-id="comments-list"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1075.1">
      .should('be.visible')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
    cy.get('[data-test-id="comment-card"]')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1077.1">
      .should('have.length', 2).first()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1078.1">
      .contains('[data-test-id="comment-card"]',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1079.1">
      'Just saying...')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
      .contains('fakeemail@email.com')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1081.1">
  })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1082.1">
})</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1083.1">When running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">add-new-comment</span></strong><span class="koboSpan" id="kobo.1085.1"> suite with the Cypress</span><a id="_idIndexMarker1474"/><span class="koboSpan" id="kobo.1086.1"> GUI, we</span><a id="_idIndexMarker1475"/><span class="koboSpan" id="kobo.1087.1"> can see the new</span><a id="_idIndexMarker1476"/> <span class="No-Break"><span class="koboSpan" id="kobo.1088.1">test passing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer349">
<span class="koboSpan" id="kobo.1089.1"><img alt="Figure 12.19 – Cypress running add-new-comment tests, including the new comment added to the top of the list test" src="image/Figure_12.19_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1090.1">Figure 12.19 – Cypress running add-new-comment tests, including the new comment added to the top of the list test</span></p>
<p><span class="koboSpan" id="kobo.1091.1">You’ve now seen how</span><a id="_idIndexMarker1477"/><span class="koboSpan" id="kobo.1092.1"> to handle network operations</span><a id="_idIndexMarker1478"/><span class="koboSpan" id="kobo.1093.1"> in your testing. </span><span class="koboSpan" id="kobo.1093.2">As most applications make </span><a id="_idIndexMarker1479"/><span class="koboSpan" id="kobo.1094.1">use of some sort of API call, this will be tremendously helpful in ensuring your tests cover as much ground </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">as possible.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor475"/><span class="koboSpan" id="kobo.1096.1">Activity 12.01 – adding the ability to set a user’s email and test</span></h2>
<p><span class="koboSpan" id="kobo.1097.1">You’ll remember</span><a id="_idIndexMarker1480"/><span class="koboSpan" id="kobo.1098.1"> that we’ve</span><a id="_idIndexMarker1481"/><span class="koboSpan" id="kobo.1099.1"> hardcoded </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">fakeemail@email.com</span></strong><span class="koboSpan" id="kobo.1101.1"> as the email for any comments. </span><span class="koboSpan" id="kobo.1101.2">What we’ll do in this </span><a id="_idIndexMarker1482"/><span class="koboSpan" id="kobo.1102.1">activity is add an email input that will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">email</span></strong><span class="koboSpan" id="kobo.1104.1"> property on comments. </span><span class="koboSpan" id="kobo.1104.2">We’ll add the relevant tests in a new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">cypress/e2e/enter-email.cy.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1"> suite:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1107.1">In order to keep track of the email, we’ll set it as a piece of reactive state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">data()</span></strong><span class="koboSpan" id="kobo.1109.1"> and add an email input to the page, which will be two-way bound to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">email</span></strong><span class="koboSpan" id="kobo.1111.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">v-model</span></strong><span class="koboSpan" id="kobo.1113.1">. </span><span class="koboSpan" id="kobo.1113.2">We also add a label and corresponding markup. </span><span class="koboSpan" id="kobo.1113.3">Note that we’ll have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1115.1"> attribute on the email input set </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">email-input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1119.1">We’ll now add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">beforeEach</span></strong><span class="koboSpan" id="kobo.1121.1"> hook to have Cypress intercept and stub out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">GET</span></strong><span class="koboSpan" id="kobo.1123.1"> comments (list) request. </span><span class="koboSpan" id="kobo.1123.2">The comments list request should be aliased </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">getComments</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1127.1">We’ll add our first test, which checks whether typing into the email input works correctly. </span><span class="koboSpan" id="kobo.1127.2">We’ll go to the app, type an email, and check that what we typed is now the </span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">input value.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1129.1">When it is run using the Cypress UI, we should get the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">passing test:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer350">
<span class="koboSpan" id="kobo.1131.1"><img alt="Figure 12.20 – Cypress running enter-email tests with the email input test" src="image/Figure_12.20_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1132.1">Figure 12.20 – Cypress running enter-email tests with the email input test</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1133.1">Having the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">email</span></strong><span class="koboSpan" id="kobo.1135.1"> property</span><a id="_idIndexMarker1483"/><span class="koboSpan" id="kobo.1136.1"> is a pre-requisite to adding</span><a id="_idIndexMarker1484"/><span class="koboSpan" id="kobo.1137.1"> comments, so we’ll disable the </span><strong class="bold"><span class="koboSpan" id="kobo.1138.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.1139.1"> button</span><a id="_idIndexMarker1485"/><span class="koboSpan" id="kobo.1140.1"> while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">email</span></strong><span class="koboSpan" id="kobo.1142.1"> is empty (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">!email</span></strong><span class="koboSpan" id="kobo.1144.1">). </span><span class="koboSpan" id="kobo.1144.2">We’ll bind to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">disabled</span></strong><span class="koboSpan" id="kobo.1146.1"> attribute based on whether or not the email field </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">is populated.</span></span></li>
<li><span class="koboSpan" id="kobo.1148.1">With this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">disable add new comment button while email is empty</span></strong><span class="koboSpan" id="kobo.1150.1"> functionality, we should add a new E2E test. </span><span class="koboSpan" id="kobo.1150.2">We’ll load up the page and on initial load, we’ll check that the email input is empty and that the </span><strong class="bold"><span class="koboSpan" id="kobo.1151.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.1152.1"> button is disabled. </span><span class="koboSpan" id="kobo.1152.2">We’ll then type an email into the email input field and check that the </span><strong class="bold"><span class="koboSpan" id="kobo.1153.1">Add a New Comment</span></strong><span class="koboSpan" id="kobo.1154.1"> button is now </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">not</span></strong><span class="koboSpan" id="kobo.1156.1"> disabled, which means it </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">is enabled.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1158.1">When run using the Cypress UI, we should see the new test passing with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">following output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer351">
<span class="koboSpan" id="kobo.1160.1"><img alt="Figure 12.21 – Cypress running enter-email﻿ tests with the disabled add comment button test" src="image/Figure_12.21_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1161.1">Figure 12.21 – Cypress running enter-email tests with the disabled add comment button test</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1162.1">Now that we’ve got</span><a id="_idIndexMarker1486"/><span class="koboSpan" id="kobo.1163.1"> a way to capture the email, we should </span><a id="_idIndexMarker1487"/><span class="koboSpan" id="kobo.1164.1">pass</span><a id="_idIndexMarker1488"/><span class="koboSpan" id="kobo.1165.1"> it to the backend API when making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">POST</span></strong><span class="koboSpan" id="kobo.1167.1"> comments call (that is, when submitting a new comment). </span><span class="koboSpan" id="kobo.1167.2">In order to do this, we should modify the spot in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">methods.submitNewComment</span></strong><span class="koboSpan" id="kobo.1169.1"> where the email is hardcoded </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">fakeemail@email.com</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1173.1">Now that we’re using the email that’s been input by the user, we should write an E2E test to check that it’s being sent. </span><span class="koboSpan" id="kobo.1173.2">We’ll stub out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">POST</span></strong><span class="koboSpan" id="kobo.1175.1"> request, alias it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">newComment</span></strong><span class="koboSpan" id="kobo.1177.1">, and send back an arbitrary value. </span><span class="koboSpan" id="kobo.1177.2">We can then visit the page, fill out the email input, open the comment editor, fill that out, and submit it. </span><span class="koboSpan" id="kobo.1177.3">We’ll then wait on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">newComment</span></strong><span class="koboSpan" id="kobo.1179.1"> request and assert in the request body that the body and email are as they were when we </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">completed them.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.1181.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1182.1">We could also opt to not stub out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">POST</span></strong><span class="koboSpan" id="kobo.1184.1"> request and instead check that the new comment inserted on the page contains the right email </span><span class="No-Break"><span class="koboSpan" id="kobo.1185.1">and body.</span></span></p>
<p><span class="koboSpan" id="kobo.1186.1">When run using the Cypress</span><a id="_idIndexMarker1489"/><span class="koboSpan" id="kobo.1187.1"> UI, we get</span><a id="_idIndexMarker1490"/><span class="koboSpan" id="kobo.1188.1"> the following test </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">run</span></span><span class="No-Break"><a id="_idIndexMarker1491"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1"> output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer352">
<span class="koboSpan" id="kobo.1191.1"><img alt="Figure 12.22 – Cypress running enter-email tests with the email input test" src="image/Figure_12.22_B18645.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1192.1">Figure 12.22 – Cypress running enter-email tests with the email input test</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1193.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1194.1">The solution for </span><a id="_idTextAnchor476"/><span class="koboSpan" id="kobo.1195.1">this activity can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">at </span></span><a href="https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Activity12.01"><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter12/Activity12.01</span></span></a></p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor477"/><span class="koboSpan" id="kobo.1198.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1199.1">Throughout this chapter, we’ve looked at leveraging Cypress to test Vue.js applications E2E. </span><span class="koboSpan" id="kobo.1199.2">E2E tests in general are useful to give us a high level of confidence that tested flows will work as expected, as opposed to unit or integration tests, which validate that our code works as expected at a much </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">lower overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.1201.1">We’ve seen how to use Cypress to inspect, interact with, and assert against a UI. </span><span class="koboSpan" id="kobo.1201.2">We’ve also shown how Cypress’ default wait/retry functionality is a great advantage when writing robust tests. </span><span class="koboSpan" id="kobo.1201.3">We leveraged Cypress’ HTTP interception library to stub out HTTP requests and make tests more predictable </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">and faster.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">Finally, we looked at how to set up visual regression testing with Cypress. </span><span class="koboSpan" id="kobo.1203.2">In the next chapter, we’ll look at how to deploy a Vue.js application to </span><span class="No-Break"><span class="koboSpan" id="kobo.1204.1">the web.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer354">
</div>
</div>
</body></html>